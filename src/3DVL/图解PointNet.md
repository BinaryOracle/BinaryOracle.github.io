---
icon: file
category:
  - 3D-VL
tag:
  - 3D-VL
  - point cloud
  - 编辑中
footer: 技术共建，知识共享
date: 2025-05-25
cover: assets/cover/PointNet.png
author:
  - BinaryOracle
---

`图解PointNet` 

<!-- more -->

# 图解PointNet

> 论文: [https://arxiv.org/abs/1612.00593](https://arxiv.org/abs/1612.00593)
> TensorFlow 版本代码: [https://github.com/charlesq34/pointnet](https://github.com/charlesq34/pointnet)
> Pytorch 版本代码: [https://github.com/fxia22/pointnet.pytorch](https://github.com/fxia22/pointnet.pytorch)

## 核心

问题背景: 点云是三维几何数据的一种重要表示形式，但由于其无序性和非规则性，传统卷积神经网络难以直接处理。

❌ 传统方法的缺陷 ：

- 将点云转换为体素网格（voxel grid）或图像视图（multi-view rendering）， 这些方法会导致信息损失、计算量大、不灵活等问题。

🌟 PointNet 的创新点 ：

- 直接以点集作为输入，避免了复杂的预处理；

- 设计了一个统一架构，适用于分类、物体分割和场景语义解析；

- 利用对称函数（如最大池化）实现点集顺序不变性；

- 引入 T-Net（空间变换网络）标准化输入点云和特征空间。

## 难点

1. 点云的无序性（Unordered）: 点云是点的集合，没有固定顺序；模型必须对输入点的排列顺序不敏感（permutation invariant）。

2. 点之间存在相互作用（Interaction among points）: 点与点之间有空间关系，需要捕捉局部结构。

3. 对几何变换的不变性（Invariance under transformations）: 模型输出应不受刚性变换影响（如旋转、平移）。

4. 输入点云可能缺失或包含噪声（Missing or noisy points）: 实际采集的点云常有遮挡、稀疏、异常值等问题。

## 解决方案

✅ 难点 1：点云的无序性 → **使用对称函数（Symmetric Function）**

- 使用 **max pooling** 作为对称函数，聚合所有点的信息；

- 所有点经过共享参数的 MLP 提取特征；

- 最终输出与点的顺序无关；

原理说明：

```python
f({x1, ..., xn}) ≈ g(h(x1), ..., h(xn)) = γ(MAX(h(x1), ..., h(xn)))
```

其中：

- `h(xi)` 是每个点的高维特征；

- `MAX` 是 max pooling 函数；

- `γ` 是后续的全连接网络；

- 整个函数 f 是对称的，即对点顺序不敏感。

效果：

- 实验证明 max pooling 比排序、RNN、average pooling 更有效；

- PointNet 可以处理任意顺序的点集；

---

✅ 难点 2：点之间的相互作用 → **设计局部 + 全局信息融合机制**

- 在分割任务中，将全局特征与每个点的局部特征拼接起来；

- 这样每个点在预测标签时都能看到整个物体的上下文；


效果：

- 显著提升了分割性能；

- 让模型既关注局部细节，又理解整体结构；

---

✅ 难点 3：对几何变换的不变性 → **引入 T-Net（空间变换网络）**

- 引入两个空间变换网络：

  - **STN3d**：对输入点云做刚性变换（3×3 矩阵）；

  - **STNkd**：对特征空间做变换（64×64 矩阵）；

- 加入正则项约束变换矩阵接近正交：

```python
L_reg = ||I - A @ A^T||_F^2
```

效果：

- PointNet 对点云的旋转、平移等变换具有鲁棒性；

- 提升了模型的泛化能力和稳定性；

---

✅ 难点 4：输入点云可能缺失或含有异常点 → **理论分析保证模型鲁棒性**

- 理论上证明 PointNet 学到的是一个“关键点集”（critical point set），即只依赖一小部分关键点就能判断整体形状；

- 即使丢失一些点或加入异常点，只要关键点还在，结果就不会变；

定理表明：

- 小扰动不会改变函数输出；

- 网络输出由一个有限子集 CS 决定（大小不超过 bottleneck 维度 K）；

- CS 是关键点集合，NS 是最大可容忍的点云范围；

实验验证：

- 即使 50% 的点缺失，分类准确率仅下降约 3.7%；

- 对异常点也有一定容忍能力；

---
✅ 总结: **PointNet 通过 max pooling 实现对称性，结合 T-Net 实现变换不变性，并通过局部+全局特征融合机制实现强大的点云建模能力，解决了点云处理中的四大技术难点，为后续三维深度学习奠定了基础。**





## 背景知识扫盲(可选)

### 点云

点云: 是一种表示三维空间中物体或场景的方式，它由大量带有位置信息的点组成。 

每个点通常包含：
- 坐标信息 ：x, y, z（3D 空间中的位置）。
- 可选属性：颜色（RGB）、法向量（Normal）、强度（Intensity）、时间戳等。

表示形式:
- 点云（Point Cloud）: 原始点集合：每个点有(x, y, z)坐标; 可选颜色、法向量等属性, 简洁、轻便; 保留原始几何信息,无序性、非结构化、难以用 CNN 处理。

- 体素网格 (voxel grids) : 将空间划分成立方体格子，每个格子表示是否有物体; 结构规整，适合 3D CNN; 计算复杂度高、稀疏性强、精度受限。

- 多视角图像（Multi-View Images）: 从多个角度渲染点云或 3D 模型为 2D 图像; 可使用成熟的 2D CNN 方法; 丢失部分几何信息，依赖视角选择。

- 网格（Mesh）： 由三角形面片组成的 3D 模型； 包含表面细节，适合渲染； 难以自动构建，拓扑复杂。


### 对称函数

对称函数（Symmetric Function）是一种对输入顺序不敏感的函数；换句话说，无论你如何打乱输入元素的顺序，输出结果都保持不变。

🧠 **数学定义:**

设$f(x_1, x_2, ..., x_n)$是一个函数，如果对于任意排列$\sigma$（permutation），都有：

$$
f(x_1, x_2, ..., x_n) = f(x_{\sigma(1)}, x_{\sigma(2)}, ..., x_{\sigma(n)})
$$

那么$f$就是一个 **对称函数**。

PointNet 处理的是点云数据，而点云是无序集合（unordered set） ，即：

- 点云中点的顺序不影响整体形状。

- 所以模型必须具有对点顺序的不变性（permutation invariance）。

- 这就要求网络中的某些关键操作必须是对称函数 ，才能保证整个网络输出与输入点的顺序无关。


📦 常见的对称函数:

| 函数 | 描述 | 是否可微 | 应用场景 |
|------|------|----------|-----------|
| **最大池化（Max Pooling）** | 取所有点的最大值：$\max(x_1, x_2, ..., x_n)$| ✅ 是 | PointNet 中的核心操作 |
| **平均池化（Average Pooling）** | 取所有点的平均值：$\frac{1}{n}\sum_{i=1}^{n} x_i$| ✅ 是 | 特征融合、平滑处理 |
| **求和（Summation）** | 所有点相加：$\sum x_i$| ✅ 是 | 构建全局特征向量 |
| **乘积（Product）** | 所有点相乘：$\prod x_i$| ⚠️ 对数值变化敏感 | 不常用，但可用于特定任务 |
| **最小池化（Min Pooling）** | 取最小值：$\min(x_1, x_2, ..., x_n)$| ✅ 是 | 异常检测等特殊场景 |
| **Softmax + 加权和（Attention-based Sum）** | 根据注意力机制加权求和，权重由 softmax 得出 | ✅ 是 | DGCNN、Transformer 中使用 |
| **统计量（如方差、标准差）** | 计算点集的分布特性 | ✅ 是 | 特征增强、异常检测 |
| **集合函数近似器（如 Deep Sets）** | 使用神经网络直接学习对称函数 | ✅ 是 | 更复杂的对称函数建模 |

