/**
* @vue/shared v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/const Se={},ze=()=>{},Ce=Object.assign,Oe=Array.isArray,D=e=>typeof e=="function",Me=e=>typeof e=="string",Ne=e=>typeof e=="symbol";let X;const L=()=>X||(X=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{});/**
* @vue/reactivity v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/new Set(Object.getOwnPropertyNames(Symbol).filter(e=>e!=="arguments"&&e!=="caller").map(e=>Symbol[e]).filter(Ne));function P(e){const t=e&&e.__v_raw;return t?P(t):e}function Te(e){return e?e.__v_isRef===!0:!1}/**
* @vue/runtime-core v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/const v=[];function kt(e){v.push(e)}function It(){v.pop()}let W=!1;function Et(e,...t){if(W)return;W=!0;const n=v.length?v[v.length-1].component:null,o=n&&n.appContext.config.warnHandler,s=Fe();if(o)A(o,n,11,[e+t.map(r=>{var i,c;return(c=(i=r.toString)==null?void 0:i.call(r))!=null?c:JSON.stringify(r)}).join(""),n&&n.proxy,s.map(({vnode:r})=>`at <${re(n,r.type)}>`).join(`
`),s]);else{const r=[`[Vue warn]: ${e}`,...t];s.length&&r.push(`
`,...$e(s)),console.warn(...r)}W=!1}function Fe(){let e=v[v.length-1];if(!e)return[];const t=[];for(;e;){const n=t[0];n&&n.vnode===e?n.recurseCount++:t.push({vnode:e,recurseCount:0});const o=e.component&&e.component.parent;e=o&&o.vnode}return t}function $e(e){const t=[];return e.forEach((n,o)=>{t.push(...o===0?[]:[`
`],...Ve(n))}),t}function Ve({vnode:e,recurseCount:t}){const n=t>0?`... (${t} recursive calls)`:"",o=e.component?e.component.parent==null:!1,s=` at <${re(e.component,e.type,o)}`,r=">"+n;return e.props?[s,...Re(e.props),r]:[s+r]}function Re(e){const t=[],n=Object.keys(e);return n.slice(0,3).forEach(o=>{t.push(...Z(o,e[o]))}),n.length>3&&t.push(" ..."),t}function Z(e,t,n){return Me(t)?(t=JSON.stringify(t),n?t:[`${e}=${t}`]):typeof t=="number"||typeof t=="boolean"||t==null?n?t:[`${e}=${t}`]:Te(t)?(t=Z(e,P(t.value),!0),n?t:[`${e}=Ref<`,t,">"]):D(t)?[`${e}=fn${t.name?`<${t.name}>`:""}`]:(t=P(t),n?t:[`${e}=`,t])}const vt={sp:"serverPrefetch hook",bc:"beforeCreate hook",c:"created hook",bm:"beforeMount hook",m:"mounted hook",bu:"beforeUpdate hook",u:"updated",bum:"beforeUnmount hook",um:"unmounted hook",a:"activated hook",da:"deactivated hook",ec:"errorCaptured hook",rtc:"renderTracked hook",rtg:"renderTriggered hook",0:"setup function",1:"render function",2:"watcher getter",3:"watcher callback",4:"watcher cleanup function",5:"native event handler",6:"component event handler",7:"vnode hook",8:"directive hook",9:"transition hook",10:"app errorHandler",11:"app warnHandler",12:"ref function",13:"async component loader",14:"scheduler flush",15:"component update",16:"app unmount cleanup function"};function A(e,t,n,o){try{return o?e(...o):e()}catch(s){ee(s,t,n)}}function ee(e,t,n,o=!0){const s=t?t.vnode:null,{errorHandler:r,throwUnhandledErrorInProduction:i}=t&&t.appContext.config||Se;if(t){let c=t.parent;const l=t.proxy,u=`https://vuejs.org/error-reference/#runtime-${n}`;for(;c;){const a=c.ec;if(a){for(let h=0;h<a.length;h++)if(a[h](e,l,u)===!1)return}c=c.parent}if(r){A(r,null,10,[e,l,u]);return}}je(e,n,s,o,i)}function je(e,t,n,o=!0,s=!1){if(s)throw e;console.error(e)}const b=[];let x=-1;const S=[];let k=null,z=0;const De=Promise.resolve();let q=null;const Le=100;function Pe(e){let t=x+1,n=b.length;for(;t<n;){const o=t+n>>>1,s=b[o],r=M(s);r<e||r===e&&s.flags&2?t=o+1:n=o}return t}function We(e){if(!(e.flags&1)){const t=M(e),n=b[b.length-1];!n||!(e.flags&2)&&t>=M(n)?b.push(e):b.splice(Pe(t),0,e),e.flags|=1,te()}}function te(){q||(q=De.then(ne))}function Ae(e){Oe(e)?S.push(...e):k&&e.id===-1?k.splice(z+1,0,e):e.flags&1||(S.push(e),e.flags|=1),te()}function qe(e){if(S.length){const t=[...new Set(S)].sort((n,o)=>M(n)-M(o));if(S.length=0,k){k.push(...t);return}for(k=t,z=0;z<k.length;z++){const n=k[z];n.flags&4&&(n.flags&=-2),n.flags&8||n(),n.flags&=-2}k=null,z=0}}const M=e=>e.id==null?e.flags&2?-1:1/0:e.id;function ne(e){const t=ze;try{for(x=0;x<b.length;x++){const n=b[x];n&&!(n.flags&8)&&(n.flags&4&&(n.flags&=-2),A(n,n.i,n.i?15:14),n.flags&4||(n.flags&=-2))}}finally{for(;x<b.length;x++){const n=b[x];n&&(n.flags&=-2)}x=-1,b.length=0,qe(e),q=null,(b.length||S.length)&&ne(e)}}function St(e,t){const n=e.get(t)||0;if(n>Le){const o=t.i,s=o&&se(o.type);return ee(`Maximum recursive updates exceeded${s?` in component <${s}>`:""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,null,10),!0}return e.set(t,n+1),!1}const H=new Map,F=new Map;function zt(e,t){return F.has(e)?!1:(F.set(e,{initialDef:$(t),instances:new Set}),!0)}function $(e){return Je(e)?e.__vccOpts:e}function Ct(e,t){const n=F.get(e);n&&(n.initialDef.render=t,[...n.instances].forEach(o=>{t&&(o.render=t,$(o.type).render=t),o.renderCache=[],o.update()}))}function Ot(e,t){const n=F.get(e);if(!n)return;t=$(t),oe(n.initialDef,t);const o=[...n.instances];for(let s=0;s<o.length;s++){const r=o[s],i=$(r.type);let c=H.get(i);c||(i!==n.initialDef&&oe(i,t),H.set(i,c=new Set)),c.add(r),r.appContext.propsCache.delete(r.type),r.appContext.emitsCache.delete(r.type),r.appContext.optionsCache.delete(r.type),r.ceReload?(c.add(r),r.ceReload(t.styles),c.delete(r)):r.parent?We(()=>{r.parent.update(),c.delete(r)}):r.appContext.reload?r.appContext.reload():typeof window<"u"?window.location.reload():console.warn("[HMR] Root or manually mounted instance modified. Full reload required."),r.root.ce&&r!==r.root&&r.root.ce._removeChildStyle(i)}Ae(()=>{H.clear()})}function oe(e,t){Ce(e,t);for(const n in e)n!=="__file"&&!(n in t)&&delete e[n]}function Mt(e){return(t,n)=>{try{return e(t,n)}catch(o){console.error(o),console.warn("[HMR] Something went wrong during Vue component hot-reload. Full reload required.")}}}L().requestIdleCallback,L().cancelIdleCallback;const Nt={};{const e=L(),t=(n,o)=>{let s;return(s=e[n])||(s=e[n]=[]),s.push(o),r=>{s.length>1?s.forEach(i=>i(r)):s[0](r)}};t("__VUE_INSTANCE_SETTERS__",n=>n),t("__VUE_SSR_SETTERS__",n=>n)}const He=/(?:^|[-_])(\w)/g,Ue=e=>e.replace(He,t=>t.toUpperCase()).replace(/[-_]/g,"");function se(e,t=!0){return D(e)?e.displayName||e.name:e.name||t&&e.__name}function re(e,t,n=!1){let o=se(t);if(!o&&t.__file){const s=t.__file.match(/([^/\\]+)\.\w+$/);s&&(o=s[1])}if(!o&&e&&e.parent){const s=r=>{for(const i in r)if(r[i]===t)return i};o=s(e.components||e.parent.type.components)||s(e.appContext.components)}return o?Ue(o):n?"App":"Anonymous"}function Je(e){return D(e)&&"__vccOpts"in e}[...new Array(6)].map((e,t)=>`[vp-content] h${t+1}`).join(",");const{entries:Ge}=Object,{fromEntries:Be}=Object,Ye="ENTRIES",ie="KEYS",ce="VALUES",y="";class U{set;_type;_path;constructor(t,n){const o=t._tree,s=Array.from(o.keys());this.set=t,this._type=n,this._path=s.length>0?[{node:o,keys:s}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:n}=C(this._path);if(C(n)===y)return{done:!1,value:this.result()};const o=t.get(C(n));return this._path.push({node:o,keys:Array.from(o.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=C(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>C(t)).filter(t=>t!==y).join("")}value(){return C(this._path).node.get(y)}result(){switch(this._type){case ce:return this.value();case ie:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const C=e=>e[e.length-1],Ke=(e,t,n)=>{const o=new Map;if(typeof t!="string")return o;const s=t.length+1,r=s+n,i=new Uint8Array(r*s).fill(n+1);for(let c=0;c<s;++c)i[c]=c;for(let c=1;c<r;++c)i[c*s]=c;return le(e,t,n,o,i,1,s,""),o},le=(e,t,n,o,s,r,i,c)=>{const l=r*i;e:for(const u of e.keys())if(u===y){const a=s[l-1];a<=n&&o.set(c,[e.get(u),a])}else{let a=r;for(let h=0;h<u.length;++h,++a){const g=u[h],m=i*a,w=m-i;let d=s[m];const f=Math.max(0,a-n-1),p=Math.min(i-1,a+n);for(let _=f;_<p;++_){const I=g!==t[_],j=s[w+_]+ +I,T=s[w+_+1]+1,E=s[m+_]+1,O=s[m+_+1]=Math.min(j,T,E);O<d&&(d=O)}if(d>n)continue e}le(e.get(u),t,n,o,s,a,i,c+u)}};let ue=class N{_tree;_prefix;_size=void 0;constructor(t=new Map,n=""){this._tree=t,this._prefix=n}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[n,o]=V(this._tree,t.slice(this._prefix.length));if(n===void 0){const[s,r]=B(o);for(const i of s.keys())if(i!==y&&i.startsWith(r)){const c=new Map;return c.set(i.slice(r.length),s.get(i)),new N(c,t)}}return new N(n,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,Qe(this._tree,t)}entries(){return new U(this,Ye)}forEach(t){for(const[n,o]of this)t(n,o,this)}fuzzyGet(t,n){return Ke(this._tree,t,n)}get(t){const n=J(this._tree,t);return n!==void 0?n.get(y):void 0}has(t){return J(this._tree,t)?.has(y)??!1}keys(){return new U(this,ie)}set(t,n){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,G(this._tree,t).set(y,n),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,n){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const o=G(this._tree,t);return o.set(y,n(o.get(y))),this}fetch(t,n){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const o=G(this._tree,t);let s=o.get(y);return s===void 0&&o.set(y,s=n()),s}values(){return new U(this,ce)}[Symbol.iterator](){return this.entries()}static from(t){const n=new N;for(const[o,s]of t)n.set(o,s);return n}static fromObject(t){return N.from(Object.entries(t))}};const V=(e,t,n=[])=>{if(t.length===0||e==null)return[e,n];for(const o of e.keys())if(o!==y&&t.startsWith(o))return n.push([e,o]),V(e.get(o),t.slice(o.length),n);return n.push([e,t]),V(void 0,"",n)},J=(e,t)=>{if(t.length===0||!e)return e;for(const n of e.keys())if(n!==y&&t.startsWith(n))return J(e.get(n),t.slice(n.length))},G=(e,t)=>{const n=t.length;e:for(let o=0;e&&o<n;){for(const r of e.keys())if(r!==y&&t[o]===r[0]){const i=Math.min(n-o,r.length);let c=1;for(;c<i&&t[o+c]===r[c];)++c;const l=e.get(r);if(c===r.length)e=l;else{const u=new Map;u.set(r.slice(c),l),e.set(t.slice(o,o+c),u),e.delete(r),e=u}o+=c;continue e}const s=new Map;return e.set(t.slice(o),s),s}return e},Qe=(e,t)=>{const[n,o]=V(e,t);if(n!==void 0){if(n.delete(y),n.size===0)ae(o);else if(n.size===1){const[s,r]=n.entries().next().value;fe(o,s,r)}}},ae=e=>{if(e.length===0)return;const[t,n]=B(e);if(t.delete(n),t.size===0)ae(e.slice(0,-1));else if(t.size===1){const[o,s]=t.entries().next().value;o!==y&&fe(e.slice(0,-1),o,s)}},fe=(e,t,n)=>{if(e.length===0)return;const[o,s]=B(e);o.set(s+t,n),o.delete(s)},B=e=>e[e.length-1],Xe=(e,t)=>{const n=e._idToShortId.get(t);if(n!=null)return e._storedFields.get(n)},Ze=/[\n\r\p{Z}\p{P}]+/u,Y="or",de="and",et="and_not",tt=(e,t)=>{e.includes(t)||e.push(t)},he=(e,t)=>{for(const n of t)e.includes(n)||e.push(n)},pe=({score:e},{score:t})=>t-e,nt=()=>new Map,R=e=>{const t=new Map;for(const n of Object.keys(e))t.set(parseInt(n,10),e[n]);return t},ge=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,me={[Y]:(e,t)=>{for(const n of t.keys()){const o=e.get(n);if(o==null)e.set(n,t.get(n));else{const{score:s,terms:r,match:i}=t.get(n);o.score=o.score+s,o.match=Object.assign(o.match,i),he(o.terms,r)}}return e},[de]:(e,t)=>{const n=new Map;for(const o of t.keys()){const s=e.get(o);if(s==null)continue;const{score:r,terms:i,match:c}=t.get(o);he(s.terms,i),n.set(o,{score:s.score+r,terms:s.terms,match:Object.assign(s.match,c)})}return n},[et]:(e,t)=>{for(const n of t.keys())e.delete(n);return e}},ot=(e,t,n,o,s,r)=>{const{k:i,b:c,d:l}=r;return Math.log(1+(n-t+.5)/(t+.5))*(l+e*(i+1)/(e+i*(1-c+c*o/s)))},st=e=>(t,n,o)=>({term:t,fuzzy:typeof e.fuzzy=="function"?e.fuzzy(t,n,o):e.fuzzy??!1,prefix:typeof e.prefix=="function"?e.prefix(t,n,o):e.prefix===!0,termBoost:typeof e.boostTerm=="function"?e.boostTerm(t,n,o):1}),_e=(e,t,n,o)=>{for(const s of Object.keys(e._fieldIds))if(e._fieldIds[s]===n){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${o}" was not present in field "${s}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},rt=(e,t,n,o)=>{if(!e._index.has(o)){_e(e,n,t,o);return}const s=e._index.fetch(o,nt),r=s.get(t),i=r?.get(n);!r||typeof i>"u"?_e(e,n,t,o):i<=1?r.size<=1?s.delete(t):r.delete(n):r.set(n,i-1),e._index.get(o).size===0&&e._index.delete(o)},it={k:1.2,b:.7,d:.5},ct={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(Ze),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{console?.[e]?.(t)},autoVacuum:!0},ye={combineWith:Y,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:it},lt={combineWith:de,prefix:(e,t,n)=>t===n.length-1},ut={batchSize:1e3,batchWait:10},we={minDirtFactor:.1,minDirtCount:20},at={...ut,...we},be=Symbol("*"),ft=(e,t)=>{const n=new Map,o={...e._options.searchOptions,...t};for(const[s,r]of e._documentIds){const i=o.boostDocument?o.boostDocument(r,"",e._storedFields.get(s)):1;n.set(s,{score:i,terms:[],match:{}})}return n},xe=(e,t=Y)=>{if(e.length===0)return new Map;const n=t.toLowerCase();if(!(n in me))throw new Error(`Invalid combination operator: ${t}`);return e.reduce(me[n])},K=(e,t,n,o,s,r,i,c,l,u=new Map)=>{if(r==null)return u;for(const a of Object.keys(i)){const h=i[a],g=e._fieldIds[a],m=r.get(g);if(m==null)continue;let w=m.size;const d=e._avgFieldLength[g];for(const f of m.keys()){if(!e._documentIds.has(f)){rt(e,g,f,n),w-=1;continue}const p=c?c(e._documentIds.get(f),n,e._storedFields.get(f)):1;if(!p)continue;const _=m.get(f),I=e._fieldLength.get(f)[g],j=ot(_,w,e._documentCount,I,d,l),T=o*s*h*p*j,E=u.get(f);if(E){E.score+=T,tt(E.terms,t);const O=ge(E.match,n);O?O.push(a):E.match[n]=[a]}else u.set(f,{score:T,terms:[t],match:{[n]:[a]}})}}return u},dt=(e,t,n)=>{const o={...e._options.searchOptions,...n},s=(o.fields??e._options.fields).reduce((d,f)=>({...d,[f]:ge(o.boost,f)||1}),{}),{boostDocument:r,weights:i,maxFuzzy:c,bm25:l}=o,{fuzzy:u,prefix:a}={...ye.weights,...i},h=e._index.get(t.term),g=K(e,t.term,t.term,1,t.termBoost,h,s,r,l);let m,w;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const d=t.fuzzy===!0?.2:t.fuzzy,f=d<1?Math.min(c,Math.round(t.term.length*d)):d;f&&(w=e._index.fuzzyGet(t.term,f))}if(m)for(const[d,f]of m){const p=d.length-t.term.length;if(!p)continue;w?.delete(d);const _=a*d.length/(d.length+.3*p);K(e,t.term,d,_,t.termBoost,f,s,r,l,g)}if(w)for(const d of w.keys()){const[f,p]=w.get(d);if(!p)continue;const _=u*d.length/(d.length+p);K(e,t.term,d,_,t.termBoost,f,s,r,l,g)}return g},ke=(e,t,n={})=>{if(t===be)return ft(e,n);if(typeof t!="string"){const a={...n,...t,queries:void 0},h=t.queries.map(g=>ke(e,g,a));return xe(h,a.combineWith)}const{tokenize:o,processTerm:s,searchOptions:r}=e._options,i={tokenize:o,processTerm:s,...r,...n},{tokenize:c,processTerm:l}=i,u=c(t).flatMap(a=>l(a)).filter(a=>!!a).map(st(i)).map(a=>dt(e,a,i));return xe(u,i.combineWith)},Ie=(e,t,n={})=>{const{searchOptions:o}=e._options,s={...o,...n},r=ke(e,t,n),i=[];for(const[c,{score:l,terms:u,match:a}]of r){const h=u.length||1,g={id:e._documentIds.get(c),score:l*h,terms:Object.keys(a),queryTerms:u,match:a};Object.assign(g,e._storedFields.get(c)),(s.filter==null||s.filter(g))&&i.push(g)}return t===be&&s.boostDocument==null||i.sort(pe),i},ht=(e,t,n={})=>{n={...e._options.autoSuggestOptions,...n};const o=new Map;for(const{score:r,terms:i}of Ie(e,t,n)){const c=i.join(" "),l=o.get(c);l!=null?(l.score+=r,l.count+=1):o.set(c,{score:r,terms:i,count:1})}const s=[];for(const[r,{score:i,terms:c,count:l}]of o)s.push({suggestion:r,terms:c,score:i/l});return s.sort(pe),s};class pt{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(!t?.fields)throw new Error('SlimSearch: option "fields" must be provided');const n=t.autoVacuum==null||t.autoVacuum===!0?at:t.autoVacuum;this._options={...ct,...t,autoVacuum:n,searchOptions:{...ye,...t.searchOptions},autoSuggestOptions:{...lt,...t.autoSuggestOptions}},this._index=new ue,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=we,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[n,o]of this._index){const s={};for(const[r,i]of o)s[r]=Object.fromEntries(i);t.push([n,s])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,version:2}}addFields(t){for(let n=0;n<t.length;n++)this._fieldIds[t[n]]=n}}const gt=e=>new pt(e),mt=({documentCount:e,nextId:t,fieldIds:n,averageFieldLength:o,dirtCount:s,version:r},i)=>{if(r!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const c=gt(i);return c._documentCount=e,c._nextId=t,c._idToShortId=new Map,c._fieldIds=n,c._avgFieldLength=o,c._dirtCount=s??0,c._index=new ue,c},_t=(e,t)=>{const{index:n,documentIds:o,fieldLength:s,storedFields:r}=e,i=mt(e,t);i._documentIds=R(o),i._fieldLength=R(s),i._storedFields=R(r);for(const[c,l]of i._documentIds)i._idToShortId.set(l,c);for(const[c,l]of n){const u=new Map;for(const a of Object.keys(l))u.set(parseInt(a,10),R(l[a]));i._index.set(c,u)}return i},Q=(e,t)=>{const n=e.toLowerCase(),o=t.toLowerCase(),s=[];let r=0,i=0;const c=(u,a=!1)=>{let h;i===0?h=u.length>20?`… ${u.slice(-20)}`:u:a?h=u.length+i>100?`${u.slice(0,100-i)}… `:u:h=u.length>20?`${u.slice(0,20)} … ${u.slice(-20)}`:u,h&&s.push(h),i+=h.length,a||(s.push(["mark",t]),i+=t.length,i>=100&&s.push(" …"))};let l=n.indexOf(o,r);if(l===-1)return null;for(;l>=0;){const u=l+o.length;if(c(e.slice(r,l)),r=u,i>100)break;l=n.indexOf(o,r)}return i<100&&c(e.slice(r),!0),s},{entries:yt}=Object,wt=(e,t)=>t.contents.reduce((n,[,o])=>n+o,0)-e.contents.reduce((n,[,o])=>n+o,0),bt=(e,t)=>Math.max(...t.contents.map(([,n])=>n))-Math.max(...e.contents.map(([,n])=>n)),Ee=(e,t,n={},o="max")=>{const s={};return Ie(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...n}).forEach(r=>{const{id:i,terms:c,score:l}=r,u=i.includes("@"),a=i.includes("#"),[h,g]=i.split(/[#@]/),m=Number(h),w=c.sort((f,p)=>f.length-p.length).filter((f,p)=>c.slice(p+1).every(_=>!_.includes(f))),{contents:d}=s[m]??={title:"",contents:[]};if(u)d.push([{type:"customField",id:m,index:g,display:w.map(f=>r.c.map(p=>Q(p,f))).flat().filter(f=>f!==null)},l]);else{const f=w.map(p=>Q(r.h,p)).filter(p=>p!==null);if(f.length&&d.push([{type:a?"heading":"title",id:m,...a&&{anchor:g},display:f},l]),"t"in r&&r.t)for(const p of r.t){const _=w.map(I=>Q(p,I)).filter(I=>I!==null);_.length&&d.push([{type:"text",id:m,...a&&{anchor:g},display:_},l])}}}),yt(s).sort(([,r],[,i])=>(o?wt:bt)(r,i)).map(([r,{title:i,contents:c}])=>{if(!i){const l=Xe(t,r);l&&(i=l.h)}return{title:i,contents:c.map(([l])=>l)}})},ve=(e,t,n={})=>{const o=ht(t,e,{fuzzy:.2,maxFuzzy:3,...n}).map(({suggestion:s})=>s);return e.includes(" ")?o:o.filter(s=>!s.includes(" "))},xt=Be(Ge(JSON.parse("{\"/\":{\"documentCount\":50,\"nextId\":50,\"documentIds\":{\"0\":\"0\",\"1\":\"1\",\"2\":\"1#binary-oracle\",\"3\":\"1#elowen\",\"4\":\"2\",\"5\":\"3\",\"6\":\"4\",\"7\":\"4#引言\",\"8\":\"4#介绍\",\"9\":\"4#训练\",\"10\":\"4#推理\",\"11\":\"4#文本描述生成\",\"12\":\"4#花卉图片分类\",\"13\":\"4#文字搜索图像\",\"14\":\"4#完整代码\",\"15\":\"4#小结\",\"16\":\"5\",\"17\":\"6\",\"18\":\"6#环境搭建\",\"19\":\"6#数据预处理\",\"20\":\"6#模型架构\",\"21\":\"6#dataloader\",\"22\":\"6#bertembeddings\",\"23\":\"6#bertencoder\",\"24\":\"6#bertlayer\",\"25\":\"6#bertencoder-1\",\"26\":\"6#bertpooler\",\"27\":\"6#bertmodel\",\"28\":\"6#bertforsequenceclassification\",\"29\":\"6#bertattention\",\"30\":\"6#bertselfattention\",\"31\":\"6#bertselfoutput\",\"32\":\"6#bertattention-1\",\"33\":\"7\",\"34\":\"7#环境\",\"35\":\"7#背景\",\"36\":\"7#模型架构\",\"37\":\"7#encoder-decoder-结构\",\"38\":\"7#generator\",\"39\":\"7#encoder-结构\",\"40\":\"7#sublayerconnection\",\"41\":\"7#encoderlayer\",\"42\":\"7#encoder\",\"43\":\"7#decoder-结构\",\"44\":\"7#decoderlayer\",\"45\":\"7#decoder\",\"46\":\"7#多头自注意力\",\"47\":\"8\",\"48\":\"9\",\"49\":\"10\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,7],\"1\":[1],\"2\":[2,13],\"3\":[1,5],\"4\":[3],\"5\":[1],\"6\":[1,3],\"7\":[1,31],\"8\":[1,20],\"9\":[1,146],\"10\":[1,156],\"11\":[1,57],\"12\":[1,245],\"13\":[1,92],\"14\":[1,210],\"15\":[1,132],\"16\":[1],\"17\":[2,2],\"18\":[1,139],\"19\":[1,165],\"20\":[1],\"21\":[1,48],\"22\":[1,66],\"23\":[1],\"24\":[1,58],\"25\":[1,30],\"26\":[1,40],\"27\":[1,49],\"28\":[1,73],\"29\":[1],\"30\":[1,104],\"31\":[1,32],\"32\":[1,23],\"33\":[1,2],\"34\":[1,41],\"35\":[1,23],\"36\":[1,64],\"37\":[3,30],\"38\":[1,28],\"39\":[2],\"40\":[1,33],\"41\":[1,37],\"42\":[1,37],\"43\":[2],\"44\":[1,49],\"45\":[1,39],\"46\":[1,116],\"47\":[1],\"48\":[1],\"49\":[1,3]},\"averageFieldLength\":[1.1600000000000001,60.174602067899926],\"storedFields\":{\"0\":{\"h\":\"主页\",\"t\":[\"知识星球: MetaMind , 小红书: BinaryOracle , CSDN: Binary Oracle\"]},\"1\":{\"h\":\"关于我们\"},\"2\":{\"h\":\"Binary Oracle\",\"t\":[\"一名普通但十分热爱探索技术的Coder\",\"开源框架 Spring committer\",\"Golang 开源网络库 netpoll committer\",\"Javaer 转型 3D - VL 方向研究\",\"现就读于四川大学\"]},\"3\":{\"h\":\"Elowen\",\"t\":[\"CV 转 LLM 领域\",\"现就读于电子科技大学\"]},\"4\":{\"h\":\"3D-Vision Language\"},\"5\":{\"h\":\"多模态\"},\"6\":{\"h\":\"庖丁解牛CLIP\",\"t\":[\"多模态模型CLIP原理与图片分类，文字搜索图像实战演练\",\"CLIP原始论文链接\"]},\"7\":{\"h\":\"引言\",\"t\":[\"2021 年可谓是视觉 Transformer（Vision Transformer）大放异彩的一年。自谷歌提出 ViT 之后，众多基于视觉 Transformer 的研究如潮水般涌来，广泛应用于各类计算机视觉任务。与此同时，OpenAI 在 2021 年 1 月发布的 DALL-E 和 CLIP，同样给计算机视觉领域带来了巨大影响。这两个模型都属于融合图像与文本的多模态模型，其中 DALL-E 是基于文本输入来生成图像的模型，而 CLIP 则是以文本作为监督信号，训练出具有可迁移能力的视觉模型。和 ViT 类似，DALL-E 和 CLIP 的出现也掀起了新一轮的研究热潮。\"]},\"8\":{\"h\":\"介绍\",\"t\":[\"CLIP的英文全称为Contrastive Language-Image Pre-training，它代表着一种基于对比文本-图像对的预训练方法，同时也指运用该方法构建的模型。CLIP属于基于对比学习的多模态模型。与计算机视觉（CV）领域中的一些对比学习方法，像MoCo和SimCLR有所不同，CLIP的训练数据采用的是文本-图像对，也就是一张图像搭配与之对应的文本描述。在训练过程中，借助对比学习机制，期望模型能够学习到文本和图像之间的匹配关系。\"]},\"9\":{\"h\":\"训练\",\"t\":[\"CLIP包含两个核心模型，分别是文本编码器（Text Encoder）和图像编码器（Image Encoder）。其中，文本编码器的作用是提取文本的特征，在实现时可采用自然语言处理（NLP）领域常用的文本Transformer模型；而图像编码器则用于提取图像的特征，在实际应用中可以选用常见的卷积神经网络（CNN）模型，也可以采用视觉Transformer模型。\",\"这里对提取的文本特征和图像特征进行对比学习。对于一个包含个文本-图像对的训练batch，将个文本特征和个图像特征两两组合，CLIP模型会预测出个可能的文本-图像对的相似度，这里的相似度直接计算文本特征和图像特征的余弦相似性（cosine similarity），即上图所示的矩阵。这里共有个正样本，即真正属于一对的文本和图像（矩阵中的对角线元素），而剩余的个文本-图像对为负样本，那么CLIP的训练目标就是最大个正样本的相似度，同时最小化个负样本的相似度，对应的伪代码实现如下所示：\",\"# image_encoder - ResNet or Vision Transformer # text_encoder - CBOW or Text Transformer # I[n, h, w, c] - minibatch of aligned images # T[n, l] - minibatch of aligned texts # W_i[d_i, d_e] - learned proj of image to embed # W_t[d_t, d_e] - learned proj of text to embed # t - learned temperature parameter # 分别提取图像特征和文本特征 I_f = image_encoder(I) #[n, d_i] T_f = text_encoder(T) #[n, d_t] # 对两个特征进行线性投射，得到相同维度的特征，并进行l2归一化 I_e = l2_normalize(np.dot(I_f, W_i), axis=1) T_e = l2_normalize(np.dot(T_f, W_t), axis=1) # 计算缩放的余弦相似度：[n, n] logits = np.dot(I_e, T_e.T) * np.exp(t) # 对称的对比学习损失：等价于N个类别的cross_entropy_loss labels = np.arange(n) # 对角线元素的labels loss_i = cross_entropy_loss(logits, labels, axis=0) loss_t = cross_entropy_loss(logits, labels, axis=1) loss = (loss_i + loss_t)/2\",\"为了训练CLIP模型，OpenAI从网络上收集了总计4亿对文本和图像，这些数据在论文中被称为WebImageText。若以文本单词数量来衡量，其规模与GPT-2训练时使用的WebText数据集相似。然而，从数据对的数量来看，它比谷歌的JFT-300M数据集还要多出1亿对，因此这是一个非常庞大的数据集。\",\"尽管CLIP是一个多模态模型，但其主要目的是训练可迁移的视觉模型。在论文中，文本编码器（Text Encoder）选择了一个包含6300万参数的Transformer模型，而图像编码器（Image Encoder）则采用了两种不同的架构：\",\"一种是常用的CNN架构ResNet。\",\"另一种是基于 Transformer 的ViT。\",\"ResNet包含五种不同尺寸的模型：ResNet50、ResNet101、RN50x4、RN50x16和RNx64（后三种模型是按照EfficientNet的缩放规则对ResNet分别放大4倍、16倍和64倍得到的），而ViT则选择了三种不同尺寸的模型：ViT-B/32、ViT-B/16和ViT-L/14。\",\"所有模型均训练了32个周期，使用AdamW优化器，并且在训练过程中采用了一个相对较大的批次大小：32768。由于数据量巨大，最大的ResNet模型RN50x64需要在592个V100 GPU上训练18天，而最大的ViT模型ViT-L/14则需要在256个V100 GPU上训练12天，这表明训练CLIP模型需要消耗大量的资源。对于ViT-L/14模型，还在336的分辨率下额外进行了一个周期的微调（finetune）以增强性能，论文发现这个模型的效果最佳，并将其标记为ViT-L/14@336，论文中进行对比实验的CLIP模型也采用了这一配置。\"]},\"10\":{\"h\":\"推理\",\"t\":[\"我们已经探讨了CLIP模型的运作机制，它由两个部分组成：一个视觉模型和一个文本模型。那么，如何将这个预训练的视觉模型应用到新的任务中呢？CLIP模型的一个显著优势是它能够进行zero-shot图像分类，这意味着它能够在没有任何特定任务训练数据的情况下，直接对图像进行分类。这不仅展示了CLIP的强大功能，也是其一大亮点。实现zero-shot分类的过程相当直接，可以概括为以下两个主要步骤：\",\"构建描述文本并提取特征：首先，根据任务的分类需求，为每个类别创建一个描述性的文本，例如“A photo of {label}”。这些文本随后被输入到文本编码器（Text Encoder）中，以生成相应的文本特征。如果有个类别，那么就会得到个文本特征。\",\"图像特征提取与分类：接下来，将待分类的图像输入到图像编码器（Image Encoder）中，以获取图像特征。然后，这些图像特征会与之前得到的个文本特征进行余弦相似度计算（这一过程与训练时相同）。最终，选择与图像特征相似度最高的文本所对应的类别，作为图像的分类预测结果。此外，这些相似度值可以被视为logits，通过softmax函数转换后，可以得到每个类别的预测概率。\",\"通过这种方式，CLIP模型能够在没有特定任务训练数据的情况下，直接对图像进行分类，这展示了其在图像分类任务中的灵活性和强大能力。\",\" 显然，我们通过利用CLIP模型的多模态能力，为特定任务动态构建了一个分类器。在这个过程中，文本编码器（Text Encoder）生成的文本特征相当于分类器的权重，而图像编码器（Image Encoder）提取的图像特征则是分类器的输入数据。以下是一个官方给出的CLIP模型的示例 ，该示例中的任务涉及8个类别:\",\"我们首先创建了各类别的文本描述，然后提取了相应的文本特征；\",\"然后我们读取要预测的图像，输入Image Encoder提取图像特征，并计算与文本特征的余弦相似度。\",\"# 1. 提取文本特征 texts = [ \\\"a page of text about segmentation\\\", \\\"a facial photo of a tabby cat\\\", \\\"a portrait of an astronaut with the American flag\\\", \\\"a rocket standing on a launchpad\\\", \\\"a red motorcycle standing in a garage\\\", \\\"a person looking at a camera on a tripod\\\", \\\"a black-and-white silhouette of a horse\\\", \\\"a cup of coffee on a saucer\\\" ] text_tokens = clip.tokenize([\\\"This is \\\" + desc for desc in texts]).cuda() with torch.no_grad(): text_features = model.encode_text(text_tokens).float() # 2. 提取图像特征 image_input = torch.tensor(np.stack(images)).cuda() with torch.no_grad(): image_features = model.encode_image(image_input).float() # 3. 计算余弦相似度 image_features /= image_features.norm(dim=-1, keepdim=True) text_features /= text_features.norm(dim=-1, keepdim=True) similarity = text_features.cpu().numpy() @ image_features.cpu().numpy().T\",\"相似度如下所示，可以看到对于要预测的8个图像，按照最大相似度，其均能匹配到正确的文本标签：\",\"进一步地，我们也可以对得到的余弦相似度计算softmax，得到每个预测类别的概率值：\",\"text_probs = (100.0 * image_features @ text_features.T).softmax(dim=-1) top_probs, top_labels = text_probs.cpu().topk(5, dim=-1)\",\"得到的预测概率如下所示，可以看到8个图像，CLIP模型均能够以较高的置信度给出正确的分类结果：\"]},\"11\":{\"h\":\"文本描述生成\",\"t\":[\"在使用CLIP模型进行zero-shot分类时，除了模型本身的应用，文本描述的生成也是一个关键环节。在之前的例子中，我们使用了“A photo of {label}”这样的格式来生成文本描述，但实际上，我们还有其他的选择。例如，我们可以直接使用类别标签作为文本描述。这种方法实际上与NLP领域的一个研究方向——prompt learning或prompt engineering——紧密相关。关于这一领域的详细综述，可以参考论文《Pre-train, Prompt, and Predict: A Systematic Survey of Prompting Methods in Natural Language Processing》。\",\"简单来说，prompt learning的核心思想是通过设计合适的prompt（提示），使得预训练模型能够直接应用于下游任务。这与传统的预训练加微调的方法有所不同。论文指出，如果我们直接使用类别标签作为文本描述，由于这些文本往往只是一个单词，缺乏具体的上下文，并且与CLIP模型的训练数据不完全一致，因此在效果上可能不如使用“A photo of {label}”这种格式（在ImageNet数据集上可以提升1.3%的效果）。\",\"此外，论文还实验了使用80个不同的prompt进行集成，结果发现在ImageNet数据集上能够带来3.5%的性能提升。具体的实验结果可以参考CLIP公开的notebook。\"]},\"12\":{\"h\":\"花卉图片分类\",\"t\":[\"本节我们将基于CLIP预训练模型实现Zero-Shot推理，训练使用到的数据集和AlexNet保持一致，因此这里就不再给出数据集下载链接了。\",\"图片分类实战 – 分别基于LeNet，AlexNet，VGG进行实现\",\"# 预训练模型名称 model_name = \\\"openai/clip-vit-large-patch14\\\" # 定义当前目录 current_dir = os.getcwd() model_dir = os.path.join(current_dir, model_name.replace(\\\"/\\\", \\\"_\\\")) # 检查当前目录是否有预训练权重文件，如果没有则下载 def download_pretrained_weights_if_needed(model_name, save_dir): if not os.path.exists(save_dir): try: print(f\\\"Downloading {model_name} to {save_dir}...\\\") snapshot_download(repo_id=model_name, local_dir=save_dir, local_dir_use_symlinks=False) print(f\\\"{model_name} downloaded successfully.\\\") except Exception as e: print(f\\\"Error downloading {model_name}: {e}\\\") download_pretrained_weights_if_needed(model_name, model_dir) # 加载模型和处理器 model = CLIPModel.from_pretrained(model_dir) processor = CLIPProcessor.from_pretrained(model_dir) device = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\") model = model.to(device)\",\"在 openai/clip-vit-large-patch14 这个 CLIP 预训练模型中，图像编码器采用了 Vision Transformer（ViT）架构，具体使用的是 ViT-L/14 版本，文本编码器使用的是基于 Transformer 的架构。\",\"# 函数：生成文本嵌入 def text_embedding(texts): inputs = processor(text=texts, return_tensors=\\\"pt\\\", padding=True).to(device) with torch.no_grad(): embeddings = model.get_text_features(**inputs) return embeddings.cpu().numpy()\",\"这个函数的作用是将输入的文本转化为对应的嵌入表示（embedding）。它通过处理器对输入文本进行处理，使其符合模型的输入要求，然后利用模型获取文本特征，最后将结果转换为 numpy 数组格式返回，方便后续的计算和比较。\",\"def get_image_embeddings(image_paths): images = [] for image_path in image_paths: try: image = Image.open(image_path).convert(\\\"RGB\\\") images.append(image) except Exception as e: print(f\\\"Error loading image {e}\\\") if not images: return None inputs = processor(images=images, return_tensors=\\\"pt\\\").to(device) with torch.no_grad(): image_features = model.get_image_features(**inputs) return image_features.cpu().numpy()\",\"该函数作用是针对给定的图片路径，读取图片并将其转换为合适的格式后，通过模型获取图片的特征嵌入。如果在读取图片过程中出现错误，会进行相应的错误提示并返回 None。\",\"def cosine_similarity(vec1, vec2): vec1 = np.array(vec1) vec2 = np.array(vec2) return np.dot(vec1, vec2.T) / (np.linalg.norm(vec1, axis=1, keepdims=True) * np.linalg.norm(vec2, axis=1))\",\"在图文检索中，我们常常需要衡量文本嵌入和图片嵌入之间的相似度，这里采用了余弦相似度的计算方法。它将输入的向量转换为 numpy 数组后，按照余弦相似度的数学公式来计算两者的相似度数值。\",\"首先，我们需要根据上面给出的花卉数据集下载链接，将数据下载到当前项目目录下:\",\"其次，我们从flower_photos目录下读取出所有图片的路径:\",\"# 递归遍历目录获取所有图片路径 def get_all_image_paths(directory): image_paths = [] for root, _, files in os.walk(directory): for file in files: file_extension = os.path.splitext(file)[1].lower() if file_extension in ['.png', '.jpg', '.jpeg']: image_paths.append(os.path.join(root, file)) return image_paths image_paths = get_all_image_paths(\\\"./flower_photos\\\")\",\"同时将flower_photos下的子目录名作为我们的候选待匹配分类文本列表，并改造为a photo of 子目录名的格式，然后计算每个分类文本对应的文本嵌入向量:\",\"# 获取候选分类名列表 def get_candidates(directory): candidates = [] for sub_dir in os.listdir(directory): sub_dir_path = os.path.join(directory, sub_dir) if os.path.isdir(sub_dir_path): candidates.append(f\\\"a photo of {sub_dir}\\\") return candidates candidates = get_candidates(\\\"./flower_photos\\\") text_embeddings = text_embedding(candidates)\",\"最后:\",\"分批次从图像列表中取出一批图像，获取其对应的图像嵌入向量列表\",\"计算这批图像嵌入向量中每一个图像嵌入向量和我们所有分类文本嵌入向量的余弦相似度\",\"针对每个图像嵌入向量取出和其相似度最高的那个文本嵌入向量的索引\",\"判断预测是否正确，统计正确率\",\"# 测试图片分类正确率 def accuracy(image_paths, candidates, text_embeddings, batch_size=64): correct_count = 0 total_count = len(image_paths) num_batches = (total_count + batch_size - 1) // batch_size # 分批次预测 for i in range(num_batches): start_idx = i * batch_size end_idx = min(start_idx + batch_size, total_count) # 取出当前批次的图像列表，并获得该批次图像列表对应的图像嵌入向量列表 batch_image_paths = image_paths[start_idx:end_idx] image_embeddings = get_image_embeddings(batch_image_paths) if image_embeddings is not None: # 计算图像嵌入向量列表中每个图像对应的嵌入向量和传入的分类文本嵌入向量的余弦相似度 similarities = cosine_similarity(image_embeddings, text_embeddings) # 针对每个图像嵌入向量获取和其相似度最高的分类文本嵌入向量索引下标 predicted_indices = np.argmax(similarities, axis=1) for j, predicted_index in enumerate(predicted_indices): # 针对每张图像，根据上述计算得到的和其相似度最高的分类文本索引，从候选分类文本集合中取出其分类名词 predicted_category = candidates[predicted_index].split(\\\" \\\")[-1] # 用当前图片外层目录的名字作为其分类名词 actual_category = os.path.basename(os.path.dirname(batch_image_paths[j])) # 比较两个分类名词是否相等 if predicted_category == actual_category: correct_count += 1 accuracy = correct_count / total_count return accuracy # 图片分类 def flowerClassify(): image_paths = get_all_image_paths(\\\"./flower_photos\\\") candidates = get_candidates(\\\"./flower_photos\\\") text_embeddings = text_embedding(candidates) start_time = time.time() acc = accuracy(image_paths, candidates, text_embeddings, batch_size=64) end_time = time.time() print(f\\\"Time taken to test accuracy: {end_time - start_time:.2f} seconds\\\") print(f\\\"Accuracy: {acc * 100:.2f}%\\\")\",\"Time taken to test accuracy: 396.62 seconds Accuracy: 95.48%\"]},\"13\":{\"h\":\"文字搜索图像\",\"t\":[\"上面的花卉分类案例相当于使用图像去匹配最合适的文本描述，而这里我们将会反转这个逻辑，用文本描述去匹配最合适的图片内容。\",\"为了实现文字搜索图像的功能，我们只需要在计算出相似度得分矩阵后，以每个文本描述为一行，取出该行中得分最大的那一列，即为与当前文本描述相似度最高的那副图片，具体代码实现如下：\",\"# 找到与文本最匹配的图片 def find_most_matching_image(text, image_paths): text_emb = text_embedding([text]) image_embeddings = get_image_embeddings(image_paths) if image_embeddings is None: return None similarities = cosine_similarity(text_emb, image_embeddings) most_matching_index = np.argmax(similarities) return image_paths[most_matching_index]\",\"下面来实际展示一下效果，首先我们用data目录充当我们的图片库来源:\",\" 遍历data目录，拿到所有图片路径:\",\"# 遍历 data 目录获取所有图片路径 def get_images_from_data_dir(): data_dir = os.path.join(current_dir, 'data') if not os.path.exists(data_dir): print(f\\\"Data directory {data_dir} does not exist.\\\") return [] return get_all_image_paths(data_dir)\",\"这里以搜索向日葵花为例，我们首先获取图片库中所有图片，然后计算出和当前文本描述相似度最高的那副图片，并将图片展示出来:\",\"# 根据文字搜索图片 def searchPicByText(): image_paths = get_images_from_data_dir() query_text = \\\"a photo of a sunflowers\\\" most_matching_image = find_most_matching_image(query_text, image_paths) if most_matching_image: print(f\\\"The most matching image for '{query_text}' is: {most_matching_image}\\\") try: img = Image.open(most_matching_image) plt.imshow(img) plt.axis('off') plt.title(f\\\"Most matching image for '{query_text}'\\\") plt.show() except Exception as e: print(f\\\"Error opening image: {e}\\\") else: print(\\\"No matching image found.\\\")\",\"图片库中的图片： 运行上述代码，搜索出来的图片:\"]},\"14\":{\"h\":\"完整代码\",\"t\":[\"import time from matplotlib import pyplot as plt from transformers import CLIPProcessor, CLIPModel import torch from PIL import Image import numpy as np import warnings import os from huggingface_hub import snapshot_download warnings.filterwarnings(\\\"ignore\\\") # 模型名称 model_name = \\\"openai/clip-vit-large-patch14\\\" # 定义当前目录 current_dir = os.getcwd() model_dir = os.path.join(current_dir, model_name.replace(\\\"/\\\", \\\"_\\\")) # 检查当前目录是否有预训练权重文件，如果没有则下载 def download_pretrained_weights_if_needed(model_name, save_dir): if not os.path.exists(save_dir): try: print(f\\\"Downloading {model_name} to {save_dir}...\\\") snapshot_download(repo_id=model_name, local_dir=save_dir, local_dir_use_symlinks=False) print(f\\\"{model_name} downloaded successfully.\\\") except Exception as e: print(f\\\"Error downloading {model_name}: {e}\\\") download_pretrained_weights_if_needed(model_name, model_dir) # 加载模型和处理器 model = CLIPModel.from_pretrained(model_dir) processor = CLIPProcessor.from_pretrained(model_dir) device = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\") model = model.to(device) # 函数：生成文本嵌入 def text_embedding(texts): inputs = processor(text=texts, return_tensors=\\\"pt\\\", padding=True).to(device) with torch.no_grad(): embeddings = model.get_text_features(**inputs) return embeddings.cpu().numpy() def get_image_embeddings(image_paths): images = [] for image_path in image_paths: try: image = Image.open(image_path).convert(\\\"RGB\\\") images.append(image) except Exception as e: print(f\\\"Error loading image {e}\\\") if not images: return None inputs = processor(images=images, return_tensors=\\\"pt\\\").to(device) with torch.no_grad(): image_features = model.get_image_features(**inputs) return image_features.cpu().numpy() def cosine_similarity(vec1, vec2): vec1 = np.array(vec1) vec2 = np.array(vec2) return np.dot(vec1, vec2.T) / (np.linalg.norm(vec1, axis=1, keepdims=True) * np.linalg.norm(vec2, axis=1)) # 递归遍历目录获取所有图片路径 def get_all_image_paths(directory): image_paths = [] for root, _, files in os.walk(directory): for file in files: file_extension = os.path.splitext(file)[1].lower() if file_extension in ['.png', '.jpg', '.jpeg']: image_paths.append(os.path.join(root, file)) return image_paths # 获取候选分类名列表 def get_candidates(directory): candidates = [] for sub_dir in os.listdir(directory): sub_dir_path = os.path.join(directory, sub_dir) if os.path.isdir(sub_dir_path): candidates.append(f\\\"a photo of {sub_dir}\\\") return candidates # 测试图片分类正确率 def accuracy(image_paths, candidates, text_embeddings, batch_size=64): correct_count = 0 total_count = len(image_paths) num_batches = (total_count + batch_size - 1) // batch_size for i in range(num_batches): start_idx = i * batch_size end_idx = min(start_idx + batch_size, total_count) batch_image_paths = image_paths[start_idx:end_idx] image_embeddings = get_image_embeddings(batch_image_paths) if image_embeddings is not None: similarities = cosine_similarity(image_embeddings, text_embeddings) predicted_indices = np.argmax(similarities, axis=1) for j, predicted_index in enumerate(predicted_indices): predicted_category = candidates[predicted_index].split(\\\" \\\")[-1] actual_category = os.path.basename(os.path.dirname(batch_image_paths[j])) if predicted_category == actual_category: correct_count += 1 accuracy = correct_count / total_count return accuracy # 图片分类 def flowerClassify(): image_paths = get_all_image_paths(\\\"./flower_photos\\\") candidates = get_candidates(\\\"./flower_photos\\\") text_embeddings = text_embedding(candidates) start_time = time.time() acc = accuracy(image_paths, candidates, text_embeddings, batch_size=64) end_time = time.time() print(f\\\"Time taken to test accuracy: {end_time - start_time:.2f} seconds\\\") print(f\\\"Accuracy: {acc * 100:.2f}%\\\") ##################################################################################################3 # 遍历 data 目录获取所有图片路径 def get_images_from_data_dir(): data_dir = os.path.join(current_dir, 'data') if not os.path.exists(data_dir): print(f\\\"Data directory {data_dir} does not exist.\\\") return [] return get_all_image_paths(data_dir) # 找到与文本最匹配的图片 def find_most_matching_image(text, image_paths): text_emb = text_embedding([text]) image_embeddings = get_image_embeddings(image_paths) if image_embeddings is None: return None similarities = cosine_similarity(text_emb, image_embeddings) most_matching_index = np.argmax(similarities) return image_paths[most_matching_index] # 根据文字搜索图片 def searchPicByText(): image_paths = get_images_from_data_dir() query_text = \\\"a photo of a sunflowers\\\" most_matching_image = find_most_matching_image(query_text, image_paths) if most_matching_image: print(f\\\"The most matching image for '{query_text}' is: {most_matching_image}\\\") try: img = Image.open(most_matching_image) plt.imshow(img) plt.axis('off') plt.title(f\\\"Most matching image for '{query_text}'\\\") plt.show() except Exception as e: print(f\\\"Error opening image: {e}\\\") else: print(\\\"No matching image found.\\\")\"]},\"15\":{\"h\":\"小结\",\"t\":[\"在计算机视觉领域，常见的迁移学习方法是首先在大规模数据集（如ImageNet）上进行预训练，然后在具体的下游任务上进行微调。这种预训练通常是基于有监督学习的，需要大量的数据标注，因此成本较高。近年来，出现了一些基于自监督的方法，包括基于对比学习的方法（如MoCo和SimCLR）和基于图像掩码的方法（如MAE和BeiT）。自监督方法的优势在于不再需要标注数据。然而，无论是有监督还是自监督方法，在迁移到下游任务时，都需要进行有监督微调，无法实现zero-shot学习。对于有监督模型，由于它们在预训练数据集上采用固定类别数的分类器，因此在新的数据集上需要定义新的分类器来重新训练。对于自监督模型，代理任务通常是辅助进行表征学习，在迁移到其他数据集时也需要加上新的分类器进行有监督训练。\",\"然而，在NLP领域，基于自回归或语言掩码的预训练方法已经相对成熟，预训练模型很容易直接zero-shot迁移到下游任务，例如OpenAI的GPT-3。这种差异一方面是由于文本和图像属于两个完全不同的模态，另一个原因是NLP模型可以利用从互联网上收集的大量文本。因此，问题来了：能否基于互联网上的大量文本来预训练视觉模型？\",\"实际上，之前已经有一些研究工作探讨了使用文本作为监督信号来训练视觉模型。例如，2016年的工作《Learning Visual Features from Large Weakly Supervised Data》将这个问题转化为一个多标签分类任务，预测图像对应的文本的词袋模型；2017年的工作《Learning Visual N-Grams from Web Data》进一步扩展了这个方法来预测n-grams。最近的一些工作采用新的模型架构和预训练方法来从文本学习视觉特征，例如VirTex基于transformer的语言模型，ICMLM基于语言掩码的方法，ConVIRT基于对比学习的方法。总体来看，这方面的工作并不多，主要是因为这些方法难以实现较高的性能，例如2017年的那篇工作只在ImageNet上实现了11.5%的zero-shot性能，这远远低于ImageNet上的SOTA。此外，还有另一个方向，即基于文本弱监督来提升性能，例如谷歌的BiT和ViT基于JFT-300M数据集来预训练模型在ImageNet上取得SOTA。JFT-300M数据集是谷歌从互联网上收集的，通过一些自动化的手段将web text转化为18291个类别，但存在一定的噪声。尽管谷歌基于JFT-300M数据集取得了较好的结果，但这些模型仍然采用固定类别的softmax分类器进行预训练，这大大限制了它们的迁移能力和扩展性。\",\"谷歌采用的弱监督方法与以往方法的一个主要区别在于规模，或者说在于计算能力和数据集的规模。JFT-300M数据集的规模达到了上亿级别，谷歌利用强大的计算能力进行了预训练。相比之下，VirTex、ICMLM和ConVIRT仅在10万级别的数据上训练了几天。为了弥补数据规模上的差距，OpenAI从网络上收集了4亿条数据进行实验。然而，新的问题出现了：应该采用什么样的方法来进行训练。\",\"OpenAI首先尝试了VirTex模型，该模型联合训练一个CNN和文本transformer来预测图像的文本描述（image caption），但发现这种方法的训练效率（根据ImageNet数据集上的zero-shot性能评估）还不如直接预测词袋模型（bag of words），两者的训练效率相差3倍。如果进一步采用ConVIRT，即基于对比学习的方法，训练效率可以提高4倍。出现这种差异的原因不难理解，因为训练数据集中的文本-图像对是从互联网收集的，存在一定的噪声，即文本和图像可能不完全匹配。在这种情况下，适当降低训练目标反而可能取得更好的效果。\",\"从任务难度来看，排序为：Transformer Language Model > Bag of Words Prediction > Bag of Words Contrastive (CLIP)。由于训练数据量和模型计算量较大，训练效率成为一个至关重要的因素。因此，作者最终选择了对比学习方法来进行训练。\"]},\"16\":{\"h\":\"大语言模型\"},\"17\":{\"h\":\"图解 Bert\",\"t\":[\"图解Bert & Bert文本分类实战\"]},\"18\":{\"h\":\"环境搭建\",\"t\":[\"按序执行以下命令完成环境搭建:\",\"git clone https://github.com/DA-southampton/Read_Bert_Code.git cd Read_Bert_Code conda create -n Read_Bert_Code python=3.9.22 conda activate Read_Bert_Code\",\"本文使用的是谷歌的中文预训练模型：chinese_L-12_H-768_A-12.zip，模型有点大，我就不上传了，如果本地不存在，就点击这里直接下载,或者直接命令行运行\",\"wget https://storage.googleapis.com/bert_models/2018_11_03/chinese_L-12_H-768_A-12.zip\",\"预训练模型下载下来之后，进行解压，然后将tf模型转为对应的pytorch版本即可。对应代码如下:\",\"export BERT_BASE_DIR=/Users/zhandaohong/Read_Bert_Code/chinese_L-12_H-768_A-12 python convert_tf_checkpoint_to_pytorch.py \\\\ --tf_checkpoint_path $BERT_BASE_DIR/bert_model.ckpt \\\\ --bert_config_file $BERT_BASE_DIR/bert_config.json \\\\ --pytorch_dump_path $BERT_BASE_DIR/pytorch_model.bin\",\"转化成功之后，将模型放入到仓库对应位置：\",\"Read_Bert_Code/bert_read_step_to_step/prev_trained_model/\",\"并重新命名为：\",\" bert-base-chinese\",\"其次是准备训练数据，这里我准备做一个文本分类任务，使用的是Tnews数据集，这个数据集来源是这里，分为训练，测试和开发集，我已经上传到了仓库中，具体位置在\",\"Read_Bert_Code/bert_read_step_to_step/chineseGLUEdatasets/tnews\",\"需要注意的一点是，因为我只是为了了解内部代码情况，所以准确度不是在我的考虑范围之内，所以我只是取其中的一部分数据，其中训练数据使用1k，测试数据使用1k，开发数据1k。\",\"准备就绪，使用pycharm导入项目，准备调试，我的调试文件是run_classifier.py文件，对应的参数为\",\"--model_type=bert --model_name_or_path=prev_trained_model/bert-base-chinese --task_name=\\\"tnews\\\" --do_train --do_eval --do_lower_case --data_dir=./chineseGLUEdatasets/tnews --max_seq_length=128 --per_gpu_train_batch_size=16 --per_gpu_eval_batch_size=16 --learning_rate=2e-5 --num_train_epochs=4.0 --logging_steps=100 --save_steps=100 --output_dir=./outputs/tnews_output/ --overwrite_output_dir\",\"然后启动 run_classifier.py 文件进行调试即可 , 所参考源仓库未提供requirements.txt文件，因此需要大家自行完成运行时缺失依赖包的安装。\"]},\"19\":{\"h\":\"数据预处理\",\"t\":[\"输入数据格式\",\"{ \\\"guid\\\": \\\"train-0\\\", \\\"label\\\": \\\"104\\\", // 文本分类任务: 文本对应的标签 \\\"text_a\\\": \\\"股票中的突破形态\\\", \\\"text_b\\\": null // NSP任务: 用于判断给出的两个句子是否连续 }\",\"NSP (Next Sentence Prediction)\",\"文本分词 & 借助字典映射为word id\",\"\\\"股票中的突破形态\\\" --> ['股', '票', '中', '的', '突', '破', '形', '态'] --> [5500, 4873, 704, 4638, 4960, 4788, 2501, 2578]\",\"对于字典中不存在的词 , 用 [UNK] 表示, 对应的id为 100\",\"过长截断策略\",\"添加特殊Token标记\",\"原序列添加特殊Token标记图\",\"[101, 5500, 4873, 704, 4638, 4960, 4788, 2501, 2578, 102]\",\"BertTokenizer中的特殊token id:\",\"[CLS]: 101\",\"[SEP]: 102\",\"[MASK]: 103\",\"[UNK]: 100\",\"[PAD]: 0\",\" # BertTokenizer def build_inputs_with_special_tokens(self, token_ids_0, token_ids_1=None): if token_ids_1 is None: return [self.cls_token_id] + token_ids_0 + [self.sep_token_id] cls = [self.cls_token_id] sep = [self.sep_token_id] return cls + token_ids_0 + sep + token_ids_1 + sep\",\"创建句子辨识列表，用以区分不同的句子\",\"token_type_ids作用图解\",\" # BertTokenizer def create_token_type_ids_from_sequences(self, token_ids_0, token_ids_1=None): \\\"\\\"\\\" Creates a mask from the two sequences passed to be used in a sequence-pair classification task. A BERT sequence pair mask has the following format: 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 | first sequence | second sequence if token_ids_1 is None, only returns the first portion of the mask (0's). \\\"\\\"\\\" sep = [self.sep_token_id] cls = [self.cls_token_id] if token_ids_1 is None: return len(cls + token_ids_0 + sep) * [0] return len(cls + token_ids_0 + sep) * [0] + len(token_ids_1 + sep) * [1]\",\"创建用以区分special tokens部分的mask列表\",\"special_tokens_mask作用图解\",\" # BertTokenizer def get_special_tokens_mask(self, token_ids_0, token_ids_1=None, already_has_special_tokens=False): if token_ids_1 is not None: return [1] + ([0] * len(token_ids_0)) + [1] + ([0] * len(token_ids_1)) + [1] return [1] + ([0] * len(token_ids_0)) + [1]\",\"超长截断\",\" # PreTrainedTokenizer if max_length and len(encoded_inputs[\\\"input_ids\\\"]) > max_length: encoded_inputs[\\\"input_ids\\\"] = encoded_inputs[\\\"input_ids\\\"][:max_length] encoded_inputs[\\\"token_type_ids\\\"] = encoded_inputs[\\\"token_type_ids\\\"][:max_length] encoded_inputs[\\\"special_tokens_mask\\\"] = encoded_inputs[\\\"special_tokens_mask\\\"][:max_length]\",\"生成padding部分的mask列表\",\"attention_mask作用图解\",\" # 生成注意力掩码，真实token对应1，填充token对应0 attention_mask = [1 if mask_padding_with_zero else 0] * len(input_ids)\",\"所有序列都填充到max_length长度,不足长度用padding填充\",\"填充过程图\",\" # 记录输入长度 input_len = len(input_ids) # 计算需要填充的长度 --- 所有输入序列等长，都等于max_length padding_length = max_length - len(input_ids) # 右填充 input_ids = input_ids + ([pad_token] * padding_length) attention_mask = attention_mask + ([0 if mask_padding_with_zero else 1] * padding_length) token_type_ids = token_type_ids + ([pad_token_segment_id] * padding_length)\",\"数据集中每一个样本最终都会解析得到一个InputFeatures\",\"InputFeatures组成图解\",\"features.append( InputFeatures(input_ids=input_ids, attention_mask=attention_mask, token_type_ids=token_type_ids, label=label, input_len=input_len))\",\"label 是当前文本对应的类别标签 input_len 是序列实际长度(含special tokens)\",\"数据集预处理完后，将InputFeatures List列表组装起来得到需要的DataSet\",\"dataset = TensorDataset(all_input_ids, all_attention_mask, all_token_type_ids, all_lens,all_labels)\"]},\"20\":{\"h\":\"模型架构\"},\"21\":{\"h\":\"DataLoader\",\"t\":[\" train_sampler = RandomSampler(train_dataset) if args.local_rank == -1 else DistributedSampler(train_dataset) train_dataloader = DataLoader(train_dataset, sampler=train_sampler, batch_size=args.train_batch_size,collate_fn=collate_fn)\",\"DataLoader 设置的回调方法cllote_fn负责对返回的一个batch，在返回前进行预处理:\",\"def collate_fn(batch): all_input_ids, all_attention_mask, all_token_type_ids, all_lens, all_labels = map(torch.stack, zip(*batch)) max_len = max(all_lens).item() # 计算当前批次中所有序列的实际最大长度 all_input_ids = all_input_ids[:, :max_len] # 按照本批次序列中最大长度进行截断: max_length --> max_len all_attention_mask = all_attention_mask[:, :max_len] all_token_type_ids = all_token_type_ids[:, :max_len] return all_input_ids, all_attention_mask, all_token_type_ids, all_labels\"]},\"22\":{\"h\":\"BertEmbeddings\",\"t\":[\"input embeddings = token embeddings + segmentation embeddings + position embeddings\",\"class BertEmbeddings(nn.Module): def __init__(self, config): super(BertEmbeddings, self).__init__() self.word_embeddings = nn.Embedding(config.vocab_size, config.hidden_size, padding_idx=0) self.position_embeddings = nn.Embedding(config.max_position_embeddings, config.hidden_size) self.token_type_embeddings = nn.Embedding(config.type_vocab_size, config.hidden_size) self.LayerNorm = BertLayerNorm(config.hidden_size, eps=config.layer_norm_eps) self.dropout = nn.Dropout(config.hidden_dropout_prob) def forward(self, input_ids, token_type_ids=None, position_ids=None): seq_length = input_ids.size(1) if position_ids is None: # 为当前批次中的每个序列样本生成一个位置序列: (1,2,3,4,5,...) , 构成一个位置序列矩阵 position_ids = torch.arange(seq_length, dtype=torch.long, device=input_ids.device) position_ids = position_ids.unsqueeze(0).expand_as(input_ids) if token_type_ids is None: token_type_ids = torch.zeros_like(input_ids) words_embeddings = self.word_embeddings(input_ids) position_embeddings = self.position_embeddings(position_ids) # 位置编码为可学习的矩阵 token_type_embeddings = self.token_type_embeddings(token_type_ids) # 让模型自己学会区分不同的句子 embeddings = words_embeddings + position_embeddings + token_type_embeddings embeddings = self.LayerNorm(embeddings) embeddings = self.dropout(embeddings) return embeddings\",\"嵌入向量生成过程图\"]},\"23\":{\"h\":\"BertEncoder\"},\"24\":{\"h\":\"BertLayer\",\"t\":[\"BertLayer模型结构图\",\"class BertIntermediate(nn.Module): def __init__(self, config): super(BertIntermediate, self).__init__() self.dense = nn.Linear(config.hidden_size, config.intermediate_size) # (768,3072) # 激活函数 - GLEU if isinstance(config.hidden_act, str) or (sys.version_info[0] == 2 and isinstance(config.hidden_act, unicode)): self.intermediate_act_fn = ACT2FN[config.hidden_act] else: self.intermediate_act_fn = config.hidden_act def forward(self, hidden_states): hidden_states = self.dense(hidden_states) hidden_states = self.intermediate_act_fn(hidden_states) # 激活函数 - GLEU return hidden_states class BertOutput(nn.Module): def __init__(self, config): super(BertOutput, self).__init__() self.dense = nn.Linear(config.intermediate_size, config.hidden_size) # (3072,768) self.LayerNorm = BertLayerNorm(config.hidden_size, eps=config.layer_norm_eps) self.dropout = nn.Dropout(config.hidden_dropout_prob) def forward(self, hidden_states, input_tensor): hidden_states = self.dense(hidden_states) hidden_states = self.dropout(hidden_states) hidden_states = self.LayerNorm(hidden_states + input_tensor) return hidden_states class BertLayer(nn.Module): def __init__(self, config): super(BertLayer, self).__init__() self.attention = BertAttention(config) self.intermediate = BertIntermediate(config) self.output = BertOutput(config) def forward(self, hidden_states, attention_mask=None): attention_output = self.attention(hidden_states, attention_mask) intermediate_output = self.intermediate(attention_output) layer_output = self.output(intermediate_output, attention_output) return layer_output\"]},\"25\":{\"h\":\"BertEncoder\",\"t\":[\"BertEncoder模型结构图\",\"class BertEncoder(nn.Module): def __init__(self, config): super(BertEncoder, self).__init__() self.layer = nn.ModuleList([BertLayer(config) for _ in range(config.num_hidden_layers)]) def forward(self, hidden_states, attention_mask=None, head_mask=None): for i, layer_module in enumerate(self.layer): hidden_states = layer_module(hidden_states, attention_mask, head_mask[i]) return hidden_states\"]},\"26\":{\"h\":\"BertPooler\",\"t\":[\"BertPooler模型结构图\",\"class BertPooler(nn.Module): def __init__(self, config): super(BertPooler, self).__init__() self.dense = nn.Linear(config.hidden_size, config.hidden_size) self.activation = nn.Tanh() def forward(self, hidden_states): # We \\\"pool\\\" the model by simply taking the hidden state corresponding # to the first token. first_token_tensor = hidden_states[:, 0] # CLS Token Context Embeddings pooled_output = self.dense(first_token_tensor) pooled_output = self.activation(pooled_output) return pooled_output\"]},\"27\":{\"h\":\"BertModel\",\"t\":[\"BertModel模型结构图\",\"class BertModel(BertPreTrainedModel): def __init__(self, config): super(BertModel, self).__init__(config) self.embeddings = BertEmbeddings(config) self.encoder = BertEncoder(config) self.pooler = BertPooler(config) self.init_weights() def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None): extended_attention_mask = attention_mask.unsqueeze(1).unsqueeze(2) extended_attention_mask = extended_attention_mask.to(dtype=next(self.parameters()).dtype) # fp16 compatibility extended_attention_mask = (1.0 - extended_attention_mask) * -10000.0 embedding_output = self.embeddings(input_ids, position_ids=position_ids, token_type_ids=token_type_ids) sequence_output = self.encoder(embedding_output, extended_attention_mask, # padding mask ) pooled_output = self.pooler(sequence_output) outputs = (sequence_output, pooled_output,) return outputs\"]},\"28\":{\"h\":\"BertForSequenceClassification\",\"t\":[\"BertForSequenceClassification模型结构图\",\"class BertForSequenceClassification(BertPreTrainedModel): def __init__(self, config): super(BertForSequenceClassification, self).__init__(config) self.num_labels = config.num_labels self.bert = BertModel(config) self.dropout = nn.Dropout(config.hidden_dropout_prob) self.classifier = nn.Linear(config.hidden_size, self.config.num_labels) self.init_weights() def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None, labels=None): outputs = self.bert(input_ids, attention_mask=attention_mask, # padding mask token_type_ids=token_type_ids, position_ids=position_ids, head_mask=head_mask) # None ? pooled_output = outputs[1] # 对于分类任务来说，只需要去除CLS Token用于分类任务即可 pooled_output = self.dropout(pooled_output) logits = self.classifier(pooled_output) outputs = (logits,) + outputs[2:] # add hidden states and attention if they are here if labels is not None: if self.num_labels == 1: # We are doing regression loss_fct = MSELoss() loss = loss_fct(logits.view(-1), labels.view(-1)) else: loss_fct = CrossEntropyLoss() loss = loss_fct(logits.view(-1, self.num_labels), labels.view(-1)) outputs = (loss,) + outputs return outputs # (loss), logits, (hidden_states), (attentions)\"]},\"29\":{\"h\":\"BertAttention\"},\"30\":{\"h\":\"BertSelfAttention\",\"t\":[\"多头自注意力计算流程图\",\"class BertSelfAttention(nn.Module): def __init__(self, config): super(BertSelfAttention, self).__init__() self.output_attentions = config.output_attentions self.num_attention_heads = config.num_attention_heads self.attention_head_size = int(config.hidden_size / config.num_attention_heads) self.all_head_size = self.num_attention_heads * self.attention_head_size self.query = nn.Linear(config.hidden_size, self.all_head_size) self.key = nn.Linear(config.hidden_size, self.all_head_size) self.value = nn.Linear(config.hidden_size, self.all_head_size) self.dropout = nn.Dropout(config.attention_probs_dropout_prob) def transpose_for_scores(self, x): new_x_shape = x.size()[:-1] + (self.num_attention_heads, self.attention_head_size) x = x.view(*new_x_shape) return x.permute(0, 2, 1, 3) def forward(self, hidden_states, attention_mask=None, head_mask=None): mixed_query_layer = self.query(hidden_states) mixed_key_layer = self.key(hidden_states) mixed_value_layer = self.value(hidden_states) # view 成多头格式: (batch,heads,seq_len,d_k) query_layer = self.transpose_for_scores(mixed_query_layer) key_layer = self.transpose_for_scores(mixed_key_layer) value_layer = self.transpose_for_scores(mixed_value_layer) # Take the dot product between \\\"query\\\" and \\\"key\\\" to get the raw attention scores. attention_scores = torch.matmul(query_layer, key_layer.transpose(-1, -2)) # (batch,heads,d_k,seq_len) attention_scores = attention_scores / math.sqrt(self.attention_head_size) if attention_mask is not None: # Apply the attention mask is (precomputed for all layers in BertModel forward() function) attention_scores = attention_scores + attention_mask # Normalize the attention scores to probabilities. attention_probs = nn.Softmax(dim=-1)(attention_scores) # This is actually dropping out entire tokens to attend to, which might # seem a bit unusual, but is taken from the original Transformer paper. attention_probs = self.dropout(attention_probs) context_layer = torch.matmul(attention_probs, value_layer) context_layer = context_layer.permute(0, 2, 1, 3).contiguous() new_context_layer_shape = context_layer.size()[:-2] + (self.all_head_size,) context_layer = context_layer.view(*new_context_layer_shape) # 合并头结果 return context_layer\"]},\"31\":{\"h\":\"BertSelfOutput\",\"t\":[\"BertSelfOutput计算流程图\",\"class BertSelfOutput(nn.Module): def __init__(self, config): super(BertSelfOutput, self).__init__() self.dense = nn.Linear(config.hidden_size, config.hidden_size) self.LayerNorm = BertLayerNorm(config.hidden_size, eps=config.layer_norm_eps) self.dropout = nn.Dropout(config.hidden_dropout_prob) # 残差链接 + 层归一化 def forward(self, hidden_states, input_tensor): hidden_states = self.dense(hidden_states) hidden_states = self.dropout(hidden_states) hidden_states = self.LayerNorm(hidden_states + input_tensor) return hidden_states\"]},\"32\":{\"h\":\"BertAttention\",\"t\":[\"BertAttention计算流程图\",\"class BertAttention(nn.Module): def __init__(self, config): super(BertAttention, self).__init__() self.self = BertSelfAttention(config) self.output = BertSelfOutput(config) def forward(self, input_tensor, attention_mask=None): self_outputs = self.self(input_tensor, attention_mask) # 多头自注意力机制 attention_output = self.output(self_outputs, input_tensor) return attention_output\"]},\"33\":{\"h\":\"图解Transformer\",\"t\":[\"图解Transformer & 机器翻译实战\"]},\"34\":{\"h\":\"环境\",\"t\":[\"本文基于 The Annotated Transformer 所提供的代码展开进行讲解。\",\"环境搭建遵从如下步骤即可:\",\"git clone https://github.com/harvardnlp/annotated-transformer cd annotated-transformer conda create -n annotated-transformer python=3.9.22 conda activate annotated-transformer pip install -r requirements.txt\",\"MacOS 用户本地运行时，需要将 requirements.txt 文件中的 torch == 1.11.0+cu113 改为 torch==1.11.0，因为CUDA不支持MacOS。\"]},\"35\":{\"h\":\"背景\",\"t\":[\"RNN等模型的缺点是需要顺序计算，从而很难并行。因此出现了Extended Neural GPU、ByteNet和ConvS2S等网络模型。这些模型都是以CNN为基础，这比较容易并行。但是和RNN相比，它较难学习到长距离的依赖关系。\",\"本文的Transformer使用了Self-Attention机制，它在编码每一词的时候都能够注意(attend to)整个句子，从而可以解决长距离依赖的问题，同时计算Self-Attention可以用矩阵乘法一次计算所有的时刻，因此可以充分利用计算资源(CPU/GPU上的矩阵运算都是充分优化和高度并行的)。\"]},\"36\":{\"h\":\"模型架构\",\"t\":[\"Transformer 模型架构图\",\"Transformer 是一种基于自注意力机制(Self-Attention) 的神经网络架构,其由七大主要部分构成:\",\"Encoder-Decoder 结构\",\"编码器(Encoder)：将输入序列（如句子）转换为一系列高维向量表示。\",\"解码器(Decoder)：根据编码器的输出生成目标序列（如翻译后的句子）。\",\"多头自注意力机制（Multi-Head Self-Attention）\",\"自注意力机制是 Transformer 的核心，它允许模型在处理每个词时关注输入序列中的所有词。\",\"多头自注意力机制通过并行计算多个注意力头，捕捉不同子空间的信息，从而增强模型的表达能力。\",\"位置编码（Positional Encoding）\",\"由于 Transformer 不使用传统的循环或卷积结构，它通过位置编码将序列中词的位置信息注入到输入中。位置编码通常使用正弦和余弦函数生成。\",\"前馈神经网络（Feed-Forward Neural Network）\",\"在自注意力机制之后，每个位置的输出会通过一个独立的前馈神经网络进行进一步处理。\",\"残差连接与层归一化（Residual Connection & Layer Normalization）\",\"每个子层（如自注意力层和前馈层）都使用了残差连接和层归一化，以加速训练并提高模型的稳定性。\",\"掩码机制（Masking）\",\"在解码器中，使用掩码机制确保模型在生成目标序列时只能看到当前及之前的词，而不能看到未来的词。\",\"在输入序列长度不一致时，通过填充掩码（Padding Mask）屏蔽填充部分的信息。\",\"输出层\",\"解码器的最终输出通过一个线性层和 Softmax 函数生成目标序列的概率分布。\"]},\"37\":{\"h\":\"Encoder-Decoder 结构\",\"t\":[\"EncoderDecoder模型结构图\",\"class EncoderDecoder(nn.Module): def __init__(self, encoder, decoder, src_embed, tgt_embed, generator): super(EncoderDecoder, self).__init__() self.encoder = encoder self.decoder = decoder self.src_embed = src_embed self.tgt_embed = tgt_embed self.generator = generator def forward(self, src, tgt, src_mask, tgt_mask): \\\"Take in and process masked src and target sequences.\\\" return self.decode(self.encode(src, src_mask), src_mask, tgt, tgt_mask) def encode(self, src, src_mask): return self.encoder(self.src_embed(src), src_mask) def decode(self, memory, src_mask, tgt, tgt_mask): return self.decoder(self.tgt_embed(tgt), memory, src_mask, tgt_mask)\"]},\"38\":{\"h\":\"Generator\",\"t\":[\"Generator模型结构图\",\"class Generator(nn.Module): # 根据Decoder的隐状态输出一个词 # d_model是Decoder输出的大小，vocab是词典大小 def __init__(self, d_model, vocab): super(Generator, self).__init__() self.proj = nn.Linear(d_model, vocab) # 全连接再加上一个softmax def forward(self, x): return F.log_softmax(self.proj(x), dim=-1)\"]},\"39\":{\"h\":\"Encoder 结构\"},\"40\":{\"h\":\"SublayerConnection\",\"t\":[\"SublayerConnection模型结构图\",\"class SublayerConnection(nn.Module): \\\"\\\"\\\" LayerNorm + sublayer(Self-Attenion/Dense) + dropout + 残差连接 为了简单，把LayerNorm放到了前面，这和原始论文稍有不同，原始论文LayerNorm在最后。 \\\"\\\"\\\" def __init__(self, size, dropout): super(SublayerConnection, self).__init__() self.norm = LayerNorm(size) self.dropout = nn.Dropout(dropout) def forward(self, x, sublayer): \\\"sublayer是传入的参数，参考DecoderLayer，它可以当成函数调用，这个函数的有一个输入参数\\\" return x + self.dropout(sublayer(self.norm(x)))\"]},\"41\":{\"h\":\"EncoderLayer\",\"t\":[\"EncoderLayer模型结构图\",\"# 编码器层 = 自注意力子层 + 前馈层 class EncoderLayer(nn.Module): def __init__(self, size, self_attn, feed_forward, dropout): super(EncoderLayer, self).__init__() self.self_attn = self_attn self.feed_forward = feed_forward # 自注意力子层 和 前馈层 各需要一个 self.sublayer = clones(SublayerConnection(size, dropout), 2) self.size = size def forward(self, x, mask): \\\"Follow Figure 1 (left) for connections.\\\" x = self.sublayer[0](x, lambda x: self.self_attn(x, x, x, mask)) return self.sublayer[1](x, self.feed_forward)\"]},\"42\":{\"h\":\"Encoder\",\"t\":[\"Encoder模型结构图\",\"class Encoder(nn.Module): \\\"Core encoder is a stack of N layers\\\" def __init__(self, layer, N): super(Encoder, self).__init__() self.layers = clones(layer, N) self.norm = LayerNorm(layer.size) def forward(self, x, mask): \\\"Pass the input (and mask) through each layer in turn.\\\" for layer in self.layers: x = layer(x, mask) return self.norm(x)\"]},\"43\":{\"h\":\"Decoder 结构\"},\"44\":{\"h\":\"DecoderLayer\",\"t\":[\"Decoder模型结构图\",\"# 解码器层 = 自注意力子层 + 源注意力子层 + 前馈层 class DecoderLayer(nn.Module): \\\"Decoder is made of self-attn, src-attn, and feed forward (defined below)\\\" def __init__(self, size, self_attn, src_attn, feed_forward, dropout): super(DecoderLayer, self).__init__() self.size = size self.self_attn = self_attn self.src_attn = src_attn self.feed_forward = feed_forward # 自注意力子层 + 源注意力子层 + 前馈层 各需要一个 self.sublayer = clones(SublayerConnection(size, dropout), 3) def forward(self, x, memory, src_mask, tgt_mask): \\\"Follow Figure 1 (right) for connections.\\\" m = memory x = self.sublayer[0](x, lambda x: self.self_attn(x, x, x, tgt_mask)) x = self.sublayer[1](x, lambda x: self.src_attn(x, m, m, src_mask)) return self.sublayer[2](x, self.feed_forward)\"]},\"45\":{\"h\":\"Decoder\",\"t\":[\"Decoder模型结构图\",\"# 解码器 = N个解码器层 + 层归一化 class Decoder(nn.Module): \\\"Generic N layer decoder with masking.\\\" def __init__(self, layer, N): super(Decoder, self).__init__() self.layers = clones(layer, N) self.norm = LayerNorm(layer.size) def forward(self, x, memory, src_mask, tgt_mask): # 输入,编码器隐藏层输出,源掩码,目标掩码 for layer in self.layers: x = layer(x, memory, src_mask, tgt_mask) return self.norm(x)\"]},\"46\":{\"h\":\"多头自注意力\",\"t\":[\"多头自注意力计算流程图\",\"class MultiHeadedAttention(nn.Module): def __init__(self, h, d_model, dropout=0.1): \\\"Take in model size and number of heads.\\\" super(MultiHeadedAttention, self).__init__() assert d_model % h == 0 # We assume d_v always equals d_k self.d_k = d_model // h # 每个头64维 self.h = h # 8个头 self.linears = clones(nn.Linear(d_model, d_model), 4) # W_q,W_k,W_v,W_projection self.attn = None self.dropout = nn.Dropout(p=dropout) def forward(self, query, key, value, mask=None): \\\"Implements Figure 2\\\" if mask is not None: # Same mask applied to all h heads. mask = mask.unsqueeze(1) nbatches = query.size(0) # 1) Do all the linear projections in batch from d_model => h x d_k query, key, value = [ lin(x).view(nbatches, -1, self.h, self.d_k).transpose(1, 2) # (batches,heads,seq_len,d_k) for lin, x in zip(self.linears, (query, key, value)) ] # 2) Apply attention on all the projected vectors in batch. x, self.attn = attention( query, key, value, mask=mask, dropout=self.dropout ) # 3) \\\"Concat\\\" using a view and apply a final linear. x = ( x.transpose(1, 2) .contiguous() .view(nbatches, -1, self.h * self.d_k) ) del query del key del value return self.linears[-1](x)\",\"def attention(query, key, value, mask=None, dropout=None): \\\"Compute 'Scaled Dot Product Attention'\\\" d_k = query.size(-1) scores = torch.matmul(query, key.transpose(-2, -1)) / math.sqrt(d_k) if mask is not None: scores = scores.masked_fill(mask == 0, -1e9) # 广播: (1,1,1,10) ---> (1,8,10,10) p_attn = scores.softmax(dim=-1) if dropout is not None: p_attn = dropout(p_attn) return torch.matmul(p_attn, value), p_attn\"]},\"47\":{\"h\":\"开源项目\"},\"48\":{\"h\":\"杂谈\"},\"49\":{\"h\":\"\",\"t\":[\"404 Not Found\"]}},\"dirtCount\":0,\"index\":[[\"杂谈\",{\"0\":{\"48\":1}}],[\"8\",{\"1\":{\"46\":1}}],[\"8个头\",{\"1\":{\"46\":1}}],[\"广播\",{\"1\":{\"46\":1}}],[\"广泛应用于各类计算机视觉任务\",{\"1\":{\"7\":1}}],[\"q\",{\"1\":{\"46\":1}}],[\"query\",{\"1\":{\"13\":4,\"14\":4,\"30\":7,\"46\":9}}],[\"目标掩码\",{\"1\":{\"45\":1}}],[\"目录获取所有图片路径\",{\"1\":{\"13\":1,\"14\":1}}],[\"源掩码\",{\"1\":{\"45\":1}}],[\"源注意力子层\",{\"1\":{\"44\":2}}],[\"各需要一个\",{\"1\":{\"41\":1,\"44\":1}}],[\"前馈层\",{\"1\":{\"41\":2,\"44\":2}}],[\"前馈神经网络\",{\"1\":{\"36\":1}}],[\"参考decoderlayer\",{\"1\":{\"40\":1}}],[\"原始论文layernorm在最后\",{\"1\":{\"40\":1}}],[\"原序列添加特殊token标记图\",{\"1\":{\"19\":1}}],[\"把layernorm放到了前面\",{\"1\":{\"40\":1}}],[\"全连接再加上一个softmax\",{\"1\":{\"38\":1}}],[\"输出层\",{\"1\":{\"36\":1}}],[\"输入\",{\"1\":{\"45\":1}}],[\"输入数据格式\",{\"1\":{\"19\":1}}],[\"输入image\",{\"1\":{\"10\":1}}],[\"屏蔽填充部分的信息\",{\"1\":{\"36\":1}}],[\"掩码机制\",{\"1\":{\"36\":1}}],[\"每个头64维\",{\"1\":{\"46\":1}}],[\"每个子层\",{\"1\":{\"36\":1}}],[\"每个位置的输出会通过一个独立的前馈神经网络进行进一步处理\",{\"1\":{\"36\":1}}],[\"残差连接\",{\"1\":{\"40\":1}}],[\"残差连接与层归一化\",{\"1\":{\"36\":1}}],[\"残差链接\",{\"1\":{\"31\":1}}],[\"不使用传统的循环或卷积结构\",{\"1\":{\"36\":1}}],[\"不足长度用padding填充\",{\"1\":{\"19\":1}}],[\"位置编码通常使用正弦和余弦函数生成\",{\"1\":{\"36\":1}}],[\"位置编码\",{\"1\":{\"36\":1}}],[\"位置编码为可学习的矩阵\",{\"1\":{\"22\":1}}],[\"捕捉不同子空间的信息\",{\"1\":{\"36\":1}}],[\"解码器层\",{\"1\":{\"44\":1}}],[\"解码器的最终输出通过一个线性层和\",{\"1\":{\"36\":1}}],[\"解码器\",{\"1\":{\"36\":1,\"45\":1}}],[\"编码器隐藏层输出\",{\"1\":{\"45\":1}}],[\"编码器层\",{\"1\":{\"41\":1}}],[\"编码器\",{\"1\":{\"36\":1}}],[\"结构\",{\"0\":{\"37\":1,\"39\":1,\"43\":1},\"1\":{\"36\":1}}],[\"结果发现在imagenet数据集上能够带来3\",{\"1\":{\"11\":1}}],[\"整个句子\",{\"1\":{\"35\":1}}],[\"背景\",{\"0\":{\"35\":1}}],[\"改为\",{\"1\":{\"34\":1}}],[\"环境\",{\"0\":{\"34\":1}}],[\"环境搭建遵从如下步骤即可\",{\"1\":{\"34\":1}}],[\"环境搭建\",{\"0\":{\"18\":1}}],[\"机器翻译实战\",{\"1\":{\"33\":1}}],[\"层归一化\",{\"1\":{\"31\":1,\"45\":1}}],[\"合并头结果\",{\"1\":{\"30\":1}}],[\"k\",{\"1\":{\"30\":2,\"46\":9}}],[\"key\",{\"1\":{\"30\":7,\"46\":7}}],[\"keepdims=true\",{\"1\":{\"12\":1,\"14\":1}}],[\"keepdim=true\",{\"1\":{\"10\":2}}],[\"成多头格式\",{\"1\":{\"30\":1}}],[\"x\",{\"1\":{\"30\":7,\"38\":2,\"40\":3,\"41\":8,\"42\":4,\"44\":12,\"45\":4,\"46\":7}}],[\"多头自注意力\",{\"0\":{\"46\":1}}],[\"多头自注意力机制通过并行计算多个注意力头\",{\"1\":{\"36\":1}}],[\"多头自注意力机制\",{\"1\":{\"32\":1,\"36\":1}}],[\"多头自注意力计算流程图\",{\"1\":{\"30\":1,\"46\":1}}],[\"多模态模型clip原理与图片分类\",{\"1\":{\"6\":1}}],[\"多模态\",{\"0\":{\"5\":1}}],[\"只需要去除cls\",{\"1\":{\"28\":1}}],[\"激活函数\",{\"1\":{\"24\":2}}],[\"嵌入向量生成过程图\",{\"1\":{\"22\":1}}],[\"让模型自己学会区分不同的句子\",{\"1\":{\"22\":1}}],[\"构成一个位置序列矩阵\",{\"1\":{\"22\":1}}],[\"构建描述文本并提取特征\",{\"1\":{\"10\":1}}],[\"设置的回调方法cllote\",{\"1\":{\"21\":1}}],[\"含special\",{\"1\":{\"19\":1}}],[\"是一种基于自注意力机制\",{\"1\":{\"36\":1}}],[\"是序列实际长度\",{\"1\":{\"19\":1}}],[\"是当前文本对应的类别标签\",{\"1\":{\"19\":1}}],[\"是基于文本输入来生成图像的模型\",{\"1\":{\"7\":1}}],[\"右填充\",{\"1\":{\"19\":1}}],[\"都使用了残差连接和层归一化\",{\"1\":{\"36\":1}}],[\"都等于max\",{\"1\":{\"19\":1}}],[\"都需要进行有监督微调\",{\"1\":{\"15\":1}}],[\"记录输入长度\",{\"1\":{\"19\":1}}],[\"填充过程图\",{\"1\":{\"19\":1}}],[\"填充token对应0\",{\"1\":{\"19\":1}}],[\"真实token对应1\",{\"1\":{\"19\":1}}],[\"超长截断\",{\"1\":{\"19\":1}}],[\"创建用以区分special\",{\"1\":{\"19\":1}}],[\"创建句子辨识列表\",{\"1\":{\"19\":1}}],[\"|\",{\"1\":{\"19\":2}}],[\"添加特殊token标记\",{\"1\":{\"19\":1}}],[\"过长截断策略\",{\"1\":{\"19\":1}}],[\"表示\",{\"1\":{\"19\":1}}],[\"using\",{\"1\":{\"46\":1}}],[\"used\",{\"1\":{\"19\":1}}],[\"users\",{\"1\":{\"18\":1}}],[\"use\",{\"1\":{\"12\":1,\"14\":1}}],[\"unusual\",{\"1\":{\"30\":1}}],[\"unicode\",{\"1\":{\"24\":1}}],[\"unsqueeze\",{\"1\":{\"22\":1,\"27\":2,\"46\":1}}],[\"unk\",{\"1\":{\"19\":2}}],[\"404\",{\"1\":{\"49\":1}}],[\"4\",{\"1\":{\"22\":1,\"46\":1}}],[\"4788\",{\"1\":{\"19\":2}}],[\"4960\",{\"1\":{\"19\":2}}],[\"4638\",{\"1\":{\"19\":2}}],[\"4873\",{\"1\":{\"19\":2}}],[\"48\",{\"1\":{\"12\":1}}],[\"704\",{\"1\":{\"19\":2}}],[\"768\",{\"1\":{\"18\":3,\"24\":2}}],[\"态\",{\"1\":{\"19\":1}}],[\"形\",{\"1\":{\"19\":1}}],[\"破\",{\"1\":{\"19\":1}}],[\"突\",{\"1\":{\"19\":1}}],[\"票\",{\"1\":{\"19\":1}}],[\"股\",{\"1\":{\"19\":1}}],[\"股票中的突破形态\",{\"1\":{\"19\":2}}],[\"借助字典映射为word\",{\"1\":{\"19\":1}}],[\"借助对比学习机制\",{\"1\":{\"8\":1}}],[\"数据集预处理完后\",{\"1\":{\"19\":1}}],[\"数据集中每一个样本最终都会解析得到一个inputfeatures\",{\"1\":{\"19\":1}}],[\"数据预处理\",{\"0\":{\"19\":1}}],[\"数组后\",{\"1\":{\"12\":1}}],[\"数组格式返回\",{\"1\":{\"12\":1}}],[\"准备调试\",{\"1\":{\"18\":1}}],[\"准备就绪\",{\"1\":{\"18\":1}}],[\"开发数据1k\",{\"1\":{\"18\":1}}],[\"开源项目\",{\"0\":{\"47\":1}}],[\"开源网络库\",{\"1\":{\"2\":1}}],[\"开源框架\",{\"1\":{\"2\":1}}],[\"所提供的代码展开进行讲解\",{\"1\":{\"34\":1}}],[\"所有输入序列等长\",{\"1\":{\"19\":1}}],[\"所有序列都填充到max\",{\"1\":{\"19\":1}}],[\"所有模型均训练了32个周期\",{\"1\":{\"9\":1}}],[\"所参考源仓库未提供requirements\",{\"1\":{\"18\":1}}],[\"所以我只是取其中的一部分数据\",{\"1\":{\"18\":1}}],[\"所以准确度不是在我的考虑范围之内\",{\"1\":{\"18\":1}}],[\"需要将\",{\"1\":{\"34\":1}}],[\"需要注意的一点是\",{\"1\":{\"18\":1}}],[\"需要大量的数据标注\",{\"1\":{\"15\":1}}],[\"测试数据使用1k\",{\"1\":{\"18\":1}}],[\"测试和开发集\",{\"1\":{\"18\":1}}],[\"测试图片分类正确率\",{\"1\":{\"12\":1,\"14\":1}}],[\"$bert\",{\"1\":{\"18\":3}}],[\"zeros\",{\"1\":{\"22\":1}}],[\"zero\",{\"1\":{\"19\":2}}],[\"zhandaohong\",{\"1\":{\"18\":1}}],[\"zip\",{\"1\":{\"18\":2,\"21\":1,\"46\":1}}],[\"进行解压\",{\"1\":{\"18\":1}}],[\"进一步扩展了这个方法来预测n\",{\"1\":{\"15\":1}}],[\"进一步地\",{\"1\":{\"10\":1}}],[\"或者直接命令行运行\",{\"1\":{\"18\":1}}],[\"或者说在于计算能力和数据集的规模\",{\"1\":{\"15\":1}}],[\"就点击这里直接下载\",{\"1\":{\"18\":1}}],[\"我的调试文件是run\",{\"1\":{\"18\":1}}],[\"我已经上传到了仓库中\",{\"1\":{\"18\":1}}],[\"我就不上传了\",{\"1\":{\"18\":1}}],[\"我们首先获取图片库中所有图片\",{\"1\":{\"13\":1}}],[\"我们首先创建了各类别的文本描述\",{\"1\":{\"10\":1}}],[\"我们只需要在计算出相似度得分矩阵后\",{\"1\":{\"13\":1}}],[\"我们从flower\",{\"1\":{\"12\":1}}],[\"我们需要根据上面给出的花卉数据集下载链接\",{\"1\":{\"12\":1}}],[\"我们常常需要衡量文本嵌入和图片嵌入之间的相似度\",{\"1\":{\"12\":1}}],[\"我们可以直接使用类别标签作为文本描述\",{\"1\":{\"11\":1}}],[\"我们还有其他的选择\",{\"1\":{\"11\":1}}],[\"我们使用了\",{\"1\":{\"11\":1}}],[\"我们也可以对得到的余弦相似度计算softmax\",{\"1\":{\"10\":1}}],[\"我们通过利用clip模型的多模态能力\",{\"1\":{\"10\":1}}],[\"我们已经探讨了clip模型的运作机制\",{\"1\":{\"10\":1}}],[\"本文的transformer使用了self\",{\"1\":{\"35\":1}}],[\"本文基于\",{\"1\":{\"34\":1}}],[\"本文使用的是谷歌的中文预训练模型\",{\"1\":{\"18\":1}}],[\"本节我们将基于clip预训练模型实现zero\",{\"1\":{\"12\":1}}],[\"9\",{\"1\":{\"18\":1,\"34\":1}}],[\"95\",{\"1\":{\"12\":1}}],[\"按序执行以下命令完成环境搭建\",{\"1\":{\"18\":1}}],[\"按照本批次序列中最大长度进行截断\",{\"1\":{\"21\":1}}],[\"按照余弦相似度的数学公式来计算两者的相似度数值\",{\"1\":{\"12\":1}}],[\"按照最大相似度\",{\"1\":{\"10\":1}}],[\"大语言模型\",{\"0\":{\"16\":1}}],[\"大放异彩的一年\",{\"1\":{\"7\":1}}],[\"作者最终选择了对比学习方法来进行训练\",{\"1\":{\"15\":1}}],[\"作为图像的分类预测结果\",{\"1\":{\"10\":1}}],[\">\",{\"1\":{\"15\":2,\"19\":3,\"21\":1,\"46\":1}}],[\"排序为\",{\"1\":{\"15\":1}}],[\"适当降低训练目标反而可能取得更好的效果\",{\"1\":{\"15\":1}}],[\"存在一定的噪声\",{\"1\":{\"15\":1}}],[\"因为cuda不支持macos\",{\"1\":{\"34\":1}}],[\"因为我只是为了了解内部代码情况\",{\"1\":{\"18\":1}}],[\"因为训练数据集中的文本\",{\"1\":{\"15\":1}}],[\"因此可以充分利用计算资源\",{\"1\":{\"35\":1}}],[\"因此出现了extended\",{\"1\":{\"35\":1}}],[\"因此需要大家自行完成运行时缺失依赖包的安装\",{\"1\":{\"18\":1}}],[\"因此\",{\"1\":{\"15\":2}}],[\"因此在新的数据集上需要定义新的分类器来重新训练\",{\"1\":{\"15\":1}}],[\"因此在效果上可能不如使用\",{\"1\":{\"11\":1}}],[\"因此成本较高\",{\"1\":{\"15\":1}}],[\"因此这里就不再给出数据集下载链接了\",{\"1\":{\"12\":1}}],[\"因此这是一个非常庞大的数据集\",{\"1\":{\"9\":1}}],[\"出现这种差异的原因不难理解\",{\"1\":{\"15\":1}}],[\"出现了一些基于自监督的方法\",{\"1\":{\"15\":1}}],[\"两者的训练效率相差3倍\",{\"1\":{\"15\":1}}],[\"应该采用什么样的方法来进行训练\",{\"1\":{\"15\":1}}],[\"新的问题出现了\",{\"1\":{\"15\":1}}],[\"相比之下\",{\"1\":{\"15\":1}}],[\"相似度如下所示\",{\"1\":{\"10\":1}}],[\"谷歌利用强大的计算能力进行了预训练\",{\"1\":{\"15\":1}}],[\"谷歌采用的弱监督方法与以往方法的一个主要区别在于规模\",{\"1\":{\"15\":1}}],[\"尽管谷歌基于jft\",{\"1\":{\"15\":1}}],[\"尽管clip是一个多模态模型\",{\"1\":{\"9\":1}}],[\"还不如直接预测词袋模型\",{\"1\":{\"15\":1}}],[\"还有另一个方向\",{\"1\":{\"15\":1}}],[\"还在336的分辨率下额外进行了一个周期的微调\",{\"1\":{\"9\":1}}],[\"主要是因为这些方法难以实现较高的性能\",{\"1\":{\"15\":1}}],[\"主页\",{\"0\":{\"0\":1}}],[\"总体来看\",{\"1\":{\"15\":1}}],[\"预测图像对应的文本的词袋模型\",{\"1\":{\"15\":1}}],[\"预训练模型下载下来之后\",{\"1\":{\"18\":1}}],[\"预训练模型很容易直接zero\",{\"1\":{\"15\":1}}],[\"预训练模型中\",{\"1\":{\"12\":1}}],[\"预训练模型名称\",{\"1\":{\"12\":1}}],[\"之前已经有一些研究工作探讨了使用文本作为监督信号来训练视觉模型\",{\"1\":{\"15\":1}}],[\"之后\",{\"1\":{\"7\":1}}],[\"实际上\",{\"1\":{\"15\":1}}],[\"实现zero\",{\"1\":{\"10\":1}}],[\"能否基于互联网上的大量文本来预训练视觉模型\",{\"1\":{\"15\":1}}],[\"问题来了\",{\"1\":{\"15\":1}}],[\"另一个原因是nlp模型可以利用从互联网上收集的大量文本\",{\"1\":{\"15\":1}}],[\"另一种是基于\",{\"1\":{\"9\":1}}],[\"基于自回归或语言掩码的预训练方法已经相对成熟\",{\"1\":{\"15\":1}}],[\"代理任务通常是辅助进行表征学习\",{\"1\":{\"15\":1}}],[\"无法实现zero\",{\"1\":{\"15\":1}}],[\"无论是有监督还是自监督方法\",{\"1\":{\"15\":1}}],[\"自注意力子层\",{\"1\":{\"41\":2,\"44\":2}}],[\"自注意力机制是\",{\"1\":{\"36\":1}}],[\"自监督方法的优势在于不再需要标注数据\",{\"1\":{\"15\":1}}],[\"自谷歌提出\",{\"1\":{\"7\":1}}],[\"包括基于对比学习的方法\",{\"1\":{\"15\":1}}],[\"近年来\",{\"1\":{\"15\":1}}],[\"上进行预训练\",{\"1\":{\"15\":1}}],[\"上面的花卉分类案例相当于使用图像去匹配最合适的文本描述\",{\"1\":{\"13\":1}}],[\"常见的迁移学习方法是首先在大规模数据集\",{\"1\":{\"15\":1}}],[\"小结\",{\"0\":{\"15\":1}}],[\"小红书\",{\"1\":{\"0\":1}}],[\"完整代码\",{\"0\":{\"14\":1}}],[\"搜索出来的图片\",{\"1\":{\"13\":1}}],[\"运行上述代码\",{\"1\":{\"13\":1}}],[\"遍历\",{\"1\":{\"13\":1,\"14\":1}}],[\"遍历data目录\",{\"1\":{\"13\":1}}],[\"拿到所有图片路径\",{\"1\":{\"13\":1}}],[\"下面来实际展示一下效果\",{\"1\":{\"13\":1}}],[\"找到与文本最匹配的图片\",{\"1\":{\"13\":1,\"14\":1}}],[\"取出该行中得分最大的那一列\",{\"1\":{\"13\":1}}],[\"取出当前批次的图像列表\",{\"1\":{\"12\":1}}],[\"用户本地运行时\",{\"1\":{\"34\":1}}],[\"用以区分不同的句子\",{\"1\":{\"19\":1}}],[\"用\",{\"1\":{\"19\":1}}],[\"用于判断给出的两个句子是否连续\",{\"1\":{\"19\":1}}],[\"用文本描述去匹配最合适的图片内容\",{\"1\":{\"13\":1}}],[\"用当前图片外层目录的名字作为其分类名词\",{\"1\":{\"12\":1}}],[\"62\",{\"1\":{\"12\":1}}],[\"比较两个分类名词是否相等\",{\"1\":{\"12\":1}}],[\"从而增强模型的表达能力\",{\"1\":{\"36\":1}}],[\"从而可以解决长距离依赖的问题\",{\"1\":{\"35\":1}}],[\"从而很难并行\",{\"1\":{\"35\":1}}],[\"从任务难度来看\",{\"1\":{\"15\":1}}],[\"从候选分类文本集合中取出其分类名词\",{\"1\":{\"12\":1}}],[\"从数据对的数量来看\",{\"1\":{\"9\":1}}],[\"根据decoder的隐状态输出一个词\",{\"1\":{\"38\":1}}],[\"根据编码器的输出生成目标序列\",{\"1\":{\"36\":1}}],[\"根据imagenet数据集上的zero\",{\"1\":{\"15\":1}}],[\"根据文字搜索图片\",{\"1\":{\"13\":1,\"14\":1}}],[\"根据上述计算得到的和其相似度最高的分类文本索引\",{\"1\":{\"12\":1}}],[\"根据任务的分类需求\",{\"1\":{\"10\":1}}],[\"针对每张图像\",{\"1\":{\"12\":1}}],[\"针对每个图像嵌入向量获取和其相似度最高的分类文本嵌入向量索引下标\",{\"1\":{\"12\":1}}],[\"针对每个图像嵌入向量取出和其相似度最高的那个文本嵌入向量的索引\",{\"1\":{\"12\":1}}],[\"统计正确率\",{\"1\":{\"12\":1}}],[\"判断预测是否正确\",{\"1\":{\"12\":1}}],[\"获取其对应的图像嵌入向量列表\",{\"1\":{\"12\":1}}],[\"获取候选分类名列表\",{\"1\":{\"12\":1,\"14\":1}}],[\"分为训练\",{\"1\":{\"18\":1}}],[\"分批次预测\",{\"1\":{\"12\":1}}],[\"分批次从图像列表中取出一批图像\",{\"1\":{\"12\":1}}],[\"分别基于lenet\",{\"1\":{\"12\":1}}],[\"分别提取图像特征和文本特征\",{\"1\":{\"9\":1}}],[\"分别是文本编码器\",{\"1\":{\"9\":1}}],[\"子目录名的格式\",{\"1\":{\"12\":1}}],[\"递归遍历目录获取所有图片路径\",{\"1\":{\"12\":1,\"14\":1}}],[\"会进行相应的错误提示并返回\",{\"1\":{\"12\":1}}],[\"读取图片并将其转换为合适的格式后\",{\"1\":{\"12\":1}}],[\"该模型联合训练一个cnn和文本transformer来预测图像的文本描述\",{\"1\":{\"15\":1}}],[\"该函数作用是针对给定的图片路径\",{\"1\":{\"12\":1}}],[\"该示例中的任务涉及8个类别\",{\"1\":{\"10\":1}}],[\"方便后续的计算和比较\",{\"1\":{\"12\":1}}],[\"方向研究\",{\"1\":{\"2\":1}}],[\"生成注意力掩码\",{\"1\":{\"19\":1}}],[\"生成padding部分的mask列表\",{\"1\":{\"19\":1}}],[\"生成文本嵌入\",{\"1\":{\"12\":1,\"14\":1}}],[\"生成的文本特征相当于分类器的权重\",{\"1\":{\"10\":1}}],[\"函数生成目标序列的概率分布\",{\"1\":{\"36\":1}}],[\"函数\",{\"1\":{\"12\":1,\"14\":1}}],[\"版本\",{\"1\":{\"12\":1}}],[\"具体位置在\",{\"1\":{\"18\":1}}],[\"具体代码实现如下\",{\"1\":{\"13\":1}}],[\"具体使用的是\",{\"1\":{\"12\":1}}],[\"具体的实验结果可以参考clip公开的notebook\",{\"1\":{\"11\":1}}],[\"架构\",{\"1\":{\"12\":1}}],[\"加载模型和处理器\",{\"1\":{\"12\":1,\"14\":1}}],[\"检查当前目录是否有预训练权重文件\",{\"1\":{\"12\":1,\"14\":1}}],[\"json\",{\"1\":{\"18\":1}}],[\"jft\",{\"1\":{\"15\":2}}],[\"j\",{\"1\":{\"12\":2,\"14\":2}}],[\"jpeg\",{\"1\":{\"12\":1,\"14\":1}}],[\"jpg\",{\"1\":{\"12\":1,\"14\":1}}],[\"join\",{\"1\":{\"12\":3,\"13\":1,\"14\":4}}],[\"javaer\",{\"1\":{\"2\":1}}],[\"定义当前目录\",{\"1\":{\"12\":1,\"14\":1}}],[\"图解transformer\",{\"0\":{\"33\":1},\"1\":{\"33\":1}}],[\"图解bert\",{\"1\":{\"17\":1}}],[\"图解\",{\"0\":{\"17\":1}}],[\"图片库中的图片\",{\"1\":{\"13\":1}}],[\"图片分类\",{\"1\":{\"12\":1,\"14\":1}}],[\"图片分类实战\",{\"1\":{\"12\":1}}],[\"图像编码器采用了\",{\"1\":{\"12\":1}}],[\"图像特征提取与分类\",{\"1\":{\"10\":1}}],[\"图像对是从互联网收集的\",{\"1\":{\"15\":1}}],[\"图像对为负样本\",{\"1\":{\"9\":1}}],[\"图像对的相似度\",{\"1\":{\"9\":1}}],[\"图像对的训练batch\",{\"1\":{\"9\":1}}],[\"图像对的预训练方法\",{\"1\":{\"8\":1}}],[\"图像对\",{\"1\":{\"8\":1}}],[\"花卉图片分类\",{\"0\":{\"12\":1}}],[\"缺乏具体的上下文\",{\"1\":{\"11\":1}}],[\"由于\",{\"1\":{\"36\":1}}],[\"由于训练数据量和模型计算量较大\",{\"1\":{\"15\":1}}],[\"由于它们在预训练数据集上采用固定类别数的分类器\",{\"1\":{\"15\":1}}],[\"由于这些文本往往只是一个单词\",{\"1\":{\"11\":1}}],[\"由于数据量巨大\",{\"1\":{\"9\":1}}],[\"使用掩码机制确保模型在生成目标序列时只能看到当前及之前的词\",{\"1\":{\"36\":1}}],[\"使用pycharm导入项目\",{\"1\":{\"18\":1}}],[\"使用的是tnews数据集\",{\"1\":{\"18\":1}}],[\"使用adamw优化器\",{\"1\":{\"9\":1}}],[\"使其符合模型的输入要求\",{\"1\":{\"12\":1}}],[\"使得预训练模型能够直接应用于下游任务\",{\"1\":{\"11\":1}}],[\"提示\",{\"1\":{\"11\":1}}],[\"提取图像特征\",{\"1\":{\"10\":1}}],[\"提取文本特征\",{\"1\":{\"10\":1}}],[\"提取的图像特征则是分类器的输入数据\",{\"1\":{\"10\":1}}],[\"简单来说\",{\"1\":{\"11\":1}}],[\"关于这一领域的详细综述\",{\"1\":{\"11\":1}}],[\"关于我们\",{\"0\":{\"1\":1}}],[\"紧密相关\",{\"1\":{\"11\":1}}],[\"但是和rnn相比\",{\"1\":{\"35\":1}}],[\"但发现这种方法的训练效率\",{\"1\":{\"15\":1}}],[\"但这些模型仍然采用固定类别的softmax分类器进行预训练\",{\"1\":{\"15\":1}}],[\"但存在一定的噪声\",{\"1\":{\"15\":1}}],[\"但实际上\",{\"1\":{\"11\":1}}],[\"但其主要目的是训练可迁移的视觉模型\",{\"1\":{\"9\":1}}],[\"除了模型本身的应用\",{\"1\":{\"11\":1}}],[\"5500\",{\"1\":{\"19\":2}}],[\"5\",{\"1\":{\"10\":1,\"11\":1,\"15\":1,\"18\":1,\"22\":1}}],[\"0+cu113\",{\"1\":{\"34\":1}}],[\"03\",{\"1\":{\"18\":1}}],[\"0\",{\"1\":{\"10\":1,\"12\":1,\"14\":1,\"18\":1,\"19\":29,\"22\":1,\"24\":1,\"26\":1,\"27\":2,\"30\":2,\"34\":1,\"41\":1,\"44\":1,\"46\":3}}],[\"得到的预测概率如下所示\",{\"1\":{\"10\":1}}],[\"得到每个预测类别的概率值\",{\"1\":{\"10\":1}}],[\"得到相同维度的特征\",{\"1\":{\"9\":1}}],[\"计算当前批次中所有序列的实际最大长度\",{\"1\":{\"21\":1}}],[\"计算需要填充的长度\",{\"1\":{\"19\":1}}],[\"计算图像嵌入向量列表中每个图像对应的嵌入向量和传入的分类文本嵌入向量的余弦相似度\",{\"1\":{\"12\":1}}],[\"计算这批图像嵌入向量中每一个图像嵌入向量和我们所有分类文本嵌入向量的余弦相似度\",{\"1\":{\"12\":1}}],[\"计算余弦相似度\",{\"1\":{\"10\":1}}],[\"计算缩放的余弦相似度\",{\"1\":{\"9\":1}}],[\"显然\",{\"1\":{\"10\":1}}],[\"通过填充掩码\",{\"1\":{\"36\":1}}],[\"通过一些自动化的手段将web\",{\"1\":{\"15\":1}}],[\"通过模型获取图片的特征嵌入\",{\"1\":{\"12\":1}}],[\"通过这种方式\",{\"1\":{\"10\":1}}],[\"通过softmax函数转换后\",{\"1\":{\"10\":1}}],[\"可以参考论文\",{\"1\":{\"11\":1}}],[\"可以看到8个图像\",{\"1\":{\"10\":1}}],[\"可以看到对于要预测的8个图像\",{\"1\":{\"10\":1}}],[\"可以得到每个类别的预测概率\",{\"1\":{\"10\":1}}],[\"可以概括为以下两个主要步骤\",{\"1\":{\"10\":1}}],[\"此外\",{\"1\":{\"10\":1,\"11\":1,\"15\":1}}],[\"选择与图像特征相似度最高的文本所对应的类别\",{\"1\":{\"10\":1}}],[\"选择了一个包含6300万参数的transformer模型\",{\"1\":{\"9\":1}}],[\"最近的一些工作采用新的模型架构和预训练方法来从文本学习视觉特征\",{\"1\":{\"15\":1}}],[\"最后\",{\"1\":{\"12\":1}}],[\"最后将结果转换为\",{\"1\":{\"12\":1}}],[\"最终\",{\"1\":{\"10\":1}}],[\"最大的resnet模型rn50x64需要在592个v100\",{\"1\":{\"9\":1}}],[\"然后启动\",{\"1\":{\"18\":1}}],[\"然后将tf模型转为对应的pytorch版本即可\",{\"1\":{\"18\":1}}],[\"然后在具体的下游任务上进行微调\",{\"1\":{\"15\":1}}],[\"然后计算出和当前文本描述相似度最高的那副图片\",{\"1\":{\"13\":1}}],[\"然后计算每个分类文本对应的文本嵌入向量\",{\"1\":{\"12\":1}}],[\"然后利用模型获取文本特征\",{\"1\":{\"12\":1}}],[\"然后我们读取要预测的图像\",{\"1\":{\"10\":1}}],[\"然后提取了相应的文本特征\",{\"1\":{\"10\":1}}],[\"然后\",{\"1\":{\"10\":1}}],[\"然而\",{\"1\":{\"9\":1,\"15\":3}}],[\"将输入序列\",{\"1\":{\"36\":1}}],[\"将inputfeatures\",{\"1\":{\"19\":1}}],[\"将模型放入到仓库对应位置\",{\"1\":{\"18\":1}}],[\"将这个问题转化为一个多标签分类任务\",{\"1\":{\"15\":1}}],[\"将数据下载到当前项目目录下\",{\"1\":{\"12\":1}}],[\"将待分类的图像输入到图像编码器\",{\"1\":{\"10\":1}}],[\"将个文本特征和个图像特征两两组合\",{\"1\":{\"9\":1}}],[\"接下来\",{\"1\":{\"10\":1}}],[\"如自注意力层和前馈层\",{\"1\":{\"36\":1}}],[\"如翻译后的句子\",{\"1\":{\"36\":1}}],[\"如句子\",{\"1\":{\"36\":1}}],[\"如mae和beit\",{\"1\":{\"15\":1}}],[\"如moco和simclr\",{\"1\":{\"15\":1}}],[\"如imagenet\",{\"1\":{\"15\":1}}],[\"如果本地不存在\",{\"1\":{\"18\":1}}],[\"如果进一步采用convirt\",{\"1\":{\"15\":1}}],[\"如果在读取图片过程中出现错误\",{\"1\":{\"12\":1}}],[\"如果没有则下载\",{\"1\":{\"12\":1,\"14\":1}}],[\"如果我们直接使用类别标签作为文本描述\",{\"1\":{\"11\":1}}],[\"如果有个类别\",{\"1\":{\"10\":1}}],[\"如何将这个预训练的视觉模型应用到新的任务中呢\",{\"1\":{\"10\":1}}],[\"以加速训练并提高模型的稳定性\",{\"1\":{\"36\":1}}],[\"以每个文本描述为一行\",{\"1\":{\"13\":1}}],[\"以下是一个官方给出的clip模型的示例\",{\"1\":{\"10\":1}}],[\"以获取图像特征\",{\"1\":{\"10\":1}}],[\"以生成相应的文本特征\",{\"1\":{\"10\":1}}],[\"以增强性能\",{\"1\":{\"9\":1}}],[\"中\",{\"1\":{\"10\":2,\"19\":1}}],[\"例如谷歌的bit和vit基于jft\",{\"1\":{\"15\":1}}],[\"例如2017年的那篇工作只在imagenet上实现了11\",{\"1\":{\"15\":1}}],[\"例如virtex基于transformer的语言模型\",{\"1\":{\"15\":1}}],[\"例如openai的gpt\",{\"1\":{\"15\":1}}],[\"例如\",{\"1\":{\"10\":1,\"11\":1,\"15\":1}}],[\"为当前批次中的每个序列样本生成一个位置序列\",{\"1\":{\"22\":1}}],[\"为了简单\",{\"1\":{\"40\":1}}],[\"为了弥补数据规模上的差距\",{\"1\":{\"15\":1}}],[\"为了实现文字搜索图像的功能\",{\"1\":{\"13\":1}}],[\"为了训练clip模型\",{\"1\":{\"9\":1}}],[\"为特定任务动态构建了一个分类器\",{\"1\":{\"10\":1}}],[\"为每个类别创建一个描述性的文本\",{\"1\":{\"10\":1}}],[\"首先我们用data目录充当我们的图片库来源\",{\"1\":{\"13\":1}}],[\"首先\",{\"1\":{\"10\":1,\"12\":1}}],[\"直接对图像进行分类\",{\"1\":{\"10\":2}}],[\"那么就会得到个文本特征\",{\"1\":{\"10\":1}}],[\"那么\",{\"1\":{\"10\":1}}],[\"那么clip的训练目标就是最大个正样本的相似度\",{\"1\":{\"9\":1}}],[\"推理\",{\"0\":{\"10\":1}}],[\"论文还实验了使用80个不同的prompt进行集成\",{\"1\":{\"11\":1}}],[\"论文指出\",{\"1\":{\"11\":1}}],[\"论文中进行对比实验的clip模型也采用了这一配置\",{\"1\":{\"9\":1}}],[\"论文发现这个模型的效果最佳\",{\"1\":{\"9\":1}}],[\"generic\",{\"1\":{\"45\":1}}],[\"generator模型结构图\",{\"1\":{\"38\":1}}],[\"generator\",{\"0\":{\"38\":1},\"1\":{\"37\":3,\"38\":2}}],[\"get\",{\"1\":{\"12\":10,\"13\":4,\"14\":12,\"19\":1,\"30\":1}}],[\"getcwd\",{\"1\":{\"12\":1,\"14\":1}}],[\"gleu\",{\"1\":{\"24\":2}}],[\"guid\",{\"1\":{\"19\":1}}],[\"gpu上的矩阵运算都是充分优化和高度并行的\",{\"1\":{\"35\":1}}],[\"gpu上训练12天\",{\"1\":{\"9\":1}}],[\"gpu上训练18天\",{\"1\":{\"9\":1}}],[\"gpu\",{\"1\":{\"18\":2,\"35\":1}}],[\"googleapis\",{\"1\":{\"18\":1}}],[\"golang\",{\"1\":{\"2\":1}}],[\"github\",{\"1\":{\"18\":1,\"34\":1}}],[\"git\",{\"1\":{\"18\":2,\"34\":1}}],[\"grams\",{\"1\":{\"15\":2}}],[\"grad\",{\"1\":{\"10\":2,\"12\":2,\"14\":2}}],[\"garage\",{\"1\":{\"10\":1}}],[\"并重新命名为\",{\"1\":{\"18\":1}}],[\"并将图片展示出来\",{\"1\":{\"13\":1}}],[\"并将其标记为vit\",{\"1\":{\"9\":1}}],[\"并获得该批次图像列表对应的图像嵌入向量列表\",{\"1\":{\"12\":1}}],[\"并改造为a\",{\"1\":{\"12\":1}}],[\"并且与clip模型的训练数据不完全一致\",{\"1\":{\"11\":1}}],[\"并且在训练过程中采用了一个相对较大的批次大小\",{\"1\":{\"9\":1}}],[\"并计算与文本特征的余弦相似度\",{\"1\":{\"10\":1}}],[\"并进行l2归一化\",{\"1\":{\"9\":1}}],[\"but\",{\"1\":{\"30\":1}}],[\"build\",{\"1\":{\"19\":1}}],[\"bit\",{\"1\":{\"30\":1}}],[\"bin\",{\"1\":{\"18\":1}}],[\"binary\",{\"0\":{\"2\":1},\"1\":{\"0\":1}}],[\"binaryoracle\",{\"1\":{\"0\":1}}],[\"bytenet和convs2s等网络模型\",{\"1\":{\"35\":1}}],[\"by\",{\"1\":{\"26\":1}}],[\"below\",{\"1\":{\"44\":1}}],[\"between\",{\"1\":{\"30\":1}}],[\"be\",{\"1\":{\"19\":1}}],[\"bertselfoutput计算流程图\",{\"1\":{\"31\":1}}],[\"bertselfoutput\",{\"0\":{\"31\":1},\"1\":{\"31\":2,\"32\":1}}],[\"bertselfattention\",{\"0\":{\"30\":1},\"1\":{\"30\":2,\"32\":1}}],[\"bertforsequenceclassification模型结构图\",{\"1\":{\"28\":1}}],[\"bertforsequenceclassification\",{\"0\":{\"28\":1},\"1\":{\"28\":2}}],[\"bertpretrainedmodel\",{\"1\":{\"27\":1,\"28\":1}}],[\"bertpooler模型结构图\",{\"1\":{\"26\":1}}],[\"bertpooler\",{\"0\":{\"26\":1},\"1\":{\"26\":2,\"27\":1}}],[\"bertmodel模型结构图\",{\"1\":{\"27\":1}}],[\"bertmodel\",{\"0\":{\"27\":1},\"1\":{\"27\":2,\"28\":1,\"30\":1}}],[\"bertattention计算流程图\",{\"1\":{\"32\":1}}],[\"bertattention\",{\"0\":{\"29\":1,\"32\":1},\"1\":{\"24\":1,\"32\":2}}],[\"bertoutput\",{\"1\":{\"24\":3}}],[\"bertintermediate\",{\"1\":{\"24\":3}}],[\"bertlayer模型结构图\",{\"1\":{\"24\":1}}],[\"bertlayer\",{\"0\":{\"24\":1},\"1\":{\"24\":2,\"25\":1}}],[\"bertlayernorm\",{\"1\":{\"22\":1,\"24\":1,\"31\":1}}],[\"bertencoder模型结构图\",{\"1\":{\"25\":1}}],[\"bertencoder\",{\"0\":{\"23\":1,\"25\":1},\"1\":{\"25\":2,\"27\":1}}],[\"bertembeddings\",{\"0\":{\"22\":1},\"1\":{\"22\":2,\"27\":1}}],[\"berttokenizer\",{\"1\":{\"19\":3}}],[\"berttokenizer中的特殊token\",{\"1\":{\"19\":1}}],[\"bert文本分类实战\",{\"1\":{\"17\":1}}],[\"bert\",{\"0\":{\"17\":1},\"1\":{\"18\":16,\"19\":1,\"28\":2}}],[\"base\",{\"1\":{\"18\":6}}],[\"basename\",{\"1\":{\"12\":1,\"14\":1}}],[\"bag\",{\"1\":{\"15\":3}}],[\"batches\",{\"1\":{\"12\":2,\"14\":2,\"46\":1}}],[\"batch\",{\"1\":{\"12\":9,\"14\":9,\"18\":2,\"21\":4,\"30\":2,\"46\":2}}],[\"black\",{\"1\":{\"10\":1}}],[\"b\",{\"1\":{\"9\":2,\"19\":1}}],[\"后三种模型是按照efficientnet的缩放规则对resnet分别放大4倍\",{\"1\":{\"9\":1}}],[\"right\",{\"1\":{\"44\":1}}],[\"rnn等模型的缺点是需要顺序计算\",{\"1\":{\"35\":1}}],[\"rn50x16和rnx64\",{\"1\":{\"9\":1}}],[\"rn50x4\",{\"1\":{\"9\":1}}],[\"r\",{\"1\":{\"34\":1}}],[\"run\",{\"1\":{\"18\":1}}],[\"raw\",{\"1\":{\"30\":1}}],[\"rank\",{\"1\":{\"21\":1}}],[\"randomsampler\",{\"1\":{\"21\":1}}],[\"range\",{\"1\":{\"12\":1,\"14\":1,\"25\":1}}],[\"rate=2e\",{\"1\":{\"18\":1}}],[\"root\",{\"1\":{\"12\":2,\"14\":2}}],[\"rocket\",{\"1\":{\"10\":1}}],[\"rgb\",{\"1\":{\"12\":1,\"14\":1}}],[\"residual\",{\"1\":{\"36\":1}}],[\"resnet101\",{\"1\":{\"9\":1}}],[\"resnet50\",{\"1\":{\"9\":1}}],[\"resnet包含五种不同尺寸的模型\",{\"1\":{\"9\":1}}],[\"resnet\",{\"1\":{\"9\":1}}],[\"requirements\",{\"1\":{\"34\":2}}],[\"regression\",{\"1\":{\"28\":1}}],[\"read\",{\"1\":{\"18\":9}}],[\"returns\",{\"1\":{\"19\":1}}],[\"return\",{\"1\":{\"12\":9,\"13\":4,\"14\":13,\"19\":6,\"21\":1,\"22\":1,\"24\":3,\"25\":1,\"26\":1,\"27\":1,\"28\":1,\"30\":2,\"31\":1,\"32\":1,\"37\":3,\"38\":1,\"40\":1,\"41\":1,\"42\":1,\"44\":1,\"45\":1,\"46\":2}}],[\"repo\",{\"1\":{\"12\":1,\"14\":1}}],[\"replace\",{\"1\":{\"12\":1,\"14\":1}}],[\"red\",{\"1\":{\"10\":1}}],[\"一个视觉模型和一个文本模型\",{\"1\":{\"10\":1}}],[\"一种是常用的cnn架构resnet\",{\"1\":{\"9\":1}}],[\"一名普通但十分热爱探索技术的coder\",{\"1\":{\"2\":1}}],[\"则采用了两种不同的架构\",{\"1\":{\"9\":1}}],[\"则是以文本作为监督信号\",{\"1\":{\"7\":1}}],[\"3072\",{\"1\":{\"24\":2}}],[\"300m数据集的规模达到了上亿级别\",{\"1\":{\"15\":1}}],[\"300m数据集取得了较好的结果\",{\"1\":{\"15\":1}}],[\"300m数据集是谷歌从互联网上收集的\",{\"1\":{\"15\":1}}],[\"300m数据集来预训练模型在imagenet上取得sota\",{\"1\":{\"15\":1}}],[\"300m数据集还要多出1亿对\",{\"1\":{\"9\":1}}],[\"396\",{\"1\":{\"12\":1}}],[\"3\",{\"1\":{\"10\":1,\"11\":1,\"14\":1,\"15\":1,\"22\":1,\"30\":2,\"44\":1,\"46\":1}}],[\"336\",{\"1\":{\"9\":1}}],[\"32768\",{\"1\":{\"9\":1}}],[\"32\",{\"1\":{\"9\":1}}],[\"3d\",{\"0\":{\"4\":1},\"1\":{\"2\":1}}],[\"它可以当成函数调用\",{\"1\":{\"40\":1}}],[\"它通过位置编码将序列中词的位置信息注入到输入中\",{\"1\":{\"36\":1}}],[\"它通过处理器对输入文本进行处理\",{\"1\":{\"12\":1}}],[\"它允许模型在处理每个词时关注输入序列中的所有词\",{\"1\":{\"36\":1}}],[\"它在编码每一词的时候都能够注意\",{\"1\":{\"35\":1}}],[\"它较难学习到长距离的依赖关系\",{\"1\":{\"35\":1}}],[\"它将输入的向量转换为\",{\"1\":{\"12\":1}}],[\"它由两个部分组成\",{\"1\":{\"10\":1}}],[\"它比谷歌的jft\",{\"1\":{\"9\":1}}],[\"它代表着一种基于对比文本\",{\"1\":{\"8\":1}}],[\"其由七大主要部分构成\",{\"1\":{\"36\":1}}],[\"其次是准备训练数据\",{\"1\":{\"18\":1}}],[\"其次\",{\"1\":{\"12\":1}}],[\"其均能匹配到正确的文本标签\",{\"1\":{\"10\":1}}],[\"其规模与gpt\",{\"1\":{\"9\":1}}],[\"其中训练数据使用1k\",{\"1\":{\"18\":1}}],[\"其中\",{\"1\":{\"7\":1,\"9\":1}}],[\"若以文本单词数量来衡量\",{\"1\":{\"9\":1}}],[\"2578\",{\"1\":{\"19\":2}}],[\"2501\",{\"1\":{\"19\":2}}],[\"22\",{\"1\":{\"18\":1,\"34\":1}}],[\"2018\",{\"1\":{\"18\":1}}],[\"2017年的工作\",{\"1\":{\"15\":1}}],[\"2016年的工作\",{\"1\":{\"15\":1}}],[\"2021\",{\"1\":{\"7\":2}}],[\"2f\",{\"1\":{\"12\":2,\"14\":2}}],[\"2训练时使用的webtext数据集相似\",{\"1\":{\"9\":1}}],[\"2\",{\"1\":{\"9\":1,\"10\":1,\"22\":1,\"24\":1,\"27\":1,\"28\":1,\"30\":4,\"41\":1,\"44\":1,\"46\":5}}],[\"+=\",{\"1\":{\"12\":1,\"14\":1}}],[\"+\",{\"1\":{\"9\":1,\"10\":1,\"12\":2,\"14\":2,\"19\":21,\"22\":4,\"24\":1,\"28\":2,\"30\":3,\"31\":2,\"40\":4,\"41\":1,\"44\":4,\"45\":1}}],[\"等价于n个类别的cross\",{\"1\":{\"9\":1}}],[\"applied\",{\"1\":{\"46\":1}}],[\"apply\",{\"1\":{\"30\":1,\"46\":2}}],[\"append\",{\"1\":{\"12\":3,\"14\":3,\"19\":1}}],[\"add\",{\"1\":{\"28\":1}}],[\"axis\",{\"1\":{\"13\":1,\"14\":1}}],[\"axis=0\",{\"1\":{\"9\":1}}],[\"axis=1\",{\"1\":{\"9\":3,\"12\":3,\"14\":3}}],[\"activation\",{\"1\":{\"26\":2}}],[\"activate\",{\"1\":{\"18\":1,\"34\":1}}],[\"act2fn\",{\"1\":{\"24\":1}}],[\"act\",{\"1\":{\"24\":7}}],[\"actually\",{\"1\":{\"30\":1}}],[\"actual\",{\"1\":{\"12\":2,\"14\":2}}],[\"acc\",{\"1\":{\"12\":2,\"14\":2}}],[\"accuracy\",{\"1\":{\"12\":8,\"14\":6}}],[\"are\",{\"1\":{\"28\":2}}],[\"args\",{\"1\":{\"21\":1}}],[\"argmax\",{\"1\":{\"12\":1,\"13\":1,\"14\":2}}],[\"array\",{\"1\":{\"12\":2,\"14\":2}}],[\"arange\",{\"1\":{\"9\":1,\"22\":1}}],[\"available\",{\"1\":{\"12\":1,\"14\":1}}],[\"assume\",{\"1\":{\"46\":1}}],[\"assert\",{\"1\":{\"46\":1}}],[\"as\",{\"1\":{\"12\":2,\"13\":1,\"14\":5,\"22\":1}}],[\"astronaut\",{\"1\":{\"10\":1}}],[\"always\",{\"1\":{\"46\":1}}],[\"already\",{\"1\":{\"19\":1}}],[\"all\",{\"1\":{\"12\":3,\"13\":1,\"14\":3,\"19\":5,\"21\":16,\"30\":6,\"46\":3}}],[\"alexnet\",{\"1\":{\"12\":1}}],[\"aligned\",{\"1\":{\"9\":2}}],[\"attn\",{\"1\":{\"41\":4,\"44\":10,\"46\":7}}],[\"attenion\",{\"1\":{\"40\":1}}],[\"attend\",{\"1\":{\"30\":1,\"35\":1}}],[\"attention可以用矩阵乘法一次计算所有的时刻\",{\"1\":{\"35\":1}}],[\"attention机制\",{\"1\":{\"35\":1}}],[\"attentions\",{\"1\":{\"28\":1,\"30\":2}}],[\"attention\",{\"1\":{\"19\":6,\"21\":4,\"24\":7,\"25\":2,\"27\":8,\"28\":3,\"30\":26,\"32\":4,\"36\":2,\"46\":4}}],[\"at\",{\"1\":{\"10\":1}}],[\"american\",{\"1\":{\"10\":1}}],[\"annotated\",{\"1\":{\"34\":5}}],[\"and\",{\"1\":{\"10\":1,\"11\":1,\"19\":1,\"24\":1,\"28\":1,\"30\":1,\"37\":2,\"42\":1,\"44\":1,\"46\":2}}],[\"an\",{\"1\":{\"10\":1}}],[\"about\",{\"1\":{\"10\":1}}],[\"a\",{\"1\":{\"10\":16,\"11\":3,\"12\":1,\"13\":2,\"14\":3,\"18\":3,\"19\":4,\"30\":1,\"42\":1,\"46\":2}}],[\"=>\",{\"1\":{\"46\":1}}],[\"==\",{\"1\":{\"12\":1,\"14\":1,\"21\":1,\"24\":1,\"28\":1,\"34\":1,\"46\":2}}],[\"=\",{\"1\":{\"9\":9,\"10\":10,\"12\":40,\"13\":9,\"14\":46,\"19\":14,\"21\":7,\"22\":16,\"24\":17,\"25\":2,\"26\":5,\"27\":10,\"28\":14,\"30\":25,\"31\":6,\"32\":4,\"37\":5,\"38\":1,\"40\":2,\"41\":6,\"42\":3,\"44\":9,\"45\":4,\"46\":15}}],[\"feed\",{\"1\":{\"36\":1,\"41\":4,\"44\":5}}],[\"features\",{\"1\":{\"10\":10,\"12\":4,\"14\":4,\"15\":1,\"19\":1}}],[\"function\",{\"1\":{\"30\":1}}],[\"fct\",{\"1\":{\"28\":4}}],[\"fp16\",{\"1\":{\"27\":1}}],[\"fn负责对返回的一个batch\",{\"1\":{\"21\":1}}],[\"fn\",{\"1\":{\"21\":2,\"24\":3}}],[\"fn=collate\",{\"1\":{\"21\":1}}],[\"follow\",{\"1\":{\"41\":1,\"44\":1}}],[\"following\",{\"1\":{\"19\":1}}],[\"found\",{\"1\":{\"13\":1,\"14\":1,\"49\":1}}],[\"forward\",{\"1\":{\"22\":1,\"24\":3,\"25\":1,\"26\":1,\"27\":1,\"28\":1,\"30\":2,\"31\":1,\"32\":1,\"36\":1,\"37\":1,\"38\":1,\"40\":1,\"41\":5,\"42\":1,\"44\":6,\"45\":1,\"46\":1}}],[\"format\",{\"1\":{\"19\":1}}],[\"for\",{\"1\":{\"10\":1,\"12\":6,\"13\":2,\"14\":8,\"25\":2,\"30\":5,\"41\":1,\"42\":1,\"44\":1,\"45\":1,\"46\":1}}],[\"figure\",{\"1\":{\"41\":1,\"44\":1,\"46\":1}}],[\"first\",{\"1\":{\"19\":2,\"26\":3}}],[\"fill\",{\"1\":{\"46\":1}}],[\"filterwarnings\",{\"1\":{\"14\":1}}],[\"file\",{\"1\":{\"12\":5,\"14\":5,\"18\":1}}],[\"files\",{\"1\":{\"12\":2,\"14\":2}}],[\"final\",{\"1\":{\"46\":1}}],[\"find\",{\"1\":{\"13\":2,\"14\":2}}],[\"finetune\",{\"1\":{\"9\":1}}],[\"from\",{\"1\":{\"12\":2,\"13\":2,\"14\":8,\"15\":2,\"19\":2,\"30\":1,\"46\":1}}],[\"flowerclassify\",{\"1\":{\"12\":1,\"14\":1}}],[\"flower\",{\"1\":{\"12\":4,\"14\":2}}],[\"float\",{\"1\":{\"10\":2}}],[\"flag\",{\"1\":{\"10\":1}}],[\"facial\",{\"1\":{\"10\":1}}],[\"f\",{\"1\":{\"9\":4,\"12\":7,\"13\":4,\"14\":11,\"38\":1}}],[\"p\",{\"1\":{\"46\":5}}],[\"p=dropout\",{\"1\":{\"46\":1}}],[\"pip\",{\"1\":{\"34\":1}}],[\"pil\",{\"1\":{\"14\":1}}],[\"pooler\",{\"1\":{\"27\":2}}],[\"pooled\",{\"1\":{\"26\":4,\"27\":2,\"28\":4}}],[\"pool\",{\"1\":{\"26\":1}}],[\"positional\",{\"1\":{\"36\":1}}],[\"position\",{\"1\":{\"22\":12,\"27\":2,\"28\":2}}],[\"portion\",{\"1\":{\"19\":1}}],[\"portrait\",{\"1\":{\"10\":1}}],[\"permute\",{\"1\":{\"30\":2}}],[\"per\",{\"1\":{\"18\":2}}],[\"person\",{\"1\":{\"10\":1}}],[\"py文件\",{\"1\":{\"18\":1}}],[\"py\",{\"1\":{\"18\":2}}],[\"pytorch\",{\"1\":{\"18\":3}}],[\"python\",{\"1\":{\"18\":1}}],[\"python=3\",{\"1\":{\"18\":1,\"34\":1}}],[\"pyplot\",{\"1\":{\"14\":1}}],[\"plt\",{\"1\":{\"13\":4,\"14\":5}}],[\"png\",{\"1\":{\"12\":1,\"14\":1}}],[\"pt\",{\"1\":{\"12\":2,\"14\":2}}],[\"pass\",{\"1\":{\"42\":1}}],[\"passed\",{\"1\":{\"19\":1}}],[\"paper\",{\"1\":{\"30\":1}}],[\"pair\",{\"1\":{\"19\":2}}],[\"padding\",{\"1\":{\"19\":6,\"22\":1,\"27\":1,\"28\":1,\"36\":1}}],[\"padding=true\",{\"1\":{\"12\":1,\"14\":1}}],[\"pad\",{\"1\":{\"19\":3}}],[\"path=prev\",{\"1\":{\"18\":1}}],[\"paths\",{\"1\":{\"12\":17,\"13\":6,\"14\":21}}],[\"path\",{\"1\":{\"12\":12,\"13\":2,\"14\":14,\"18\":2}}],[\"patch14\",{\"1\":{\"12\":2,\"14\":1}}],[\"page\",{\"1\":{\"10\":1}}],[\"parameters\",{\"1\":{\"27\":1}}],[\"parameter\",{\"1\":{\"9\":1}}],[\"photos下的子目录名作为我们的候选待匹配分类文本列表\",{\"1\":{\"12\":1}}],[\"photos\",{\"1\":{\"12\":4,\"14\":2}}],[\"photos目录下读取出所有图片的路径\",{\"1\":{\"12\":1}}],[\"photo\",{\"1\":{\"10\":2,\"11\":2,\"12\":2,\"13\":1,\"14\":2}}],[\"print\",{\"1\":{\"12\":6,\"13\":4,\"14\":10}}],[\"product\",{\"1\":{\"30\":1,\"46\":1}}],[\"probabilities\",{\"1\":{\"30\":1}}],[\"prob\",{\"1\":{\"22\":1,\"24\":1,\"28\":1,\"30\":1,\"31\":1}}],[\"probs\",{\"1\":{\"10\":3,\"30\":5}}],[\"process\",{\"1\":{\"37\":1}}],[\"processor\",{\"1\":{\"12\":3,\"14\":3}}],[\"processing\",{\"1\":{\"11\":1}}],[\"prompting\",{\"1\":{\"11\":1}}],[\"prompt\",{\"1\":{\"11\":3}}],[\"projected\",{\"1\":{\"46\":1}}],[\"projections\",{\"1\":{\"46\":1}}],[\"projection\",{\"1\":{\"46\":1}}],[\"proj\",{\"1\":{\"9\":2,\"38\":2}}],[\"precomputed\",{\"1\":{\"30\":1}}],[\"prev\",{\"1\":{\"18\":1}}],[\"pretrainedtokenizer\",{\"1\":{\"19\":1}}],[\"pretrained\",{\"1\":{\"12\":4,\"14\":4}}],[\"prediction\",{\"1\":{\"15\":1,\"19\":1}}],[\"predicted\",{\"1\":{\"12\":6,\"14\":6}}],[\"predict\",{\"1\":{\"11\":1}}],[\"pre\",{\"1\":{\"8\":1,\"11\":1}}],[\"dropping\",{\"1\":{\"30\":1}}],[\"dropout=none\",{\"1\":{\"46\":1}}],[\"dropout=self\",{\"1\":{\"46\":1}}],[\"dropout=0\",{\"1\":{\"46\":1}}],[\"dropout\",{\"1\":{\"22\":4,\"24\":4,\"28\":4,\"30\":4,\"31\":4,\"40\":6,\"41\":2,\"44\":2,\"46\":5}}],[\"dtype\",{\"1\":{\"27\":1}}],[\"dtype=next\",{\"1\":{\"27\":1}}],[\"dtype=torch\",{\"1\":{\"22\":1}}],[\"dump\",{\"1\":{\"18\":1}}],[\"da\",{\"1\":{\"18\":1}}],[\"dataloader\",{\"0\":{\"21\":1},\"1\":{\"21\":3}}],[\"dataset\",{\"1\":{\"19\":1,\"21\":3}}],[\"data\",{\"1\":{\"13\":9,\"14\":9,\"15\":2,\"18\":1}}],[\"dall\",{\"1\":{\"7\":3}}],[\"doing\",{\"1\":{\"28\":1}}],[\"do\",{\"1\":{\"18\":3,\"46\":1}}],[\"does\",{\"1\":{\"13\":1,\"14\":1}}],[\"downloaded\",{\"1\":{\"12\":1,\"14\":1}}],[\"downloading\",{\"1\":{\"12\":2,\"14\":2}}],[\"download\",{\"1\":{\"12\":3,\"14\":4}}],[\"dot\",{\"1\":{\"9\":3,\"12\":1,\"14\":1,\"30\":1,\"46\":1}}],[\"del\",{\"1\":{\"46\":3}}],[\"decode\",{\"1\":{\"37\":2}}],[\"decoder模型结构图\",{\"1\":{\"44\":1,\"45\":1}}],[\"decoderlayer\",{\"0\":{\"44\":1},\"1\":{\"44\":2}}],[\"decoder\",{\"0\":{\"37\":1,\"43\":1,\"45\":1},\"1\":{\"36\":2,\"37\":4,\"44\":1,\"45\":3}}],[\"dense\",{\"1\":{\"24\":4,\"26\":2,\"31\":2,\"40\":1}}],[\"device=input\",{\"1\":{\"22\":1}}],[\"device\",{\"1\":{\"12\":5,\"14\":5,\"22\":1}}],[\"defined\",{\"1\":{\"44\":1}}],[\"def\",{\"1\":{\"12\":8,\"13\":3,\"14\":11,\"19\":3,\"21\":1,\"22\":2,\"24\":6,\"25\":2,\"26\":2,\"27\":2,\"28\":2,\"30\":3,\"31\":2,\"32\":2,\"37\":4,\"38\":2,\"40\":2,\"41\":2,\"42\":2,\"44\":2,\"45\":2,\"46\":3}}],[\"desc\",{\"1\":{\"10\":2}}],[\"distributedsampler\",{\"1\":{\"21\":1}}],[\"dir=\",{\"1\":{\"18\":3}}],[\"dir=save\",{\"1\":{\"12\":1,\"14\":1}}],[\"dirname\",{\"1\":{\"12\":1,\"14\":1}}],[\"directory\",{\"1\":{\"12\":5,\"13\":1,\"14\":6}}],[\"dir\",{\"1\":{\"12\":16,\"13\":7,\"14\":23,\"18\":4}}],[\"dim=\",{\"1\":{\"10\":4,\"30\":1,\"38\":1,\"46\":1}}],[\"d\",{\"1\":{\"9\":6,\"30\":2,\"38\":3,\"46\":15}}],[\"m\",{\"1\":{\"44\":3}}],[\"memory\",{\"1\":{\"37\":2,\"44\":2,\"45\":2}}],[\"methods\",{\"1\":{\"11\":1}}],[\"metamind\",{\"1\":{\"0\":1}}],[\"multiheadedattention\",{\"1\":{\"46\":2}}],[\"multi\",{\"1\":{\"36\":1}}],[\"might\",{\"1\":{\"30\":1}}],[\"mixed\",{\"1\":{\"30\":6}}],[\"min\",{\"1\":{\"12\":1,\"14\":1}}],[\"minibatch\",{\"1\":{\"9\":2}}],[\"mseloss\",{\"1\":{\"28\":1}}],[\"made\",{\"1\":{\"44\":1}}],[\"macos\",{\"1\":{\"34\":1}}],[\"map\",{\"1\":{\"21\":1}}],[\"masked\",{\"1\":{\"37\":1,\"46\":1}}],[\"masking\",{\"1\":{\"36\":1,\"45\":1}}],[\"mask=mask\",{\"1\":{\"46\":1}}],[\"mask=head\",{\"1\":{\"28\":1}}],[\"mask=none\",{\"1\":{\"24\":1,\"25\":2,\"27\":2,\"28\":2,\"30\":2,\"32\":1,\"46\":2}}],[\"mask=attention\",{\"1\":{\"19\":1,\"28\":1}}],[\"mask作用图解\",{\"1\":{\"19\":2}}],[\"mask\",{\"1\":{\"19\":14,\"21\":4,\"24\":1,\"25\":2,\"27\":8,\"28\":3,\"30\":3,\"32\":1,\"36\":1,\"37\":11,\"41\":2,\"42\":3,\"44\":4,\"45\":4,\"46\":6}}],[\"max\",{\"1\":{\"18\":1,\"19\":6,\"21\":7,\"22\":1}}],[\"math\",{\"1\":{\"30\":1,\"46\":1}}],[\"matmul\",{\"1\":{\"30\":2,\"46\":2}}],[\"matplotlib\",{\"1\":{\"14\":1}}],[\"matching\",{\"1\":{\"13\":11,\"14\":11}}],[\"modulelist\",{\"1\":{\"25\":1}}],[\"module\",{\"1\":{\"22\":1,\"24\":3,\"25\":3,\"26\":1,\"30\":1,\"31\":1,\"32\":1,\"37\":1,\"38\":1,\"40\":1,\"41\":1,\"42\":1,\"44\":1,\"45\":1,\"46\":1}}],[\"model是decoder输出的大小\",{\"1\":{\"38\":1}}],[\"models\",{\"1\":{\"18\":1}}],[\"model\",{\"1\":{\"10\":2,\"12\":16,\"14\":16,\"15\":1,\"18\":6,\"26\":1,\"38\":2,\"46\":7}}],[\"most\",{\"1\":{\"13\":10,\"14\":10}}],[\"motorcycle\",{\"1\":{\"10\":1}}],[\"which\",{\"1\":{\"30\":1}}],[\"white\",{\"1\":{\"10\":1}}],[\"word\",{\"1\":{\"22\":2}}],[\"words\",{\"1\":{\"15\":3,\"22\":2}}],[\"wget\",{\"1\":{\"18\":1}}],[\"we\",{\"1\":{\"26\":1,\"28\":1,\"46\":1}}],[\"web\",{\"1\":{\"15\":1}}],[\"weakly\",{\"1\":{\"15\":1}}],[\"weights\",{\"1\":{\"12\":2,\"14\":2,\"27\":1,\"28\":1}}],[\"warnings\",{\"1\":{\"14\":2}}],[\"walk\",{\"1\":{\"12\":1,\"14\":1}}],[\"with\",{\"1\":{\"10\":3,\"12\":2,\"14\":2,\"19\":3,\"45\":1}}],[\"w\",{\"1\":{\"9\":5,\"46\":4}}],[\"harvardnlp\",{\"1\":{\"34\":1}}],[\"has\",{\"1\":{\"19\":2}}],[\"here\",{\"1\":{\"28\":1}}],[\"heads\",{\"1\":{\"30\":7,\"46\":3}}],[\"head\",{\"1\":{\"25\":2,\"27\":1,\"28\":2,\"30\":10,\"36\":1}}],[\"hidden\",{\"1\":{\"22\":5,\"24\":24,\"25\":5,\"26\":5,\"28\":4,\"30\":8,\"31\":12}}],[\"https\",{\"1\":{\"18\":2,\"34\":1}}],[\"hub\",{\"1\":{\"14\":1}}],[\"huggingface\",{\"1\":{\"14\":1}}],[\"horse\",{\"1\":{\"10\":1}}],[\"h\",{\"1\":{\"9\":1,\"18\":3,\"46\":9}}],[\"item\",{\"1\":{\"21\":1}}],[\"icmlm和convirt仅在10万级别的数据上训练了几天\",{\"1\":{\"15\":1}}],[\"icmlm基于语言掩码的方法\",{\"1\":{\"15\":1}}],[\"ignore\",{\"1\":{\"14\":1}}],[\"implements\",{\"1\":{\"46\":1}}],[\"import\",{\"1\":{\"14\":9}}],[\"imshow\",{\"1\":{\"13\":1,\"14\":1}}],[\"img\",{\"1\":{\"13\":2,\"14\":2}}],[\"images=images\",{\"1\":{\"12\":1,\"14\":1}}],[\"images\",{\"1\":{\"9\":1,\"10\":1,\"12\":3,\"13\":2,\"14\":5}}],[\"image\",{\"1\":{\"8\":1,\"9\":5,\"10\":10,\"12\":31,\"13\":21,\"14\":51,\"15\":1}}],[\"ids=position\",{\"1\":{\"27\":1,\"28\":1}}],[\"ids=none\",{\"1\":{\"22\":2,\"27\":2,\"28\":2}}],[\"ids=token\",{\"1\":{\"19\":1,\"27\":1,\"28\":1}}],[\"ids=input\",{\"1\":{\"19\":1}}],[\"ids作用图解\",{\"1\":{\"19\":1}}],[\"ids\",{\"1\":{\"19\":36,\"21\":8,\"22\":14,\"27\":4,\"28\":4}}],[\"id\",{\"1\":{\"19\":9}}],[\"idx=0\",{\"1\":{\"22\":1}}],[\"idx\",{\"1\":{\"12\":5,\"14\":5}}],[\"id=model\",{\"1\":{\"12\":1,\"14\":1}}],[\"if\",{\"1\":{\"12\":9,\"13\":3,\"14\":12,\"19\":7,\"21\":1,\"22\":2,\"24\":1,\"28\":3,\"30\":1,\"46\":3}}],[\"isinstance\",{\"1\":{\"24\":2}}],[\"isdir\",{\"1\":{\"12\":1,\"14\":1}}],[\"is\",{\"1\":{\"10\":1,\"12\":2,\"13\":2,\"14\":4,\"19\":4,\"22\":2,\"28\":1,\"30\":4,\"42\":1,\"44\":1,\"46\":3}}],[\"install\",{\"1\":{\"34\":1}}],[\"int\",{\"1\":{\"30\":1}}],[\"intermediate\",{\"1\":{\"24\":9}}],[\"info\",{\"1\":{\"24\":1}}],[\"init\",{\"1\":{\"22\":2,\"24\":6,\"25\":2,\"26\":2,\"27\":3,\"28\":3,\"30\":2,\"31\":2,\"32\":2,\"37\":2,\"38\":2,\"40\":2,\"41\":2,\"42\":2,\"44\":2,\"45\":2,\"46\":2}}],[\"index\",{\"1\":{\"12\":2,\"13\":2,\"14\":4}}],[\"indices\",{\"1\":{\"12\":2,\"14\":2}}],[\"inputfeatures\",{\"1\":{\"19\":1}}],[\"inputfeatures组成图解\",{\"1\":{\"19\":1}}],[\"inputs\",{\"1\":{\"12\":4,\"14\":4,\"19\":8}}],[\"input\",{\"1\":{\"10\":2,\"19\":13,\"21\":4,\"22\":6,\"24\":2,\"27\":2,\"28\":2,\"31\":2,\"32\":3,\"42\":1}}],[\"in\",{\"1\":{\"10\":2,\"11\":1,\"12\":7,\"14\":7,\"19\":1,\"25\":2,\"30\":1,\"37\":1,\"42\":2,\"45\":1,\"46\":4}}],[\"i\",{\"1\":{\"9\":12,\"12\":2,\"14\":2,\"25\":2}}],[\"对应的id为\",{\"1\":{\"19\":1}}],[\"对应的参数为\",{\"1\":{\"18\":1}}],[\"对应的伪代码实现如下所示\",{\"1\":{\"9\":1}}],[\"对应代码如下\",{\"1\":{\"18\":1}}],[\"对于分类任务来说\",{\"1\":{\"28\":1}}],[\"对于字典中不存在的词\",{\"1\":{\"19\":1}}],[\"对于自监督模型\",{\"1\":{\"15\":1}}],[\"对于有监督模型\",{\"1\":{\"15\":1}}],[\"对于vit\",{\"1\":{\"9\":1}}],[\"对于一个包含个文本\",{\"1\":{\"9\":1}}],[\"对角线元素的labels\",{\"1\":{\"9\":1}}],[\"对称的对比学习损失\",{\"1\":{\"9\":1}}],[\"对两个特征进行线性投射\",{\"1\":{\"9\":1}}],[\"矩阵中的对角线元素\",{\"1\":{\"9\":1}}],[\"即文本和图像可能不完全匹配\",{\"1\":{\"15\":1}}],[\"即基于对比学习的方法\",{\"1\":{\"15\":1}}],[\"即基于文本弱监督来提升性能\",{\"1\":{\"15\":1}}],[\"即为与当前文本描述相似度最高的那副图片\",{\"1\":{\"13\":1}}],[\"即真正属于一对的文本和图像\",{\"1\":{\"9\":1}}],[\"即上图所示的矩阵\",{\"1\":{\"9\":1}}],[\"scaled\",{\"1\":{\"46\":1}}],[\"scores\",{\"1\":{\"30\":12,\"46\":4}}],[\"src\",{\"1\":{\"37\":16,\"44\":7,\"45\":2}}],[\"sqrt\",{\"1\":{\"30\":1,\"46\":1}}],[\"shape\",{\"1\":{\"30\":4}}],[\"show\",{\"1\":{\"13\":1,\"14\":1}}],[\"shot性能评估\",{\"1\":{\"15\":1}}],[\"shot性能\",{\"1\":{\"15\":1}}],[\"shot迁移到下游任务\",{\"1\":{\"15\":1}}],[\"shot学习\",{\"1\":{\"15\":1}}],[\"shot推理\",{\"1\":{\"12\":1}}],[\"shot分类时\",{\"1\":{\"11\":1}}],[\"shot分类的过程相当直接\",{\"1\":{\"10\":1}}],[\"shot图像分类\",{\"1\":{\"10\":1}}],[\"s\",{\"1\":{\"19\":1}}],[\"str\",{\"1\":{\"24\":1}}],[\"steps=100\",{\"1\":{\"18\":2}}],[\"step\",{\"1\":{\"18\":4}}],[\"storage\",{\"1\":{\"18\":1}}],[\"state\",{\"1\":{\"26\":1}}],[\"states\",{\"1\":{\"24\":16,\"25\":4,\"26\":2,\"28\":2,\"30\":4,\"31\":8}}],[\"start\",{\"1\":{\"12\":5,\"14\":5}}],[\"stack\",{\"1\":{\"10\":1,\"21\":1,\"42\":1}}],[\"standing\",{\"1\":{\"10\":2}}],[\"southampton\",{\"1\":{\"18\":1}}],[\"softmax\",{\"1\":{\"10\":1,\"30\":1,\"36\":1,\"38\":1,\"46\":1}}],[\"seem\",{\"1\":{\"30\":1}}],[\"segment\",{\"1\":{\"19\":1}}],[\"segmentation\",{\"1\":{\"10\":1,\"22\":1}}],[\"second\",{\"1\":{\"19\":1}}],[\"seconds\",{\"1\":{\"12\":2,\"14\":1}}],[\"self\",{\"1\":{\"19\":9,\"22\":13,\"24\":26,\"25\":5,\"26\":7,\"27\":11,\"28\":14,\"30\":28,\"31\":9,\"32\":11,\"36\":2,\"37\":16,\"38\":5,\"40\":8,\"41\":15,\"42\":7,\"44\":19,\"45\":7,\"46\":15}}],[\"sep\",{\"1\":{\"19\":11}}],[\"sentence\",{\"1\":{\"19\":1}}],[\"sequence\",{\"1\":{\"19\":4,\"27\":3}}],[\"sequences\",{\"1\":{\"19\":2,\"37\":1}}],[\"seq\",{\"1\":{\"18\":1,\"22\":2,\"30\":2,\"46\":1}}],[\"searchpicbytext\",{\"1\":{\"13\":1,\"14\":1}}],[\"special\",{\"1\":{\"19\":6}}],[\"split\",{\"1\":{\"12\":1,\"14\":1}}],[\"splitext\",{\"1\":{\"12\":1,\"14\":1}}],[\"spring\",{\"1\":{\"2\":1}}],[\"super\",{\"1\":{\"22\":1,\"24\":3,\"25\":1,\"26\":1,\"27\":1,\"28\":1,\"30\":1,\"31\":1,\"32\":1,\"37\":1,\"38\":1,\"40\":1,\"41\":1,\"42\":1,\"44\":1,\"45\":1,\"46\":1}}],[\"supervised\",{\"1\":{\"15\":1}}],[\"sunflowers\",{\"1\":{\"13\":1,\"14\":1}}],[\"sublayer是传入的参数\",{\"1\":{\"40\":1}}],[\"sublayer\",{\"1\":{\"40\":3,\"41\":3,\"44\":4}}],[\"sublayerconnection模型结构图\",{\"1\":{\"40\":1}}],[\"sublayerconnection\",{\"0\":{\"40\":1},\"1\":{\"40\":2,\"41\":1,\"44\":1}}],[\"sub\",{\"1\":{\"12\":5,\"14\":5}}],[\"successfully\",{\"1\":{\"12\":1,\"14\":1}}],[\"survey\",{\"1\":{\"11\":1}}],[\"sys\",{\"1\":{\"24\":1}}],[\"systematic\",{\"1\":{\"11\":1}}],[\"symlinks=false\",{\"1\":{\"12\":1,\"14\":1}}],[\"snapshot\",{\"1\":{\"12\":1,\"14\":2}}],[\"same\",{\"1\":{\"46\":1}}],[\"sampler=train\",{\"1\":{\"21\":1}}],[\"sampler\",{\"1\":{\"21\":2}}],[\"save\",{\"1\":{\"12\":3,\"14\":3,\"18\":1}}],[\"saucer\",{\"1\":{\"10\":1}}],[\"simply\",{\"1\":{\"26\":1}}],[\"similarities\",{\"1\":{\"12\":2,\"13\":2,\"14\":4}}],[\"similarity\",{\"1\":{\"9\":1,\"10\":1,\"12\":2,\"13\":1,\"14\":3}}],[\"size=args\",{\"1\":{\"21\":1}}],[\"size=16\",{\"1\":{\"18\":2}}],[\"size=64\",{\"1\":{\"12\":2,\"14\":2}}],[\"size\",{\"1\":{\"12\":4,\"14\":4,\"21\":1,\"22\":7,\"24\":5,\"26\":2,\"28\":1,\"30\":15,\"31\":3,\"40\":2,\"41\":4,\"42\":1,\"44\":4,\"45\":1,\"46\":3}}],[\"silhouette\",{\"1\":{\"10\":1}}],[\"这和原始论文稍有不同\",{\"1\":{\"40\":1}}],[\"这比较容易并行\",{\"1\":{\"35\":1}}],[\"这大大限制了它们的迁移能力和扩展性\",{\"1\":{\"15\":1}}],[\"这远远低于imagenet上的sota\",{\"1\":{\"15\":1}}],[\"这方面的工作并不多\",{\"1\":{\"15\":1}}],[\"这个函数的有一个输入参数\",{\"1\":{\"40\":1}}],[\"这个函数的作用是将输入的文本转化为对应的嵌入表示\",{\"1\":{\"12\":1}}],[\"这个数据集来源是这里\",{\"1\":{\"18\":1}}],[\"这个\",{\"1\":{\"12\":1}}],[\"这种差异一方面是由于文本和图像属于两个完全不同的模态\",{\"1\":{\"15\":1}}],[\"这种预训练通常是基于有监督学习的\",{\"1\":{\"15\":1}}],[\"这种格式\",{\"1\":{\"11\":1}}],[\"这种方法实际上与nlp领域的一个研究方向\",{\"1\":{\"11\":1}}],[\"这与传统的预训练加微调的方法有所不同\",{\"1\":{\"11\":1}}],[\"这样的格式来生成文本描述\",{\"1\":{\"11\":1}}],[\"这展示了其在图像分类任务中的灵活性和强大能力\",{\"1\":{\"10\":1}}],[\"这一过程与训练时相同\",{\"1\":{\"10\":1}}],[\"这些模型都是以cnn为基础\",{\"1\":{\"35\":1}}],[\"这些相似度值可以被视为logits\",{\"1\":{\"10\":1}}],[\"这些图像特征会与之前得到的个文本特征进行余弦相似度计算\",{\"1\":{\"10\":1}}],[\"这些文本随后被输入到文本编码器\",{\"1\":{\"10\":1}}],[\"这些数据在论文中被称为webimagetext\",{\"1\":{\"9\":1}}],[\"这不仅展示了clip的强大功能\",{\"1\":{\"10\":1}}],[\"这意味着它能够在没有任何特定任务训练数据的情况下\",{\"1\":{\"10\":1}}],[\"这表明训练clip模型需要消耗大量的资源\",{\"1\":{\"9\":1}}],[\"这里我准备做一个文本分类任务\",{\"1\":{\"18\":1}}],[\"这里以搜索向日葵花为例\",{\"1\":{\"13\":1}}],[\"这里采用了余弦相似度的计算方法\",{\"1\":{\"12\":1}}],[\"这里共有个正样本\",{\"1\":{\"9\":1}}],[\"这里的相似度直接计算文本特征和图像特征的余弦相似性\",{\"1\":{\"9\":1}}],[\"这里对提取的文本特征和图像特征进行对比学习\",{\"1\":{\"9\":1}}],[\"这两个模型都属于融合图像与文本的多模态模型\",{\"1\":{\"7\":1}}],[\"也是其一大亮点\",{\"1\":{\"10\":1}}],[\"也可以采用视觉transformer模型\",{\"1\":{\"9\":1}}],[\"也就是一张图像搭配与之对应的文本描述\",{\"1\":{\"8\":1}}],[\"模型架构图\",{\"1\":{\"36\":1}}],[\"模型架构\",{\"0\":{\"20\":1,\"36\":1}}],[\"模型有点大\",{\"1\":{\"18\":1}}],[\"模型名称\",{\"1\":{\"14\":1}}],[\"模型\",{\"1\":{\"9\":1}}],[\"nbatches\",{\"1\":{\"46\":3}}],[\"n个解码器层\",{\"1\":{\"45\":1}}],[\"nn\",{\"1\":{\"22\":5,\"24\":6,\"25\":2,\"26\":3,\"28\":2,\"30\":6,\"31\":3,\"32\":1,\"37\":1,\"38\":2,\"40\":2,\"41\":1,\"42\":1,\"44\":1,\"45\":1,\"46\":3}}],[\"nsp\",{\"1\":{\"19\":1}}],[\"nsp任务\",{\"1\":{\"19\":1}}],[\"null\",{\"1\":{\"19\":1}}],[\"number\",{\"1\":{\"46\":1}}],[\"num\",{\"1\":{\"12\":2,\"14\":2,\"18\":1,\"25\":1,\"28\":5,\"30\":5}}],[\"numpy\",{\"1\":{\"10\":2,\"12\":4,\"14\":3}}],[\"network\",{\"1\":{\"36\":1}}],[\"netpoll\",{\"1\":{\"2\":1}}],[\"neural\",{\"1\":{\"35\":1,\"36\":1}}],[\"new\",{\"1\":{\"30\":4}}],[\"next\",{\"1\":{\"19\":1}}],[\"needed\",{\"1\":{\"12\":2,\"14\":2}}],[\"name=\",{\"1\":{\"18\":1}}],[\"name\",{\"1\":{\"12\":8,\"14\":8,\"18\":1}}],[\"natural\",{\"1\":{\"11\":1}}],[\"none\",{\"1\":{\"12\":3,\"13\":2,\"14\":4,\"19\":4,\"22\":2,\"28\":2,\"30\":1,\"46\":4}}],[\"not\",{\"1\":{\"12\":3,\"13\":2,\"14\":5,\"19\":1,\"28\":1,\"30\":1,\"46\":3,\"49\":1}}],[\"normalization\",{\"1\":{\"36\":1}}],[\"normalize\",{\"1\":{\"9\":2,\"30\":1}}],[\"norm\",{\"1\":{\"10\":2,\"12\":2,\"14\":2,\"22\":1,\"24\":1,\"31\":1,\"40\":2,\"42\":2,\"45\":2}}],[\"no\",{\"1\":{\"10\":2,\"12\":2,\"13\":1,\"14\":3}}],[\"np\",{\"1\":{\"9\":5,\"10\":1,\"12\":6,\"13\":1,\"14\":8}}],[\"n\",{\"1\":{\"9\":7,\"15\":1,\"18\":1,\"34\":1,\"42\":3,\"45\":3}}],[\"nlp\",{\"1\":{\"9\":1}}],[\"文件中的\",{\"1\":{\"34\":1}}],[\"文件进行调试即可\",{\"1\":{\"18\":1}}],[\"文字搜索图像\",{\"0\":{\"13\":1}}],[\"文字搜索图像实战演练\",{\"1\":{\"6\":1}}],[\"文本分词\",{\"1\":{\"19\":1}}],[\"文本分类任务\",{\"1\":{\"19\":1}}],[\"文本对应的标签\",{\"1\":{\"19\":1}}],[\"文本描述的生成也是一个关键环节\",{\"1\":{\"11\":1}}],[\"文本描述生成\",{\"0\":{\"11\":1}}],[\"文本编码器使用的是基于\",{\"1\":{\"12\":1}}],[\"文本编码器\",{\"1\":{\"9\":1,\"10\":1}}],[\"文本编码器的作用是提取文本的特征\",{\"1\":{\"9\":1}}],[\"turn\",{\"1\":{\"42\":1}}],[\"tgt\",{\"1\":{\"37\":12,\"44\":2,\"45\":2}}],[\"txt\",{\"1\":{\"34\":2}}],[\"txt文件\",{\"1\":{\"18\":1}}],[\"two\",{\"1\":{\"19\":1}}],[\"type\",{\"1\":{\"19\":9,\"21\":4,\"22\":9,\"27\":3,\"28\":3}}],[\"type=bert\",{\"1\":{\"18\":1}}],[\"tnews\",{\"1\":{\"18\":4}}],[\"tf\",{\"1\":{\"18\":2}}],[\"title\",{\"1\":{\"13\":1,\"14\":1}}],[\"time\",{\"1\":{\"12\":10,\"14\":10}}],[\"target\",{\"1\":{\"37\":1}}],[\"take\",{\"1\":{\"30\":1,\"37\":1,\"46\":1}}],[\"taken\",{\"1\":{\"12\":2,\"14\":1,\"30\":1}}],[\"taking\",{\"1\":{\"26\":1}}],[\"tanh\",{\"1\":{\"26\":1}}],[\"task\",{\"1\":{\"18\":1,\"19\":1}}],[\"tabby\",{\"1\":{\"10\":1}}],[\"through\",{\"1\":{\"42\":1}}],[\"this\",{\"1\":{\"10\":1,\"30\":1}}],[\"they\",{\"1\":{\"28\":1}}],[\"the\",{\"1\":{\"10\":1,\"13\":1,\"14\":1,\"19\":4,\"26\":3,\"30\":5,\"34\":1,\"42\":1,\"46\":2}}],[\"try\",{\"1\":{\"12\":2,\"13\":1,\"14\":3}}],[\"tripod\",{\"1\":{\"10\":1}}],[\"transpose\",{\"1\":{\"30\":5,\"46\":3}}],[\"transformers\",{\"1\":{\"14\":1}}],[\"transformer\",{\"1\":{\"7\":3,\"9\":3,\"12\":2,\"15\":1,\"30\":1,\"34\":5,\"36\":4}}],[\"trained\",{\"1\":{\"18\":2}}],[\"train\",{\"1\":{\"11\":1,\"18\":3,\"19\":1,\"21\":6}}],[\"training\",{\"1\":{\"8\":1}}],[\"test\",{\"1\":{\"12\":2,\"14\":1}}],[\"tensordataset\",{\"1\":{\"19\":1}}],[\"tensors=\",{\"1\":{\"12\":2,\"14\":2}}],[\"tensor\",{\"1\":{\"10\":1,\"24\":2,\"26\":2,\"31\":2,\"32\":3}}],[\"temperature\",{\"1\":{\"9\":1}}],[\"text转化为18291个类别\",{\"1\":{\"15\":1}}],[\"text=texts\",{\"1\":{\"12\":1,\"14\":1}}],[\"texts\",{\"1\":{\"9\":1,\"10\":2,\"12\":1,\"14\":1}}],[\"text\",{\"1\":{\"9\":6,\"10\":13,\"12\":9,\"13\":9,\"14\":16,\"19\":2}}],[\"total\",{\"1\":{\"12\":4,\"14\":4}}],[\"topk\",{\"1\":{\"10\":1}}],[\"top\",{\"1\":{\"10\":2}}],[\"torch==1\",{\"1\":{\"34\":1}}],[\"torch\",{\"1\":{\"10\":3,\"12\":4,\"14\":5,\"21\":1,\"22\":2,\"30\":2,\"34\":1,\"46\":2}}],[\"token用于分类任务即可\",{\"1\":{\"28\":1}}],[\"token\",{\"1\":{\"19\":35,\"21\":4,\"22\":9,\"26\":4,\"27\":2,\"28\":2}}],[\"tokenize\",{\"1\":{\"10\":1}}],[\"tokens=false\",{\"1\":{\"19\":1}}],[\"tokens部分的mask列表\",{\"1\":{\"19\":1}}],[\"tokens\",{\"1\":{\"10\":2,\"19\":6,\"30\":1}}],[\"to\",{\"1\":{\"9\":2,\"12\":6,\"14\":5,\"18\":3,\"19\":1,\"26\":1,\"27\":1,\"30\":4,\"35\":1,\"46\":1}}],[\"t\",{\"1\":{\"9\":15,\"10\":2,\"12\":1,\"14\":1}}],[\"训练效率成为一个至关重要的因素\",{\"1\":{\"15\":1}}],[\"训练效率可以提高4倍\",{\"1\":{\"15\":1}}],[\"训练使用到的数据集和alexnet保持一致\",{\"1\":{\"12\":1}}],[\"训练\",{\"0\":{\"9\":1}}],[\"训练出具有可迁移能力的视觉模型\",{\"1\":{\"7\":1}}],[\"期望模型能够学习到文本和图像之间的匹配关系\",{\"1\":{\"8\":1}}],[\"像moco和simclr有所不同\",{\"1\":{\"8\":1}}],[\"与计算机视觉\",{\"1\":{\"8\":1}}],[\"与此同时\",{\"1\":{\"7\":1}}],[\"同时计算self\",{\"1\":{\"35\":1}}],[\"同时将flower\",{\"1\":{\"12\":1}}],[\"同时最小化个负样本的相似度\",{\"1\":{\"9\":1}}],[\"同时也指运用该方法构建的模型\",{\"1\":{\"8\":1}}],[\"同样给计算机视觉领域带来了巨大影响\",{\"1\":{\"7\":1}}],[\"介绍\",{\"0\":{\"8\":1}}],[\"的核心\",{\"1\":{\"36\":1}}],[\"的神经网络架构\",{\"1\":{\"36\":1}}],[\"的\",{\"1\":{\"19\":1}}],[\"的zero\",{\"1\":{\"15\":1}}],[\"的架构\",{\"1\":{\"12\":1}}],[\"的性能提升\",{\"1\":{\"11\":1}}],[\"的效果\",{\"1\":{\"11\":1}}],[\"的vit\",{\"1\":{\"9\":1}}],[\"的出现也掀起了新一轮的研究热潮\",{\"1\":{\"7\":1}}],[\"的研究如潮水般涌来\",{\"1\":{\"7\":1}}],[\"类似\",{\"1\":{\"7\":1}}],[\"而不能看到未来的词\",{\"1\":{\"36\":1}}],[\"而这里我们将会反转这个逻辑\",{\"1\":{\"13\":1}}],[\"而最大的vit模型vit\",{\"1\":{\"9\":1}}],[\"而vit则选择了三种不同尺寸的模型\",{\"1\":{\"9\":1}}],[\"而图像编码器\",{\"1\":{\"9\":1,\"10\":1}}],[\"而图像编码器则用于提取图像的特征\",{\"1\":{\"9\":1}}],[\"而剩余的个文本\",{\"1\":{\"9\":1}}],[\"而\",{\"1\":{\"7\":1}}],[\"和基于图像掩码的方法\",{\"1\":{\"15\":1}}],[\"和图像编码器\",{\"1\":{\"9\":1}}],[\"和\",{\"1\":{\"7\":3,\"41\":1}}],[\"equals\",{\"1\":{\"46\":1}}],[\"each\",{\"1\":{\"42\":1}}],[\"eps\",{\"1\":{\"22\":1,\"24\":1,\"31\":1}}],[\"eps=config\",{\"1\":{\"22\":1,\"24\":1,\"31\":1}}],[\"epochs=4\",{\"1\":{\"18\":1}}],[\"eval\",{\"1\":{\"18\":2}}],[\"emb\",{\"1\":{\"13\":2,\"14\":2}}],[\"embeddings\",{\"1\":{\"12\":12,\"13\":4,\"14\":15,\"22\":23,\"26\":1,\"27\":2}}],[\"embedding\",{\"1\":{\"12\":4,\"13\":1,\"14\":3,\"22\":3,\"27\":2}}],[\"embed\",{\"1\":{\"9\":2,\"37\":8}}],[\"else\",{\"1\":{\"12\":1,\"13\":1,\"14\":2,\"19\":2,\"21\":1,\"24\":1,\"28\":1}}],[\"elowen\",{\"0\":{\"3\":1}}],[\"error\",{\"1\":{\"12\":2,\"13\":1,\"14\":3}}],[\"extended\",{\"1\":{\"27\":6}}],[\"extension\",{\"1\":{\"12\":2,\"14\":2}}],[\"exist\",{\"1\":{\"13\":1,\"14\":1}}],[\"exists\",{\"1\":{\"12\":1,\"13\":1,\"14\":2}}],[\"exception\",{\"1\":{\"12\":2,\"13\":1,\"14\":3}}],[\"except\",{\"1\":{\"12\":2,\"13\":1,\"14\":3}}],[\"expand\",{\"1\":{\"22\":1}}],[\"export\",{\"1\":{\"18\":1}}],[\"exp\",{\"1\":{\"9\":1}}],[\"encoding\",{\"1\":{\"36\":1}}],[\"encoded\",{\"1\":{\"19\":7}}],[\"encode\",{\"1\":{\"10\":2,\"37\":2}}],[\"encoder模型结构图\",{\"1\":{\"42\":1}}],[\"encoderlayer模型结构图\",{\"1\":{\"41\":1}}],[\"encoderlayer\",{\"0\":{\"41\":1},\"1\":{\"41\":2}}],[\"encoderdecoder\",{\"1\":{\"37\":2}}],[\"encoderdecoder模型结构图\",{\"1\":{\"37\":1}}],[\"encoder提取图像特征\",{\"1\":{\"10\":1}}],[\"encoder\",{\"0\":{\"37\":1,\"39\":1,\"42\":1},\"1\":{\"9\":8,\"10\":4,\"27\":2,\"36\":2,\"37\":4,\"42\":3}}],[\"entire\",{\"1\":{\"30\":1}}],[\"entropy\",{\"1\":{\"9\":3}}],[\"enumerate\",{\"1\":{\"12\":1,\"14\":1,\"25\":1}}],[\"end\",{\"1\":{\"12\":4,\"14\":4}}],[\"engineering\",{\"1\":{\"11\":1}}],[\"e\",{\"1\":{\"7\":3,\"9\":6,\"12\":4,\"13\":2,\"14\":6}}],[\"月发布的\",{\"1\":{\"7\":1}}],[\"1e9\",{\"1\":{\"46\":1}}],[\"1=none\",{\"1\":{\"19\":3}}],[\"10\",{\"1\":{\"46\":3}}],[\"103\",{\"1\":{\"19\":1}}],[\"102\",{\"1\":{\"19\":2}}],[\"101\",{\"1\":{\"19\":2}}],[\"104\",{\"1\":{\"19\":1}}],[\"10000\",{\"1\":{\"27\":1}}],[\"100\",{\"1\":{\"10\":1,\"12\":1,\"14\":1,\"19\":2}}],[\"11\",{\"1\":{\"18\":1,\"34\":2}}],[\"12\",{\"1\":{\"18\":6}}],[\"14模型\",{\"1\":{\"9\":1}}],[\"14则需要在256个v100\",{\"1\":{\"9\":1}}],[\"14\",{\"1\":{\"9\":2,\"12\":1}}],[\"16和vit\",{\"1\":{\"9\":1}}],[\"16倍和64倍得到的\",{\"1\":{\"9\":1}}],[\"1\",{\"1\":{\"7\":1,\"10\":5,\"12\":4,\"14\":4,\"19\":26,\"21\":1,\"22\":2,\"27\":2,\"28\":6,\"30\":5,\"34\":1,\"38\":1,\"41\":2,\"44\":2,\"46\":15}}],[\"年\",{\"1\":{\"7\":1}}],[\"年可谓是视觉\",{\"1\":{\"7\":1}}],[\"在输入序列长度不一致时\",{\"1\":{\"36\":1}}],[\"在解码器中\",{\"1\":{\"36\":1}}],[\"在自注意力机制之后\",{\"1\":{\"36\":1}}],[\"在返回前进行预处理\",{\"1\":{\"21\":1}}],[\"在这种情况下\",{\"1\":{\"15\":1}}],[\"在这个过程中\",{\"1\":{\"10\":1}}],[\"在nlp领域\",{\"1\":{\"15\":1}}],[\"在迁移到其他数据集时也需要加上新的分类器进行有监督训练\",{\"1\":{\"15\":1}}],[\"在迁移到下游任务时\",{\"1\":{\"15\":1}}],[\"在计算机视觉领域\",{\"1\":{\"15\":1}}],[\"在图文检索中\",{\"1\":{\"12\":1}}],[\"在imagenet数据集上可以提升1\",{\"1\":{\"11\":1}}],[\"在之前的例子中\",{\"1\":{\"11\":1}}],[\"在使用clip模型进行zero\",{\"1\":{\"11\":1}}],[\"在论文中\",{\"1\":{\"9\":1}}],[\"在实际应用中可以选用常见的卷积神经网络\",{\"1\":{\"9\":1}}],[\"在实现时可采用自然语言处理\",{\"1\":{\"9\":1}}],[\"在训练过程中\",{\"1\":{\"8\":1}}],[\"在\",{\"1\":{\"7\":1,\"12\":1}}],[\"out\",{\"1\":{\"30\":1}}],[\"outputs\",{\"1\":{\"18\":1,\"27\":2,\"28\":7,\"32\":2}}],[\"output\",{\"1\":{\"18\":3,\"24\":9,\"26\":4,\"27\":7,\"28\":4,\"30\":2,\"32\":4}}],[\"overwrite\",{\"1\":{\"18\":1}}],[\"opening\",{\"1\":{\"13\":1,\"14\":1}}],[\"open\",{\"1\":{\"12\":1,\"13\":1,\"14\":2}}],[\"openai首先尝试了virtex模型\",{\"1\":{\"15\":1}}],[\"openai从网络上收集了4亿条数据进行实验\",{\"1\":{\"15\":1}}],[\"openai从网络上收集了总计4亿对文本和图像\",{\"1\":{\"9\":1}}],[\"openai\",{\"1\":{\"7\":1,\"12\":2,\"14\":1}}],[\"os\",{\"1\":{\"12\":11,\"13\":2,\"14\":14}}],[\"only\",{\"1\":{\"19\":1}}],[\"on\",{\"1\":{\"10\":3,\"46\":1}}],[\"off\",{\"1\":{\"13\":1,\"14\":1}}],[\"of\",{\"1\":{\"9\":4,\"10\":6,\"11\":3,\"12\":2,\"13\":1,\"14\":2,\"15\":3,\"19\":1,\"42\":1,\"44\":1,\"46\":1}}],[\"original\",{\"1\":{\"30\":1}}],[\"or\",{\"1\":{\"9\":2,\"18\":1,\"24\":1}}],[\"oracle\",{\"0\":{\"2\":1},\"1\":{\"0\":1}}],[\"众多基于视觉\",{\"1\":{\"7\":1}}],[\"引言\",{\"0\":{\"7\":1}}],[\"庖丁解牛clip\",{\"0\":{\"6\":1}}],[\"left\",{\"1\":{\"41\":1}}],[\"lens\",{\"1\":{\"19\":1,\"21\":2}}],[\"len=input\",{\"1\":{\"19\":1}}],[\"length长度\",{\"1\":{\"19\":1}}],[\"length\",{\"1\":{\"19\":11,\"21\":1,\"22\":2}}],[\"length=128\",{\"1\":{\"18\":1}}],[\"len\",{\"1\":{\"12\":1,\"14\":1,\"19\":13,\"21\":5,\"30\":2,\"46\":1}}],[\"learning\",{\"1\":{\"15\":2,\"18\":1}}],[\"learning的核心思想是通过设计合适的prompt\",{\"1\":{\"11\":1}}],[\"learning或prompt\",{\"1\":{\"11\":1}}],[\"learned\",{\"1\":{\"9\":3}}],[\"lin\",{\"1\":{\"46\":2}}],[\"linears\",{\"1\":{\"46\":3}}],[\"linear\",{\"1\":{\"24\":2,\"26\":1,\"28\":1,\"30\":3,\"31\":1,\"38\":1,\"46\":3}}],[\"linalg\",{\"1\":{\"12\":2,\"14\":2}}],[\"like\",{\"1\":{\"22\":1}}],[\"list列表组装起来得到需要的dataset\",{\"1\":{\"19\":1}}],[\"listdir\",{\"1\":{\"12\":1,\"14\":1}}],[\"lambda\",{\"1\":{\"41\":1,\"44\":2}}],[\"layers\",{\"1\":{\"25\":1,\"30\":1,\"42\":3,\"45\":2}}],[\"layer\",{\"1\":{\"22\":1,\"24\":3,\"25\":4,\"30\":21,\"31\":1,\"36\":1,\"42\":6,\"45\":6}}],[\"layernorm\",{\"1\":{\"22\":2,\"24\":2,\"31\":2,\"40\":2,\"42\":1,\"45\":1}}],[\"large\",{\"1\":{\"12\":2,\"14\":1,\"15\":1}}],[\"launchpad\",{\"1\":{\"10\":1}}],[\"label=label\",{\"1\":{\"19\":1}}],[\"label\",{\"1\":{\"10\":1,\"11\":2,\"19\":2}}],[\"labels=none\",{\"1\":{\"28\":1}}],[\"labels\",{\"1\":{\"9\":3,\"10\":1,\"19\":1,\"21\":2,\"28\":8}}],[\"language\",{\"0\":{\"4\":1},\"1\":{\"8\":1,\"11\":1,\"15\":1}}],[\"long\",{\"1\":{\"22\":1}}],[\"log\",{\"1\":{\"38\":1}}],[\"logging\",{\"1\":{\"18\":1}}],[\"logits\",{\"1\":{\"9\":3,\"28\":5}}],[\"lower\",{\"1\":{\"12\":1,\"14\":1,\"18\":1}}],[\"loading\",{\"1\":{\"12\":1,\"14\":1}}],[\"local\",{\"1\":{\"12\":2,\"14\":2,\"21\":1}}],[\"looking\",{\"1\":{\"10\":1}}],[\"loss\",{\"1\":{\"9\":8,\"28\":8}}],[\"l2\",{\"1\":{\"9\":2}}],[\"l\",{\"1\":{\"9\":5,\"12\":1,\"18\":3}}],[\"llm\",{\"1\":{\"3\":1}}],[\"v\",{\"1\":{\"46\":2}}],[\"value\",{\"1\":{\"30\":6,\"46\":7}}],[\"version\",{\"1\":{\"24\":1}}],[\"vectors\",{\"1\":{\"46\":1}}],[\"vec2\",{\"1\":{\"12\":5,\"14\":5}}],[\"vec1\",{\"1\":{\"12\":5,\"14\":5}}],[\"vocab是词典大小\",{\"1\":{\"38\":1}}],[\"vocab\",{\"1\":{\"22\":2,\"38\":2}}],[\"vgg进行实现\",{\"1\":{\"12\":1}}],[\"view\",{\"1\":{\"28\":4,\"30\":3,\"46\":3}}],[\"virtex\",{\"1\":{\"15\":1}}],[\"visual\",{\"1\":{\"15\":2}}],[\"vision\",{\"0\":{\"4\":1},\"1\":{\"7\":1,\"9\":1,\"12\":1}}],[\"vit\",{\"1\":{\"7\":2,\"9\":2,\"12\":4,\"14\":1}}],[\"vl\",{\"1\":{\"2\":1}}],[\"现就读于电子科技大学\",{\"1\":{\"3\":1}}],[\"现就读于四川大学\",{\"1\":{\"2\":1}}],[\"领域常用的文本transformer模型\",{\"1\":{\"9\":1}}],[\"领域中的一些对比学习方法\",{\"1\":{\"8\":1}}],[\"领域\",{\"1\":{\"3\":1}}],[\"转换为一系列高维向量表示\",{\"1\":{\"36\":1}}],[\"转化成功之后\",{\"1\":{\"18\":1}}],[\"转\",{\"1\":{\"3\":1}}],[\"转型\",{\"1\":{\"2\":1}}],[\"ckpt\",{\"1\":{\"18\":1}}],[\"checkpoint\",{\"1\":{\"18\":2}}],[\"chinesegluedatasets\",{\"1\":{\"18\":2}}],[\"chinese\",{\"1\":{\"18\":5}}],[\"creates\",{\"1\":{\"19\":1}}],[\"create\",{\"1\":{\"18\":1,\"19\":1,\"34\":1}}],[\"crossentropyloss\",{\"1\":{\"28\":1}}],[\"cross\",{\"1\":{\"9\":2}}],[\"cd\",{\"1\":{\"18\":1,\"34\":1}}],[\"class\",{\"1\":{\"22\":1,\"24\":3,\"25\":1,\"26\":1,\"27\":1,\"28\":1,\"30\":1,\"31\":1,\"32\":1,\"37\":1,\"38\":1,\"40\":1,\"41\":1,\"42\":1,\"44\":1,\"45\":1,\"46\":1}}],[\"classification\",{\"1\":{\"19\":1}}],[\"classifier\",{\"1\":{\"18\":2,\"28\":2}}],[\"cls\",{\"1\":{\"19\":9,\"26\":1}}],[\"clones\",{\"1\":{\"41\":1,\"42\":1,\"44\":1,\"45\":1,\"46\":1}}],[\"clone\",{\"1\":{\"18\":1,\"34\":1}}],[\"clipprocessor\",{\"1\":{\"12\":1,\"14\":2}}],[\"clipmodel\",{\"1\":{\"12\":1,\"14\":2}}],[\"clip模型均能够以较高的置信度给出正确的分类结果\",{\"1\":{\"10\":1}}],[\"clip模型能够在没有特定任务训练数据的情况下\",{\"1\":{\"10\":1}}],[\"clip模型的一个显著优势是它能够进行zero\",{\"1\":{\"10\":1}}],[\"clip模型会预测出个可能的文本\",{\"1\":{\"9\":1}}],[\"clip包含两个核心模型\",{\"1\":{\"9\":1}}],[\"clip的训练数据采用的是文本\",{\"1\":{\"8\":1}}],[\"clip的英文全称为contrastive\",{\"1\":{\"8\":1}}],[\"clip属于基于对比学习的多模态模型\",{\"1\":{\"8\":1}}],[\"clip\",{\"1\":{\"7\":3,\"10\":1,\"12\":3,\"14\":1,\"15\":1}}],[\"clip原始论文链接\",{\"1\":{\"6\":1}}],[\"cpu\",{\"1\":{\"10\":3,\"12\":3,\"14\":3,\"35\":1}}],[\"current\",{\"1\":{\"12\":2,\"13\":1,\"14\":3}}],[\"cuda\",{\"1\":{\"10\":2,\"12\":2,\"14\":2}}],[\"cup\",{\"1\":{\"10\":1}}],[\"case\",{\"1\":{\"18\":1}}],[\"caption\",{\"1\":{\"15\":1}}],[\"candidates\",{\"1\":{\"12\":13,\"14\":10}}],[\"camera\",{\"1\":{\"10\":1}}],[\"category\",{\"1\":{\"12\":4,\"14\":4}}],[\"cat\",{\"1\":{\"10\":1}}],[\"c\",{\"1\":{\"9\":1}}],[\"cbow\",{\"1\":{\"9\":1}}],[\"core\",{\"1\":{\"42\":1}}],[\"corresponding\",{\"1\":{\"26\":1}}],[\"correct\",{\"1\":{\"12\":3,\"14\":3}}],[\"collate\",{\"1\":{\"21\":2}}],[\"code\",{\"1\":{\"18\":7}}],[\"compute\",{\"1\":{\"46\":1}}],[\"compatibility\",{\"1\":{\"27\":1}}],[\"com\",{\"1\":{\"18\":2,\"34\":1}}],[\"committer\",{\"1\":{\"2\":2}}],[\"concat\",{\"1\":{\"46\":1}}],[\"connections\",{\"1\":{\"41\":1,\"44\":1}}],[\"connection\",{\"1\":{\"36\":1}}],[\"contiguous\",{\"1\":{\"30\":1,\"46\":1}}],[\"context\",{\"1\":{\"26\":1,\"30\":9}}],[\"contrastive\",{\"1\":{\"15\":1}}],[\"config\",{\"1\":{\"18\":2,\"22\":9,\"24\":16,\"25\":3,\"26\":3,\"27\":5,\"28\":7,\"30\":9,\"31\":5,\"32\":3}}],[\"conda\",{\"1\":{\"18\":2,\"34\":2}}],[\"convirt基于对比学习的方法\",{\"1\":{\"15\":1}}],[\"convert\",{\"1\":{\"12\":1,\"14\":1,\"18\":1}}],[\"count\",{\"1\":{\"12\":7,\"14\":7}}],[\"coffee\",{\"1\":{\"10\":1}}],[\"cosine\",{\"1\":{\"9\":1,\"12\":2,\"13\":1,\"14\":3}}],[\"cnn\",{\"1\":{\"9\":1}}],[\"cv\",{\"1\":{\"3\":1,\"8\":1}}],[\"csdn\",{\"1\":{\"0\":1}}],[\"知识星球\",{\"1\":{\"0\":1}}]],\"version\":2}}")).map(([e,t])=>[e,_t(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:n,options:o,id:s}})=>{const r=xt[n];e==="suggest"?self.postMessage([e,s,ve(t,r,o)]):e==="search"?self.postMessage([e,s,Ee(t,r,o,"max")]):self.postMessage({suggestions:[e,s,ve(t,r,o)],results:[e,s,Ee(t,r,o,__SLIMSEARCH_SORT_STRATEGY__)]})};
//# sourceMappingURL=index.js.map
