/**
* @vue/shared v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**//*! #__NO_SIDE_EFFECTS__ */function xt(e){const t=Object.create(null);for(const n of e.split(","))t[n]=1;return n=>n in t}const Ot={},St=()=>{},ze=Object.assign,It=Object.prototype.hasOwnProperty,se=(e,t)=>It.call(e,t),z=Array.isArray,Y=e=>Ve(e)==="[object Map]",oe=e=>typeof e=="function",Ce=e=>typeof e=="string",L=e=>typeof e=="symbol",B=e=>e!==null&&typeof e=="object",Nt=Object.prototype.toString,Ve=e=>Nt.call(e),ke=e=>Ve(e).slice(8,-1),ie=e=>Ce(e)&&e!=="NaN"&&e[0]!=="-"&&""+parseInt(e,10)===e,Mt=e=>{const t=Object.create(null);return n=>t[n]||(t[n]=e(n))},Ln=Mt(e=>e.charAt(0).toUpperCase()+e.slice(1)),W=(e,t)=>!Object.is(e,t);let $e;const ce=()=>$e||($e=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{});/**
* @vue/reactivity v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/function Rt(e,...t){console.warn(`[Vue warn] ${e}`,...t)}let Tt,je=0,ae;function ue(){je++}function le(){if(--je>0)return;let e;for(;ae;){let t=ae;for(ae=void 0;t;){const n=t.next;if(t.next=void 0,t.flags&=-9,t.flags&1)try{t.trigger()}catch(s){e||(e=s)}t=n}}if(e)throw e}let G=!0;const De=[];function fe(){De.push(G),G=!1}function de(){const e=De.pop();G=e===void 0?!0:e}class Fe{constructor(t){this.computed=t,this.version=0,this.activeLink=void 0,this.subs=void 0,this.map=void 0,this.key=void 0,this.sc=0,this.__v_skip=!0}track(t){}trigger(t){this.version++,this.notify(t)}notify(t){ue();try{for(let n=this.subs;n;n=n.prevSub)n.sub.notify()&&n.sub.dep.notify()}finally{le()}}}const he=new WeakMap,C=Symbol(""),pe=Symbol(""),H=Symbol("");function E(e,t,n){if(G&&Tt){let s=he.get(e);s||he.set(e,s=new Map);let r=s.get(n);r||(s.set(n,r=new Fe),r.map=s,r.key=n),r.track()}}function I(e,t,n,s,r,o){const i=he.get(e);if(!i)return;const c=a=>{a&&a.trigger()};if(ue(),t==="clear")i.forEach(c);else{const a=z(e),u=a&&ie(n);if(a&&n==="length"){const l=Number(s);i.forEach((f,d)=>{(d==="length"||d===H||!L(d)&&d>=l)&&c(f)})}else switch((n!==void 0||i.has(void 0))&&c(i.get(n)),u&&c(i.get(H)),t){case"add":a?u&&c(i.get("length")):(c(i.get(C)),Y(e)&&c(i.get(pe)));break;case"delete":a||(c(i.get(C)),Y(e)&&c(i.get(pe)));break;case"set":Y(e)&&c(i.get(C));break}}le()}function $(e){const t=p(e);return t===e?t:(E(t,"iterate",H),N(e)?t:t.map(v))}function ge(e){return E(e=p(e),"iterate",H),e}const zt={__proto__:null,[Symbol.iterator](){return _e(this,Symbol.iterator,v)},concat(...e){return $(this).concat(...e.map(t=>z(t)?$(t):t))},entries(){return _e(this,"entries",e=>(e[1]=v(e[1]),e))},every(e,t){return O(this,"every",e,t,void 0,arguments)},filter(e,t){return O(this,"filter",e,t,n=>n.map(v),arguments)},find(e,t){return O(this,"find",e,t,v,arguments)},findIndex(e,t){return O(this,"findIndex",e,t,void 0,arguments)},findLast(e,t){return O(this,"findLast",e,t,v,arguments)},findLastIndex(e,t){return O(this,"findLastIndex",e,t,void 0,arguments)},forEach(e,t){return O(this,"forEach",e,t,void 0,arguments)},includes(...e){return me(this,"includes",e)},indexOf(...e){return me(this,"indexOf",e)},join(e){return $(this).join(e)},lastIndexOf(...e){return me(this,"lastIndexOf",e)},map(e,t){return O(this,"map",e,t,void 0,arguments)},pop(){return K(this,"pop")},push(...e){return K(this,"push",e)},reduce(e,...t){return Pe(this,"reduce",e,t)},reduceRight(e,...t){return Pe(this,"reduceRight",e,t)},shift(){return K(this,"shift")},some(e,t){return O(this,"some",e,t,void 0,arguments)},splice(...e){return K(this,"splice",e)},toReversed(){return $(this).toReversed()},toSorted(e){return $(this).toSorted(e)},toSpliced(...e){return $(this).toSpliced(...e)},unshift(...e){return K(this,"unshift",e)},values(){return _e(this,"values",v)}};function _e(e,t,n){const s=ge(e),r=s[t]();return s!==e&&!N(e)&&(r._next=r.next,r.next=()=>{const o=r._next();return o.value&&(o.value=n(o.value)),o}),r}const Ct=Array.prototype;function O(e,t,n,s,r,o){const i=ge(e),c=i!==e&&!N(e),a=i[t];if(a!==Ct[t]){const f=a.apply(e,o);return c?v(f):f}let u=n;i!==e&&(c?u=function(f,d){return n.call(this,v(f),d,e)}:n.length>2&&(u=function(f,d){return n.call(this,f,d,e)}));const l=a.call(i,u,s);return c&&r?r(l):l}function Pe(e,t,n,s){const r=ge(e);let o=n;return r!==e&&(N(e)?n.length>3&&(o=function(i,c,a){return n.call(this,i,c,a,e)}):o=function(i,c,a){return n.call(this,i,v(c),a,e)}),r[t](o,...s)}function me(e,t,n){const s=p(e);E(s,"iterate",H);const r=s[t](...n);return(r===-1||r===!1)&&Jt(n[0])?(n[0]=p(n[0]),s[t](...n)):r}function K(e,t,n=[]){fe(),ue();const s=p(e)[t].apply(e,n);return le(),de(),s}const Vt=xt("__proto__,__v_isRef,__isVue"),Ae=new Set(Object.getOwnPropertyNames(Symbol).filter(e=>e!=="arguments"&&e!=="caller").map(e=>Symbol[e]).filter(L));function kt(e){L(e)||(e=String(e));const t=p(this);return E(t,"has",e),t.hasOwnProperty(e)}class Le{constructor(t=!1,n=!1){this._isReadonly=t,this._isShallow=n}get(t,n,s){if(n==="__v_skip")return t.__v_skip;const r=this._isReadonly,o=this._isShallow;if(n==="__v_isReactive")return!r;if(n==="__v_isReadonly")return r;if(n==="__v_isShallow")return o;if(n==="__v_raw")return s===(r?o?Kt:Ke:o?Ht:He).get(t)||Object.getPrototypeOf(t)===Object.getPrototypeOf(s)?t:void 0;const i=z(t);if(!r){let a;if(i&&(a=zt[n]))return a;if(n==="hasOwnProperty")return kt}const c=Reflect.get(t,n,V(t)?t:s);return(L(n)?Ae.has(n):Vt(n))||(r||E(t,"get",n),o)?c:V(c)?i&&ie(n)?c:c.value:B(c)?r?Ue(c):qe(c):c}}class $t extends Le{constructor(t=!1){super(!1,t)}set(t,n,s,r){let o=t[n];if(!this._isShallow){const a=j(o);if(!N(s)&&!j(s)&&(o=p(o),s=p(s)),!z(t)&&V(o)&&!V(s))return a?!1:(o.value=s,!0)}const i=z(t)&&ie(n)?Number(n)<t.length:se(t,n),c=Reflect.set(t,n,s,V(t)?t:r);return t===p(r)&&(i?W(s,o)&&I(t,"set",n,s,o):I(t,"add",n,s)),c}deleteProperty(t,n){const s=se(t,n),r=t[n],o=Reflect.deleteProperty(t,n);return o&&s&&I(t,"delete",n,void 0,r),o}has(t,n){const s=Reflect.has(t,n);return(!L(n)||!Ae.has(n))&&E(t,"has",n),s}ownKeys(t){return E(t,"iterate",z(t)?"length":C),Reflect.ownKeys(t)}}class jt extends Le{constructor(t=!1){super(!0,t)}set(t,n){return!0}deleteProperty(t,n){return!0}}const Dt=new $t,Ft=new jt,ye=e=>e,Q=e=>Reflect.getPrototypeOf(e);function Pt(e,t,n){return function(...s){const r=this.__v_raw,o=p(r),i=Y(o),c=e==="entries"||e===Symbol.iterator&&i,a=e==="keys"&&i,u=r[e](...s),l=n?ye:t?we:v;return!t&&E(o,"iterate",a?pe:C),{next(){const{value:f,done:d}=u.next();return d?{value:f,done:d}:{value:c?[l(f[0]),l(f[1])]:l(f),done:d}},[Symbol.iterator](){return this}}}}function X(e){return function(...t){return e==="delete"?!1:e==="clear"?void 0:this}}function At(e,t){const n={get(r){const o=this.__v_raw,i=p(o),c=p(r);e||(W(r,c)&&E(i,"get",r),E(i,"get",c));const{has:a}=Q(i),u=t?ye:e?we:v;if(a.call(i,r))return u(o.get(r));if(a.call(i,c))return u(o.get(c));o!==i&&o.get(r)},get size(){const r=this.__v_raw;return!e&&E(p(r),"iterate",C),Reflect.get(r,"size",r)},has(r){const o=this.__v_raw,i=p(o),c=p(r);return e||(W(r,c)&&E(i,"has",r),E(i,"has",c)),r===c?o.has(r):o.has(r)||o.has(c)},forEach(r,o){const i=this,c=i.__v_raw,a=p(c),u=t?ye:e?we:v;return!e&&E(a,"iterate",C),c.forEach((l,f)=>r.call(o,u(l),u(f),i))}};return ze(n,e?{add:X("add"),set:X("set"),delete:X("delete"),clear:X("clear")}:{add(r){!t&&!N(r)&&!j(r)&&(r=p(r));const o=p(this);return Q(o).has.call(o,r)||(o.add(r),I(o,"add",r,r)),this},set(r,o){!t&&!N(o)&&!j(o)&&(o=p(o));const i=p(this),{has:c,get:a}=Q(i);let u=c.call(i,r);u||(r=p(r),u=c.call(i,r));const l=a.call(i,r);return i.set(r,o),u?W(o,l)&&I(i,"set",r,o,l):I(i,"add",r,o),this},delete(r){const o=p(this),{has:i,get:c}=Q(o);let a=i.call(o,r);a||(r=p(r),a=i.call(o,r));const u=c?c.call(o,r):void 0,l=o.delete(r);return a&&I(o,"delete",r,void 0,u),l},clear(){const r=p(this),o=r.size!==0,i=void 0,c=r.clear();return o&&I(r,"clear",void 0,void 0,i),c}}),["keys","values","entries",Symbol.iterator].forEach(r=>{n[r]=Pt(r,e,t)}),n}function We(e,t){const n=At(e,t);return(s,r,o)=>r==="__v_isReactive"?!e:r==="__v_isReadonly"?e:r==="__v_raw"?s:Reflect.get(se(n,r)&&r in s?n:s,r,o)}const Lt={get:We(!1,!1)},Wt={get:We(!0,!1)};function Wn(e,t,n){const s=p(n);if(s!==n&&t.call(e,s)){const r=ke(e);Rt(`Reactive ${r} contains both the raw and reactive versions of the same object${r==="Map"?" as keys":""}, which can lead to inconsistencies. Avoid differentiating between the raw and reactive versions of an object and only use the reactive version if possible.`)}}const He=new WeakMap,Ht=new WeakMap,Ke=new WeakMap,Kt=new WeakMap;function qt(e){switch(e){case"Object":case"Array":return 1;case"Map":case"Set":case"WeakMap":case"WeakSet":return 2;default:return 0}}function Ut(e){return e.__v_skip||!Object.isExtensible(e)?0:qt(ke(e))}function qe(e){return j(e)?e:Je(e,!1,Dt,Lt,He)}function Ue(e){return Je(e,!0,Ft,Wt,Ke)}function Je(e,t,n,s,r){if(!B(e)||e.__v_raw&&!(t&&e.__v_isReactive))return e;const o=Ut(e);if(o===0)return e;const i=r.get(e);if(i)return i;const c=new Proxy(e,o===2?s:n);return r.set(e,c),c}function j(e){return!!(e&&e.__v_isReadonly)}function N(e){return!!(e&&e.__v_isShallow)}function Jt(e){return e?!!e.__v_raw:!1}function p(e){const t=e&&e.__v_raw;return t?p(t):e}const v=e=>B(e)?qe(e):e,we=e=>B(e)?Ue(e):e;function V(e){return e?e.__v_isRef===!0:!1}function Yt(e){return Bt(e,!1)}function Bt(e,t){return V(e)?e:new Gt(e,t)}class Gt{constructor(t,n){this.dep=new Fe,this.__v_isRef=!0,this.__v_isShallow=!1,this._rawValue=n?t:p(t),this._value=n?t:v(t),this.__v_isShallow=n}get value(){return this.dep.track(),this._value}set value(t){const n=this._rawValue,s=this.__v_isShallow||N(t)||j(t);t=s?t:p(t),W(t,n)&&(this._rawValue=t,this._value=s?t:v(t),this.dep.trigger())}}/**
* @vue/runtime-core v3.5.17
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/const k=[];function Hn(e){k.push(e)}function Kn(){k.pop()}let be=!1;function qn(e,...t){if(be)return;be=!0,fe();const n=k.length?k[k.length-1].component:null,s=n&&n.appContext.config.warnHandler,r=Qt();if(s)ve(s,n,11,[e+t.map(o=>{var i,c;return(c=(i=o.toString)==null?void 0:i.call(o))!=null?c:JSON.stringify(o)}).join(""),n&&n.proxy,r.map(({vnode:o})=>`at <${et(n,o.type)}>`).join(`
`),r]);else{const o=[`[Vue warn]: ${e}`,...t];r.length&&o.push(`
`,...Xt(r)),console.warn(...o)}de(),be=!1}function Qt(){let e=k[k.length-1];if(!e)return[];const t=[];for(;e;){const n=t[0];n&&n.vnode===e?n.recurseCount++:t.push({vnode:e,recurseCount:0});const s=e.component&&e.component.parent;e=s&&s.vnode}return t}function Xt(e){const t=[];return e.forEach((n,s)=>{t.push(...s===0?[]:[`
`],...Zt(n))}),t}function Zt({vnode:e,recurseCount:t}){const n=t>0?`... (${t} recursive calls)`:"",s=e.component?e.component.parent==null:!1,r=` at <${et(e.component,e.type,s)}`,o=">"+n;return e.props?[r,...en(e.props),o]:[r+o]}function en(e){const t=[],n=Object.keys(e);return n.slice(0,3).forEach(s=>{t.push(...Ye(s,e[s]))}),n.length>3&&t.push(" ..."),t}function Ye(e,t,n){return Ce(t)?(t=JSON.stringify(t),n?t:[`${e}=${t}`]):typeof t=="number"||typeof t=="boolean"||t==null?n?t:[`${e}=${t}`]:V(t)?(t=Ye(e,p(t.value),!0),n?t:[`${e}=Ref<`,t,">"]):oe(t)?[`${e}=fn${t.name?`<${t.name}>`:""}`]:(t=p(t),n?t:[`${e}=`,t])}const Un={sp:"serverPrefetch hook",bc:"beforeCreate hook",c:"created hook",bm:"beforeMount hook",m:"mounted hook",bu:"beforeUpdate hook",u:"updated",bum:"beforeUnmount hook",um:"unmounted hook",a:"activated hook",da:"deactivated hook",ec:"errorCaptured hook",rtc:"renderTracked hook",rtg:"renderTriggered hook",0:"setup function",1:"render function",2:"watcher getter",3:"watcher callback",4:"watcher cleanup function",5:"native event handler",6:"component event handler",7:"vnode hook",8:"directive hook",9:"transition hook",10:"app errorHandler",11:"app warnHandler",12:"ref function",13:"async component loader",14:"scheduler flush",15:"component update",16:"app unmount cleanup function"};function ve(e,t,n,s){try{return s?e(...s):e()}catch(r){Be(r,t,n)}}function Be(e,t,n,s=!0){const r=t?t.vnode:null,{errorHandler:o,throwUnhandledErrorInProduction:i}=t&&t.appContext.config||Ot;if(t){let c=t.parent;const a=t.proxy,u=`https://vuejs.org/error-reference/#runtime-${n}`;for(;c;){const l=c.ec;if(l){for(let f=0;f<l.length;f++)if(l[f](e,a,u)===!1)return}c=c.parent}if(o){fe(),ve(o,null,10,[e,a,u]),de();return}}tn(e,n,r,s,i)}function tn(e,t,n,s=!0,r=!1){if(r)throw e;console.error(e)}const x=[];let S=-1;const D=[];let M=null,F=0;const nn=Promise.resolve();let Ee=null;const rn=100;function sn(e){let t=S+1,n=x.length;for(;t<n;){const s=t+n>>>1,r=x[s],o=q(r);o<e||o===e&&r.flags&2?t=s+1:n=s}return t}function on(e){if(!(e.flags&1)){const t=q(e),n=x[x.length-1];!n||!(e.flags&2)&&t>=q(n)?x.push(e):x.splice(sn(t),0,e),e.flags|=1,Ge()}}function Ge(){Ee||(Ee=nn.then(Qe))}function cn(e){z(e)?D.push(...e):M&&e.id===-1?M.splice(F+1,0,e):e.flags&1||(D.push(e),e.flags|=1),Ge()}function an(e){if(D.length){const t=[...new Set(D)].sort((n,s)=>q(n)-q(s));if(D.length=0,M){M.push(...t);return}for(M=t,F=0;F<M.length;F++){const n=M[F];n.flags&4&&(n.flags&=-2),n.flags&8||n(),n.flags&=-2}M=null,F=0}}const q=e=>e.id==null?e.flags&2?-1:1/0:e.id;function Qe(e){const t=St;try{for(S=0;S<x.length;S++){const n=x[S];n&&!(n.flags&8)&&(n.flags&4&&(n.flags&=-2),ve(n,n.i,n.i?15:14),n.flags&4||(n.flags&=-2))}}finally{for(;S<x.length;S++){const n=x[S];n&&(n.flags&=-2)}S=-1,x.length=0,an(e),Ee=null,(x.length||D.length)&&Qe(e)}}function Jn(e,t){const n=e.get(t)||0;if(n>rn){const s=t.i,r=s&&Ze(s.type);return Be(`Maximum recursive updates exceeded${r?` in component <${r}>`:""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,null,10),!0}return e.set(t,n+1),!1}const xe=new Map,Z=new Map;function Yn(e,t){return Z.has(e)?!1:(Z.set(e,{initialDef:ee(t),instances:new Set}),!0)}function ee(e){return fn(e)?e.__vccOpts:e}function Bn(e,t){const n=Z.get(e);n&&(n.initialDef.render=t,[...n.instances].forEach(s=>{t&&(s.render=t,ee(s.type).render=t),s.renderCache=[],s.update()}))}function Gn(e,t){const n=Z.get(e);if(!n)return;t=ee(t),Xe(n.initialDef,t);const s=[...n.instances];for(let r=0;r<s.length;r++){const o=s[r],i=ee(o.type);let c=xe.get(i);c||(i!==n.initialDef&&Xe(i,t),xe.set(i,c=new Set)),c.add(o),o.appContext.propsCache.delete(o.type),o.appContext.emitsCache.delete(o.type),o.appContext.optionsCache.delete(o.type),o.ceReload?(c.add(o),o.ceReload(t.styles),c.delete(o)):o.parent?on(()=>{o.parent.update(),c.delete(o)}):o.appContext.reload?o.appContext.reload():typeof window<"u"?window.location.reload():console.warn("[HMR] Root or manually mounted instance modified. Full reload required."),o.root.ce&&o!==o.root&&o.root.ce._removeChildStyle(i)}cn(()=>{xe.clear()})}function Xe(e,t){ze(e,t);for(const n in e)n!=="__file"&&!(n in t)&&delete e[n]}function Qn(e){return(t,n)=>{try{return e(t,n)}catch(s){console.error(s),console.warn("[HMR] Something went wrong during Vue component hot-reload. Full reload required.")}}}ce().requestIdleCallback,ce().cancelIdleCallback;const Xn={};{const e=ce(),t=(n,s)=>{let r;return(r=e[n])||(r=e[n]=[]),r.push(s),o=>{r.length>1?r.forEach(i=>i(o)):r[0](o)}};t("__VUE_INSTANCE_SETTERS__",n=>n),t("__VUE_SSR_SETTERS__",n=>n)}const un=/(?:^|[-_])(\w)/g,ln=e=>e.replace(un,t=>t.toUpperCase()).replace(/[-_]/g,"");function Ze(e,t=!0){return oe(e)?e.displayName||e.name:e.name||t&&e.__name}function et(e,t,n=!1){let s=Ze(t);if(!s&&t.__file){const r=t.__file.match(/([^/\\]+)\.\w+$/);r&&(s=r[1])}if(!s&&e&&e.parent){const r=o=>{for(const i in o)if(o[i]===t)return i};s=r(e.components||e.parent.type.components)||r(e.appContext.components)}return s?ln(s):n?"App":"Anonymous"}function fn(e){return oe(e)&&"__vccOpts"in e}const tt=()=>document.documentElement.getAttribute("data-theme")==="dark";[...new Array(6)].map((e,t)=>`[vp-content] h${t+1}`).join(",");const{entries:dn}=Object,{fromEntries:hn}=Object,nt=Yt(!1);typeof document<"u"&&(nt.value=tt(),new MutationObserver(()=>{nt.value=tt()}).observe(document.documentElement,{attributeFilter:["data-theme"],attributes:!0}));const pn="ENTRIES",rt="KEYS",st="VALUES",w="";class Oe{set;_type;_path;constructor(t,n){const s=t._tree,r=Array.from(s.keys());this.set=t,this._type=n,this._path=r.length>0?[{node:s,keys:r}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:n}=P(this._path);if(P(n)===w)return{done:!1,value:this.result()};const s=t.get(P(n));return this._path.push({node:s,keys:Array.from(s.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=P(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>P(t)).filter(t=>t!==w).join("")}value(){return P(this._path).node.get(w)}result(){switch(this._type){case st:return this.value();case rt:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const P=e=>e[e.length-1],gn=(e,t,n)=>{const s=new Map;if(typeof t!="string")return s;const r=t.length+1,o=r+n,i=new Uint8Array(o*r).fill(n+1);for(let c=0;c<r;++c)i[c]=c;for(let c=1;c<o;++c)i[c*r]=c;return ot(e,t,n,s,i,1,r,""),s},ot=(e,t,n,s,r,o,i,c)=>{const a=o*i;e:for(const u of e.keys())if(u===w){const l=r[a-1];l<=n&&s.set(c,[e.get(u),l])}else{let l=o;for(let f=0;f<u.length;++f,++l){const d=u[f],m=i*l,b=m-i;let g=r[m];const h=Math.max(0,l-n-1),_=Math.min(i-1,l+n);for(let y=h;y<_;++y){const R=d!==t[y],re=r[b+y]+ +R,J=r[b+y+1]+1,T=r[m+y]+1,A=r[m+y+1]=Math.min(re,J,T);A<g&&(g=A)}if(g>n)continue e}ot(e.get(u),t,n,s,r,l,i,c+u)}};let it=class U{_tree;_prefix;_size=void 0;constructor(t=new Map,n=""){this._tree=t,this._prefix=n}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[n,s]=te(this._tree,t.slice(this._prefix.length));if(n===void 0){const[r,o]=Ne(s);for(const i of r.keys())if(i!==w&&i.startsWith(o)){const c=new Map;return c.set(i.slice(o.length),r.get(i)),new U(c,t)}}return new U(n,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,_n(this._tree,t)}entries(){return new Oe(this,pn)}forEach(t){for(const[n,s]of this)t(n,s,this)}fuzzyGet(t,n){return gn(this._tree,t,n)}get(t){const n=Se(this._tree,t);return n!==void 0?n.get(w):void 0}has(t){return Se(this._tree,t)?.has(w)??!1}keys(){return new Oe(this,rt)}set(t,n){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,Ie(this._tree,t).set(w,n),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,n){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const s=Ie(this._tree,t);return s.set(w,n(s.get(w))),this}fetch(t,n){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const s=Ie(this._tree,t);let r=s.get(w);return r===void 0&&s.set(w,r=n()),r}values(){return new Oe(this,st)}[Symbol.iterator](){return this.entries()}static from(t){const n=new U;for(const[s,r]of t)n.set(s,r);return n}static fromObject(t){return U.from(Object.entries(t))}};const te=(e,t,n=[])=>{if(t.length===0||e==null)return[e,n];for(const s of e.keys())if(s!==w&&t.startsWith(s))return n.push([e,s]),te(e.get(s),t.slice(s.length),n);return n.push([e,t]),te(void 0,"",n)},Se=(e,t)=>{if(t.length===0||!e)return e;for(const n of e.keys())if(n!==w&&t.startsWith(n))return Se(e.get(n),t.slice(n.length))},Ie=(e,t)=>{const n=t.length;e:for(let s=0;e&&s<n;){for(const o of e.keys())if(o!==w&&t[s]===o[0]){const i=Math.min(n-s,o.length);let c=1;for(;c<i&&t[s+c]===o[c];)++c;const a=e.get(o);if(c===o.length)e=a;else{const u=new Map;u.set(o.slice(c),a),e.set(t.slice(s,s+c),u),e.delete(o),e=u}s+=c;continue e}const r=new Map;return e.set(t.slice(s),r),r}return e},_n=(e,t)=>{const[n,s]=te(e,t);if(n!==void 0){if(n.delete(w),n.size===0)ct(s);else if(n.size===1){const[r,o]=n.entries().next().value;at(s,r,o)}}},ct=e=>{if(e.length===0)return;const[t,n]=Ne(e);if(t.delete(n),t.size===0)ct(e.slice(0,-1));else if(t.size===1){const[s,r]=t.entries().next().value;s!==w&&at(e.slice(0,-1),s,r)}},at=(e,t,n)=>{if(e.length===0)return;const[s,r]=Ne(e);s.set(r+t,n),s.delete(r)},Ne=e=>e[e.length-1],mn=(e,t)=>{const n=e._idToShortId.get(t);if(n!=null)return e._storedFields.get(n)},yn=/[\n\r\p{Z}\p{P}]+/u,Me="or",ut="and",wn="and_not",bn=(e,t)=>{e.includes(t)||e.push(t)},lt=(e,t)=>{for(const n of t)e.includes(n)||e.push(n)},ft=({score:e},{score:t})=>t-e,vn=()=>new Map,ne=e=>{const t=new Map;for(const n of Object.keys(e))t.set(parseInt(n,10),e[n]);return t},dt=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,ht={[Me]:(e,t)=>{for(const n of t.keys()){const s=e.get(n);if(s==null)e.set(n,t.get(n));else{const{score:r,terms:o,match:i}=t.get(n);s.score=s.score+r,s.match=Object.assign(s.match,i),lt(s.terms,o)}}return e},[ut]:(e,t)=>{const n=new Map;for(const s of t.keys()){const r=e.get(s);if(r==null)continue;const{score:o,terms:i,match:c}=t.get(s);lt(r.terms,i),n.set(s,{score:r.score+o,terms:r.terms,match:Object.assign(r.match,c)})}return n},[wn]:(e,t)=>{for(const n of t.keys())e.delete(n);return e}},En=(e,t,n,s,r,o)=>{const{k:i,b:c,d:a}=o;return Math.log(1+(n-t+.5)/(t+.5))*(a+e*(i+1)/(e+i*(1-c+c*s/r)))},xn=e=>(t,n,s)=>({term:t,fuzzy:typeof e.fuzzy=="function"?e.fuzzy(t,n,s):e.fuzzy??!1,prefix:typeof e.prefix=="function"?e.prefix(t,n,s):e.prefix===!0,termBoost:typeof e.boostTerm=="function"?e.boostTerm(t,n,s):1}),pt=(e,t,n,s)=>{for(const r of Object.keys(e._fieldIds))if(e._fieldIds[r]===n){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${s}" was not present in field "${r}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},On=(e,t,n,s)=>{if(!e._index.has(s)){pt(e,n,t,s);return}const r=e._index.fetch(s,vn),o=r.get(t),i=o?.get(n);!o||typeof i>"u"?pt(e,n,t,s):i<=1?o.size<=1?r.delete(t):o.delete(n):o.set(n,i-1),e._index.get(s).size===0&&e._index.delete(s)},Sn={k:1.2,b:.7,d:.5},In={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(yn),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{console?.[e]?.(t)},autoVacuum:!0},gt={combineWith:Me,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:Sn},Nn={combineWith:ut,prefix:(e,t,n)=>t===n.length-1},Mn={batchSize:1e3,batchWait:10},_t={minDirtFactor:.1,minDirtCount:20},Rn={...Mn,..._t},mt=Symbol("*"),Tn=(e,t)=>{const n=new Map,s={...e._options.searchOptions,...t};for(const[r,o]of e._documentIds){const i=s.boostDocument?s.boostDocument(o,"",e._storedFields.get(r)):1;n.set(r,{score:i,terms:[],match:{}})}return n},yt=(e,t=Me)=>{if(e.length===0)return new Map;const n=t.toLowerCase();if(!(n in ht))throw new Error(`Invalid combination operator: ${t}`);return e.reduce(ht[n])},Re=(e,t,n,s,r,o,i,c,a,u=new Map)=>{if(o==null)return u;for(const l of Object.keys(i)){const f=i[l],d=e._fieldIds[l],m=o.get(d);if(m==null)continue;let b=m.size;const g=e._avgFieldLength[d];for(const h of m.keys()){if(!e._documentIds.has(h)){On(e,d,h,n),b-=1;continue}const _=c?c(e._documentIds.get(h),n,e._storedFields.get(h)):1;if(!_)continue;const y=m.get(h),R=e._fieldLength.get(h)[d],re=En(y,b,e._documentCount,R,g,a),J=s*r*f*_*re,T=u.get(h);if(T){T.score+=J,bn(T.terms,t);const A=dt(T.match,n);A?A.push(l):T.match[n]=[l]}else u.set(h,{score:J,terms:[t],match:{[n]:[l]}})}}return u},zn=(e,t,n)=>{const s={...e._options.searchOptions,...n},r=(s.fields??e._options.fields).reduce((g,h)=>({...g,[h]:dt(s.boost,h)||1}),{}),{boostDocument:o,weights:i,maxFuzzy:c,bm25:a}=s,{fuzzy:u,prefix:l}={...gt.weights,...i},f=e._index.get(t.term),d=Re(e,t.term,t.term,1,t.termBoost,f,r,o,a);let m,b;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const g=t.fuzzy===!0?.2:t.fuzzy,h=g<1?Math.min(c,Math.round(t.term.length*g)):g;h&&(b=e._index.fuzzyGet(t.term,h))}if(m)for(const[g,h]of m){const _=g.length-t.term.length;if(!_)continue;b?.delete(g);const y=l*g.length/(g.length+.3*_);Re(e,t.term,g,y,t.termBoost,h,r,o,a,d)}if(b)for(const g of b.keys()){const[h,_]=b.get(g);if(!_)continue;const y=u*g.length/(g.length+_);Re(e,t.term,g,y,t.termBoost,h,r,o,a,d)}return d},wt=(e,t,n={})=>{if(t===mt)return Tn(e,n);if(typeof t!="string"){const l={...n,...t,queries:void 0},f=t.queries.map(d=>wt(e,d,l));return yt(f,l.combineWith)}const{tokenize:s,processTerm:r,searchOptions:o}=e._options,i={tokenize:s,processTerm:r,...o,...n},{tokenize:c,processTerm:a}=i,u=c(t).flatMap(l=>a(l)).filter(l=>!!l).map(xn(i)).map(l=>zn(e,l,i));return yt(u,i.combineWith)},bt=(e,t,n={})=>{const{searchOptions:s}=e._options,r={...s,...n},o=wt(e,t,n),i=[];for(const[c,{score:a,terms:u,match:l}]of o){const f=u.length||1,d={id:e._documentIds.get(c),score:a*f,terms:Object.keys(l),queryTerms:u,match:l};Object.assign(d,e._storedFields.get(c)),(r.filter==null||r.filter(d))&&i.push(d)}return t===mt&&r.boostDocument==null||i.sort(ft),i},Cn=(e,t,n={})=>{n={...e._options.autoSuggestOptions,...n};const s=new Map;for(const{score:o,terms:i}of bt(e,t,n)){const c=i.join(" "),a=s.get(c);a!=null?(a.score+=o,a.count+=1):s.set(c,{score:o,terms:i,count:1})}const r=[];for(const[o,{score:i,terms:c,count:a}]of s)r.push({suggestion:o,terms:c,score:i/a});return r.sort(ft),r};class Vn{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(!t?.fields)throw new Error('SlimSearch: option "fields" must be provided');const n=t.autoVacuum==null||t.autoVacuum===!0?Rn:t.autoVacuum;this._options={...In,...t,autoVacuum:n,searchOptions:{...gt,...t.searchOptions},autoSuggestOptions:{...Nn,...t.autoSuggestOptions}},this._index=new it,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=_t,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[n,s]of this._index){const r={};for(const[o,i]of s)r[o]=Object.fromEntries(i);t.push([n,r])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,version:2}}addFields(t){for(let n=0;n<t.length;n++)this._fieldIds[t[n]]=n}}const kn=e=>new Vn(e),$n=({documentCount:e,nextId:t,fieldIds:n,averageFieldLength:s,dirtCount:r,version:o},i)=>{if(o!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const c=kn(i);return c._documentCount=e,c._nextId=t,c._idToShortId=new Map,c._fieldIds=n,c._avgFieldLength=s,c._dirtCount=r??0,c._index=new it,c},jn=(e,t)=>{const{index:n,documentIds:s,fieldLength:r,storedFields:o}=e,i=$n(e,t);i._documentIds=ne(s),i._fieldLength=ne(r),i._storedFields=ne(o);for(const[c,a]of i._documentIds)i._idToShortId.set(a,c);for(const[c,a]of n){const u=new Map;for(const l of Object.keys(a))u.set(parseInt(l,10),ne(a[l]));i._index.set(c,u)}return i},Te=(e,t)=>{const n=e.toLowerCase(),s=t.toLowerCase(),r=[];let o=0,i=0;const c=(u,l=!1)=>{let f;i===0?f=u.length>20?`… ${u.slice(-20)}`:u:l?f=u.length+i>100?`${u.slice(0,100-i)}… `:u:f=u.length>20?`${u.slice(0,20)} … ${u.slice(-20)}`:u,f&&r.push(f),i+=f.length,l||(r.push(["mark",t]),i+=t.length,i>=100&&r.push(" …"))};let a=n.indexOf(s,o);if(a===-1)return null;for(;a>=0;){const u=a+s.length;if(c(e.slice(o,a)),o=u,i>100)break;a=n.indexOf(s,o)}return i<100&&c(e.slice(o),!0),r},{entries:Dn}=Object,Fn=(e,t)=>t.contents.reduce((n,[,s])=>n+s,0)-e.contents.reduce((n,[,s])=>n+s,0),Pn=(e,t)=>Math.max(...t.contents.map(([,n])=>n))-Math.max(...e.contents.map(([,n])=>n)),vt=(e,t,n={},s="max")=>{const r={};return bt(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...n}).forEach(o=>{const{id:i,terms:c,score:a}=o,u=i.includes("@"),l=i.includes("#"),[f,d]=i.split(/[#@]/),m=Number(f),b=c.sort((h,_)=>h.length-_.length).filter((h,_)=>c.slice(_+1).every(y=>!y.includes(h))),{contents:g}=r[m]??={title:"",contents:[]};if(u)g.push([{type:"customField",id:m,index:d,display:b.map(h=>o.c.map(_=>Te(_,h))).flat().filter(h=>h!==null)},a]);else{const h=b.map(_=>Te(o.h,_)).filter(_=>_!==null);if(h.length&&g.push([{type:l?"heading":"title",id:m,...l&&{anchor:d},display:h},a]),"t"in o&&o.t)for(const _ of o.t){const y=b.map(R=>Te(_,R)).filter(R=>R!==null);y.length&&g.push([{type:"text",id:m,...l&&{anchor:d},display:y},a])}}}),Dn(r).sort(([,o],[,i])=>(s?Fn:Pn)(o,i)).map(([o,{title:i,contents:c}])=>{if(!i){const a=mn(t,o);a&&(i=a.h)}return{title:i,contents:c.map(([a])=>a)}})},Et=(e,t,n={})=>{const s=Cn(t,e,{fuzzy:.2,maxFuzzy:3,...n}).map(({suggestion:r})=>r);return e.includes(" ")?s:s.filter(r=>!r.includes(" "))},An=hn(dn(JSON.parse("{\"/\":{\"documentCount\":890,\"nextId\":890,\"documentIds\":{\"0\":\"0\",\"1\":\"1\",\"2\":\"1#binary-oracle\",\"3\":\"1#elowen\",\"4\":\"2\",\"5\":\"2#摘要\",\"6\":\"2#简介\",\"7\":\"2#相关工作\",\"8\":\"2#方法\",\"9\":\"2#_3-2-multi-head-affordance-chain-of-thought\",\"10\":\"2#fine-tuning-mllm\",\"11\":\"2#object-head-reasoning-几何推理\",\"12\":\"2#affordance-head-reasoning-类比推理\",\"13\":\"2#knowledge-encoding-and-integration\",\"14\":\"2#_3-3-cross-modal-adaptive-fusion-module-cmafm\",\"15\":\"2#_3-4-decoder-and-loss-functions\",\"16\":\"2#数据集\",\"17\":\"2#数据收集-collection\",\"18\":\"2#标注策略-annotation\",\"19\":\"2#统计分析-statistical-analysis\",\"20\":\"2#数据划分-data-partitions\",\"21\":\"2#实验\",\"22\":\"2#_5-1-benchmark-setting\",\"23\":\"2#_5-2-comparison-results\",\"24\":\"2#_5-3-ablation-study\",\"25\":\"2#_5-4-performance-analysis\",\"26\":\"2#结论\",\"27\":\"2#代码\",\"28\":\"2#multi-head-affordance-chain-of-thought\",\"29\":\"2#数据集-1\",\"30\":\"2#模型\",\"31\":\"2#文本编码\",\"32\":\"2#改良的交叉注意力\",\"33\":\"2#几何结构信息与交互信息的融合\",\"34\":\"2#交互信息与图像特征的融合\",\"35\":\"2#解码阶段\",\"36\":\"2#点云特征与几何结构特征的融合\",\"37\":\"3\",\"38\":\"3#环境配置-待完善\",\"39\":\"3#模型结构\",\"40\":\"3#lmaffordance3d\",\"41\":\"3#step-2-融合多模态空间特征\",\"42\":\"3#step-3-多模态特征投影到语言语义空间\",\"43\":\"3#step-6-拼接多模态嵌入与语言嵌入\",\"44\":\"3#step-8-降维适配器\",\"45\":\"3#step-9-解码器融合所有特征以预测可操作性特征\",\"46\":\"3#step-10-使用分割头预测最终的-3d-可操作性热图\",\"47\":\"4\",\"48\":\"4#摘要\",\"49\":\"4#简介\",\"50\":\"4#相关工作\",\"51\":\"4#_1-功能学习-affordance-learning\",\"52\":\"4#_2-图像-点云跨模态学习\",\"53\":\"4#方法\",\"54\":\"4#_1-整体框架-iag网络\",\"55\":\"4#_2-损失函数\",\"56\":\"4#_3-关键创新\",\"57\":\"4#代码\",\"58\":\"4#数据集\",\"59\":\"4#模型\",\"60\":\"5\",\"61\":\"5#数据集\",\"62\":\"5#_1-基础数据来源\",\"63\":\"5#_2-构建问题-question-crafting\",\"64\":\"5#_3-标注-gt-mask-ground-truth-mask\",\"65\":\"5#_4-数据集组织方式\",\"66\":\"5#_5-数据增强与配对策略\",\"67\":\"5#_6-数据集统计信息-来自论文图3\",\"68\":\"5#_7-代码实现\",\"69\":\"5#_8-总结\",\"70\":\"5#模型实现\",\"71\":\"5#afm-自适应融合模块\",\"72\":\"5#_1️⃣-grouping-文本引导的点特征分组\",\"73\":\"5#_2️⃣-mixing-mlp-mixer-进行组内和通道间的信息混合\",\"74\":\"5#_3️⃣-ungrouping-将融合特征映射回点空间\",\"75\":\"5#_4️⃣-afm-自适应融合模块\",\"76\":\"5#rpo-参考点解码器\",\"77\":\"5#损失函数\",\"78\":\"5#hm-loss-hybrid-mask-loss\",\"79\":\"5#训练\",\"80\":\"5#准备\",\"81\":\"5#训练-1\",\"82\":\"5#评估\",\"83\":\"5#复现\",\"84\":\"6\",\"85\":\"7\",\"86\":\"7#背景\",\"87\":\"7#模型结构\",\"88\":\"7#层次化点集特征学习\",\"89\":\"7#sampling-layer\",\"90\":\"7#grouping-layer\",\"91\":\"7#pointnet-layer\",\"92\":\"7#代码实现\",\"93\":\"7#单尺度分组分类模型\",\"94\":\"7#非均匀密度下稳定的特征学习\",\"95\":\"7#多尺度分组-multi-scale-grouping\",\"96\":\"7#多尺度分组分类模型\",\"97\":\"7#多分辨率分组-multi-resolution-grouping\",\"98\":\"7#点云语义分割\",\"99\":\"7#代码实现-1\",\"100\":\"7#特征传播层\",\"101\":\"7#点云语义分割模型\",\"102\":\"8\",\"103\":\"8#核心\",\"104\":\"8#难点\",\"105\":\"8#解决方案\",\"106\":\"8#代码-pytorch版本\",\"107\":\"8#输入标准化\",\"108\":\"8#正则化损失\",\"109\":\"8#特征提取\",\"110\":\"8#分类任务\",\"111\":\"8#分割任务\",\"112\":\"8#缺陷\",\"113\":\"8#背景知识扫盲-可选\",\"114\":\"8#点云\",\"115\":\"8#对称函数\",\"116\":\"8#刚性运动\",\"117\":\"8#正交变换\",\"118\":\"9\",\"119\":\"10\",\"120\":\"10#introduction\",\"121\":\"10#related-work\",\"122\":\"10#视觉-语言预训练-vlp\",\"123\":\"10#知识蒸馏-knowledge-distillation\",\"124\":\"10#数据增强-data-augmentation\",\"125\":\"10#method\",\"126\":\"10#模型架构-med-multimodal-mixture-of-encoder-decoder\",\"127\":\"10#预训练目标-itc、itm、lm\",\"128\":\"10#capfilt-图文数据的自举式清洗机制\",\"129\":\"10#小结\",\"130\":\"10#experiments-and-discussions\",\"131\":\"10#预训练细节\",\"132\":\"10#capfilt-效果验证\",\"133\":\"10#合成文本的多样性对性能的影响\",\"134\":\"10#编码器-解码器参数共享与解耦\",\"135\":\"10#ablation-study\",\"136\":\"10#capfilt-的性能提升并非源于更长的训练时间\",\"137\":\"10#应使用-bootstrapped-数据集重新训练模型\",\"138\":\"10#conclusion\",\"139\":\"10#code-implementation\",\"140\":\"10#capfilt-模块实现\",\"141\":\"10#captioner-模块\",\"142\":\"10#微调阶段\",\"143\":\"10#生成阶段\",\"144\":\"10#filter-模块\",\"145\":\"10#微调阶段-1\",\"146\":\"10#过滤阶段\",\"147\":\"10#blip-预训练\",\"148\":\"11\",\"149\":\"11#introduction\",\"150\":\"11#related-work\",\"151\":\"11#albef\",\"152\":\"11#model-structure\",\"153\":\"11#pre-training-objectives\",\"154\":\"11#image-text-contrastive-learning\",\"155\":\"11#masked-language-modeling-mlm\",\"156\":\"11#image-text-matching-itm\",\"157\":\"11#momentum-distillation\",\"158\":\"11#code-implementation\",\"159\":\"11#train\",\"160\":\"11#model-init\",\"161\":\"11#itc\",\"162\":\"11#itm\",\"163\":\"11#mlm\",\"164\":\"12\",\"165\":\"12#引言\",\"166\":\"12#方法\",\"167\":\"12#预训练阶段一-向量量化知识蒸馏算法用于d-vae预训练\",\"168\":\"12#代码实现\",\"169\":\"12#码本-ema\",\"170\":\"12#向量量化器\",\"171\":\"13\",\"172\":\"14\",\"173\":\"14#引言\",\"174\":\"14#相关工作\",\"175\":\"14#自监督学习的发展路径\",\"176\":\"14#自训练与知识蒸馏的联系\",\"177\":\"14#方法\",\"178\":\"14#基于知识蒸馏的自监督学习\",\"179\":\"14#实现细节\",\"180\":\"14#消融实验\",\"181\":\"14#patch大小的重要性\",\"182\":\"14#教师网络的选择\",\"183\":\"14#避免崩溃\",\"184\":\"14#计算需求\",\"185\":\"14#小批量训练\",\"186\":\"14#代码解析\",\"187\":\"15\",\"188\":\"15#摘要\",\"189\":\"15#简介\",\"190\":\"15#相关工作\",\"191\":\"15#_1-视觉基础模型-vision-foundation-models\",\"192\":\"15#_2-大语言模型-large-language-models-llms\",\"193\":\"15#_3-视觉大语言模型-vision-large-language-models-vllms\",\"194\":\"15#核心问题与本文定位\",\"195\":\"15#方法\",\"196\":\"15#_1-整体架构设计\",\"197\":\"15#_2-模型设计\",\"198\":\"15#_3-对齐策略\",\"199\":\"15#实现细节\",\"200\":\"15#实验\",\"201\":\"15#视觉感知能力验证-visual-perception-benchmarks\",\"202\":\"15#视觉-语言任务能力-vision-language-benchmarks\",\"203\":\"15#多模态对话任务-multi-modal-dialogue-benchmarks\",\"204\":\"15#消融实验-ablation-study\",\"205\":\"15#总结\",\"206\":\"15#结论\",\"207\":\"15#详细训练设置-附录内容\",\"208\":\"15#第一阶段设置-stage-1\",\"209\":\"15#第二阶段设置-stage-2\",\"210\":\"15#第三阶段设置-stage-3\",\"211\":\"15#检索任务微调设置\",\"212\":\"15#imagenet-线性探测设置\",\"213\":\"15#ade20k-语义分割设置\",\"214\":\"16\",\"215\":\"16#摘要\",\"216\":\"16#简介\",\"217\":\"16#相关工作\",\"218\":\"16#_1-商业专有多模态大模型-proprietary-commercial-mllms\",\"219\":\"16#_2-开源多模态大模型-open-source-mllms\",\"220\":\"16#_3-视觉基础模型-vision-foundation-models-vfms\",\"221\":\"16#方法\",\"222\":\"16#_1-整体架构\",\"223\":\"16#_2-强视觉编码器\",\"224\":\"16#_3-动态高分辨率策略\",\"225\":\"16#_4-高质量双语数据集\",\"226\":\"16#实验\",\"227\":\"16#_1-实现细节\",\"228\":\"16#_2-基准测试结果\",\"229\":\"16#_3-关键消融研究\",\"230\":\"16#结论\",\"231\":\"17\",\"232\":\"17#背景\",\"233\":\"17#方法\",\"234\":\"17#预训练\",\"235\":\"17#微调\",\"236\":\"17#联合-gpt-4-的推理机制-ensemble-with-gpt-4\",\"237\":\"17#ablation-study-消融实验\",\"238\":\"17#补充\",\"239\":\"17#辨析-instruction-tuning-和-prompt-tuning\",\"240\":\"18\",\"241\":\"18#introduction\",\"242\":\"18#what-is-contrast-learning\",\"243\":\"18#instance-discrimination-task\",\"244\":\"18#momentum-contrast\",\"245\":\"18#abstract\",\"246\":\"18#introduction-1\",\"247\":\"18#conclusion\",\"248\":\"18#related-work\",\"249\":\"18#detail\",\"250\":\"18#preview-work\",\"251\":\"18#code-implementation\",\"252\":\"18#train-code\",\"253\":\"18#model-implementation\",\"254\":\"18#model-init\",\"255\":\"18#model-forward\",\"256\":\"18#momentum-update\",\"257\":\"18#dequeue-and-enqueue\",\"258\":\"19\",\"259\":\"20\",\"260\":\"20#introduction\",\"261\":\"20#related-work\",\"262\":\"20#method\",\"263\":\"20#输入表示\",\"264\":\"20#多模态专家混合-transformer-mome-transformer\",\"265\":\"20#预训练任务\",\"266\":\"20#分阶段预训练-stagewise-pre-training\",\"267\":\"20#下游任务微调\",\"268\":\"20#ablation-studies\",\"269\":\"20#conclusion\",\"270\":\"21\",\"271\":\"21#前置知识\",\"272\":\"21#mome-mixture-of-multimodal-experts-transformer\",\"273\":\"21#vlmo\",\"274\":\"21#数据模块\",\"275\":\"21#模型实现\",\"276\":\"21#masked-language-modeling\",\"277\":\"21#contrastive-loss-for-pretraining\",\"278\":\"21#image-text-matching\",\"279\":\"22\",\"280\":\"22#introduction\",\"281\":\"22#motivation\",\"282\":\"22#method\",\"283\":\"22#modality-interaction-schema\",\"284\":\"22#model-structure\",\"285\":\"22#pretraining-objectives\",\"286\":\"22#conclusion\",\"287\":\"23\",\"288\":\"23#多模态-bert-前向传播流程\",\"289\":\"23#_1-整体流程总览-bertmodel\",\"290\":\"23#_2-编码器-bertencoder\",\"291\":\"23#_3-transformer-层-bertlayer\",\"292\":\"23#_4-attention-模块-bertattention\",\"293\":\"23#_5-核心计算-bertselfattention\",\"294\":\"23#_6-小结\",\"295\":\"23#自回归语言建模\",\"296\":\"24\",\"297\":\"24#引言\",\"298\":\"24#介绍\",\"299\":\"24#训练\",\"300\":\"24#推理\",\"301\":\"24#文本描述生成\",\"302\":\"24#花卉图片分类\",\"303\":\"24#文字搜索图像\",\"304\":\"24#完整代码\",\"305\":\"24#小结\",\"306\":\"25\",\"307\":\"25#背景\",\"308\":\"25#模型结构\",\"309\":\"25#stage-1-representation-learning-表征学习\",\"310\":\"25#_1、image-text-contrastive-learning-itc-loss-clip-like\",\"311\":\"25#_2、image-text-matching-itm-loss-二分类task\",\"312\":\"25#_3、image-grounded-text-generation-itg-loss-gpt-like\",\"313\":\"25#stage-2-generative-learning-生成学习\",\"314\":\"26\",\"315\":\"26#原理\",\"316\":\"26#_0-数据下载\",\"317\":\"26#_1-图片预处理\",\"318\":\"26#_2-图片切割\",\"319\":\"26#_3-添加-class-token\",\"320\":\"26#_4-添加位置编码\",\"321\":\"26#_5-encoder\",\"322\":\"26#_6-多头自注意力\",\"323\":\"26#_7-mlp-head\",\"324\":\"26#效果对比\",\"325\":\"26#注意力可视化\",\"326\":\"26#混合模型探索\",\"327\":\"26#加载预训练模型\",\"328\":\"26#总结\",\"329\":\"27\",\"330\":\"28\",\"331\":\"28#numpy\",\"332\":\"28#np-linspace\",\"333\":\"28#np-concatenate\",\"334\":\"29\",\"335\":\"29#python\",\"336\":\"29#作用域\",\"337\":\"29#位置参数与关键字参数\",\"338\":\"29#闭包与高阶导数\",\"339\":\"29#什么是高阶函数\",\"340\":\"29#什么是闭包\",\"341\":\"29#装饰器的实现用到了什么\",\"342\":\"29#装饰器\",\"343\":\"29#最基本的函数装饰器\",\"344\":\"29#带参数的函数装饰器\",\"345\":\"29#带参数的装饰器-装饰器工厂\",\"346\":\"29#使用-functools-wraps-保留原函数元信息\",\"347\":\"29#装饰类方法-普通方法-类方法-静态方法\",\"348\":\"29#装饰整个类\",\"349\":\"29#装饰器的底层原理与执行过程\",\"350\":\"29#多个装饰器叠加时的执行顺序-从内到外\",\"351\":\"29#类装饰器\",\"352\":\"29#总结\",\"353\":\"29#典型应用场景举例\",\"354\":\"29#地板除\",\"355\":\"29#ellipsis\",\"356\":\"30\",\"357\":\"30#pytorch\",\"358\":\"30#stack\",\"359\":\"30#transpose\",\"360\":\"30#permute\",\"361\":\"30#view\",\"362\":\"30#reshape\",\"363\":\"30#repeat\",\"364\":\"30#expand\",\"365\":\"30#torch-no-grad\",\"366\":\"30#register-buffer\",\"367\":\"30#einsum\",\"368\":\"30#where\",\"369\":\"30#torch-nn-functional-pad\",\"370\":\"30#rearrange\",\"371\":\"30#tensor-uniform\",\"372\":\"30#torch-unique-consecutive\",\"373\":\"30#torch-cumsum\",\"374\":\"30#torch-tensor-的-chunk-方法\",\"375\":\"30#torch-randperm\",\"376\":\"30#torch-randint\",\"377\":\"30#torch-bincount\",\"378\":\"30#tensor-new-zeros\",\"379\":\"30#tensor-scatter-add\",\"380\":\"31\",\"381\":\"31#模型\",\"382\":\"31#resnet18\",\"383\":\"31#bert\",\"384\":\"31#公式-定理\",\"385\":\"31#通用近似定理\",\"386\":\"31#roi-pooling\",\"387\":\"31#roi-align\",\"388\":\"31#上采样\",\"389\":\"31#最近邻-nearest-插值\",\"390\":\"31#双线性-bilinear-插值\",\"391\":\"31#余弦相似度\",\"392\":\"31#l1-归一化-l1-normalization\",\"393\":\"31#l2-归一化-l2-normalization\",\"394\":\"32\",\"395\":\"32#timm-库\",\"396\":\"32#create-model-与-register-model-装饰器\",\"397\":\"32#scikit-learn-库\",\"398\":\"32#train-test-split\",\"399\":\"32#compute-class-weight\",\"400\":\"32#python-内置-collections-库\",\"401\":\"32#counter\",\"402\":\"32#pytorch-内置-采样库\",\"403\":\"32#weightedrandomsampler\",\"404\":\"33\",\"405\":\"33#一、注意力机制的基本流程\",\"406\":\"33#二、q、k、v-的初始维度对结果的影响\",\"407\":\"33#_1-q-×-k-t-的维度\",\"408\":\"33#_2-softmax-操作\",\"409\":\"33#_3-与-v-相乘\",\"410\":\"33#三、总结-输入维度-→-输出维度\",\"411\":\"33#四、如何理解这个过程\",\"412\":\"33#✅-1-信息融合机制\",\"413\":\"33#✅-2-维度设计的灵活性\",\"414\":\"33#✅-3-可类比为-软检索-系统\",\"415\":\"33#五、例子说明-以-transformer-为例\",\"416\":\"33#六、常见疑问解答\",\"417\":\"33#❓q-为什么和可以不同\",\"418\":\"33#❓q-为什么要除以\",\"419\":\"33#七、可视化示意\",\"420\":\"34\",\"421\":\"34#引言\",\"422\":\"34#连续性\",\"423\":\"34#步长\",\"424\":\"34#张量变换操作\",\"425\":\"34#切片-slice\",\"426\":\"34#转置-transpose\",\"427\":\"34#广播-broadcast\",\"428\":\"34#维度问题\",\"429\":\"35\",\"430\":\"36\",\"431\":\"36#一、创建新环境\",\"432\":\"36#二、激活-切换-环境\",\"433\":\"36#三、退出当前环境\",\"434\":\"36#四、查看所有已创建的环境\",\"435\":\"36#五、删除已创建的环境\",\"436\":\"36#六、查看当前激活的环境\",\"437\":\"36#七、查看当前环境已安装的包\",\"438\":\"36#八、在当前环境下安装包\",\"439\":\"36#九、常见错误\",\"440\":\"37\",\"441\":\"37#二元分类场景\",\"442\":\"37#混淆矩阵-confusion-matrix\",\"443\":\"37#准确率-accuracy\",\"444\":\"37#召回率-recall-真正例率\",\"445\":\"37#误报概率-假正例率\",\"446\":\"37#精确率\",\"447\":\"37#指标的选择和权衡\",\"448\":\"37#f1-得分\",\"449\":\"37#roc-曲线和-auc\",\"450\":\"37#roc-receiver-operating-characteristic\",\"451\":\"37#auc-曲线下面积\",\"452\":\"37#精确率与召回率曲线\",\"453\":\"37#用于选择模型和阈值的-auc-和-roc\",\"454\":\"38\",\"455\":\"38#协方差矩阵\",\"456\":\"38#马氏距离\",\"457\":\"38#欧几里得距离-euclidean-distance\",\"458\":\"38#马氏距离-mahalanobis-distance\",\"459\":\"38#尺度差异性\",\"460\":\"38#总结\",\"461\":\"39\",\"462\":\"39#注意力图可视化\",\"463\":\"39#vit-模型\",\"464\":\"40\",\"465\":\"40#语义分割\",\"466\":\"40#损失函数\",\"467\":\"40#dice-loss\",\"468\":\"40#bce-dice-loss\",\"469\":\"40#jaccard-intersection-over-union-iou-loss\",\"470\":\"40#focal-loss\",\"471\":\"40#tversky-loss\",\"472\":\"40#lovasz-hinge-loss\",\"473\":\"40#combo-loss\",\"474\":\"40#如何选择\",\"475\":\"41\",\"476\":\"41#预训练过程\",\"477\":\"41#分词过程\",\"478\":\"41#附录\",\"479\":\"42\",\"480\":\"43\",\"481\":\"43#什么是大模型\",\"482\":\"43#为什么要对大模型进行微调\",\"483\":\"43#如何对大模型进行微调\",\"484\":\"43#常用的peft方案\",\"485\":\"43#prompt-tuning\",\"486\":\"43#prefix-tuning\",\"487\":\"43#lora\",\"488\":\"43#qlora\",\"489\":\"44\",\"490\":\"44#符合认知的大模型微调流程\",\"491\":\"44#大模型微调大致发展历史\",\"492\":\"44#lora-微调\",\"493\":\"44#矩阵a和b为什么不能同时为零\",\"494\":\"44#秩的选择\",\"495\":\"44#注意\",\"496\":\"45\",\"497\":\"45#什么是prompt-engineering\",\"498\":\"45#如何写好prompt\",\"499\":\"45#要明确-要具体\",\"500\":\"45#给llm更多的时间去思考\",\"501\":\"45#思维链技术-chain-of-thought\",\"502\":\"45#自一致性技术-self-consistency\",\"503\":\"45#从易至难技术-least-to-most\",\"504\":\"46\",\"505\":\"47\",\"506\":\"47#摘要\",\"507\":\"47#简介\",\"508\":\"47#相关工作\",\"509\":\"47#框架\",\"510\":\"47#无监督预训练\",\"511\":\"47#有监督微调\",\"512\":\"47#特定任务输入转换\",\"513\":\"47#实验\",\"514\":\"47#设置\",\"515\":\"47#监督微调\",\"516\":\"47#分析\",\"517\":\"47#结论\",\"518\":\"48\",\"519\":\"48#摘要\",\"520\":\"48#简介\",\"521\":\"48#方法\",\"522\":\"48#实验\",\"523\":\"48#讨论\",\"524\":\"48#总结\",\"525\":\"49\",\"526\":\"49#摘要\",\"527\":\"49#简介\",\"528\":\"49#方法\",\"529\":\"49#结果\",\"530\":\"49#局限性\",\"531\":\"49#相关工作\",\"532\":\"49#结论\",\"533\":\"50\",\"534\":\"50#摘要\",\"535\":\"50#简介\",\"536\":\"50#相关工作\",\"537\":\"50#方法\",\"538\":\"50#结果\",\"539\":\"50#讨论\",\"540\":\"51\",\"541\":\"51#why-we-need-kv-cache\",\"542\":\"51#self-attention-without-cache\",\"543\":\"51#self-attention-with-cache\",\"544\":\"51#huggingface-官方代码实现\",\"545\":\"52\",\"546\":\"52#摘要\",\"547\":\"52#简介\",\"548\":\"52#方法\",\"549\":\"52#结果\",\"550\":\"52#指令微调\",\"551\":\"52#bias-toxicity-and-misinformation\",\"552\":\"52#相关工作\",\"553\":\"52#总结\",\"554\":\"53\",\"555\":\"53#摘要\",\"556\":\"54\",\"557\":\"55\",\"558\":\"55#摘要\",\"559\":\"55#引言\",\"560\":\"55#背景\",\"561\":\"55#实验步骤\",\"562\":\"55#训练步骤分析\",\"563\":\"55#roberta核心改进总结\",\"564\":\"55#_1-训练策略优化\",\"565\":\"55#_2-数据规模与训练时长\",\"566\":\"55#_3-性能表现-关键结果\",\"567\":\"55#_4-结论与启示\",\"568\":\"55#相关工作\",\"569\":\"55#总结\",\"570\":\"56\",\"571\":\"56#bert-是什么\",\"572\":\"56#masked-language-model\",\"573\":\"56#next-sentence-prediction\",\"574\":\"56#multi-task-learning\",\"575\":\"56#fine-tuning\",\"576\":\"56#从-零-开始的预训练\",\"577\":\"56#数据清洗\",\"578\":\"56#分词器实现\",\"579\":\"56#batch数据准备\",\"580\":\"56#模型\",\"581\":\"56#训练\",\"582\":\"56#效果\",\"583\":\"56#details\",\"584\":\"56#padding-mask-如何生成并起作用的\",\"585\":\"57\",\"586\":\"57#绝对位置编码-absolute-positional-encoding-ape\",\"587\":\"57#正弦-余弦位置编码-sinusoidal-positional-encoding\",\"588\":\"57#基于可学习的嵌入\",\"589\":\"57#相对位置编码-relative-position-encoding-rpe\",\"590\":\"57#relative-position-representations-shaw-et-al-2018\",\"591\":\"57#t5-相对位置偏置-relative-position-bias-rpb\",\"592\":\"58\",\"593\":\"58#环境搭建\",\"594\":\"58#数据预处理\",\"595\":\"58#模型架构\",\"596\":\"58#dataloader\",\"597\":\"58#bertembeddings\",\"598\":\"58#bertencoder\",\"599\":\"58#bertlayer\",\"600\":\"58#bertencoder-1\",\"601\":\"58#bertpooler\",\"602\":\"58#bertmodel\",\"603\":\"58#bertforsequenceclassification\",\"604\":\"58#bertattention\",\"605\":\"58#bertselfattention\",\"606\":\"58#bertselfoutput\",\"607\":\"58#bertattention-1\",\"608\":\"58#预训练\",\"609\":\"58#bertpredictionheadtransform\",\"610\":\"58#bertlmpredictionhead\",\"611\":\"58#bertpretrainingheads\",\"612\":\"58#bertforpretraining\",\"613\":\"58#其他下游任务\",\"614\":\"58#问答任务\",\"615\":\"58#代码实现\",\"616\":\"58#易混淆\",\"617\":\"58#token分类任务\",\"618\":\"58#多项选择任务\",\"619\":\"59\",\"620\":\"59#环境\",\"621\":\"59#背景\",\"622\":\"59#模型架构\",\"623\":\"59#encoder-decoder-结构\",\"624\":\"59#generator\",\"625\":\"59#encoder-结构\",\"626\":\"59#sublayerconnection\",\"627\":\"59#encoderlayer\",\"628\":\"59#encoder\",\"629\":\"59#decoder-结构\",\"630\":\"59#decoderlayer\",\"631\":\"59#decoder\",\"632\":\"59#多头自注意力\",\"633\":\"60\",\"634\":\"60#引言-揭开深度学习框架的神秘面纱\",\"635\":\"60#步骤1-作为-箱子-的变量\",\"636\":\"60#变量的基本概念\",\"637\":\"60#代码实现\",\"638\":\"60#使用示例\",\"639\":\"60#关键要点\",\"640\":\"60#步骤2-创建变量的函数\",\"641\":\"60#函数与计算图\",\"642\":\"60#函数类的设计\",\"643\":\"60#代码实现-1\",\"644\":\"60#辅助函数\",\"645\":\"60#步骤3-函数的连续调用\",\"646\":\"60#复合函数的计算\",\"647\":\"60#代码示例\",\"648\":\"60#计算图的意义\",\"649\":\"60#步骤4-数值微分\",\"650\":\"60#导数的定义\",\"651\":\"60#数值微分的实现\",\"652\":\"60#代码实现-2\",\"653\":\"60#数值微分的问题\",\"654\":\"60#步骤5-反向传播的理论知识\",\"655\":\"60#链式法则\",\"656\":\"60#反向传播的方向\",\"657\":\"60#计算图的反向传播\",\"658\":\"60#步骤6-手动进行反向传播\",\"659\":\"60#扩展variable类\",\"660\":\"60#扩展function类\",\"661\":\"60#具体函数的反向传播\",\"662\":\"60#反向传播的执行\",\"663\":\"60#步骤7-反向传播的自动化\",\"664\":\"60#建立变量与函数的连接\",\"665\":\"60#自动反向传播的实现\",\"666\":\"60#步骤8-从递归到循环\",\"667\":\"60#递归实现的问题\",\"668\":\"60#循环实现反向传播\",\"669\":\"60#循环实现的优势\",\"670\":\"60#步骤9-让函数更易用\",\"671\":\"60#函数的python化\",\"672\":\"60#自动设置梯度\",\"673\":\"60#数据类型检查\",\"674\":\"60#步骤10-测试\",\"675\":\"60#单元测试\",\"676\":\"60#梯度检验\",\"677\":\"60#测试的重要性\",\"678\":\"60#第一阶段总结\",\"679\":\"61\",\"680\":\"61#引言-从自动微分迈向通用框架\",\"681\":\"61#步骤11-多输入与多输出\",\"682\":\"61#步骤12-backward-的多输入实现\",\"683\":\"61#步骤13-重置导数\",\"684\":\"61#步骤14-共享变量与梯度累加\",\"685\":\"61#步骤15-梯度重复累加的问题\",\"686\":\"61#步骤16-辈分-机制\",\"687\":\"61#步骤17-循环引用与内存释放\",\"688\":\"61#步骤18-优化内存消耗\",\"689\":\"61#步骤19-variable-功能增强\",\"690\":\"61#步骤20–22-运算符重载\",\"691\":\"61#步骤23-项目模块化结构\",\"692\":\"61#步骤24-复杂函数的求导\",\"693\":\"61#第二阶段总结\",\"694\":\"62\",\"695\":\"62#引言-从自动微分走向-可视化-高阶导数-灵活控制\",\"696\":\"62#步骤25-可视化计算图\",\"697\":\"62#步骤26-寻找函数最优解\",\"698\":\"62#步骤27-高阶导数\",\"699\":\"63\",\"700\":\"63#引言-从自动微分迈向可训练的神经网络模型\",\"701\":\"64\",\"702\":\"65\",\"703\":\"65#大语言模型\",\"704\":\"65#常见的llm\",\"705\":\"65#llm-的特点与能力\",\"706\":\"65#涌现能力-emergent-abilities\",\"707\":\"65#作为基座模型支持多元应用的能力\",\"708\":\"65#支持对话作为统一入口的能力\",\"709\":\"65#检索增强生成-rag-retrieval-augmented-generation\",\"710\":\"65#工作流程\",\"711\":\"65#rag-vs-finetune\",\"712\":\"65#langchain\",\"713\":\"65#核心组件\",\"714\":\"65#版本迭代\",\"715\":\"65#生态圈\",\"716\":\"65#大模型开发\",\"717\":\"65#基本流程\",\"718\":\"65#参考\",\"719\":\"66\",\"720\":\"67\",\"721\":\"68\",\"722\":\"69\",\"723\":\"70\",\"724\":\"71\",\"725\":\"72\",\"726\":\"72#概率空间\",\"727\":\"72#离散随机变量\",\"728\":\"72#连续随机变量\",\"729\":\"72#概率公理\",\"730\":\"72#条件概率\",\"731\":\"72#全概率公式-law-of-total-probability\",\"732\":\"72#贝叶斯法则\",\"733\":\"72#离散随机变量形式\",\"734\":\"72#连续随机变量形式\",\"735\":\"72#一些常见的概率分布\",\"736\":\"72#离散分布\",\"737\":\"72#伯努利分布与二项分布-bernoulli-and-binomial-distributions\",\"738\":\"72#分类分布与多项分布-categorical-and-multinomial-distributions\",\"739\":\"72#泊松分布-poisson-distribution\",\"740\":\"72#负二项分布-negative-binomial-distribution\",\"741\":\"72#转换视角-定义失败为红球-成功为蓝球\",\"742\":\"72#特殊情况说明\",\"743\":\"72#数学期望与方差\",\"744\":\"72#负二项分布的意义与优势\",\"745\":\"72#定义在实数上的连续分布\",\"746\":\"72#高斯分布-正态分布\",\"747\":\"72#半正态分布-half-normal\",\"748\":\"72#学生-t-分布-student-t-distribution\",\"749\":\"72#柯西分布-cauchy-distribution\",\"750\":\"72#高斯联合分布-gaussian-joint-distributions\",\"751\":\"72#多元正态分布-the-multivariate-normal\",\"752\":\"72#定义-definition\",\"753\":\"72#高斯壳-gaussian-shells\",\"754\":\"72#直观解释如下\",\"755\":\"72#数学解释-为什么高斯样本集中在壳层上\",\"756\":\"72#图像空间的含义-例如灰度图像\",\"757\":\"73\",\"758\":\"73#bayes-rule\",\"759\":\"73#inverse-problems\",\"760\":\"74\",\"761\":\"74#计数法则\",\"762\":\"74#排列-考虑元素之间的顺序\",\"763\":\"74#组合-不考虑元素之间的顺序\",\"764\":\"75\",\"765\":\"75#摘要\",\"766\":\"75#简介\",\"767\":\"75#方法\",\"768\":\"75#图像表示\",\"769\":\"75#图像-patch\",\"770\":\"75#视觉-token\",\"771\":\"75#主干网络-图像-transformer\",\"772\":\"75#beit-的预训练-掩码图像建模-masked-image-modeling\",\"773\":\"75#从变分自编码器的视角\",\"774\":\"75#预训练设置-pre-training-setup\",\"775\":\"75#在下游视觉任务上微调-beit\",\"776\":\"75#图像分类-image-classification\",\"777\":\"75#语义分割-semantic-segmentation\",\"778\":\"75#中间微调-intermediate-fine-tuning\",\"779\":\"75#实验\",\"780\":\"75#消融实验-ablation-studies\",\"781\":\"75#自注意力图的分析\",\"782\":\"75#相关工作\",\"783\":\"75#自监督视觉预训练\",\"784\":\"75#_1-对比学习-contrastive-learning\",\"785\":\"75#_2-生成式预训练-generative-pretraining\",\"786\":\"75#_3-目标预训练-pretext-task\",\"787\":\"75#离散表示学习-discrete-representation-learning\",\"788\":\"75#bert-式的预训练方法-bert-style-pretraining\",\"789\":\"75#多模态预训练-multimodal-pretraining\",\"790\":\"75#结论\",\"791\":\"76\",\"792\":\"76#dvae-预训练\",\"793\":\"76#discretevae-初始化\",\"794\":\"76#discretevae-前向传播\",\"795\":\"76#gumbel-softmax\",\"796\":\"76#hard-true时-如何实现的\",\"797\":\"76#smooth-l1-loss\",\"798\":\"76#kl散度计算\",\"799\":\"76#log-target-参数\",\"800\":\"76#为什么先验分布设置为均匀分布\",\"801\":\"76#块状遮挡-blockwise-masking-策略\",\"802\":\"76#数据集加载\",\"803\":\"76#beit主模型预训练\",\"804\":\"76#主模型代码实现\",\"805\":\"77\",\"806\":\"77#引言\",\"807\":\"77#方法\",\"808\":\"77#阶段一-学习视觉码本-visual-codebook\",\"809\":\"77#阶段二-学习先验\",\"810\":\"77#数据收集\",\"811\":\"77#采样生成\",\"812\":\"78\",\"813\":\"78#代码实现\",\"814\":\"78#模型初始化\",\"815\":\"78#前向传播流程\",\"816\":\"78#classifier-free-guidance-无条件引导技术\",\"817\":\"78#推理过程-图文联合生成图像\",\"818\":\"78#top-k-采样\",\"819\":\"78#gumbel-sampling\",\"820\":\"78#语言建模能力-的回溯性验证\",\"821\":\"78#discretevae-离散化变分自编码器\",\"822\":\"78#生成质量判别器-clip\",\"823\":\"79\",\"824\":\"79#前置知识\",\"825\":\"79#最大似然估计-maximum-likelihood-estimation-mle\",\"826\":\"79#数学推导\",\"827\":\"79#信息论-信息量-熵-交叉熵-kl散度\",\"828\":\"79#_1-信息量-self-information\",\"829\":\"79#_2-熵-entropy\",\"830\":\"79#_3-交叉熵-cross-entropy\",\"831\":\"79#_4-kl-散度-信息增益\",\"832\":\"79#交叉熵损失-cross-entropy-loss\",\"833\":\"79#js散度-jensen-shannon-divergence\",\"834\":\"79#_1-js散度是什么-浅层直观\",\"835\":\"79#_2-为什么要用js散度而不是kl散度\",\"836\":\"79#_3-js散度的数学定义\",\"837\":\"79#_4-直观理解js散度\",\"838\":\"79#_5-举个简单例子\",\"839\":\"79#_1-lipschitz-函数\",\"840\":\"79#原始-gan\",\"841\":\"79#推荐资料\",\"842\":\"80\",\"843\":\"80#引言\",\"844\":\"80#掩码卷积\",\"845\":\"80#空间掩码\",\"846\":\"80#通道掩码\",\"847\":\"80#思考\",\"848\":\"80#minist-数据集上的实战测试\",\"849\":\"80#摘录\",\"850\":\"81\",\"851\":\"81#实现vae\",\"852\":\"81#_1-安装和导入依赖\",\"853\":\"81#_2-定义-vae-模型\",\"854\":\"81#_3-定义损失函数-重构损失-kl散度\",\"855\":\"81#_4-数据加载\",\"856\":\"81#_5-训练模型\",\"857\":\"81#_6-模型评估\",\"858\":\"81#cvae-实现\",\"859\":\"81#_2-定义-cvae-模型\",\"860\":\"81#_5-训练过程\",\"861\":\"81#_6-条件生成图像-指定标签\",\"862\":\"82\",\"863\":\"83\",\"864\":\"83#引言\",\"865\":\"83#预备知识-潜变量模型\",\"866\":\"83#变分自编码器\",\"867\":\"83#构建目标函数\",\"868\":\"83#优化目标函数\",\"869\":\"83#测试已学习的模型\",\"870\":\"83#解读目标函数\",\"871\":\"83#项引入的误差分析\",\"872\":\"83#信息论视角\",\"873\":\"83#vae-与正则化参数\",\"874\":\"83#条件变分自编码器\",\"875\":\"83#推荐阅读\",\"876\":\"84\",\"877\":\"84#引言\",\"878\":\"84#从-ae-到-vq-vae\",\"879\":\"84#vq-vae-实现细节\",\"880\":\"84#输出离散编码\",\"881\":\"84#优化编码器和解码器\",\"882\":\"84#优化嵌入空间\",\"883\":\"84#总结\",\"884\":\"84#代码实现\",\"885\":\"84#训练阶段\",\"886\":\"84#生成阶段\",\"887\":\"84#转载\",\"888\":\"85\",\"889\":\"86\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,7],\"1\":[1],\"2\":[2,16],\"3\":[1,5],\"4\":[2,35],\"5\":[1,25],\"6\":[1,83],\"7\":[1,71],\"8\":[1,48],\"9\":[8],\"10\":[3,22],\"11\":[5,16],\"12\":[5,19],\"13\":[4,15],\"14\":[8,27],\"15\":[6,24],\"16\":[1,16],\"17\":[3,40],\"18\":[3,12],\"19\":[4,18],\"20\":[4,15],\"21\":[1,8],\"22\":[4,59],\"23\":[4,45],\"24\":[4,48],\"25\":[4,22],\"26\":[1,49],\"27\":[1],\"28\":[6,202],\"29\":[1,242],\"30\":[1,73],\"31\":[1,34],\"32\":[1,69],\"33\":[1,40],\"34\":[1,54],\"35\":[1,100],\"36\":[1,75],\"37\":[2,29],\"38\":[3,4],\"39\":[1,1],\"40\":[1,223],\"41\":[3,92],\"42\":[3,25],\"43\":[3,114],\"44\":[3,20],\"45\":[3,142],\"46\":[5,153],\"47\":[2,27],\"48\":[1,29],\"49\":[1,73],\"50\":[1],\"51\":[1,31],\"52\":[1,19],\"53\":[1],\"54\":[1,35],\"55\":[1,15],\"56\":[1,14],\"57\":[1],\"58\":[1,152],\"59\":[1,259],\"60\":[2,31],\"61\":[1],\"62\":[2,25],\"63\":[5,72],\"64\":[7,26],\"65\":[2,54],\"66\":[2,14],\"67\":[4,39],\"68\":[2,211],\"69\":[2,20],\"70\":[1,154],\"71\":[2,40],\"72\":[3,78],\"73\":[5,118],\"74\":[3,61],\"75\":[3,96],\"76\":[2,224],\"77\":[1],\"78\":[5,174],\"79\":[1,6],\"80\":[1,105],\"81\":[1,61],\"82\":[1,338],\"83\":[1,310],\"84\":[3],\"85\":[1,19],\"86\":[1,73],\"87\":[1,15],\"88\":[1,24],\"89\":[2,23],\"90\":[2,51],\"91\":[2,15],\"92\":[1,316],\"93\":[1,122],\"94\":[1,17],\"95\":[5,35],\"96\":[1,196],\"97\":[5,40],\"98\":[1,151],\"99\":[1,42],\"100\":[1,222],\"101\":[1,140],\"102\":[1,17],\"103\":[1,33],\"104\":[1,28],\"105\":[1,121],\"106\":[3,1],\"107\":[1,192],\"108\":[1,73],\"109\":[1,112],\"110\":[1,54],\"111\":[1,94],\"112\":[1,290],\"113\":[3],\"114\":[1,65],\"115\":[1,83],\"116\":[1,24],\"117\":[1,13],\"118\":[1],\"119\":[2,19],\"120\":[1,65],\"121\":[2],\"122\":[4,26],\"123\":[4,19],\"124\":[4,11],\"125\":[1,11],\"126\":[8,87],\"127\":[5,55],\"128\":[2,43],\"129\":[1,22],\"130\":[3],\"131\":[1,69],\"132\":[2,32],\"133\":[1,25],\"134\":[2,61],\"135\":[2],\"136\":[2,23],\"137\":[3,17],\"138\":[1,42],\"139\":[2],\"140\":[2,43],\"141\":[2],\"142\":[1,248],\"143\":[1,149],\"144\":[2],\"145\":[1,353],\"146\":[1,92],\"147\":[2,363],\"148\":[2,19],\"149\":[1,46],\"150\":[2,36],\"151\":[1],\"152\":[2,27],\"153\":[3,12],\"154\":[4,35],\"155\":[5,27],\"156\":[5,39],\"157\":[2,109],\"158\":[2],\"159\":[1,110],\"160\":[2,147],\"161\":[1,173],\"162\":[1,191],\"163\":[1,307],\"164\":[2,21],\"165\":[1,44],\"166\":[1],\"167\":[3,105],\"168\":[1],\"169\":[2,134],\"170\":[1,395],\"171\":[2,23],\"172\":[2,15],\"173\":[1,136],\"174\":[1],\"175\":[1,69],\"176\":[1,60],\"177\":[1],\"178\":[1,127],\"179\":[1,125],\"180\":[1],\"181\":[1,29],\"182\":[1,31],\"183\":[1,33],\"184\":[1,39],\"185\":[1,23],\"186\":[1,602],\"187\":[6,27],\"188\":[1,21],\"189\":[1,62],\"190\":[1],\"191\":[1,27],\"192\":[1,15],\"193\":[1,21],\"194\":[1,6],\"195\":[1],\"196\":[1,80],\"197\":[1,72],\"198\":[1,131],\"199\":[1,75],\"200\":[1],\"201\":[1,53],\"202\":[1,69],\"203\":[1,41],\"204\":[1,45],\"205\":[1,21],\"206\":[1,25],\"207\":[3],\"208\":[1,60],\"209\":[1,37],\"210\":[1,33],\"211\":[1,23],\"212\":[1,23],\"213\":[1,11],\"214\":[6,19],\"215\":[1,52],\"216\":[1,83],\"217\":[1],\"218\":[1,39],\"219\":[1,27],\"220\":[1,41],\"221\":[1],\"222\":[1,41],\"223\":[1,58],\"224\":[1,25],\"225\":[1,51],\"226\":[1],\"227\":[1,34],\"228\":[1,37],\"229\":[1,22],\"230\":[1,20],\"231\":[9,21],\"232\":[1,130],\"233\":[1,21],\"234\":[1,126],\"235\":[1,127],\"236\":[7,40],\"237\":[4,28],\"238\":[1],\"239\":[5,107],\"240\":[2,15],\"241\":[1,13],\"242\":[5,40],\"243\":[3,50],\"244\":[2,24],\"245\":[1,45],\"246\":[1,153],\"247\":[1,45],\"248\":[2,179],\"249\":[1,62],\"250\":[2,74],\"251\":[2],\"252\":[2,151],\"253\":[2],\"254\":[2,98],\"255\":[2,109],\"256\":[2,30],\"257\":[3,54],\"258\":[1],\"259\":[2,22],\"260\":[1,118],\"261\":[2,70],\"262\":[1,38],\"263\":[1,49],\"264\":[4,42],\"265\":[1,64],\"266\":[5,26],\"267\":[1,22],\"268\":[2,123],\"269\":[1,60],\"270\":[2,22],\"271\":[1,17],\"272\":[6,528],\"273\":[1,102],\"274\":[1,356],\"275\":[1,94],\"276\":[3,240],\"277\":[4,387],\"278\":[3,160],\"279\":[2,18],\"280\":[1,56],\"281\":[1,7],\"282\":[1,47],\"283\":[3,35],\"284\":[2,31],\"285\":[2,50],\"286\":[1,21],\"287\":[1,7],\"288\":[3,5],\"289\":[4,85],\"290\":[3,43],\"291\":[4,42],\"292\":[4,39],\"293\":[3,71],\"294\":[2,46],\"295\":[1,143],\"296\":[1,3],\"297\":[1,31],\"298\":[1,20],\"299\":[1,146],\"300\":[1,156],\"301\":[1,57],\"302\":[1,245],\"303\":[1,92],\"304\":[1,210],\"305\":[1,132],\"306\":[1,17],\"307\":[1,66],\"308\":[1,20],\"309\":[6,144],\"310\":[10,95],\"311\":[8,183],\"312\":[10,349],\"313\":[6,194],\"314\":[1,53],\"315\":[1,4],\"316\":[2,234],\"317\":[2,130],\"318\":[2,181],\"319\":[4,160],\"320\":[2,141],\"321\":[2,153],\"322\":[2,138],\"323\":[3,220],\"324\":[1,61],\"325\":[1,13],\"326\":[1,51],\"327\":[1,158],\"328\":[1,15],\"329\":[1],\"330\":[1,1],\"331\":[1],\"332\":[2,40],\"333\":[2,33],\"334\":[1,1],\"335\":[1],\"336\":[1,86],\"337\":[1,19],\"338\":[1],\"339\":[2,25],\"340\":[2,37],\"341\":[2,40],\"342\":[1,22],\"343\":[1,23],\"344\":[1,24],\"345\":[3,27],\"346\":[2,64],\"347\":[5,20],\"348\":[1,12],\"349\":[1,17],\"350\":[3,12],\"351\":[1,23],\"352\":[1,16],\"353\":[1,35],\"354\":[2,16],\"355\":[2,41],\"356\":[1,1],\"357\":[1],\"358\":[1,31],\"359\":[1,16],\"360\":[1,26],\"361\":[1,37],\"362\":[1,42],\"363\":[1,26],\"364\":[1,77],\"365\":[4,8],\"366\":[2,64],\"367\":[1,45],\"368\":[1,16],\"369\":[4,44],\"370\":[1,45],\"371\":[3,20],\"372\":[3,64],\"373\":[2,49],\"374\":[5,56],\"375\":[2,22],\"376\":[2,23],\"377\":[2,47],\"378\":[3,42],\"379\":[4,24],\"380\":[1,1],\"381\":[1],\"382\":[1,16],\"383\":[1,4],\"384\":[2],\"385\":[1,266],\"386\":[2,94],\"387\":[2,128],\"388\":[1,46],\"389\":[3,35],\"390\":[3,54],\"391\":[1,27],\"392\":[4,17],\"393\":[4,22],\"394\":[1,1],\"395\":[2,99],\"396\":[5,22],\"397\":[3],\"398\":[3,91],\"399\":[3,72],\"400\":[4],\"401\":[1,50],\"402\":[3],\"403\":[1,68],\"404\":[1,16],\"405\":[2,19],\"406\":[5],\"407\":[2,11],\"408\":[2,6],\"409\":[2,13],\"410\":[5,24],\"411\":[3,2],\"412\":[3,12],\"413\":[3,9],\"414\":[3,10],\"415\":[6,18],\"416\":[2],\"417\":[5,5],\"418\":[3,8],\"419\":[2,14],\"420\":[1,1],\"421\":[1,52],\"422\":[1,30],\"423\":[1,147],\"424\":[1],\"425\":[3,114],\"426\":[3,120],\"427\":[3,83],\"428\":[1,28],\"429\":[1],\"430\":[1,1],\"431\":[2,25],\"432\":[4,13],\"433\":[2,6],\"434\":[2,20],\"435\":[2,12],\"436\":[2,3],\"437\":[2,3],\"438\":[2,63],\"439\":[2,13],\"440\":[1,1],\"441\":[1],\"442\":[4,37],\"443\":[3,35],\"444\":[3,25],\"445\":[2,23],\"446\":[1,29],\"447\":[1,30],\"448\":[2,20],\"449\":[3,6],\"450\":[5,29],\"451\":[3,34],\"452\":[1,20],\"453\":[4,49],\"454\":[1,1],\"455\":[1,121],\"456\":[1],\"457\":[4,13],\"458\":[4,12],\"459\":[1,70],\"460\":[1,7],\"461\":[1,1],\"462\":[1],\"463\":[2,199],\"464\":[1,1],\"465\":[1,22],\"466\":[1],\"467\":[2,144],\"468\":[3,150],\"469\":[6,159],\"470\":[2,321],\"471\":[2,158],\"472\":[3,14],\"473\":[2,190],\"474\":[2,22],\"475\":[1,29],\"476\":[1,200],\"477\":[1,98],\"478\":[1,214],\"479\":[1],\"480\":[4,4],\"481\":[2,40],\"482\":[2,47],\"483\":[2,67],\"484\":[1,4],\"485\":[2,31],\"486\":[2,31],\"487\":[1,54],\"488\":[1,66],\"489\":[1,10],\"490\":[1,59],\"491\":[1,63],\"492\":[2,92],\"493\":[2,34],\"494\":[1,15],\"495\":[1,62],\"496\":[3,3],\"497\":[3,33],\"498\":[2],\"499\":[2,21],\"500\":[1,44],\"501\":[4,51],\"502\":[3,43],\"503\":[4,46],\"504\":[1],\"505\":[3,10],\"506\":[1,35],\"507\":[1,83],\"508\":[1,16],\"509\":[1,4],\"510\":[1,24],\"511\":[1,30],\"512\":[1,52],\"513\":[1],\"514\":[1,113],\"515\":[1,100],\"516\":[1,66],\"517\":[1,14],\"518\":[3,10],\"519\":[1,29],\"520\":[1,64],\"521\":[1,213],\"522\":[1,235],\"523\":[1,35],\"524\":[1,26],\"525\":[3,10],\"526\":[1,18],\"527\":[1,100],\"528\":[1,128],\"529\":[1,150],\"530\":[1,104],\"531\":[1,135],\"532\":[1,18],\"533\":[2,12],\"534\":[1,26],\"535\":[1,76],\"536\":[1,166],\"537\":[1,287],\"538\":[1,202],\"539\":[1,230],\"540\":[3,2],\"541\":[6,136],\"542\":[4,16],\"543\":[4,5],\"544\":[2,333],\"545\":[2,10],\"546\":[1,16],\"547\":[1,67],\"548\":[1,114],\"549\":[1,166],\"550\":[1,68],\"551\":[4,69],\"552\":[1,47],\"553\":[1,5],\"554\":[2,12],\"555\":[1],\"556\":[1],\"557\":[2,9],\"558\":[1,20],\"559\":[1,62],\"560\":[1,85],\"561\":[1,101],\"562\":[1,148],\"563\":[1,11],\"564\":[1,62],\"565\":[1,31],\"566\":[1,37],\"567\":[1,18],\"568\":[1,19],\"569\":[1,15],\"570\":[4,9],\"571\":[3,50],\"572\":[3,64],\"573\":[3,42],\"574\":[3,7],\"575\":[2,129],\"576\":[3,6],\"577\":[1,150],\"578\":[1,181],\"579\":[1,116],\"580\":[1,176],\"581\":[1,177],\"582\":[1,23],\"583\":[1,2],\"584\":[4,77],\"585\":[1,1],\"586\":[6],\"587\":[6,130],\"588\":[1,43],\"589\":[6,17],\"590\":[8,230],\"591\":[7,400],\"592\":[2,2],\"593\":[1,138],\"594\":[1,165],\"595\":[1],\"596\":[1,48],\"597\":[1,66],\"598\":[1],\"599\":[1,58],\"600\":[1,30],\"601\":[1,40],\"602\":[1,49],\"603\":[1,73],\"604\":[1],\"605\":[1,104],\"606\":[1,32],\"607\":[1,23],\"608\":[1,1],\"609\":[1,41],\"610\":[1,44],\"611\":[1,28],\"612\":[1,75],\"613\":[1,1],\"614\":[1,120],\"615\":[1,95],\"616\":[1,173],\"617\":[1,75],\"618\":[1,119],\"619\":[1,2],\"620\":[1,41],\"621\":[1,23],\"622\":[1,64],\"623\":[3,30],\"624\":[1,28],\"625\":[2],\"626\":[1,33],\"627\":[1,37],\"628\":[1,37],\"629\":[2],\"630\":[1,49],\"631\":[1,39],\"632\":[1,116],\"633\":[4,11],\"634\":[2,11],\"635\":[4],\"636\":[1,8],\"637\":[1,7],\"638\":[1,14],\"639\":[1,4],\"640\":[2],\"641\":[1,6],\"642\":[1,5],\"643\":[1,19],\"644\":[1,8],\"645\":[2],\"646\":[1,6],\"647\":[1,27],\"648\":[1,4],\"649\":[2],\"650\":[1,3],\"651\":[1,5],\"652\":[1,19],\"653\":[1,6],\"654\":[2],\"655\":[1,6],\"656\":[1,33],\"657\":[1,5],\"658\":[2],\"659\":[1,11],\"660\":[1,41],\"661\":[1,15],\"662\":[1,17],\"663\":[2],\"664\":[1,19],\"665\":[1,25],\"666\":[2],\"667\":[1,3],\"668\":[1,27],\"669\":[1,3],\"670\":[2],\"671\":[1,10],\"672\":[1,17],\"673\":[1,23],\"674\":[2],\"675\":[1,28],\"676\":[1,32],\"677\":[1,3],\"678\":[1,17],\"679\":[4,11],\"680\":[2,34],\"681\":[2,64],\"682\":[3,50],\"683\":[2,15],\"684\":[2,65],\"685\":[2,38],\"686\":[3,105],\"687\":[2,137],\"688\":[2,159],\"689\":[3,92],\"690\":[3,278],\"691\":[2,67],\"692\":[2,113],\"693\":[1,25],\"694\":[4,11],\"695\":[7,50],\"696\":[2,236],\"697\":[2,190],\"698\":[2],\"699\":[4,11],\"700\":[2,44],\"701\":[1],\"702\":[2,3],\"703\":[1,133],\"704\":[1,594],\"705\":[2,59],\"706\":[1,55],\"707\":[1,32],\"708\":[1,66],\"709\":[6,72],\"710\":[1,19],\"711\":[3,51],\"712\":[1,50],\"713\":[1,45],\"714\":[1,100],\"715\":[1,52],\"716\":[1,78],\"717\":[1,114],\"718\":[1,28],\"719\":[2,4],\"720\":[1],\"721\":[2],\"722\":[1],\"723\":[1],\"724\":[1],\"725\":[1,5],\"726\":[1,13],\"727\":[1,117],\"728\":[1,166],\"729\":[1,50],\"730\":[1,37],\"731\":[6,51],\"732\":[1,12],\"733\":[1,16],\"734\":[1,9],\"735\":[1,12],\"736\":[1,4],\"737\":[6,20],\"738\":[6,37],\"739\":[4,13],\"740\":[5,18],\"741\":[3,40],\"742\":[1,6],\"743\":[1,4],\"744\":[1,16],\"745\":[1,6],\"746\":[3,33],\"747\":[4,17],\"748\":[6,32],\"749\":[4,33],\"750\":[5,18],\"751\":[5,5],\"752\":[3,60],\"753\":[4,23],\"754\":[2,27],\"755\":[3,18],\"756\":[3,23],\"757\":[1,5],\"758\":[2,121],\"759\":[2,46],\"760\":[1,1],\"761\":[1,18],\"762\":[3,41],\"763\":[3,9],\"764\":[2,17],\"765\":[1,27],\"766\":[1,69],\"767\":[1,22],\"768\":[1,9],\"769\":[2,32],\"770\":[2,49],\"771\":[3,36],\"772\":[7,114],\"773\":[1,102],\"774\":[5,115],\"775\":[2,21],\"776\":[4,26],\"777\":[4,20],\"778\":[5,16],\"779\":[1],\"780\":[4,52],\"781\":[1,30],\"782\":[1],\"783\":[1,2],\"784\":[5,23],\"785\":[5,15],\"786\":[5,18],\"787\":[5,25],\"788\":[5,31],\"789\":[4,26],\"790\":[1,51],\"791\":[2,3],\"792\":[2,27],\"793\":[2,148],\"794\":[2,123],\"795\":[2,105],\"796\":[3,79],\"797\":[3,43],\"798\":[1,77],\"799\":[3,31],\"800\":[2,46],\"801\":[4,200],\"802\":[1,220],\"803\":[1,242],\"804\":[1,203],\"805\":[3,11],\"806\":[1,70],\"807\":[1,181],\"808\":[5,73],\"809\":[2,100],\"810\":[1,45],\"811\":[1,36],\"812\":[3,11],\"813\":[1,14],\"814\":[1,282],\"815\":[1,291],\"816\":[5,103],\"817\":[2,221],\"818\":[3,58],\"819\":[2,56],\"820\":[3,181],\"821\":[2,396],\"822\":[2,184],\"823\":[3,3],\"824\":[1],\"825\":[6,35],\"826\":[1,56],\"827\":[5],\"828\":[2,24],\"829\":[2,23],\"830\":[2,16],\"831\":[2,38],\"832\":[5,27],\"833\":[5],\"834\":[4,11],\"835\":[3,11],\"836\":[2,7],\"837\":[2,30],\"838\":[2,8],\"839\":[3,40],\"840\":[2,283],\"841\":[1,11],\"842\":[2,2],\"843\":[1,117],\"844\":[1],\"845\":[1,64],\"846\":[1,107],\"847\":[1,110],\"848\":[2,272],\"849\":[1,9],\"850\":[5,10],\"851\":[1],\"852\":[2,17],\"853\":[4,105],\"854\":[6,96],\"855\":[2,19],\"856\":[2,54],\"857\":[2,96],\"858\":[2,26],\"859\":[4,59],\"860\":[2,58],\"861\":[4,50],\"862\":[1],\"863\":[5,6],\"864\":[1,59],\"865\":[2,53],\"866\":[1,135],\"867\":[1,116],\"868\":[1,133],\"869\":[1,108],\"870\":[1,39],\"871\":[1,91],\"872\":[1,84],\"873\":[2,125],\"874\":[1,56],\"875\":[1,4],\"876\":[3,3],\"877\":[1,27],\"878\":[5,187],\"879\":[3,12],\"880\":[1,61],\"881\":[1,100],\"882\":[1,51],\"883\":[1,53],\"884\":[1],\"885\":[1,300],\"886\":[1,232],\"887\":[1,7],\"888\":[2,2],\"889\":[1,3]},\"averageFieldLength\":[1.989887640449438,66.41357149978941],\"storedFields\":{\"0\":{\"h\":\"主页\",\"t\":[\"知识星球: MetaMind , 小红书: BinaryOracle , CSDN: Binary Oracle\"]},\"1\":{\"h\":\"关于我们\"},\"2\":{\"h\":\"Binary Oracle\",\"t\":[\"一名普通但十分热爱探索技术的Coder\",\"开源框架 Spring committer\",\"Golang 开源网络库 netpoll committer\",\"Javaer 转型 3D - VL 方向研究\",\"现就读于四川大学\",\"有问题需要咨询的小伙伴，可以加微信备注来意:\"]},\"3\":{\"h\":\"Elowen\",\"t\":[\"CV 转 LLM 领域\",\"现就读于电子科技大学\"]},\"4\":{\"h\":\"GREAT 论文解读\",\"t\":[\"GREAT: Geometry-Intention Collaborative Inference for Open-Vocabulary 3D Object Affordance Grounding 论文解读\",\"论文: https://arxiv.org/abs/2411.19626 代码: https://github.com/yawen-shao/GREAT_code 数据集: https://drive.google.com/drive/folders/1n_L_mSmVpAM-1ASoW2T2MltYkaiA_X9X\"]},\"5\":{\"h\":\"摘要\",\"t\":[\"GREAT（Geometry-Intention Collaborative Inference）是一种新颖的框架，旨在通过挖掘物体的不变几何属性和潜在交互意图，以开放词汇的方式定位3D物体的功能区域（affordance）。该框架结合了多模态大语言模型（MLLMs）的推理能力，设计了多头部功能链式思维（MHACoT）策略，逐步分析交互图像中的几何属性和交互意图，并通过跨模态自适应融合模块（CMAFM）将这些知识与点云和图像特征结合，实现精准的3D功能定位。此外，研究还提出了目前最大的3D功能数据集PIADv2，包含15K交互图像和38K标注的3D物体实例。实验证明了GREAT在开放词汇场景下的有效性和优越性。\"]},\"6\":{\"h\":\"简介\",\"t\":[\"Open-Vocabulary 3D对象功能定位（OVAG）旨在通过任意指令定位物体上支持特定交互的“动作可能性”区域，对机器人感知与操作至关重要。现有方法（如IAGNet、LASO）通过结合描述交互的图像或语言与3D几何结构引入外部先验，但存在以下局限性（如图1(b)所示）：\",\"语义空间受限：依赖预定义类别，难以泛化到未见过的功能（如将“pour”错误分类为“grasp”）。\",\"几何与意图利用不足：未充分挖掘物体间共享的几何不变性（如手柄的抓握属性）和同一物体的多交互意图关联。\",\"人类认知启发:\",\"研究表明（Gick & Holyoak, 1980），人类通过多步推理和类比思维解决复杂任务。例如，观察倒水场景时（图1(c)），人类会：\",\"识别交互部件（壶嘴）\",\"提取几何属性（倾斜曲面）\",\"推理潜在意图（倒水/注水）\",\"方法创新:\",\"GREAT框架通过以下设计模拟这一过程（图1(d)）：\",\"MHACoT推理链：基于微调的MLLM（如InternVL）分步推理：\",\"Object-Head：定位交互部件并分析几何结构（如“为什么壶嘴适合倒水”）\",\"Affordance-Head：描述实际交互（如“握柄倒水”）并联想潜在意图（如“注水/清洗”）\",\"跨模态融合：通过CMAFM模块将几何属性（）与交互意图（）注入点云（）和图像特征（），最终解码为3D功能热图 。\",\"数据集贡献:\",\"扩展构建了PIADv2（对比见表1）：\",\"规模：15K交互图像（×3）和38K 3D实例（×5）\",\"多样性：43类物体、24类功能，覆盖多对多关联（图3(c)）\"]},\"7\":{\"h\":\"相关工作\",\"t\":[\"1. Affordance Grounding\",\"现有研究主要从2D数据（如图像、视频）和自然语言理解出发，定位“动作可能性”区域。例如，部分工作通过语言理解在2D数据中定位功能区域（3, 21），但机器人操作需要3D信息，2D方法难以直接迁移。随着3D数据集（如5, 6）的出现，部分研究开始映射语义功能到3D结构，但受限于预定义类别，无法处理开放词汇场景。\",\"2. Open-Vocabulary 3D Affordance Grounding (OVAG)\",\"OVAG旨在通过额外指令（如文本或图像）引入交互先验，提升泛化能力。例如：\",\"IAGNet 利用2D交互语义指导3D功能定位；\",\"LASO 通过文本条件查询分割功能区域；\",\"OpenAD 和 OpenKD 利用CLIP编码器实现文本-点云关联。\",\"这些方法仍受限于训练语义空间，而GREAT通过几何-意图协同推理（CoT）解决此问题（如表2所示）。\",\"3. Chain-of-Thought (CoT) 与多模态大模型 (MLLMs)\",\"CoT及其变体通过多步推理增强MLLMs能力。例如：\",\"视觉任务中，MLLMs（如InternVL）结合CoT在目标检测、机器人操作等任务中表现优异；\",\"但动态功能特性使得MLLMs难以直接从交互图像推理3D功能，GREAT通过微调MLLMs并设计MHACoT策略解决这一问题。\",\"关键问题（如图1所示）：\",\"现有方法依赖数据对齐，泛化性不足（如将“pour”误分类为“grasp”）；\",\"GREAT通过模拟人类多步推理（几何属性提取+意图类比）实现开放词汇功能定位。\"]},\"8\":{\"h\":\"方法\",\"t\":[\"GREAT 的输入为 ，其中 是点云，包含物体的坐标 和其对应的 3D 可供性标注 ， 为图像。目标是优化模型 ，输出 3D 物体可供性 ，即：\",\"如图2所示，首先使用 ResNet [9] 和 PointNet++ [43] 提取特征，分别得到 和 ，随后将 reshape 为 （其中 ）。接着通过多头可供性链式思维（MHACoT）策略对交互图像进行推理，挖掘不变几何属性与潜在交互意图。\",\"然后，使用 Roberta [28] 编码推理结果，通过交叉注意力机制计算对象几何特征 和可供性意图特征 （见 Sec. 3.2）。GREAT 利用跨模态自适应融合模块（CMAFM）将这些知识注入点云特征并与图像特征融合，得到融合特征 （见 Sec. 3.3）。最后将这两个特征送入解码器以获得可供性输出 ，并通过复合损失优化整个流程（见 Sec. 3.4）。\"]},\"9\":{\"h\":\"3.2 Multi-Head Affordance Chain-of-Thought\"},\"10\":{\"h\":\"Fine-Tuning MLLM\",\"t\":[\"为了获得对物体可供性更深入的理解，我们对 InternVL [4] 使用可学习的 Adapter [10] 进行微调，仅更新 Adapter 模块（10 个 epoch，学习率 4e-5，LoRA rank 为 16），其余参数保持冻结，以保持原始模型识别能力的同时增强其推理能力。\"]},\"11\":{\"h\":\"Object-Head Reasoning（几何推理）\",\"t\":[\"该部分包含：\",\"物体交互感知（Object Interaction Perception）：识别图像中物体与人发生交互的部分。Prompt 示例为：“指出图像中物体与人交互的部分。”\",\"几何结构推理（Geometric Structure Reasoning）：进一步从几何结构角度推理为什么该部位适合交互。Prompt 示例为：“从几何结构解释该部位可以交互的原因。”\"]},\"12\":{\"h\":\"Affordance-Head Reasoning（类比推理）\",\"t\":[\"该部分包含：\",\"交互细节描述（Interaction Detailed Description）：描述图像中人与物体之间的完整交互过程，生成细粒度表示。Prompt 示例为：“描述图像中人与物体的交互方式。”\",\"交互类比推理（Interactive Analogical Reasoning）：模拟人类对交互方式的联想，挖掘其他可能交互意图，增强类比能力。Prompt 示例为：“列举两个该物体常见的其他交互方式。”\"]},\"13\":{\"h\":\"Knowledge Encoding and Integration\",\"t\":[\"从 Object-Head 得到的几何属性描述与 Affordance-Head 推理的交互描述被 Roberta 编码为两个特征：\",\"：物体几何知识特征\",\"：可供性意图知识特征\",\"通过交叉注意力层 与自注意力层 对齐二者，公式如下：\"]},\"14\":{\"h\":\"3.3 Cross-Modal Adaptive Fusion Module (CMAFM)\",\"t\":[\"为了将几何属性与点云特征更好地对齐融合，CMAFM 将 融合至 PointNet++ 最深层特征，并与图像特征联合用于预测。\",\"具体地，对点云特征 和知识特征 进行线性映射形成 Query、Key、Value：\",\"跨注意力融合公式为：\",\"最终点云融合特征表示为：\",\"其中 为全连接层， 表示池化后扩展为 ， 为 卷积，输出 上采样至原始点数后记为：\",\"图像特征 与意图特征 融合表示为：\"]},\"15\":{\"h\":\"3.4 Decoder and Loss Functions\",\"t\":[\"最终将融合后的图像特征 和点云特征 拼接后送入解码器输出可供性预测：\",\"其中 为 sigmoid 激活， 为输出头，， 是最终的 3D 可供性预测。\",\"损失函数由 focal loss [26] 与 dice loss [37] 组成：\",\"这种设计无需依赖具体的可供性分类标签，而是通过监督点级热图，将 3D 可供性与交互图像直接联系起来。\"]},\"16\":{\"h\":\"数据集\",\"t\":[\"为支撑开放词汇 3D 物体可供性定位任务，本文构建了 PIADv2（Point Image Affordance Dataset v2），由成对的 2D 交互图像与 3D 点云对象组成，是当前规模最大的同类数据集。\"]},\"17\":{\"h\":\"数据收集（Collection）\",\"t\":[\"点云部分主要来自以下开源数据源：\",\"3DIR [57]\",\"3D-AffordanceNet [6]\",\"Objaverse [5]\",\"图像部分主要来源于：\",\"AGD20k [32]\",\"OpenImage [18]\",\"其他开源许可网站\",\"总体数据统计：\",\"图像数：15,213\",\"点云数：38,889\",\"覆盖类别：\",\"物体类别：43类\",\"可供性类别：24类\",\"该数据集大大超越了前作 PIAD [56]，其图像数量是前者的三倍，点云数量是前者的五倍。\",\"如图3(a) 所示，红色区域为点云的可供性标注。图3(b) 展示了各类别的分布情况，显示出数据集对交互多样性和类别多样性的全面覆盖。\"]},\"18\":{\"h\":\"标注策略（Annotation）\",\"t\":[\"对于点云实例：\",\"每个点云实例按可供性类别标注\",\"每个样本为一个 的矩阵，含：\",\"2048 个点\",\"每个点包括 坐标与热力图形式的可供性值\",\"对于图像：\",\"图像按可供性类别进行分类，以支持训练阶段的匹配与推理\"]},\"19\":{\"h\":\"统计分析（Statistical Analysis）\",\"t\":[\"图像与点云之间不需要一一对应，二者分别从不同实例中采样，以增强泛化能力\",\"多对多关系分析：如图3(c) 所示，affordance 与 object 类别间存在明显的多对多关系，挑战模型对可供性的泛化能力\",\"类平衡分析：图3(d) 展示了各 object 类别下图像与点云的数量比例，体现出数据集在样本分布上的全面性和均衡性\"]},\"20\":{\"h\":\"数据划分（Data Partitions）\",\"t\":[\"PIADv2 提供三种标准划分方式（前两种与 PIAD [56] 保持一致）：\",\"Seen：\",\"训练集与测试集中的物体与可供性类别相同\",\"Unseen Object：\",\"测试集中包含训练集中未出现的物体类别，但可供性类别相同\",\"Unseen Affordance：\",\"测试集中的可供性类别未在训练集中出现，同时包含部分新物体类别\"]},\"21\":{\"h\":\"实验\",\"t\":[\"为验证所提方法 GREAT 的有效性与泛化能力，作者在提出的 PIADv2 数据集上开展了系统性的实验评估，包括与多个先进方法的对比以及消融实验和可视化分析。\"]},\"22\":{\"h\":\"5.1 Benchmark Setting\",\"t\":[\"评估指标：\",\"实验采用以下评估指标评估 3D 可供性预测质量（参考 [25, 56]）：\",\"AUC（Area Under Curve）[29]\",\"aIOU（average Intersection over Union）[45]\",\"SIM（Similarity）[47]\",\"MAE（Mean Absolute Error）[52]\",\"对比方法：\",\"IAG (2023)：2D-引导的3D可供性方法\",\"LASO (2024)：基于语言引导的3D可供性分割\",\"FRCNN [54]：LiDAR-图像融合两阶段3D检测框架\",\"XMF [1]：图像-点云的跨模态点云形状补全方法\",\"Baseline：直接拼接图像与点云特征作为输入\",\"实现细节：\",\"3D backbone：PointNet++ [43]\",\"2D backbone：ResNet18 [9]\",\"优化器：Adam\",\"学习率：1e-4\",\"批大小：16\",\"总训练轮次：65\"]},\"23\":{\"h\":\"5.2 Comparison Results\",\"t\":[\"如表2所示，GREAT 在所有划分（Seen、Unseen Object、Unseen Affordance）下均显著优于现有方法，达成最新最优性能。\",\"量化分析：\",\"在 Unseen Affordance 这一最具挑战性的设置下，GREAT 依旧表现出色：\",\"AUC：69.81（高出 LASO 约 9%）\",\"aIOU：12.05（高出 IAG 约 34%）\",\"SIM：0.290（大幅超越所有基线）\",\"MAE：0.127（最小）\",\"可视化分析（如图4所示）：\",\"Seen setting：各方法差别不大\",\"Unseen setting：\",\"其他方法倾向于错误地预测为训练集中频繁出现的 affordance（如 grasp）\",\"GREAT 能正确捕捉如 \\\"pour\\\" 这类 unseen affordance，定位精度显著更高\"]},\"24\":{\"h\":\"5.3 Ablation Study\",\"t\":[\"表3 展示了对关键模块的消融实验结果：\",\"消融项分析：\",\"✗ AffCoT（无意图推理）：\",\"unseen affordance 的 aIOU 下降了 1.12，表明交互意图推理对泛化至新 affordance 极为重要\",\"✗ ObjCoT（无几何推理）：\",\"模型对物体关键交互区域的识别能力下降\",\"✗ CMAFM（无跨模态融合）：\",\"几何信息无法有效注入点云，导致各项指标大幅下降（aIOU 从 38.03 降到 29.48）\",\"✗ FT（无 MLLM 微调）：\",\"推理能力受限，泛化性下降明显\",\"可视化支持（见图5）：\",\"(a)：若缺失 AffCoT，模型无法进行类比推理，预测倾向训练集中已有的 affordance\",\"(b)：缺失 ObjCoT 时，模型无法精确聚焦于关键交互部位（如 kettle 的 spout）\"]},\"25\":{\"h\":\"5.4 Performance Analysis\",\"t\":[\"为进一步评估模型的理解与泛化能力，作者设计了多个分析实验。\",\"多个物体场景（Multiple Objects）：\",\"在同一张交互图像中存在多个物体时，模型能准确对每个对象生成独立的 affordance 区域（见图6）\",\"多种可供性（Multiple Affordances）：\",\"同一物体在不同交互图像中被推理出不同的 3D affordance 区域，体现出模型对语义的灵活解析能力（见图7）\",\"多实例鲁棒性（Multiple Instances）：\",\"在几何形状变化显著的同类物体中，模型依然能稳定预测合理的交互区域（见图8），说明其具备良好的泛化能力与鲁棒性\"]},\"26\":{\"h\":\"结论\",\"t\":[\"我们提出了一种开放词汇形式的 3D 物体可供性定位方法，该方法从交互图像中进行推理，能够突破预定义样本空间的限制，并推广至未见场景。为实现这一目标，我们设计了一个新颖的框架 —— 通过多头可供性链式思维（Multi-Head Affordance Chain-of-Thought）推理，挖掘物体的不变几何属性，并对潜在交互方式进行类比推理，同时结合跨模态特征对齐，实现对 3D 可供性区域的精准定位。\",\"此外，我们引入了目前最大规模的 3D 可供性数据集 PIADv2，涵盖 1.5 万张交互图像与超过 3.8 万个标注完整的 3D 物体。大量实验验证了我们提出的 GREAT 框架在多项评估指标上具有显著优势，能够在开放场景下支持可供性理解，有望提升机器人在未知环境中的自主交互能力。我们相信该研究将为视觉可供性理解领域带来新的启发并推动其发展。\",\"局限性与未来工作： GREAT 的主要局限在于其多步推理机制带来了较高的计算复杂度，在大规模或实时应用中可能成为瓶颈。未来，我们计划构建专用于推理的数据集，并利用这些数据集对多模态模型进行知识蒸馏，使其专注于特定领域，从而在实际应用中实现更快、更高效的性能。\"]},\"27\":{\"h\":\"代码\"},\"28\":{\"h\":\"Multi-Head Affordance Chain-of-Thought\",\"t\":[\"MHACoT是一种类人推理方式，分多个步骤，模拟人观察交互图像时的思维链条：\",\"识别交互部位（Object Interaction Perception）\",\"解析几何属性（Geometric Structure Reasoning）\",\"详细描述交互（Interaction Detailed Description）\",\"类比额外交互（Interactive Analogical Reasoning）\",\"每个子步骤都由一个 prompt 引导 MLLM（如 InternVL）做回答，从而获得：\",\"对象的交互区域\",\"Object Interaction Perception Prompt 1: Point out which part of the object in the image interacts with the person.\",\"🔹目标：定位交互发生的对象区域（如“水壶的壶嘴”）\",\"对应的几何属性\",\"Geometric Structure Reasoning Prompt 2: Explain why this part can interact from the geometric structure of the object.\",\"🔹目标：推理几何形态支持该交互（如“壶嘴上开口狭窄、带曲线”）\",\"当前交互行为\",\"Interaction Detailed Description Prompt 3: Describe the interaction between object and the person.\",\"🔹目标：细致地识别交互动作及其参与部位（如“用手握住壶把倒水”）\",\"潜在交互意图\",\"Interactive Analogical Reasoning Prompt 4: List two interactions that describe additional common interactions that the object can interact with people.\",\"🔹目标：推理除了当前交互以外，该物体常见的其他交互（如“开壶盖、抓握中部”）\",\"核心代码实现如下:\",\"# 1. 加载预训练多模态大模型 model = AutoModel.from_pretrained( path, torch_dtype=torch.bfloat16, #load_in_8bit=True, low_cpu_mem_usage=True, trust_remote_code=True, device_map=device_map).eval() tokenizer = AutoTokenizer.from_pretrained(path, trust_remote_code=True, use_fast=False) # 2. 加载图像数据 image_path = 'PATH/Data/Kettle/Internet/pour/kettle_pour_1.jpg' pixel_values = load_image(image_path, max_num=12).to(torch.bfloat16).cuda() object = image_path.split('/')[-4] # 图像所属的物体名 # 3. 定位交互部位 question1 = f'Point out which part of the {object} in the image interacts with the person. If this part is different from the part of the {object} shown in the image that performs the main function, point out the part of the {object} that performs the main function shown in the image.' response1, history = model.chat(tokenizer, pixel_values, question1, generation_config, history=None, return_history=True) print(f'{response1}') # 4. 推理几何结构 question2 = f'Explain why this part can interact from the geometric structure of the {object}. Just give the final result in one sentence.' response2, history = model.chat(tokenizer, pixel_values, question2, generation_config, history=history, return_history=True) print(f'{response2}') # 5. 详细交互行为 question3 = f'Describe the interaction between {object} and the person in the image, including the interaction type, the interaction part of the {object}, and the interaction part of the person.' response3, history= model.chat(tokenizer, pixel_values, question3, generation_config, history=history, return_history=True) print(f'{response3}') # 6. 推测其他交互 question4 = f'List two interactions that describe additional common interactions that the {object} can interact with people, including the interaction type, the interaction part of the {object}, and the interaction part of the person.' response4, history= model.chat(tokenizer, pixel_values, question4, generation_config, history=history, return_history=True) print(f'{response4}') ''' Sample output 1. the spout of kettle. 2. a narrow opening, a slight curve and the spout's position at the top of the kettle. 3. pour the liquid from the spout of the kettle using people’s hand 4. grasp the kettle using person's hand around middle body, open the kettle using people's fingers on the lid object knowledge: the spout of kettle: a narrow opening, a slight curve and the spout's position at the top of the kettle. affordance/human knowledge: pour the liquid from the spout of the kettle using people’s hand, grasp the kettle using person's hand around handle, open the kettle using people's fingers on the lid ''\",\"其中:\",\"几何结构知识 = Prompt 1 + Prompt 2 的回答 = 交互部位 + 该部位的几何属性推理\",\"交互知识 = Prompt 3 + Prompt 4 的回答 = 当前交互 + 类比/补充的交互方式\",\"MHACoT 这个过程发生在数据集准备阶段。\"]},\"29\":{\"h\":\"数据集\",\"t\":[\"先了解一下GREAT项目对应的数据集目录结构:\",\"数据集的初始化:\",\"class PIAD(Dataset): def __init__(self, run_type, setting_type, point_path, img_path, text_hk_path, text_ok_path, pair=2, img_size=(224, 224)): super().__init__() self.run_type = run_type # 当前是训练/测试/验证环境 self.p_path = point_path # 点云索引文件路径 self.i_path = img_path # 图片索引文件路径 self.text_hk_path = text_hk_path # 物体几何结构文本数据文件路径 self.text_ok_path = text_ok_path # 人类交互文本数据文件路径 self.pair_num = pair # 控制每个 图像样本 对应多少个 3D点云样本 self.affordance_label_list = ['grasp', 'contain', 'lift', 'open', 'lay', 'sit', 'support', 'wrapgrasp', 'pour', 'move', 'display', 'push', 'listen', 'wear', 'press', 'cut', 'stab', 'carry', 'ride', 'clean', 'play', 'beat', 'speak', 'pull'] # 24 ... ''' Seen ''' # 43 if setting_type == 'Seen': number_dict = {'Bag': 0, 'Microphone': 0, 'Toothbrush': 0, 'TrashCan': 0, 'Bicycle': 0, 'Guitar': 0, 'Glasses': 0, 'Hat': 0, 'Microwave':0, 'Backpack': 0, 'Door':0, 'Scissors': 0, 'Bowl': 0, 'Baseballbat': 0, 'Mop': 0, 'Dishwasher': 0, 'Bed': 0, 'Keyboard': 0, 'Clock': 0, 'Vase': 0, 'Knife': 0, 'Suitcase': 0, 'Hammer': 0, 'Refrigerator': 0, 'Chair': 0, 'Umbrella': 0, 'Bucket': 0, 'Display': 0, 'Earphone': 0, 'Motorcycle': 0, 'StorageFurniture': 0, 'Fork': 0, 'Broom': 0, 'Skateboard': 0, 'Tennisracket': 0, 'Laptop': 0, 'Table':0, 'Bottle': 0, 'Faucet': 0, 'Kettle': 0, 'Surfboard': 0, 'Mug': 0, 'Spoon': 0 } # 读取所有图片路径，所有人类交互文本数据，所有物体几何结构文本数据 self.img_files = self.read_file(self.i_path) self.text_human_files = self.read_file(self.text_hk_path) self.text_object_files = self.read_file(self.text_ok_path) self.img_size = img_size if self.run_type == 'train': # 读取所有点云路径，同时记录每类物体对应的样本总量，比如: 椅子对应的点云一共1000个 self.point_files, self.number_dict = self.read_file(self.p_path, number_dict) self.object_list = list(number_dict.keys()) # 注意: Dict 按照key的插入顺序返回的 self.object_train_split = {} start_index = 0 # 记录每个物体对应的点云索引下标区间 for obj_ in self.object_list: temp_split = [start_index, start_index + self.number_dict[obj_]] self.object_train_split[obj_] = temp_split start_index += self.number_dict[obj_] else: self.point_files = self.read_file(self.p_path)\",\"为什么我们需要pair_num参数?\",\"问题背景：GREAT 需要将 2D 交互图像（Image）与 3D 点云（Point Cloud）的特征进行对齐，但同一物体的不同实例可能有几何差异（例如不同形状的椅子）。\",\"解决方案：通过为每张图像配对多个点云（pair_num > 1），模型能够学习从 多样化的几何变体 中提取共性的几何属性（如“可抓握”的共享结构特征），而不仅仅依赖单一实例。\",\"代码体现：在 getitem 中，训练时会对每个图像随机采样 pair_num 个同类别点云（见 point_sample_idx 的生成逻辑）\",\"GREAT 项目的数据组织中，将每个样本属于的物体类型，待预测功能区域类型全部隐含在了样本对应的文件路径中:\",\"获取数据:\",\" def __getitem__(self, index): # 1. 获取图片，人类交互文本，物体几何结构文本 img_path = self.img_files[index] text_hd = self.text_human_files[index] text_od = self.text_object_files[index] # 2.1 评估时需要标准的单一样本对比 if (self.run_type=='val'): point_path = self.point_files[index] else: # 2.2 从图片路径中截取得到物体名，交互行为名，点云索引下标区间 object_name = img_path.split('/')[-4] affordance_name = img_path.split('/')[-2] range_ = self.object_train_split[object_name] # 从索引区间中随机采样pair_num个点云样本 point_sample_idx = random.sample(range(range_[0],range_[1]), self.pair_num) # 3. 加载点云样本，同时判断是否与当前图片交互行为一致，不一致则重新随机选 for i ,idx in enumerate(point_sample_idx): while True: point_path = self.point_files[idx] sele_affordance = point_path.split('/')[-2] if sele_affordance == affordance_name: point_sample_idx[i] = idx break else: idx = random.randint(range_[0],range_[1]-1) # re-select idx Img = Image.open(img_path).convert('RGB') if(self.run_type == 'train'): Img = Img.resize(self.img_size) Img = img_normalize_train(Img) # 4. 加载列表中所有点云样本 Points_List = [] affordance_label_List = [] affordance_index_List = [] for id_x in point_sample_idx: point_path = self.point_files[id_x] # 加载点云数据和功能区域掩码(功能区域热力图) Points, affordance_label = self.extract_point_file(point_path) # （2048，3） Points,_,_ = pc_normalize(Points) Points = Points.transpose() # (3,2048) affordance_index = self.get_affordance_label(img_path) # 当前点云待预测的交互行为/功能区域类型 Points_List.append(Points) # 点云 affordance_label_List.append(affordance_label) # 功能区域热力图 affordance_index_List.append(affordance_index) # 待预测功能区域类型 else: Img = Img.resize(self.img_size) Img = img_normalize_train(Img) Point, affordance_label = self.extract_point_file(point_path) Point,_,_ = pc_normalize(Point) Point = Point.transpose() if(self.run_type == 'train'): # 图片 ， 交互信息文本，物体几何结构文本，点云样本列表，功能区域热力图列表，待预测功能区域类型列表 return Img, text_hd, text_od, Points_List, affordance_label_List, affordance_index_List else: return Img, text_hd, text_od, Point, affordance_label, img_path, point_path\"]},\"30\":{\"h\":\"模型\",\"t\":[\"class GREAT(nn.Module): ... def forward(self, img, xyz, text_human, text_object): ''' img: [B, 3, H, W] xyz: [B, 3, 2048] ''' B, C, N = xyz.size() # 1. 用Resnet18对图像进行编码，返回的高维隐向量维度为 (batch,512,7,7) -- （batch,channel,h,w) F_I = self.img_encoder(img) # 维度展平(batch,channel,h*w) F_i = F_I.view(B, self.emb_dim, -1) # 2， PointNet++ 对点云进行编码 F_p_wise = self.point_encoder(xyz) # 3. Roberta 对交互文本和几何结构文本进行编码 T_h= self.text_encoder(text_human) # (batch,3,512) T_o = self.text_encoder2(text_object) # (batch,1,512) # 4. 交互文本和几何结构文本的信息通过改良的交叉注意力机制进行交互融合 T_h_, T_o_ =self.affordance_dictionary_fusion(T_h, T_o) # 维度同上，均保持不变 # 5. 交互文本信息与图像信息进行融合 I_h = self.img_text_fusion(F_i,T_h_) # (batch,512,49) # 6. 几何结构文本信息与点云信息进行融合，然后进入pointnet++的特征传播阶段(插值阶段)，最后再与I_h进行交互融合 _3daffordance = self.decoder(T_o_, I_h.permute(0,2,1), F_p_wise) # T_o_(batch,1,512)，I_h.permute(batch,49,512)，点云特征 return _3daffordance\"]},\"31\":{\"h\":\"文本编码\",\"t\":[\"使用 RoBerta 对交互文本和几何结构文本进行编码这块，需要注意在对交互文本进行编码时，会按照 \\\",\\\" 将文本切分为多个句子，对每个句子独立进行编码:\",\"原始交互文本: pour the liquid from the spout of the kettle using people’s hand, grasp the kettle using person's hand around handle, open the kettle using people's fingers on the lid 切分后: pour the liquid from the spout of the kettle using people’s hand grasp the kettle using person's hand around handle open the kettle using people's fingers on the lid\",\"这样做的原因是因为交互文本由当前图片反映的交互行为和模型额外补充的当前物体存在的其他交互行为构成，他们之间的关系是独立的。而几何结构文本则是单一连贯的几何描述，无需切分，直接对整句进行编码。\"]},\"32\":{\"h\":\"改良的交叉注意力\",\"t\":[\"人类通过同时分析物体的 功能意图（如\\\"倒水\\\"）和 几何属性（如\\\"壶嘴的形状\\\"）来推断交互可能性。交叉注意力模拟了这种双向推理过程，通过建立意图与几何的显式关联，实现类似人类的类比推理能力。\",\"class Cross_Attention(nn.Module): ... def forward(self, hk, ok): ''' hk : human knowledge [B,N_hk,C] ok : object knowledge [B,N_ok,C] ''' # 用意图文本（如\\\"pour\\\"）筛选相关的几何特征（强化\\\"壶嘴\\\"结构，弱化\\\"把手\\\"） hk_q = self.proj_hq(hk) ok_key = self.proj_ok(ok) ok_value = self.proj_ov(ok) ok_key_ = torch.cat((hk_q,ok_key),dim=1) # 强化人类意图在物体语义推理中的引导作用 ok_value_ = torch.cat((hk_q,ok_value),dim=1) atten_I1 = torch.bmm(hk_q, ok_key_.permute(0, 2, 1))*self.scale atten_I1 = atten_I1.softmax(dim=-1) I_1 = torch.bmm(atten_I1, ok_value_) I_1 = self.layernorm(hk + I_1) # 用几何结构（如\\\"cylindrical handle\\\"）修正意图理解（排除与几何矛盾的意图） ok_q = self.proj_oq(ok) hk_key = self.proj_hk(hk) hk_value = self.proj_hv(hk) hk_key_ = torch.cat((ok_q,hk_key),dim=1) # 利用物体结构辅助推断更多人类交互意图 hk_value_ = torch.cat((ok_q,hk_value),dim=1) atten_I2 = torch.bmm(ok_q, hk_key_.permute(0, 2, 1))*self.scale atten_I2 = atten_I2.softmax(dim=-1) I_2 = torch.bmm(atten_I2, hk_value_) I_2 = self.layernorm(ok + I_2) return I_1, I_2\"]},\"33\":{\"h\":\"几何结构信息与交互信息的融合\",\"t\":[\"class affordance_dictionary_fusion(nn.Module): ... def forward(self,f_hk,f_ok): # 第一阶段：语义对齐（cross attention）➜ 把 Human 与 Object 信息“连接”起来 H, O = self.cross_atten(f_hk, f_ok) # 第二阶段：结构融合（self attention）➜ 在 Human 内部或 Object 内部 “整理、总结、泛化” H_= self.h_atten(H) O_= self.o_atten(O) return H_, O_\"]},\"34\":{\"h\":\"交互信息与图像特征的融合\",\"t\":[\"class img_text_fusion(nn.Module): def __init__(self, emb_dim = 512, proj_dim = 512): class SwapAxes(nn.Module): def __init__(self): super().__init__() def forward(self, x): return x.transpose(1, 2) super().__init__() self.emb_dim = emb_dim self.proj_dim = proj_dim self.fusion = nn.Sequential( nn.Conv1d(2*self.emb_dim, self.emb_dim, 1, 1), nn.BatchNorm1d(self.emb_dim), nn.ReLU() ) self.reshape = nn.Sequential( nn.Linear(3, 3 * 8), # (batch,512,24) SwapAxes(), # (batch,24,512) nn.BatchNorm1d(3 * 8), nn.ReLU(), SwapAxes(), # (batch,512,24) nn.Linear(3 * 8, 49), # （batch,512,49) ) # F_i (batch,512,49) --> (batch,channel,H*W) def forward(self,F_i,T_h_): # T_h_(batch,3,512) ---> 转置后 (batch,512,3) --> reshape后 (batch,512,49) T_h_ = self.reshape(T_h_.permute(0,2,1)) # 拼接后: (batch,1024,49) I_ = torch.cat((F_i, T_h_),dim=1) # 通道维度上进行特征融合，同时降维: (batch.512,49) I_ = self.fusion(I_) return I_\"]},\"35\":{\"h\":\"解码阶段\",\"t\":[\"class Decoder(nn.Module): def __init__(self, additional_channel, emb_dim, proj_dim): class SwapAxes(nn.Module): def __init__(self): super().__init__() def forward(self, x): return x.transpose(1, 2) super().__init__() self.emb_dim = emb_dim self.proj_dim = proj_dim #upsample self.fp3 = PointNetFeaturePropagation(in_channel=512+self.emb_dim, mlp=[768, 512]) self.fp2 = PointNetFeaturePropagation(in_channel=832, mlp=[768, 512]) self.fp1 = PointNetFeaturePropagation(in_channel=518+additional_channel, mlp=[512, 512]) self.cmff = Cross_Modal_Feature_Fusion(emb_dim, proj_dim) self.out_head = nn.Sequential( nn.Linear(self.emb_dim, self.emb_dim // 8), SwapAxes(), nn.BatchNorm1d(self.emb_dim // 8), nn.ReLU(), SwapAxes(), nn.Linear(self.emb_dim // 8, 1), ) self.reshape = nn.Sequential( nn.Linear(49, 49 * 8), SwapAxes(), nn.BatchNorm1d(49 * 8), nn.ReLU(), SwapAxes(), nn.Linear(49 * 8, 2048), ) self.sigmoid = nn.Sigmoid() self.fusion = nn.Sequential( nn.Conv1d(2*self.emb_dim, self.emb_dim, 1, 1), nn.BatchNorm1d(self.emb_dim), nn.ReLU() ) def forward(self, T_o, I_h, encoder_p): ''' T_o --->object knowledge embedding (batch,1,512) I_h ---> [B, N_i, C] (batch,49,512) encoder_p ---> [Hierarchy feature] ''' B, _, _ = I_h.shape # p_i[1]: (1,3,2048) , （1，320，512) , (1,512,128) , (1,512,64) --> (batch,features,points) # p_i[0] 为坐标 p_0, p_1, p_2, p_3 = encoder_p # 逐层点云特征列表 # 1. 传入数据维度: (1,1,512) , (1,64,512) , 点云特征和几何结构特征做特征融合 p_3[1] = self.cmff(T_o, p_3[1].transpose(-2, -1)) # (1,512,64) # 2. 进入PointNet++经典的特征传播阶段 up_sample = self.fp3(p_2[0], p_3[0], p_2[1], p_3[1]) # (1,512,128) up_sample = self.fp2(p_1[0], p_2[0], p_1[1], up_sample) # (1,512,512) up_sample = self.fp1(p_0[0], p_1[0], torch.cat([p_0[0], p_0[1]],1), up_sample) # (1,512,2048) # 3. I_h reshape后 (1,512,2048) F_I = self.reshape(I_h.permute(0,2,1)) # 4. 图像交互信息与点云特征做融合: 拼接后，通道维度上进行特征融合，同时降维: (1,512,2048) F_j = torch.cat((F_I, up_sample),dim=1) F_j_fusion = self.fusion(F_j) # 5. F_j_fusion.permute后(1,2048,512) --> (1,2048,1) _3daffordance = self.out_head(F_j_fusion.permute(0, 2, 1)) _3daffordance = self.sigmoid(_3daffordance) # 生成功能区域掩码 return _3daffordance\"]},\"36\":{\"h\":\"点云特征与几何结构特征的融合\",\"t\":[\"class Cross_Modal_Feature_Fusion(nn.Module): def __init__(self, emb_dim, proj_dim): class SwapAxes(nn.Module): def __init__(self): super().__init__() def forward(self, x): return x.transpose(1, 2) super().__init__() self.emb_dim = emb_dim self.proj_dim = proj_dim self.cross_atten1 = Cross_Attention(emb_dim = self.emb_dim, proj_dim = self.proj_dim) # 假设输入数据维度为 (1,64,512) : 先降维，进行信息压缩 self.fc = nn.Sequential( nn.Linear(self.emb_dim, self.emb_dim//2), # (1,64,256) SwapAxes(), # (1,256,64) nn.BatchNorm1d(self.emb_dim // 2), nn.ReLU(), SwapAxes(), # (1,64,256) nn.Linear(self.emb_dim//2, self.emb_dim), # (1,64,512) SwapAxes(), # (1,512,64) nn.BatchNorm1d(self.emb_dim), SwapAxes(), # (1,64,512) ) self.norm1 = nn.LayerNorm(self.emb_dim) self.norm2 = nn.LayerNorm(self.emb_dim) self.pool = nn.AdaptiveAvgPool1d(1) self.fusion = nn.Sequential( nn.Conv1d(2*self.emb_dim, self.emb_dim, 1, 1), nn.BatchNorm1d(self.emb_dim), nn.ReLU() ) # (1,1,512) , (1,64,512) def forward(self,f_t,f_p): _, N_P, _ = f_p.size() # 1. 应用改良的交叉注意力机制 f_to, f_po = self.cross_atten1(f_t, f_p) # 2. 注意力后，加上经典的: x + FNN f_to = f_to + self.fc(f_to) f_po = f_po + self.fc(f_po) # 3. f_to.permute维度(1,512,1) --> pool后(1,512,1) f_t_p = self.pool(f_to.permute(0,2,1)) # 4. 维度扩展到64 --> (1,512,64) f_t_r = f_t_p.repeat(1, 1, N_P) # 5. f_po.permute维度(1,512,64) --> 拼接后(1,1024,64) joint = torch.cat((f_po.permute(0,2,1), f_t_r), dim = 1) # 6. 通道维度作信息融合(1,512,64) output = self.fusion(joint) return output\"]},\"37\":{\"h\":\"LMAffordance3D 模型代码解读与复现\",\"t\":[\"Grounding 3D Object Affordance with Language Instructions, Visual Observations and Interactions 论文代码解读与复现\",\"论文: https://arxiv.org/abs/2504.04744 代码: https://github.com/cn-hezhu/LMAffordance3D\",\"由于论文数据集还未开源，加之原本在Github上开源的代码后续被下架，导致本论文复现流程暂时终止。\"]},\"38\":{\"h\":\"环境配置 (待完善)\",\"t\":[\"建议用Linux或者Windows系统进行测试，MacOS系统某些包的加载和依赖关系上存在问题，不方便进行处理。\"]},\"39\":{\"h\":\"模型结构\",\"t\":[\"模型结构图\"]},\"40\":{\"h\":\"LMAffordance3D\",\"t\":[\"class LMAffordance3D(Blip2Base): ... def forward(self, img, point, description, label, inference_mode=False): ''' img: [B, 3, H, W] -> 输入图像 (batch_size, channels, height, width) point: [B, 3, 2048] -> 点云数据 (batch_size, dimensions, num_points) description: 自然语言指令 (e.g., \\\"Grasp the bottle\\\") label: 真实标签，即每个点对应的 affordance 概率分布 (B, 2048, 1) inference_mode: 是否为推理模式（True/False） ''' # 获取输入维度信息 B, C, H, W = img.size() B, D, N = point.size() device = img.device # 获取设备信息（CPU/GPU） # Step 1: 提取图像和点云的特征 # -------------------------------------------------- # 图像编码器：ResNet18 提取 2D 特征 F2D ∈ RB×CI×H×W img_feature = self.img_encoder(img) # shape: [B, CI, H', W'] # 点云编码器：PointNet++ 提取 3D 特征 F3D ∈ RB×CP×NP point_feature = self.point_encoder(point) # shape: [B, CP, NP] # Step 2: 融合多模态空间特征 # -------------------------------------------------- # 使用 MLP 和自注意力机制融合图像与点云特征 spatial_feature = self.fusion(img_feature, point_feature) # shape: [B, NS, CS] # Step 3: 多模态特征投影到语言语义空间 # -------------------------------------------------- # 将融合后的空间特征通过适配器上采样到与语言模型匹配的维度 if self.has_qformer: ... # 如果使用 Q-Former，则进行额外处理 else: multi_embeds = self.adapter_up(spatial_feature) # shape: [B, NS, CL] image_atts = None # 默认图像注意力掩码为空 # Step 4: 对自然语言指令进行 Tokenization # -------------------------------------------------- # 设置 tokenizer 的 padding 和 truncation 方向 self.llm_tokenizer.padding_side = \\\"right\\\" self.llm_tokenizer.truncation_side = 'left' # 对语言指令进行分词，转换为 token ID 并生成 attention mask text_input_tokens = self.llm_tokenizer( description, return_tensors=\\\"pt\\\", padding=\\\"longest\\\", # 填充至最长序列长度 truncation=True, # 截断过长文本 max_length=self.max_txt_len, # 最大文本长度 ).to(device) # Step 5: 获取语言嵌入 # -------------------------------------------------- # 使用 LLM 的 embedding 层将 token ID 转换为嵌入向量 inputs_embeds = self.llm_model.get_input_embeddings()(text_input_tokens.input_ids) # shape: [B, NL, CL] （NL=token数，CL=语言嵌入维度） # Step 6: 拼接多模态嵌入与语言嵌入 # -------------------------------------------------- # 调用 concat_input 函数，将图像+点云特征插入语言嵌入中 llm_inputs, llm_attention_mask = self.concat_input( inputs_embeds, text_input_tokens.attention_mask, multi_embeds, image_atts ) # llm_inputs: [B, NL + NS, CL] # llm_attention_mask: [B, NL + NS] # Step 7: 使用 Vision-Language Model 进行联合推理 # -------------------------------------------------- # 在混合精度下运行 LLM，融合语言与视觉特征 with self.maybe_autocast(): hidden_states = self.llm_model( inputs_embeds=llm_inputs, attention_mask=llm_attention_mask, return_dict=False, # 返回 tuple 格式输出 ) # Step 8: 降维适配器 # -------------------------------------------------- # 通过适配器层将 LLM 输出映射回合适维度 hidden_states = self.adapter_down(hidden_states) # shape: [B, NS + NL, CS] # 分割出 semantic feature 和 instructional feature # 视觉语义特征 和 语言指令理解特征 semantic_feature, instructional_feature = torch.split( hidden_states, split_size_or_sections=spatial_feature.size(1), dim=1 ) # Step 9: 解码器融合所有特征以预测可操作性特征 # -------------------------------------------------- # 使用 cross-attention 融合 instruction, semantic, spatial features affordance_feature = self.affordance_decoder( spatial_feature, instructional_feature, semantic_feature ) # shape: [B, NA, CA] # Step 10: 使用分割头预测最终的 3D 可操作性热图 # -------------------------------------------------- out = self.head(spatial_feature, affordance_feature, point_feature) # 输出 shape: [B, 2048, 1]，表示每个点是否具有特定可操作性的概率 # Step 11: 推理或训练分支 # -------------------------------------------------- if inference_mode == True: return out # 仅返回预测结果 else: loss_hm = self.loss_hm(out, label) # 计算 heatmap 的损失（focal + dice） loss = loss_hm * self.w_hm # 加权总损失 return { \\\"out\\\": out, \\\"loss\\\": loss, \\\"loss_hm\\\": loss_hm }\"]},\"41\":{\"h\":\"Step 2: 融合多模态空间特征\",\"t\":[\"class Fusion(nn.Module): def __init__(self, emb_dim = 512, num_heads = 4): super().__init__() self.emb_dim = emb_dim # 对点积结果进行缩放，防止 softmax 梯度消失或爆炸。 self.div_scale = self.emb_dim ** (-0.5) self.num_heads = num_heads # 对图像和点云特征进行 非线性增强和空间对齐 ，使得它们能够在统一的语义空间中进行有效的跨模态交互。 self.mlp = nn.Sequential( nn.Conv1d(self.emb_dim, 2*self.emb_dim, 1, 1), nn.BatchNorm1d(2*self.emb_dim), nn.ReLU(), nn.Conv1d(2*self.emb_dim, self.emb_dim, 1, 1), nn.BatchNorm1d(self.emb_dim), nn.ReLU() ) self.img_attention = Self_Attention(self.emb_dim, self.num_heads) self.point_attention = Self_Attention(self.emb_dim, self.num_heads) self.joint_attention = Self_Attention(self.emb_dim, self.num_heads) def forward(self, img_feature, point_feature): ''' i_feature: [B, C, H, W] p_feature: [B, C, N_p] HW = N_i ''' B, C, H, W = img_feature.size() img_feature = img_feature.view(B, self.emb_dim, -1) #[B, C, N_i] point_feature = point_feature[-1][1] # 对图像和点云特征进行 非线性增强和空间对齐 ，使得它们能够在统一的语义空间中进行有效的跨模态交互。 p_feature = self.mlp(point_feature) i_feature = self.mlp(img_feature) # 跨模态注意力矩阵: 每个点云点与图像中每个位置之间的相似度得分 phi = torch.bmm(p_feature.permute(0, 2, 1), i_feature)*self.div_scale #[B, N_p, N_i] # 每列是一个 softmax 分布（每个图像位置对应的所有点云点）, 表示：“对于图像中的每一个位置，应该关注哪些点云点？” phi_p = F.softmax(phi,dim=1) # 每行是一个 softmax 分布（每个点云点对应的所有图像位置）, 表示：“对于点云中的每一个点，应该关注图像中的哪些位置？” phi_i = F.softmax(phi,dim=-1) # I_enhance 是图像 patch 引导下提取的点云信息增强后的图像特征 # 它不是直接包含原始图像 patch 的语义 # 而是通过“点云中相关点”的方式重构图像 patch 的语义 I_enhance = torch.bmm(p_feature, phi_p) #[B, C, N_i] # P_enhance 是每个点云局部区域关键点引导下提取的图像信息增强后的点云关键点局部区域特征 P_enhance = torch.bmm(i_feature, phi_i.permute(0,2,1)) #[B, C, N_p] # 在跨模态融合后，进一步提取各自模态内部的语义一致性与结构关系，形成更稳定的联合表示。 I = self.img_attention(I_enhance.mT) #[B, N_i, C] P = self.point_attention(P_enhance.mT) #[B, N_p, C] # 将图像patch和点云点拼接成一个统一的token序列 # 使用自注意力机制提炼两个模态之间的语义一致性 joint_patch = torch.cat((P, I), dim=1) multi_feature = self.joint_attention(joint_patch) #[B, N_p+N_i, C] return multi_feature\"]},\"42\":{\"h\":\"Step 3: 多模态特征投影到语言语义空间\",\"t\":[\" # 将融合后的 3D 和 2D 特征从原始嵌入维度 (self.emb_dim) 映射到 LLM（语言模型）所使用的隐藏状态空间维度 （self.llm_model.config.hidden_size）。 self.adapter_up = nn.Sequential( nn.Linear(self.emb_dim, self.emb_dim), nn.ReLU(), nn.Linear(self.emb_dim, self.llm_model.config.hidden_size) )\"]},\"43\":{\"h\":\"Step 6: 拼接多模态嵌入与语言嵌入\",\"t\":[\"def concat_input(self, input_embeds, input_atts, multi_embeds, image_atts=None): ''' 将语言嵌入（text embeddings）与多模态嵌入（如图像、点云等）拼接在一起， 构建 Vision-Language Model (VLM) 所需的输入格式。 Args: input_embeds: (batch_size, sequence_length, hidden_size) - 语言 token 经过 embedding 层后的结果。 input_atts: (batch_size, sequence_length) - 语言部分的 attention mask（1 表示有效，0 表示填充）。 multi_embeds: (batch_size, n, hidden_size) - 多模态嵌入（如图像或点云特征），形状为 [B, n, H]。 image_atts: (batch_size, n), optional - 多模态数据的 attention mask，默认为全 1（即所有 token 都有效）。 Returns: llm_inputs: (batch_size, total_length, hidden_size) - 拼接后的输入嵌入，供 LLM 使用。 llm_attention_mask: (batch_size, total_length) - 对应的注意力掩码。 ''' # 初始化用于存储每个样本拼接后输入和 attention mask 的列表 llm_inputs = [] llm_attention_mask = [] # 获取 batch size bs = multi_embeds.size()[0] # 对每个样本单独处理（逐个拼接） for i in range(bs): # 获取当前样本中多模态嵌入的维度信息：(n, dim) _, n, dim = multi_embeds.size() # 计算当前语言输入中有多少个有效 token（非 padding） this_input_ones = input_atts[i].sum() # 拼接嵌入向量： # 语言前半段（有效的部分）+ 多模态嵌入 + 语言后半段（padding 部分） llm_inputs.append( torch.cat([ input_embeds[i][:this_input_ones], # 有效语言部分 multi_embeds[i], # 插入的多模态嵌入 input_embeds[i][this_input_ones:] # 剩余的语言 padding 部分 ]) ) # 构建 attention mask： if image_atts is None: # 如果没有提供 image_atts，则默认多模态 token 都是有效的（mask 全为 1） llm_attention_mask.append( torch.cat([ input_atts[i][:this_input_ones], torch.ones((n), device=multi_embeds.device, dtype=torch.long), input_atts[i][this_input_ones:] ]) ) else: # 否则使用给定的 image_atts 来标记哪些多模态 token 是有效的 llm_attention_mask.append( torch.cat([ input_atts[i][:this_input_ones], image_atts[i], input_atts[i][this_input_ones:] ]) ) # 将 list 转换为 batched tensor llm_inputs = torch.stack(llm_inputs, 0) llm_attention_mask = torch.stack(llm_attention_mask, 0) # 返回拼接好的输入和 attention mask return llm_inputs, llm_attention_mask\"]},\"44\":{\"h\":\"Step 8: 降维适配器\",\"t\":[\" # 降维适配器：将 LLM 输出的隐藏状态映射回原始嵌入维度（self.emb_dim） self.adapter_down = nn.Sequential( nn.Linear(self.llm_model.config.hidden_size, self.llm_model.config.hidden_size), nn.ReLU(), nn.Linear(self.llm_model.config.hidden_size, self.emb_dim) )\"]},\"45\":{\"h\":\"Step 9: 解码器融合所有特征以预测可操作性特征\",\"t\":[\"class Affordance_Decoder(nn.Module): def __init__(self, emb_dim, proj_dim): super().__init__() self.emb_dim = emb_dim self.proj_dim = proj_dim self.cross_atten = Cross_Attention(emb_dim = self.emb_dim, proj_dim = self.proj_dim) self.fusion = nn.Sequential( nn.Conv1d(2*self.emb_dim, self.emb_dim, 1, 1), nn.BatchNorm1d(self.emb_dim), nn.ReLU() ) def forward(self, query, key, value): ''' query: [B, N_p + N_i, C] -> spatial_feature (query) key: [B, N_l, C] -> instructional_feature (key) value: [B, N_l, C] -> semantic_feature (value) ''' B, _, C = query.size() # 调整 key 和 value 的形状为 [B, C, N_l] key = key.view(B, C, -1) # [B, C, N_l] value = value.view(B, C, -1) # [B, C, N_l] # 使用 cross attention 获取两个注意力加权结果 Theta_1, Theta_2 = self.cross_atten(query, key.mT, value.mT) # 将两个注意力输出拼接在一起 joint_context = torch.cat((Theta_1.mT, Theta_2.mT), dim=1) # [B, 2C, N_p + N_i] # 使用 Conv1D 融合通道信息 affordance = self.fusion(joint_context) # [B, C, N_p + N_i] # 调整输出格式为 [B, N_p + N_i, C] affordance = affordance.permute(0, 2, 1) # [B, N_p + N_i, C] return affordance\",\"class Cross_Attention(nn.Module): def __init__(self, emb_dim, proj_dim): \\\"\\\"\\\" 多模态交叉注意力模块（Cross-Attention Module）， 用于融合来自语言模型的不同语义信息，增强空间特征表达。 Args: emb_dim: 输入特征维度（embedding dimension），例如 LLM 的 hidden size（如 4096） proj_dim: 投影维度，用于降低计算复杂度，在 attention 中使用 \\\"\\\"\\\" super().__init__() self.emb_dim = emb_dim self.proj_dim = proj_dim # 定义投影层，将输入映射到低维空间以进行 attention 计算 self.proj_q = nn.Linear(self.emb_dim, proj_dim) # query 投影 self.proj_sk = nn.Linear(self.emb_dim, proj_dim) # sub key 投影 self.proj_sv = nn.Linear(self.emb_dim, proj_dim) # sub value 投影 self.proj_ek = nn.Linear(self.emb_dim, proj_dim) # scene key 投影 self.proj_ev = nn.Linear(self.emb_dim, proj_dim) # scene value 投影 # 缩放因子，用于 attention 分数归一化 self.scale = self.proj_dim ** (-0.5) # 层归一化（LayerNorm），用于稳定训练过程 self.layernorm = nn.LayerNorm(self.emb_dim) def forward(self, obj, sub, scene): \\\"\\\"\\\" 执行交叉注意力机制，融合不同来源的信息： - obj: 空间特征（spatial feature），作为 query； - sub: 指令理解特征（instructional feature），作为第一个 attention 的 key 和 value； - scene: 视觉语义特征（semantic feature），作为第二个 attention 的 key 和 value； Args: obj: [B, N_p + HW, C] → spatial_feature（query 来源） sub: [B, HW, C] → instructional_feature（key/value 来源之一） scene: [B, HW, C] → semantic_feature（key/value 来源之二） Returns: I_1: 经过 attention 加权后的输出（第一分支） I_2: 经过 attention 加权后的输出（第二分支） \\\"\\\"\\\" B, seq_length, C = obj.size() # 获取 batch size 和通道维度 # 将输入分别投影到低维空间，便于后续 attention 计算 query = self.proj_q(obj) # [B, N_q, proj_dim] s_key = self.proj_sk(sub) # [B, N_i, proj_dim] s_value = self.proj_sv(sub) # [B, N_i, proj_dim] e_key = self.proj_ek(scene) # [B, N_e, proj_dim] e_value = self.proj_ev(scene) # [B, N_e, proj_dim] # 第一个 cross attention：使用 sub 的 key 和 value 增强 query atten_I1 = torch.bmm(query, s_key.mT) * self.scale # [B, N_q, N_i] atten_I1 = atten_I1.softmax(dim=-1) # softmax 归一化 I_1 = torch.bmm(atten_I1, s_value) # [B, N_q, proj_dim] # 第二个 cross attention：使用 scene 的 key 和 value 增强 query atten_I2 = torch.bmm(query, e_key.mT) * self.scale # [B, N_q, N_e] atten_I2 = atten_I2.softmax(dim=-1) I_2 = torch.bmm(atten_I2, e_value) # [B, N_q, proj_dim] # 使用残差连接 + LayerNorm 增强稳定性 I_1 = self.layernorm(obj + I_1) # [B, N_q, emb_dim] I_2 = self.layernorm(obj + I_2) # [B, N_q, emb_dim] return I_1, I_2\"]},\"46\":{\"h\":\"Step 10: 使用分割头预测最终的 3D 可操作性热图\",\"t\":[\"class Head(nn.Module): def __init__(self, additional_channel, emb_dim, N_p, N_raw): \\\"\\\"\\\" Head 模块用于最终的 3D 可操作性（affordance）预测。 它接收来自编码器和解码器的特征，并通过多尺度上采样与融合， 输出每个点云点的 affordance 热图（heatmap），表示该点是否具有可操作性。 Args: additional_channel: 额外通道数，例如法向量、颜色等信息 emb_dim: 特征维度（embedding dimension） N_p: point cloud token 数量（如 64） N_raw: 原始点云数量（如 2048） Notes: - 使用 PointNetFeaturePropagation 进行逐级上采样； - 结合全局池化增强语义表达； - 最终使用 MLP + Sigmoid 输出每个点的 affordance score； \\\"\\\"\\\" super().__init__() self.emb_dim = emb_dim self.N_p = N_p # point cloud token 数量 self.N_raw = N_raw # 原始点云数量（如 2048） # 多尺度上采样模块：PointNetFeaturePropagation # fp3: 输入为 [512 + emb_dim]，输出为 512 维度 self.fp3 = PointNetFeaturePropagation(in_channel=512+self.emb_dim, mlp=[768, 512]) self.fp2 = PointNetFeaturePropagation(in_channel=832, mlp=[768, 512]) self.fp1 = PointNetFeaturePropagation(in_channel=518+additional_channel, mlp=[512, 512]) # 全局平均池化层，压缩时间/空间维度 self.pool = nn.AdaptiveAvgPool1d(1) # 最终输出头：MLP + BatchNorm + ReLU + Sigmoid self.out_head = nn.Sequential( nn.Linear(self.emb_dim, self.emb_dim // 8), nn.BatchNorm1d(self.N_raw), # 对点数维度做 BN nn.ReLU(), nn.Linear(self.emb_dim // 8, 1), # 输出每个点的 affordance score nn.Sigmoid() # 输出范围 [0,1]，表示概率 ) def forward(self, multi_feature, affordance_feature, encoder_p): \\\"\\\"\\\" 执行 Head 模块的前向传播，生成最终的 3D affordance heatmap。 Args: multi_feature: [B, N_p + N_i, C] → 来自 Vision-Language Model 的拼接特征 affordance_feature: [B, N_p + N_i, C] → 来自 decoder 的可操作性特征 encoder_p: [p0, p1, p2, p3] → 编码器不同层级的点云特征 Returns: out: [B, N_raw, 1] → 每个点的 affordance score（概率值） \\\"\\\"\\\" B, N, C = multi_feature.size() # 解包编码器输出的不同层级特征 p_0, p_1, p_2, p_3 = encoder_p # 从 multi_feature 和 affordance_feature 中提取 point cloud token 部分 P_align, _ = torch.split(multi_feature, split_size_or_sections=self.N_p, dim=1) F_pa, _ = torch.split(affordance_feature, split_size_or_sections=self.N_p, dim=1) # 上采样过程：fp3 -> fp2 -> fp1 up_sample = self.fp3(p_2[0], p_3[0], p_2[1], P_align.mT) # [B, emb_dim, npoint_sa2] up_sample = self.fp2(p_1[0], p_2[0], p_1[1], up_sample) # [B, emb_dim, npoint_sa1] up_sample = self.fp1(p_0[0], p_1[0], torch.cat([p_0[0], p_0[1]], 1), up_sample) # [B, emb_dim, N_raw] # 对 F_pa 做全局池化，得到一个全局语义向量 F_pa_pool = self.pool(F_pa.mT) # [B, emb_dim, 1] # 将全局语义向量扩展回原始点云数量，实现 feature-wise attention affordance = up_sample * F_pa_pool.expand(-1, -1, self.N_raw) # [B, emb_dim, N_raw] # 输出 head：将特征映射到 0~1 的概率值，表示每个点是否具有可操作性 out = self.out_head(affordance.mT) # [B, N_raw, 1] return out\"]},\"47\":{\"h\":\"IAGNet 论文解读\",\"t\":[\"Grounding 3D Object Affordance from 2D Interactions in Images 论文解读\",\"论文: https://arxiv.org/abs/2303.10437 代码: https://github.com/yyvhang/IAGNet 数据集: https://drive.google.com/drive/folders/1F242TsdXjRZkKQotiBsiN2u6rJAGRZ2W\"]},\"48\":{\"h\":\"摘要\",\"t\":[\"这篇论文提出了一种新颖的任务设定：通过2D图像中的交互信息来预测3D物体的功能区域（affordance），旨在为具身智能体建立感知与操作之间的联系。作者设计了一个名为IAG（Interaction-driven 3D Affordance Grounding Network）的框架，通过联合区域对齐模块（JRA）解决不同来源物体区域的对齐问题，并通过功能揭示模块（ARM）建模交互上下文以明确功能区域。此外，作者还构建了一个包含图像-点云配对数据的数据集PIAD，用于支持该任务。实验结果表明，该方法在PIAD数据集上表现优异，验证了任务设定的可行性和方法的有效性。这一研究为功能学习领域提供了新的视角，并有望应用于机器人操作、增强现实等领域。\"]},\"49\":{\"h\":\"简介\",\"t\":[\"Gibson（2014）提出的“功能可供性”（affordance）概念，即物体支持的交互可能性，是连接具身智能体感知与操作的关键。现有研究主要分为两类：\",\"几何结构映射方法（如11、22）通过标注物体交互区域建立几何结构与功能的固定关联，但泛化性受限，且对多功能的相似结构易产生混淆（如图2(b)中椅子的“坐”与“移动”功能）。\",\"强化学习方法（如54）通过智能体在虚拟环境中主动交互学习功能，但搜索空间大、耗时严重。\",\"本文创新点：\",\"任务设定：首次提出通过2D交互图像预测3D物体功能区域（如图1），模拟人类通过观察学习物体功能的能力。\",\"核心挑战： \",\"对齐模糊性：2D演示与3D物体来自不同实例，需跨源对齐区域（图2(a)展示同类物体的结构相似性可辅助对齐）。\",\"功能模糊性：同一物体区域可能支持多功能（如“杯子”既可“握持”也可“盛放”），需通过交互上下文建模解决（图2(b)）。\",\"解决方案：\",\"IAG框架：包含JRA模块（通过密集跨模态相似性 对齐区域）和ARM模块（通过交叉注意力建模物体-主体/场景交互以揭示功能）。\",\"PIAD数据集：包含7,012个点云和5,162张图像，覆盖23类物体和17种功能，支持“可见”与“未见”场景的评估（图4）。\",\"意义：该方法摆脱了对几何标注或固定场景的依赖，为机器人操作、AR/VR等应用提供了更通用的功能理解范式。\"]},\"50\":{\"h\":\"相关工作\"},\"51\":{\"h\":\"\",\"t\":[\"现有研究可分为三类（如表1所示）：\",\"2D功能检测：\",\"早期工作（如12、69）从图像/视频中分割功能区域，但无法定位具体交互部位。\",\"语言辅助方法（如36）结合文本描述提升语义理解。\",\"3D功能定位：\",\"基于几何映射的方法（如11）直接关联结构与功能，泛化性差。\",\"强化学习方法（如54）通过智能体主动交互学习，但效率低。\",\"机器人操作应用：\",\"针对铰接物体（如48）设计功能热图，指导抓取和运动规划。\",\"本文区别：首次通过非配对的2D-3D数据学习功能，摆脱几何标注和固定场景限制。\"]},\"52\":{\"h\":\"\",\"t\":[\"现有方法依赖两类对齐策略：\",\"空间先验对齐：\",\"基于相机参数（如68、90）将点云投影到图像平面，需严格的空间对应。\",\"特征空间对齐：\",\"无相机参数方法（如1、6）直接建模跨模态特征相似性。\",\"本文创新：利用功能-结构的隐式关联（如图2(a)），在无空间先验下实现跨源特征对齐。\"]},\"53\":{\"h\":\"方法\"},\"54\":{\"h\":\"\",\"t\":[\"如图3所示，IAG网络输入为四元组 ，其中：\",\" 为点云坐标\",\" 为RGB图像\",\" 为图像中主体和物体的边界框\",\" 为功能类别标签\",\"处理流程：\",\"特征提取：\",\"图像分支：ResNet提取特征 \",\"点云分支：PointNet++提取特征 \",\"区域定位：\",\"通过ROI-Align获取物体/主体/场景特征 （）\",\"联合区域对齐（JRA模块）：\",\"计算密集跨模态相似性矩阵：\",\"通过自注意力建模模态内结构关系：\",\"联合注意力生成对齐特征 \",\"功能揭示（ARM模块）：\",\"交叉注意力建模交互上下文：\",\"融合生成功能表征 \",\"解码输出：\",\"功能类别预测 ：对 和 池化后拼接\",\"3D功能热图 ：通过特征传播层上采样：\"]},\"55\":{\"h\":\"\",\"t\":[\"总损失包含三项：\",\"功能分类损失：交叉熵损失监督 \",\"特征分布对齐损失：KL散度约束 与 分布：\",\"热图回归损失：Focal Loss + Dice Loss监督 \",\"最终损失为加权和：\"]},\"56\":{\"h\":\"\",\"t\":[\"JRA模块：通过跨模态相似性（）和联合注意力（）实现无先验对齐\",\"ARM模块：通过双路交叉注意力分别建模物体-主体（）和物体-场景（）交互\",\"互优化机制： 使功能表征与对齐特征相互增强（如图15所示）\"]},\"57\":{\"h\":\"代码\"},\"58\":{\"h\":\"数据集\",\"t\":[\"数据集目录下的组织方式:\",\"数据集初始化\",\"class PIAD(Dataset): def __init__(self, run_type, setting_type, point_path, img_path, box_path, pair=2, img_size=(224, 224)): super().__init__() self.run_type = run_type # train/val/test self.p_path = point_path self.i_path = img_path self.b_path = box_path # 记录物体边界框 self.pair_num = pair self.affordance_label_list = ['grasp', 'contain', 'lift', 'open', 'lay', 'sit', 'support', 'wrapgrasp', 'pour', 'move', 'display', 'push', 'listen', 'wear', 'press', 'cut', 'stab'] ... ''' Seen ''' if setting_type == 'Seen': number_dict = {'Earphone': 0, 'Bag': 0, 'Chair': 0, 'Refrigerator': 0, 'Knife': 0, 'Dishwasher': 0, 'Keyboard': 0, 'Scissors': 0, 'Table': 0, 'StorageFurniture': 0, 'Bottle': 0, 'Bowl': 0, 'Microwave': 0, 'Display': 0, 'TrashCan': 0, 'Hat': 0, 'Clock': 0, 'Door': 0, 'Mug': 0, 'Faucet': 0, 'Vase': 0, 'Laptop': 0, 'Bed': 0} # 读取出所有图片路径，存储了物体边界框文件路径 self.img_files = self.read_file(self.i_path) self.box_files = self.read_file(self.b_path) self.img_size = img_size if self.run_type == 'train': # 读取出所有点云文件路径,同时记录每类物体共对应多少不同的点云 self.point_files, self.number_dict = self.read_file(self.p_path, number_dict) self.object_list = list(number_dict.keys()) self.object_train_split = {} start_index = 0 # 记录每类物体对应的点云文件下标索引区间 for obj_ in self.object_list: temp_split = [start_index, start_index + self.number_dict[obj_]] self.object_train_split[obj_] = temp_split start_index += self.number_dict[obj_] else: self.point_files = self.read_file(self.p_path)\",\"获取数据\",\" def __getitem__(self, index): # 1. 获取图片，Box框文件路径 img_path = self.img_files[index] box_path = self.box_files[index] if (self.run_type=='val'): point_path = self.point_files[index] else: # 2. 从文件路径中提取物体名 object_name = img_path.split('_')[-3] # 3. 一张图片对应多张同物体但形状不同的点云图片 range_ = self.object_train_split[object_name] point_sample_idx = random.sample(range(range_[0],range_[1]), self.pair_num) Img = Image.open(img_path).convert('RGB') if(self.run_type == 'train'): # 4. 随机裁剪图片，同时获取裁剪后的物体框(交互主体框，目标物体框) Img, subject, object = self.get_crop(box_path, Img, self.run_type) # 5. 对图片进行缩放，同时等比例对物体框做同样的缩放 sub_box, obj_box = self.get_resize_box(Img, self.img_size, subject, object) sub_box, obj_box = torch.tensor(sub_box).float(), torch.tensor(obj_box).float() Img = Img.resize(self.img_size) Img = img_normalize_train(Img) Points_List = [] affordance_label_List = [] affordance_index_List = [] # 6. 加载点云 for id_x in point_sample_idx: point_path = self.point_files[id_x] Points, affordance_label = self.extract_point_file(point_path) Points,_,_ = pc_normalize(Points) Points = Points.transpose() affordance_label, affordance_index = self.get_affordance_label(img_path, affordance_label) Points_List.append(Points) affordance_label_List.append(affordance_label) affordance_index_List.append(affordance_index) else: ... if(self.run_type == 'train'): # 7. 图片，点云列表，点云功能区域掩码列表，点云功能区域索引列表，交互主体框，目标物体框 return Img, Points_List, affordance_label_List, affordance_index_List, sub_box, obj_box else: return Img, Point, affordance_label, img_path, point_path, sub_box, obj_box\"]},\"59\":{\"h\":\"模型\",\"t\":[\"class IAG(nn.Module): ... def forward(self, img, xyz, sub_box, obj_box): ''' img: [B, 3, H, W] xyz: [B, 3, 2048] sub_box: bounding box of the interactive subject obj_box: bounding box of the interactive object ''' B, C, N = xyz.size() ... # 1. ResNet18 编码图像 (batch,512,7,7) F_I = self.img_encoder(img) # 2. 利用ROI Align技术，得到目标物体区域特征，交互主体区域特征，背景区域特征 ROI_box = self.get_roi_box(B).to(device) F_i, F_s, F_e = self.get_mask_feature(img, F_I, sub_box, obj_box, device) # 背景区域特征图经过ROI Align映射为4*4大小的特征图 # ROI_box 大小为 7*7 , 正好为resnet18最后生成的特征图的分辨率, 因为背景区域大小等于特征图大小 F_e = roi_align(F_e, ROI_box, output_size=(4,4)) # F_i (batch,512,4,4) , F_s (batch,512,4,4) , F_e (batch,512,4,4) # 3. PointNet编码点云 # (B,3,2048) , (B,320,512) , (B,512,128) ， (B,512,64) F_p_wise = self.point_encoder(xyz) # 4. F_j = self.JRA(F_i, F_p_wise[-1][1]) # 5. affordance = self.ARM(F_j, F_s, F_e) _3daffordance, logits, to_KL = self.decoder(F_j, affordance, F_p_wise) return _3daffordance, logits, to_KL\",\"关于利用ROI Align技术，得到目标物体区域特征，交互主体区域特征，背景区域特征过程的实现细节如下:\",\" def get_mask_feature(self, raw_img, img_feature, sub_box, obj_box, device): raw_size = raw_img.size(2) current_size = img_feature.size(2) B = img_feature.size(0) # 1. 计算经过下采样得到的特征图相比于原始图片的缩小比例 scale_factor = current_size / raw_size # 2. 将交互主体框和目标物体框等比例缩小 sub_box[:, :] = sub_box[:, :] * scale_factor obj_box[:, :] = obj_box[:, :] * scale_factor # 3. 根据目标物体框，将掩码图像中目标物体所在区域激活，得到目标物体区域掩码 obj_mask = torch.zeros_like(img_feature) obj_roi_box = [] for i in range(B): obj_mask[i,:, int(obj_box[i][1]+0.5):int(obj_box[i][3]+0.5), int(obj_box[i][0]+0.5):int(obj_box[i][2]+0.5)] = 1 roi_obj = [obj_box[i][0], obj_box[i][1], obj_box[i][2]+0.5, obj_box[i][3]] # 对交互主体框位置进行精细调整(just a trick) roi_obj.insert(0, i) # 插入批次索引 -- ROI Align对齐方法需要 obj_roi_box.append(roi_obj) obj_roi_box = torch.tensor(obj_roi_box).float().to(device) sub_roi_box = [] # 4. 根据交互主体框，在目标物体区域掩码之上，激活交互主体所在区域 Scene_mask = obj_mask.clone() for i in range(B): Scene_mask[i,:, int(sub_box[i][1]+0.5):int(sub_box[i][3]+0.5), int(sub_box[i][0]+0.5):int(sub_box[i][2]+0.5)] = 1 roi_sub = [sub_box[i][0], sub_box[i][1], sub_box[i][2], sub_box[i][3]] roi_sub.insert(0,i) sub_roi_box.append(roi_sub) # 5. 借助取反激活图片背景区域 Scene_mask = torch.abs(Scene_mask - 1) # 6. 拿到图片背景区域特征图 Scene_mask_feature = img_feature * Scene_mask sub_roi_box = torch.tensor(sub_roi_box).float().to(device) # 7. 利用ROI Align技术，将目标物体区域框在特征图中框出的区域，映射为4*4大小的特征图 obj_feature = roi_align(img_feature, obj_roi_box, output_size=(4,4), sampling_ratio=4) # 8. 利用ROI Align技术，将交互主体区域框在特征图中框出的区域，映射为4*4大小的特征图 sub_feature = roi_align(img_feature, sub_roi_box, output_size=(4,4), sampling_ratio=4) # 9. 返回目标物体区域特征图，交互主体区域特征图，背景区域特征图(未经ROI Align进行映射) return obj_feature, sub_feature, Scene_mask_feature\",\"to_common 是一个跨模态特征投影模块，其核心目标是将来自不同模态（图像和点云）的特征映射到一个统一的公共特征空间，从而消除模态间的分布差异，为后续的跨模态交互提供基础。\",\"关键功能：\",\"非线性变换：通过MLP（多层感知机）对输入特征进行非线性映射。\",\"特征融合准备：将异构特征（图像网格特征 vs 点云无序特征）转换为同构表示，便于计算相似度。\",\"筛选关键信息：通过瓶颈结构（先升维后降维）过滤噪声，保留跨模态共享的显著特征。\",\"class Joint_Region_Alignment(nn.Module): def __init__(self, emb_dim = 512, num_heads = 4): super().__init__() class SwapAxes(nn.Module): def __init__(self): super().__init__() def forward(self, x): return x.transpose(1, 2) self.emb_dim = emb_dim self.div_scale = self.emb_dim ** (-0.5) self.num_heads = num_heads self.to_common = nn.Sequential( nn.Conv1d(self.emb_dim, 2*self.emb_dim, 1, 1), nn.BatchNorm1d(2*self.emb_dim), nn.ReLU(), nn.Conv1d(2*self.emb_dim, self.emb_dim, 1, 1), nn.BatchNorm1d(self.emb_dim), nn.ReLU() ) self.i_atten = Inherent_relation(self.emb_dim, self.num_heads) self.p_atten = Inherent_relation(self.emb_dim, self.num_heads) self.joint_atten = Inherent_relation(self.emb_dim, self.num_heads) def forward(self, F_i, F_p): ''' i_feature: [B, C, H, W] p_feature: [B, C, N_p] HW = N_i ''' B,_,N_p = F_p.size() # (B,512,64) # 1. 物体区域特征图展平: (B,512,4,4) --> (B,512,4*4) F_i = F_i.view(B, self.emb_dim, -1) #[B, C, N_i] # 2. 通过共享MLP迫使图像和点云特征在相同空间分布，消除模态差异 I = self.to_common(F_i) # (B,512,16) P = self.to_common(F_p) # (B,512,64) # 3. 计算相似度矩阵: (B,64,512) * (B,512,16) = (B,64,16) phi = torch.bmm(P.permute(0, 2, 1), I)*self.div_scale #[B, N_p, N_i] phi_p = F.softmax(phi,dim=1) # 计算特征图中每个点和点云每个点特征的相似度 phi_i = F.softmax(phi,dim=-1) # 计算点云中每个点和特征图中每个点特征的相似度 # 4. 特征增强(按照相似度完成信息融合 + 自注意力完成内部信息建模) I_enhance = torch.bmm(P, phi_p) # (B,512,64) * (B,64,16) = （B,512,16） [B, C, N_i] P_enhance = torch.bmm(I, phi_i.permute(0,2,1)) # (B,512,16) * (B,16,64) = （B,512,64） [B, C, N_p] I_ = self.i_atten(I_enhance.mT) #[B, N_i, C] P_ = self.p_atten(P_enhance.mT) #[B, N_p, C] # I_ (B,16,512) , P_ (B,64,512) # 5. 联合建模: 拼接 (B,80,512) + 自注意力 joint_patch = torch.cat((P_, I_), dim=1) F_j = self.joint_atten(joint_patch) #[B, N_p+N_i, C] return F_j\",\"class Affordance_Revealed_Module(nn.Module): def __init__(self, emb_dim, proj_dim): class SwapAxes(nn.Module): def __init__(self): super().__init__() def forward(self, x): return x.transpose(1, 2) super().__init__() self.emb_dim = emb_dim self.proj_dim = proj_dim self.cross_atten = Cross_Attention(emb_dim = self.emb_dim, proj_dim = self.proj_dim) self.fusion = nn.Sequential( nn.Conv1d(2*self.emb_dim, self.emb_dim, 1, 1), nn.BatchNorm1d(self.emb_dim), nn.ReLU() ) def forward(self, F_j, F_s, F_e): ''' F_j: [B, N_p + N_i, C] (B,80,512) 物体区域特征和点云特征的联合建模 F_s: [B, H, W, C] (B,512,4,4) 交互区域特征 F_e: [B, H, W, C] (B,512,4,4) 背景特征 ''' B,_,C = F_j.size() # 拉平: (B,512,4,4) --> (B,512,4*4) F_s = F_s.view(B, C, -1) #[B, N_i, C] F_e = F_e.view(B, C, -1) #[B, N_i, C] # 利用联合建模特征作为query，从交互区域特征和背景特征中提取相关信息分别单独加到自己身上 Theta_1, Theta_2 = self.cross_atten(F_j, F_s.mT, F_e.mT) #[B, C, N_p + N_i] # 通道维度完成拼接后，利用1x1卷积完成通道维度上的信息融合 joint_context = torch.cat((Theta_1.mT, Theta_2.mT), dim=1) #[B, 2C, N_p + N_i] affordance = self.fusion(joint_context) #[B, C, N_p + N_i] affordance = affordance.permute(0, 2, 1) #[B, N_p + N_i, C] return affordance # （B,80,512)\",\"class Decoder(nn.Module): def __init__(self, additional_channel, emb_dim, N_p, N_raw, num_affordance): class SwapAxes(nn.Module): def __init__(self): super().__init__() def forward(self, x): return x.transpose(1, 2) super().__init__() self.emb_dim = emb_dim self.N_p = N_p self.N = N_raw self.num_affordance = num_affordance #upsample self.fp3 = PointNetFeaturePropagation(in_channel=512+self.emb_dim, mlp=[768, 512]) self.fp2 = PointNetFeaturePropagation(in_channel=832, mlp=[768, 512]) self.fp1 = PointNetFeaturePropagation(in_channel=518+additional_channel, mlp=[512, 512]) self.pool = nn.AdaptiveAvgPool1d(1) self.out_head = nn.Sequential( nn.Linear(self.emb_dim, self.emb_dim // 8), SwapAxes(), nn.BatchNorm1d(self.emb_dim // 8), nn.ReLU(), SwapAxes(), nn.Linear(self.emb_dim // 8, 1), ) self.cls_head = nn.Sequential( nn.Linear(2*self.emb_dim, self.emb_dim // 2), nn.BatchNorm1d(self.emb_dim // 2), nn.ReLU(), nn.Linear(self.emb_dim // 2, self.num_affordance), nn.BatchNorm1d(self.num_affordance) ) self.sigmoid = nn.Sigmoid() def forward(self, F_j, affordance, encoder_p): ''' obj ---> [F_j] affordance ---> [B, N_p + N_i, C] encoder_p ---> [Hierarchy feature] ''' B,_,_ = F_j.size() p_0, p_1, p_2, p_3 = encoder_p P_align, I_align = torch.split(F_j, split_size_or_sections=self.N_p, dim=1) #[B, N_p, C] --- [B, N_i, C] F_pa, F_ia = torch.split(affordance, split_size_or_sections = self.N_p, dim=1) #[B, N_p, C] --- [B, N_i, C] up_sample = self.fp3(p_2[0], p_3[0], p_2[1], P_align.mT) #[B, emb_dim, npoint_sa2] up_sample = self.fp2(p_1[0], p_2[0], p_1[1], up_sample) #[B, emb_dim, npoint_sa1] up_sample = self.fp1(p_0[0], p_1[0], torch.cat([p_0[0], p_0[1]],1), up_sample) #[B, emb_dim, N] F_pa_pool = self.pool(F_pa.mT) #[B, emb_dim, 1] F_ia_pool = self.pool(F_ia.mT) #[B, emb_dim, 1] logits = torch.cat((F_pa_pool, F_ia_pool), dim=1) #[B, 2*emb_dim, 1] logits = self.cls_head(logits.view(B,-1)) _3daffordance = up_sample * F_pa_pool.expand(-1,-1,self.N) #[B, emb_dim, 2048] _3daffordance = self.out_head(_3daffordance.mT) #[B, 2048, 1] _3daffordance = self.sigmoid(_3daffordance) return _3daffordance, logits, [F_ia.mT.contiguous(), I_align.mT.contiguous()]\"]},\"60\":{\"h\":\"LASO 模型代码解读与复现\",\"t\":[\"LASO: Language-guided Affordance Segmentation on 3D Object 论文代码解读与复现\",\"论文: https://openaccess.thecvf.com/content/CVPR2024/papers/Li_LASO_Language-guided_Affordance_Segmentation_on_3D_Object_CVPR_2024_paper.pdf 代码: https://github.com/yl3800/LASO\",\"这篇论文提出了一项新的任务和一个配套的数据集，旨在推动 语言引导下的 3D对象功能区域分割（Language-guided Affordance Segmentation on 3D Object, 简称 LASO）。\"]},\"61\":{\"h\":\"数据集\"},\"62\":{\"h\":\"1. 基础数据来源\",\"t\":[\"数据集基于 3D-AffordanceNet 提供的点云和功能区域标注构建：\",\"每个物体都以点云形式表示；\",\"点云中的每个点被标注为支持一个或多个功能类型（multi-class affordance labels），例如 grasp、open、lift、move 等；\",\"这些功能标注是人工标注的，具有语义意义；\",\"为什么使用 3D-AffordanceNet？\",\"因为它提供了高质量的点云和功能标注，能够很好地支持 LASO 的目标：根据自然语言问题找出与之相关的功能区域。\"]},\"63\":{\"h\":\"2. 构建问题（Question Crafting）\",\"t\":[\"选取物体-功能组合： \",\"从 3D-AffordanceNet 中选取了 58 种物体-功能组合（如 mug-grasp、door-open 等）；\",\"手工设计问题： \",\"对每种组合手工编写 5 个代表性问题；\",\"使用 GPT-4 扩展生成更多问题： \",\"使用 GPT-4 为每个组合额外生成 10 个问题；\",\"总共得到 870 个专家设计的问题（58 × 15 = 870）；\",\"Affordance-Question数据可视化\",\"在扩展过程中，GPT-4 生成的问题遵循以下三个关键原则，以确保问题多样性和语义丰富性：\",\"原则\",\"描述\",\"Contextual Enrichment（上下文丰富化）\",\"添加更多上下文细节，使问题更具体地连接目标对象的功能；例：将 “Grasping scissors: top choice?” 改为 “Identify the key points on the scissors that ensure successful grasping.”\",\"Concise Phrasing（简洁表达）\",\"提炼问题本质，使其简短但仍有意义；\",\"Structural Diversity（结构多样性）\",\"使用不同句式结构（疑问句、陈述句等），防止模型偏向特定句式或长度；\"]},\"64\":{\"h\":\"3. 标注 GT Mask（Ground Truth Mask）\",\"t\":[\"对于每个问题，结合其对应的功能类型和原始点云标注信息，构造出对应的二值掩码 gt_mask：\",\"每个点是否属于当前问题描述的功能区域；\",\"gt_mask 是 (N,) 形状的一维数组，其中 N 是点数；\",\"数值可以是 0/1（binary mask），也可以是软标签（soft label），表示点属于该功能区域的概率；\",\"软标签通常用于边界模糊区域，反映点与功能核心区域的距离远近；\",\"💡 注意：这些功能标签仅用于构造问题和定位正确功能区域，在训练和测试中不作为显式监督信号。\"]},\"65\":{\"h\":\"4. 数据集组织方式\",\"t\":[\"数据总量：\",\"总样本数：19,751 个点云-问题配对；\",\"物体类别数：23 类；\",\"功能类型数：17 类；\",\"问题总数：870 个专家设计的问题；\",\"每个物体类别可有多个形状实例；\",\"一个问题可以作用于多个物体类别（泛化能力）；\",\"数据集设置（两种模式）：\",\"🔹 Seen（见过）\",\"训练和测试阶段共享相似的物体类别和功能类型的分布；\",\"目的是评估模型在熟悉场景下的表现；\",\"🔹 Unseen（未见）\",\"某些功能类型在特定物体类别下会从训练集中省略，但在测试集中保留；\",\"目的是测试模型对新组合的泛化能力；\",\"例如：模型在训练期间学会了抓取包和杯子，但测试时要求“抓取耳机”——这是训练中未曾遇到过的功能-物体组合；\",\"数据划分方式：\",\"分区\",\"物体类别数\",\"问题数\",\"样本数\",\"Train\",\"6883\",\"638\",\"16,120\",\"Val\",\"516\",\"58\",\"1,215\",\"Test\",\"1035\",\"174\",\"2,416\"]},\"66\":{\"h\":\"5. 数据增强与配对策略\",\"t\":[\"训练阶段：\",\"每次迭代中，每个形状实例随机匹配一个与其功能类型一致的问题；\",\"随机配对使模型暴露于各种语义上下文中，提升泛化能力；\",\"推理阶段（验证 & 测试）：\",\"问题配对是固定的；\",\"所有问题专属于评估阶段，不在训练中透露；\",\"确保推理一致性，保持评估完整性；\"]},\"67\":{\"h\":\"6. 数据集统计信息（来自论文图3）\",\"t\":[\"维度\",\"内容\",\"功能类型\",\"17 类，如 grasp、open、lift、move 等\",\"物体类别\",\"23 类，如 mug、microwave、chair、door 等\",\"物体-功能组合\",\"58 种唯一组合（object-affordance pairs）\",\"问题总数\",\"870 个定制化问题\",\"点云-问题配对\",\"19,751 对\",\"点云来源\",\"来自 3D-AffordanceNet，每个点云约 2048 个点\"]},\"68\":{\"h\":\"7. 代码实现\",\"t\":[\"数据集初始化的核心代码实现如下:\",\"class AffordQ(Dataset): def __init__(self, split='train', **kwargs ): # 数据集存放目录 data_root='LASO_dataset' # 数据集类型: 训练集，评估集，测试集 self.split = split # 所支持的23种物体类型和17种功能类型 classes = [\\\"Bag\\\", \\\"Bed\\\", \\\"Bowl\\\",\\\"Clock\\\", \\\"Dishwasher\\\", \\\"Display\\\", \\\"Door\\\", \\\"Earphone\\\", \\\"Faucet\\\", \\\"Hat\\\", \\\"StorageFurniture\\\", \\\"Keyboard\\\", \\\"Knife\\\", \\\"Laptop\\\", \\\"Microwave\\\", \\\"Mug\\\", \\\"Refrigerator\\\", \\\"Chair\\\", \\\"Scissors\\\", \\\"Table\\\", \\\"TrashCan\\\", \\\"Vase\\\", \\\"Bottle\\\"] afford_cl = ['lay','sit','support','grasp','lift','contain','open','wrap_grasp','pour', 'move','display','push','pull','listen','wear','press','cut','stab'] # 建立物体类型和功能类型的索引映射关系，神经网络模型只认识数字 self.cls2idx = {cls.lower():np.array(i).astype(np.int64) for i, cls in enumerate(classes)} self.aff2idx = {cls:np.array(i).astype(np.int64) for i, cls in enumerate(afford_cl)} # 加载标注数据 with open(os.path.join(data_root, f'anno_{split}.pkl'), 'rb') as f: self.anno = pickle.load(f) # 加载点云数据 with open(os.path.join(data_root, f'objects_{split}.pkl'), 'rb') as f: self.objects = pickle.load(f) # 加载58种物体-功能组合的标注数据 (数据组织形式，参考上文的 Affordance-Question数据可视化图) self.question_df = pd.read_csv(os.path.join(data_root, 'Affordance-Question.csv')) # sort anno by object class and affordance type -- 遍历标注数据列表 self.sort_anno ={} for item in sorted(self.anno, key=lambda x: x['class']): # 获取当前样本的物体类别和物体信息值: 点云ID, 功能区域掩码, 功能类别 key = item['class'] value = {'shape_id': item['shape_id'], 'mask': item['mask'], 'affordance': item['affordance']} # 每种物体可以对应多种形状实例和功能类别 if key not in self.sort_anno: # 如果当前物体类别不在排序后的字典中，直接添加 self.sort_anno[key] = [value] else: # 如果当前物体类别在排序后的字典中，将当前样本的物体信息值追加到对应列表中 self.sort_anno[key].append(value)\",\"加载的标注数据中每个样本的组织形式如下:\",\"shape_id ：点云ID\",\"class ：物体类别（如bed）\",\"affordance ：功能类别（如lay）\",\"mask ：功能区域掩码（点级别标注）\",\"标注数据组织形式\",\"点云数据组织形式\",\"每种物体可以对应多种形状实例和功能类别\",\"获取样本的代码实现:\",\" def __getitem__(self, index): # 根据样本索引取出样本数据 data = self.anno[index] # 获取当前样本对应的点云ID shape_id = data['shape_id'] # 获取当前样本对应的物体类别 cls = data['class'] # 获取当前样本对应的功能类型 affordance = data['affordance'] # 获取当前样本对应的功能区域掩码 gt_mask = data['mask'] # 取出当前样本对应的点云数据 ，（2048,3) point_set = self.objects[str(shape_id)] # 对点云数据进行归一化处理，消除尺度差异 point_set,_,_ = pc_normalize(point_set) # 对点云数据进行转置操作 ，（3,2048) point_set = point_set.transpose() # 获取当前样本对应的问题文本(训练: 随机选； 验证&测试: 固定返回问题0) question = self.find_rephrase(self.question_df, cls, affordance) # 获取当前功能类型对应的索引值 affordance = self.aff2idx[affordance] # 返回: 点云数据， 物体类别索引， 功能区域掩码， 问题文本， 功能类型索引 return point_set, self.cls2idx[cls], gt_mask, question, affordance def find_rephrase(self, df, object_name, affordance): # 如果当前是训练模式，则从问题1～15中随机选择一个问题，否则固定返回问题0 qid = str(np.random.randint(1, 15)) if self.split == 'train' else '0' qid = 'Question'+qid # 从 DataFrame df 中筛选出同时满足 物体名称匹配 和 功能属性匹配 的行，并仅保留 qid 指定的列，也就是取出上面随机选择的问题文本 result = df.loc[(df['Object'] == object_name) & (df['Affordance'] == affordance), [qid]] # 问题文本不为空，则返回该问题文本 if not result.empty: # return result.index[0], result.iloc[0]['Rephrase'] return result.iloc[0][qid] else: raise NotImplementedError\"]},\"69\":{\"h\":\"8. 总结\",\"t\":[\"LASO 数据集基于 3D-AffordanceNet 的点云和功能标注，结合人工+GPT-4 生成的多样化问题，构造出 19,751 个点云-问题配对，旨在实现语言引导下的 3D 功能区域分割，推动 3D 视觉与大语言模型（LLM）的深度融合。\"]},\"70\":{\"h\":\"模型实现\",\"t\":[\"论文提出了一个全新的模型：PointRefer，用于解决一个新颖的任务 —— 语言引导的 3D 对象功能区域分割（LASO）。\",\"模型目标： 给定一个 3D 点云对象和一个自然语言问题（例如：“Where would you grasp this mug?”），PointRefer 的目标是预测出与该问题相关的点云区域，即生成一个二值掩码，表示哪些点属于目标功能区域。\",\"PointRefer 包括以下核心模块：\",\"3D 骨干网络（3D Backbone）\",\"使用 PointNet++ 编码点云特征；\",\"多阶段编码-解码结构提取多尺度点特征；\",\"自适应融合模块（Adaptive Fusion Module, AFM）\",\"在不同解码层注入语言信息；\",\"实现语言引导下的跨模态融合；\",\"增强点特征的语义判别能力；\",\"参考点解码器（Referred Point Decoder, RPD）\",\"引入一组可学习的“问题条件化查询”（affordance queries）；\",\"利用 Transformer 解码器将这些查询与点云特征进行交互；\",\"生成动态卷积核（dynamic kernels）；\",\"最终通过卷积操作生成分割掩码；\",\"PointRefer模型结构图\",\"PointRefer 前向传播过程如下:\",\"class PointRefer(nn.Module): # 传入question文本 和 point点云数据 def forward(self, text, xyz): ''' text: [B, L, 768] xyz: [B, 3, 2048] -- (b,c,n) ''' B, C, N = xyz.size() # 1. Encoding 过程 # 1.1 Language Encoding 使用RoBert编码文本 t_feat, t_mask = self.forward_text(list(text), xyz.device) # [batch, q_len, d_model] # 1.2 BackBone Encoding 使用PointNet++编码点云 F_p_wise = self.point_encoder(xyz) \\\"\\\"\\\" Decoding \\\"\\\"\\\" # 1.3 PointNet++ 逐级做点集抽象得到的每层的点集坐标和点集特征集合 p_0, p_1, p_2, p_3 = F_p_wise # 2.Backbone Decoding过程 # 2.1 点集集合中每个点的特征和文本特征信息进行融合,传入的点集特征集合经过转置处理后的维度为: (b, n, c) p_3[1] = self.gpb(t_feat, p_3[1].transpose(-2, -1)).transpose(-2, -1) # 2.2 PointNet++ 特征传播阶段: 上采样过程中，上一层点集中的点特征重建过程中，充分吸收了高级区域抽象特征和文本特征 up_sample = self.fp3(p_2[0], p_3[0], p_2[1], p_3[1]) #[B, emb_dim, npoint_sa2] up_sample = self.gpb(t_feat, up_sample.transpose(-2, -1)).transpose(-2, -1) up_sample = self.fp2(p_1[0], p_2[0], p_1[1], up_sample) #[B, emb_dim, npoint_sa1] up_sample = self.gpb(t_feat, up_sample.transpose(-2, -1)).transpose(-2, -1) # 2.3 特征传播阶段结束: 一步步重建回原始点数量 128->256->512->1024->2048 up_sample = self.fp1(p_0[0], p_1[0], torch.cat([p_0[0], p_0[1]],1), up_sample) #[B, emb_dim, N] # 3. Referred Point Decoding过程 t_feat = self.decoder(t_feat, up_sample.transpose(-2, -1), tgt_key_padding_mask=t_mask, query_pos=self.pos1d) # b,l,c t_feat *= t_mask.unsqueeze(-1).float() _3daffordance = torch.einsum('blc,bcn->bln', t_feat, up_sample) _3daffordance = _3daffordance.sum(1)/(t_mask.float().sum(1).unsqueeze(-1)) _3daffordance = torch.sigmoid(_3daffordance) return _3daffordance.squeeze(-1)\",\"论文中所给的模型架构图中的Encoder layer指的是PointNet++中提供的PointNetSetAbstractionMsg多尺度分组点集特征抽取类\",\"论文中所给的模型架构图中的Decoder layer指的是PointNet++中提供的PointNetFeaturePropagation特征传播类\"]},\"71\":{\"h\":\"AFM 自适应融合模块\",\"t\":[\"在 LASO 任务中，模型需要根据自然语言问题（如 “Where to grasp?”）识别点云中的功能区域。由于目标功能区域的尺度、形状多样，传统方法难以适应不同情况。为此，作者设计了 AFM 模块，以增强 PointNet++ 解码过程中点特征的语言引导能力。\",\"AFM 的目标是：在不同解码阶段注入语言线索（text clues），将文本语义信息与点云特征进行跨模态融合，逐步以自上而下的方式细化点特征图，从而提升模型对多尺度、多形状的功能区域的感知能力。\",\"AFM 遵循一个 瓶颈式架构（bottleneck architecture），包含三个关键步骤：\",\"Grouping（分组）\",\"Mixing（混合）\",\"Ungrouping（解组）\",\"这三个步骤构成了一个完整的跨模态融合流程。\"]},\"72\":{\"h\":\"1️⃣ Grouping：文本引导的点特征分组\",\"t\":[\"输入：\",\"X ∈ R^{L×d}：问题编码后的文本特征（由 RoBERTa 编码得到）\",\"P ∈ R^{T×d}：某一层解码器输出的点特征，其中 T 表示该层点数\",\"处理过程：\",\"使用一个轻量级的交叉注意力模块，将文本特征作为查询（query），点特征作为键（key）和值（value），输出分组标记 G：\",\"其中：\",\" 是一个线性变换；\",\"注意力机制使得每个文本 token 对应一组相关的点特征；\",\"分组操作实现了“语言引导的点特征筛选”。\",\"重点是如何理解这里的分组: 每个文本Token询问所有点Key后，知道了哪些点跟自身的相关度更大，因此加权融合的时候，侧重于给这些点的特征分配更大的融合权重。\",\"这部分代码实现如下:\",\"# group_layer 的实现 class LightGroupAttnBlock(nn.Module): # query 是RoBerta编码后的文本特征 , (b,l,c) # key和value都是点云特征 , (b,n,c) def forward(self, query, key, value, q_mask=None): def _inner_forward(query, key, value): q = self.norm_query(query) k = q if self.key_is_query else self.norm_key(key) v = k if self.value_is_key else self.norm_value(value) # 让每个语言 token 去关注点云中最相关的区域，并在此基础上强化自身的语义表达。 # 加上原始 X 是一种残差连接（Residual Connection），可以确保语言语义不会丢失。 x = self.attn(q, k, v, q_mask) + self.drop(q) return x return _inner_forward(query, key, value)\"]},\"73\":{\"h\":\"2️⃣ Mixing：MLP-Mixer 进行组内和通道间的信息混合\",\"t\":[\"MLP-Mixer 是一种 基于 MLP（多层感知机）的视觉模型架构 ，由 Google Research 在 2021 年提出。它不使用任何注意力机制，而是通过 空间混合（mixing）和通道混合（mixing）操作 来实现全局信息建模。\",\"MLP-Mixer: An all-MLP Architecture for Vision\",\"MLP-Mixer 的核心思想是：用 MLP 替代 Transformer 中的自注意力机制 ，从而减少计算复杂度并保持性能。\",\"Token-mixing MLP\",\"对所有点/patch 的相同通道进行混合；\",\"相当于跨空间位置的信息交换；\",\"类似于 CNN 中的空间卷积；\",\"Channel-mixing MLP\",\"对每个 token 的所有通道进行处理；\",\"提取更高级的特征表示；\",\"类似于传统的全连接层或 1x1 卷积；\",\"这两个操作交替进行，形成一个类似于 Transformer 的堆叠结构，但完全不使用注意力机制。\",\"输入：\",\"G ∈ R^{L×d}：分组后的文本引导特征\",\"处理过程：\",\"使用 MLP-Mixer 来更新分组特征，生成融合特征 F：\",\"其中：\",\"MLP₁ 负责组内信息混合（token 内部）；\",\"MLP₂ 负责通道间信息混合（feature channel）；\",\"两个 MLP 交替作用，实现跨模态信息的充分交互；\",\"最终输出融合特征 F；\",\"这部分代码实现如下:\",\"# mixer 的实现 class MLPMixerLayer(nn.Module): def __init__(self, num_patches, embed_dims, patch_expansion, channel_expansion, drop_out, **kwargs): super().__init__() patch_mix_dims = int(patch_expansion * embed_dims) # 16 channel_mix_dims = int(channel_expansion * embed_dims) # 128 self.patch_mixer = nn.Sequential( nn.Linear(num_patches, patch_mix_dims, bias=False), # try here nn.GELU(), nn.Dropout(drop_out), nn.Linear(patch_mix_dims, num_patches, bias=False), nn.Dropout(drop_out) ) self.channel_mixer = nn.Sequential( nn.Linear(embed_dims, channel_mix_dims), nn.GELU(), nn.Dropout(drop_out), nn.Linear(channel_mix_dims, embed_dims), nn.Dropout(drop_out) ) self.norm1 = nn.LayerNorm(embed_dims) self.norm2 = nn.LayerNorm(embed_dims) # x 分组后的文本引导特征 : (b,l,c) def forward(self, x): # x 转置后: (b,c,l) , patch_mixer 负责组内信息混合（token 内部） x = x + self.patch_mixer(self.norm1(x).transpose(1,2)).transpose(1,2) # channel_mixer 负责通道间信息混合（feature channel) x = x + self.channel_mixer(self.norm2(x)) return x\"]},\"74\":{\"h\":\"3️⃣ Ungrouping：将融合特征映射回点空间\",\"t\":[\"输入：\",\"原始点特征 P；\",\"融合后的文本特征 F；\",\"处理过程：\",\"使用另一个注意力模块，将融合特征重新分配给每个点：\",\"其中：\",\"W₂ 是线性变换；\",\"注意力机制让每个点从融合特征中提取相关信息；\",\"输出 P_m 是语言增强后的点特征；\",\"最后加上残差连接形成最终输出 P_o：\",\"这个 P_o 就是经过 AFM 增强的点特征图，用于后续分割掩码预测。\",\"class FullAttnCatBlock(nn.Module): # query 为点云: (b,n,c) , key和value为融合后的文本特征: (b,l,c) def forward(self, query, key, value, key_padding_mask=None): def _inner_forward(query, key, value, key_padding_mask): q = self.norm_query(query) k = q if self.key_is_query else self.norm_key(key) v = k if self.value_is_key else self.norm_value(value) # 使用另一个注意力模块，将融合特征重新分配给每个点 x = self.attn(q, k, v, key_padding_mask) + self.drop(query) # MLP映射 + Residual Connection x = self.ffn(self.norm2(x)) + x return x return _inner_forward(query, key, value, key_padding_mask)\"]},\"75\":{\"h\":\"4️⃣ AFM 自适应融合模块\",\"t\":[\"有了以上 Grouping - Mixing - Ungrouping 三个关键步骤的实现，下面只需要把以上的三个步骤按流程组织起来即可得到AFM模块的完整实现了:\",\"class GPBlock(nn.Module): # q: 文本特征 (b, l, c) ， x: 点集特征集合 (b, n, c) def forward(self, q, x, q_mask=None): # Grouping阶段 gt = self.group_layer(query=q, key=x, value=x) if q_mask is not None: gt *= q_mask.unsqueeze(-1) # Mixing阶段 gt = self.mixer(gt) + self.drop(gt) # Ungrouping阶段 ungroup_tokens = self.un_group_layer(query=x, key=gt, value=gt, key_padding_mask=q_mask) return ungroup_tokens\",\"AFM 的网络结构可视化理解\",\"文本特征 X ──┐ ↓ Grouping (Cross-Attention) ↓ Mixing (MLP-Mixer) ↓ Ungrouping (Attention) ↓ 输出增强后的点特征 P_o\",\"Grouping：用语言引导点特征分组；\",\"Mixing：在分组内进行信息交换；\",\"Ungrouping：再将融合信息返回点空间；\",\"这种设计使得语言信息能有效地指导点特征的学习过程，论文中也进行了大量消融实验来验证 AFM 的有效性：\",\"模型变体\",\"mIoU\",\"AUC\",\"SIM\",\"MAE\",\"基线（不加 AFM）\",\"17.7\",\"82.1\",\"0.558\",\"0.110\",\"加入 AFM 后\",\"20.8\",\"87.3\",\"0.629\",\"0.093\",\"结果表明：加入 AFM 显著提升了所有指标，说明其确实有效增强了语言-视觉的跨模态交互能力。\"]},\"76\":{\"h\":\"RPO 参考点解码器\",\"t\":[\"Referred Point Decoder（RPD）是 LASO 任务中用于生成功能区域掩码的核心模块。\",\"它的主要目标是：\",\"利用一组问题条件化的 affordance queries 通过 Transformer 解码器与点云特征交互 ，生成一组动态卷积核（dynamic kernels），最终通过这些 kernel 对 AFM 增强后的点特征进行卷积，得到分割掩码。\",\"class TransformerDecoderLayer(nn.Module): # tgt: text feature (b,l,c), memory: up_sample (b,n,c) def forward(self, tgt, memory, tgt_mask: Optional[Tensor] = None, memory_mask: Optional[Tensor] = None, tgt_key_padding_mask: Optional[Tensor] = None, memory_key_padding_mask: Optional[Tensor] = None, pos: Optional[Tensor] = None, query_pos: Optional[Tensor] = None): # 1. Affordance Query = 问题嵌入（Question Embedding）X + 可学习的位置编码（Learnable Position Embeddings） # 这里tgt就是Roberta编码得到的文本特征嵌入向量 # 使用 X 作为初始输入，确保每个 query 都带有原始语言上下文； # 如果只用 learnable embeddings，模型将完全依赖随机初始化的参数去“猜”语言含义，效率极低； q = k = self.with_pos_embed(tgt, query_pos) # 2. 自注意力机制: 让每个 query 不仅理解自己的语义，还能感知其他 query 的信息，从而形成更完整的语言上下文理解。 tgt2 = self.self_attn(q, k, value=tgt, attn_mask=tgt_mask, key_padding_mask=tgt_key_padding_mask) tgt = tgt + self.dropout1(tgt2) tgt = self.norm1(tgt) # (b,l,c) # 3. 跨模态注意力机制: 每个 affordance query 都会基于其语言语义，从点云中找出最相关的功能区域，从而为后续的动态卷积和掩码预测提供基础。 tgt2 = self.multihead_attn(query=self.with_pos_embed(tgt, query_pos), key=self.with_pos_embed(memory, pos), value=memory, attn_mask=memory_mask, key_padding_mask=memory_key_padding_mask, output_attentions = True) tgt = tgt + self.dropout2(tgt2) tgt = self.norm2(tgt) # (b,l,c) # 4. MLP: 每个query通道维度做特征融合 tgt2 = self.linear2(self.dropout(self.activation(self.linear1(tgt)))) tgt = tgt + self.dropout3(tgt2) tgt = self.norm3(tgt) # (b,l,c) return tgt class PointRefer(nn.Module): def forward(self, text, xyz): ... # 3. Referred Point Decoding过程 # 3.1 利用一组问题条件化的 affordance queries 通过 Transformer 解码器与点云特征交互 ，生成一组动态卷积核（dynamic kernels）(b,l,c) t_feat = self.decoder(t_feat, up_sample.transpose(-2, -1), tgt_key_padding_mask=t_mask, query_pos=self.pos1d) # 3.2 对无效 token（padding）做掩码操作，防止其影响后续计算。 (b,l,c) t_feat *= t_mask.unsqueeze(-1).float() # 3.3 执行 动态卷积（Dynamic Convolution） 操作，用增强后的语言查询去“扫描”点云特征图 （b,l,n) _3daffordance = torch.einsum('blc,bcn->bln', t_feat, up_sample) # 3.4 对affordance query的响应图进行平均池化，融合所有 affordance query 的得分结果。 (b,n) _3daffordance = _3daffordance.sum(1)/(t_mask.float().sum(1).unsqueeze(-1)) # 3.5 将响应值映射到 [0, 1] 区间，表示每个点属于目标功能区域的概率。 (b,n) _3daffordance = torch.sigmoid(_3daffordance) return _3daffordance # (b,n)\",\"PyTorch 的 einsum 函数，它是一个非常强大且灵活的张量操作函数，支持通过爱因斯坦求和约定（Einstein Summation Convention） 来表达各种线性代数运算。\",\"下面详细介绍一下动态卷机核卷积的过程:\",\"t_feat: 语言查询特征 , 形状：(B, L, C) , 这是 经过 Referred Point Decoder (RPD) 处理后的 affordance queries，表示每个 token 对应的“动态卷积核”。\",\"up_sample: 上采样后的点云特征 , 形状：(B, C, N)。\",\"而下面这行代码实现的是一个 动态卷积（Dynamic Convolution） 操作：\",\"_3daffordance = torch.einsum('blc,bcn->bln', t_feat, up_sample)\",\"它的本质是： 用一组由语言引导的动态卷积核 t_feat 去卷积点云特征 up_sample，得到每个 token 对每个点的关注响应。\",\"详细解释 einsum 表达式:\",\"torch.einsum('blc,bcn->bln', t_feat, up_sample)\",\"维度\",\"含义\",\"b\",\"batch 维度，保持不变\",\"l\",\"token 维度，保留下来\",\"c\",\"特征通道维度，进行内积操作（求和）\",\"n\",\"点云维度，保留下来\",\"所以这个表达式的含义是：\",\"也就是说，对于每一个 batch 中的数据：\",\"每个 token（l）都与所有点（n）交互；\",\"每个 token 实际上是一个动态生成的卷积核（C × 1 × 1），作用于点云特征图（C × N）；\",\"最终输出形状为 (B, L, N)，表示： \",\"每个 token 对每个点的关注程度；\",\"输出张量\",\"形状\",\"含义\",\"_3daffordance\",\"(B, L, N)\",\"每个 token 对每个点的响应值（得分）\",\"然后在后续会进行如下处理：\",\"_3daffordance = _3daffordance.sum(1) / (t_mask.float().sum(1).unsqueeze(-1)) _3daffordance = torch.sigmoid(_3daffordance)\",\"即：\",\"在 token 维度求和（或平均池化），融合多个 token 的关注信息；\",\"使用 sigmoid 得到最终的掩码，形状 (B, N)；\",\"每个点的值 ∈ [0, 1]，表示其属于目标功能区域的概率；\"]},\"77\":{\"h\":\"损失函数\"},\"78\":{\"h\":\"HM_Loss（Hybrid Mask Loss）\",\"t\":[\"在 LASO 数据集中，模型需要根据自然语言问题识别点云中最相关的功能区域（如 grasping area, opening area 等），而 HM_Loss 是 PointRefer 模型的监督信号，它结合了：\",\"Focal Loss ：用于缓解类别不平衡问题；\",\"Dice Loss ：用于衡量预测掩码与真实标签之间的空间重合度；\",\"最终 loss = CELoss + DiceLoss，让模型同时关注逐点分类精度和整体区域匹配。\",\"import torch import torch.nn as nn import torch.nn.functional as F class HM_Loss(nn.Module): def __init__(self): \\\"\\\"\\\" Hybrid Mask Loss 实现： - BCE-Focal Loss（加权交叉熵） - Dice Loss（衡量预测掩码与 GT 的重合度） 公式来自论文 Section 4.2，用于语言引导下的功能区域分割。 \\\"\\\"\\\" super(HM_Loss, self).__init__() # 设置 Focal Loss 参数 self.gamma = 2 # 聚焦参数，放大难分类样本影响 self.alpha = 0.25 # 平衡因子，强调正类（前景点）loss def forward(self, pred, target): \\\"\\\"\\\" 输入： pred: 模型输出的原始 logit 或经过 sigmoid 的概率值； 形状为 [B, N] target: ground truth 掩码（soft mask），形状也为 [B, N] 返回： total_loss: CELoss + DiceLoss 的加权和 \\\"\\\"\\\" # Step 1: 构建 Focal Loss 权重项 # temp1：负类 loss（背景点） # temp2：正类 loss（目标功能区域） # 1e-6 的加入是为了让 log 计算保持稳定，尤其是在预测值接近极端值（0 或 1）时 temp1 = -(1 - self.alpha) * torch.mul( pred ** self.gamma, torch.mul(1 - target, torch.log(1 - pred + 1e-6)) ) temp2 = -self.alpha * torch.mul( (1 - pred) ** self.gamma, torch.mul(target, torch.log(pred + 1e-6)) ) # 将两个方向的 loss 合并，并取 batch 和点维度的平均 temp = temp1 + temp2 CELoss = torch.sum(torch.mean(temp, dim=(0, 1))) # Step 2: 计算正类 Dice Loss（预测与 Ground Truth 的交集 / 并集） intersection_positive = torch.sum(pred * target, dim=1) cardinality_positive = torch.sum(torch.abs(pred) + torch.abs(target), dim=1) dice_positive = (intersection_positive + 1e-6) / (cardinality_positive + 1e-6) # Step 3: 计算负类 Dice Loss（非目标区域匹配度） intersection_negative = torch.sum((1 - pred) * (1 - target), dim=1) cardinality_negative = torch.sum(2 - torch.abs(pred) - torch.abs(target), dim=1) dice_negative = (intersection_negative + 1e-6) / (cardinality_negative + 1e-6) # Step 4: 构建 Dice Loss，形式为 1 - Dice Score # 使用了一个偏置项 1.5（可能是经验设定） temp3 = torch.mean(1.5 - dice_positive - dice_negative, dim=0) DICELoss = torch.sum(temp3) # Step 5: 总损失 = 分类误差 + 区域匹配误差 return CELoss + 1.0 * DICELoss\",\"在论文 Section 4.2 中提到：\",\"“We solely employ Dice loss and Binary Cross-Entropy (BCE) loss to guide the segmentation mask prediction.”\",\"虽然这里用的是 Focal Loss + Dice Loss 的组合形式，但它本质上是 BCE + Dice 的改进版，具有以下优势：\",\"Focal Loss: 抑制 easy examples，放大 hard examples，防止忽略小区域\",\"Dice Loss: 关注整体掩码匹配度，提升边界识别能力\",\"两者结合可以：\",\"缓解类别极度不平衡问题；\",\"提高模型对语言指令下功能区域的理解能力；\",\"更好地应对 LASO 中的语言引导 + soft mask 场景；\"]},\"79\":{\"h\":\"训练\",\"t\":[\"模型的训练过程大体分为了 准备，训练，评估 三个流程；\"]},\"80\":{\"h\":\"准备\",\"t\":[\"准备阶段主要完成数据集加载，模型初始化，损失函数定义，优化器设置，学习率调度器初始化等；\",\"def main(opt, dict): # 1. 加载训练集，验证集，测试集 train_dataset = AffordQ('train') train_loader = DataLoader(train_dataset, batch_size=batch_size, num_workers=8 ,shuffle=True, drop_last=True) val_dataset = AffordQ('val') val_loader = DataLoader(val_dataset, batch_size=batch_size, num_workers=8, shuffle=False) test_dataset = AffordQ('test') test_loader = DataLoader(test_dataset, batch_size=batch_size, num_workers=8, shuffle=False) # 2. 初始化模型 model = get_PointRefer(emb_dim=dict['emb_dim'], proj_dim=dict['proj_dim'], num_heads=dict['num_heads'], N_raw=dict['N_raw'], num_affordance = dict['num_affordance'], n_groups=opt.n_groups) # 3. 初始化损失函数，优化器，学习率调度器 criterion_hm = HM_Loss() criterion_ce = nn.CrossEntropyLoss() param_dicts = [ {\\\"params\\\": [p for n, p in model.named_parameters() if \\\"text_encoder\\\" not in n and p.requires_grad]}, {\\\"params\\\": [p for n, p in model.named_parameters() if \\\"text_encoder\\\" in n and p.requires_grad], \\\"lr\\\": opt.tlr}] optimizer = torch.optim.Adam(params = param_dicts, lr=dict['lr'], betas=(0.9, 0.999), eps=1e-8, weight_decay=opt.decay_rate) # scheduler = torch.optim.lr_scheduler.CosineAnnealingLR(optimizer, T_max=dict['Epoch'], eta_min=1e-6) scheduler = torch.optim.lr_scheduler.StepLR(optimizer, step_size=10, gamma=0.5)\"]},\"81\":{\"h\":\"训练\",\"t\":[\"训练阶段则是模型的核心迭代过程，包括前向传播，损失计算，反向传播，参数更新等:\",\" ''' Training ''' for epoch in range(start_epoch+1, dict['Epoch']): num_batches = len(train_loader) loss_sum = 0 total_point = 0 model = model.train() for i,(point, cls, gt_mask, question, aff_label) in enumerate(train_loader): optimizer.zero_grad() # 4. 前向传播过程 _3d = model(question, point) # 5. 计算损失 loss_hm = criterion_hm(_3d, gt_mask) # loss_ce = criterion_ce(logits, cls) # 6. 反向传播 temp_loss = loss_hm # + opt.loss_cls*loss_ce temp_loss.backward() optimizer.step() results = torch.zeros((len(val_dataset), 2048, 1)) targets = torch.zeros((len(val_dataset), 2048, 1))\"]},\"82\":{\"h\":\"评估\",\"t\":[\"评估阶段则是在验证集或测试集上评估模型的性能，计算指标包括 MAE，SIM，AUC，mIoU。\",\"在 LASO（Language-guided Affordance Segmentation on 3D Object）任务 中，作者使用了四个核心评估指标来衡量模型对语言引导下功能区域的识别能力：\",\"指标\",\"名称\",\"英文全称\",\"MAE\",\"平均绝对误差\",\"Mean Absolute Error\",\"SIM\",\"相似性得分\",\"Similarity Score\",\"AUC\",\"曲线下面积\",\"Area Under the Curve\",\"mIoU\",\"平均交并比\",\"mean Intersection over Union\",\"MAE（Mean Absolute Error）是预测值与真实值之间的平均绝对误差，用于衡量模型输出的 soft mask 与 ground truth 掩码之间的逐点偏差。\",\"其中：\",\"：点云中点的数量；\",\"：模型预测该点属于功能区域的概率；\",\"：ground truth 标签（可以是 soft mask 或 binary mask）；\",\"特点与作用：\",\"特性\",\"描述\",\"✔️ 支持 soft mask 输入\",\"不依赖 thresholding，适用于连续响应值\",\"✔️ 衡量整体分布一致性\",\"反映模型是否准确学习语言引导下的响应强度\",\"⚠️ 对边界模糊区域不敏感\",\"IoU 等指标更关注重合度\",\"SIM（Similarity）是一种基于直方图交集的相似性指标，用于衡量两个概率分布之间的匹配程度。它常用于图像检索、图像分割等任务。\",\"即：对每个点取预测值和真实值中的较小者，然后求和。也可以归一化为：\",\"特点与作用：\",\"特性\",\"描述\",\"✔️ 不需要 thresholding\",\"支持 soft mask 输入\",\"✔️ 强调分布匹配\",\"不仅看交集，还看响应强度分布\",\"✔️ 对边界模糊区域友好\",\"不像 IoU 那样依赖 hard threshold\",\"⚠️ 不直接优化最终目标\",\"不能作为 loss 使用，更适合评估\",\"AUC（Area Under ROC Curve）是 Receiver Operating Characteristic (ROC) 曲线下的面积，衡量模型对二分类问题的判别能力。\",\"AUC 的计算流程如下：\",\"对不同阈值计算 TPR 和 FPR；\",\"绘制 ROC 曲线；\",\"计算曲线下面积（AUC）；\",\"特点与作用：\",\"特性\",\"描述\",\"✔️ 不依赖特定阈值\",\"考察所有可能的 threshold 下的表现\",\"✔️ 关注排序能力\",\"判断模型是否能正确区分前景和背景\",\"✔️ 适用于 binary 分类\",\"需要先将 soft mask 转换为 binary\",\"⚠️ 对 small region 敏感度有限\",\"需结合 mIoU 使用\",\"mIoU（mean Intersection over Union）是图像/点云分割中最常用的指标之一，衡量预测区域与真实标签之间的空间重合度。\",\"公式如下：\",\"其中：\",\"：预测的 binary mask；\",\"：真实的 binary mask；\",\"通常我们会使用多个 threshold（如 np.linspace(0, 1, 20)），然后取平均得到 aiou（average IoU）。\",\"特点与作用：\",\"特性\",\"描述\",\"✔️ 直接评价分割精度\",\"最贴近实际应用需求\",\"✔️ 对边界敏感\",\"能反映边缘响应质量\",\"✔️ 易受 threshold 影响\",\"多阈值评估更稳定\",\"⚠️ 不支持 soft mask 直接输入\",\"需先 threshold 成 binary mask\",\"四个指标对比总结:\",\"指标\",\"是否支持 soft mask\",\"是否依赖 threshold\",\"是否关注分布相似性\",\"是否关注空间重合度\",\"输出范围\",\"MAE\",\"✅ 是\",\"❌ 否\",\"✅ 是\",\"❌ 否\",\"[0, ∞)\",\"SIM\",\"✅ 是\",\"❌ 否\",\"✅ 是\",\"❌ 否\",\"[0, 1]\",\"AUC\",\"✅ 是（排序）\",\"✅ 是（binary）\",\"❌ 否\",\"❌ 否\",\"[0, 1]\",\"mIoU\",\"❌ 否（需先 threshold）\",\"✅ 是\",\"❌ 否\",\"✅ 是\",\"[0, 1]\",\"结合论文理解这些指标的意义，来自论文 Table 3 的结果：\",\"方法\",\"mIoU\",\"AUC\",\"SIM\",\"MAE\",\"PointRefer（完整方法）\",\"20.8%\",\"87.3%\",\"0.629\",\"0.093\",\"这些指标共同构成了 LASO 任务的评估体系，分别从以下角度衡量模型表现：\",\"角度\",\"对应指标\",\"1. 分布一致性\",\"SIM\",\"2. 分类判别能力\",\"AUC\",\"3. 逐点误差\",\"MAE\",\"4. 区域重合度\",\"mIoU\",\"这意味着：\",\"PointRefer 不仅理解语言指令；\",\"还能生成与 GT 掩码高度匹配的功能区域；\",\"并且在 unseen object 上也具有泛化能力；\",\"在 LASO 这种类别不平衡、soft mask、语言引导的 3D 功能区域识别任务中，四个指标协同工作：\",\"MAE 衡量逐点误差；\",\"SIM 衡量分布相似性；\",\"AUC 衡量分类器排序能力；\",\"mIoU 衡量空间重合度；\",\"它们共同帮助我们判断模型是否真正理解语言引导下的功能区域语义。\",\"验证集上进行评估的核心代码实现如下:\",\" num = 0 for i, (point, _, label, question, aff_label) in enumerate(val_loader): # 1. 前向传播，得到预测的 soft mask `_3d` ∈ [B, N] _3d = model(question, point) # 2. 计算 MAE（Mean Absolute Error），衡量逐点误差 mae, point_nums = evaluating(_3d, label) total_point += point_nums total_MAE += mae.item() pred_num = _3d.shape[0] # 当前 batch 的样本数 # 3. 收集所有样本的预测结果，便于后续统一评估 results[num : num + pred_num, :, :] = _3d.unsqueeze(-1) # shape: [B, N, 1] targets[num : num + pred_num, :, :] = label.unsqueeze(-1) # shape: [B, N, 1] num += pred_num # 更新索引 # 4. 计算平均 MAE（Mean Absolute Error） mean_mae = total_MAE / total_point # 5. 计算 SIM（Similarity Metric）—— 直方图交集，衡量分布相似性 SIM_matrix = np.zeros(targets.shape[0]) for i in range(targets.shape[0]): SIM_matrix[i] = SIM(results[i], targets[i]) # SIM 函数定义见 utils.eval sim = np.mean(SIM_matrix) # 6. 初始化 AUC 和 IOU 存储数组 AUC = np.zeros((targets.shape[0], targets.shape[2])) # shape: [num_samples, 1] IOU = np.zeros((targets.shape[0], targets.shape[2])) IOU_thres = np.linspace(0, 1, 20) # 多阈值下的 IoU 计算 # 7. 将 GT 标签二值化（soft mask → binary mask） targets_binary = (targets >= 0.5).astype(int) for i in range(AUC.shape[0]): t_true = targets_binary[i].flatten() # 真实标签 p_score = results[i].flatten() # 模型输出的概率值 if np.sum(t_true) == 0: # 8. 如果当前样本没有正类（即无功能区域），标记为 nan AUC[i] = np.nan IOU[i] = np.nan else: # 9. 计算 AUC（Area Under the Curve），衡量分类器整体判别能力 auc = roc_auc_score(t_true, p_score) AUC[i] = auc # 10. 使用多个阈值计算 mIoU（mean Intersection over Union） temp_iou = [] for thre in IOU_thres: p_mask = (p_score >= thre).astype(int) # 用不同 threshold 生成 binary mask intersect = np.sum(p_mask & t_true) # 交集 union = np.sum(p_mask | t_true) # 并集 temp_iou.append(intersect / union) # IoU = intersect / union temp_iou = np.array(temp_iou) aiou = np.mean(temp_iou) # 对所有 threshold 下的 IoU 取均值 IOU[i] = aiou # 10. 最终取所有样本的 AUC 和 mIoU 均值作为最终评估指标 AUC = np.nanmean(AUC) IOU = np.nanmean(IOU) # 11. 打印当前性能指标 logger.debug(f'AUC:{AUC} | IOU:{IOU} | SIM:{sim} | MAE:{mean_mae}') current_IOU = IOU # 12. 如果当前 mIoU 超过历史最佳，则保存 best model if current_IOU > best_IOU: best_IOU = current_IOU best_model_path = save_path + '/best_model-{}.pt'.format(sign) checkpoint = { 'model': model.state_dict(), 'optimizer': optimizer.state_dict(), 'Epoch': epoch } torch.save(checkpoint, best_model_path)\",\"测试集最终评估:\",\"category_metrics, affordance_metrics, overall_metrics = evaluate(model, test_loader, device, 3) print_metrics_in_table(category_metrics, affordance_metrics, overall_metrics, logger)\"]},\"83\":{\"h\":\"复现\",\"t\":[\"设置后台运行，同时将运行时输出写入日志:\",\"nohup python -u train.py > train.log 2>&1 &\",\"在 Python 命令中， -u 是 unbuffered 的缩写。Python 存在缓存机制， sys.stdout （标准输出）是有缓存的，只有遇到换行符或者输出内容积累到一定大小时，才会将内容显示到屏幕上；而 sys.stderr （标准错误）是无缓存的，程序向 sys.stderr 输出一个字符，就会立即在屏幕上显示一个字符 1 2 3 。\",\"当在 Python 命令后加上 -u 参数（例如 python -u xx.py ），会强制标准输出也像标准错误一样，不通过缓存直接将内容打印到屏幕上 1 2 3 。这在使用 nohup 后台运行 Python 脚本时非常有用，可以避免因为输出缓存导致日志卡在某一行不输出的问题。\",\"持续追踪日志最新输出:\",\"tail -f train.log\",\"杀死训练进程:\",\"pkill -f \\\"python train.py\\\"\",\"用训练好的模型权重，进行推理 (以下代码是我自己写的一个测试代码):\",\"import os import pickle import torch import numpy as np import open3d as o3d from utils.util import read_yaml from model.PointRefer import get_PointRefer def pc_normalize(pc): \\\"\\\"\\\" 点云数据归一化处理 Args: pc: 输入点云数据，形状为 [N, 3] 的 numpy 数组 Returns: 归一化后的点云数据 \\\"\\\"\\\" centroid = np.mean(pc, axis=0) # 计算点云质心 pc = pc - centroid # 中心化 m = np.max(np.sqrt(np.sum(pc**2, axis=1))) # 计算最大半径 pc = pc / m # 归一化到单位球内 return pc def predict_affordance_mask(points, text, model_path): \\\"\\\"\\\" 预测点云的功能区域掩码 Args: points: 输入点云数据 [N, 3] text: 描述功能的文本提示 model_path: 预训练模型路径 Returns: 功能区域预测结果 [N] \\\"\\\"\\\" # 加载模型配置 dict = read_yaml(\\\"config/default.yaml\\\") dict['bs'] = 16 # 设置batch size dict['lr'] = 1e-4 # 设置学习率 dict['Epoch'] = 50 # 设置训练轮数 # 初始化PointRefer模型 model = get_PointRefer( emb_dim=dict['emb_dim'], proj_dim=dict['proj_dim'], num_heads=dict['num_heads'], N_raw=dict['N_raw'], num_affordance=dict['num_affordance'], n_groups=40 ) # 加载预训练权重 checkpoint = torch.load(model_path, map_location='cpu') model.load_state_dict(checkpoint['model']) model.eval() # 设置为评估模式 # 点云预处理 Point = pc_normalize(points) # 归一化 Point = Point.transpose() # 转置为 [3, N] Points = torch.from_numpy(Point).unsqueeze(0).float() # 增加batch维度 [1, 3, N] text_list = [text] # 文本输入格式处理 # 模型推理 pred = model(text_list, Points) pred = torch.squeeze(pred) # 去除batch维度 [N] affordance_pred = pred.cpu().detach().numpy() # 转为numpy数组 return affordance_pred def visualize_affordance(points_coordinates, affordance_pred): \\\"\\\"\\\" 可视化功能区域预测结果（渐变颜色） Args: points_coordinates: 点云坐标 [N, 3] affordance_pred: 预测结果 [N] \\\"\\\"\\\" pred_point = o3d.geometry.PointCloud() pred_point.points = o3d.utility.Vector3dVector(points_coordinates) # 颜色映射：根据预测值从灰色(背景)到红色(功能区域)渐变 color = np.zeros((2048, 3)) reference_color = np.array([255, 0, 0]) # 红色 back_color = np.array([190, 190, 190]) # 灰色 for i, aff_pred in enumerate(affordance_pred): scale_i = aff_pred color[i] = (reference_color - back_color) * scale_i + back_color pred_point.colors = o3d.utility.Vector3dVector(color.astype(np.float64) / 255.0) o3d.visualization.draw_geometries([pred_point], window_name='Predicted Affordance', width=600, height=600) def visualize_point_cloud(points, pred_mask=None): \\\"\\\"\\\" 基础点云可视化（二值化显示） Args: points: 点云数据 [N, 3] 或 [N, 4] pred_mask: 可选，预测掩码 [N] \\\"\\\"\\\" pcd = o3d.geometry.PointCloud() # 数据预处理 if points.shape[1] == 4: # 如果包含强度值 coordinates = points[:, :3].astype(np.float64) if pred_mask is None: pred_mask = points[:, 3] > 0.5 # 使用第4列作为默认掩码 else: coordinates = points.astype(np.float64) if pred_mask is None: pred_mask = np.zeros(len(points), dtype=bool) # 设置颜色：红色=功能区域，蓝色=背景 colors = np.zeros((len(points), 3)) colors[pred_mask] = [1, 0, 0] # 红色 colors[~pred_mask] = [0, 0, 1] # 蓝色 pcd.points = o3d.utility.Vector3dVector(coordinates) pcd.colors = o3d.utility.Vector3dVector(colors.astype(np.float64)) # 创建可视化窗口 vis = o3d.visualization.Visualizer() vis.create_window(window_name='LASO Prediction Visualization') vis.add_geometry(pcd) # 设置渲染参数 opt = vis.get_render_option() opt.point_size = 2.5 # 点大小 opt.background_color = np.array([1, 1, 1]) # 白色背景 vis.run() # 运行可视化 vis.destroy_window() if __name__ == '__main__': # 数据路径设置 data_root = 'LASO_dataset' # 加载标注数据 with open(os.path.join(data_root, f'anno_val.pkl'), 'rb') as f: anno = pickle.load(f) # 加载点云数据 with open(os.path.join(data_root, f'objects_val.pkl'), 'rb') as f: objects = pickle.load(f) # 示例数据（第500个样本） print(\\\"当前物体类型: \\\", anno[500][\\\"class\\\"]) print(\\\"当前物体待预测的功能区域: \\\", anno[500][\\\"affordance\\\"]) point_cloud_data = objects[anno[500][\\\"shape_id\\\"]] # visualize_point_cloud(point_cloud_data) -- 可视化当前物体点云，再决定要使用什么文本查询 # 示例文本查询 text = \\\"If I want to move this chair, which part of the chair should I hold with my hands?\\\" # 执行预测和可视化 affordance_pred = predict_affordance_mask( point_cloud_data, text, \\\"runs/train/PointRefer/best_model-try_at_6.15_23.53.29.pt\\\" ) visualize_affordance(point_cloud_data, affordance_pred)\",\"预测结果可视化:\",\"If I want to move this chair, which part of the chair should I hold with my hands?\",\"If I want to sit on this chair, which part of the chair should I sit on?\",\"本文使用的是训练了9个epoch后的模型权重进行的推理演示，后续训练完50个epoch后，会进行推理能力结果更新。\"]},\"84\":{\"h\":\"3D-Vision Language\"},\"85\":{\"h\":\"简析PointNet++\",\"t\":[\"简析PointNet++\",\"论文: https://arxiv.org/abs/1706.02413 TensorFlow 版本代码: https://github.com/charlesq34/pointnet2 Pytorch 版本代码: https://github.com/yanx27/Pointnet_Pointnet2_pytorch\"]},\"86\":{\"h\":\"背景\",\"t\":[\"在PointNet中，网络对每一个点做低维到高维的映射，进行特征学习，然后把所有点映射到高维的特征通过最大池化最终表示全局特征。从本质上来说，要么对一个点做操作，要么对所有点做操作，实际上没有局部的概念(loal context) 。同时缺少 local context 在平移不变性上也有局限性（世界坐标系和局部坐标系）。对点云数据做平移操作后，所有的数据都将发生变化，导致所有的特征，全局特征都不一样了。对于单个的物体还好，可以将其平移到坐标系的中心，把他的大小归一化到一个球中，但是在一个场景中有多个物体时则不好办，需要对哪个物体做归一化呢？\",\"PointNet++ 解决了两个问题：如何生成点集的划分（Partitioning），以及如何通过局部特征学习器（Local Feature Learner）抽象点集或局部特征。\",\"生成点集的划分（Partitioning）：\",\"点集划分是指如何将一个大的点云分割成更小的、更易于管理的子集。这个过程类似于在传统的卷积神经网络中如何处理图像的小区域（或“patches”），以便可以在这些区域上应用局部操作。PointNet++需要一种方法来有效地将点云分割成多个部分，这样可以在每个部分上独立地学习特征。\",\"通过局部特征学习器（Local Feature Learner）抽象点集或局部特征：\",\"一旦点云被划分成小的子集，PointNet++的下一个任务是学习这些子集（或局部区域）的特征。这需要一个“局部特征学习器”，它能够从每个子集中提取有用的信息或特征。这与在传统CNN中学习图像局部区域特征的过程相似。\",\"两个问题是相关联的，因为：\",\"点集的划分必须产生跨分区的共同结构：为了能够在不同的局部子集上共享权重（类似于在CNN中权重共享的概念），PointNet++在进行点集划分时，需要确保这些划分具有一定的一致性或共同结构。这意味着即使是不同的局部子集，也应该以一种方式被处理，使得在它们之间可以共享学习到的特征表示的权重。这样做的目的是提高模型的效率和泛化能力，因为学习到的特征和权重可以在多个局部区域中复用。\",\"上述即为PointNet++设计中的两个核心挑战：\",\"如何有效地对点云进行分区，以便可以在这些分区上独立地学习特征。\",\"如何设计一个能够从这些局部分区中学习有用特征的机制，同时确保这些分区的处理方式允许在它们之间共享模型权重。 \",\"为了模仿传统卷积网络中的权重共享机制以提高学习效率和模型的泛化能力。\",\"PointNet++选择PointNet作为局部特征学习器（它是无序点云数据特征提取的高效算法）。\",\"可以理解为：PointNet++应用PointNet递归地对输入集进行嵌套分区。\"]},\"87\":{\"h\":\"模型结构\",\"t\":[\"以二维欧几里得空间为例，网络的分割和分类模型\",\"网络的每一组set abstraction layers主要包括3个部分：\",\"Sample layer : 对输入点进行采样，在这些点中选出若干个中心点。\",\"Grouping layer : 利用上一步得到的中心点将点集划分成若干个区域。\",\"PointNet layer : 对上述得到的每个区域进行编码，变成特征向量。\"]},\"88\":{\"h\":\"层次化点集特征学习\",\"t\":[\"层次化结构由多个set abstraction layers组成，在每个层上，一组点云被处理和抽象，以产生一个更少元素的新集合。set abstraction layers 由 Sampling layer、Grouping layer 和 PointNet layer 三部分组成。\",\"Sampling layer ：采样层 从输入点中选取一组点，定义局部区域的形心。\",\"Grouping layer ：通过查找形心点周围的“邻近点”来构建局部区域点集。\",\"PointNet layer ：使用mini-PointNet将局部区域编码为特征向量。\"]},\"89\":{\"h\":\"Sampling layer\",\"t\":[\"使用farthest point sampling（FPS）选择𝑁个点（相比于随机采样，该方法能更好的覆盖整个点集，具体选择多少个中心点以及邻域内的数量由超参数确定）\",\"FPS是一种在点云、图像处理或其他数据集中用于抽样的算法。目的是从一个大的数据集中选出一组代表性强的点，这些点彼此之间的最小距离尽可能大。\",\"作者通过FPS来抽样点集中较为重要的点。（即任务是找到点云集中的局部区域的中心点）\",\"可能存在的问题：计算成本、样本分布偏差（可能导致样本在高密度区域内过度集中，低密度区域则过于稀缺）、参数依赖（依赖初始点和距离度量方式的选择）、可能无法捕捉重要的几何细节。\"]},\"90\":{\"h\":\"Grouping layer\",\"t\":[\"文中作者通过Ball query来查询形心的邻居点。\",\"具体做法：给定两个超参数（每个区域中点的数量𝐾和query的半径𝑟），对于某个形心，Ball query找到该查询点在半径为𝑟范围内点，该范围确保局部区域的尺度是固定的。\",\"与K最近邻（kNN）查询相比，Ball query通过固定区域尺度而不是固定邻居数量来定义邻域。kNN查询寻找最近的K个邻居，但这可能导致所选邻域的实际尺寸随点的密度变化而变化，这在处理非均匀采样的数据时可能不是最优的选择。相反，Ball query通过确保每个局部区域都有一个固定的尺度，提高了模型在空间上的泛化能力。在实现时，通常会设置一个上限K，以限制每个局部区域中考虑的点的数量，以保持计算的可管理性。\",\"可改进的地方：对点云密度变换较为敏感、对参数选择依赖性高（半径太小可能无法有效捕获足够的局部详细，太大则可能导致不相关的点增多，使局部特征的表示不够精确）、计算效率问题、均匀性假设（Ball query是基于欧氏距离的均匀性假设）\",\"欧式距离的均匀性假设：即在欧氏空间中，两点的距离反映了这两点的实际相似度或关联度。\",\"基于以下前提： \",\"空间均匀性：空间是均匀和各向同性的，即任何方向上的度量都是等价的，距离的度量不受空间中位置的影响。\",\"距离直观性：在屋里空间或某些特定的抽象空间中，两个点之间的直线距离被认为是相似度或连接强度的直观表示。\",\"规模一致性：假设空间中所有区域的尺度或特征分布具有一定的一致性，即空间中的任何距离值具有相似的含义。\",\"总结: Grouping layer的任务是通过中心点找到邻居点，并将它们组织称为局部区域集。\"]},\"91\":{\"h\":\"PointNet layer\",\"t\":[\"局部坐标系转换：局部区域中的点转换成相对于形心的局部坐标系。\",\"局部区域中的每个点将相对于形心所在位置进行调整，以反映其相对位置。\",\"实现方法：通过将局部区域中的每个点-形心点的坐标来实现。\",\"特征编码：将转换后的坐标以及点的附加特征（文中的𝐶所表示的其他信息）一起送入mini-PointNet来提取局部区域中的特征。\",\"输出：利用相对坐标与点特征相结合的方式可以捕获局部区域中点与点之间的关系。\"]},\"92\":{\"h\":\"代码实现\",\"t\":[\"sample_and_group 这个函数的作用是从输入点云中：\",\"采样一些关键点\",\"为每个关键点构建局部邻域（局部区域）\",\"提取这些局部区域中的点及其特征\",\"def sample_and_group(npoint, radius, nsample, xyz, points, returnfps=False): \\\"\\\"\\\" Input: npoint: 采样的关键点数量 radius: 构建局部邻域的半径 nsample: 每个邻域内采样的关键点数量 xyz: 点云坐标数据 , [B, N, 3] points: 点的特征数据（可选）, [B, N, D] Return: new_xyz: 采样得到的关键点坐标, [B, npoint, nsample, 3] new_points: 每个关键点对应的局部区域点和特征, [B, npoint, nsample, 3+D] \\\"\\\"\\\" B, N, C = xyz.shape S = npoint # 使用 最远点采样（FPS） 从原始点云中选出 npoint 个具有代表性的点。 fps_idx = farthest_point_sample(xyz, npoint) # [B, npoint] new_xyz = index_points(xyz, fps_idx) # [B, npoint, 3] # 对于每个选中的关键点，使用 球查询（Ball Query） 找出它周围距离小于 radius 的所有邻近点。 # 最多保留 nsample 个点，如果不够就重复最近的点来填充。 idx = query_ball_point(radius, nsample, xyz, new_xyz) # 把刚才找到的邻近点的坐标提取出来。 grouped_xyz = index_points(xyz, idx) # [B, npoint, nsample, 3] # 把它们相对于关键点的位置进行归一化（平移中心到以关键点为原点的局部坐标系上）。 grouped_xyz_norm = grouped_xyz - new_xyz.view(B, S, 1, C) # [B, npoint, nsample, 3] # 如果有额外的点特征（比如颜色、法线等），也一并提取。 if points is not None: grouped_points = index_points(points, idx) # 把邻近点的坐标和特征拼接在一起，形成最终的局部区域表示。 new_points = torch.cat([grouped_xyz_norm, grouped_points], dim=-1) # [B, npoint, nsample, C+D] else: new_points = grouped_xyz_norm if returnfps: return new_xyz, new_points, grouped_xyz, fps_idx else: return new_xyz, new_points\",\"farthest_point_sample 这个函数实现的是最远点采样（Farthest Point Sampling, FPS）, 这是 PointNet++ 中用于从点云中选择具有代表性的采样点的一种策略。它的核心思想是：在点云中逐步选择离已选点尽可能远的点，使得采样点在整个点云空间中分布尽可能均匀 。\",\"def farthest_point_sample(xyz, npoint): \\\"\\\"\\\" Input: xyz: pointcloud data, [B, N, 3] npoint: number of samples Return: centroids: sampled pointcloud index, [B, npoint] \\\"\\\"\\\" device = xyz.device B, N, C = xyz.shape centroids = torch.zeros(B, npoint, dtype=torch.long).to(device) # 存储每次选出的“最远点”的索引。 distance = torch.ones(B, N).to(device) * 1e10 # 每个点到当前所有已选中心点的最小距离，初始设为一个极大值（1e10）。 farthest = torch.randint(0, N, (B,), dtype=torch.long).to(device) # 初始时随机选择一个点作为第一个中心点。 batch_indices = torch.arange(B, dtype=torch.long).to(device) # 批次索引，用于快速访问每个 batch 的点。 # 重复 npoint 次，最终得到 npoint 个分布尽可能均匀的采样点索引。 for i in range(npoint): # 将当前选中的“最远点”索引保存下来； centroids[:, i] = farthest # （batch,npoint) # 取出当前最远点的坐标，用于后续计算其他点到该点的距离; centroid = xyz[batch_indices, farthest, :].view(B, 1, 3) # # （batch, 1 , 3) # 计算当前中心点与所有点之间的欧氏距离平方。 dist = torch.sum((xyz - centroid) ** 2, -1) # （batch,npoint) # 如果某个点到新中心点的距离比之前记录的“最小距离”还小，就更新它。 mask = dist < distance # 在 distance 中找到最大的那个距离对应的点，这就是下一个“最远点”。 distance[mask] = dist[mask] # （batch,npoint) # 在 distance 中找到最大的那个距离对应的点，这就是下一个“最远点”。 # 返回：一个元组：(values, indices)，分别是最大值和它们的位置索引。 farthest = torch.max(distance, -1)[1] # 返回位置索引 return centroids\",\"index_points 这个函数实现的是根据给定的索引 idx，从输入点云 points 中提取对应的点，形成一个新的子集。\",\"def index_points(points, idx): \\\"\\\"\\\" Input: points: input points data, [B, N, C] idx: sample index data, [B, S] Return: new_points:, indexed points data, [B, S, C] \\\"\\\"\\\" device = points.device B = points.shape[0] view_shape = list(idx.shape) view_shape[1:] = [1] * (len(view_shape) - 1) # 将view_shape的形状从[B, S]变成[B, 1]，便于广播 repeat_shape = list(idx.shape) repeat_shape[0] = 1 # 从[B, S]变成[1, S] # 从点云中根据索引提取特定点 (看不懂下面两行代码的话，可以先去了解一下python中的高级索引机制)。 batch_indices = torch.arange(B, dtype=torch.long).to(device).view(view_shape).repeat(repeat_shape) new_points = points[batch_indices, idx, :] # （batch,npoint,3) return new_points\",\"query_ball_point 这个函数的作用是从点云中找出每个查询点周围一定半径范围内的邻近点索引。这个操作被称为 球查询（Ball Query）。\",\"def query_ball_point(radius, nsample, xyz, new_xyz): \\\"\\\"\\\" Input: radius: local region radius nsample: max sample number in local region xyz: all points, [B, N, 3] new_xyz: query points, [B, S, 3] Return: group_idx: grouped points index, [B, S, nsample] \\\"\\\"\\\" device = xyz.device B, N, C = xyz.shape _, S, _ = new_xyz.shape # 查询点数量（比如通过 FPS 得到的质心） # 构造一个从 0 到 N-1 的索引数组，代表原始点云中每个点的“身份证号” # 然后复制这个索引数组到每个 batch 和每个查询点上，形成 [B, S, N] 的结构 group_idx = torch.arange(N, dtype=torch.long).to(device).view(1, 1, N).repeat([B, S, 1]) # 计算每个查询点（new_xyz）与原始点（xyz）之间的平方欧氏距离 # 输出形状为 [B, S, N]：每个查询点对所有原始点的距离 sqrdists = square_distance(new_xyz, xyz) # 把距离超过 radius^2 的点全部替换为 N（一个非法索引），表示“这些人离我太远了，我不感兴趣。” group_idx[sqrdists > radius ** 2] = N # 对每个查询点的邻近点按索引排序（因为前面有 N，所以小的才是有效点） # 然后只保留前 nsample 个点 group_idx = group_idx.sort(dim=-1)[0][:, :, :nsample] # 如果某个查询点附近的点太少，有些位置被标记为 N（无效）。 # 我们就用该查询点最近的那个点（第一个点）去填充这些空缺。 group_first = group_idx[:, :, 0].view(B, S, 1).repeat([1, 1, nsample]) mask = group_idx == N group_idx[mask] = group_first[mask] return group_idx # （batch,npoint,nsample)\",\"sample_and_group流程图\",\"sample_and_group_all 函数的作用是将整个点云视为一个“大局部区域”，不进行采样，直接对所有点进行特征提取，用于 PointNet++ 中的全局特征学习。\",\"def sample_and_group_all(xyz, points): \\\"\\\"\\\" Input: xyz: input points position data, [B, N, 3], 点云坐标数据 points: input points data, [B, N, D], 点云的额外特征（如法线、颜色等） Return: new_xyz: sampled points position data, [B, 1, 3] new_points: sampled points data, [B, 1, N, 3+D] \\\"\\\"\\\" device = xyz.device B, N, C = xyz.shape # 创建一个全零点作为“质心” # 虽然这个点没有实际意义，但它是为了统一接口设计的一个占位符 new_xyz = torch.zeros(B, 1, C).to(device) # 把原始点云 reshape 成一个大的局部区域 grouped_xyz = xyz.view(B, 1, N, C) # 如果有额外特征（比如法线、颜色），也一并加入 if points is not None: # 终输出的 new_points 是 [B, 1, N, 3+D]，代表每个 batch 中只有一组“大区域”的点及其特征 new_points = torch.cat([grouped_xyz, points.view(B, 1, N, -1)], dim=-1) else: new_points = grouped_xyz return new_xyz, new_points # 全局质心点（0 位置）, 所有点组成的局部区域\",\"sample_and_group_all流程图\",\"PointNetSetAbstraction（点集抽象层） 是 PointNet++ 中的核心模块 ， 它的作用是负责从输入的点云数据中采样关键点，构建它们的局部邻域区域，并通过一个小型 PointNet 提取这些区域的高维特征，从而实现点云的分层特征学习。\",\"class PointNetSetAbstraction(nn.Module): def __init__(self, npoint, radius, nsample, in_channel, mlp, group_all): super(PointNetSetAbstraction, self).__init__() self.npoint = npoint # 采样的关键点数量 self.radius = radius # 构建局部邻域的半径 self.nsample = nsample # 每个邻域内采样的关键点数量 self.mlp_convs = nn.ModuleList() self.mlp_bns = nn.ModuleList() last_channel = in_channel # 输入点的特征维度 for out_channel in mlp: self.mlp_convs.append(nn.Conv2d(last_channel, out_channel, 1)) self.mlp_bns.append(nn.BatchNorm2d(out_channel)) last_channel = out_channel self.group_all = group_all def forward(self, xyz, points): \\\"\\\"\\\" Input: xyz: input points position data, [B, C, N] points: input points data, [B, D, N] Return: new_xyz: sampled points position data, [B, C, S] new_points_concat: sample points feature data, [B, D', S] \\\"\\\"\\\" xyz = xyz.permute(0, 2, 1) # [B, N, C] if points is not None: points = points.permute(0, 2, 1) # 如果 group_all=True，则对整个点云做全局特征提取。 if self.group_all: new_xyz, new_points = sample_and_group_all(xyz, points) else: # 否则使用 FPS（最远点采样）选关键点，再用 Ball Query 找出每个点的局部邻近点。 # 参数: 质点数量，采样半径，采样点数量，点坐标，点额外特征 new_xyz, new_points = sample_and_group(self.npoint, self.radius, self.nsample, xyz, points) # 局部特征编码（Mini-PointNet） # new_xyz: sampled points position data, [B, npoint, C] # new_points: sampled points data, [B, npoint, nsample, C+D] # 把邻域点的数据整理成适合卷积的格式 [B, C+D, nsample, npoint] new_points = new_points.permute(0, 3, 2, 1) # 使用多个 Conv2d + BatchNorm + ReLU 层提取特征 for i, conv in enumerate(self.mlp_convs): bn = self.mlp_bns[i] new_points = F.relu(bn(conv(new_points))) # [B, out_channel , nsample, npoint] # 对每个局部区域内所有点的最大响应值进行池化，得到该区域的固定长度特征表示。 # 在 new_points 的第 2 个维度（即每个局部邻域内的点数量维度）上做最大池化（max pooling）。 # 输出形状为 [B, out_channel, npoint]，即每个查询点有一个特征向量。 new_points = torch.max(new_points, 2)[0] # [B, out_channel, npoint] new_xyz = new_xyz.permute(0, 2, 1) # [B, C, npoint] return new_xyz, new_points # 查询点的位置(质心) ， 每个查询点点局部特征。\",\"最终每个采样得到的关键点所在的局部领域，都会被压缩为一个固定长度的特征向量。这个特征向量代表了这个局部区域的高维特征，它包含了这个区域内所有点的信息。\"]},\"93\":{\"h\":\"单尺度分组分类模型\",\"t\":[\"PointNet++ 的 单尺度分组（SSG）架构 ，通过多层 Set Abstraction 提取点云的层次化特征，并最终输出分类结果。\",\"Single-Scale Grouping (SSG)\",\"代码实现如下:\",\"# pointnet2_cls_ssg.py class get_model(nn.Module): # num_class: 输出类别数 # normal_channel: 是否包含法线信息（默认有 (x,y,z,nx,ny,nz)，否则只有 (x,y,z)） def __init__(self,num_class,normal_channel=True): super(get_model, self).__init__() in_channel = 6 if normal_channel else 3 self.normal_channel = normal_channel # PointNet++ 的核心就是逐层提取局部特征。这里的三个 SA 层构成了一个 三层分层特征学习结构 ： self.sa1 = PointNetSetAbstraction(npoint=512, radius=0.2, nsample=32, in_channel=in_channel, mlp=[64, 64, 128], group_all=False) self.sa2 = PointNetSetAbstraction(npoint=128, radius=0.4, nsample=64, in_channel=128 + 3, mlp=[128, 128, 256], group_all=False) self.sa3 = PointNetSetAbstraction(npoint=None, radius=None, nsample=None, in_channel=256 + 3, mlp=[256, 512, 1024], group_all=True) self.fc1 = nn.Linear(1024, 512) self.bn1 = nn.BatchNorm1d(512) self.drop1 = nn.Dropout(0.4) self.fc2 = nn.Linear(512, 256) self.bn2 = nn.BatchNorm1d(256) self.drop2 = nn.Dropout(0.4) self.fc3 = nn.Linear(256, num_class) def forward(self, xyz): B, _, _ = xyz.shape if self.normal_channel: norm = xyz[:, 3:, :] xyz = xyz[:, :3, :] else: norm = None l1_xyz, l1_points = self.sa1(xyz, norm) l2_xyz, l2_points = self.sa2(l1_xyz, l1_points) l3_xyz, l3_points = self.sa3(l2_xyz, l2_points) x = l3_points.view(B, 1024) x = self.drop1(F.relu(self.bn1(self.fc1(x)))) x = self.drop2(F.relu(self.bn2(self.fc2(x)))) x = self.fc3(x) x = F.log_softmax(x, -1) return x, l3_points\",\"完整的单尺度分组分类流程为:\",\"原始点云数据，首次sample，grouping，mini-PointNet后，得到:\",\"512 个关键点的坐标\",\"512 个关键点对应的局部区域特征向量\",\"二次sample，grouping，mini-PointNet后，得到:\",\"128 个关键点的坐标\",\"128 个关键点对应的局部区域特征向量\",\"三次sample，grouping，mini-PointNet后，得到:\",\"1 个关键点的坐标\",\"1 个关键点对应的全局区域特征向量\",\"获取全局区域特征向量后，通过全连接层进行分类。\"]},\"94\":{\"h\":\"非均匀密度下稳定的特征学习\",\"t\":[\"由于点集在不同区域可能会有不同的采样密度，这种非均匀性为点集特征学习带来了显著挑战。在密集采样的区域中学到的特征可能无法很好地泛化到稀疏采样的区域，反之亦然。因此，为了解决这一问题，PointNet++提出了密度自适应PointNet层，包含两种适应性特征学习层：多尺度分组（Multi-Scale Grouping, MSG）和多分辨率分组（Multi-Resolution Grouping, MRG）。\"]},\"95\":{\"h\":\"多尺度分组 （Multi-Scale Grouping）\",\"t\":[\"MSG通过应用不同尺度的分组层（按照不同的搜索半径或领域大小对点集进行分组），然后通过对应的PointNets提取每个尺度上的特征来捕获多尺度模式。不同尺度的特征被串联形成多尺度特征向量。这种方法使网络能够通过在训练期间随机丢弃输入点（称为随机输入丢弃 - random input dropout）来学习优化的策略，以结合来自不同尺度的特征。这样，网络在训练时被呈现了不同稀疏度的点集，从而学会根据输入数据的变化自适应地加权不同尺度上检测到的模式。\",\"多尺度分组\",\"具体来说，在MSG中，网络对于每个选定的形心点，按照几个预定义的半径值来搜索周围的邻近点。每个半径定义了一个局部邻域的大小，因此每个质心将根据这些不同的半径值与其周围点形成多个点集群。这样，对于每个质心点，网络不是只捕获一个尺度上的局部特征，而是能够捕获多个尺度上的局部特征。\",\"每个尺度（或每组邻域大小）的点集群都将独立地送入对应的PointNet网络进行特征提取，之后这些不同尺度上提取的特征被串联起来，形成一个综合的多尺度特征表示。这种方法使得网络能够在细节丰富的区域（通过较小的邻域尺度捕获细节）和稀疏采样的区域（通过较大的邻域尺度避免过度稀疏的问题）中均能有效提取特征。\"]},\"96\":{\"h\":\"多尺度分组分类模型\",\"t\":[\"PointNetSetAbstractionMsg 这个模块实现了 PointNet++ 中的 多尺度特征提取机制 ：对于每个局部区域，使用多个不同大小的邻域球（multi-scale ball query），分别提取特征，然后将这些不同尺度的特征拼接在一起，以获得更强的局部几何感知能力。\",\"class PointNetSetAbstractionMsg(nn.Module): def __init__(self, npoint, radius_list, nsample_list, in_channel, mlp_list): super(PointNetSetAbstractionMsg, self).__init__() self.npoint = npoint # 要采样的质心点数量 self.radius_list = radius_list # 不同尺度的查询半径列表 self.nsample_list = nsample_list # 对应半径下最多取多少邻近点 self.conv_blocks = nn.ModuleList() self.bn_blocks = nn.ModuleList() # 为每个尺度构建一个独立的小型 PointNet（Conv2d + BN + ReLU） # 每个尺度可以有不同的网络深度和宽度 # 所有尺度的网络并行运行，最后拼接结果 for i in range(len(mlp_list)): convs = nn.ModuleList() bns = nn.ModuleList() last_channel = in_channel + 3 for out_channel in mlp_list[i]: convs.append(nn.Conv2d(last_channel, out_channel, 1)) bns.append(nn.BatchNorm2d(out_channel)) last_channel = out_channel self.conv_blocks.append(convs) self.bn_blocks.append(bns) def forward(self, xyz, points): \\\"\\\"\\\" Input: xyz: input points position data, [B, C, N] points: input points data, [B, D, N] Return: new_xyz: sampled points position data, [B, C, S] new_points_concat: sample points feature data, [B, D', S] \\\"\\\"\\\" xyz = xyz.permute(0, 2, 1) # [B, N, C] if points is not None: points = points.permute(0, 2, 1) B, N, C = xyz.shape S = self.npoint # 使用 FPS（最远点采样）选出 S 个关键点作为局部区域中心 new_xyz = index_points(xyz, farthest_point_sample(xyz, S)) new_points_list = [] for i, radius in enumerate(self.radius_list): K = self.nsample_list[i] # 对每个半径 radius，找出该尺度下每个质心点周围的邻近点 group_idx = query_ball_point(radius, K, xyz, new_xyz) grouped_xyz = index_points(xyz, group_idx) # 把这些点的坐标归一化到以质心为中心的局部坐标系下 grouped_xyz -= new_xyz.view(B, S, 1, C) # 如果有额外特征，也一并加入 if points is not None: grouped_points = index_points(points, group_idx) grouped_points = torch.cat([grouped_points, grouped_xyz], dim=-1) else: grouped_points = grouped_xyz # 对每个尺度的局部点集应用对应的 Conv2d + BN + ReLU grouped_points = grouped_points.permute(0, 3, 2, 1) # [B, D, K, S] for j in range(len(self.conv_blocks[i])): conv = self.conv_blocks[i][j] bn = self.bn_blocks[i][j] grouped_points = F.relu(bn(conv(grouped_points))) # 使用最大池化聚合局部信息，生成固定长度的特征向量 new_points = torch.max(grouped_points, 2)[0] # [B, D', S] # 所有尺度的特征保存到 new_points_list new_points_list.append(new_points) new_xyz = new_xyz.permute(0, 2, 1) # 把不同尺度学到的特征拼接在一起，形成最终的局部特征表示 new_points_concat = torch.cat(new_points_list, dim=1) # 最终输出就是： 一组新的关键点位置； 每个关键点的多尺度特征表示 return new_xyz, new_points_concat\",\"pointnet2_cls_msg 这个模型使用了 PointNet++ 的 多尺度分组（MSG）策略 ，通过多个局部区域球查询提取不同尺度的局部特征，逐层抽象后融合成全局特征，最后通过全连接层完成分类任务。\",\"# pointnet2_cls_msg.py class get_model(nn.Module): def __init__(self,num_class,normal_channel=True): super(get_model, self).__init__() in_channel = 3 if normal_channel else 0 self.normal_channel = normal_channel self.sa1 = PointNetSetAbstractionMsg(512, [0.1, 0.2, 0.4], [16, 32, 128], in_channel,[[32, 32, 64], [64, 64, 128], [64, 96, 128]]) self.sa2 = PointNetSetAbstractionMsg(128, [0.2, 0.4, 0.8], [32, 64, 128], 320,[[64, 64, 128], [128, 128, 256], [128, 128, 256]]) self.sa3 = PointNetSetAbstraction(None, None, None, 640 + 3, [256, 512, 1024], True) self.fc1 = nn.Linear(1024, 512) self.bn1 = nn.BatchNorm1d(512) self.drop1 = nn.Dropout(0.4) self.fc2 = nn.Linear(512, 256) self.bn2 = nn.BatchNorm1d(256) self.drop2 = nn.Dropout(0.5) self.fc3 = nn.Linear(256, num_class) def forward(self, xyz): B, _, _ = xyz.shape if self.normal_channel: norm = xyz[:, 3:, :] xyz = xyz[:, :3, :] else: norm = None l1_xyz, l1_points = self.sa1(xyz, norm) l2_xyz, l2_points = self.sa2(l1_xyz, l1_points) l3_xyz, l3_points = self.sa3(l2_xyz, l2_points) x = l3_points.view(B, 1024) x = self.drop1(F.relu(self.bn1(self.fc1(x)))) x = self.drop2(F.relu(self.bn2(self.fc2(x)))) x = self.fc3(x) x = F.log_softmax(x, -1) return x,l3_points\",\"MSG的关键优点在于它通过在训练期间的随机输入丢弃（即随机移除一部分输入点）来模拟不同的采样密度，从而训练网络在面对实际应用中可能遇到的各种采样密度时，能够自适应地选择最适合的特征尺度进行组合，以实现最佳的性能。这种方法大大增强了网络处理非均匀采样数据的能力，提高了模型的泛化性和稳健性。\",\"在训练时引入不同密度的点集情况，使网络能学习不同采样密度下局部点云特征的提取，捕获密集到稀疏采样区域内的多尺度信息 -- 通过随机丢弃来模拟不同密度的采样，使网络能够应对实际中各种密度变换的情况-提高模型的泛化性能。\",\"MSG相当于并联了多个hierarchical structure，每个结构中心点不变，但是尺度不同。通过PointNet获取每个形心多尺度信息，之后concat形成该区域提取的总特征。在训练时引入随机丢弃形心来模拟不同密度情况，提高算法鲁棒性。\"]},\"97\":{\"h\":\"多分辨率分组（Multi-Resolution Grouping）\",\"t\":[\"MSG方法虽然有效，但在计算上可能非常昂贵，尤其是在低层次上对每个质心点运行局部PointNet时。为此，MRG为一种低成本的替代方案。\",\"MRG通过结合来自不同分辨率的特征来实现效率和适应性的平衡。具体而言，MRG策略在处理每个局部区域时，不仅考虑从当前分辨率下抽象得到的特征，还考虑了从更低分辨率（即上一层级）直接提取的特征。这两种特征被concat为一个复合特征向量，为后续的处理步骤提供信息。\",\"多分辨率分组\",\"在MRG中，某一层次𝐿𝑖的区域特征是通过将来自下一级𝐿𝑖−1的子区域特征总结后的向量与直接处理该局部区域所有原始点的单个PointNet得到的特征向量进行concat得到的。当局部区域的密度较低时，由于子区域在计算第一个向量时包含的点更稀疏，因此可能比第二个向量更不可靠。在这种情况下，应该更高地加权第二个向量。相反，当局部区域的密度较高时，第一个向量提供了更细致的信息，因为它能够在更低层次上递归地检视更高分辨率。\",\"来自下一级的特征：首先，将来自下一级（更高分辨率）的特征进行汇总，形成一个特征向量。这一过程通过对每个子区域应用集合抽象层（set abstraction level）完成。\",\"直接处理的原始点特征：另一部分特征是通过在当前分辨率直接对所有原始点应用单个PointNet得到的。\"]},\"98\":{\"h\":\"点云语义分割\",\"t\":[\"PointNet++ 完成点云分割任务的过程是一个典型的“编码-解码”结构，结合了层级特征提取和多尺度融合机制。\",\"目标: 给定一个点云，模型需要为每个点预测一个类别标签（如桌子、椅子、墙壁等）。\",\"输入：xyz: [B, N, 3]\",\"输出：labels: [B, N, C]，其中 C 是类别数\",\"PointNet++ 分割的整体结构 :\",\"Input Points (xyz): [ B, N, 3 ] ↓ Set Abstraction Layers（编码器） ↓ Feature Vectors at Multiple Scales ↓ Feature Propagation Layers（解码器） ↓ Recovered Features at Original Resolution ↓ MLP + Softmax → Per-point Semantic Labels\",\"第一步：Set Abstraction（集合抽象）—— 编码器: 对点云进行下采样，并在每个局部区域提取特征。\",\"核心操作包括：\",\"FPS（Farthest Point Sampling）：从点云中选出有代表性的点作为中心点。\",\"Ball Query：为每个中心点找到其邻域内的点。\",\"Grouping：将邻域点组合成局部点云组。\",\"PointNet 操作：使用 T-Net 对局部点云进行变换，然后通过 MLP 提取特征。\",\"Pooling：对局部点云组做最大池化或平均池化，得到该区域的特征。\",\"多个 Set Abstraction 层堆叠，逐步减少点的数量，增加特征维度，形成多尺度特征表示。\",\"第二步：Feature Propagation（特征传播）—— 解码器: 从最稀疏的点开始，逐层将特征插值回原始点数量。\",\"特征插值方式：\",\"使用 反距离加权插值（IDW），即根据最近的几个邻近点的距离进行加权平均。\",\"可选地拼接 skip connection 中的原始特征（来自 Set Abstraction 前的某一层）。\",\"输入输出示例：\",\"def forward(xyz1, xyz2, points1, points2): # xyz1: 原始点坐标（多） # xyz2: 下采样点坐标（少） # points1: 原始点特征（可为空） # points2: 下采样点特征 return interpolated_points # 插值得到的密集特征，形状与 xyz1 一致\",\"多个 Feature Propagation 层堆叠，逐渐恢复点数，最终回到原始点数量。\",\"第三步：Head 预测头 —— 分类每个点: 对每个点的特征做一个简单的分类器，输出类别概率。\",\"实现方式：\",\"将最后一层 Feature Propagation 输出的特征送入一个小型 MLP。\",\"最后一层使用 Softmax（对于多分类）或 Sigmoid（对于多标签）激活函数。\",\"例如：\",\"mlp = nn.Sequential( nn.Conv1d(128, 128, 1), nn.BatchNorm1d(128), nn.ReLU(), nn.Dropout(0.5), nn.Conv1d(128, num_classes, 1) ) logits = mlp(final_features) # shape: [B, C, N]\"]},\"99\":{\"h\":\"代码实现\",\"t\":[\"PointNet++ 的整体结构是一个典型的 编码器-解码器（Encoder-Decoder）架构 ：\",\"Set Abstraction 层 ：不断对点云进行下采样 + 提取局部特征（编码过程）\",\"Feature Propagation 层 ：从最稀疏的点开始，逐层恢复到原始点数（解码过程）\",\"[Input Points] ↓ SA Layer 1 → [Points: 1024 → 512] ↓ SA Layer 2 → [Points: 512 → 128] ↓ SA Layer 3 → [Points: 128 → 32] ↓ FP Layer 3 ← [Points: 32 → 128] ↓ FP Layer 2 ← [Points: 128 → 512] ↓ FP Layer 1 ← [Points: 512 → 1024] ↓ [Per-point Classification Head] ↓ [Output: per-point labels]\"]},\"100\":{\"h\":\"特征传播层\",\"t\":[\"PointNetFeaturePropagation 是 PointNet++ 中用于点云“特征传播”（Feature Propagation）的核心模块，主要作用是：\",\"将稀疏点集的特征插值回原始点集的位置上。\",\"换句话说：\",\"输入：少量点的坐标 + 特征（如经过下采样后的点）\",\"输出：在原始点数量下的每个点都拥有一个合理的特征向量\",\"这一步相当于图像任务中的 上采样（upsample）或转置卷积（transpose convolution） ，但在点云这种非结构化数据中，不能直接使用这些操作。\",\"class PointNetFeaturePropagation(nn.Module): def __init__(self, in_channel, mlp): \\\"\\\"\\\" 初始化函数，构建用于特征传播（上采样）的MLP层 参数： in_channel: 输入特征的通道数（维度） mlp: 一个列表，表示每一层MLP的输出通道数，例如 [64, 128] \\\"\\\"\\\" super(PointNetFeaturePropagation, self).__init__() # 用于保存卷积层和批归一化层 self.mlp_convs = nn.ModuleList() self.mlp_bns = nn.ModuleList() last_channel = in_channel # 当前输入通道数初始化为in_channel # 构建MLP层：每个层是一个Conv1d + BatchNorm1d + ReLU for out_channel in mlp: self.mlp_convs.append(nn.Conv1d(last_channel, out_channel, 1)) self.mlp_bns.append(nn.BatchNorm1d(out_channel)) last_channel = out_channel # 更新下一层的输入通道数 def forward(self, xyz1, xyz2, points1, points2): \\\"\\\"\\\" 前向传播函数：将稀疏点集points2插值到密集点集xyz1的位置上 参数： xyz1: 原始点坐标数据，形状 [B, C, N] （如 1024 个点） xyz2: 下采样后的点坐标数据，形状 [B, C, S] （如 256 个点） points1: 原始点对应的特征数据，形状 [B, D, N] （可为 None） points2: 下采样点对应的特征数据，形状 [B, D, S] 返回： new_points: 插值并融合后的特征，形状 [B, D', N] \\\"\\\"\\\" # 将坐标和特征从 [B, C, N] 转换为 [B, N, C] 格式，便于后续计算 xyz1 = xyz1.permute(0, 2, 1) # [B, N, C] xyz2 = xyz2.permute(0, 2, 1) # [B, S, C] points2 = points2.permute(0, 2, 1) # [B, S, D] B, N, C = xyz1.shape # 原始点数量 N _, S, _ = xyz2.shape # 下采样点数量 S # 如果只有1个下采样点，直接复制其特征到所有原始点 if S == 1: interpolated_points = points2.repeat(1, N, 1) # [B, N, D] else: # 计算原始点与下采样点之间的距离矩阵（欧氏距离平方） dists = square_distance(xyz1, xyz2) # [B, N, S] # 对每个原始点，找到最近的3个邻近点 dists, idx = dists.sort(dim=-1) dists = dists[:, :, :3] # 取最小的三个距离 [B, N, 3] idx = idx[:, :, :3] # 取对应的索引 [B, N, 3] # 使用反距离加权（IDW）计算权重: # 1.将距离转换为“权重”，距离越近，权重越大 dist_recip = 1.0 / (dists + 1e-8) # 避免除以零 # 2.对每个点的3个权重求和，得到归一化因子 norm = torch.sum(dist_recip, dim=2, keepdim=True) # 归一化因子 # 3.归一化权重，使得每个点的权重之和为1 weight = dist_recip / norm # 加权平均系数 [B, N, 3] # 为每个原始点，找到它最近的 3 个邻近点，根据距离分配权重，然后对它们的特征做加权平均，从而插值得到该点的特征。 # index_points: [B, S, D] -> [B, N, 3, D] # weight.view(B, N, 3, 1): 扩展维度后相乘 interpolated_points = torch.sum( # 1. 从下采样点中取出每个原始点对应的最近邻点的特征。 # points2: [B, S, D] —— 下采样点的特征（S 个点，每个点有 D 维特征） # idx: [B, N, 3] —— 每个原始点对应的 3 个最近邻点索引 # [B, N, 3, D] —— 每个原始点都有了它最近的 3 个邻近点的特征 index_points(points2, idx) # 将之前计算好的权重扩展维度，以便和特征相乘。 # weight: [B, N, 3] —— 每个点的三个邻近点的权重 # [B, N, 3, 1] —— 扩展后便于广播乘法 * weight.view(B, N, 3, 1), dim=2 ) # [B, N, D] # 如果原始点有特征，则拼接起来（skip connection） if points1 is not None: points1 = points1.permute(0, 2, 1) # [B, N, D] new_points = torch.cat([points1, interpolated_points], dim=-1) # [B, N, D1+D2] else: new_points = interpolated_points # [B, N, D] # 恢复张量格式为 [B, D, N]，以适配后面的卷积操作 new_points = new_points.permute(0, 2, 1) # [B, D', N] # 经过MLP进一步提取和融合特征 for i, conv in enumerate(self.mlp_convs): bn = self.mlp_bns[i] new_points = F.relu(bn(conv(new_points))) # Conv1d + BN + ReLU return new_points # 最终输出特征 [B, D', N]\",\"流程四步走：\",\"1️⃣ 找到邻居 “我这个点最近的3个熟人是谁？”\",\"计算每个原始点和下采样点之间的距离；\",\"找出最近的3个邻近点。\",\"2️⃣ 分配权重 “谁离我越近，说话越有分量。”\",\"根据距离反比加权（IDW），给这3个邻近点分配权重；\",\"权重归一化，确保它们加起来是1。\",\"3️⃣ 加权平均插值 “综合最近几个熟人的意见，猜出我的特征。”\",\"提取邻近点的特征；\",\"按照权重做加权平均；\",\"得到每个原始点的插值特征。\",\"4️⃣ 融合+增强 “如果我本来就有特征，那就一起用；再用MLP提提神。”\",\"如果原始点有自己的特征（points1），就拼接起来；\",\"经过几层 Conv1d + BN + ReLU，进一步提取和融合特征；\",\"输出最终的插值后特征。\",\"📦 输出结果\",\"new_points: 每个原始点都有了一个新的特征向量 [B, D', N]\"]},\"101\":{\"h\":\"点云语义分割模型\",\"t\":[\"下面给出的是一个基于PointNet++的点云语义分割模型定义 ，其主要功能是：\",\"对输入点云中的每个点进行分类（如桌子、椅子、地板等），输出每个点的类别概率。\",\"网络结构特点：\",\"使用 Set Abstraction（SA）层 进行多尺度特征提取和下采样；\",\"使用 Feature Propagation（FP）层 进行特征插值和上采样；\",\"最后通过两个卷积层输出每个点的分类结果；\",\"输出为 [B, N, num_classes]，即每个点都有一个类别预测。\",\"class get_model(nn.Module): def __init__(self, num_classes): \\\"\\\"\\\" 初始化 PointNet++ 分割网络 参数： num_classes: 分类类别数 \\\"\\\"\\\" super(get_model, self).__init__() # Set Abstraction 层（编码器部分） # 每层逐步下采样，并提取更高级别的局部特征 self.sa1 = PointNetSetAbstraction(npoint=1024, radius=0.1, nsample=32, in_channel=9+3, mlp=[32, 32, 64], group_all=False) self.sa2 = PointNetSetAbstraction(npoint=256, radius=0.2, nsample=32, in_channel=64+3, mlp=[64, 64, 128], group_all=False) self.sa3 = PointNetSetAbstraction(npoint=64, radius=0.4, nsample=32, in_channel=128+3, mlp=[128, 128, 256], group_all=False) self.sa4 = PointNetSetAbstraction(npoint=16, radius=0.8, nsample=32, in_channel=256+3, mlp=[256, 256, 512], group_all=False) # Feature Propagation 层（解码器部分） # 从稀疏点恢复到原始点密度，逐层融合上下文信息 self.fp4 = PointNetFeaturePropagation(in_channel=768, mlp=[256, 256]) self.fp3 = PointNetFeaturePropagation(in_channel=384, mlp=[256, 256]) self.fp2 = PointNetFeaturePropagation(in_channel=320, mlp=[256, 128]) self.fp1 = PointNetFeaturePropagation(in_channel=128, mlp=[128, 128, 128]) # 最终分类头 self.conv1 = nn.Conv1d(128, 128, 1) self.bn1 = nn.BatchNorm1d(128) self.drop1 = nn.Dropout(0.5) self.conv2 = nn.Conv1d(128, num_classes, 1) def forward(self, xyz): \\\"\\\"\\\" 前向传播函数 输入： xyz: 点云数据，形状 [B, C, N] 返回： x: 每个点的分类结果，形状 [B, N, num_classes] l4_points: 最后一层抽象特征，用于其他任务 \\\"\\\"\\\" # l0 表示最原始的点云 l0_points = xyz l0_xyz = xyz[:, :3, :] # 只取 xyz 坐标，不带法向量或其他属性 # 编码器：层层下采样并提取特征 l1_xyz, l1_points = self.sa1(l0_xyz, l0_points) # 1024 points l2_xyz, l2_points = self.sa2(l1_xyz, l1_points) # 256 points l3_xyz, l3_points = self.sa3(l2_xyz, l2_points) # 64 points l4_xyz, l4_points = self.sa4(l3_xyz, l3_points) # 16 points # 解码器：层层插值并融合特征 l3_points = self.fp4(l3_xyz, l4_xyz, l3_points, l4_points) # 64 → 64 l2_points = self.fp3(l2_xyz, l3_xyz, l2_points, l3_points) # 256 → 256 l1_points = self.fp2(l1_xyz, l2_xyz, l1_points, l2_points) # 1024 → 1024 l0_points = self.fp1(l0_xyz, l1_xyz, None, l1_points) # 4096 → 4096 # MLP 头部处理：进一步增强特征 x = self.drop1(F.relu(self.bn1(self.conv1(l0_points)), inplace=True)) # [B, 128, N] x = self.conv2(x) # [B, num_classes, N] # Softmax 分类 x = F.log_softmax(x, dim=1) # [B, num_classes, N] # 调整维度，返回 [B, N, num_classes] x = x.permute(0, 2, 1) return x, l4_points # 返回每个点的分类结果和抽象特征\"]},\"102\":{\"h\":\"简析PointNet\",\"t\":[\"简析PointNet网络模型及其背后原理\",\"论文: https://arxiv.org/abs/1612.00593 TensorFlow 版本代码: https://github.com/charlesq34/pointnet Pytorch 版本代码: https://github.com/fxia22/pointnet.pytorch\"]},\"103\":{\"h\":\"核心\",\"t\":[\"问题背景: 点云是三维几何数据的一种重要表示形式，但由于其无序性和非规则性，传统卷积神经网络难以直接处理。\",\"❌ 传统方法的缺陷 ：\",\"将点云转换为体素网格（voxel grid）或图像视图（multi-view rendering）， 这些方法会导致信息损失、计算量大、不灵活等问题。\",\"🌟 PointNet 的创新点 ：\",\"直接以点集作为输入，避免了复杂的预处理；\",\"设计了一个统一架构，适用于分类、物体分割和场景语义解析；\",\"利用对称函数（如最大池化）实现点集顺序不变性；\",\"引入 T-Net（空间变换网络）标准化输入点云和特征空间。\"]},\"104\":{\"h\":\"难点\",\"t\":[\"点云的无序性（Unordered）: 点云是点的集合，没有固定顺序；模型必须对输入点的排列顺序不敏感（permutation invariant）。\",\"点之间存在相互作用（Interaction among points）: 点与点之间有空间关系，需要捕捉局部结构。\",\"对几何变换的不变性（Invariance under transformations）: 模型输出应不受刚性变换影响（如旋转、平移）。\",\"输入点云可能缺失或包含噪声（Missing or noisy points）: 实际采集的点云常有遮挡、稀疏、异常值等问题。\"]},\"105\":{\"h\":\"解决方案\",\"t\":[\"✅ 难点 1：点云的无序性 → 使用对称函数（Symmetric Function）\",\"使用 max pooling 作为对称函数，聚合所有点的信息；\",\"所有点经过共享参数的 MLP 提取特征；\",\"最终输出与点的顺序无关；\",\"原理说明：\",\"f({x1, ..., xn}) ≈ g(h(x1), ..., h(xn)) = γ(MAX(h(x1), ..., h(xn)))\",\"其中：\",\"h(xi) 是每个点的高维特征；\",\"MAX 是 max pooling 函数；\",\"γ 是后续的全连接网络；\",\"整个函数 f 是对称的，即对点顺序不敏感。\",\"效果：\",\"实验证明 max pooling 比排序、RNN、average pooling 更有效；s\",\"PointNet 可以处理任意顺序的点集；\",\"✅ 难点 2：点之间的相互作用 → 设计局部 + 全局信息融合机制\",\"在分割任务中，将全局特征与每个点的局部特征拼接起来；\",\"这样每个点在预测标签时都能看到整个物体的上下文；\",\"效果：\",\"显著提升了分割性能；\",\"让模型既关注局部细节，又理解整体结构；\",\"✅ 难点 3：对几何变换的不变性 → 引入 T-Net（空间变换网络）\",\"引入两个空间变换网络： \",\"STN3d：对输入点云做刚性变换（3×3 矩阵）；\",\"STNkd：对特征空间做变换（64×64 矩阵）；\",\"加入正则项约束变换矩阵接近正交：\",\"L_reg = ||I - A @ A^T||_F^2\",\"效果：\",\"PointNet 对点云的旋转、平移等变换具有鲁棒性；\",\"提升了模型的泛化能力和稳定性；\",\"✅ 难点 4：输入点云可能缺失或含有异常点 → 理论分析保证模型鲁棒性\",\"理论上证明 PointNet 学到的是一个“关键点集”（critical point set），即只依赖一小部分关键点就能判断整体形状；\",\"即使丢失一些点或加入异常点，只要关键点还在，结果就不会变；\",\"定理表明：\",\"小扰动不会改变函数输出；\",\"网络输出由一个有限子集 CS 决定（大小不超过 bottleneck 维度 K）；\",\"CS 是关键点集合，NS 是最大可容忍的点云范围；\",\"实验验证：\",\"即使 50% 的点缺失，分类准确率仅下降约 3.7%；\",\"对异常点也有一定容忍能力；\",\"✅ 总结: PointNet 通过 max pooling 实现对称性，结合 T-Net 实现变换不变性，并通过局部+全局特征融合机制实现强大的点云建模能力，解决了点云处理中的四大技术难点，为后续三维深度学习奠定了基础。\"]},\"106\":{\"h\":\"代码(Pytorch版本)\",\"t\":[\"PointNet网络模型结构图\"]},\"107\":{\"h\":\"输入标准化\",\"t\":[\"在 PointNet 架构中，第一层是一个叫做 STN3d（Spatial Transformer Network for 3D points） 的模块，它的目标是：\",\"✅ 对输入的点云做刚性变换（如旋转 + 平移），使其姿态统一，提升模型鲁棒性。\",\"这是因为在实际采集过程中，点云的姿态可能各不相同（比如椅子朝向不同、扫描角度不同等），如果不加处理，会影响特征提取的一致性。\",\"STN3d 是一个小型神经网络，专门用于预测一个 3×3 的变换矩阵 ，这个矩阵表示对点云所做的变换（通常是旋转或反射）。\",\"它具有以下特点：\",\"输入是原始点云（shape: (B, 3, N)）；\",\"输出是一个变换矩阵（shape: (B, 3, 3)）；\",\"这个变换矩阵是近似正交的，保证变换是刚性的；\",\"变换矩阵会通过 torch.bmm() 应用到原始点云上（这一步不在 STN3d 类中）；\",\"目的是让点云“摆正”，便于后续处理。\",\"代码实现:\",\"class STN3d(nn.Module): def __init__(self): super(STN3d, self).__init__() # 使用 1D 卷积 处理点云数据（每个点有 3 个坐标值） # kernel_size=1 表示只在通道维度操作，不考虑空间邻域关系 # 提取每一点的特征向量（从 3 → 64 → 128 → 1024） self.conv1 = torch.nn.Conv1d(3, 64, 1) self.conv2 = torch.nn.Conv1d(64, 128, 1) self.conv3 = torch.nn.Conv1d(128, 1024, 1) # 经过全局池化后得到一个全局特征向量（1024维） # 用全连接层逐步压缩到 9 个输出 → 对应一个 3x3 的变换矩阵 self.fc1 = nn.Linear(1024, 512) self.fc2 = nn.Linear(512, 256) self.fc3 = nn.Linear(256, 9) # 所有卷积和 FC 层后面都加了 BN 和 ReLU，帮助训练稳定收敛 self.relu = nn.ReLU() self.bn1 = nn.BatchNorm1d(64) self.bn2 = nn.BatchNorm1d(128) self.bn3 = nn.BatchNorm1d(1024) self.bn4 = nn.BatchNorm1d(512) self.bn5 = nn.BatchNorm1d(256) # x: (batch,3,point_size) def forward(self, x): # 获取当前 batch 的大小（有多少组点云） batchsize = x.size()[0] # CNN 逐点，通道维度特征提取阶段 x = F.relu(self.bn1(self.conv1(x))) x = F.relu(self.bn2(self.conv2(x))) x = F.relu(self.bn3(self.conv3(x))) # x: (batch,1024,point_size) # 全局最大池化（Global Max Pooling） # 从所有点中选出每个通道的最大响应值，作为整个点云的“抽象”表示，shape: (B, 1024) # 返回：一个元组：(values, indices)，分别是最大值和它们的位置索引。 x = torch.max(x, 2, keepdim=True)[0] # x: (batch,1024,1) x = x.view(-1, 1024) # x: (batch,1024) # 全连接层预测变换矩阵 x = F.relu(self.bn4(self.fc1(x))) x = F.relu(self.bn5(self.fc2(x))) x = self.fc3(x) # x: (batch,9) # 加上单位矩阵作为初始偏置 # 初始假设变换为恒等变换（不做任何变化） iden = Variable(torch.from_numpy(np.array([1,0,0,0,1,0,0,0,1]).astype(np.float32))).view(1,9).repeat(batchsize,1) if x.is_cuda: iden = iden.cuda() # 让网络从一个小扰动开始学习，更容易训练 x = x + iden # 最终 reshape 成 3x3 矩阵返回 x = x.view(-1, 3, 3) return x\",\"标准化的意义:\",\"✅ 1. 解决点云姿态不一致问题\",\"输入点云可能来自不同角度、不同位置；\",\"T-Net 把它们“对齐”到一个标准姿态；\",\"这样 PointNet 后续的特征提取更稳定。\",\"✅ 2. 提升模型鲁棒性\",\"如果没有 T-Net，PointNet 必须自己学会对各种姿态都识别准确；\",\"加入 T-Net 后，相当于加了一个“预处理层”，让模型更容易训练和泛化。\",\"神经网络的输出在训练初期往往接近于零，如果直接作为变换矩阵，会导致非正交、不稳定。PointNet 通过“加单位矩阵”的方式，让变换矩阵从一个恒等变换开始学习，并结合正则化损失，逐步向正交矩阵靠拢，从而保证变换是刚性的、稳定的。\"]},\"108\":{\"h\":\"正则化损失\",\"t\":[\"feature_transform_regularizer 是 PointNet 中用于约束变换矩阵接近正交性的正则化损失函数。\",\"🧠 为什么需要这个正则化项？\",\"在 PointNet 中，为了提升模型对点云姿态变化的鲁棒性，引入了两个变换网络：\",\"STN3d: 对原始点云做刚性变换（如旋转、反射），使其标准化。\",\"STNkd: 对特征空间做变换，使特征分布更稳定。\",\"这两个网络输出的是变换矩阵（分别是 3×3 和 k×k 的矩阵）。但由于它们是神经网络直接预测出来的，并不能保证这些矩阵是正交矩阵（orthogonal matrix） 。\",\"❗而只有正交矩阵才能表示刚性变换（rigid transformation），即只改变物体的方向而不改变形状和大小。\",\"所以我们需要加一个正则化项来鼓励变换矩阵接近正交矩阵 , 这就是 feature_transform_regularizer 的作用！\",\"def feature_transform_regularizer(trans): d = trans.size()[1] batchsize = trans.size()[0] # 构造一个单位矩阵 I，用于后续比较； # 添加 None 是为了扩展成 (1, d, d)，便于广播到整个 batch； I = torch.eye(d)[None, :, :] if trans.is_cuda: I = I.cuda() # 计算变换矩阵与其转置相乘后与单位矩阵之间的距离（Frobenius 范数），然后取 batch 平均值作为损失项，鼓励变换矩阵接近正交矩阵。 # Frobenius 范数（矩阵所有元素平方和开方） loss = torch.mean(torch.norm(torch.bmm(trans, trans.transpose(2,1)) - I, dim=(1,2))) return loss\"]},\"109\":{\"h\":\"特征提取\",\"t\":[\"PointNet 的核心特征提取模块 PointNetfeat ，它负责从输入点云中提取出可用于分类或分割的特征。\",\"class PointNetfeat(nn.Module): def __init__(self, global_feat = True, feature_transform = False): super(PointNetfeat, self).__init__() # 输入点云变换网络（3D） self.stn = STN3d() # 使用 Conv1D 对每个点进行特征提取； # 每个卷积层后跟一个 BatchNorm 层； # 最终输出高维特征（1024维）； self.conv1 = torch.nn.Conv1d(3, 64, 1) self.conv2 = torch.nn.Conv1d(64, 128, 1) self.conv3 = torch.nn.Conv1d(128, 1024, 1) self.bn1 = nn.BatchNorm1d(64) self.bn2 = nn.BatchNorm1d(128) self.bn3 = nn.BatchNorm1d(1024) # 全局特征开关：控制是否输出全局特征 self.global_feat = global_feat # 特征变换开关：控制是否使用 STN 对特征空间进行变换 self.feature_transform = feature_transform if self.feature_transform: self.fstn = STNkd(k=64) def forward(self, x): n_pts = x.size()[2] # 使用 STN3d 预测出一个变换矩阵； trans = self.stn(x) x = x.transpose(2, 1) # 将原始点云“摆正”； x = torch.bmm(x, trans) x = x.transpose(2, 1) # 再通过第一个卷积层提取初始特征； x = F.relu(self.bn1(self.conv1(x))) if self.feature_transform: trans_feat = self.fstn(x) x = x.transpose(2,1) x = torch.bmm(x, trans_feat) x = x.transpose(2,1) else: trans_feat = None # 提取更高维的特征； # 最后一层输出 shape: (B, 1024, N) pointfeat = x x = F.relu(self.bn2(self.conv2(x))) x = self.bn3(self.conv3(x)) # 从所有点中选出每个通道的最大响应值，作为整个点云的“抽象”表示，shape: (B, 1024) # 返回：一个元组：(values, indices)，分别是最大值和它们的位置索引。 x = torch.max(x, 2, keepdim=True)[0] x = x.view(-1, 1024) # 如果是分类任务 (global_feat=True)： if self.global_feat: return x, trans, trans_feat else: # 如果是分割任务 (global_feat=False)： x = x.view(-1, 1024, 1).repeat(1, 1, n_pts) return torch.cat([x, pointfeat], 1), trans, trans_feat\",\"✅ 如果是分类任务 (global_feat=True)，则返回：\",\"x: 全局特征 (B, 1024)\",\"trans: 输入点云变换矩阵\",\"trans_feat: 特征空间变换矩阵（可选）\",\"✅ 如果是分割任务 (global_feat=False)， 则返回：\",\"把全局特征复制 N 次并与每个点的局部特征，在通道维度进行拼接\",\"将每个点的局部特征与整个点云的全局特征拼接起来，让每个点都能看到上下文信息\",\"输出 shape: (B, 1088, N) ，即 1088 = 1024+64\"]},\"110\":{\"h\":\"分类任务\",\"t\":[\"PointNet 的分类模块 PointNetCls ，它基于前面的特征提取模块 PointNetfeat 来完成点云分类任务。\",\"class PointNetCls(nn.Module): def __init__(self, k=2, feature_transform=False): super(PointNetCls, self).__init__() self.feature_transform = feature_transform # 它使用 PointNetfeat 提取全局特征（1024维）； self.feat = PointNetfeat(global_feat=True, feature_transform=feature_transform) # 然后通过全连接层（MLP）将这些特征映射到类别空间； self.fc1 = nn.Linear(1024, 512) self.fc2 = nn.Linear(512, 256) self.fc3 = nn.Linear(256, k) self.dropout = nn.Dropout(p=0.3) self.bn1 = nn.BatchNorm1d(512) self.bn2 = nn.BatchNorm1d(256) self.relu = nn.ReLU() def forward(self, x): # 它使用 PointNetfeat 提取全局特征（1024维）； x, trans, trans_feat = self.feat(x) # 然后通过全连接层（MLP）将这些特征映射到类别空间； x = F.relu(self.bn1(self.fc1(x))) x = F.relu(self.bn2(self.dropout(self.fc2(x)))) x = self.fc3(x) # 最终输出每个类别的概率分布（log_softmax）； return F.log_softmax(x, dim=1), trans, trans_feat\"]},\"111\":{\"h\":\"分割任务\",\"t\":[\"PointNet 的分割模块 PointNetDenseCls ，它基于前面的特征提取模块 PointNetfeat 来完成点云物体分割任务。\",\"class PointNetDenseCls(nn.Module): def __init__(self, k = 2, feature_transform=False): super(PointNetDenseCls, self).__init__() self.k = k self.feature_transform=feature_transform self.feat = PointNetfeat(global_feat=False, feature_transform=feature_transform) self.conv1 = torch.nn.Conv1d(1088, 512, 1) self.conv2 = torch.nn.Conv1d(512, 256, 1) self.conv3 = torch.nn.Conv1d(256, 128, 1) self.conv4 = torch.nn.Conv1d(128, self.k, 1) self.bn1 = nn.BatchNorm1d(512) self.bn2 = nn.BatchNorm1d(256) self.bn3 = nn.BatchNorm1d(128) def forward(self, x): batchsize = x.size()[0] n_pts = x.size()[2] # 点的数量 # 调用 PointNetfeat 提取特征 # 最后将每个点的局部特征与整个点云的全局特征拼接起来，让每个点都能看到上下文信息 x, trans, trans_feat = self.feat(x) # 使用多层 Conv1D 层进一步融合局部 + 全局信息 # 最终输出 shape: (B, k, N) x = F.relu(self.bn1(self.conv1(x))) x = F.relu(self.bn2(self.conv2(x))) x = F.relu(self.bn3(self.conv3(x))) x = self.conv4(x) # shape: (B, k, N) -> (B, N, k) , 即每个点的各个类别得分 x = x.transpose(2,1).contiguous() # 使用 log_softmax 得到 log 概率分布； x = F.log_softmax(x.view(-1,self.k), dim=-1) # shape: (B*N, k) x = x.view(batchsize, n_pts, self.k) # shape: (B, N, k) return x, trans, trans_feat\",\"✅ 1. 每个点都需要全局上下文\",\"仅靠局部特征很难判断某个点属于哪个部件（比如椅子的腿 vs 座位）；\",\"加上全局特征后，相当于告诉模型：“你知道吗，这是一个椅子”；\",\"这样模型就能根据上下文更准确地做出判断；\",\"✅ 2. 全局特征不能直接用于分割\",\"全局特征只有一份（(B, 1024)），无法直接用于每个点；\",\"所以要把它复制 N 次，变成 (B, 1024, N)；\",\"再与每个点的局部特征拼接；\"]},\"112\":{\"h\":\"缺陷\",\"t\":[\"🧠 一、核心问题：忽略局部结构信息\",\"PointNet 只通过 max pooling 聚合所有点的信息，忽略了局部邻域之间的结构关系。\",\"🔍 原因分析：\",\"PointNet 对每个点独立处理（参数共享），然后使用全局最大池化（Global Max Pooling）提取特征；\",\"这种设计使得网络只关注“最显著的点”，而没有建模点与点之间的局部几何关系；\",\"导致模型无法捕捉到更细粒度的几何细节，比如边缘、曲率、表面纹理等；\",\"💡 论文中的验证：\",\"在部件分割任务中，虽然 PointNet 表现不错，但在一些复杂区域（如椅子腿和桌面连接处）容易出错；\",\"分类任务中对缺失点具有一定鲁棒性，但遇到遮挡严重或点分布不均匀时性能下降明显；\",\"📉 二、分割任务依赖拼接机制，不够精细\",\"PointNet 的分割模块通过拼接全局特征 + 局部特征实现上下文感知，但这种方式表达能力有限。\",\"🔍 原理回顾：\",\"PointNet 的分割网络将全局特征复制 N 次并与每个点的局部特征拼接；\",\"然后使用 Conv1D 进行分类；\",\"实际上是用一个固定大小的全局特征去“广播”给每个点；\",\"⚠️ 问题所在：\",\"全局特征不能很好地反映每个点的上下文；\",\"拼接方式缺乏动态调整机制；\",\"难以区分语义相近但位置不同的区域（如桌子边缘 vs 中心）；\",\"🧱 三、对局部形状变化敏感\",\"PointNet 提取的关键点集合（critical point set）可能不足以代表复杂的局部结构。\",\"🔍 实验观察：\",\"在论文中提到，PointNet 学到的是一个关键点集合，这些点大致构成物体的骨架；\",\"如果这些关键点缺失或被遮挡，即使其他点都在，也可能导致错误分类；\",\"对于非刚性变形（如人体姿态变化），PointNet 的表现不如基于图结构的模型；\",\"📈 四、分类性能略逊于多视角方法\",\"在某些标准数据集（如 ModelNet40）上，PointNet 的分类准确率略低于 MVCNN 等基于图像的方法。\",\"方法\",\"分类准确率\",\"MVCNN（多视角 CNN）\",\"90.1%\",\"VoxNet（体素 CNN）\",\"85.9%\",\"PointNet\",\"89.2%\",\"虽然 PointNet 在速度和效率上占优，但在精度上仍略逊一筹。\",\"🧩 五、难以捕捉非刚性变换下的不变性\",\"PointNet 使用 T-Net 强制学习正交变换矩阵，只能处理刚性变换（旋转、反射），无法处理非刚性形变（如弯曲、拉伸）。\",\"🔍 举例说明：\",\"如果你有一张人脸的点云，由于表情不同，面部发生形变；\",\"PointNet 很难在这种情况下保持分类的一致性；\",\"相比之下，基于图卷积或注意力机制的模型更能捕捉这种非刚性变化；\",\"🧱 六、缺乏层次化特征提取机制\",\"PointNet 是一种单尺度网络，无法像 CNN 那样逐层提取多层次的抽象特征。\",\"✅ 后续改进：\",\"PointNet++ 正是对这一缺陷的改进；\",\"它引入了局部区域搜索 + 多尺度聚合机制；\",\"从而能够更好地捕捉点云的局部结构和层次信息；\",\"📊 七、对稀疏点云敏感\",\"当输入点云非常稀疏时（如只有几十个点），PointNet 的性能会显著下降。\",\"🔍 原因分析：\",\"PointNet 的全局特征来自于 max pooling；\",\"如果点太少，max pooling 得到的特征可能无法覆盖整个物体；\",\"特别是在遮挡严重的情况下，关键点可能丢失；\",\"📐 八、结构简单，不利于高维空间建模\",\"PointNet 的结构过于简单，难以建模更高维度的空间关系。\",\"✅ 后续发展：\",\"后续的 3D 深度学习模型（如 DGCNN、SpiderCNN、PointCNN、Transformer-based 点云模型）都尝试引入更复杂的结构来提升建模能力；\",\"如：构建点之间的邻接图、使用 attention、引入多尺度采样等；\",\"🧪 九、理论上的限制：受限于瓶颈维度 K\",\"PointNet 的表达能力受 max pooling 层维度 K 的限制，即 bottleneck dimension。\",\"📌 来自论文的理论分析：\",\"Theorem 2 表明，PointNet 的输出仅由一个不超过 K 个点的子集决定（critical point set），这意味着：\",\"如果 K 不够大，PointNet 可能遗漏重要细节；\",\"如果 K 太大，又会导致计算资源浪费；\",\"🧱 十、对噪声点敏感（尤其未训练时）\",\"虽然 PointNet 对少量异常点有一定鲁棒性，但如果训练时没有加入扰动，面对大量噪声点时效果较差。\",\"🔍 实验验证：\",\"论文中做了“插入异常点”的实验；\",\"结果显示，如果训练过程中加入了噪声，模型表现良好；\",\"否则，异常点会影响分类和分割性能；\",\"📉 十一、在大规模场景理解任务中表现一般\",\"PointNet 的时间复杂度虽然是 O(N)，但在处理超大规模点云时，仍然不如分块处理或多层级聚合模型高效。\",\"✅ 后续改进方向：\",\"使用分块策略（chunking）\",\"构建点云的层次化表示\",\"引入 attention 或图结构增强局部建模能力\",\"🧩 总结表格：PointNet 的主要缺陷\",\"缺陷类型\",\"描述\",\"是否被后续模型改进\",\"忽略局部结构\",\"仅靠 max pooling 提取特征，无局部聚合机制\",\"✅ PointNet++ 改进\",\"分割精度不高\",\"拼接机制不够精细，缺乏动态上下文感知\",\"✅ Transformer-based 改进\",\"无法处理非刚性变形\",\"T-Net 只学正交变换，无法应对弯曲、拉伸等形变\",\"✅ 图卷积、attention 改进\",\"分类精度略低\",\"在 ModelNet40 上略低于 MVCNN\",\"✅ 多视角 + PointNet 混合模型改进\",\"稀疏点云下性能差\",\"少量点无法覆盖关键结构\",\"✅ PointNet++ 改进\",\"局部建模能力弱\",\"无法捕捉边缘、曲率等细节\",\"✅ DGCNN、SpiderCNN 改进\",\"对噪声点敏感\",\"未经扰动训练时，对异常点鲁棒性差\",\"✅ 加入数据增强后缓解\",\"结构单一\",\"缺乏层次化、多尺度建模能力\",\"✅ PointNet++ / Transformer 改进\",\"📈 PointNet 的优势 vs 缺陷对比\",\"维度\",\"优势\",\"缺陷\",\"输入形式\",\"支持原始点云，无需预处理\",\"无法有效利用局部结构\",\"排列不变性\",\"完全支持\",\"无法区分顺序信息（如时间序列点云）\",\"变换不变性\",\"支持刚性变换标准化\",\"无法处理非刚性形变\",\"分类性能\",\"接近 SOTA\",\"略逊于多视角 CNN\",\"分割性能\",\"表现良好\",\"缺乏精细建模\",\"效率\",\"极其高效（O(N)）\",\"无法充分利用 GPU 并行优化\",\"扩展性\",\"易于扩展为检测、检索等任务\",\"表达能力受限于 max pooling 维度\",\"✅ 一句话总结：\",\"PointNet 的最大缺陷在于它“看不清细节”，只关注全局结构，忽视局部邻域关系，这使得它在细粒度识别、非刚性变形、稀疏点云等任务中表现受限，但它也为后续模型奠定了基础。\"]},\"113\":{\"h\":\"背景知识扫盲(可选)\"},\"114\":{\"h\":\"点云\",\"t\":[\"点云: 是一种表示三维空间中物体或场景的方式，它由大量带有位置信息的点组成。\",\"每个点通常包含：\",\"坐标信息 ：x, y, z（3D 空间中的位置）。\",\"可选属性：颜色（RGB）、法向量（Normal）、强度（Intensity）、时间戳等。\",\"表示形式:\",\"点云（Point Cloud）: 原始点集合：每个点有(x, y, z)坐标; 可选颜色、法向量等属性, 简洁、轻便; 保留原始几何信息,无序性、非结构化、难以用 CNN 处理。\",\"体素网格 (voxel grids) : 将空间划分成立方体格子，每个格子表示是否有物体; 结构规整，适合 3D CNN; 计算复杂度高、稀疏性强、精度受限。\",\"多视角图像（Multi-View Images）: 从多个角度渲染点云或 3D 模型为 2D 图像; 可使用成熟的 2D CNN 方法; 丢失部分几何信息，依赖视角选择。\",\"网格（Mesh）： 由三角形面片组成的 3D 模型； 包含表面细节，适合渲染； 难以自动构建，拓扑复杂。\"]},\"115\":{\"h\":\"对称函数\",\"t\":[\"对称函数（Symmetric Function）是一种对输入顺序不敏感的函数；换句话说，无论你如何打乱输入元素的顺序，输出结果都保持不变。\",\"🧠 数学定义:\",\"设是一个函数，如果对于任意排列（permutation），都有：\",\"那么就是一个 对称函数。\",\"PointNet 处理的是点云数据，而点云是无序集合（unordered set） ，即：\",\"点云中点的顺序不影响整体形状。\",\"所以模型必须具有对点顺序的不变性（permutation invariance）。\",\"这就要求网络中的某些关键操作必须是对称函数 ，才能保证整个网络输出与输入点的顺序无关。\",\"📦 常见的对称函数:\",\"函数\",\"描述\",\"是否可微\",\"应用场景\",\"最大池化（Max Pooling）\",\"取所有点的最大值：\",\"✅ 是\",\"PointNet 中的核心操作\",\"平均池化（Average Pooling）\",\"取所有点的平均值：\",\"✅ 是\",\"特征融合、平滑处理\",\"求和（Summation）\",\"所有点相加：\",\"✅ 是\",\"构建全局特征向量\",\"乘积（Product）\",\"所有点相乘：\",\"⚠️ 对数值变化敏感\",\"不常用，但可用于特定任务\",\"最小池化（Min Pooling）\",\"取最小值：\",\"✅ 是\",\"异常检测等特殊场景\",\"Softmax + 加权和（Attention-based Sum）\",\"根据注意力机制加权求和，权重由 softmax 得出\",\"✅ 是\",\"DGCNN、Transformer 中使用\",\"统计量（如方差、标准差）\",\"计算点集的分布特性\",\"✅ 是\",\"特征增强、异常检测\",\"集合函数近似器（如 Deep Sets）\",\"使用神经网络直接学习对称函数\",\"✅ 是\",\"更复杂的对称函数建模\"]},\"116\":{\"h\":\"刚性运动\",\"t\":[\"刚性运动(rigid motions) 是指：物体在空间中移动时，其形状和大小保持不变的运动方式 。\",\"刚性运动\",\"❌ 不改变\",\"移动、旋转\",\"非刚性运动\",\"✅ 改变\",\"弯曲、拉伸、缩放（非均匀）、变形\",\"刚性运动 = 平移 + 旋转，不改变物体形状和内部结构，只改变位置和朝向。\"]},\"117\":{\"h\":\"正交变换\",\"t\":[\"正交变换的本质是：只改变物体的方向（旋转），不改变形状和大小\",\"所以：\",\"正交变换包括：旋转 + 反射。\",\"不包括：缩放、剪切、拉伸等会导致形变的操作。\"]},\"118\":{\"h\":\"大语言模型\"},\"119\":{\"h\":\"BLIP 论文\",\"t\":[\"BLIP: Bootstrapping Language-Image Pre-training for Unified Vision-Language Understanding and Generation 论文解读\",\"论文链接: BLIP: Bootstrapping Language-Image Pre-training for Unified Vision-Language Understanding and Generation 代码链接: https://github.com/salesforce/BLIP\"]},\"120\":{\"h\":\"Introduction\",\"t\":[\"当前视觉-语言预训练（VLP）方法虽然在多模态任务上取得进展，但普遍存在两个问题：\",\"模型限制：编码器模型不适合文本生成任务；编码器-解码器模型难以用于图文检索。\",\"数据质量差：大多使用从网络收集的嘈杂图文对作为训练数据，监督信号不理想。\",\"BLIP（Bootstrapping Language-Image Pre-training）是一个新颖的 VLP 框架，兼顾理解与生成能力。其两大创新点：\",\"MED 模型结构（Multimodal Mixture of Encoder-Decoder）：\",\"同时支持编码器、图像条件编码器、图像条件解码器三种模式。\",\"联合训练三种任务：图文对比学习、图文匹配、图像条件语言建模。\",\"实现多任务预训练与灵活迁移。\",\"CapFilt 数据自举方法（Captioning and Filtering）：\",\"使用训练好的 MED 模型构建两个模块：\",\"描述器（captioner）生成图像的合成描述；\",\"过滤器（filter）剔除原始和生成的低质量描述。\",\"在保留信息的同时提升训练数据质量。\",\"实验结果与表现:\",\"BLIP 在多个任务（图文检索、图像描述、VQA 等）上取得最先进性能。\",\"同时，在两个视频-语言任务上以零样本方式迁移也表现优异。\",\"实验证明：描述器与过滤器的组合能显著提升性能，多样化描述更有利于学习。\"]},\"121\":{\"h\":\"Related Work\"},\"122\":{\"h\":\"视觉-语言预训练（VLP）\",\"t\":[\"现状问题：\",\"主流 VLP 方法依赖从网络抓取的图文对数据，虽然规模大，但包含大量噪声文本。\",\"尽管使用简单的过滤规则，噪声仍广泛存在。\",\"编码器模型适合理解类任务但难以生成文本；编码器-解码器适合生成任务但不适用于检索。\",\"BLIP 的改进：\",\"提出 CapFilt：通过“生成 + 过滤”的方式优化数据质量。\",\"提出 MED 模型结构：在保持预训练高效的前提下，同时兼顾理解与生成任务，提升泛化能力。\"]},\"123\":{\"h\":\"知识蒸馏（Knowledge Distillation）\",\"t\":[\"现有做法：\",\"知识蒸馏让小模型（学生）学习大模型（教师）的预测结果。\",\"自蒸馏也取得了不错效果，尤其在图像分类与部分 VLP 方法中已开始尝试。\",\"BLIP 的新视角：\",\"CapFilt 可视为一种结构化的知识蒸馏方式：\",\"Captioner 模块用生成的语义丰富描述进行蒸馏；\",\"Filter 模块通过剔除噪声文本完成隐式知识过滤。\"]},\"124\":{\"h\":\"数据增强（Data Augmentation）\",\"t\":[\"现有做法：\",\"图像任务中数据增强广泛应用，但语言任务的数据增强较困难。\",\"近年来生成模型被用于文本任务的样本合成，但多用于低资源语言场景。\",\"BLIP 的贡献：\",\"展示了在大规模视觉-语言预训练中使用合成图像描述的独特优势，提升了多模态学习效果。\"]},\"125\":{\"h\":\"Method\",\"t\":[\"在本文中，作者提出了一个统一的视觉语言预训练框架 BLIP，该方法能够有效从噪声图文对中学习。方法部分主要分为三个内容：模型架构 MED、预训练目标，以及数据集自举策略 CapFilt。\"]},\"126\":{\"h\":\"模型架构：MED（Multimodal Mixture of Encoder-Decoder）\",\"t\":[\"作者在模型中采用了 视觉 Transformer（ViT）（Dosovitskiy et al., 2021）作为图像编码器，它会将图像切分为 patch，并编码为一系列嵌入表示，其中额外添加的 [CLS] token 被用作图像的全局特征。相比使用预训练目标检测器（如 Chen et al., 2020），ViT 的使用更具计算效率，也被近年来的工作所采纳（Li et al., 2021a；Kim et al., 2021）。\",\"为了训练一个既具理解能力又具生成能力的统一模型，作者提出了一个多任务模型架构：多模态混合的编码器-解码器（MED）。该架构支持以下三种功能模式：\",\"Unimodal Encoder（单模态编码器）\",\"图像和文本分别编码。\",\"文本编码器使用 BERT（Devlin et al., 2019），在文本前添加 [CLS] token 来表示整句话的语义。\",\"Image-grounded Text Encoder（图像引导的文本编码器）\",\"在 BERT 的每个 block 中添加一层 cross-attention（CA），位于 self-attention（SA）和 FFN 之间。\",\"文本末尾添加一个 [Encode] token，输出的该 token 表示图文对的多模态表示。\",\"Image-grounded Text Decoder（图像引导的文本解码器）\",\"在 encoder 的基础上将双向 SA 替换为因果 self-attention，以实现生成任务。\",\"使用 [Decode] token 标记序列开始，使用 <eos> 表示结束。\",\"为了实现多任务高效预训练，模型设计上 encoder 和 decoder 共享除了 SA 层以外的所有参数。作者认为编码和解码之间的主要差异体现在 SA 层（前者为双向，后者为因果），而嵌入层、CA 和 FFN 层则可以共享。这样的共享设计能够提升训练效率，并有利于多任务学习。\"]},\"127\":{\"h\":\"预训练目标（ITC、ITM、LM）\",\"t\":[\"BLIP 同时优化三个预训练目标，其中包括两个理解任务和一个生成任务。每对图文样本只需通过一次视觉 Transformer，但文本 Transformer 会根据不同功能分支前向三次，以计算以下三种损失：\",\"Image-Text Contrastive Loss（ITC）\",\"启用 Unimodal Encoder，用于对齐图像和文本的表示空间。\",\"目标是使正样本的图文对在特征空间中接近，同时区分负样本。\",\"方法参考 Li et al. (2021a)，采用动量编码器来生成表示，并用其产生的软标签作为训练目标，从而考虑负样本中的潜在正样本。\",\"Image-Text Matching Loss（ITM）\",\"启用 Image-grounded Text Encoder，用于学习图文之间的细粒度对齐关系。\",\"本质是一个二分类任务，判断图文是否匹配，使用一个线性分类头进行预测。\",\"采用 Li et al. (2021a) 提出的 困难负样本挖掘策略，即在 batch 中优先选择对比相似度高的负样本来增强训练信号。\",\"Language Modeling Loss（LM）\",\"启用 Image-grounded Text Decoder，训练模型根据图像生成文本描述。\",\"使用交叉熵损失，训练模型以自回归方式生成文本；计算时引入 0.1 的标签平滑。\",\"相比于传统的 MLM，LM 更能增强模型将视觉信息转化为自然语言的能力。\"]},\"128\":{\"h\":\"CapFilt：图文数据的自举式清洗机制\",\"t\":[\"由于高质量人工标注图文对（如 COCO）数量有限，而自动爬取的网页图文对（）噪声严重，作者提出了一个新的数据处理流程：CapFilt（Captioning and Filtering），用于提升图文语料的质量。\",\"CapFilt 包含两个模块，分别用于生成和过滤文本：\",\"Captioner\",\"是一个图像引导的文本解码器，使用 LM 目标在 COCO 上轻量微调。\",\"输入网页图像 ，输出合成描述 （一张图对应一条生成的 caption）。\",\"Filter\",\"是一个图像引导的文本编码器，使用 ITC 和 ITM 目标进行微调。\",\"输入图像及文本，判断是否匹配；若 ITM 头预测为不匹配，则认为是噪声文本。\",\"过滤对象既包括网页原始文本 ，也包括合成描述 。\",\"最后，作者将通过 Filter 筛选出的图文对与人工标注数据结合，组成新的训练集，用于训练下一个更强的模型。\"]},\"129\":{\"h\":\"小结\",\"t\":[\"BLIP 在模型设计上提出了一个灵活、统一的多任务架构（MED），同时结合图文对比、匹配和生成等任务目标进行联合训练。在数据方面，通过 CapFilt 机制有效从网页图文对中挖掘高质量样本，显著扩展了训练数据的规模和质量。\",\"整体来看，BLIP 是一个兼顾理解与生成、统一建模与数据增强的多模态预训练方法，具有较强的实用性与拓展性。\",\"以下是对“Experiments and Discussions”部分翻译内容的总结，遵循您的格式规范：\"]},\"130\":{\"h\":\"Experiments and Discussions\"},\"131\":{\"h\":\"预训练细节\",\"t\":[\"BLIP 模型使用 PyTorch 实现，预训练环境为两个16-GPU节点。图像编码器基于在 ImageNet 上预训练的 ViT（参考 Touvron et al., 2020；Dosovitskiy et al., 2021），文本编码器则基于 BERTbase（Devlin et al., 2019）。模型变体包括 ViT-B/16 和 ViT-L/16，其中默认使用 ViT-B。\",\"训练配置如下：\",\"训练轮数为 20，批量大小为 2880（ViT-B）/ 2400（ViT-L）；\",\"优化器使用 AdamW（Loshchilov & Hutter, 2017），权重衰减为 0.05，学习率预热后分别达到 （ViT-B）和 （ViT-L），随后线性衰减；\",\"图像预训练分辨率为 ，微调时提升为 。\",\"所使用的训练数据总共包含约 1400 万张图像，覆盖以下数据集：\",\"COCO 和 Visual Genome（人工标注）；\",\"Conceptual Captions、Conceptual 12M 和 SBU Captions（网页收集）；\",\"补充实验中还使用了 LAION（Schuhmann et al., 2021）的大规模网页数据集（1.15 亿图像），每轮只使用 1/5 数据。\"]},\"132\":{\"h\":\"CapFilt 效果验证\",\"t\":[\"CapFilt 模块通过 Captioner 生成合成文本，再由 Filter 去除噪声文本，显著提升模型性能（表1）。三种设置下的对比表明：\",\"单独使用 Captioner 或 Filter 均有性能提升；\",\"两者联合使用时效果最佳，且具备数据量和模型规模的可扩展性；\",\"更强的视觉主干（如 ViT-L）可进一步增强性能。\",\"图4 展示了网页原始文本（）与合成文本（）的对比，绿色为 Filter 接收的文本，红色为剔除的文本，验证了 Captioner 提供新描述、Filter 移除无效数据的有效 性。\"]},\"133\":{\"h\":\"合成文本的多样性对性能的影响\",\"t\":[\"表2 比较了两种文本生成方式：\",\"Beam search：确定性搜索，噪声比例较低（19%）；\",\"Nucleus sampling：随机采样，噪声比例稍高（25%），但性能全面超越 Beam search。\",\"作者推测，nucleus sampling 生成的文本更具有 新颖性与多样性，提供更多额外信息；而 beam search 更倾向于生成数据集中常见的“安全”文本，难以提升模型泛化能力。\"]},\"134\":{\"h\":\"编码器-解码器参数共享与解耦\",\"t\":[\"表3 分析了不同的参数共享策略对模型性能的影响。结论如下：\",\"最佳方案是 仅在 SA 层不共享参数，其余部分共享；\",\"如果完全不共享参数，则模型体积大、性能次优；\",\"如果共享 SA 层，性能反而下降，因其在编码（双向注意力）与解码（因果注意力）间存在功能冲突。\",\"在 CapFilt 阶段，Captioner 与 Filter 分别进行微调。表4 显示，如果二者参数共享，则会因“确认偏差”导致性能下降 —— 生成的错误文本更难被 Filter 剔除（噪声比例仅 8%，远低于解耦时的 25%）。\",\"以下是论文 BLIP: Bootstrapping Language-Image Pre-training for Unified Vision-Language Understanding and Generation 中第 6章 Additional Ablation Study 和第 7章 Conclusion 部分的翻译：\"]},\"135\":{\"h\":\"Ablation Study\"},\"136\":{\"h\":\"CapFilt 的性能提升并非源于更长的训练时间\",\"t\":[\"由于经过 CapFilt 处理后的数据集包含比原始数据集更多的文本，因此在相同的 epoch 数下，训练时间会更长。为了验证 CapFilt 的有效性是否真正来自其机制本身，而非训练时间变长，我们将原始数据集中的网页文本复制，使得每个 epoch 的样本数量与 bootstrapped 数据集一致。\",\"如表 12 所示，仅通过扩充原始数据进行更长时间训练 并未带来性能提升，验证了 CapFilt 的真正价值。\"]},\"137\":{\"h\":\"应使用 Bootstrapped 数据集重新训练模型\",\"t\":[\"Bootstrapped 数据集应当用于重新训练一个新模型。我们对比了两种方式：\",\"在预训练模型基础上继续使用 CapFilt 数据训练；\",\"用 CapFilt 数据从头训练一个新模型。\",\"表 13 显示，继续训练的效果不如重新训练，这与知识蒸馏领域的常见做法一致：学生模型不能由教师模型直接初始化。这也间接说明 CapFilt 机制与重新初始化更契合。\"]},\"138\":{\"h\":\"Conclusion\",\"t\":[\"BLIP 是一个新的视觉-语言预训练框架，在众多下游任务中都实现了最先进（SOTA）性能，包括理解类任务和生成类任务。\",\"BLIP 使用多模态混合的编码器-解码器模型（Multimodal Mixture of Encoder-Decoder, MED），并通过对大规模嘈杂图文数据进行 bootstrapping 构建预训练语料：注入多样的合成描述，并剔除低质量描述。\",\"发布了 bootstrapped 数据集，以促进视觉-语言研究的发展。\",\"未来可进一步探索以下方向以提升 BLIP 表现：\",\"多轮数据集 Bootstrapping；\",\"为每张图像生成 多个合成描述，进一步扩大语料规模；\",\"使用多个不同的 Captioner 和 Filter 训练多个模型，再进行集成，增强 CapFilt 的效果。\"]},\"139\":{\"h\":\"Code Implementation\"},\"140\":{\"h\":\"CapFilt 模块实现\",\"t\":[\"BLIP 使用 CapFilt 对多个大规模噪声网页图文数据集（包括 CC12M、CC3M 和 SBU Captions）进行增强，首先通过 captioner 为图像生成合成文本，再通过 filter 过滤掉与图像不匹配的原始和合成文本，最终构建出高质量的自举数据集（bootstrapped dataset），用于预训练新模型。\",\"在 CapFilt 模块微调阶段，BLIP 则基于高质量人工标注的数据集如 COCO Captions、Visual Genome 和 Flickr30K 进行训练和评估。\",\"经过 CapFilt 处理后，输出的数据集是经过图文对齐质量优化的图文对集合，有效提升了下游任务中的表现。\",\"官方代码库并没有非常清晰指明CapFilt模块的实现代码位置，但是官方仓库的ISSUE给出了明确答复: https://github.com/salesforce/BLIP/issues/86?utm_source=chatgpt.com\"]},\"141\":{\"h\":\"Captioner 模块\"},\"142\":{\"h\":\"微调阶段\",\"t\":[\"Captioner 基于 Coco 数据集进行微调:\",\"# 训练函数：执行一个 epoch 的训练流程 def train(model, data_loader, optimizer, device): for i, (image, caption, _) in data_loader: loss = model(image, caption) # 前向传播，计算语言建模损失 optimizer.zero_grad() # 清除旧梯度 loss.backward() # 反向传播 optimizer.step() # 更新模型参数 # 主流程：加载数据、初始化模型和优化器、执行多轮训练 def main(args, config): #### Dataset #### # 加载 COCO Caption 数据集的训练/验证/测试划分 train_dataset, val_dataset, test_dataset = create_dataset('caption_coco', config) # 构造对应的数据加载器 train_loader, val_loader, test_loader = create_loader( [train_dataset, val_dataset, test_dataset], samplers, batch_size=[config['batch_size']]*3, num_workers=[4, 4, 4], is_trains=[True, False, False], collate_fns=[None, None, None] ) #### Model #### # 初始化 BLIP 解码器模型（用于图像字幕生成），加载预训练视觉编码器与文本解码器 model = blip_decoder( pretrained=config['pretrained'], image_size=config['image_size'], vit=config['vit'], vit_grad_ckpt=config['vit_grad_ckpt'], vit_ckpt_layer=config['vit_ckpt_layer'], prompt=config['prompt'] ) # 初始化优化器（AdamW） optimizer = torch.optim.AdamW( params=model.parameters(), lr=config['init_lr'], weight_decay=config['weight_decay'] ) #### Train #### for epoch in range(0, config['max_epoch']): # 每个 epoch 执行一次训练 train_stats = train(model, train_loader, optimizer, epoch, device)\",\"训练阶段唯一需要注意的一点就是数据集的构造过程中，会在Coco数据集每个样本原有Caption的基础上添加一个Prompt:\",\"class coco_karpathy_train(Dataset): def __getitem__(self, index): ann = self.annotation[index] image_path = os.path.join(self.image_root,ann['image']) image = Image.open(image_path).convert('RGB') image = self.transform(image) # 在caption前添加prompt , prompt 默认为 'a picture of ' caption = self.prompt+pre_caption(ann['caption'], self.max_words) # self.img_ids[ann['image_id']]: 取出图像 ID 对应的 索引编号 return image, caption, self.img_ids[ann['image_id']]\",\"下面将给出Captioner模块基于Coco数据集，采用 next token predict 方法进行训练的代码实现：\",\"class BLIP_Decoder(nn.Module): def __init__(self, med_config = 'configs/med_config.json', image_size = 384, vit = 'base', vit_grad_ckpt = False, vit_ckpt_layer = 0, prompt = 'a picture of ', ): \\\"\\\"\\\" BLIP Captioner模块初始化，实现论文中提出的图像-文本跨模态编码器-解码器架构 Args: med_config (str): 混合编码器-解码器模型配置文件路径，对应论文3.1节中提到的多模态融合模块配置 image_size (int): 输入图像尺寸，论文4.1节实验设置中使用384x384 vit (str): 视觉Transformer模型大小，论文中采用ViT-Base作为默认视觉编码器 vit_grad_ckpt (bool): 是否使用梯度检查点优化ViT显存占用，论文附录A中提到的训练优化策略 vit_ckpt_layer (int): ViT梯度检查点层数，用于平衡训练效率与显存使用 prompt (str): 图像描述生成的引导提示词，对应论文3.2节中使用的prompt engineering技术 \\\"\\\"\\\" super().__init__() self.visual_encoder, vision_width = create_vit(vit,image_size, vit_grad_ckpt, vit_ckpt_layer) # 初始化视觉编码器，对应论文图1中的视觉Transformer self.tokenizer = init_tokenizer() # 初始化文本分词器，采用BERT分词器实现论文中的文本预处理 med_config = BertConfig.from_json_file(med_config) med_config.encoder_width = vision_width self.text_decoder = BertLMHeadModel(config=med_config) # 初始化文本解码器，实现论文3.1节中的跨模态解码器 self.prompt = prompt # 存储图像描述引导提示词，用于论文3.3节中的条件生成任务 self.prompt_length = len(self.tokenizer(self.prompt).input_ids)-1 # 计算提示词token长度，用于后续解码时区分提示与生成文本 def forward(self, image, caption): # 提取图像特征表示 image_embeds = self.visual_encoder(image) image_atts = torch.ones(image_embeds.size()[:-1], dtype=torch.long).to(image.device) # 编码文本输入，并替换开头 token 为 [BOS] text = self.tokenizer(caption, padding='longest', truncation=True, max_length=40, return_tensors=\\\"pt\\\").to(image.device) text.input_ids[:, 0] = self.tokenizer.bos_token_id # 构建语言建模标签：屏蔽掉 padding 和 prompt 部分 decoder_targets = text.input_ids.masked_fill(text.input_ids == self.tokenizer.pad_token_id, -100) decoder_targets[:, :self.prompt_length] = -100 # 调用跨模态解码器，执行语言建模训练 decoder_output = self.text_decoder( text.input_ids, attention_mask=text.attention_mask, encoder_hidden_states=image_embeds, encoder_attention_mask=image_atts, labels=decoder_targets, return_dict=True ) loss_lm = decoder_output.loss # 提取语言建模损失 return loss_lm\",\"BertLMHeadModel自回归语言建模实现\"]},\"143\":{\"h\":\"生成阶段\",\"t\":[\"当 Captioner 模块在 Coco 数据集上进行训练后，即可用于生成图像描述。\",\"def generate(self, image, sample=False, num_beams=3, max_length=30, min_length=10, top_p=0.9, repetition_penalty=1.0): # 通过视觉编码器提取图像的视觉特征（image embeddings） image_embeds = self.visual_encoder(image) if not sample: # 如果使用 beam search 生成，则需要将图像特征复制 num_beams 份 # 这是为了每个 beam 都能接收相同的图像信息 image_embeds = image_embeds.repeat_interleave(num_beams, dim=0) # 构造图像 attention mask，全为 1，表示图像特征没有被 mask image_atts = torch.ones(image_embeds.size()[:-1], dtype=torch.long).to(image.device) # 构造 encoder-decoder 所需的关键词参数（即图像特征作为 cross-attention 的条件输入） model_kwargs = { \\\"encoder_hidden_states\\\": image_embeds, \\\"encoder_attention_mask\\\": image_atts } # 构造输入的 prompt，格式为 [\\\"a picture of \\\", \\\"a picture of \\\", ...] prompt = [self.prompt] * image.size(0) # 对 prompt 进行分词并转为 tensor，作为 decoder 的输入起点（input_ids） input_ids = self.tokenizer(prompt, return_tensors=\\\"pt\\\").input_ids.to(image.device) # 强制将每个样本开头的 token 设为 [BOS]（beginning-of-sentence） input_ids[:, 0] = self.tokenizer.bos_token_id # 移除最后一个 token（保持 prompt 是 decoder 的 prefix） input_ids = input_ids[:, :-1] if sample: # ---------- 使用 nucleus sampling（核采样）生成 ---------- outputs = self.text_decoder.generate( input_ids=input_ids, max_length=max_length, min_length=min_length, do_sample=True, # 启用采样 top_p=top_p, # nucleus 采样的阈值 num_return_sequences=1, # 每张图像生成一个序列 eos_token_id=self.tokenizer.sep_token_id, # 使用 [SEP] 作为结束标记 pad_token_id=self.tokenizer.pad_token_id, # 使用 [PAD] 作为 padding repetition_penalty=1.1, # 防止重复生成 **model_kwargs # 传入图像编码信息 ) else: # ---------- 使用 beam search（束搜索）生成 ---------- outputs = self.text_decoder.generate( input_ids=input_ids, max_length=max_length, min_length=min_length, num_beams=num_beams, # beam 数量 eos_token_id=self.tokenizer.sep_token_id, pad_token_id=self.tokenizer.pad_token_id, repetition_penalty=repetition_penalty, # 重复惩罚项 **model_kwargs ) # ---------- 解码生成的 token 序列为文本 ---------- captions = [] for output in outputs: caption = self.tokenizer.decode(output, skip_special_tokens=True) # 去掉 prompt 的前缀，只保留生成部分 captions.append(caption[len(self.prompt):]) return captions\"]},\"144\":{\"h\":\"Filter 模块\"},\"145\":{\"h\":\"微调阶段\",\"t\":[\"Filter 模块同样也是基于 Coco 数据集进行微调，但采用图文检索和图文匹配作为训练目标:\",\"def train(model, data_loader, optimizer, epoch, device, config): for i,(image, caption, idx) in data_loader: # 采用Moco的动量慢更新策略进行学习 if epoch>0: alpha = config['alpha'] else: alpha = config['alpha']*min(1,i/len(data_loader)) # idx 是每个图像对应的索引编号 loss_ita, loss_itm = model(image, caption, alpha=alpha, idx=idx) loss = loss_ita + loss_itm optimizer.zero_grad() loss.backward() optimizer.step() def main(args, config): #### Dataset #### # 数据集处理方面，同样会为Coco数据集中每个样本的Caption前添加固定长度的Prompt: 'a picture of' train_dataset, val_dataset, test_dataset = create_dataset('retrieval_%s'%config['dataset'], config) train_loader, val_loader, test_loader = create_loader([train_dataset, val_dataset, test_dataset],samplers, batch_size=[config['batch_size_train']]+[config['batch_size_test']]*2, num_workers=[4,4,4], is_trains=[True, False, False], collate_fns=[None,None,None]) #### Model #### model = blip_retrieval(pretrained=config['pretrained'], image_size=config['image_size'], vit=config['vit'], vit_grad_ckpt=config['vit_grad_ckpt'], vit_ckpt_layer=config['vit_ckpt_layer'], queue_size=config['queue_size'], negative_all_rank=config['negative_all_rank']) optimizer = torch.optim.AdamW(params=model.parameters(), lr=config['init_lr'], weight_decay=config['weight_decay']) for epoch in range(0, config['max_epoch']): train(model, train_loader, optimizer, epoch, device, config)\",\"训练过程代码实现基本遵循Moco论文中所提出的动量慢更新对比学习代码实现，下面先给出 BLIP_Retrieval 模型 init 方法实现:\",\"class BLIP_Retrieval(nn.Module): def __init__(self, med_config='configs/med_config.json', image_size=384, vit='base', vit_grad_ckpt=False, vit_ckpt_layer=0, embed_dim=256, queue_size=57600, momentum=0.995, negative_all_rank=False): # 初始化视觉编码器 self.visual_encoder, vision_width = create_vit(vit, image_size, vit_grad_ckpt, vit_ckpt_layer) # 初始化文本编码器和分词器 self.tokenizer = init_tokenizer() self.text_encoder = BertModel(config=med_config, add_pooling_layer=False) # 特征投影层（用于对比学习） self.vision_proj = nn.Linear(vision_width, embed_dim) self.text_proj = nn.Linear(text_width, embed_dim) # ITM分类头（判断图文是否匹配） self.itm_head = nn.Linear(text_width, 2) # 创建动量编码器（momentum encoder） self.visual_encoder_m, vision_width = create_vit(vit, image_size) self.vision_proj_m = nn.Linear(vision_width, embed_dim) self.text_encoder_m = BertModel(config=med_config, add_pooling_layer=False) self.text_proj_m = nn.Linear(text_width, embed_dim) # 配对编码器用于同步参数 self.model_pairs = [[self.visual_encoder, self.visual_encoder_m], [self.vision_proj, self.vision_proj_m], [self.text_encoder, self.text_encoder_m], [self.text_proj, self.text_proj_m]] self.copy_params() # 初始化对比学习的负样本队列 self.register_buffer(\\\"image_queue\\\", torch.randn(embed_dim, queue_size)) self.register_buffer(\\\"text_queue\\\", torch.randn(embed_dim, queue_size)) self.register_buffer(\\\"idx_queue\\\", torch.full((1, queue_size), -100)) self.register_buffer(\\\"ptr_queue\\\", torch.zeros(1, dtype=torch.long)) self.image_queue = nn.functional.normalize(self.image_queue, dim=0) self.text_queue = nn.functional.normalize(self.text_queue, dim=0) self.queue_size = queue_size self.momentum = momentum self.temp = nn.Parameter(0.07 * torch.ones([])) # 对比学习温度参数 self.negative_all_rank = negative_all_rank\",\"前向传播过程主要是为了计算两个训练目标的损失:\",\"图文对比目标（ITC）\",\"图文匹配目标（ITM）\",\"代码整体流程比较长，我们切分为多个步骤进行解析:\",\"提取图像和文本特征\",\" def forward(self, image, caption, alpha, idx): # 图像特征提取和投影 # image: (B, 3, H, W) -> image_embeds: (B, N, D) image_embeds = self.visual_encoder(image) image_atts = torch.ones(image_embeds.size()[:-1], dtype=torch.long).to(image.device) # (B, N) image_feat = F.normalize(self.vision_proj(image_embeds[:, 0, :]), dim=-1) # 只取CLS Token做投影: (B, D_proj) # 文本特征提取和投影 text = self.tokenizer(caption, padding='max_length', truncation=True, max_length=35, return_tensors=\\\"pt\\\").to(image.device) # text.input_ids: (B, L) text_output = self.text_encoder(text.input_ids, attention_mask=text.attention_mask, return_dict=True, mode='text') text_feat = F.normalize(self.text_proj(text_output.last_hidden_state[:, 0, :]), dim=-1) # 只取CLS Token做投影: (B, D_proj)\",\"构造图文匹配矩阵 (Target)\",\" # 构造图文匹配矩阵 idx = idx.view(-1, 1) # (B, 1) idx_all = torch.cat([idx.t(), self.idx_queue.clone().detach()], dim=1) # (1, B + Q) pos_idx = torch.eq(idx, idx_all).float() # (B, B + Q) sim_targets = pos_idx / pos_idx.sum(1, keepdim=True) # (B, B + Q)\",\"这里需要和 MoCo 论文实现进行区分，MoCo 中采用的是每个 query（图像）只对应一个 positive（key），因此正负样本是 one-hot 编码，contrastive loss 是严格的一对一；而在 BLIP 中，由于图文对来自自然语言描述，可能存在多个正样本（即同一个图像可以有多个 caption），而且动量队列可能重复包含同一个样本（multi-hot），因此这里构造 sim_targets 时不是用 one-hot，而是通过 pos_idx 判断当前图文对与队列中哪些样本是正对（idx 相等），然后用行归一化将多个正样本平均分配权重，形成 soft target 分布，从而使对比学习更加稳健。\",\"举例:\",\"# 1. 环境 idx = [[7], [13], [20]] # B=3 idx_queue = [1, 7, 5, 13, 9, 30] # Q=6 idx_all = [7, 13, 20, 1, 7, 5, 13, 9, 30] # shape: (1, 9) # 2. 构造图文匹配矩阵 pos_idx = torch.eq(idx, idx_all) # 第1行: [1, 0, 0, 0, 1, 0, 0, 0, 0] # 第2行: [0, 1, 0, 0, 0, 0, 1, 0, 0] # 第3行: [0, 0, 1, 0, 0, 0, 0, 0, 0] # 3. 进行归一化 # 第1行: [0.5, 0, 0, 0, 0.5, 0, 0, 0, 0] # 第2行: [0, 0.5, 0, 0, 0, 0, 0.5, 0, 0] # 第3行: [0, 0, 1.0, 0, 0, 0, 0, 0, 0]\",\"动量慢更新 + 软标签计算\",\" # 使用动量编码器获取特征 with torch.no_grad(): self._momentum_update() image_embeds_m = self.visual_encoder_m(image) # (B, N, D) image_feat_m = F.normalize(self.vision_proj_m(image_embeds_m[:, 0, :]), dim=-1) # (B, D_proj) image_feat_m_all = torch.cat([image_feat_m.t(), self.image_queue.clone().detach()], dim=1) # (D_proj, B + Q) text_output_m = self.text_encoder_m(text.input_ids, attention_mask=text.attention_mask,return_dict=True, mode='text') text_feat_m = F.normalize(self.text_proj_m(text_output_m.last_hidden_state[:, 0, :]), dim=-1) # (B, D_proj) text_feat_m_all = torch.cat([text_feat_m.t(), self.text_queue.clone().detach()], dim=1) # (D_proj, B + Q) sim_i2t_m = image_feat_m @ text_feat_m_all / self.temp # (B, B + Q) sim_t2i_m = text_feat_m @ image_feat_m_all / self.temp # (B, B + Q) sim_i2t_targets = alpha * F.softmax(sim_i2t_m, dim=1) + (1 - alpha) * sim_targets # (B, B + Q) sim_t2i_targets = alpha * F.softmax(sim_t2i_m, dim=1) + (1 - alpha) * sim_targets # (B, B + Q)\",\"计算ITC损失 + 更新动量队列\",\" # 当前 batch 与动量队列的相似度 sim_i2t = image_feat @ text_feat_m_all / self.temp # (B, B + Q) sim_t2i = text_feat @ image_feat_m_all / self.temp # (B, B + Q) # 对比损失（InfoNCE） loss_i2t = -torch.sum(F.log_softmax(sim_i2t, dim=1) * sim_i2t_targets, dim=1).mean() loss_t2i = -torch.sum(F.log_softmax(sim_t2i, dim=1) * sim_t2i_targets, dim=1).mean() loss_ita = (loss_i2t + loss_t2i) / 2 # 更新队列 idxs = concat_all_gather(idx) # (B*, 1) self._dequeue_and_enqueue(image_feat_m, text_feat_m, idxs)\",\"正样本编码 + 难负样本采样\",\" ### 图文匹配任务 (ITM) ### encoder_input_ids = text.input_ids.clone() # (B, L) encoder_input_ids[:, 0] = self.tokenizer.enc_token_id bs = image.size(0) # 正样本编码 output_pos = self.text_encoder(encoder_input_ids, attention_mask=text.attention_mask, encoder_hidden_states=image_embeds, encoder_attention_mask=image_atts, return_dict=True) # last_hidden_state: (B, L, D) # 采样难负样本（是否跨 GPU） if self.negative_all_rank: # 跨GPU部分实现，自信看源码进行学习 else: with torch.no_grad(): mask = torch.eq(idx, idx.t()) sim_i2t = image_feat @ text_feat.t() / self.temp sim_t2i = text_feat @ image_feat.t() / self.temp weights_i2t = F.softmax(sim_i2t,dim=1) weights_i2t.masked_fill_(mask, 0) weights_t2i = F.softmax(sim_t2i,dim=1) weights_t2i.masked_fill_(mask, 0) # select a negative image (from same rank) for each text image_embeds_neg = [] for b in range(bs): neg_idx = torch.multinomial(weights_t2i[b], 1).item() image_embeds_neg.append(image_embeds[neg_idx]) image_embeds_neg = torch.stack(image_embeds_neg,dim=0) # select a negative text (from same rank) for each image text_ids_neg = [] text_atts_neg = [] for b in range(bs): neg_idx = torch.multinomial(weights_i2t[b], 1).item() text_ids_neg.append(encoder_input_ids[neg_idx]) text_atts_neg.append(text.attention_mask[neg_idx]) text_ids_neg = torch.stack(text_ids_neg, dim=0) # (B, L) text_atts_neg = torch.stack(text_atts_neg, dim=0) # (B, L)\",\"idx 是当前 GPU 上 本地批次（batch）的样本索引（shape: (B, 1)）。\",\"idxs 是通过 concat_all_gather(idx) 得到的 所有 GPU 上所有样本索引的集合（shape: (total_batch_size, 1)）。\",\"构造两组负样本\",\" # [正样本，负样本] text_ids_all = torch.cat([encoder_input_ids, text_ids_neg], dim=0) # (2B, L) text_atts_all = torch.cat([text.attention_mask, text_atts_neg], dim=0) # (2B, L) # [负样本，正样本] image_embeds_all = torch.cat([image_embeds_neg, image_embeds], dim=0) # (2B, N, D) image_atts_all = torch.cat([image_atts, image_atts], dim=0) # (2B, N) # 两组负样本编码 output_neg = self.text_encoder(text_ids_all, attention_mask=text_atts_all, encoder_hidden_states=image_embeds_all, encoder_attention_mask=image_atts_all, return_dict=True)\",\"计算ITM损失 + 返回ITC损失和ITM损失\",\" # ITM 分类损失 vl_embeddings = torch.cat([output_pos.last_hidden_state[:, 0, :], output_neg.last_hidden_state[:, 0, :]], dim=0) # (3B, D) vl_output = self.itm_head(vl_embeddings) # (3B, 2) itm_labels = torch.cat([torch.ones(bs, dtype=torch.long), torch.zeros(2 * bs, dtype=torch.long)], dim=0).to(image.device) # (3B,) loss_itm = F.cross_entropy(vl_output, itm_labels) return loss_ita, loss_itm\"]},\"146\":{\"h\":\"过滤阶段\",\"t\":[\"当Filter模块在Coco数据集上，采用ITC和ITM目标执行完微调后，便得到了模态对齐好的图像编码器Vit 和 文本编码器Bert ， 然后我们便可以直接用训练好的Vit和Bert来做图文匹配和图文相似度计算了。\",\"class BLIP_ITM(nn.Module): def __init__(self, med_config = 'configs/med_config.json', image_size = 384, vit = 'base', vit_grad_ckpt = False, vit_ckpt_layer = 0, embed_dim = 256, ): self.visual_encoder, vision_width = create_vit(vit,image_size, vit_grad_ckpt, vit_ckpt_layer) self.tokenizer = init_tokenizer() self.text_encoder = BertModel(config=med_config, add_pooling_layer=False) self.vision_proj = nn.Linear(vision_width, embed_dim) self.text_proj = nn.Linear(text_width, embed_dim) self.itm_head = nn.Linear(text_width, 2) def forward(self, image, caption, match_head='itm'): image_embeds = self.visual_encoder(image) image_atts = torch.ones(image_embeds.size()[:-1],dtype=torch.long).to(image.device) text = self.tokenizer(caption, padding='max_length', truncation=True, max_length=35, return_tensors=\\\"pt\\\").to(image.device) if match_head=='itm': output = self.text_encoder(text.input_ids, attention_mask = text.attention_mask, encoder_hidden_states = image_embeds, encoder_attention_mask = image_atts, return_dict = True, ) itm_output = self.itm_head(output.last_hidden_state[:,0,:]) return itm_output elif match_head=='itc': text_output = self.text_encoder(text.input_ids, attention_mask = text.attention_mask, return_dict = True, mode = 'text') image_feat = F.normalize(self.vision_proj(image_embeds[:,0,:]),dim=-1) text_feat = F.normalize(self.text_proj(text_output.last_hidden_state[:,0,:]),dim=-1) sim = image_feat @ text_feat.t() return sim\"]},\"147\":{\"h\":\"BLIP 预训练\",\"t\":[\"BLIP 模型基于 CapFilt 模块增强后的数据集上，采用ITC，ITM，LM三个目标进行训练，以下首先给出的是 BLIP 模型的训练代码:\",\"def train(model, data_loader, optimizer, epoch, device, config): for i, (image, caption) in data_loader: optimizer.zero_grad() # ramp up alpha in the first 2 epochs alpha = config['alpha']*min(1,(epoch*len(data_loader)+i)/(2*len(data_loader))) loss_ita, loss_itm, loss_lm = model(image, caption, alpha = alpha) loss = loss_ita + loss_itm + loss_lm loss.backward() optimizer.step() def main(args, config): #### Dataset #### datasets = [create_dataset('pretrain', config, min_scale=0.2)] # 返回的caption前不添加prompt data_loader = create_loader(datasets,samplers,batch_size=[config['batch_size']], num_workers=[4], is_trains=[True], collate_fns=[None])[0] #### Model #### model = blip_pretrain(image_size=config['image_size'], vit=config['vit'], vit_grad_ckpt=config['vit_grad_ckpt'], vit_ckpt_layer=config['vit_ckpt_layer'], queue_size=config['queue_size']) optimizer = torch.optim.AdamW(params=model.parameters(), lr=config['init_lr'], weight_decay=config['weight_decay']) for epoch in range(start_epoch, config['max_epoch']): train(model, data_loader, optimizer, epoch, device, config)\",\"BLIP 预训练代码实现部分参考Moco论文实现，采用动量慢更新策略，整体流程和ALBEF模型实现一致，下面首先给出的是 BLIP 模型的 init 初始化方法:\",\"class BLIP_Pretrain(nn.Module): def __init__(self, med_config='configs/bert_config.json', # 文本编码器配置 image_size=224, # 输入图像大小 vit='base', # 使用的 ViT 模型类型（如 base、large） vit_grad_ckpt=False, # 是否使用梯度检查点（节省显存） vit_ckpt_layer=0, # 从第几层开始启用 checkpoint embed_dim=256, # 图文共享表示的嵌入维度 queue_size=57600, # 对比学习中图文特征队列长度 momentum=0.995, # 动量编码器的更新参数 ): super().__init__() # 1. 创建主视觉编码器（ViT） self.visual_encoder, vision_width = create_vit( vit, image_size, vit_grad_ckpt, vit_ckpt_layer, 0 ) # 2. 创建文本编码器（BERT） self.tokenizer = init_tokenizer() # 加载 tokenizer（默认 BERT） self.text_encoder = BertModel.from_pretrained( 'bert-base-uncased', config=encoder_config, add_pooling_layer=False ) # 3. 视觉 / 文本 特征映射到共享空间 self.vision_proj = nn.Linear(vision_width, embed_dim) # (D_v → D_e) self.text_proj = nn.Linear(text_width, embed_dim) # (D_t → D_e) # 4. 图文匹配（ITM）任务的二分类头 self.itm_head = nn.Linear(text_width, 2) # ======================= 动量编码器（Momentum Encoder） ======================= # # 用于构造 InfoNCE 的 soft target，与主模型参数不同步，而是 EMA 滑动平均更新 self.visual_encoder_m, _ = create_vit(vit, image_size) # 动量视觉编码器 self.vision_proj_m = nn.Linear(vision_width, embed_dim) self.text_encoder_m = BertModel( config=encoder_config, add_pooling_layer=False ) # 动量文本编码器 self.text_proj_m = nn.Linear(text_width, embed_dim) # 将主模型和动量模型参数组织成配对，用于拷贝和更新 self.model_pairs = [ [self.visual_encoder, self.visual_encoder_m], [self.vision_proj, self.vision_proj_m], [self.text_encoder, self.text_encoder_m], [self.text_proj, self.text_proj_m], ] self.copy_params() # 初始化时直接复制参数（后续 EMA 更新） # ======================= 特征队列初始化 ======================= # # 队列用于 InfoNCE 对比学习中的负样本缓存（增强样本多样性） self.register_buffer(\\\"image_queue\\\", torch.randn(embed_dim, queue_size)) # 图像队列：(D_e, Q) self.register_buffer(\\\"text_queue\\\", torch.randn(embed_dim, queue_size)) # 文本队列：(D_e, Q) self.register_buffer(\\\"queue_ptr\\\", torch.zeros(1, dtype=torch.long)) # 队列指针（循环更新） # 初始化队列为单位向量（便于计算归一化相似度） self.image_queue = nn.functional.normalize(self.image_queue, dim=0) self.text_queue = nn.functional.normalize(self.text_queue, dim=0) self.queue_size = queue_size self.momentum = momentum # InfoNCE 温度参数（可学习） self.temp = nn.Parameter(0.07 * torch.ones([])) # ======================= 文本解码器（用于 LM 任务） ======================= # self.text_decoder = BertLMHeadModel.from_pretrained( 'bert-base-uncased', config=decoder_config )\",\"BLIP 模型的前向传播流程和ALBEF实现基本一致，这里不过多进行展开:\",\"def forward(self, image, caption, alpha): # ===================== 1. 图像与文本特征提取 ===================== # # 图像编码：提取视觉特征 image_embeds = self.visual_encoder(image) # (B, N, D_v) image_atts = torch.ones(image_embeds.size()[:-1], dtype=torch.long).to(image.device) # (B, N) image_feat = F.normalize(self.vision_proj(image_embeds[:, 0, :]), dim=-1) # (B, D_e)，CLS特征 → 投影 → 归一化 # 文本编码：tokenize 文本 text = self.tokenizer(caption, padding='max_length', truncation=True, max_length=30, return_tensors=\\\"pt\\\").to(image.device) text_output = self.text_encoder(text.input_ids, attention_mask=text.attention_mask, return_dict=True, mode='text') text_feat = F.normalize(self.text_proj(text_output.last_hidden_state[:, 0, :]), dim=-1) # (B, D_e)，CLS特征 → 投影 → 归一化 # ===================== 2. 计算动量编码器输出，用于生成 soft target ===================== # with torch.no_grad(): self._momentum_update() # 图像动量编码器 image_embeds_m = self.visual_encoder_m(image) # (B, N, D_v) image_feat_m = F.normalize(self.vision_proj_m(image_embeds_m[:, 0, :]), dim=-1) # (B, D_e) # 构建图像所有对比特征 = 当前batch + 队列 image_feat_all = torch.cat([image_feat_m.T, self.image_queue.clone().detach()], dim=1) # (D_e, B+Q) # 文本动量编码器 text_output_m = self.text_encoder_m(text.input_ids, attention_mask=text.attention_mask, return_dict=True, mode='text') text_feat_m = F.normalize(self.text_proj_m(text_output_m.last_hidden_state[:, 0, :]), dim=-1) # (B, D_e) # 构建文本所有对比特征 = 当前batch + 队列 text_feat_all = torch.cat([text_feat_m.T, self.text_queue.clone().detach()], dim=1) # (D_e, B+Q) # 计算图 → 文本 和 文本 → 图 相似度（soft target） sim_i2t_m = image_feat_m @ text_feat_all / self.temp # (B, B+Q) sim_t2i_m = text_feat_m @ image_feat_all / self.temp # (B, B+Q) sim_targets = torch.zeros(sim_i2t_m.size()).to(image.device) sim_targets.fill_diagonal_(1) # 构造 hard target (对角线为正例) sim_i2t_targets = alpha * F.softmax(sim_i2t_m, dim=1) + (1 - alpha) * sim_targets # 软标签 + 硬标签混合 sim_t2i_targets = alpha * F.softmax(sim_t2i_m, dim=1) + (1 - alpha) * sim_targets # ===================== 3. 计算 InfoNCE 对比学习损失 (ITC) ===================== # sim_i2t = image_feat @ text_feat_all / self.temp # (B, B+Q) sim_t2i = text_feat @ image_feat_all / self.temp # (B, B+Q) loss_i2t = -torch.sum(F.log_softmax(sim_i2t, dim=1) * sim_i2t_targets, dim=1).mean() loss_t2i = -torch.sum(F.log_softmax(sim_t2i, dim=1) * sim_t2i_targets, dim=1).mean() loss_ita = (loss_i2t + loss_t2i) / 2 # 更新负样本队列 self._dequeue_and_enqueue(image_feat_m, text_feat_m) # ===================== 4. 图文匹配 (ITM) ===================== # # 用于多模态 cross-attention 编码的输入文本（替换 CLS） encoder_input_ids = text.input_ids.clone() encoder_input_ids[:, 0] = self.tokenizer.enc_token_id bs = image.size(0) # 正样本对 output_pos = self.text_encoder(encoder_input_ids, attention_mask=text.attention_mask, encoder_hidden_states=image_embeds, encoder_attention_mask=image_atts, return_dict=True) with torch.no_grad(): # 为 ITM 任务采样负样本索引（从 sim 分布中采样，避免选到自己） weights_t2i = F.softmax(sim_t2i[:, :bs], dim=1) + 1e-4 weights_t2i.fill_diagonal_(0) weights_i2t = F.softmax(sim_i2t[:, :bs], dim=1) + 1e-4 weights_i2t.fill_diagonal_(0) # select a negative image for each text image_embeds_neg = [] for b in range(bs): neg_idx = torch.multinomial(weights_t2i[b], 1).item() image_embeds_neg.append(image_embeds[neg_idx]) image_embeds_neg = torch.stack(image_embeds_neg,dim=0) # select a negative text for each image text_ids_neg = [] text_atts_neg = [] for b in range(bs): neg_idx = torch.multinomial(weights_i2t[b], 1).item() text_ids_neg.append(encoder_input_ids[neg_idx]) text_atts_neg.append(text.attention_mask[neg_idx]) text_ids_neg = torch.stack(text_ids_neg,dim=0) text_atts_neg = torch.stack(text_atts_neg,dim=0) # 合并正负样本对 text_ids_all = torch.cat([encoder_input_ids, text_ids_neg], dim=0) # (2B, L) text_atts_all = torch.cat([text.attention_mask, text_atts_neg], dim=0) # (2B, L) image_embeds_all = torch.cat([image_embeds_neg, image_embeds], dim=0) # (2B, N, D_v) image_atts_all = torch.cat([image_atts, image_atts], dim=0) # (2B, N) output_neg = self.text_encoder(text_ids_all, attention_mask=text_atts_all, encoder_hidden_states=image_embeds_all, encoder_attention_mask=image_atts_all, return_dict=True) # 提取 [CLS] 融合特征，用于二分类匹配 vl_embeddings = torch.cat([output_pos.last_hidden_state[:, 0, :], output_neg.last_hidden_state[:, 0, :]], dim=0) # (3B, D_t) vl_output = self.itm_head(vl_embeddings) # (3B, 2)，匹配or不匹配 itm_labels = torch.cat([ torch.ones(bs, dtype=torch.long), torch.zeros(2 * bs, dtype=torch.long) ], dim=0).to(image.device) loss_itm = F.cross_entropy(vl_output, itm_labels) # ===================== 5. 文本生成任务（LM） ===================== # decoder_input_ids = text.input_ids.clone() decoder_input_ids[:, 0] = self.tokenizer.bos_token_id # 用 [BOS] 替换 [CLS] decoder_targets = decoder_input_ids.masked_fill(decoder_input_ids == self.tokenizer.pad_token_id, -100) # 忽略pad位loss decoder_output = self.text_decoder(decoder_input_ids, attention_mask=text.attention_mask, encoder_hidden_states=image_embeds, encoder_attention_mask=image_atts, labels=decoder_targets, return_dict=True) loss_lm = decoder_output.loss # ===================== 6. 返回三个 loss ===================== # return loss_ita, loss_itm, loss_lm\"]},\"148\":{\"h\":\"ALBEF 论文\",\"t\":[\"Align before Fuse: Vision and Language Representation Learning with Momentum Distillation 论文简析\",\"论文链接: Align before Fuse: Vision and Language Representation Learning with Momentum Distillation 代码链接: https://github.com/salesforce/ALBEF\"]},\"149\":{\"h\":\"Introduction\",\"t\":[\"视觉-语言大规模预训练能提升多种视觉语言任务，但视觉和文本的token未对齐，导致多模态编码器难以有效建模图文交互。当前论文提出了一个基于对比损失的“先对齐后融合”（ALBEF）策略，通过对比学习先对齐图像和文本的表示，再用跨模态注意力融合，提升表示的准确性。并且ALBEF 不依赖目标检测器，也不需要高分辨率图像；同时通过引入动量蒸馏(momentum distillation)自训练方法，能更有效应对含噪声的网络数据，提高泛化能力。\",\"传统VLP方法依赖目标检测器提取区域特征，结合文本通过多模态编码器处理，面临：\",\"图像和文本特征空间不一致，交互难度大。\",\"目标检测器开销高，注释和计算开销大。\",\"网络图文数据噪声多，容易导致预训练过拟合，泛化差。\",\"ALBEF 采用无检测器的图像编码器和文本编码器独立编码，再用多模态编码器融合。设计图文对比（ITC）损失：\",\"对齐图文特征空间，简化跨模态融合。\",\"改善单模态编码语义理解。\",\"学习共同低维空间，促进硬负样本挖掘。\",\"提出动量蒸馏（MoD），用动量模型生成伪标签，缓解噪声影响，提升预训练及下游表现。\"]},\"150\":{\"h\":\"Related Work\",\"t\":[\"Vision-Language Representation Learning:\",\"当前视觉-语言表示学习主要分为两类：一类使用多模态 Transformer 编码器建模图文交互，适用于复杂推理任务但依赖目标检测器和高分辨率图像，计算开销大；另一类则采用独立的图像与文本编码器，通过对比学习在大规模图文对中对齐表示，虽在图文检索中效果出色，但难以处理复杂语义交互。ALBEF 融合两者优势，先用对比学习对齐图文表示，再通过跨模态注意力实现深度融合，同时摒弃目标检测器，在保证高性能的同时显著降低了计算成本，兼顾了效率与泛化能力。\",\"Knowledge Distillation:\",\"传统知识蒸馏通过教师模型指导学生模型提升性能，通常依赖预训练教师。近年来的在线蒸馏则使用多个同时训练的模型进行知识迁移。ALBEF 提出的 Momentum Distillation 属于自蒸馏的一种形式，通过使用自身参数的滑动平均作为教师，生成伪标签辅助训练。该方法无需额外模型，能缓解弱标注图文数据中的噪声问题，提升表示稳定性和泛化能力。\"]},\"151\":{\"h\":\"ALBEF\"},\"152\":{\"h\":\"Model Structure\",\"t\":[\"ALBEF 模型由三个主要部分组成：图像编码器、文本编码器和多模态编码器。图像编码器采用了预训练的 ViT-B/16（12 层视觉 Transformer），将输入图像编码为一系列嵌入向量。文本编码器和多模态编码器均为 6 层 Transformer，分别初始化自 BERTbase 的前 6 层和后 6 层。文本经过编码后生成的嵌入序列，会与图像嵌入一起送入多模态编码器进行融合。融合过程在多模态编码器的每一层中通过跨模态注意力（Cross Attention）实现，实现图文信息的深层交互。\"]},\"153\":{\"h\":\"Pre-training Objectives\",\"t\":[\"我们对 ALBEF 进行预训练，包含三个目标：在单模态编码器上进行图文对比学习（ITC），以及在多模态编码器上进行掩码语言模型（MLM）和图文匹配（ITM）。我们通过在线对比难样本挖掘来改进图文匹配（ITM）。\"]},\"154\":{\"h\":\"Image-Text Contrastive Learning\",\"t\":[\"图文对比学习旨在融合之前学习更好的单模态表示。它通过学习一个相似度函数\",\"使得配对的图文具有更高的相似度得分。这里 和 是线性变换，用于将 [CLS] 表征映射到归一化的低维（256维）向量。受 MoCo 启发，我们维护两个队列来存储动量单模态编码器最近的 个图文表示。动量编码器生成的归一化特征分别记为\",\"定义相似度函数为：\",\"对于每个图像和文本，我们计算归一化的图像到文本和文本到图像的 softmax 相似度：\",\"其中 是一个可学习的温度参数。令 和 分别表示真实的 one-hot 标签，负样本概率为 0，正样本概率为 1。图文对比损失定义为交叉熵 ：\"]},\"155\":{\"h\":\"Masked Language Modeling（MLM）\",\"t\":[\"Masked Language Modeling 利用图像和上下文文本共同预测被 mask 掉的单词。我们以 15% 的概率随机将输入文本中的 token 替换为特殊标记 [MASK]。设 表示被 mask 的文本， 表示模型预测的被 mask token 的概率分布。MLM 任务的目标是最小化交叉熵损失：\",\"其中 是 one-hot 词表分布，真实标签对应的概率为 1。\"]},\"156\":{\"h\":\"Image-Text Matching（ITM）\",\"t\":[\"Image-Text Matching 用于判断图文对是否匹配。我们使用多模态编码器输出的 [CLS] token 表征作为图文对的联合表示，接一个全连接层（FC），再通过 softmax 得到预测概率 ，最终计算 ITM 的交叉熵损失：\",\"其中 是二分类 one-hot 向量，表示图文对的真实匹配状态。\",\"我们提出了一种 零计算开销的 ITM 硬负样本采样策略：\",\"若图文语义相近但细节不同，则视为 hard negative；\",\"利用图文对比损失中的相似度作为度量，在 mini-batch 中为每张图像选择一个最相似的非匹配文本作为负样本；\",\"同样地，为每个文本选择一个最相似的非匹配图像。\",\"ALBEF 预训练总目标函数：\"]},\"157\":{\"h\":\"Momentum Distillation\",\"t\":[\"视觉-语言预训练所使用的图文对大多来自网页，因此存在较大的噪声。例如：正样本图文对往往关联性较弱，文本中可能包含与图像无关的信息，图像中也可能存在未被文本描述的实体。在对比学习（ITC）中，有些“负样本”文本可能实际上与图像语义一致；而在掩码语言建模（MLM）中，也可能存在多个与被 mask 单词同样合理甚至更好的替代词。但标准 one-hot 标签的监督会一律惩罚这些“非标答案”。\",\"为解决这一问题，ALBEF 提出使用 动量模型（Momentum Model）生成伪标签（pseudo-targets）进行蒸馏监督。动量模型是对主模型参数的滑动平均版本（exponential moving average），起到“老师模型”的作用。在训练中，主模型被训练去匹配动量模型的预测，从而提升鲁棒性和泛化能力。\",\"对比学习中的动量蒸馏:\",\"设动量编码器生成的相似度为：\",\"将其代入标准的对比学习 softmax 公式中，构造软标签（soft pseudo-target）。然后定义 ITC 的动量蒸馏损失为：\",\"这里的 KL 表示 Kullback-Leibler 散度，衡量模型预测分布与动量模型生成的软标签之间的差异。\",\"掩码语言建模中的动量蒸馏:\",\"设动量模型在图像 和被 mask 的文本 上预测得到的概率分布为 ，主模型的预测为 。对应的蒸馏损失定义为：\",\"这样的设计使得 MLM 模型不再被 one-hot 标签约束，可以学习更丰富的词汇表达，捕捉与图像内容相关的多种可能性。\",\"如论文中的图 2 所示，动量模型生成的伪标签往往比真实标签更具多样性和语义丰富性。例如：\",\"原始文本：\\\"polar bear in the [MASK]\\\" 真实标签：wild 伪标签前五名：zoo, pool, water, pond, wild\",\"这种伪标签不仅能补充视觉信息中的遗漏，还能提供更灵活的语义参考。\",\"通过引入动量蒸馏，ALBEF 能够：\",\"在噪声标签数据上提高学习效果；\",\"避免因 one-hot 标签过度惩罚合理预测；\",\"在多任务（如 ITC 和 MLM）中更稳定地训练；\",\"提高预训练模型在下游任务中的表现。\",\"动量蒸馏的总体损失是对原始监督信号与伪监督信号的加权组合，平衡其指导作用：\",\"其中 控制动量蒸馏信号的强度，实验中统一设为 0.4。\"]},\"158\":{\"h\":\"Code Implementation\"},\"159\":{\"h\":\"Train\",\"t\":[\"训练代码:\",\"def train(model, data_loader, optimizer, tokenizer, epoch, warmup_steps, device, scheduler, config): for i, (image, text) in enumerate(metric_logger.log_every(data_loader, print_freq, header)): optimizer.zero_grad() image = image.to(device,non_blocking=True) text_input = tokenizer(text, padding='longest', truncation=True, max_length=25, return_tensors=\\\"pt\\\").to(device) if epoch>0: alpha = config['alpha'] else: alpha = config['alpha']*min(1,i/len(data_loader)) loss_mlm, loss_ita, loss_itm = model(image, text_input, alpha = alpha) loss = loss_mlm + loss_ita + loss_itm loss.backward() optimizer.step()\",\"为何前期要让 α 慢慢增加？\",\"训练初期模型尚不稳定，动量分支的 soft label 不可靠。直接用 soft label 可能误导主模型。因此，先以 hard label 为主，逐渐引入 soft label 的指导。\",\"前期：alpha ≈ 0 → 以 one-hot 监督为主，训练稳定\",\"中期：alpha 上升 → soft label 引入更丰富的监督\",\"后期：alpha ≈ config['alpha'] → 强化多义性和类间相似度学习，提高泛化\",\"图中展示的是 ALBEF 模型训练过程中 alpha 参数的变化趋势：\",\"第一个 epoch（前 100 步）：alpha 线性从 0 增加到设定的最大值（如 0.5）。这种方式在训练初期让模型更多依赖于 one-hot 形式的监督信号，降低动量负样本带来的扰动。\",\"第二个 epoch 及之后：alpha 恒定为最大值（例如 0.5），意味着动量分布和 one-hot label 的加权比固定，开始充分利用动量编码器提供的软标签来训练。\"]},\"160\":{\"h\":\"Model Init\",\"t\":[\"ALBEF 模型初始化:\",\"def __init__(self, text_encoder = None, tokenizer = None, config = None, temp = 0.07, init_deit = True ): super().__init__() # 初始化 tokenizer（用于文本编码） self.tokenizer = tokenizer # MLM 任务中 mask 掉的 token 比例 self.mlm_probability = config['mlm_probability'] # 图文对比学习后的共同嵌入维度 embed_dim = config['embed_dim'] # 初始化视觉编码器（ViT backbone），输出: (B, N+1, 768) self.visual_encoder = VisionTransformer( img_size=config['image_res'], patch_size=16, embed_dim=768, depth=12, num_heads=12, mlp_ratio=4, qkv_bias=True, norm_layer=partial(nn.LayerNorm, eps=1e-6)) vision_width = config['vision_width'] # ViT 输出维度，通常为 768 # 加载文本编码器 BertConfig 配置 bert_config = BertConfig.from_json_file(config['bert_config']) # 加载文本编码器，输出: (B, L, hidden_size)，默认 hidden_size = 768 self.text_encoder = BertForMaskedLM.from_pretrained(text_encoder, config=bert_config) text_width = self.text_encoder.config.hidden_size # Bert 输出维度（默认 768） # 图像特征 → 共享嵌入空间（Linear projection）：(B, vision_width) → (B, embed_dim) self.vision_proj = nn.Linear(vision_width, embed_dim) # 文本特征 → 共享嵌入空间（Linear projection）：(B, text_width) → (B, embed_dim) self.text_proj = nn.Linear(text_width, embed_dim) # 学习温度系数 temp ∈ [0.001, 0.5]，用于对比学习中的 softmax 除法 self.temp = nn.Parameter(torch.ones([]) * config['temp']) # 对比学习中的队列长度（如 65536） self.queue_size = config['queue_size'] # 动量更新系数（如 0.995） self.momentum = config['momentum'] # ITM 分类头：输入为 text_encoder 最后一层的 CLS 特征 → 输出为二分类 (B, 2) self.itm_head = nn.Linear(text_width, 2) # =============== 构建动量编码器（结构与主模型相同，仅参数使用 EMA 更新）=============== self.visual_encoder_m = VisionTransformer( img_size=config['image_res'], patch_size=16, embed_dim=768, depth=12, num_heads=12, mlp_ratio=4, qkv_bias=True, norm_layer=partial(nn.LayerNorm, eps=1e-6)) self.vision_proj_m = nn.Linear(vision_width, embed_dim) self.text_encoder_m = BertForMaskedLM.from_pretrained(text_encoder, config=bert_config) self.text_proj_m = nn.Linear(text_width, embed_dim) # 将主编码器和动量编码器配对，用于 EMA 参数更新 self.model_pairs = [[self.visual_encoder,self.visual_encoder_m], [self.vision_proj,self.vision_proj_m], [self.text_encoder,self.text_encoder_m], [self.text_proj,self.text_proj_m], ] # 初始化动量编码器参数 = 主模型参数 self.copy_params() # =============== 初始化负样本队列 =============== # 图像特征队列：(embed_dim, queue_size) self.register_buffer(\\\"image_queue\\\", torch.randn(embed_dim, self.queue_size)) # 文本特征队列：(embed_dim, queue_size) self.register_buffer(\\\"text_queue\\\", torch.randn(embed_dim, self.queue_size)) # 当前入队位置指针，形状: (1,) self.register_buffer(\\\"queue_ptr\\\", torch.zeros(1, dtype=torch.long)) # 初始化队列特征为单位向量，便于之后相似度计算 self.image_queue = nn.functional.normalize(self.image_queue, dim=0) self.text_queue = nn.functional.normalize(self.text_queue, dim=0)\"]},\"161\":{\"h\":\"ITC\",\"t\":[\"ALBEF 模型前向传播中的 ITC 学习目标实现过程:\",\"def forward(self, image, text, alpha=0): # 1. 使用 ViT 对图像进行编码，输出图像特征 # image_embeds: (B, N+1, embed_dim)，N 个 patch + 1 个 CLS token image_embeds = self.visual_encoder(image) # 2. 构造图像的 attention mask，全部为1，表示无 padding # image_atts: (B, N+1)，与 image_embeds 保持一致 image_atts = torch.ones(image_embeds.size()[:-1], dtype=torch.long).to(image.device) # 3. 取出 CLS Token（图像全局语义），进行线性变换 + 归一化 # image_feat: (B, D)，D为投影后的embedding维度（如256） image_feat = F.normalize(self.vision_proj(image_embeds[:, 0, :]), dim=-1) # 4. 文本编码器（BERT）对文本进行编码 # text_output.last_hidden_state: (B, L, H)，L 为文本长度，H 为hidden size text_output = self.text_encoder.bert(text.input_ids, attention_mask=text.attention_mask, return_dict=True, mode='text') text_embeds = text_output.last_hidden_state # 5. 取出 CLS Token（文本全局语义），线性变换 + 归一化 # text_feat: (B, D) text_feat = F.normalize(self.text_proj(text_embeds[:, 0, :]), dim=-1) # ========== 以下为动量编码器分支（momentum encoder），不参与反向传播 ========== with torch.no_grad(): # 6. 更新动量编码器参数（对主编码器做 EMA） self._momentum_update() # 7. 动量图像编码器输出特征 # image_embeds_m: (B, N+1, embed_dim) # image_feat_m: (B, D) image_embeds_m = self.visual_encoder_m(image) image_feat_m = F.normalize(self.vision_proj_m(image_embeds_m[:, 0, :]), dim=-1) # 8. 拼接当前动量图像特征和图像队列（K 个历史负样本） # image_feat_m.T: (D, B) # image_queue: (D, K) # image_feat_all: (D, B + K) image_feat_all = torch.cat([image_feat_m.t(), self.image_queue.clone().detach()], dim=1) # 9. 动量文本编码器输出特征 # text_output_m.last_hidden_state: (B, L, H) # text_feat_m: (B, D) text_output_m = self.text_encoder_m.bert(text.input_ids, attention_mask=text.attention_mask, return_dict=True, mode='text') text_feat_m = F.normalize(self.text_proj_m(text_output_m.last_hidden_state[:, 0, :]), dim=-1) # 10. 拼接当前动量文本特征和文本队列 # text_feat_all: (D, B + K) text_feat_all = torch.cat([text_feat_m.t(), self.text_queue.clone().detach()], dim=1) # 11. 图像特征与所有文本特征做内积，计算相似度（B, B+K） sim_i2t_m = image_feat_m @ text_feat_all / self.temp sim_t2i_m = text_feat_m @ image_feat_all / self.temp # 12. 构造一对一的匹配目标（对角为正样本） # sim_targets: (B, B+K)，对角为1，其他为0 sim_targets = torch.zeros(sim_i2t_m.size()).to(image.device) sim_targets.fill_diagonal_(1) # 13. 构造 soft label（平滑过的对比目标） # alpha = 0 则为 hard label，alpha 越大越 soft sim_i2t_targets = alpha * F.softmax(sim_i2t_m, dim=1) + (1 - alpha) * sim_targets sim_t2i_targets = alpha * F.softmax(sim_t2i_m, dim=1) + (1 - alpha) * sim_targets # ========== 当前主分支计算相似度，用于 loss 反向传播 ========== # 14. 使用主分支特征与队列拼接结果计算图像-文本相似度（B, B+K） sim_i2t = image_feat @ text_feat_all / self.temp sim_t2i = text_feat @ image_feat_all / self.temp # 15. 计算交叉熵损失（基于 soft label 的 KL loss） loss_i2t = -torch.sum(F.log_softmax(sim_i2t, dim=1) * sim_i2t_targets, dim=1).mean() loss_t2i = -torch.sum(F.log_softmax(sim_t2i, dim=1) * sim_t2i_targets, dim=1).mean() # 16. 图文对比损失（取双向平均） loss_ita = (loss_i2t + loss_t2i) / 2 # 17. 将当前动量特征送入队列，更新队列 self._dequeue_and_enqueue(image_feat_m, text_feat_m)\",\"加入动量队列中的样本作为负样本，是为了扩大负样本池，提升训练难度、判别性和稳定性，使模型能学到更强的图文对齐表示。\"]},\"162\":{\"h\":\"ITM\",\"t\":[\"ALBEF 模型前向传播中的 ITM 学习目标实现过程:\",\"###=================================### # 正向图文对的前向传播（正样本） output_pos = self.text_encoder.bert( encoder_embeds = text_embeds, # 输入文本的嵌入表示 attention_mask = text.attention_mask, # 文本的注意力掩码 encoder_hidden_states = image_embeds, # 图像特征作为 cross-attention 的 encoder hidden state encoder_attention_mask = image_atts, # 图像 attention mask（通常为全 1） return_dict = True, # 返回结构化输出（字典） mode = 'fusion', # 模态融合模式 ) # ================================= # # 计算 ITC 相似度生成的 soft label，用于选择难负样本 with torch.no_grad(): bs = image.size(0) # batch size # 图像到文本的相似度权重（归一化) , sim_i2t维度为(B, B+K) , 这里只取前B个样本, 不考虑从动量队列拿到的负样本 weights_i2t = F.softmax(sim_i2t[:, :bs], dim=1) # 文本到图像的相似度权重（归一化） weights_t2i = F.softmax(sim_t2i[:, :bs], dim=1) # 屏蔽对角线（避免采样到自己） weights_i2t.fill_diagonal_(0) weights_t2i.fill_diagonal_(0) # ================================= # # 采样每个文本对应的负图像（hard negative） image_embeds_neg = [] for b in range(bs): neg_idx = torch.multinomial(weights_t2i[b], 1).item() # 按权重从当前行采样一个负样本索引 image_embeds_neg.append(image_embeds[neg_idx]) # 获取对应的负图像嵌入 image_embeds_neg = torch.stack(image_embeds_neg, dim=0) # [B, D] # 采样每个图像对应的负文本（hard negative） text_embeds_neg = [] text_atts_neg = [] for b in range(bs): neg_idx = torch.multinomial(weights_i2t[b], 1).item() text_embeds_neg.append(text_embeds[neg_idx]) # 获取对应的负文本嵌入 text_atts_neg.append(text.attention_mask[neg_idx]) # 同时获取对应的 attention mask text_embeds_neg = torch.stack(text_embeds_neg, dim=0) text_atts_neg = torch.stack(text_atts_neg, dim=0) # 构造新的图文对：正文本 + 负文本，负图像 + 正图像 # 共有 2N 个图文对：N 个正样本 + N 个负样本（正文负图 + 正图负文） text_embeds_all = torch.cat([text_embeds, text_embeds_neg], dim=0) text_atts_all = torch.cat([text.attention_mask, text_atts_neg], dim=0) image_embeds_all = torch.cat([image_embeds_neg, image_embeds], dim=0) image_atts_all = torch.cat([image_atts, image_atts], dim=0) # 所有图文对的前向传播（用于 ITM 分类） output_neg = self.text_encoder.bert( encoder_embeds = text_embeds_all, attention_mask = text_atts_all, encoder_hidden_states = image_embeds_all, encoder_attention_mask = image_atts_all, return_dict = True, mode = 'fusion', ) # 提取 [CLS] token 表征作为跨模态图文对表示，输入到 ITM 头 vl_embeddings = torch.cat([ output_pos.last_hidden_state[:, 0, :], # 正样本 [CLS] output_neg.last_hidden_state[:, 0, :] # 负样本 [CLS] ], dim=0) # 二分类：匹配 or 不匹配 vl_output = self.itm_head(vl_embeddings) # shape: [3N, 2] # 构造 ground-truth 标签：前 N 个为正样本（1），后 2N 个为负样本（0） itm_labels = torch.cat([ torch.ones(bs, dtype=torch.long), # N 个正样本 torch.zeros(2*bs, dtype=torch.long) # 2N 个负样本（正图负文 + 正文负图） ], dim=0).to(image.device) # 计算 ITM 的交叉熵损失 loss_itm = F.cross_entropy(vl_output, itm_labels)\",\"补充说明:\",\"ALBEF 在进行 CrossAttention 时，image features 会作为 key 和 value ，而 text features 作为 query:\",\"class BertSelfAttention(nn.Module): def forward( self, hidden_states, attention_mask=None, head_mask=None, encoder_hidden_states=None, encoder_attention_mask=None, past_key_value=None, output_attentions=False, ): # 1. text features 固定作为 query 计算来源 mixed_query_layer = self.query(hidden_states) # 2. 传入了 image features ，则做 cross attention is_cross_attention = encoder_hidden_states is not None if is_cross_attention: key_layer = self.transpose_for_scores(self.key(encoder_hidden_states)) value_layer = self.transpose_for_scores(self.value(encoder_hidden_states)) attention_mask = encoder_attention_mask else: key_layer = self.transpose_for_scores(self.key(hidden_states)) value_layer = self.transpose_for_scores(self.value(hidden_states)) query_layer = self.transpose_for_scores(mixed_query_layer) ...\",\"ALBEF 采用加权随机采样而非直接取相似度最大的负样本（argmax），是为了在突出“难负样本”的同时保持训练的稳定性和多样性，避免模型过拟合于极端负样本或伪负样本，从而提升泛化能力和鲁棒性。\"]},\"163\":{\"h\":\"MLM\",\"t\":[\"ALBEF 模型前向传播中的 MLM 学习目标实现过程:\",\"##================= MLM ========================## # 克隆一份 input_ids 和 labels，作为 MLM 的输入和标签副本 input_ids = text.input_ids.clone() labels = input_ids.clone() # 构造一个与 input_ids 同形状的矩阵，值为 mask 概率（例如 0.15） probability_matrix = torch.full(labels.shape, self.mlm_probability) # 对 input_ids 按照给定概率进行 [MASK] 操作，同时将对应的 labels 保留为原始 token id，其余位置设为 -100（忽略） input_ids, labels = self.mask(input_ids, self.text_encoder.config.vocab_size, image.device, targets=labels, probability_matrix = probability_matrix) # ===== 使用动量编码器对 masked 输入做前向传播，获取 soft target（Teacher 网络） ===== # 注意：这一步不计算梯度，仅用于生成 soft label with torch.no_grad(): logits_m = self.text_encoder_m( input_ids, attention_mask = text.attention_mask, # 文本 attention mask encoder_hidden_states = image_embeds_m, # 动量视觉特征 encoder_attention_mask = image_atts, # 图像 attention mask return_dict = True, return_logits = True, # 返回 logits 用于 soft label ) # ===== 主网络进行 MLM 前向传播，并引入 soft label 监督 ===== mlm_output = self.text_encoder( input_ids, attention_mask = text.attention_mask, encoder_hidden_states = image_embeds, # 主视觉特征（非动量） encoder_attention_mask = image_atts, return_dict = True, labels = labels, # 用于 standard cross-entropy 监督（hard label） soft_labels = F.softmax(logits_m, dim=-1), # soft label 来自动量编码器（Teacher） alpha = alpha # 混合比：控制 hard 和 soft loss 的权重 ) # 最终的 masked language modeling 损失 loss_mlm = mlm_output.loss\",\"mask 方法代码实现:\",\"def mask(self, input_ids, vocab_size, device, targets=None, masked_indices=None, probability_matrix=None): # Step 1: 生成掩码位置 if masked_indices is None: # 若未指定掩码位置，则按给定的概率矩阵进行伯努利采样，得到每个 token 是否被 mask masked_indices = torch.bernoulli(probability_matrix).bool() # Step 2: 屏蔽不可 mask 的位置（例如 [PAD] 和 [CLS]） masked_indices[input_ids == self.tokenizer.pad_token_id] = False masked_indices[input_ids == self.tokenizer.cls_token_id] = False # Step 3: 构造目标标签（只对被 mask 的位置计算 loss） if targets is not None: targets[~masked_indices] = -100 # 非 mask 位置的标签设为 -100，表示 loss 忽略 # Step 4: 对被 mask 的 token 进行替换（按 BERT 策略） # 80% 的 mask token 被替换为 [MASK] indices_replaced = torch.bernoulli(torch.full(input_ids.shape, 0.8)).bool() & masked_indices input_ids[indices_replaced] = self.tokenizer.mask_token_id # 10% 的 mask token 被替换为随机 token（噪声） indices_random = torch.bernoulli(torch.full(input_ids.shape, 0.5)).bool() & masked_indices & ~indices_replaced random_words = torch.randint(vocab_size, input_ids.shape, dtype=torch.long).to(device) input_ids[indices_random] = random_words[indices_random] # 剩下的 10% 保持原样（不修改 token） # Step 5: 返回掩码后的 input_ids 和（可选的）标签 targets if targets is not None: return input_ids, targets else: return input_ids\",\"text_encoder 前向传播代码实现:\",\"def forward( self, input_ids=None, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None, inputs_embeds=None, encoder_embeds=None, # 外部传入的 encoder embeddings（不常用） encoder_hidden_states=None, # 图像编码器输出（作为 cross-attn 的 K,V） encoder_attention_mask=None, # 图像部分的 attention mask labels=None, # MLM 标签（只在 MLM 模式中提供） output_attentions=None, output_hidden_states=None, return_dict=None, is_decoder=False, mode='multi_modal', # 模式控制，支持 'fusion'（图文融合）等 soft_labels=None, # 蒸馏 soft labels，来自 momentum encoder alpha=0, # 蒸馏损失的权重 return_logits=False, # 是否仅返回 logits（用于 momentum 计算） ): # Step 1: 调用 BERT 模型（支持 encoder-decoder 模式，支持 fusion 模式） outputs = self.bert( input_ids, attention_mask=attention_mask, token_type_ids=token_type_ids, position_ids=position_ids, head_mask=head_mask, inputs_embeds=inputs_embeds, encoder_embeds=encoder_embeds, encoder_hidden_states=encoder_hidden_states, encoder_attention_mask=encoder_attention_mask, output_attentions=output_attentions, output_hidden_states=output_hidden_states, return_dict=return_dict, is_decoder=is_decoder, mode=mode, ) # Step 2: 获取 transformer 输出的 token 表征（[B, L, D]） sequence_output = outputs[0] # Step 3: 计算每个 token 的预测分布（[B, L, vocab_size]） prediction_scores = self.cls(sequence_output) # Step 4: 若只需输出 logits（如 momentum 模型前向），直接返回 if return_logits: return prediction_scores # Step 5: 计算标准 MLM 交叉熵损失（仅对 label ≠ -100 的位置有效） masked_lm_loss = None if labels is not None: loss_fct = CrossEntropyLoss() # 忽略标签为 -100 的位置 masked_lm_loss = loss_fct(prediction_scores.view(-1, self.config.vocab_size), labels.view(-1)) # Step 6: 若提供 soft labels（如知识蒸馏），计算 KL-style 蒸馏损失 if soft_labels is not None: # 蒸馏损失：soft label 和当前输出的 softmax 分布之间的 KL 散度 loss_distill = -torch.sum( F.log_softmax(prediction_scores, dim=-1) * soft_labels, dim=-1 ) loss_distill = loss_distill[labels != -100].mean() # 混合两种损失：标准 MLM loss 和 蒸馏 loss masked_lm_loss = (1 - alpha) * masked_lm_loss + alpha * loss_distill # Step 7: 根据 return_dict 控制输出格式（支持 tuple 或 dict） if not return_dict: output = (prediction_scores,) + outputs[2:] return ((masked_lm_loss,) + output) if masked_lm_loss is not None else output # 标准化输出（MaskedLMOutput 是 huggingface 定义的一个结构体） return MaskedLMOutput( loss=masked_lm_loss, logits=prediction_scores, hidden_states=outputs.hidden_states, attentions=outputs.attentions, )\",\"注意:\",\"HuggingFace 的 CrossEntropyLoss 默认会忽略标签为 -100 的位置，这是 PyTorch 官方文档中的行为规范：\",\"class CrossEntropyLoss(_WeightedLoss): def __init__( self, weight: Optional[Tensor] = None, size_average=None, ignore_index: int = -100, reduce=None, reduction: str = \\\"mean\\\", label_smoothing: float = 0.0, )\"]},\"164\":{\"h\":\"BEIT2 论文\",\"t\":[\"BEiT v2: Masked Image Modeling with Vector-Quantized Visual Tokenizers 论文解读\",\"论文链接: BEiT v2: Masked Image Modeling with Vector-Quantized Visual Tokenizers 代码链接: https://github.com/microsoft/unilm/tree/master/beit2\"]},\"165\":{\"h\":\"引言\",\"t\":[\"掩码图像建模（MIM）通过恢复被掩码的图像块，能够在自监督学习中捕捉丰富的上下文信息，但大多数方法仅在低层像素上操作。\",\"现有重建目标可以分为三类：\",\"低层图像元素（如原始像素）\",\"手工特征（如 HOG 特征）\",\"视觉 token\",\"这些方法大多忽略了高层语义信息，而语言模型中的掩码词都是高层语义，这启发了 MIM 可以借助语义感知监督进行改进。\",\"BEIT V2 提出 向量量化知识蒸馏（VQ-KD），将连续的语义空间离散化为紧凑的视觉 token。VQ-KD 训练过程：\",\"编码器将输入图像转为离散 token，基于可学习码本（codebook）。\",\"解码器根据教师模型编码的语义特征重建图像特征。\",\"训练完成后，VQ-KD 的编码器被用作 BEIT V2 的语义视觉分词器，离散 token 作为监督信号进行 MIM 预训练。引入 图像块聚合策略，让 [CLS] token 聚合全局信息，解决传统 MIM 过度关注局部块重建而忽略全局表示的问题。\"]},\"166\":{\"h\":\"方法\"},\"167\":{\"h\":\"预训练阶段一: 向量量化知识蒸馏算法用于d-VAE预训练\",\"t\":[\"BEIT V2 继承了 BEIT 的掩码图像建模（Masked Image Modeling）框架，其核心思想是将每张图像通过视觉 tokenizer 转换为一组离散的视觉 token，然后训练模型去恢复被遮挡的 token。每个 token 对应图像中的一个 patch，从而实现对局部图像信息的建模（如图 2 所示）。训练过程中，引入了向量量化知识蒸馏（VQ-KD）算法，用于训练视觉 tokenizer，使其能够有效将图像映射到离散编码。\",\"图像表示部分，输入图像 会被划分为 个 patch ，每个 patch 大小为 ，在实验中 224 × 224 图像被划分为 14 × 14 个 patch，每个 patch 16 × 16。所有 patch 展平并线性映射得到 Transformer 的输入嵌入 ，用于后续编码。\",\"在 VQ-KD 训练中，视觉 tokenizer 由编码器和量化器组成：\",\"编码器将图像转换为 patch 表征 ；\",\"量化器在代码本 中查找每个 的最近邻进行量化，得到离散 token ，公式为：\",\"其中 表示 归一化，等价于基于余弦相似度查找最近代码。量化后的 归一化代码 输入解码器，解码器输出 尝试重建教师模型（如 DINO 或 CLIP）的语义特征 。训练目标最大化 decoder 输出与教师特征的余弦相似度，同时通过 stop-gradient 机制处理量化不可导问题，梯度从 decoder 输入传递到 encoder 输出。训练目标公式为：\",\"其中 表示停止梯度操作， 为训练图像数据集。\",\"向量量化训练中常见问题是代码本塌陷（codebook collapse），即只使用少量编码。为缓解此问题，VQ-KD 使用经验策略：\",\"查找最近邻时对代码本嵌入进行 归一化，并将维度降至 32；\",\"在输入 decoder 前将低维嵌入映射回高维空间；\",\"代码本嵌入使用指数移动平均（EMA）更新，EMA 能更稳定地追踪模型训练动态。\",\"整体而言，BEIT V2 结合视觉 tokenizer、VQ-KD 和 Transformer 架构，通过 patch 级别的离散表示学习与教师特征对齐，实现对图像语义信息的高效编码与预训练。\"]},\"168\":{\"h\":\"代码实现\"},\"169\":{\"h\":\"码本_EMA\",\"t\":[\"class EmbeddingEMA(nn.Module): def __init__(self, num_tokens, codebook_dim, decay=0.99, eps=1e-5, kmeans_init=True, codebook_init_path=''): \\\"\\\"\\\" 向量量化的 codebook（码本）管理类，采用 EMA（指数滑动平均）进行更新。 参数: - num_tokens: 码本的向量个数（即字典大小） - codebook_dim: 每个向量的维度 - decay: EMA 的衰减系数 - eps: 避免数值错误的小常数 - kmeans_init: 是否使用 k-means 初始化 - codebook_init_path: 若提供，则从已有 checkpoint 加载初始化码本 \\\"\\\"\\\" super().__init__() self.num_tokens = num_tokens self.codebook_dim = codebook_dim self.decay = decay self.eps = eps # ========== 初始化权重 ========== if codebook_init_path == '': # 如果没有提供预训练的 codebook if not kmeans_init: # 随机初始化，并做 L2 归一化，保证每个 embedding 向量长度为 1 weight = torch.randn(num_tokens, codebook_dim) weight = l2norm(weight) else: # 若选择 kmeans_init，则先用全零矩阵占位，稍后再通过 k-means 初始化 weight = torch.zeros(num_tokens, codebook_dim) # 标记是否完成初始化（True=已初始化，False=未初始化） self.register_buffer('initted', torch.Tensor([not kmeans_init])) else: # 如果给定路径，则直接加载预训练的 codebook 权重 print(f\\\"load init codebook weight from {codebook_init_path}\\\") codebook_ckpt_weight = torch.load(codebook_init_path, map_location='cpu') weight = codebook_ckpt_weight.clone() self.register_buffer('initted', torch.Tensor([True])) # ========== 需要维护的参数 ========== # codebook 权重（不参与梯度更新，使用 EMA 更新） self.weight = nn.Parameter(weight, requires_grad = False) # 每个 cluster 的大小（计数），用来做 EMA 更新 self.cluster_size = nn.Parameter(torch.zeros(num_tokens), requires_grad = False) # 每个 cluster embedding 的均值，用于 EMA 更新 self.embed_avg = nn.Parameter(weight.clone(), requires_grad = False) # 是否启用更新 self.update = True @torch.jit.ignore def init_embed_(self, data): \\\"\\\"\\\" 用 k-means 对码本进行初始化。 - data: encoder 输出的样本数据 (N, D) \\\"\\\"\\\" if self.initted: # 若已初始化，则跳过 return print(\\\"Performing K-means init for codebook\\\") # 调用 kmeans 获取初始的 cluster 中心和 cluster 大小 embed, cluster_size = kmeans(data, self.num_tokens, 10, use_cosine_sim = True) # 更新权重和 cluster_size self.weight.data.copy_(embed) self.cluster_size.data.copy_(cluster_size) # 设置为已初始化状态 self.initted.data.copy_(torch.Tensor([True]))\"]},\"170\":{\"h\":\"向量量化器\",\"t\":[\"向量量化器负责将连续的视觉特征映射到离散的视觉 token，该过程借助内部维护的 cookbook 完成，本节我们先来详细解析一下它的实现逻辑:\",\"class NormEMAVectorQuantizer(nn.Module): def __init__(self, n_embed, embedding_dim, beta, decay=0.99, eps=1e-5, statistic_code_usage=True, kmeans_init=False, codebook_init_path=''): super().__init__() # codebook 向量的维度（即每个 embedding 的维数） self.codebook_dim = embedding_dim # codebook 的大小（有多少个离散 token） self.num_tokens = n_embed # commitment loss 的权重系数 self.beta = beta # EMA 更新的衰减系数 self.decay = decay # codebook，使用 EMA 更新（非梯度更新） # 这里的 EmbeddingEMA 类负责存储和更新 codebook 向量 # 参数： # - num_tokens: codebook 的大小 # - codebook_dim: 每个向量的维度 # - decay, eps: EMA 更新超参 # - kmeans_init: 是否用 k-means 初始化 codebook # - codebook_init_path: 是否从文件加载已有的 codebook self.embedding = EmbeddingEMA( self.num_tokens, self.codebook_dim, decay, eps, kmeans_init, codebook_init_path ) # 是否统计每个 code 的使用频率（防止 dead code） self.statistic_code_usage = statistic_code_usage if statistic_code_usage: # cluster_size 用来存储每个 code 的使用计数，注册为 buffer，随模型保存 self.register_buffer('cluster_size', torch.zeros(n_embed))\",\" @torch.jit.ignore def init_embed_(self, data): \\\"\\\"\\\" 使用 k-means 对 codebook 进行初始化。 只会执行一次，之后 self.initted 会标记为 True。 \\\"\\\"\\\" if self.initted: return print(\\\"Performing Kmeans init for codebook\\\") # 在输入数据 data 上运行 k-means embed, cluster_size = kmeans(data, self.num_tokens, 10, use_cosine_sim = True) # 把 k-means 得到的聚类中心赋值给 codebook self.weight.data.copy_(embed) # 把每个簇的样本数存下来 self.cluster_size.data.copy_(cluster_size) # 标记为已初始化 self.initted.data.copy_(torch.Tensor([True]))\",\"k-means 的计算步骤可以总结为以下几个核心环节：\",\"初始化簇中心\",\"从样本中随机选取 num_clusters 个向量作为初始中心，或者使用其他方法（如 k-means++）。\",\"计算样本与中心的距离/相似度\",\"对每个样本计算它与所有簇中心的距离（欧氏距离）或相似度（余弦相似度）。\",\"样本分配\",\"将每个样本分配到最近的簇（或相似度最高的簇），形成簇成员集合。\",\"统计簇信息\",\"统计每个簇的样本数量（用于更新中心和处理空簇）。\",\"更新簇中心\",\"对每个簇，将簇内样本向量求平均，得到新的中心。\",\"若某簇为空，则保留原中心不变。\",\"如果使用余弦相似度，更新后的中心需要做 L2 归一化。\",\"迭代\",\"重复步骤 2–5，直到达到预定迭代次数或收敛条件。\",\"输出结果\",\"返回最终的簇中心和每个簇的样本数。\",\"这整个过程就是 k-means 聚类的标准迭代流程：分配 → 更新 → 循环。\",\"def kmeans(samples, num_clusters, num_iters = 10, use_cosine_sim = False): # samples: 输入样本，形状 (N, D)，N 是样本数，D 是维度 # num_clusters: 聚类簇数，即要分成多少类 # num_iters: k-means 的迭代次数 # use_cosine_sim: 是否用余弦相似度（默认用欧氏距离） # 提取样本维度、数据类型和设备 dim, dtype, device = samples.shape[-1], samples.dtype, samples.device # 从样本中随机选取 num_clusters 个向量作为初始中心 means = sample_vectors(samples, num_clusters) # 重复迭代更新聚类中心 for _ in range(num_iters): if use_cosine_sim: # 使用余弦相似度：直接点积即可（因为向量一般做过 l2norm） # 结果 shape: (N, K)，表示每个样本和每个中心的相似度 dists = samples @ means.t() else: # 使用欧氏距离： (x - μ)^2 # diffs: (N, 1, D) - (1, K, D) = (N, K, D) diffs = rearrange(samples, 'n d -> n () d') \\\\ - rearrange(means, 'c d -> () c d') # 计算平方距离并取负号（因为后面要用 max 来找最近中心） dists = -(diffs ** 2).sum(dim = -1) # shape: (N, K) # 找到每个样本最近的中心（或相似度最大的中心） # buckets: (N,) 每个样本对应的簇编号 buckets = dists.max(dim = -1).indices # 统计每个簇的样本数量 bins = torch.bincount(buckets, minlength = num_clusters) # (K,) # 标记哪些簇没有分配到样本（空簇） zero_mask = bins == 0 # 防止除以 0，把空簇的计数临时设为 1 bins_min_clamped = bins.masked_fill(zero_mask, 1) # 初始化新的簇中心 (K, D)，全部为 0 new_means = buckets.new_zeros(num_clusters, dim, dtype = dtype) # 把属于同一簇的样本向量加到对应的中心上 # repeat(buckets, 'n -> n d', d = dim): 把 (N,) 扩展成 (N, D)，方便 scatter_add new_means.scatter_add_(0, repeat(buckets, 'n -> n d', d = dim), samples) # 除以该簇的样本数，得到新的簇中心 new_means = new_means / bins_min_clamped[..., None] # 如果用余弦相似度，记得对中心做 l2norm 归一化 if use_cosine_sim: new_means = l2norm(new_means) # 更新簇中心： # - 如果该簇是空簇（zero_mask=True），保留旧的中心 # - 否则更新为新的中心 means = torch.where(zero_mask[..., None], means, new_means) # 返回最终的簇中心和每个簇的样本数 return means, bins\",\"在 量化前做 L2 归一化，主要有几个原因：\",\"避免数值尺度差异\",\"原始特征向量 可能不同维度、不同样本之间的数值范围差异很大。\",\"如果直接计算欧氏距离，大的数值范围会主导距离计算，导致不公平。\",\"L2 归一化后，每个向量都被缩放到单位长度（模长 = 1），使得比较时主要依赖 方向差异 而不是数值大小。\",\"提高稳定性\",\"在训练过程中，如果向量的范数变化剧烈，会导致距离计算不稳定，进而影响 codebook 的更新。\",\"归一化可以避免过大的梯度和数值爆炸，稳定 EMA 更新。\",\"class NormEMAVectorQuantizer(nn.Module): def __init__(self, n_embed, embedding_dim, beta, decay=0.99, eps=1e-5, statistic_code_usage=True, kmeans_init=False, codebook_init_path=''): \\\"\\\"\\\" 基于 EMA（Exponential Moving Average）的向量量化器（Vector Quantizer） 用于 VQ-VAE 或类似模型。 参数： - n_embed: 码本中向量的数量（token 数量） - embedding_dim: 每个码本向量的维度 - beta: 重构损失中的量化损失系数 - decay: EMA 更新衰减系数 - eps: 防止除零的小常数 - statistic_code_usage: 是否统计每个码本向量的使用频率 - kmeans_init: 是否使用 K-means 初始化码本 - codebook_init_path: 初始化码本的路径 \\\"\\\"\\\" super().__init__() # 保存码本的维度和 token 数量 self.codebook_dim = embedding_dim self.num_tokens = n_embed self.beta = beta self.decay = decay # 使用 EMA 的可学习嵌入表 # EmbeddingEMA 内部会实现 EMA 更新和量化逻辑 self.embedding = EmbeddingEMA( self.num_tokens, self.codebook_dim, decay, eps, kmeans_init, codebook_init_path ) # 是否统计码本向量的使用频率 self.statistic_code_usage = statistic_code_usage if statistic_code_usage: # cluster_size 用于记录每个码本向量被使用的次数 # register_buffer 不会被认为是可训练参数，但会随模型一起保存/加载 self.register_buffer('cluster_size', torch.zeros(n_embed)) # 分布式训练支持 # 如果当前环境支持分布式训练并已初始化，则使用 all_reduce 同步各 GPU 的码本使用统计 if distributed.is_available() and distributed.is_initialized(): print(\\\"ddp is enable, so use ddp_reduce to sync the statistic_code_usage for each gpu!\\\") self.all_reduce_fn = distributed.all_reduce else: # 单 GPU 或未初始化分布式训练时，直接使用 Identity（不做任何操作） self.all_reduce_fn = nn.Identity()\",\"def forward(self, z): \\\"\\\"\\\" 前向传播函数，实现向量量化（Vector Quantization）和 EMA 更新 参数: - z: 输入特征图, shape (batch, channel, height, width) 返回: - z_q: 量化后的特征图，shape 同输入 - loss: 量化损失 - encoding_indices: 每个向量对应的码本索引 \\\"\\\"\\\" # 将输入从 (B, C, H, W) 转换为 (B, H, W, C) 以便处理通道维 z = rearrange(z, 'b c h w -> b h w c') # L2 归一化 z = l2norm(z) # 展平特征图，每一行对应一个向量 (num_vectors, embedding_dim) z_flattened = z.reshape(-1, self.codebook_dim) # 初始化码本（如果需要） self.embedding.init_embed_(z_flattened) # 计算每个向量与码本中所有向量的欧氏距离平方 d = z_flattened.pow(2).sum(dim=1, keepdim=True) + \\\\ self.embedding.weight.pow(2).sum(dim=1) - 2 * \\\\ torch.einsum('bd,nd->bn', z_flattened, self.embedding.weight) # 'n d -> d n' # 为每个向量找到最近的码本索引 encoding_indices = torch.argmin(d, dim=1) # 将编码索引映射回码本向量并 reshape 成原来的特征图形状 z_q = self.embedding(encoding_indices).view(z.shape) # one-hot 编码 encodings = F.one_hot(encoding_indices, self.num_tokens).type(z.dtype) # 非训练模式下统计码本使用情况 if not self.training: with torch.no_grad(): cluster_size = encodings.sum(0) self.all_reduce_fn(cluster_size) # 分布式同步 ema_inplace(self.cluster_size, cluster_size, self.decay) # 训练模式下更新 EMA 码本 if self.training and self.embedding.update: bins = encodings.sum(0) self.all_reduce_fn(bins) # 更新 cluster_size 的 EMA ema_inplace(self.cluster_size, bins, self.decay) # 避免除零 zero_mask = (bins == 0) bins = bins.masked_fill(zero_mask, 1.) # 计算每个码本向量的累加特征 embed_sum = z_flattened.t() @ encodings self.all_reduce_fn(embed_sum) # 归一化并 L2 正则化 embed_normalized = (embed_sum / bins.unsqueeze(0)).t() embed_normalized = l2norm(embed_normalized) # 对未使用的码本向量保持原值 embed_normalized = torch.where(zero_mask[..., None], self.embedding.weight, embed_normalized) # 更新 EMA 码本权重 norm_ema_inplace(self.embedding.weight, embed_normalized, self.decay) # 量化损失 loss = self.beta * F.mse_loss(z_q.detach(), z) # 保留梯度 z_q = z + (z_q - z).detach() # reshape 回原始输入形状 (B, C, H, W) z_q = rearrange(z_q, 'b h w c -> b c h w') return z_q, loss, encoding_indices\"]},\"171\":{\"h\":\"BEIT3 论文\",\"t\":[\"Image as a Foreign Language: BEiT Pretraining for All Vision and Vision-Language Tasks 论文解读\",\"论文链接: Image as a Foreign Language: BEiT Pretraining for All Vision and Vision-Language Tasks 代码链接: https://github.com/microsoft/unilm/tree/master/beit3\"]},\"172\":{\"h\":\"DINO 论文\",\"t\":[\"Emerging Properties in Self-Supervised Vision Transformers 论文解读\",\"论文链接: Emerging Properties in Self-Supervised Vision Transformers 代码链接: https://github.com/facebookresearch/dino\"]},\"173\":{\"h\":\"引言\",\"t\":[\"Vision Transformer（ViT）近期成为卷积神经网络（convnets）的替代方案，在视觉识别任务中表现出竞争力。但与 convnets 相比，ViT 存在以下不足：\",\"计算开销更大\",\"需要更多训练数据\",\"提取的特征不具备独特优势\",\"研究者提出一个问题：是否是 监督式预训练 限制了 Transformer 在视觉中的潜力？在 NLP 任务中，Transformer 的成功很大程度上得益于 自监督学习（如 BERT 的掩码预测、GPT 的语言建模），这些预训练目标利用上下文信息提供了更丰富的学习信号，而不仅仅是单一标签。相比之下，图像监督学习往往把丰富的视觉信息压缩为一个类别标签，导致潜在信息损失。因此，研究者探索 自监督学习是否能为 ViT 带来新的特性。\",\"论文通过研究自监督预训练对 ViT 特征的影响，得到以下核心结论（部分如图1所示）：\",\"显式的语义分割信息: 自监督 ViT 特征中会自然出现场景布局与物体边界，这些信息可以直接在最后一个 Transformer block 的自注意力模块中读取。相比之下，监督 ViT 和 convnets 并不显式包含这些特征。\",\"优异的 k-NN 分类性能: 在完全不做微调、线性分类器训练或数据增强的情况下，单纯使用最近邻分类器（k-NN），自监督 ViT 在 ImageNet 上可达到 78.3% top-1 准确率。\",\"分割掩码的普遍性与关键条件: 分割掩码的涌现似乎是自监督方法的普遍属性，但要想在 k-NN 上取得良好性能，必须结合以下组件：\",\"动量编码器（momentum encoder）\",\"多视角裁剪增强（multi-crop augmentation）\",\"小 patch 的重要性: 使用更小的 patch 能显著提升 ViT 特征质量。\",\"基于以上发现，作者提出了 DINO（self-distillation with no labels），它可以被理解为一种 无标签的知识蒸馏：\",\"学生网络通过交叉熵损失，直接预测教师网络（由动量编码器构建）的输出。\",\"为避免模型塌缩，仅需在教师输出上应用 居中（centering）与锐化（sharpening）。\",\"相比之下，其他方法使用的复杂组件（如 predictor、先进归一化方式或对比损失）并未带来额外收益。\",\"性能表现：\",\"在 ImageNet 线性分类基准上，DINO + ViT-Base（小 patch）达到 80.1% top-1，显著超越之前的自监督方法。\",\"在 ResNet-50 上，DINO 的表现与最新的自监督系统相当。\",\"灵活性与通用性：\",\"DINO 同时适用于 ViT 和 convnets，无需对架构或归一化方式做修改。\",\"计算效率：\",\"在资源有限的场景下，仅需 2 台 8-GPU 服务器训练 3 天，DINO + ViT 就能在 ImageNet 线性基准上达到 76.1% top-1，超越了同规模 convnets 的自监督系统，同时计算开销更低。\"]},\"174\":{\"h\":\"相关工作\"},\"175\":{\"h\":\"\",\"t\":[\"自监督学习主要经历了以下几类方法：\",\"实例分类（Instance Classification）：把每张图像当作一个独立类别，训练模型去区分它们（允许数据增强后的一致性）。但问题是，当数据规模增大时，显式地学习分类器无法很好扩展。\",\"NCE（噪声对比估计）方法：通过比较图像特征而不是分类，避免了巨量类别的学习。但这种方法要求一次性比较大量样本，因此需要 超大 batch size 或 记忆库（memory bank）。\",\"聚类式方法：自动将实例分组，从而缓解对大规模比较的需求。\",\"无须区分图像的学习方法：近期研究发现，不必显式区分图像也能学到好特征。典型例子是 BYOL，它通过让学生特征去匹配由 动量编码器（momentum encoder） 生成的教师特征来学习。即使去掉动量编码器，BYOL 仍然能工作，但性能下降。\",\"在 BYOL 的启发下，出现了一系列扩展方向：\",\"匹配更复杂的表示\",\"将特征训练为匹配 均匀分布\",\"通过 白化（whitening） 来约束特征学习\",\"DINO 借鉴了 BYOL 的思想，但不同点在于：它使用 不同的相似性匹配损失，并且 学生和教师完全相同的架构。因此，DINO 补充了 BYOL 的观点，把自监督学习解释为 一种无标签的 Mean Teacher 自蒸馏（self-distillation）。\"]},\"176\":{\"h\":\"\",\"t\":[\"自训练（Self-training） 的目标是：利用少量标注，将知识传播到大量无标签数据中，以提升特征质量。这种传播方式有两类：\",\"硬标签分配（hard assignments）\",\"软标签分配（soft assignments）\",\"当使用软标签时，这种方法通常被称为 知识蒸馏（Knowledge Distillation），最初是为了让小模型模仿大模型的输出，从而实现模型压缩。\",\"Xie 等人 提出，蒸馏还能用于将软伪标签传播到无标签数据，这表明 自训练与知识蒸馏本质上是相关的。\",\"在此基础上，DINO 进一步发展：\",\"将知识蒸馏扩展到 无标签场景。\",\"与过去依赖 固定、预训练教师模型 的方法不同，DINO 的教师模型在训练过程中是 动态更新的。\",\"这样一来，知识蒸馏不再是自监督预训练之后的 后处理步骤，而是直接作为 自监督目标函数。\",\"此外，DINO 也与 协同蒸馏（Codistillation） 有关。协同蒸馏中，学生与教师使用相同架构，并在训练中相互蒸馏。但不同的是：在协同蒸馏里，教师也会从学生蒸馏；而在 DINO 中，教师参数是通过 学生参数的指数移动平均（EMA） 来更新的。\"]},\"177\":{\"h\":\"方法\"},\"178\":{\"h\":\"基于知识蒸馏的自监督学习\",\"t\":[\"DINO（Distillation with No Labels）整体框架与近年来的自监督学习方法类似（如SimCLR、BYOL等），但其核心思想借鉴了 知识蒸馏（Knowledge Distillation）。在该框架中，我们训练一个学生网络 去匹配一个教师网络 的输出，二者参数分别为 和 。\",\"对于输入图像 ，两者都会输出一个 维的概率分布，分别记为 和 。这些分布由网络输出经过 softmax 归一化得到：\",\"其中， 是温度参数，控制分布的平滑程度；教师网络也有类似公式，只是温度为 。\",\"在传统的知识蒸馏中，学生通过最小化交叉熵损失来学习匹配教师的分布：\",\"DINO在此基础上引入 多视角（multi-crop）策略：\",\"从同一张图片中生成多个视角（裁剪），形成集合 。\",\"包含两张分辨率较高的 全局视角，以及多张较低分辨率的 局部视角。\",\"学生网络处理所有视角，教师网络只处理全局视角，从而实现 局部-全局对齐。\",\"最终损失函数为：\",\"在默认参数设置下：\",\"全局视角分辨率为 ，覆盖原图超过50%区域。\",\"局部分辨率为 ，覆盖小于50%的区域。\",\"与传统知识蒸馏不同，DINO的教师网络不是固定的，而是由学生网络迭代生成：\",\"冻结教师：在一个epoch内固定教师参数，效果不错。\",\"直接拷贝学生参数：无法收敛。\",\"EMA（指数滑动平均）更新：效果最佳。\",\"更新规则为：\",\"其中 随训练进程按余弦调度从 0.996 增加到 1。这一机制类似 Mean Teacher，教师的表现始终优于学生，从而为学生提供更高质量的特征目标。\",\"网络 由两部分组成：\",\"Backbone ：可以是 ViT 或 ResNet。\",\"投影头 ：由三层 MLP（隐藏维度2048）、 归一化、以及一个权重归一化的全连接层组成。\",\"值得注意的是：\",\"DINO不使用预测器（predictor），因此学生和教师网络架构完全相同。\",\"ViT没有使用BN（Batch Normalization），因此整个系统BN-free。\",\"在自监督学习中，如果所有样本映射到相同的表示，会出现 坍塌问题。DINO采用以下机制来避免：\",\"居中（Centering）：防止某一维度主导表示，但容易导致均匀分布坍塌。\",\"锐化（Sharpening）：通过较低温度参数 增强分布尖锐性，但风险是过度集中。\",\"结合使用：居中与锐化效果互补，可以有效避免坍塌。\",\"其中，居中操作等价于给教师输出加一个偏置项 ，更新方式为：\",\"其中 为动量参数， 为batch size。该方法依赖于 一阶统计量，能适应不同batch大小。\"]},\"179\":{\"h\":\"实现细节\",\"t\":[\"Vision Transformer (ViT) 的机制\",\"ViT 将图像切分为不重叠的 patch（本文常用 或 ），每个 patch 通过线性层转为 embedding。序列中额外加入一个可学习的 token（称为 [CLS]），它用于聚合全局信息，并在其输出位置接上投影头 。虽然 [CLS] token 并不对应标签或监督，但为了与前人工作保持一致，依然称之为 class token。\",\"这些 patch token 和 [CLS] token 被输入到标准的 Transformer 网络，网络采用 pre-norm 的 LayerNorm。Transformer 由自注意力层与前馈层组成，并带有跳跃连接。自注意力层通过 attention 机制让每个 token 能够参考其他 token 的表示，进而更新自身表示。\",\"实现细节\",\"预训练在 无标签的 ImageNet 上进行。\",\"优化器：AdamW\",\"批量大小：1024（ViT-S/16 下分布在 16 个 GPU 上）\",\"学习率：前 10 个 epoch 内线性升至基础值，基础值遵循线性缩放规则：\",\"学习率调度：余弦退火\",\"权重衰减：同样采用余弦调度，从 0.04 增加到 0.4\",\"温度：学生温度 在前 30 个 epoch 内从 0.04 线性升到 0.07；教师温度 \",\"数据增强：采用 BYOL 的增强方式（颜色抖动、高斯模糊、光照变换 solarization），并结合 multi-crop；同时使用双三次插值（bicubic interpolation）调整位置编码以适配不同尺度\",\"评估协议\",\"自监督学习的常见评估方式有两类：\",\"线性评估：冻结特征，训练线性分类器；训练阶段使用随机裁剪缩放和水平翻转，测试阶段用中心裁剪来报告准确率。\",\"微调评估：以预训练权重初始化网络，并在训练过程中更新参数。\",\"但这两种方法对超参数较为敏感，例如学习率不同会导致准确率差异较大。因此，论文还引入了 k-NN 最近邻分类器 来简化特征质量评估：\",\"将预训练模型冻结，用它提取并存储下游任务训练集的特征\",\"对于输入图片，找到其特征的 个最近邻，由它们投票决定分类\",\"实验发现 的效果最好，且在大多数实验中表现稳定\",\"这种方法的优势在于：\",\"不需要超参数调节\",\"不依赖数据增强\",\"只需一次遍历下游数据集即可完成评估\",\"因此大大简化了特征评估的流程。\"]},\"180\":{\"h\":\"消融实验\"},\"181\":{\"h\":\"Patch大小的重要性\",\"t\":[\"研究发现，更小的Patch尺寸能显著提升ViT-S的k-NN分类性能（如表5所示）。例如：\",\"ViT-S/16 → ViT-S/8 → ViT-S/5，性能逐步提升\",\"ViT-B同样表现出这种趋势\",\"这种提升并不依赖增加模型参数，但会牺牲吞吐率：\",\"5×5 patch 的吞吐率仅 44 im/s\",\"8×8 patch 的吞吐率为 180 im/s\",\"因此，更小的Patch能带来准确率提升，但需要付出计算速度代价。\"]},\"182\":{\"h\":\"教师网络的选择\",\"t\":[\"在DINO中，教师网络扮演关键角色。实验结果表明：\",\"使用 上一轮迭代的学生网络 作为教师，模型无法收敛，除非增加额外的归一化。\",\"使用 前一个epoch的学生网络 作为教师，模型不会崩溃，k-NN结果与MoCo-v2、BYOL等框架接近。\",\"使用 动量教师 时效果最佳，显著优于上述方法。\",\"进一步分析（如图6所示）：\",\"动量教师在整个训练过程中始终优于学生模型，无论是ViT还是ResNet-50。\",\"这一现象在其他动量方法（如MoCo）中未被观察到。\",\"作者将动量教师解释为一种 指数衰减的Polyak-Ruppert平均，相当于在训练中持续进行模型集成，构建出性能更强的教师来指导学生学习。\"]},\"183\":{\"h\":\"避免崩溃\",\"t\":[\"DINO训练中可能出现两种形式的崩溃：\",\"均匀输出：模型对所有输入输出一致的分布\",\"单维主导：输出仅集中在一个维度\",\"DINO通过 居中（centering） 和 目标锐化（sharpening） 来避免这两类崩溃：\",\"居中操作抑制单维主导，但会推动输出趋向均匀\",\"锐化操作则产生相反作用，抑制均匀输出\",\"作者用交叉熵公式来解释：\",\"其中，若 ，则输出为常量，表示发生崩溃。实验（如图7所示）表明：\",\"缺少居中 → 收敛为0，出现单维崩溃\",\"缺少锐化 → 收敛为 ，出现均匀崩溃\",\"同时使用居中和锐化 → 两种崩溃被平衡并避免\"]},\"184\":{\"h\":\"计算需求\",\"t\":[\"在两台8-GPU服务器上训练ViT-S/16 DINO模型时，作者对比了不同的 multi-crop策略：\",\"无multi-crop（2×224²）：72.5%准确率，耗时46小时，显存9.3G\",\"multi-crop (2×224²+10×96²)：74.6%准确率，仅需24小时，显存15.4G\",\"可见：\",\"multi-crop 提升了准确率/训练时间的性价比\",\"更多视角数（如6×、10×96²）带来的提升逐渐减弱\",\"DINO最终在两台8-GPU、3天内达到了 76.1% top-1准确率，超越了同规模CNN的自监督方法，同时计算需求更低\"]},\"185\":{\"h\":\"小批量训练\",\"t\":[\"DINO同样可以在小batch下训练（如表9所示）：\",\"默认 batch size = 1024\",\"batch size = 128 时性能略低，但仍能达到较高水平\",\"batch size = 128 的实验仅需1张GPU即可运行\",\"batch size = 8 时，训练50个epoch能达到35.2%准确率，显示了在极小显存条件下训练大模型的潜力\",\"学习率采用线性缩放：\",\"不过，小batch训练可能需要重新调整超参数（如动量率）才能达到最佳效果。\"]},\"186\":{\"h\":\"代码解析\",\"t\":[\"从本节开始我们将对官方开源的 DINO 模型代码实现进行详细讲解，下图给出的是 DINO 模型的运行完整流程图:\",\"按照 DINO 模型的训练流程，第一步首先是对 输入图像 进行数据增强，生成 两张全局视角图像 + 若干局部视角图像， 该过程由 DataAugmentationDINO 类实现，代码如下:\",\"class DataAugmentationDINO(object): \\\"\\\"\\\" 数据增强类，用于 DINO 训练。 主要思想：从一张输入图像生成多个视角（multi-crop）， 包括 2 张全局裁剪图像（224x224）和若干张局部裁剪图像（96x96）。 \\\"\\\"\\\" def __init__(self, global_crops_scale, local_crops_scale, local_crops_number): # 基础增强：随机翻转 + 颜色抖动 + 随机灰度化 flip_and_color_jitter = transforms.Compose([ transforms.RandomHorizontalFlip(p=0.5), # 以 50% 概率水平翻转 transforms.RandomApply( # 以 80% 概率执行颜色抖动 [transforms.ColorJitter( brightness=0.4, # 亮度变化 contrast=0.4, # 对比度变化 saturation=0.2, # 饱和度变化 hue=0.1 # 色调变化 )], p=0.8 ), transforms.RandomGrayscale(p=0.2), # 以 20% 概率转为灰度图 ]) # 标准化（Imagenet 预训练均值/方差） normalize = transforms.Compose([ transforms.ToTensor(), # 转换为 Tensor transforms.Normalize( (0.485, 0.456, 0.406), # mean (0.229, 0.224, 0.225) # std ), ]) # ----------- 全局裁剪 1 ----------- self.global_transfo1 = transforms.Compose([ # 随机裁剪并缩放到 224x224 transforms.RandomResizedCrop(224, scale=global_crops_scale, interpolation=Image.BICUBIC), flip_and_color_jitter, utils.GaussianBlur(1.0), # 高斯模糊（概率 100%） normalize, ]) # ----------- 全局裁剪 2 ----------- self.global_transfo2 = transforms.Compose([ transforms.RandomResizedCrop(224, scale=global_crops_scale, interpolation=Image.BICUBIC), flip_and_color_jitter, utils.GaussianBlur(0.1), # 高斯模糊（概率 10%） utils.Solarization(0.2), # 以 20% 概率进行太阳化增强（反转亮部） normalize, ]) # ----------- 局部裁剪 ----------- self.local_crops_number = local_crops_number # 局部裁剪数量 self.local_transfo = transforms.Compose([ transforms.RandomResizedCrop(96, scale=local_crops_scale, interpolation=Image.BICUBIC), flip_and_color_jitter, utils.GaussianBlur(p=0.5), # 高斯模糊（概率 50%） normalize, ]) def __call__(self, image): \\\"\\\"\\\" 输入一张图像，返回多个增强后的 crop。 输出顺序： [全局视角1, 全局视角2, 局部视角1, 局部视角2, ...] \\\"\\\"\\\" # 先生成两张全局 crop crops = [self.global_transfo1(image), self.global_transfo2(image)] # 再生成若干张局部 crop for _ in range(self.local_crops_number): crops.append(self.local_transfo(image)) return crops\",\"特别注意初始化方法中传入的 global_crops_scale 和 local_crops_scale 参数 :\",\" # Multi-crop parser.add_argument('--global_crops_scale', type=float, nargs='+', default=(0.4, 1.0), help=\\\"Scale range for global crops.\\\") parser.add_argument('--local_crops_number', type=int, default=8, help=\\\"Number of local crops (0 disables multi-crop).\\\") parser.add_argument('--local_crops_scale', type=float, nargs='+', default=(0.05, 0.4), help=\\\"Scale range for local crops.\\\")\",\"*_crops_scale 是 随机裁剪区域的相对尺度范围，即原始图像面积的比例。\",\"参数形式：*_crops_scale = (min_scale, max_scale)\",\"作用：控制 随机裁剪区域的最小和最大面积比例。\",\"举例：\",\"如果 global_crops_scale = (0.4, 1.0)\",\"随机裁剪的区域面积 ∈ [40%, 100%] 原图面积之间。\",\"也就是说，有时裁掉少量边缘（接近原图），有时只取 40% 的图像内容（更聚焦）。\",\"裁剪后再统一缩放到 224 × 224，作为模型输入。\",\"由于 DINO 采用多视角图像输入，对于学生模型来说，一个批次图像经过增强后，会得到 2+n 个来自不同视角下的批次图像:\",\"为了同时处理多视角图像输入，DINO 使用了 装饰器模式 ，设计 MultiCropWrapper 类来将输入图像批次列表按照分辨率进行分组：\",\"[0,2) 区间对应 224 分辨率 ， [2,6) 对应 96 分辨率\",\"将分辨率相同的批次合并后输入模型，拼接结果:\",\"完整代码实现如下:\",\"class MultiCropWrapper(nn.Module): \\\"\\\"\\\" 一个封装类，用于处理多视角输入（multi-crop inputs）。 不同分辨率的输入会被分组，每一组在 backbone 中分别进行一次前向计算， 得到的特征拼接后再送入 head 中处理。 \\\"\\\"\\\" def __init__(self, backbone, head): super(MultiCropWrapper, self).__init__() # 去掉 backbone 中原本为 ImageNet 分类准备的全连接层（fc, head） # 因为这里是自监督学习，不需要类别分类器 backbone.fc, backbone.head = nn.Identity(), nn.Identity() self.backbone = backbone # 特征提取网络 self.head = head # 投影头（projection head），用于后续对比学习 def forward(self, x): # 保证输入是 list（多 crop 的场景可能传进来的是多个张量） if not isinstance(x, list): x = [x] # 获取每个输入 crop 的分辨率（最后一个维度 size） # torch.unique_consecutive 会返回连续相同值的唯一值及计数 # return_counts=True 表示返回每个唯一值的计数 # torch.cumsum 累积求和，得到每组 crop 的结束索引 idx_crops = torch.cumsum(torch.unique_consecutive( torch.tensor([inp.shape[-1] for inp in x]), # 取每个 crop 的宽度 return_counts=True, )[1], 0) # 初始化 start_idx = 0 # 创建一个空 tensor 用于保存所有特征，放到和输入相同的 device 上 output = torch.empty(0).to(x[0].device) # 遍历不同分辨率的分组 for end_idx in idx_crops: # 将相同分辨率的 crop 拼接（batch 化），一起送入 backbone _out = self.backbone(torch.cat(x[start_idx: end_idx])) # 有些 backbone（如 XCiT）返回的是 tuple，这里只取第一个元素（主特征） if isinstance(_out, tuple): _out = _out[0] # 将这一批特征拼接到输出中 output = torch.cat((output, _out)) # 更新下一个起始位置 start_idx = end_idx # 所有特征拼接完成后，送入 head 得到最终表示 return self.head(output)\",\"下面我们来看 DINO 模型完整的训练流程:\",\"def train_dino(args): \\\"\\\"\\\" 在单进程下运行完整的 DINO 训练循环 步骤： 1. 构建多视图增强 (Multi-crop augmentations) 和数据集 / DataLoader 2. 构建学生 (Student) / 教师 (Teacher) 网络，并附加 DINO 头 3. 用学生初始化教师网络，教师梯度冻结 4. 创建损失函数、优化器及余弦调度器 (学习率、权重衰减、EMA momentum) 5. 标准 float32 训练循环，每轮迭代更新 EMA 教师参数 \\\"\\\"\\\" # ===================== # 1. 数据准备 # ===================== # 构建 DINO 的多视图增强策略：2 个全局裁剪 + N 个局部裁剪 transform = DataAugmentationDINO( args.global_crops_scale, args.local_crops_scale, args.local_crops_number, ) # 使用 ImageFolder 数据集，要求目录结构为： # data_path/class_x/*.jpg # ImageFolder 会根据子文件夹名自动生成 class 索引，并返回 (PIL image, label) dataset = datasets.ImageFolder(args.data_path, transform=transform) # 创建 DataLoader data_loader = torch.utils.data.DataLoader( dataset, shuffle=True, # 打乱数据顺序 batch_size=args.batch_size, num_workers=args.num_workers, # 多线程加载数据 pin_memory=True, # CUDA 加速 drop_last=True, # 丢弃最后不足 batch 的数据 ) print(f\\\"数据加载完成: {len(dataset)} 张图片. Batch size: {args.batch_size}\\\") # ===================== # 2. 构建学生/教师网络 # ===================== # 使用相同的骨干网络 (Backbone) 构建学生和教师，并附加 DINO head student_backbone = vits.__dict__[args.arch]( patch_size=args.patch_size, drop_path_rate=args.drop_path_rate # DropPath 用于正则化 ) teacher_backbone = vits.__dict__[args.arch](patch_size=args.patch_size) embed_dim = student_backbone.embed_dim # ViT 输出 embedding 维度 # 构建学生网络 (Student) + DINO head student = utils.MultiCropWrapper( student_backbone, DINOHead( embed_dim, args.out_dim, use_bn=args.use_bn_in_head, # 是否在 head 使用 BN norm_last_layer=args.norm_last_layer, # 是否规范化最后一层 ) ) # 构建教师网络 (Teacher) + DINO head teacher = utils.MultiCropWrapper( teacher_backbone, DINOHead(embed_dim, args.out_dim, args.use_bn_in_head), ) # ===================== # 3. 初始化教师网络 # ===================== # 教师网络初始参数与学生网络相同 teacher.load_state_dict(student.state_dict()) # 教师网络不参与梯度更新，仅通过 EMA 更新参数 for p in teacher.parameters(): p.requires_grad = False print(f\\\"学生/教师网络构建完成: arch={args.arch}, embed_dim={embed_dim}\\\") # ===================== # 4. 构建 DINO 损失函数 # ===================== # DINOLoss 接收学生输出、教师输出和当前 epoch 信息 dino_loss = DINOLoss( args.out_dim, args.local_crops_number + 2, # 总视图数量: 2 个全局 + N 个局部 args.warmup_teacher_temp, args.teacher_temp, args.warmup_teacher_temp_epochs, args.epochs, ) # ===================== # 5. 构建优化器 # ===================== # 对参数进行分组：对 bias / norm 等不使用 weight decay params_groups = utils.get_params_groups(student) optimizer = torch.optim.AdamW(params_groups) # ===================== # 6. 学习率、权重衰减、EMA momentum 调度器 # ===================== # 使用余弦调度器，按迭代次数调整 base_lr = args.lr * (args.batch_size / 256.0) # 学习率按 batch_size 线性缩放 lr_schedule = utils.cosine_scheduler( base_lr, args.min_lr, args.epochs, len(data_loader), warmup_epochs=args.warmup_epochs, ) wd_schedule = utils.cosine_scheduler( args.weight_decay, args.weight_decay_end, args.epochs, len(data_loader), ) momentum_schedule = utils.cosine_scheduler( args.momentum_teacher, 1.0, args.epochs, len(data_loader) ) # ===================== # 7. 训练循环 # ===================== for epoch in range(args.epochs): student.train() # 学生网络训练模式 teacher.train() # 教师网络不更新梯度，但 train 模式保持 BN 行为 for it, (images, _) in enumerate(data_loader): # --------------------- # 每次迭代更新学习率和权重衰减 # --------------------- gid = it + epoch * len(data_loader) # 全局迭代索引 for i, pg in enumerate(optimizer.param_groups): pg[\\\"lr\\\"] = lr_schedule[gid] if i == 0: pg[\\\"weight_decay\\\"] = wd_schedule[gid] # --------------------- # 前向计算 + 损失 # 教师网络只看 2 个全局裁剪 # 学生网络看所有裁剪 (2 个全局 + N 个局部) # --------------------- teacher_output = teacher(images[:2]) # 仅前 2 个全局裁剪 student_output = student(images) # 所有裁剪 loss = dino_loss(student_output, teacher_output, epoch) # --------------------- # 反向传播 (仅学生网络) # --------------------- optimizer.zero_grad() loss.backward() # 训练初期冻结学生网络最后一层 utils.cancel_gradients_last_layer(epoch, student, args.freeze_last_layer) # 更新学生网络参数 optimizer.step() # --------------------- # EMA 更新教师网络参数 # --------------------- with torch.no_grad(): m = momentum_schedule[gid] # 当前迭代 EMA momentum for ps, pt in zip(student.parameters(), teacher.parameters()): pt.data.mul_(m).add_((1 - m) * ps.detach().data)\",\"DINOHead 将 [CLS] token 投影到 65536 维空间，是为了：\",\"增强训练稳定性（避免塌缩）。\",\"分离“表征空间”和“对比空间”。\",\"通过超大维度的“语义字典”让模型学习更细粒度、更丰富的表征。\",\"部分代码细节没有详细介绍，大家请自行阅读源代码\",\"最后来看一下 DINOLoss 类的实现:\",\"class DINOLoss(nn.Module): \\\"\\\"\\\" DINO 损失函数类，支持温度调度、中心化(center)和多视图(crop)处理。 功能说明： - 对教师输出进行温度锐化(sharpening)，并维护一个移动中心(center) 来稳定训练。 - 计算跨视图的交叉熵损失：每个教师的全局视图监督所有学生视图， 但不监督与其索引相同的学生视图。 \\\"\\\"\\\" def __init__(self, out_dim, ncrops, warmup_teacher_temp, teacher_temp, warmup_teacher_temp_epochs, nepochs, student_temp=0.1, center_momentum=0.9): super().__init__() self.student_temp = student_temp # 学生输出 softmax 的温度 self.center_momentum = center_momentum # 中心更新的 EMA 动量 self.ncrops = ncrops # 输入图像裁剪数量 self.register_buffer(\\\"center\\\", torch.zeros(1, out_dim)) # 初始化教师输出中心向量 # 教师温度调度表 # 前 warmup_teacher_temp_epochs 采用线性增长，从 warmup_teacher_temp 到 teacher_temp # 后续 epoch 固定为 teacher_temp self.teacher_temp_schedule = np.concatenate(( np.linspace(warmup_teacher_temp, teacher_temp, warmup_teacher_temp_epochs), np.ones(nepochs - warmup_teacher_temp_epochs) * teacher_temp )) def forward(self, student_output, teacher_output, epoch): \\\"\\\"\\\" 计算跨视图交叉熵损失。 输入： - student_output: 学生模型输出，包含所有裁剪的拼接结果 - teacher_output: 教师模型输出，仅包含全局视图 - epoch: 当前训练轮数，用于教师温度调度 处理流程： 1. 学生输出按温度缩放并拆分为每个裁剪的输出 2. 教师输出减去中心并进行温度锐化 3. 每个教师视图监督除同索引学生视图外的所有学生视图 \\\"\\\"\\\" # 学生输出按温度缩放，并拆分为 ncrops 个裁剪 student_out = student_output / self.student_temp student_out = student_out.chunk(self.ncrops) # 教师输出：减去中心并进行温度锐化 temp = self.teacher_temp_schedule[epoch] # 当前 epoch 的教师温度 teacher_out = F.softmax((teacher_output - self.center) / temp, dim=-1) teacher_out = teacher_out.detach().chunk(2) # 仅两张全局裁剪用于教师监督 total_loss = 0 # 总损失 n_loss_terms = 0 # 用于计算平均损失的项数 # 遍历每个教师视图 for iq, q in enumerate(teacher_out): # 遍历每个学生视图 for v in range(len(student_out)): if v == iq: # 不监督同索引的学生视图 continue # 计算交叉熵损失 loss = torch.sum(-q * F.log_softmax(student_out[v], dim=-1), dim=-1) total_loss += loss.mean() n_loss_terms += 1 # 对所有损失求平均 total_loss /= n_loss_terms # 更新教师输出中心 self.update_center(teacher_output) return total_loss @torch.no_grad() def update_center(self, teacher_output): \\\"\\\"\\\" 使用当前 batch 教师输出更新 EMA 中心 公式： center = center * center_momentum + batch_center * (1 - center_momentum) \\\"\\\"\\\" batch_center = teacher_output.mean(dim=0, keepdim=True) # 计算 batch 中心 self.center = self.center * self.center_momentum + batch_center * (1 - self.center_momentum)\",\"DINO 不对同索引的学生视图进行监督，是为了 避免学生只学到平凡的输入匹配，强制学生跨视图对齐，才能让表示真正学到 语义一致性，而不是表面相似性。\"]},\"187\":{\"h\":\"书生·万象多模态大模型（InternVL 1.0）\",\"t\":[\"InternVL 1.0: Scaling up Vision Foundation Models and Aligning for Generic Visual-Linguistic Tasks 论文简析\",\"论文链接: https://arxiv.org/abs/2312.14238 代码链接: https://github.com/OpenGVLab/InternVL\"]},\"188\":{\"h\":\"摘要\",\"t\":[\"InternVL是一个大规模视觉-语言基础模型，旨在解决当前视觉与视觉-语言基础模型发展滞后于大型语言模型（LLMs）的问题。该模型通过将视觉基础模型扩展到60亿参数，并利用多源网络图像-文本数据进行渐进式对齐训练，成功实现了视觉与语言模型在参数规模和特征表示上的协调。InternVL在32个通用视觉-语言任务中表现出色，包括图像分类、语义分割、视频分类、图像/视频-文本检索以及多模态对话系统等，展现了强大的视觉能力和与LLMs的无缝集成潜力，为多模态大模型的发展提供了重要贡献。\"]},\"189\":{\"h\":\"简介\",\"t\":[\"研究背景与问题: 大型语言模型（LLMs）的快速发展推动了通用人工智能（AGI）系统的进步，但视觉和视觉-语言基础模型的发展却相对滞后。现有的视觉-语言大模型（VLLMs）通常使用轻量级的“胶水层”（如QFormer或线性投影）来对齐视觉和语言模型的特征，但这种方法存在三个主要限制：\",\"参数规模不匹配：LLMs的参数规模已达千亿级，而视觉编码器通常仅约10亿参数，限制了LLM的能力利用。\",\"表征不一致：视觉模型通常基于纯视觉数据或BERT系列模型训练，与LLMs的特征空间存在差异。\",\"低效连接：轻量级胶水层难以捕捉跨模态的复杂交互。\",\"解决方案与核心设计: 论文提出 InternVL，通过以下关键设计解决上述问题：\",\"参数平衡的视觉与语言组件：包含60亿参数的视觉编码器（InternViT-6B）和80亿参数的语言中间件（QLLaMA），后者作为强大的“胶水层”重组视觉特征。\",\"一致的表征对齐：使用多语言LLaMA初始化中间件，确保视觉编码器与LLMs的特征空间一致。\",\"渐进式图像-文本对齐策略：先在大规模噪声数据上对比学习，再在高质量数据上生成学习，逐步提升模型性能（如图1c所示）。\",\"模型优势\",\"多功能性：可作为独立视觉编码器或与语言中间件结合，支持感知、检索、生成和对话任务。\",\"强大性能：在ImageNet分类、ADE20K分割、视频检索等任务中达到SOTA（如图2所示）。\",\"LLM友好性：与LLaMA、Vicuna等LLMs无缝集成，推动多模态应用发展。\"]},\"190\":{\"h\":\"相关工作\"},\"191\":{\"h\":\"\",\"t\":[\"视觉基础模型在过去十年中经历了显著发展，从早期的AlexNet和CNN架构（如ResNet）到近年来的Vision Transformer（ViT）及其变体。ViT及其衍生模型（如ViT-G、EVA-02等）通过扩大模型规模和参数量，显著提升了视觉任务的性能。然而，当前广泛使用的视觉模型参数量仍停留在约10亿级别（如ViT-22B除外），远落后于LLMs的规模。此外，这些模型多基于纯视觉数据（如ImageNet、JFT）训练，或与BERT系列模型对齐，缺乏与LLMs的直接特征兼容性，限制了其在多模态任务中的表现。\"]},\"192\":{\"h\":\"\",\"t\":[\"LLMs（如GPT-3、LLaMA系列、Vicuna等）在自然语言处理领域取得了突破性进展，展示了强大的少样本和零样本学习能力。开源模型（如ChatGLM、Falcon等）的涌现进一步加速了多模态研究的进程。然而，LLMs本身缺乏视觉理解能力，如何将其与视觉模态结合成为关键挑战。\"]},\"193\":{\"h\":\"\",\"t\":[\"近期研究通过将视觉模型与LLMs结合，构建了多模态对话系统（如Flamingo、LLaVA、MiniGPT-4等）。这些工作主要依赖轻量级适配层（如QFormer、线性投影）连接视觉编码器和LLM，但受限于视觉模型的规模和对齐效率。部分模型（如KOSMOS-2、Qwen-VL）进一步引入了视觉定位能力，支持区域描述和问答。尽管如此，视觉基础模型的性能瓶颈仍是制约VLLMs发展的关键因素。\"]},\"194\":{\"h\":\"\",\"t\":[\"现有工作表明，视觉模型的规模不足和对齐低效是阻碍多模态能力提升的主要障碍。InternVL通过规模化视觉编码器和渐进式跨模态对齐，首次实现了视觉与语言模型在参数和特征空间的深度协同，填补了这一领域的空白。\"]},\"195\":{\"h\":\"方法\"},\"196\":{\"h\":\"\",\"t\":[\"InternVL的整体架构（如图3所示）突破了传统视觉模型（如ViT）和双塔模型（如CLIP）的局限，通过以下两个核心组件实现跨模态深度协同：\",\"InternViT-6B: 基于标准ViT架构的60亿参数视觉编码器，通过超参数搜索优化了深度（48层）、头数（25）和MLP比率（8），在模型规模（5.9B参数）与计算效率间取得平衡（详见表1）。其输出支持密集特征图（）或全局池化特征，适配分类、分割等任务。\",\"QLLaMA: 基于多语言LLaMA-7B初始化的80亿参数语言中间件，新增96个可学习查询和交叉注意力层（1B参数），作为视觉与LLMs之间的\\\"重型胶水层\\\"。相比QFormer等轻量适配器，其参数量提升42倍，能更有效地重组视觉特征为LLM兼容的序列（见图4b/d）。\",\"如图1所示，InternVL的架构设计显著区别于：\",\"(a) 纯视觉模型（如ResNet）：仅支持单模态任务，缺乏语言对齐。\",\"(b) 双塔模型（如CLIP）：独立编码图像/文本，依赖浅层相似度计算。\",\"(c) InternVL：通过QLLaMA实现动态特征交互，同时支持对比学习（如检索）和生成任务（如描述）。\",\"通过组合不同组件，InternVL可灵活切换为四种模式（图4）：\",\"纯视觉模式（图4a）：仅用InternViT-6B处理图像分类/分割。\",\"对比模式-InternVL-C（图4b）：视觉编码器+注意力池化，用于零样本分类/检索。\",\"对比模式-InternVL-G（图4b）：联合QLLaMA二次编码视觉特征，提升检索精度。\",\"对话模式（图4c/d）：连接LLM（如Vicuna），支持多模态问答。\"]},\"197\":{\"h\":\"\",\"t\":[\"大规模视觉编码器（InternViT-6B）\",\"InternViT-6B是一个基于Vision Transformer（ViT）的视觉编码器，参数量达到60亿，旨在与大型语言模型（LLM）的规模相匹配。\",\"通过超参数搜索（如模型深度、头维度和MLP比例），作者确定了在性能和效率之间取得平衡的最佳配置（表1）。实验发现，模型深度对速度的影响在GPU计算饱和后可以忽略，而参数数量相同时，不同配置对性能影响较小。最终选择了深度48、宽度3200、MLP比率12800的稳定配置。\",\"该编码器支持密集预测任务（如语义分割）和图像分类任务，并能生成全局或局部视觉特征（图4a/b）。\",\"语言中间件（QLLaMA）\",\"QLLaMA是一个80亿参数的语言中间件，基于多语言LLaMA-7B初始化，新增了96个可学习查询和交叉注意力层（1亿参数），用于对齐视觉与语言特征（图3）。\",\"相比传统轻量级“胶水层”（如QFormer或线性投影），QLLaMA的优势包括：\",\"通过预训练权重实现视觉特征到LLM表示的对齐；\",\"参数量是QFormer的42倍，即使冻结LLM解码器也能在多模态对话任务中表现优异；\",\"支持对比学习任务（如零样本图像分类和检索）。\",\"灵活的组合方式（“瑞士军刀”模型）\",\"InternVL通过组合视觉编码器和语言中间件，支持多种任务模式（图4）：\",\"视觉感知任务：直接使用InternViT-6B提取特征。\",\"对比任务（如检索）：通过注意力池化生成全局特征（InternVL-C或InternVL-G）。\",\"生成任务（如图像描述）：QLLaMA利用其大规模参数重组视觉表示并生成文本。\",\"多模态对话：连接LLM解码器（InternVL-Chat），支持两种配置（图4c/d）。\"]},\"198\":{\"h\":\"\",\"t\":[\"1. 视觉-语言对比训练（Vision-Language Contrastive Training）\",\"目标：初步对齐视觉编码器（InternViT-6B）和文本编码器（LLaMA-7B）。\",\"数据：使用大规模但噪声较多的公开网络图像-文本对（如 LAION-en、LAION-multi、COYO 等，共 4.98B 样本，表 2）。\",\"方法：\",\"采用 CLIP 风格的对比学习，最小化图像-文本对的对称交叉熵损失。\",\"初始阶段在较低分辨率（196×196）训练，并应用 50% 图像 token 掩码 以提高效率，后期切换至 224×224 分辨率。\",\"效果：使模型在零样本分类、图像-文本检索等对比任务上表现优异，并为后续阶段提供稳健的视觉表示。\",\"2. 视觉-语言生成训练（Vision-Language Generative Training）\",\"目标：增强模型生成能力，进一步对齐视觉与语言特征。\",\"数据：筛选高质量图像-文本数据（1.03B，表 2），去除低质量描述（如重复文本、无意义内容）。\",\"方法：\",\"冻结 InternViT-6B 和 QLLaMA 的预训练权重，仅训练新增的 可学习查询和交叉注意力层。\",\"结合 三种损失函数：\",\"ITC（图像-文本对比损失）\",\"ITM（图像-文本匹配损失）\",\"ITG（基于图像的文本生成损失）\",\"效果：使 QLLaMA 能够有效重组视觉特征，并生成连贯的文本描述（如表 10 的零样本图像描述结果）。\",\"3. 监督微调（Supervised Fine-tuning, SFT）\",\"目标：优化多模态对话能力，连接 LLM 解码器（如 Vicuna、InternLM）。\",\"数据：收集约 400 万高质量指令数据（表 3），涵盖图像描述、VQA、OCR、视觉定位等任务。\",\"方法：\",\"两种配置（图 4c/d）：\",\"仅使用 InternViT-6B，通过 MLP 层连接 LLM（类似 LLaVA）。\",\"使用完整 InternVL（InternViT + QLLaMA），利用其对齐的特征空间提升性能。\",\"由于 QLLaMA 与 LLM 特征空间一致，即使冻结 LLM 解码器，仅微调 MLP 层也能取得良好效果。\",\"效果：在 MME、POPE 等多模态对话基准上达到 SOTA（表 9）。\",\"这一渐进式策略确保模型 从粗粒度对齐过渡到细粒度优化，充分利用不同质量的数据，最终实现强大的多模态理解和生成能力。\"]},\"199\":{\"h\":\"实现细节\",\"t\":[\"第一阶段（Stage 1）\",\"在该阶段，图像编码器 InternViT-6B 是随机初始化的 7，而文本编码器 LLaMA-7B 则使用来自文献 32的预训练权重进行初始化。此阶段中，所有参数都是可训练的。\",\"第二阶段（Stage 2）\",\"在该阶段，InternViT-6B 和 QLLaMA 继承了第一阶段中学习到的权重，而 QLLaMA 中新加入的可学习查询（learnable queries）和跨注意力层（cross-attention layers）是随机初始化的。由于第一阶段中已获得了强大的表示能力，我们在该阶段冻结 InternViT-6B 和 QLLaMA，仅训练新引入的参数。\",\"基座是 LLaMA-7B：QLLaMA 继承了经过第一阶段对比训练后得到的 LLaMA-7B 权重；\",\"新增模块：\",\"96 个 learnable query 向量：用于从视觉特征中提取信息；\",\"Cross-Attention 层：插入到了 LLaMA 的每一层 decoder block 中（这是主流做法，如 BLIP-2 也是如此），使得语言模型具备视觉融合能力；\",\"参数量：新加入模块约为 10 亿参数，占 QLLaMA 总体 8B 的一部分；\",\"第三阶段（Stage 3）\",\"此阶段有两种不同的配置方式：\",\"一种是单独使用 InternViT-6B，如图 4(c) 所示；\",\"另一种是同时使用完整的 InternVL 模型，如图 4(d) 所示。\"]},\"200\":{\"h\":\"实验\"},\"201\":{\"h\":\"\",\"t\":[\"图像分类（Image Classification）：\",\"InternViT-6B 在 ImageNet-1K 及其多个变种（如 IN-A、IN-R、IN-V2 等）上进行线性探测评估。结果显示，其在冻结骨干网络的前提下，取得了领先的零样本分类准确率，平均精度达到 82.5%，超过了如 OpenCLIP-G、EVA-01-CLIP-g 等主流模型。\",\"语义分割（Semantic Segmentation）：\",\"在 ADE20K 上进行语义分割测试，在不同微调策略下（线性探测、Head Tuning、全量微调），InternViT-6B 都展现出更强的像素级感知能力。例如，在全参数微调下，mIoU 达到 58.9%，显著优于 ViT-22B（55.3%）。\"]},\"202\":{\"h\":\"\",\"t\":[\"零样本图像分类（Zero-Shot Image Classification）：\",\"在多语言版本的 ImageNet 上（EN, ZH, JP, AR, IT），InternVL-C 的表现优于 OpenCLIP-XLM-R 和其他多语言模型，展示了良好的语言泛化能力。\",\"零样本图像-文本检索（Image-Text Retrieval）：\",\"InternVL-C 和 InternVL-G 在英中双语的 Flickr30K / COCO / Flickr30K-CN / COCO-CN 上均取得 SoTA 表现，InternVL-G 的 Recall@1 在 COCO 图像→文本检索任务中达到 85.0%，在多语言图像→文本检索任务 XTD 中，Recall@10 平均可达 96.6%，显著超越现有方法。\",\"零样本图像字幕生成（Image Captioning）：\",\"InternVL-G 在不使用指令微调的前提下，仅通过 QLLaMA 即可生成高质量图像描述。例如在 COCO 测试集上，zero-shot CIDEr 得分达到 128.2，超越如 BLIP-2、Qwen-VL 等多模态生成模型。\"]},\"203\":{\"h\":\"\",\"t\":[\"InternVL-Chat 在多模态对话基准（如 MME、POPE）上超越了多个 SoTA 模型。比如，在 MME 综合指标上，InternVL-Chat（13B + QLLaMA）达到 1586.4 分，优于 LLaVA-1.5 和 InstructBLIP 等方法。\",\"此外，InternVL 的多模态对话能力还体现在：\",\"VQA 子任务上：GQA 得分达 59.5（优于 LLaVA-13B 的 63.3）；\",\"图像字幕、OCR、视觉推理任务中均表现稳定，兼具理解和生成能力。\"]},\"204\":{\"h\":\"\",\"t\":[\"视觉主干设计选择（InternViT-6B）：\",\"作者在不同模型深度、宽度、MLP 比例等超参数组合上进行对比试验，最终选择了参数约为 5.9B 的 variant 3 作为 InternViT-6B 版本，在计算成本和准确率之间取得了良好平衡。\",\"QLLaMA 的重要性验证：\",\"通过最小化配置（仅训练 MLP 层）进行对比，发现使用 QLLaMA 作为 glue 层明显优于传统 MLP 层或 QFormer，在对话任务（如 MME、OKVQA、GQA）上均有显著提升。例如 MME 得分从 1022.3（无 QLLaMA）提高至 1317.2（使用 QLLaMA 和 Vicuna-13B）。\"]},\"205\":{\"h\":\"总结\",\"t\":[\"InternVL 的实验结果充分证明了其设计策略的有效性：\",\"大型视觉编码器（InternViT-6B）具备极强的感知能力；\",\"QLLaMA 显著提升了视觉-语言对齐与生成能力；\",\"多阶段训练策略（对比 + 生成 + 指令微调）保障了模型的通用性与灵活性；\",\"在图像分类、文本检索、VQA、多模态对话等任务上全面领先于现有开源模型，是当前最具代表性的通用多模态基础模型之一。\"]},\"206\":{\"h\":\"结论\",\"t\":[\"通过将视觉基础模型扩展到 60 亿参数规模（InternViT-6B），并与一个由 LLaMA 初始化的语言中间件（QLLaMA）进行渐进式对齐，InternVL 构建了一个强大且通用的视觉-语言基础模型。借助海量图文数据和多阶段训练策略（对比、生成、微调），InternVL 实现了在图像分类、图文检索、图像描述、VQA、多模态对话等任务上的领先性能，成功弥合了视觉模型与大型语言模型之间的能力与表示鸿沟，推动了多模态大模型的发展。\"]},\"207\":{\"h\":\"详细训练设置(附录内容)\"},\"208\":{\"h\":\"\",\"t\":[\"如表20所示，在此阶段：\",\"图像编码器（InternViT-6B） 采用 BEiT 的初始化方法随机初始化，文本编码器（LLaMA-7B） 则加载多语言 LLaMA-7B 的预训练权重。所有参数均参与训练。\",\"优化器使用 AdamW，超参数为 β1=0.9、β2=0.95，权重衰减 0.1，学习率采用余弦退火策略（图像编码器初始 1e-3，文本编码器 1e-4）。\",\"采用 DropPath 率 0.2，总批量大小 164K，在 640 张 A100 GPU 上训练 175K 步，处理约 287 亿样本。\",\"为提升效率，初期在 196×196 分辨率 下训练并 掩码 50% 图像 token，后期切换至 224×224 分辨率 并取消掩码（最后 5 亿样本）。\"]},\"209\":{\"h\":\"\",\"t\":[\"InternViT-6B 和 QLLaMA 继承第一阶段权重，新增的可学习查询和交叉注意力层 随机初始化。\",\"冻结主干网络，仅训练新增参数，输入分辨率保持 224×224。\",\"优化器使用 AdamW（β1=0.9、β2=0.98，权重衰减 0.05），总批量大小 20K，在 160 张 A100 GPU 上训练 80K 步（含 2K 步热身），峰值学习率 5e-5。\"]},\"210\":{\"h\":\"\",\"t\":[\"提供两种配置：\",\"InternVL-Chat（不含 QLLaMA）\",\"类似 LLaVA-1.5，先以 LGS-558K 数据集 训练 MLP 层，再用 LLaVA-Mix-665K 微调 LLM，各训练 1 轮。\",\"InternVL-Chat（含 QLLaMA）\",\"分两步：先用自定义 SFT 数据训练 MLP 层，再微调 LLM。因数据量扩大，批量大小增至 512。\"]},\"211\":{\"h\":\"\",\"t\":[\"所有参数可训练，分别在 Flickr30K 和 Flickr30K-CN 上微调。\",\"分辨率 364×364，采用 分层学习率衰减（0.9） 和 DropPath 率 0.3。\",\"使用 AdamW，批量大小 1024，训练 10 轮。\"]},\"212\":{\"h\":\"\",\"t\":[\"遵循常规做法：\",\"用 BatchNorm 归一化特征，拼接平均池化的 patch token 和类别 token。\",\"线性分类头使用 SGD 训练 10 轮（批量 1024，峰值学习率 0.2，1 轮热身，无权重衰减），数据增强包括随机裁剪和翻转。\"]},\"213\":{\"h\":\"\",\"t\":[\"表23列出了三种配置的超参数：\",\"线性探测（Linear Probing）\",\"头部调优（Head Tuning）\",\"全参数调优（Full-parameter Tuning）\"]},\"214\":{\"h\":\"书生·万象多模态大模型（InternVL 1.5）\",\"t\":[\"How Far Are We to GPT-4V? Closing the Gap to Commercial Multimodal Models with Open-Source Suites 论文简析\",\"论文链接: How Far Are We to GPT-4V? Closing the Gap to Commercial Multimodal Models with Open-Source Suites\"]},\"215\":{\"h\":\"摘要\",\"t\":[\"InternVL 1.5 是一个开源的多模态大语言模型（MLLM），旨在缩小开源模型与商业多模态模型（如 GPT-4V）之间的性能差距。其核心改进包括以下三点：\",\"强大的视觉编码器：通过持续学习策略优化大规模视觉基础模型 InternViT-6B，提升其视觉理解能力，并使其能够适配不同的语言模型（LLMs）。\",\"动态高分辨率处理：根据输入图像的长宽比和分辨率，将其动态分割为 1 到 40 个 448×448 像素的图块，最高支持 4K 分辨率输入，同时保留全局缩略图以捕捉上下文信息。\",\"高质量双语数据集：精心构建了一个涵盖常见场景和文档图像的双语数据集（中英文问答对），显著提升了模型在 OCR 和中文相关任务中的表现。\",\"实验结果表明，InternVL 1.5 在 18 个多模态基准测试中表现优异，其中 8 项达到领先水平，尤其在 OCR 相关任务中表现突出。其性能与商业模型（如 GPT-4V、Gemini 系列等）相当，部分任务甚至超越商业模型。这一成果为开源多模态模型的发展提供了重要支持。\"]},\"216\":{\"h\":\"简介\",\"t\":[\"研究背景与问题: 大型语言模型（LLMs）在推动通用人工智能（AGI）方面发挥了重要作用，而多模态大型语言模型（MLLMs）进一步扩展了文本与视觉信息的交互能力。然而，开源模型与商业专有模型（如GPT-4V、Gemini系列和Qwen-VL-Max）之间仍存在显著差距，主要体现在三个方面：\",\"参数规模：商业模型通常具有超过1000亿参数，而开源模型的视觉基础模型（VFM）通常仅3亿参数，搭配70亿或130亿参数的LLMs。\",\"图像分辨率：商业模型支持动态分辨率以保留原始宽高比，而开源模型多采用固定分辨率（如336×336或448×448），限制了细节理解能力。\",\"多语言能力：商业模型通过多语言数据集训练，而开源模型主要依赖英语数据，其他语言任务表现较差（如OCR和中文场景理解）。\",\"解决方案与创新: 论文提出InternVL 1.5，通过以下改进缩小差距：\",\"强大的视觉编码器：基于InternViT-6B的持续学习策略，增强视觉理解能力并适配不同LLMs。\",\"动态高分辨率处理：将图像分割为1至40个448×448像素的区块（支持4K分辨率），并添加缩略图以保留全局上下文（见图4）。\",\"高质量双语数据集：涵盖常见场景和文档图像，通过中英文问答对标注，显著提升OCR和中文任务性能（见表1）。\",\"模型优势\",\"灵活分辨率：类似GPT-4V的“低/高”模式，用户可根据任务需求选择分辨率（如低分辨率用于场景描述，高分辨率用于文档分析）。\",\"双语能力：在中文任务中表现优于GPT-4V（见图1）。\",\"强视觉表征：InternViT-6B的大参数规模使其视觉表征能力媲美200亿参数的LLMs，实现多模态能力的协同提升（见图2）。\",\"性能验证: InternVL 1.5在18个多模态基准测试中表现优异，在8个任务中达到SOTA，尤其在OCR相关任务（如TextVQA、ChartQA）中超越商业模型（见表2）。研究团队开源模型权重，以促进MLLM社区发展。\"]},\"217\":{\"h\":\"相关工作\"},\"218\":{\"h\":\"\",\"t\":[\"商业模型在多模态领域占据领先地位，主要代表包括：\",\"GPT-4V（OpenAI）：扩展GPT-4的视觉能力，支持文本和图像输入。\",\"Gemini 系列（Google）：从1.0到1.5版本，支持文本、图像和音频，并扩展至100万tokens的上下文窗口。\",\"Qwen-VL-Plus/Max（阿里）：在无需OCR工具的情况下展现强大的多模态能力。\",\"Claude-3V、HPT Pro、MM1、Step-1V、Grok-1.5V 等新兴模型进一步推动多模态技术的发展。\",\"这些模型的优势在于大规模参数、动态分辨率支持和多语言优化，但通常不开源，限制了研究社区的应用和优化。\"]},\"219\":{\"h\":\"\",\"t\":[\"开源模型在视觉-语言任务中取得显著进展，代表性工作包括：\",\"LLaVA 系列、MiniGPT-4、Qwen-VL、CogVLM 等，主要采用固定分辨率（如336×336或448×448），导致在非常规宽高比或文档理解任务上表现受限。\",\"高分辨率优化方法：\",\"双分支视觉编码器（如LLaVA-HR、DeepSeek-VL），结合低分辨率和高分辨率特征。\",\"分块策略（如UReader），将高分辨率图像分割为多个低分辨率区块处理。\",\"尽管这些方法有所改进，但开源模型在文档、图表和场景文本理解方面仍显著落后于商业模型。\"]},\"220\":{\"h\":\"\",\"t\":[\"VFMs 是 MLLMs 的核心组件，当前研究重点包括：\",\"CLIP-ViT 和 SigLIP 是主流选择，但它们在非互联网图像（如文档）上的表现较差。\",\"混合特征方法（如结合CLIP和DINOv2）提升视觉表征能力。\",\"双编码器设计（如DeepSeek-VL 使用 SigLIP 和 SAM-B）优化不同分辨率输入。\",\"本文提出的 InternViT-6B 通过持续学习策略增强视觉理解能力，并适配不同LLMs，提升模型的泛化性。\",\"商业模型在规模和性能上领先，但开源模型通过高分辨率优化、数据增强和更强的视觉编码器（如InternViT-6B）逐步缩小差距。InternVL 1.5 的创新点在于动态分辨率、双语数据集和持续学习的视觉编码器，使其在OCR和中文任务上表现优异。\"]},\"221\":{\"h\":\"方法\"},\"222\":{\"h\":\"\",\"t\":[\"InternVL 1.5 采用经典的 \\\"ViT-MLP-LLM\\\" 架构（见图3），主要包含以下组件：\",\"视觉编码器：基于 InternViT-6B（45层），通过持续学习优化，支持高分辨率输入。\",\"语言模型：采用 InternLM2-20B（聊天版本），提供强大的语言理解能力。\",\"动态分辨率策略：训练时根据输入图像的宽高比和分辨率，将图像分割为 1~12个448×448区块，测试时可扩展至 40区块（4K分辨率），并引入缩略图保留全局信息。\",\"Token压缩：使用 Pixel Shuffle 操作将视觉Token数量减少至1/4（如448×448图像对应256个Token），提升计算效率。\",\"MLP投影层: 随机初始化\"]},\"223\":{\"h\":\"\",\"t\":[\"现有 MLLM 通常采用对比学习预训练的 ViT 模型作为视觉基础模型。然而，这些 ViT 模型通常在固定低分辨率（如224×224）的互联网爬取图像-文本对上训练，因此在处理高分辨率图像或非互联网来源图像（如文档图像）时性能会下降。\",\"InternViT-6B-448px-V1.2：\",\"为解决这一问题，我们在InternVL 1.2版本中对InternViT-6B模型进行了持续预训练。首先，我们发现倒数第四层的特征在多模态任务中表现最佳，因此直接移除了最后三层的权重，将模型层数从48层缩减至45层。\",\"随后，我们将分辨率从224提升至448，并将其与Nous-Hermes-2-Yi-34B结合。为赋予模型高分辨率处理和OCR能力，我们在训练中同时激活视觉编码器和MLP投影层，使用了混合的图像描述和OCR专用数据集。\",\"InternViT-6B-448px-V1.5：\",\"InternVL 1.5的开发基于InternViT-6B-448px-V1.2的强健基础进一步预训练。在此版本中，训练图像的分辨率从固定的448×448扩展为动态的448×448，其中基础图块大小为448×448，图块数量为1至12个。此外，我们还提升了预训练数据集的规模、质量和多样性，最终使1.5版本模型具备了强大的鲁棒性、OCR能力和高分辨率处理能力。\",\"语言模型从Nous-Hermes-2-Yi-34B更换为InternLM2-20B，但InternViT仍展现出与新语言模型的优秀兼容性和可移植性。这表明，InternViT-6B在MLLM预训练阶段学习到的视觉特征具有广泛适用性，并不依赖于特定的语言模型\"]},\"224\":{\"h\":\"\",\"t\":[\"受UReader启发，我们采用动态高分辨率训练策略，有效适应输入图像的不同分辨率和宽高比。该方法通过灵活分割图像图块，在保留细节信息的同时兼容多样化的图像分辨率。主要步骤如下：\",\"动态宽高比匹配：从35种预设宽高比中选择最接近输入图像的配置，避免过度拉伸。\",\"分块与缩略图：\",\"图像调整至目标分辨率（如800×1300 → 896×1344）后分割为448×448区块。\",\"额外添加448×448缩略图以保留全局上下文。\",\"训练与测试灵活性：训练时最多12区块（3,328 Token），测试时支持40区块（10,496 Token）。\"]},\"225\":{\"h\":\"\",\"t\":[\"预训练数据（53.9% 图像描述 + 32% OCR数据）：\",\"涵盖 Laion-EN/ZH、COYO、GRIT 等通用数据集，以及 Wukong-OCR、Common Crawl PDFs 等大规模OCR数据。\",\"使用PaddleOCR生成中英文文本标注，增强模型文字识别能力。\",\"微调数据：\",\"包括 TextCaps、ShareGPT4V（双语描述）、DocVQA、ChartQA 等任务专用数据。\",\"通过翻译管道（图5）将英文数据转为中文，提升多语言支持。\",\"InternVL 1.5 通过 强视觉编码器、动态分辨率策略 和 双语数据集，显著提升了开源模型在OCR、中文任务和高分辨率场景下的性能，缩小了与商业模型的差距。其模块化设计（如InternViT-6B的兼容性）为后续研究提供了灵活的基础。\"]},\"226\":{\"h\":\"实验\"},\"227\":{\"h\":\"\",\"t\":[\"InternVL 1.5 基于 InternViT-6B（视觉编码器）和 InternLM2-20B-Chat（聊天版语言模型）构建，采用 动态高分辨率策略：\",\"训练阶段：图像分割为 1~12个448×448图块\",\"测试阶段：支持零样本扩展至 40图块（4K分辨率）\",\"两阶段训练：\",\"（1）预训练视觉编码器+MLP投影器\",\"（2）全模型微调（260亿参数）\",\"技术配置：上下文长度4096，响应格式与 LLaVA 1.5 一致，评估工具 VLMEvalKit\"]},\"228\":{\"h\":\"\",\"t\":[\"（1）OCR相关任务\",\"文档理解（DocVQA）、图表解析（ChartQA）、场景文本（TextVQA）等任务表现优异\",\"关键优势：在ChartQA和OCRBench上超越所有商业模型（如GPT-4V、Gemini系列）\",\"（2）通用多模态任务\",\"中文能力突出：在MMBench-CN、CCBench等中文基准上大幅领先\",\"幻觉控制：HallusionBench分数最高\",\"科学理解：AI2D科学图表任务表现接近商业模型\",\"（3）数学推理\",\"MathVista基准：超越GPT-4V，展示强大的数学-视觉联合推理能力\",\"（4）多轮对话\",\"ConvBench评估显示：在开源模型中领先，但较GPT-4V仍有差距\"]},\"229\":{\"h\":\"\",\"t\":[\"（1）视觉编码器规模的影响\",\"实验证明：大语言模型（如34B参数）需搭配大规模视觉编码器（如6B参数），才能更好处理复杂多模态任务\",\"（2）动态分辨率的作用\",\"OCR任务（如DocVQA）：高分辨率（更多图块）显著提升性能\",\"通用任务（如MMMU）：分辨率过高可能略微降低效果\",\"灵活性：模型可自适应调整分辨率，平衡效率与精度\"]},\"230\":{\"h\":\"结论\",\"t\":[\"InternVL 1.5作为开源多模态大语言模型，通过持续优化的视觉编码器InternViT-6B、创新的动态高分辨率处理策略（支持4K输入）和高质量双语数据集，在18个多模态基准测试中展现出媲美商业模型的性能，尤其在OCR相关任务（TextVQA/ChartQA/DocVQA）和中文理解方面表现突出，部分能力甚至超越GPT-4V，其开源的模型权重和研究方法为多模态AI发展提供了重要基准，未来将持续优化对话和推理能力，推动技术民主化进程。\"]},\"231\":{\"h\":\"LLaVA 1.0(Large Language and Vision Assistant)\",\"t\":[\"LLaVA 1.0 : Large Language and Vision Assistant 论文简析\",\"论文链接: https://arxiv.org/abs/2304.08485 代码链接: https://github.com/haotian-liu/LLaVA\"]},\"232\":{\"h\":\"背景\",\"t\":[\"此前，大型语言模型（如 GPT-3、LLaMA）通过机器生成的指令数据进行调优，显著提升了零样本和少样本泛化能力（如 InstructGPT、FLAN-T5 等）。\",\"InstructGPT 是由 OpenAI 提出的一种通过 人类反馈强化学习（Reinforcement Learning from Human Feedback, RLHF） 来实现 指令调优（Instruction Tuning） 的方法。 其目标是让预训练语言模型（如 GPT-3）更好地理解和执行用户给出的自然语言指令，从而提升其在各种任务上的泛化能力，尤其是零样本（zero-shot）或多任务场景下的表现。 InstructGPT 的核心思想是：通过结合人工标注数据和强化学习，引导语言模型更好地遵循用户指令，并在多种任务上表现良好。 它不是单纯地“记住”训练数据中的例子，而是学会根据用户指令理解任务意图并生成合适的结果。 InstructGPT 的 instruction tuning 实现主要包括以下三个关键阶段： 步骤1：收集指令-响应对（Instruction-Following Data）\",\"OpenAI 收集了大量的人类编写的 指令（instruction） 和对应的 期望输出（response）。\",\"这些指令可以是开放式的（如“写一个关于猫的故事”），也可以是特定任务（如“翻译成中文”、“总结文章”）。\",\"数据来源包括：\",\"用户提交给 GPT-3 的 API 请求；\",\"内部标注人员手动构造的示例。\",\"目标：构建一个多样化的指令-响应数据集，用于训练或评估模型。\",\"步骤2：训练监督模型（Supervised Policy）\",\"使用标注好的指令-响应数据对模型进行微调（fine-tune）。\",\"输入是一个指令，输出是模型应该生成的响应。\",\"模型结构与原始 GPT-3 相同，只是参数经过调整以更好响应指令。\",\"步骤3：基于人类反馈的强化学习（RLHF）, 这是 InstructGPT 最具创新性的部分。具体分为三步:\",\"收集人类偏好数据\",\"对于同一个指令，让模型生成多个不同的回答；\",\"让人类标注者对这些回答进行排序，选出他们认为最好的答案。\",\"训练奖励模型（Reward Model）\",\"使用上述人类偏好数据，训练一个奖励模型（Reward Model），该模型的输入是一对（指令 + 回答），输出是对这个回答的评分（score）。\",\"奖励模型的目标是模拟人类的偏好判断。\",\"使用强化学习优化策略（Policy Optimization）\",\"使用 PPO（Proximal Policy Optimization） 等强化学习算法，以奖励模型为“环境”，进一步微调模型。\",\"在训练过程中，模型尝试生成尽可能高奖励的回答，从而更贴近人类期望。\",\"《 Visual Instruction Tuning 》 这篇论文首次尝试使用仅支持文本输入的 GPT-4 / ChatGPT 来生成图文结合的指令响应对（instruction-following data） ，并用这些数据训练一个端到端的视觉语言模型 LLaVA。\",\"论文核心创新点: 这是第一个系统性地将 NLP 中的指令调优思想引入多模态领域的研究。\"]},\"233\":{\"h\":\"方法\",\"t\":[\"作者将模型训练分为两个阶段 ：\",\"预训练阶段（Feature Alignment Pre-training）: 让视觉编码器提取的图像特征与语言模型的词嵌入空间对齐 , 也就是说：让模型理解图像和文本之间的语义关系, 这是后续指令调优的基础。\",\"微调阶段（End-to-End Fine-tuning）：在预训练的基础上，进一步训练模型理解和执行更复杂的视觉指令任务。\",\"多轮对话能力；\",\"复杂推理能力；\",\"科学问答等实际应用任务。\"]},\"234\":{\"h\":\"预训练\",\"t\":[\"预训练是 LLaVA 模型训练的第一阶段，目标让视觉编码器输出的图像特征与语言模型的词向量空间对齐 ，使得后续指令调优时，模型可以更好地理解和生成图文结合的内容。\",\"作者使用的是大规模图文对数据集 CC3M（Conceptual Captions 3M） ，包含约 300 万条图文对。\",\"为了提升数据质量，进行了以下筛选： 名词短语过滤（Noun Phrase Filtering）\",\"使用 Spacy 提取每条 caption 中的名词短语；\",\"统计每个名词短语出现的频率；\",\"去除频率小于 3 的短语（避免罕见组合）；\",\"对于频率大于 100 的短语，只保留最多 100 条描述（防止过拟合）；\",\"最终得到约 595,000 条高质量图文对 。\",\"数据构建方式: 为了模拟用户提问和模型回答的形式，将这些图文对转换为如下格式：\",\"Human: [指令] [图像描述] Assistant: [详细描述]\",\"其中：\",\"[指令] ：如“请描述这张图片。”、“图中有什么？” [图像描述] ：来自 caption 或 bounding box 的文本化表示； [详细描述] ：期望的回答，通常是图像内容的全面视觉描述。\",\"Caption: 图像的文字描述，从多个角度描述图像内容 , 如: \\\"A group of people standing outside of a black vehicle with various luggage.\\\" Bounding Box: 标注图像中的物体及其位置 , 如: person:[0.681, 0.242, 0.774, 0.694], backpack:[0.384, 0.696, 0.485, 0.914] .\",\"模型结构:\",\"视觉编码器 ：CLIP ViT-L/14（预训练好的）\",\"语言模型 ：Vicuna（基于 LLaMA 的指令调优版本）\",\"投影层 ：一个简单的线性层，连接视觉特征和语言嵌入空间\",\"LLaVA模型结构\",\"训练流程:\",\"输入图像 : 使用 CLIP 视觉编码器提取图像特征 。\",\"投影层 : 将 转换为语言模型可用的 token 序列 。\",\"训练目标: 使用交叉熵损失函数，最小化语言模型输出与真实答案之间的差异 。\",\"仅更新投影矩阵 ，保持视觉编码器和语言模型参数冻结。这个阶段相当于在语言模型的词空间中“训练出一个能看懂图的视觉分词器”。\",\"通过这个阶段训练后，模型已经具备基本的视觉理解能力，即：\",\"可以根据图像描述生成合理的文字解释；\",\"实现了图像与语言之间的初步语义对齐；\",\"为下一阶段的端到端微调提供了良好的初始化。\",\"虽然还不能执行复杂的推理任务，但已经可以处理基本的图文问答任务。\"]},\"235\":{\"h\":\"微调\",\"t\":[\"微调过程 是 LLaVA 模型训练的第二阶段，目标是让模型在预训练的基础上进一步掌握多模态指令理解与复杂推理能力 ，具体包括：\",\"支持多轮视觉对话（Multimodal Chat）\",\"理解并回答科学类问题（如 ScienceQA 数据集）\",\"执行复杂的视觉推理任务\",\"具备跨模态交互能力（图像 + 文本）\",\"这是实现“通用视觉助手”的关键一步。\",\"微调阶段使用的是作者自己构建的高质量多模态指令数据集：\",\"名称：LLaVA-Instruct-158K\",\"包含约 158,000 条图文对\",\"分为三种响应类型：\",\"对话型（Conversation） ：58,000 条\",\"详细描述型（Detailed Description） ：23,000 条\",\"复杂推理型（Complex Reasoning） ：77,000 条\",\"这些数据由 GPT-4 / ChatGPT 自动生成，涵盖多种任务类型，具有高度多样性和挑战性。\",\"微调阶段的数据组织方式如下：\",\"Xsystem-message <STOP> Human: X1instruct <STOP> Assistant: X1a <STOP> Human: X2instruct <STOP> Assistant: X2a <STOP> ...\",\"其中：\",\"Xsystem-message：系统提示语（如：“你是一个视觉助手”）； Xinstruct：用户提问或指令； Xa：期望的回答； <STOP>：分隔符，表示输入结束，开始输出回答。\",\"模型结构:\",\"视觉编码器 ：CLIP ViT-L/14（保持冻结）\",\"语言模型 ：Vicuna（基于 LLaMA 的指令调优版本）\",\"投影层 ：连接图像特征和语言嵌入空间的线性层\",\"训练流程:\",\"输入图像 : 使用 CLIP 提取图像特征 \",\"投影层 : 使用可训练的投影矩阵 将图像特征 转换为语言嵌入 \",\"训练目标: 最小化语言模型输出与真实答案之间的交叉熵损失。\",\"微调时保持视觉编码器参数不变，只更新投影层 和语言模型 Vicuna 的参数。\",\"论文中重点测试了以下两个应用场景：\",\"多模态聊天机器人（Multimodal Chatbot）： 使用 LLaVA-Instruct-158K 数据集进行训练；\",\"其中：\",\"对话型问答为多轮对话；\",\"其他两类为单轮对话；\",\"数据均匀采样，训练出一个能自然理解图像内容、并进行视觉对话的 AI 助手。\",\"科学问答（Science QA）：在 ScienceQA 数据集上进行迁移学习；\",\"每个问题包含文本或图像上下文；\",\"助手需要生成推理过程，并从多个选项中选择正确答案；\",\"在这个任务上，LLaVA 达到了 90.92% 准确率 ；\",\"当与 GPT-4 联合推理时，准确率达到 92.53% ，刷新该数据集 SOTA。\"]},\"236\":{\"h\":\"联合 GPT-4 的推理机制（Ensemble with GPT-4）\",\"t\":[\"作者还提出了一种创新方法，将 LLaVA 与 GPT-4 联合使用：\",\"方法一：GPT-4 补充\",\"当 GPT-4 无法回答时，使用 LLaVA 的预测结果；\",\"效果：准确率提升不大（仅 0.05%），说明 LLaVA 已经接近其上限。\",\"方法二：GPT-4 判断者（Judge）\",\"当 LLaVA 和 GPT-4 输出不一致时，再次用 GPT-4 做判断；\",\"效果：显著提升表现，最终准确率达到 92.53% ，刷新 ScienceQA 数据集的 SOTA。\",\"这是首次尝试将大语言模型用于模型集成（model ensemble）的研究。\"]},\"237\":{\"h\":\"ablation study（消融实验）\",\"t\":[\"论文中还进行了多项 ablation 实验，以分析不同训练策略的影响：\",\"训练策略\",\"准确率变化\",\"不做预训练\",\"-5.11%\",\"仅使用最后一层视觉特征\",\"-0.96%\",\"先生成答案再推理\",\"-1.15%\",\"使用较小的 7B 模型\",\"-1.08%\",\"这些实验表明：\",\"预训练阶段非常关键；\",\"使用倒数第二层视觉特征更有利于细节理解；\",\"推理优先（Reasoning First）有助于加快收敛；\",\"模型规模对性能有显著影响。\"]},\"238\":{\"h\":\"补充\"},\"239\":{\"h\":\"辨析 instruction tuning 和 prompt tuning\",\"t\":[\"Instruction Tuning（指令调优） 和 Prompt Tuning（提示调优） 是两种用于提升预训练语言模型（LLM）或视觉语言模型性能的技术，但它们的目标、方法和应用场景有显著区别。以下是两者的主要区别：\",\"定义与核心思想\",\"类别\",\"Instruction Tuning（指令调优）\",\"Prompt Tuning（提示调优）\",\"定义\",\"通过大量“指令-响应”对微调模型，使其更好地理解和执行用户给出的自然语言指令。\",\"在输入中添加可学习的前缀（prefix）或前缀/后缀（prompt），引导模型生成特定任务的结果，而不需要改变整个模型参数。\",\"核心思想\",\"模型要理解并遵循人类语言中的任务描述（如“总结一下这篇文章”）。\",\"模型通过在输入前后插入一些可训练的提示词来“唤醒”其已有的知识，完成特定任务。\",\"训练方式\",\"类别\",\"Instruction Tuning\",\"Prompt Tuning\",\"是否修改模型结构\",\"否（通常保留原始结构）\",\"否\",\"是否更新全部参数\",\"是（微调整个模型参数）\",\"否（仅更新插入的 prompt 参数，其余参数冻结）\",\"数据需求\",\"需要大量人工或机器生成的“指令-响应”对\",\"不需要额外标注数据，直接使用原始任务描述\",\"训练目标\",\"提升模型在各种任务上的泛化能力，尤其是零样本/少样本任务迁移\",\"让固定模型适应新任务，利用已有知识进行推理\",\"应用场景举例\",\"类别\",\"示例场景\",\"Instruction Tuning\",\"ChatGPT、InstructGPT、FLAN-T5、LLaVA（视觉+语言）等，能根据用户指令回答问题、写故事、编程、推理等。\",\"Prompt Tuning\",\"使用 [PROMPT] 前缀让 BERT 回答 QA 问题、分类任务；在图像识别中加入 learnable prefix 来适配不同类别。\",\"优缺点对比:\",\"对比维度\",\"Instruction Tuning\",\"Prompt Tuning\",\"优点\",\"- 更强的任务泛化能力- 更贴近真实用户交互- 可用于多模态任务\",\"- 参数效率高（只训练少量 prompt）- 可复用已有大模型权重\",\"缺点\",\"- 数据依赖性强（需要大量高质量指令数据）- 微调成本高（需训练整个模型）\",\"- 表达能力受限于 prompt 的设计- 泛化性不如 instruction tuning\",\"总结一句话： Instruction Tuning 是教会模型“听懂人话”，按指令做事；Prompt Tuning 是引导模型“激活已有知识”，通过提示词让它自己做任务。\"]},\"240\":{\"h\":\"MoCo 论文\",\"t\":[\"Momentum Contrast for Unsupervised Visual Representation Learning 论文简析\",\"论文链接: Momentum Contrast for Unsupervised Visual Representation Learning 代码链接: https://github.com/facebookresearch/moco\"]},\"241\":{\"h\":\"Introduction\",\"t\":[\"对比学习从2019年开始到现在一直都比较火，Moco是视觉领域使用对比学习一个里程碑的工作。\",\"Moco作为一个无监督的表征学习工作，不仅在分类任务上逼近了有监督的基线模型，在其他任务，如检测、分割、人体关键点检测上都超越了有监督的预训练模型，也就是ImageNet上的预训练模型；\",\"Moco证明了一点，无监督学习真的可行，我们并不需要大量标注好的数据；\"]},\"242\":{\"h\":\"What is contrast learning?\",\"t\":[\"首先说对比学习想要做到什么呢？我们现在有三张图，第一张图是人高兴，第二张图片是人悲伤，第三张图片是狗。\",\"我们想得到一个结果，就是我们不需要知道前两张图片是人这个类别，不需要知道第三张图片是狗这个类别。但是我们需要知道前两张图片是一个类别，第三张图片不是一个类别。\",\"换句话说，我们现在把这三张图片输入一个模型，得到三个表征，我们需要让这三个表征在特征空间中，前两张图片的表征距离比较近，第三张图片和它们的距离比较远。\",\"一句话说，我们希望在特征空间里，同一个类别的物体处于相邻的区域，不同类别的物体处于不相邻的区域。\",\"在这个过程中，我们需要知道的是，我们并没有用到标签信息，我们不需要知道第一张和第二张图片是人，第三张是狗。\",\"但是我们用到了另外一种信息，就是第一张图片和第二张图片是同一个类别，第三张图片不是同一个类别的信息。这其实也是一种标签信息。\",\"不过这种标签信息，我们可以使用一些代理任务，巧妙构造出来，而不需要人为地去标注这种标签信息。这些代理任务，会去定义一些规则，这些规则可以去定义哪些图片是相似的，哪些图片是不相似的，从而可以提供一些监督信号给到模型去训练。这个过程其实也是自监督训练的一个过程。\"]},\"243\":{\"h\":\"instance discrimination task\",\"t\":[\"一个最经典的代理任务就是：instance discrimination，叫做个体判别。\",\"这个代理任务是指，如果我们有一个没有标注的数据集，里面有n个图片。\",\"从这个数据集中，我们随机选择一个图片 ，对这个图片做随机裁剪（或者其他的数据增广操作，我们称之为transformation），从而得到另外两张图；\",\"一个是 一个是 ，这样我们会得到两个不太一样的照片。但是由于这两张图片是从同一个图片经过某种变化得到的，语义信息不应该发生变化。所以这两张图片就可以称之为正样本，也就是同一个类别的图片。\",\"这个代理任务，同时认为，这个数据集中剩余的所有图片都是负样本。\",\"为什么叫做个体判别呢？因为它认为每个图片自成一个类别，剩余的图片都不是同一个类别。\",\"这个粒度其实是很细，你在图片分类的时候很多照片是同一个类别，其余的照片又分为了很多类别，所以个体判别这个代理任务经过模型训练，表征会很细。\",\"对于ImageNet这个数据集来说，如果是个体判别任务，不是一千个类别，而是100多万个类别。\",\"所以个体判别这个代理任务定义了什么是正样本，什么是负样本，接下来就很简单了，我们只需要经过模型，然后使用一个对比学习的函数去训练模型就可以了，比如说NCEloss。\",\"在这个过程中，其实有一个很有意思的点，就是代理任务是多样性的，是很灵活的。只要你能够得到一个判断正样本和负样本的规律，后续的损失函数之类的训练就很常规了。\",\"比如说在视频领域，同一个视频里的任意两帧是正样本，其他视频里的帧是负样本；\"]},\"244\":{\"h\":\"Momentum Contrast\",\"t\":[\"Moco 这个名字就是来源于前两个单词的前两个字母，即基于动量的对比学习。\",\"动量是一种加权移动平均:\",\" 是上一个时刻的输出， 是动量超参数， 是当前时刻的输入。\",\"说白了，就是不想让当前时刻的输出只是依赖于当前时刻的输入，还希望和之前时刻的输出有关系。动量这个超参数是 的一个参数；如果 趋近于 ，那么 的改变会非常缓慢，因为 趋近于零。\",\"Moco 就是利用这个动量的特性，去缓慢地更新编码器，从而让中间学习到的字典特征尽可能保持一致（这句话没看懂没关系，一会详细讲）。\"]},\"245\":{\"h\":\"Abstract\",\"t\":[\"Moco 把对比学习看成了是一个字典查询的过程，构建了一个动态的字典。这个动态的字典分为两个部分：第一部分是一个队列，第二部分是一个移动平均的编码器。\",\"队列里的样本不需要进行梯度回传，因此我们可以往队列里放入很多负样本，从而让字典的规模变得很大。\",\"为什么还要使用一个移动平均的编码器呢？这是为了让字典里的特征尽可能保持一致。\",\"在训练过程中发现，拥有一个规模大且特征较为一致的字典，能让无监督的对比学习取得很好的效果。\",\"从实验结果来看，在 ImageNet 数据集上，如果采用 线性评估（Linear Probing） 进行测试，Moco 可以取得和之前最优的无监督方法相近甚至更好的结果。\",\"线性评估指的是，先预训练好一个骨干模型，然后将这个骨干网络参数冻结，只训练最后的全连接层，再查看在不同数据集上的表现结果。这样做其实类似于把骨干网络当成一个特征提取器，仅从其中提取特征，这和使用 ResNet 作为特征提取器的方式差不多。\",\"Moco 一个很大的优势在于，学习到的特征在下游任务上具有很好的迁移性。我们看重无监督学习的优点，就是它可以从大量未标注的数据上学习到特征，并迁移到标注数据较少的任务上。\",\"Moco 在 7 个下游任务（如分割、检测等）上超越了之前的有监督预训练模型。\"]},\"246\":{\"h\":\"Introduction\",\"t\":[\"GPT和BERT，已经证明无监督学习在NLP任务上是行得通的。但是在CV领域，有监督预训练还是占据主导地位；\",\"之前也有很多优秀的无监督工作，但是表现都会比有监督要差，作者认为这是因为CV领域和NLP领域的原始信号空间不同。\",\"对于NLP领域来说，它们是离散的信号，也就是原始的信号空间是由单词组成，或者更细一点，是由单词词缀组成的，所以我们可以很容易地去建立一个字典，然后让模型去学习特征。那么字典中的每个key就是一个类别，我们可以根据这个类别去学习模型（比如BERT最后进行的softmax操作，不就是分类操作吗）\",\"但是对于CV领域来讲，情况完全不一样。CV领域的信号是在一个连续而且高维的空间，它并不像单词那样有很强的语义信息，也没有浓缩得那么简洁；所以CV领域并不适合去建立一个字典来学习模型；如果没有这个字典，无监督就很难去建模。因此，在CV领域，无监督学习的表现往往不如有监督学习。\",\"在之前有很多优秀的对比学习工作，都可以归纳为一种字典查询的工作。\",\"我们接着来看图：\",\"两个编码器，一个是E11，一个是E12；然后我们将图片x1经过数据增强T1得到图片X11，再经过E11这个编码器，得到图片表征f11；同理，图片x1经过数据增强T2得到图片x12，然后经过E12这个编码器，得到表征f12。\",\"我们把X11这个图片叫做 anchor（锚点），x12叫做x11的正样本。\",\"什么是负样本呢？就是数据集中剩余的所有图片都是负样本。那么负样本走哪个编码器呢？走的是E12这个编码器，因为正样本和负样本都是相对于锚点来说的，所以正样本和负样本要走同一个编码器，从而让特征的获取过程保持一致性。于是，负样本x2、x3、x4等等也经过E12得到了真正的负样本表征f2、f3、fn。\",\"我们把f11叫做 query，把f12、f2、f3、fn叫做 key。\",\"对比学习的过程就是想要在特征空间里，让正样本的key和query距离近，其余的key离query远。\",\"我们其实可以把key集合看成字典。那么对比学习的过程，就是想得到一个模型，让query在字典中与自己匹配的正样本更近。\",\"如果把对比学习的过程看成一个动态字典的过程，若想要得到比较好的效果，那么字典最好需要满足两个条件：第一个是字典足够大，第二个是在训练的时候尽量保持一致性。\",\"首先，我们在做对比学习的时候，是一个batch一个batch地去做，所以如果key这个字典足够大，那么从中抽样的可能性组合就很多，模型的泛化性就很强。如果字典很小，泛化性就不足，相当于数据量不够。\",\"其次，保持一致性是因为我们需要字典中的特征尽可能使用同一个或者相近的编码器进行表征。因为如果不这样做，模型可能就只会学习到和query使用同样编码器的那个key，导致模型泛化性不足，走了捷径。\",\"所以Moco要做的就是：在对比学习框架中，提供一个又大又一致的字典；框架图如下：\",\"大字典是怎么做到的：维护一个队列，把每次训练的 batch-size 和队列大小分离开；具体来说就是这个队列可以很大，但是我们每次更新这个队列，是一点点地更新的，也就是说当我们用一个很小的 batchsize 时，把当前 batch 中的特征加入队列，将最老的 batch-size 的特征从队列中抽离；这样我们的队列就可以设置得很大，比如几万。通过这种方式，使用一个 GPU 也可以很好地训练模型。\",\"那么一致性是如何做到的？刚才说了，每次都是使用新的编码器更新 batch 大小的队列特征，除此之外的特征都是使用之前的编码器得到的，这样不就不一致了吗？这时使用动量更新即可。我们最开始右边分支的编码器是由左边初始化而来，后续更新时对右边这个编码器的参数进行动量更新，让 m 足够大，确保右边编码器更新得非常缓慢，从公式来说，就是这个图：\",\"可以看到，右边编码器会被之前的 编码，和当前时刻的 编码影响。当 足够大，无限接近于 时，就可以认为其无限被 控制，更新会非常缓慢。\",\"Moco 只是建立中间模型的一种方式，它非常灵活，可以和很多代理任务结合，这里使用的是之前讲过的个体判别任务。\",\"无监督学习最大的一个卖点，就是我们的模型在大量无标注的数据集上进行训练之后，得到的特征可以很好地迁移到下游任务中（比如标注数据很少的任务）。\"]},\"247\":{\"h\":\"Conclusion\",\"t\":[\"Moco 论文在 ImageNet 数据集上取得了很好的结果，在 Facebook 自家的数据集上同样效果良好，但提升幅度不大。当数据集规模从 100 万增长到 10 亿时，提升依然不明显。作者认为大规模数据没有被充分利用，可能采用一个更好的代理任务会取得更好的效果。所以作者提出，除了个体判别这个任务外，有没有可能将 MoCo 和 mask encoded 任务结合起来，也就是类似 BERT 的操作，使用 MLM（Masked Language Modeling） 自监督的方式进行学习。（这不就是 MAE 模型吗）\",\"开头提到过 CV 和 NLP 的信号空间不一致，直接照搬 BERT 的方法可能行不通，具体可参考 MAE 模型。\"]},\"248\":{\"h\":\"Related Work\",\"t\":[\"一般来说，自监督学习的方法可以从两个方面来进行优化或创新：\",\"在损失函数上做文章：设计或改进对比损失函数，使得模型能够更有效地学习到有判别性的表示。\",\"在代理任务上做文章：通过设计合理的预训练任务（如图像重建、上下文预测等）引导模型学习有用的特征。\",\"💡 注解：自监督学习其实是一种特殊形式的无监督学习，通过人为构造“标签”来训练模型。\",\"损失函数:\",\"NCE（Noise Contrastive Estimation）损失函数：\",\"最初用于语言模型（如word2vec）中，它的基本思想是把一个“超级大的多分类问题”（即从大量候选中选出正确样本）转化为一系列“二分类问题”（即判断某个样本是否是正样本）。\",\"因为直接在超大类别空间上做 softmax 计算代价太高，所以 NCE 提供了一种更可行的替代方法。\",\"类似于 word2vec 中的 negative sampling 技术。\",\"InfoNCE：\",\"是 NCE 的一种改进或变体，被广泛应用于对比学习中（如MoCo、SimCLR）。\",\"它的目标是在一个由一个正样本和多个负样本构成的集合中，最大化正样本的得分，使得模型能够区分正负样本对。\",\"温度系数（temperature hyperparameter）：\",\"在 InfoNCE 的 softmax 函数中，通常会加入一个 温度超参数 ，用于调节 logits（相似度）的“尖锐程度”：\",\" 越小，softmax 越尖锐，模型对正负样本差异更加敏感；\",\" 越大，softmax 趋于平滑，训练更稳定但区分度下降。\",\"在看 InfoNCE 的损失函数的时候，首先从 softmax 看起，这个是softmax的公式:\",\"然后我们加一个 就是 交叉熵损失函数：\",\"这个公式其实可以直接用在对比学习中。\",\"什么意思呢？ 交叉熵是一个多分类问题的损失函数，一个one-hot向量，和我真实输出做一个损失，目标是为了让真正标签的输出尽可能的大。\",\"那么有一个问题，如果把这个损失函数，直接套到对比学习中去，那么是什么意义呢？\",\"比如 ImageNet 100万个图片，那么我当前图片经过数据增强之后，经过编码器1得到了 锚点特征，经过编码器2得到了正样本，也就是我的 ground-truth；\",\"那么除了我当前这个图片外，其余100万 - 1个图片经过编码器2得到的表征都是负样本，也就是会得到这样一个向量：\",\"1 0 0 0 （1个1 , 100万 - 1个0）\",\"在这个向量上做交叉熵，其实就可以用在对比学习上。\",\"但是这样做 softmax 计算量太大了，像 BERT 这种模型，也就几万个类别，处理起来没啥问题，几百万个类别就太难了。\",\"这个时候 NCE（Noise Contrastive Estimation） 就是一种很好的解决方式，将问题转化为一个二分类问题，也就是现在只有两个类别，一个是正常样本，除此之外的都是噪声样本。\",\"但是这样做的逻辑不太清晰，所以 InfoNCE 就应运而生了。\",\"与其在整个数据集上计算损失，不如抽样一部分数据来计算损失。如果选取的抽样部分过少，就没什么意义，无法模拟整个数据集，所以抽样的部分还是要大一点。此时，字典的大小就很重要，也就是字典的大小就是分母下方的类别数量；在这个过程中，InfoNCE 把 NCE 的一系列二分类问题又转为了多分类问题。\",\" 就是我们的 query 表征，也就是 锚点 那个图片的特征， 就是正样本，分母累加那里的 ，就是我们的负样本数量，分类累加了 项，因为有 个负样本和一个正样本。\",\"温度参数 （希腊字母读音为 \\\"tao\\\"），在蒸馏相关内容里其实提到过，如果 很大，那么 softmax 分布会很平滑，看不出区别，就是把所有的负样本一视同仁，导致模型学习没有轻重；如果 很小，分布会更尖锐，会让模型只关注那个困难的负样本，其实那些负样本很有可能是潜在的正样本，如果模型过度关注这个困难的负样本，会导致模型很难收敛，或者 学习 到的特征不太好泛化。\",\"去除这个温度超参数，InfoNCE 本质就是一个交叉熵损失函数，只不过类别和所有样本相比，做了个近似，进行了一次随机抽样，抽样数量就是字典大小。Moco 伪代码里的 InfoNCE 直接使用的就是交叉熵损失函数代码。\"]},\"249\":{\"h\":\"Detail\",\"t\":[\"有个细节，为什么使用队列这种数据结构存储字典呢？\",\"因为先进先出，每次一个 batch 进来，最老的那个部分 batch 数据会出去，这部分数据是过时的，从而能够保持队列中的特征尽可能的 一致性。\",\"另一个细节：\",\"第二个分支不能随着走这一支的样本使用梯度回传进行更新，为什么呢？因为如果这样做了，第二个分支的编码器就更新得太快了，这些特征，我们是放到字典中去的，就会导致特征 不一致。\",\"为什么第二个分支不直接不更新，而是采用缓慢更新呢？（我自己理解，如果第二个分支一直不变，由于正样本的定义规则是经过编码器之后所在的语义空间才为正样本。在模型训练时可能会出现问题，因为到后来第一个分支和第二个分支编码器差距越来越大，原本是正样本的，损失也会很大，导致模型很难训练。）\",\"两个贡献：\",\"一个是构建很大的字典：计算损失的时候使用多分类，能够很近似在整个数据集上做的多分类损失。\",\"一个是保证字典内特征一致性，使用动量更新。\",\"需要注意的一点：就是 InfoNCE 损失计算的是整个字典做多分类。minibatch 大小和字典大小剥离开，batch 可以设置为 256，然后进来 256 个样本，每个样本都需要做一个 锚点，走一遍对比学习的流程。\",\"动量设置为了 0.99，这个值 很大 了。字典大小是 65536。\",\"在 Moco 之前的工作中， 字典大小和字典特征一致性经常不能同时满足。\"]},\"250\":{\"h\":\"Preview Work\",\"t\":[\"端到端的框架：\",\"端到端的框架 就是两个编码器都可以通过梯度回传进行更新，因为 和 都是从同一个 batch 中来的，我们通过一次 forward 就可以拿到所有样本的特征，我们直接梯度回传就可以了。这要求 batch 大小要足够的大，那么 InfoNCE 才能起作用，做到一个近似的全部数据集的多分类。SIMCLR 就是这个端到端的框架。这样字典是高度一致的。在这种情况下，batch 大小和字典大小是等价的。SIMCLR 就是用了 8192 作为 batch 大小。\",\"另一流派，更关注 字典的大，然后牺牲一些一致性，就是 memory bank；在这个流派只有一个编码器，就是 query 的编码器，可以进行梯度回传进行更新。对于 key 这边，是没有一个单独的编码器。\",\"memory bank 就是把整个数据集的特征，都存到了一起。对于 ImageNet 来说，这里就是 128 万个特征（作者说到，每个特征 128 维度，只需要 600M 的空间，还好。）\",\"然后每次训练的时候，从 memory bank 中随机抽样字典大小就可以了。右边的编码是在线下执行。\",\"在执行的时候，比如字典大小是 3，那么抽出三个来，左边做一次梯度回传之后，我们把字典中的 3 个用新的编码器做一个编码，放回到 memory bank 中去。\",\"（首先，我认为为了保持正样本的定义，肯定得更新样本特征）\",\"因为你这个更新操作，导致字典内编码特征不一致。\"]},\"251\":{\"h\":\"Code Implementation\"},\"252\":{\"h\":\"Train Code\",\"t\":[\"MoCo 训练代码如下所示:\",\"def main_worker(args): # 1. init MoCo Model model = deeplearning.cross_image_ssl.moco.builder.MoCo( models.__dict__[args.arch], args.moco_dim, args.moco_k, args.moco_m, args.moco_t, args.mlp, ) # 2. define loss function (criterion) and optimizer criterion = nn.CrossEntropyLoss().cuda(args.gpu) optimizer = torch.optim.SGD( model.parameters(), args.lr, momentum=args.momentum, weight_decay=args.weight_decay, ) # 3. Data loading code normalize = transforms.Normalize( mean=[0.485, 0.456, 0.406], std=[0.229, 0.224, 0.225] ) augmentation = [ transforms.RandomResizedCrop(224, scale=(0.2, 1.0)), transforms.RandomGrayscale(p=0.2), transforms.ColorJitter(0.4, 0.4, 0.4, 0.4), transforms.RandomHorizontalFlip(), transforms.ToTensor(), normalize, ] train_dataset = datasets.ImageFolder( traindir, deeplearning.cross_image_ssl.moco.loader.TwoCropsTransform( transforms.Compose(augmentation) ), ) train_loader = torch.utils.data.DataLoader( train_dataset, batch_size=args.batch_size, shuffle=(train_sampler is None), num_workers=args.workers, pin_memory=True, sampler=train_sampler, drop_last=True, ) for epoch in range(args.start_epoch, args.epochs): # 4. train for one epoch train(train_loader, model, criterion, optimizer, epoch, args)\",\"这里的重点是 TwoCropsTransform 这个增强方法，它的作用是对一个样本进行两次增强，得到两个样本。\",\"class TwoCropsTransform: \\\"\\\"\\\"Take two random crops of one image as the query and key.\\\"\\\"\\\" def __init__(self, base_transform) -> None: self.base_transform = base_transform def __call__(self, x): q = self.base_transform(x) k = self.base_transform(x) return [q, k]\",\"此时 train_loader 返回的每个 batch 维度为: [2, batch_size, C, H, W] , 其中 batch[0] 代表 query , batch[1] 代表 positive key。\",\"def train(train_loader, model, criterion, optimizer, epoch, args) -> None: for i, (images, _) in enumerate(train_loader): # 1. compute output output, target = model(im_q=images[0], im_k=images[1]) loss = criterion(output, target) # 2. compute gradient and do SGD step optimizer.zero_grad() loss.backward() optimizer.step()\"]},\"253\":{\"h\":\"Model Implementation\"},\"254\":{\"h\":\"Model Init\",\"t\":[\"模型初始化代码如下所示:\",\"class MoCo(nn.Module): def __init__( self, base_encoder, # ResNet 模型 dim: int = 128, K: int = 65536, # 队列大小/字典大小/负样本数量 m: float = 0.999, # 动量更新参数 T: float = 0.07, # 温度参数 mlp: bool = False, ) -> None: \\\"\\\"\\\" dim: feature dimension (default: 128) K: queue size; number of negative keys (default: 65536) m: moco momentum of updating key encoder (default: 0.999) T: softmax temperature (default: 0.07) \\\"\\\"\\\" super(MoCo, self).__init__() self.K = K self.m = m self.T = T # 1. create the encoders: num_classes is the output fc dimension self.encoder_q = base_encoder(num_classes=dim) self.encoder_k = base_encoder(num_classes=dim) # 2. key encoder参数使用query encoder进行初始化，同时key encoder不参与梯度运算 for param_q, param_k in zip( self.encoder_q.parameters(), self.encoder_k.parameters() ): param_k.data.copy_(param_q.data) # initialize param_k.requires_grad = False # not update by gradient # 3. create the queue/dictionary and pointer self.register_buffer(\\\"queue\\\", torch.randn(dim, K)) self.queue = nn.functional.normalize(self.queue, dim=0) self.register_buffer(\\\"queue_ptr\\\", torch.zeros(1, dtype=torch.long)) # 队列指针，负责完成出队入队的信息记录\"]},\"255\":{\"h\":\"Model Forward\",\"t\":[\"模型前向传播代码如下所示:\",\" def forward(self, im_q, im_k): \\\"\\\"\\\" Input: im_q: a batch of query images im_k: a batch of key images Output: logits, targets \\\"\\\"\\\" # 1. compute query features q = self.encoder_q(im_q) # queries: NxC q = nn.functional.normalize(q, dim=1) # 2. compute key features with torch.no_grad(): # no gradient to keys self._momentum_update_key_encoder() # update the key encoder # shuffle for making use of BN im_k, idx_unshuffle = self._batch_shuffle_ddp(im_k) k = self.encoder_k(im_k) # keys: NxC k = nn.functional.normalize(k, dim=1) # undo shuffle k = self._batch_unshuffle_ddp(k, idx_unshuffle) # 3. compute logits # Einstein sum is more intuitive # positive logits: Nx1 l_pos = torch.einsum(\\\"nc,nc->n\\\", [q, k]).unsqueeze(-1) # negative logits: NxK l_neg = torch.einsum(\\\"nc,ck->nk\\\", [q, self.queue.clone().detach()]) # 4. logits: Nx(1+K) logits = torch.cat([l_pos, l_neg], dim=1) # 5. apply temperature logits /= self.T # 6. labels: positive key indicators labels = torch.zeros(logits.shape[0], dtype=torch.long).cuda() # 7. dequeue and enqueue self._dequeue_and_enqueue(k) return logits, labels\",\"论文采用 ResNet 作为编码器，其最后的全连接层（在全局平均池化之后）输出一个固定维度的向量（128 维）。这个输出向量会通过其 L2 范数进行归一化。该向量即表示一个 query（查询向量） 或 key（键向量） 的特征表示。\"]},\"256\":{\"h\":\"Momentum Update\",\"t\":[\"采用动量更新方式对 key encoder 进行缓慢更新的代码实现如下所示:\",\" @torch.no_grad() def _momentum_update_key_encoder(self) -> None: \\\"\\\"\\\" Momentum update of the key encoder \\\"\\\"\\\" for param_q, param_k in zip( self.encoder_q.parameters(), self.encoder_k.parameters() ): param_k.data = param_k.data * self.m + param_q.data * (1.0 - self.m)\"]},\"257\":{\"h\":\"Dequeue and Enqueue\",\"t\":[\"维护队列状态的代码实现如下所示：\",\" @torch.no_grad() def _dequeue_and_enqueue(self, keys) -> None: # 1. gather keys before updating queue keys = concat_all_gather(keys) # 如果你在多 GPU 上训练，每个 GPU 都会处理一部分 batch，该方法会将所有 GPU 上的 key 向量合并成一个完整的 batch batch_size = keys.shape[0] ptr = int(self.queue_ptr) assert self.K % batch_size == 0 # for simplicity # 2. replace the keys at ptr (dequeue and enqueue) self.queue[:, ptr : ptr + batch_size] = keys.T # queue 的形状是 (C, K)，每列是一个 key 向量（transpose 存储是为了快速矩阵乘） ptr = (ptr + batch_size) % self.K # move pointer self.queue_ptr[0] = ptr\"]},\"258\":{\"h\":\"多模态\"},\"259\":{\"h\":\"VLMo 论文\",\"t\":[\"VLMO: Unified Vision-Language Pre-Training with Mixture-of-Modality-Experts 论文简析\",\"论文链接: VLMO: Unified Vision-Language Pre-Training with Mixture-of-Modality-Experts 代码链接: https://github.com/microsoft/unilm/tree/master/vlmo\"]},\"260\":{\"h\":\"Introduction\",\"t\":[\"视觉-语言（VL）预训练旨在从大规模图文对中学习通用的跨模态表示。现有模型通常通过图文匹配、图文对比学习、掩码区域分类/特征回归、词-区域/块对齐以及掩码语言建模等方法来聚合和对齐视觉与语言信息，然后在下游任务如图文检索、视觉问答（VQA）、视觉推理等进行微调。\",\"现有两类主流架构各有优缺点：\",\"双编码器架构（Dual-Encoder，如 CLIP、ALIGN）：\",\"图像和文本分别编码，模态间交互通过特征向量的余弦相似度进行。\",\"优点：检索任务高效，特征向量可提前计算存储，线性复杂度。\",\"缺点：交互浅，对复杂视觉-语言分类任务表现有限，如 CLIP 在视觉推理任务上准确率偏低。\",\"融合编码器架构（Fusion-Encoder）：\",\"使用多层 Transformer 通过跨模态注意力融合图像和文本表示。\",\"优点：在视觉-语言分类任务上性能优异。\",\"缺点：检索任务需对所有图文对联合编码，时间复杂度为二次方，推理速度慢。\",\"VLMO 的提出\",\"为兼顾双编码器和融合编码器的优势，论文提出了 统一视觉-语言预训练模型 VLMO，其特点如下：\",\"可作为双编码器用于图文检索，也可作为融合编码器处理图文对分类任务。\",\"核心组件为 Mixture-of-Modality-Experts (MOME) Transformer，一个 Transformer 块内可编码图像、文本及图文对。\",\"MOME 替换标准 Transformer 的前馈网络为模态专家池，捕获模态特定信息，同时共享自注意力层进行跨模态对齐。\",\"三类模态专家：视觉专家（图像编码）、语言专家（文本编码）、视觉-语言专家（图文融合）。\",\"模型灵活性高，可复用共享参数实现文本编码器、图像编码器和图文融合编码器。\",\"预训练任务与策略\",\"VLMO 采用三种联合预训练任务：\",\"图文对比学习（image-text contrastive learning）\",\"图文匹配（image-text matching）\",\"掩码语言建模（masked language modeling）\",\"同时提出 分阶段预训练策略，充分利用大规模图像单模态和文本单模态数据：\",\"在图像单模态数据上预训练视觉专家和自注意力模块，采用 BEIT 的掩码图像建模方法。\",\"在文本单模态数据上预训练语言专家，采用掩码语言建模方法。\",\"最终初始化视觉-语言预训练模型，解决图文对数量有限、描述短小的问题，从而学习更泛化的表示。\",\"实验结果与贡献\",\"在图文检索任务中，VLMO 作为双编码器比融合编码器更快，并且性能优于其他融合编码器模型。\",\"在视觉问答（VQA）和自然语言视觉推理（NLVR2）任务中，作为融合编码器的 VLMO 达到最先进性能。\",\"主要贡献：\",\"提出统一视觉-语言预训练模型 VLMO，可灵活用作融合编码器或双编码器。\",\"引入通用多模态 Transformer（MOME Transformer），通过模态专家捕获模态特定信息，并通过共享自注意力实现跨模态对齐。\",\"分阶段预训练策略利用大规模图像单模态和文本单模态数据，显著提升模型性能。\"]},\"261\":{\"h\":\"Related Work\",\"t\":[\"视觉-语言预训练方法大体可分为两类：\",\"双编码器（Dual Encoder）（如 CLIP [35], ALIGN [18]）：\",\"图像和文本分别编码，模态间交互通过余弦相似度或线性投影实现。\",\"通常使用图文对比学习优化模型。\",\"优点：对检索任务效果好，图像和文本特征可预计算。\",\"缺点：交互浅，不适合处理需要复杂推理的 VL 分类任务，如视觉问答或视觉推理。\",\"融合编码器（Fusion Encoder）（如 ALBEF [23], ViLT [20], Pixel-BERT [16]）：\",\"使用深度融合编码器，通过跨模态注意力建模图像和文本的交互。\",\"训练任务包括图文匹配、掩码语言建模、词-区域/块对齐、掩码区域分类和特征回归。\",\"优点：在分类任务上性能更好，可捕获深层交互。\",\"缺点：对所有图文对进行联合编码，推理速度慢；依赖目标检测器（如 Faster R-CNN [37]）获取区域特征时可扩展性差。\",\"改进方法：Pixel-BERT 去掉目标检测器，使用卷积网络提取网格特征；ALBEF 使用图像 Transformer 和文本 Transformer 获取表示再融合；ViLT 将图像 patch 与词嵌入拼接输入 Transformer 学习上下文表示。\",\"VLMO 的特点：\",\"采用共享的 MOME Transformer 统一预训练。\",\"可在检索任务中执行独立编码，也可联合编码图文对用于分类任务。\",\"优点：在保证性能的同时，检索和分类任务的推理速度更快。\"]},\"262\":{\"h\":\"Method\",\"t\":[\"给定图像-文本对，VLMO 通过 MOME Transformer 网络获得图像、文本以及图像-文本对的表示。如图 1 所示，统一的预训练通过以下任务优化共享的 MOME Transformer：\",\"对图像-only 和文本-only 表示进行图文对比学习（Image-Text Contrastive Learning）\",\"对图像-文本对表示进行图文匹配（Image-Text Matching）和掩码语言建模（Masked Language Modeling）\",\"得益于这种建模灵活性，模型在微调时可以作为双编码器（Dual Encoder）用于检索任务，单独编码图像和文本；也可以作为融合编码器（Fusion Encoder）用于分类任务，建模图像与文本的深层交互。\"]},\"263\":{\"h\":\"输入表示\",\"t\":[\"给定一个图像-文本对，我们将其编码为图像、文本和图像-文本向量表示，这些表示会被输入到 MOME Transformer 中以学习上下文表示，并对图像和文本特征进行对齐。\",\"图像表示\",\"遵循视觉 Transformer 方法，二维图像 被划分为 个 patch，，其中 为通道数， 为图像分辨率， 为 patch 分辨率。\",\"将图像 patch 拉平后线性投影获得 patch embedding，并在序列前添加可学习的特殊 token [I_CLS]。\",\"最终的图像输入表示为 patch embedding、可学习位置嵌入 和图像类型嵌入 的和：\",\"文本表示\",\"遵循 BERT 方法，将文本拆分为子词（WordPiece），并在序列前后添加 [T_CLS] 和 [T_SEP]。\",\"文本输入表示 为对应词向量、位置嵌入和类型嵌入之和：\",\"其中 为分词后的长度。\",\"图像-文本表示\",\"将图像和文本向量拼接得到图像-文本输入表示：\"]},\"264\":{\"h\":\"多模态专家混合 Transformer（MOME Transformer）\",\"t\":[\"受到 Mixture-of-Experts 网络启发，提出 MOME Transformer 用于多模态编码，将标准 Transformer 的前馈网络替换为“模态专家混合网络”（Mixture-of-Modality-Experts, MoME-FFN）。\",\"对上一层输出 ，每个 MOME Transformer 块通过切换不同模态专家捕捉模态特定信息，并通过多头自注意力（MSA）对齐视觉和语言内容。\",\"MoME-FFN 会根据输入模态选择不同专家：视觉专家（V-FFN）、语言专家（L-FFN）和视觉-语言专家（VL-FFN）。\",\"输入为图像-only 或文本-only 时，分别使用视觉或语言专家编码；输入为图像-文本对时，底层使用视觉和语言专家分别编码各自模态，顶层使用视觉-语言专家捕捉跨模态交互。\",\"最终得到图像-only、文本-only 和图像-文本的上下文表示。\"]},\"265\":{\"h\":\"预训练任务\",\"t\":[\"VLMO 使用共享参数同时进行以下预训练任务：\",\"图文对比学习（Image-Text Contrastive Learning）\",\"给定一个 batch 的 个图像-文本对，目标是从 个可能配对中识别正确配对，其中有 个负样本。\",\"使用 [I_CLS] 和 [T_CLS] 的输出向量作为图像和文本的聚合表示，通过线性投影和归一化得到 和 ，计算图像-文本相似度：\",\"其中 为可学习温度参数，使用交叉熵损失训练。\",\"掩码语言建模（Masked Language Modeling）\",\"随机选择文本序列中的 token 替换为 [MASK]（概率 15%），模型预测被掩码的 token，利用视觉信息辅助。\",\"使用 cross-entropy loss 对整个词表进行分类训练。\",\"图文匹配（Image-Text Matching）\",\"预测图像与文本是否匹配，使用 [T_CLS] 的最终隐藏向量作为表示输入分类器。\",\"采用 hard negative 采样策略：不同于 ALBEF 的局部采样（local hard negative），VLMO 提出全局 hard negative 采样（global hard negative），从所有 GPU 的训练样本中采样，能显著提升模型性能。\"]},\"266\":{\"h\":\"分阶段预训练（Stagewise Pre-Training）\",\"t\":[\"利用大规模图像-only 和文本-only 数据提升模型能力（图 2）。\",\"首先对图像-only 数据进行视觉预训练，训练 MOME Transformer 的注意力模块和视觉专家，使用 BEIT 预训练参数初始化。\",\"然后对文本-only 数据进行语言预训练，冻结注意力模块和视觉专家，仅训练语言专家进行掩码语言建模。\",\"这种方式比直接使用图像-文本对更容易收集数据，同时文本-only 数据通常较长、复杂，有助于提升对复杂图文对的泛化能力。\"]},\"267\":{\"h\":\"下游任务微调\",\"t\":[\"视觉-语言分类\",\"如视觉问答、视觉推理任务，VLMO 作为融合编码器使用，建模图像和文本的交互。\",\"使用 [T_CLS] 的最终编码向量表示图文对，输入任务专用分类器预测标签。\",\"视觉-语言检索\",\"VLMO 可作为双编码器，分别编码图像和文本，优化图文对比损失。\",\"推理阶段计算所有图像和文本表示，通过点积获得相似度。\",\"分别编码方式比融合编码器推理速度快得多（图 3）。\"]},\"268\":{\"h\":\"Ablation Studies\",\"t\":[\"阶段式预训练（Stagewise Pre-Training）\",\"我们首先进行了阶段式预训练的消融实验。ViLT 表明：使用在图像数据上预训练的 ViT 作为初始化，比使用在文本数据上预训练的 BERT 模型表现更好。因此，我们的实验从图像预训练开始。我们比较了两种初始化方式：\",\"图像预训练：直接使用 BEIT-Base 的参数初始化自注意力模块和所有模态专家。\",\"图像预训练 + 文本预训练：使用 BEIT-Base 的参数初始化 MOME Transformer 的视觉专家和自注意力模块，然后在文本语料上预训练语言专家。\",\"实验结果（见表4）显示：相比单独图像预训练，图像预训练 + 文本预训练进一步提升了视觉语言模型的性能。我们也尝试过随机初始化直接进行视觉语言预训练，但下游任务的准确率较低。阶段式预训练能够有效利用大规模图像语料与文本语料，从而提升视觉语言预训练效果。此外，考虑到我们使用的图文对数量有限，阶段式预训练能够缓解对大量图文对数据的依赖。\",\"MOME Transformer\",\"我们还进行了 MOME Transformer 的消融实验，使用 ViT-Base 作为模型初始化。实验结果（见表5）表明：\",\"使用 MOME Transformer 在检索和分类任务中都优于标准 Transformer。\",\"我们进一步分析了 MOME Transformer 中的视觉语言专家（VL-FFN）的贡献。当移除顶层 Transformer 层中的视觉语言专家时，模型性能下降，说明视觉语言专家有助于捕获更多的模态交互信息。\",\"共享的自注意力模块也对模型有积极贡献。关于共享自注意力模块的消融结果，详见附录 A。\",\"预训练任务（Pre-Training Tasks）\",\"我们对不同预训练任务的贡献进行了消融实验，结果见表5。\",\"仅使用图文对比损失训练的模型性能显著低于我们统一训练框架下的模型。\",\"引入带有 困难负样本挖掘（hard negative mining） 的图文匹配任务，显著提升了模型性能，验证了 MOME Transformer 统一训练框架的有效性。\",\"此外，实验结果显示 遮盖语言建模（MLM） 任务也能进一步提升模型效果。更多消融实验见附录。\",\"全局困难负样本挖掘（Global Hard Negative Mining）\",\"与 ALBEF [23] 不同，后者只从单个 GPU 的训练样本中采样困难负样本（称为 局部困难负样本挖掘）。我们的方法则从所有 GPU 的训练样本中采样困难负样本（称为 全局困难负样本挖掘）。实验结果（见表6）表明：全局困难负样本挖掘带来了显著的性能提升。\",\"共享自注意力机制的消融实验\",\"表7展示了在 MOME Transformer 中使用的共享自注意力模块的消融实验结果，该模块用于编码图像 patch 与文本 token。\",\"研究者将 共享自注意力（shared self-attention） 与 分离自注意力（separate self-attention） 进行对比。后者在前 层中，分别采用不同的注意力参数对图像 patch 和文本 token 进行编码。\",\"实验结果表明：\",\"使用 MOME 的共享自注意力效果更好。\",\"共享自注意力模块能够帮助 VLMO 学习不同模态之间的对齐关系，并在底层融合图像与文本，从而提升分类任务的表现。\"]},\"269\":{\"h\":\"Conclusion\",\"t\":[\"VLMO 是一个统一的视觉-语言预训练模型，它基于 MOME Transformer。MOME 引入了一组模态专家（modality experts），用于处理模态特定的信息，并通过共享的自注意力模块实现不同模态的对齐。\",\"因此，VLMO 可以同时支持两种不同的应用方式：\",\"作为 双编码器（dual encoder），分别编码图像和文本，并进行相似度计算，从而实现高效的视觉-语言检索任务；\",\"作为 融合编码器（fusion encoder），直接建模图像与文本的交互，用于更复杂的跨模态分类任务。\",\"研究表明，单靠有限规模的图文对数据进行预训练不足以获得最佳效果。VLMO 采用了阶段式预训练策略：\",\"先利用大规模 图像语料 和 文本语料 进行单模态预训练；\",\"再进行视觉-语言联合预训练。\",\"这种方式显著提升了模型的效果，并且缓解了对大规模图文对数据的依赖。\",\"未来工作方向：\",\"扩大模型规模：在预训练中使用更大规模的 VLMO 模型；\",\"支持生成任务：将 VLMO 微调用于图像描述（image captioning）等生成类任务，借鉴 UniLM [11] 的方法；\",\"跨模态互助：研究视觉与语言预训练在多大程度上能够互相促进，特别是 MOME 的共享骨干能够自然融合文本与图像表示；\",\"扩展到更多模态：例如语音、视频和结构化知识，以支持通用的多模态预训练。\"]},\"270\":{\"h\":\"VLMo 模型代码解读\",\"t\":[\"VLMO 模型代码解读\",\"论文链接: VLMO: Unified Vision-Language Pre-Training with Mixture-of-Modality-Experts 代码链接: https://github.com/microsoft/unilm/tree/master/vlmo\"]},\"271\":{\"h\":\"前置知识\",\"t\":[\"VLMO 模型的代码实现中主要使用了以下两个库，如果不提前了解一下库的基本用法，可能会导致读不懂代码实现：\",\"Sacred 实验管理框架\",\"PyTorch Lightning\",\"VLMo 模型代码实现是基于 ViLT 模型代码进行修改的，因此如果研究过 ViLT 代码实现的同学，对 VLMo 模型的代码实现应该比较亲切。\"]},\"272\":{\"h\":\"MOME（Mixture of Multimodal Experts）Transformer\",\"t\":[\"VLMO 论文中所提到的 MOME Transformer 的代码实现对应的类是 MultiWayTransformer , 本节我们将一点点完成该类代码的拆解; 首先，既然是 混合多模态专家模型, 那么它就需要具有同时处理图像和文本的能力；对于输入的图像，第一步需要完成图像的切片和嵌入，该功能由 PatchEmbed 类负责完成，具体代码实现如下:\",\"class PatchEmbed(nn.Module): \\\"\\\"\\\" Image to Patch Embedding 将输入的图像切分成小 patch，并通过卷积映射到指定的 embedding 维度。 这是 Vision Transformer (ViT) 中常用的图像嵌入方法。 \\\"\\\"\\\" def __init__( self, img_size=224, # 输入图像的高度和宽度（默认224x224） patch_size=16, # 每个patch的高度和宽度（默认16x16） in_chans=3, # 输入通道数，彩色图像通常为3 embed_dim=768, # 输出 embedding 的维度 no_patch_embed_bias=False, # 是否在卷积层中去掉偏置 ): super().__init__() # 将 img_size 和 patch_size 转换为 (height, width) 的 tuple img_size = to_2tuple(img_size) patch_size = to_2tuple(patch_size) # 计算图像能切分成多少个 patch num_patches = (img_size[1] // patch_size[1]) * (img_size[0] // patch_size[0]) # 保存 patch 行列数，用于位置编码或其他处理 self.patch_shape = (img_size[0] // patch_size[0], img_size[1] // patch_size[1]) self.img_size = img_size self.patch_size = patch_size self.num_patches = num_patches # 定义卷积层，将图像切分成 patch 并映射到 embedding 维度 # 注意：kernel_size = patch_size, stride = patch_size，这样每个卷积核对应一个 patch self.proj = nn.Conv2d( in_chans, embed_dim, kernel_size=patch_size, stride=patch_size, bias=False if no_patch_embed_bias else True, ) def forward(self, x): B, C, H, W = x.shape # 检查输入图像尺寸是否与初始化尺寸匹配 assert H == self.img_size[0] and W == self.img_size[1], \\\\ f\\\"Input image size ({H}*{W}) doesn't match model ({self.img_size[0]}*{self.img_size[1]}).\\\" # 卷积映射，将图像切分成 patch 并生成 embedding x = self.proj(x) # 输出 shape: [B, embed_dim, H_patch, W_patch] return x\",\"PatchEmbed 只完成了借助卷积对图像进行前置处理的步骤，MultiWayTransformer 类额外提供了 visual_embed 方法来完成与 文本Token 统一形式的 视觉Token 的构建:\",\"class MultiWayTransformer(nn.Module): def visual_embed(self, _x): \\\"\\\"\\\" 将输入的图像张量 _x 转换为视觉 token embedding。 步骤包括： 1. patch embedding 2. 展平并调整维度 3. 添加 cls token 4. 添加位置编码（可选） 5. 添加 dropout \\\"\\\"\\\" # 1. 将图像切分成 patch 并映射到 embedding 维度 x = self.patch_embed(_x) # shape: [B, embed_dim, H_patch, W_patch] # 2. 展平 patch 并调整维度，使其变为序列形式 [B, num_patches, embed_dim] x = x.flatten(2).transpose(1, 2) # flatten 从 H*W -> L，transpose 调整维度 B, L, _ = x.shape # B: batch size, L: patch 数量, _: embedding 维度 # 3. 扩展 cls_token 到 batch 大小，并与 patch embedding 拼接 cls_tokens = self.cls_token.expand(B, -1, -1) # shape: [B, 1, embed_dim] x = torch.cat((cls_tokens, x), dim=1) # 拼接后 shape: [B, L+1, embed_dim] # 4. 如果有位置编码，则加上 if self.pos_embed is not None: x = x + self.pos_embed # shape: [B, L+1, embed_dim] # 5. 添加 dropout，增加模型鲁棒性 x = self.pos_drop(x) # 6. 构建 mask，这里全 1 表示所有 token 都有效 x_mask = torch.ones(x.shape[0], x.shape[1]) # shape: [B, L+1] return x, x_mask # 返回 token embedding 和 mask\",\"MultiWayTransformer 类没有直接对外提供现成的 forward 方法实现，而是由调用方 VLMo 类负责完成前向传播流程的组织，所以下面我们将首先对其 init 方法进行分析，看看它内部包含哪些重要组件:\",\"class MultiWayTransformer(nn.Module): def __init__( self, img_size=224, # 输入图像尺寸 patch_size=16, # patch 大小 in_chans=3, # 输入通道数（例如 RGB 图像为 3） embed_dim=768, # embedding 维度 depth=12, # transformer block 层数 num_heads=12, # attention 头数 mlp_ratio=4.0, # MLP 隐层维度与 embedding 维度的比例 qkv_bias=True, # 是否在 QKV 上使用偏置 qk_scale=None, # 可手动设置 QK 缩放值 drop_rate=0.0, # dropout 概率 attn_drop_rate=0.0, # attention dropout 概率 drop_path_rate=0.0, # stochastic depth 概率 norm_layer=None, # normalization 层类型 need_relative_position_embed=True, # 是否使用相对位置编码 use_abs_pos_emb=False, # 是否使用绝对位置编码 layer_scale_init_values=0.1, # LayerScale 初始化值 vlffn_start_layer_index=10, # 从第几层开始使用 VL-FFN config=None, # 其他配置（如从 pytorch-lightning 传入） **kwargs, # 接收 timm 或其他传入的额外参数 ): \\\"\\\"\\\" MultiWayTransformer 构造函数，初始化视觉与文本 transformer 的参数。 \\\"\\\"\\\" super().__init__() # 如果传入 config，则覆盖 drop_path_rate drop_path_rate = drop_path_rate if config is None else config[\\\"drop_path_rate\\\"] # 保存是否使用绝对位置编码和相对位置编码的标志 self.use_abs_pos_emb = use_abs_pos_emb self.need_relative_position_embed = need_relative_position_embed # 记录 embedding 特征维度 self.num_features = (self.embed_dim) = embed_dim # num_features 与 embed_dim 保持一致 # 默认归一化层，如果未指定则使用 LayerNorm norm_layer = norm_layer or partial(nn.LayerNorm, eps=1e-6) # PatchEmbedding，将图像切分为 patch 并映射到 embed_dim self.patch_embed = PatchEmbed( img_size=img_size, patch_size=patch_size, in_chans=in_chans, embed_dim=embed_dim, ) # 记录 patch 数量和 patch 尺寸 num_patches = self.patch_embed.num_patches self.patch_size = patch_size self.num_heads = num_heads # VL-FFN 从哪一层开始 self.vlffn_start_layer_index = vlffn_start_layer_index # 针对 text-only pretraining，如果 textmlm loss 大于 0，则从最后一层开始使用 VL-FFN if config[\\\"loss_names\\\"][\\\"textmlm\\\"] > 0: self.vlffn_start_layer_index = depth # 类别 token 参数（用于全局聚合） self.cls_token = nn.Parameter(torch.zeros(1, 1, embed_dim)) # 绝对位置编码参数（可选） self.pos_embed = nn.Parameter(torch.zeros(1, num_patches + 1, embed_dim)) if self.use_abs_pos_emb else None # dropout 层 self.pos_drop = nn.Dropout(p=drop_rate) # stochastic depth，每层的 drop_path 概率线性增长 dpr = [x.item() for x in torch.linspace(0, drop_path_rate, depth)] # 构建 transformer block 列表 self.blocks = nn.ModuleList( [ Block( dim=embed_dim, num_heads=num_heads, mlp_ratio=mlp_ratio, qkv_bias=qkv_bias, qk_scale=qk_scale, drop=drop_rate, attn_drop=attn_drop_rate, drop_path=dpr[i], norm_layer=norm_layer, with_vlffn=(i >= self.vlffn_start_layer_index), # 超过起始层索引才启用 VL-FFN layer_scale_init_values=layer_scale_init_values, max_text_len=config[\\\"max_text_len\\\"], ) for i in range(depth) ] ) # transformer 最后的归一化层 self.norm = norm_layer(embed_dim) # 参数初始化 if self.pos_embed is not None: trunc_normal_(self.pos_embed, std=0.02) trunc_normal_(self.cls_token, std=0.02) self.apply(self._init_weights) # 初始化所有权重\",\"MultiWayTransformer 支持同时处理文本和图像模态，这个功能具体实现在其内部的 Transformer Block 中:\",\"class Block(nn.Module): def __init__( self, dim, # 输入特征维度 num_heads, # 多头注意力的头数 mlp_ratio=4.0, # MLP 隐藏层维度与输入维度的比例 qkv_bias=False, # QKV 是否使用偏置 qk_scale=None, # QK 缩放因子（覆盖默认 head_dim ** -0.5） drop=0.0, # Dropout 概率 attn_drop=0.0, # 注意力权重的 Dropout 概率 drop_path=0.0, # Stochastic Depth 概率 act_layer=nn.GELU, # 激活函数类型 norm_layer=nn.LayerNorm, # 归一化层类型 with_vlffn=False, # 是否使用跨模态 MLP（Vision-Language Feed-Forward Network） layer_scale_init_values=0.1, # LayerScale 初始化值 max_text_len=40, # 最大文本序列长度 ): super().__init__() # 第一个 LayerNorm（作用于注意力之前） self.norm1 = norm_layer(dim) # 多头注意力机制 self.attn = Attention( dim, num_heads=num_heads, qkv_bias=qkv_bias, qk_scale=qk_scale, attn_drop=attn_drop, proj_drop=drop, ) # DropPath（随机丢弃整个残差分支）或恒等映射 self.drop_path = DropPath(drop_path) if drop_path > 0.0 else nn.Identity() # 第二阶段的 LayerNorm（针对文本和图像分别有独立的归一化层） self.norm2_text = norm_layer(dim) self.norm2_imag = norm_layer(dim) # MLP 隐藏层维度 mlp_hidden_dim = int(dim * mlp_ratio) # 文本模态的 MLP self.mlp_text = Mlp( in_features=dim, hidden_features=mlp_hidden_dim, act_layer=act_layer, drop=drop, ) # 图像模态的 MLP self.mlp_imag = Mlp( in_features=dim, hidden_features=mlp_hidden_dim, act_layer=act_layer, drop=drop, ) # 跨模态 MLP（仅在 with_vlffn=True 时使用） self.mlp_vl = None if with_vlffn: self.mlp_vl = Mlp( in_features=dim, hidden_features=mlp_hidden_dim, act_layer=act_layer, drop=drop, ) self.norm2_vl = norm_layer(dim) # LayerScale 参数（gamma_1 作用于注意力分支，gamma_2 作用于 MLP 分支） self.gamma_1 = ( nn.Parameter(layer_scale_init_values * torch.ones((dim)), requires_grad=True) if layer_scale_init_values is not None else 1.0 ) self.gamma_2 = ( nn.Parameter(layer_scale_init_values * torch.ones((dim)), requires_grad=True) if layer_scale_init_values is not None else 1.0 ) # 最大文本长度（在拆分多模态输入时使用） self.max_text_len = max_text_len def forward(self, x, mask=None, modality_type=None, relative_position_bias=None): \\\"\\\"\\\" Args: x: 输入特征 [B, L, C] mask: 注意力掩码（可选） modality_type: 输入模态类型 (\\\"image\\\", \\\"text\\\", 或 None 表示多模态） relative_position_bias: 相对位置编码偏置 \\\"\\\"\\\" # ====== 注意力子层（带残差连接 + LayerScale + DropPath）====== x = x + self.drop_path( self.gamma_1 * self.attn( self.norm1(x), mask=mask, relative_position_bias=relative_position_bias ) ) # ====== 前馈网络子层（根据模态类型选择不同 MLP）====== if modality_type == \\\"image\\\": # 仅图像模态 x = x + self.drop_path(self.gamma_2 * self.mlp_imag(self.norm2_imag(x))) elif modality_type == \\\"text\\\": # 仅文本模态 x = x + self.drop_path(self.gamma_2 * self.mlp_text(self.norm2_text(x))) else: # 多模态情况 if self.mlp_vl is None: # 分开处理文本和图像序列 x_text = x[:, : self.max_text_len] # 前 max_text_len 为文本 x_imag = x[:, self.max_text_len :] # 剩余部分为图像 x_text = x_text + self.drop_path(self.gamma_2 * self.mlp_text(self.norm2_text(x_text))) x_imag = x_imag + self.drop_path(self.gamma_2 * self.mlp_imag(self.norm2_imag(x_imag))) # 合并回一个序列 x = torch.cat([x_text, x_imag], dim=1) else: # 跨模态 MLP x = x + self.drop_path(self.gamma_2 * self.mlp_vl(self.norm2_vl(x))) return x\",\"LayerScale 技术: 在深层 Transformer 中，如果直接把残差相加，可能导致梯度爆炸或梯度消失; LayerScale 允许网络自己调节每一层的残差输出强度，从而改善训练稳定性。提高深层网络可训练性； 对深层 ViT（几十甚至上百层）非常有效，减少了训练前期的收敛难度。\",\"简单理解：\",\"x = x + γ1 * Attention(x) x = x + γ2 * MLP(x)\",\"γ1、γ2 = 可学习缩放因子\",\"作用 = 控制残差贡献，稳定训练\",\"为什么分开？因为 Attention 和 MLP 输出的统计特性不同，需要不同的缩放系数\",\"Attention 模块的代码属于模版代码，不涉及新技术的引入，代码实现如下所示:\",\"class Attention(nn.Module): def __init__( self, dim, # 输入特征的维度 (embedding dimension) num_heads=8, # 多头注意力的头数 qkv_bias=False, # 是否为 Q、K、V 添加可学习偏置 qk_scale=None, # QK 点积的缩放因子（可覆盖默认值） attn_drop=0.0, # 注意力权重的 Dropout 概率 proj_drop=0.0, # 输出投影层的 Dropout 概率 ): super().__init__() self.num_heads = num_heads head_dim = dim // num_heads # 每个注意力头的维度 # QK 缩放因子，默认为 1/sqrt(head_dim)，防止点积结果过大 self.scale = qk_scale or head_dim ** -0.5 # 线性层生成 Q、K、V（一次性计算 dim → 3*dim） self.qkv = nn.Linear(dim, dim * 3, bias=False) # 如果需要 Q、V 偏置，则单独为 Q 和 V 创建可学习参数 if qkv_bias: self.q_bias = nn.Parameter(torch.zeros(dim)) self.v_bias = nn.Parameter(torch.zeros(dim)) else: self.q_bias = None self.v_bias = None # 注意力权重的 Dropout self.attn_drop = nn.Dropout(attn_drop) # 注意力结果的输出投影层 self.proj = nn.Linear(dim, dim) # 输出投影后的 Dropout self.proj_drop = nn.Dropout(proj_drop) def forward(self, x, mask=None, relative_position_bias=None): \\\"\\\"\\\" Args: x: 输入张量 (B, N, C)， B=批大小，N=序列长度，C=通道数(embedding dim) mask: 注意力掩码 (B, N)，用于屏蔽无效位置 relative_position_bias: 相对位置编码 (num_heads, N, N) \\\"\\\"\\\" B, N, C = x.shape # 取出批大小、序列长度、通道数 # 处理 Q、K、V 偏置 qkv_bias = None if self.q_bias is not None: # 拼接 Q 偏置、K 偏置(全0)、V 偏置 qkv_bias = torch.cat(( self.q_bias, torch.zeros_like(self.v_bias, requires_grad=False), self.v_bias )) # 线性映射得到 Q、K、V（在这里一次性计算） qkv = F.linear(input=x, weight=self.qkv.weight, bias=qkv_bias) # 变形为 (3, B, num_heads, N, head_dim)，并调整维度顺序 qkv = qkv.reshape(B, N, 3, self.num_heads, -1).permute(2, 0, 3, 1, 4) # 拆分 Q、K、V q, k, v = qkv[0], qkv[1], qkv[2] # 缩放 Q q = q * self.scale # QK^T 得到注意力分数矩阵 attn = (q.float() @ k.float().transpose(-2, -1)) # 如果有相对位置偏置，则加上 if relative_position_bias is not None: attn = attn + relative_position_bias.unsqueeze(0) # 如果有 mask（如解码器中的自回归屏蔽） if mask is not None: mask = mask.bool() attn = attn.masked_fill(~mask[:, None, None, :], float(\\\"-inf\\\")) # 对最后一维做 softmax 得到注意力权重 attn = attn.softmax(dim=-1).type_as(x) # 对注意力权重做 Dropout attn = self.attn_drop(attn) # 注意力加权 V，然后还原维度为 (B, N, C) x = (attn @ v).transpose(1, 2).reshape(B, N, C) # 输出投影 x = self.proj(x) # 投影结果 Dropout x = self.proj_drop(x) return x\"]},\"273\":{\"h\":\"VLMo\",\"t\":[\"主模型 VLMo 由于使用了 PyTorch Lightning 实验全流程管理框架，使得其代码看起来并不常规，但是其本质还是借助 模版方法设计模型 抽取出一套通用的模版流程，并通过在各个模版节点预留钩子函数的方式，使得用户可以在不改变模版流程的情况下，自定义模型的行为;\",\"因此，我们首先用一幅图理清楚 PyTorch Lightning 预留的这套模版流程是怎么设计的:\",\"图片取至 PytorchLightning : Model calls order\",\"1. 初始化阶段 ├─ 用户创建 LightningModule 和 Trainer (用户代码) ├─ LightningModule.configure_optimizers() (LightningModule) ├─ Trainer 配置 logger、callbacks、accelerator、分布式 (Trainer 内部) 2. 数据准备阶段 ├─ LightningDataModule.prepare_data() (LightningDataModule, global_rank=0) └─ LightningDataModule.setup(stage) (LightningDataModule, 每个进程, stage ∈ {'fit','validate','test','predict'}) 3. 数据加载阶段 ├─ LightningDataModule.train_dataloader() (LightningDataModule) ├─ LightningDataModule.val_dataloader() (LightningDataModule) └─ LightningDataModule.test_dataloader() (LightningDataModule) 4. 训练阶段（fit） ├─ Trainer.on_fit_start() (Trainer 调用所有 callbacks.on_fit_start) └─ Epoch 循环 (for epoch in max_epochs) ├─ Trainer.on_train_epoch_start() (Trainer callbacks) └─ Batch 循环 (for batch in train_dataloader) ├─ Trainer.on_train_batch_start(batch, batch_idx) (Trainer callbacks) ├─ LightningModule.training_step(batch, batch_idx) (LightningModule) ├─ Trainer.on_before_zero_grad(optimizer) (Trainer callbacks) ├─ optimizer.zero_grad() (PyTorch) ├─ loss.backward() (PyTorch) ├─ Trainer.on_after_backward() (Trainer callbacks) ├─ Trainer.on_before_optimizer_step(optimizer) (Trainer callbacks) ├─ optimizer.step() (PyTorch) └─ Trainer.on_train_batch_end(output, batch, batch_idx)(Trainer callbacks) ├─ LightningModule.training_epoch_end(outputs) (LightningModule) └─ Trainer.on_train_epoch_end() (Trainer callbacks) └─ 验证阶段（每个 epoch 后可选） ├─ Trainer.on_validation_start() (Trainer callbacks) ├─ model.eval(), torch.no_grad() (Trainer 内部) └─ 循环 val_dataloader ├─ LightningModule.validation_step(batch, batch_idx) (LightningModule) ├─ LightningModule.validation_step_end(output) (LightningModule) └─ 汇总 outputs ├─ LightningModule.validation_epoch_end(outputs) (LightningModule) └─ Trainer.on_validation_epoch_end() (Trainer callbacks) └─ Trainer.on_fit_end() (Trainer callbacks) 5. 测试阶段（test） ├─ Trainer.on_test_start() (Trainer callbacks) ├─ model.eval(), torch.no_grad() (Trainer 内部) └─ 循环 test_dataloader ├─ LightningModule.test_step(batch, batch_idx) (LightningModule) ├─ LightningModule.test_step_end(output) (LightningModule) └─ 汇总 outputs ├─ LightningModule.test_epoch_end(outputs) (LightningModule) └─ Trainer.on_test_end() (Trainer callbacks) 6. 预测阶段（predict） ├─ Trainer.on_predict_start() (Trainer callbacks) ├─ model.eval(), torch.no_grad() (Trainer 内部) └─ 循环 predict_dataloader ├─ LightningModule.predict_step(batch, batch_idx) (LightningModule) ├─ LightningModule.predict_step_end(output) (LightningModule) └─ 汇总 outputs ├─ LightningModule.predict_epoch_end(outputs) (LightningModule) └─ Trainer.on_predict_end() (Trainer callbacks)\",\"下面我们将结合上面的模版流程，分析一下 VLMo 在模版流程的各种阶段都做了什么:\"]},\"274\":{\"h\":\"数据模块\",\"t\":[\"一般模型训练都会加载多个来源不同的开源或私有数据集，VLMo 也不例外，因此 VLMo 提供了 MTDataModule 类用于完成多数据源加载的任务:\",\"class MTDataModule(LightningDataModule): def __init__(self, _config, dist=False): \\\"\\\"\\\" 多任务/多数据集 DataModule，负责管理多个子数据集 Args: _config: 配置字典，包含数据集 key 和其他参数 dist: 是否使用分布式采样 \\\"\\\"\\\" datamodule_keys = _config[\\\"datasets\\\"] assert len(datamodule_keys) > 0 super().__init__() # 保存数据集 key 和对应的数据模块实例 self.dm_keys = datamodule_keys self.dm_dicts = {key: _datamodules[key](_config) for key in datamodule_keys} self.dms = [v for k, v in self.dm_dicts.items()] # 从第一个数据模块读取通用配置 self.batch_size = self.dms[0].batch_size self.vocab_size = self.dms[0].vocab_size self.num_workers = self.dms[0].num_workers self.dist = dist # 是否使用分布式采样 def prepare_data(self): \\\"\\\"\\\" 数据准备阶段（只在主进程调用一次） 生命周期阶段: Trainer 调用 prepare_data() \\\"\\\"\\\" for dm in self.dms: dm.prepare_data() # 调用每个子数据模块的 prepare_data def setup(self, stage): \\\"\\\"\\\" 数据集构建阶段，每个进程都会调用 Args: stage: 'fit', 'validate', 'test', 'predict' 等 \\\"\\\"\\\" for dm in self.dms: dm.setup(stage) # 调用子数据模块的 setup # 合并各个子数据集 self.train_dataset = ConcatDataset([dm.train_dataset for dm in self.dms]) self.val_dataset = ConcatDataset([dm.val_dataset for dm in self.dms]) self.test_dataset = ConcatDataset([dm.test_dataset for dm in self.dms]) # 保存 tokenizer 和 collate 函数 self.tokenizer = self.dms[0].tokenizer self.collate = functools.partial( self.dms[0].train_dataset.collate, mlm_collator=self.dms[0].mlm_collator, ) # 分布式采样器 if self.dist and torch.distributed.is_initialized(): self.train_sampler = DistributedSampler(self.train_dataset, shuffle=True) self.val_sampler = DistributedSampler(self.val_dataset, shuffle=True) self.test_sampler = DistributedSampler(self.test_dataset, shuffle=False) else: self.train_sampler = None self.val_sampler = None self.test_sampler = None def train_dataloader(self): \\\"\\\"\\\" 返回训练 DataLoader 生命周期阶段: Trainer.fit() 内部调用 \\\"\\\"\\\" loader = DataLoader( self.train_dataset, batch_size=self.batch_size, sampler=self.train_sampler, num_workers=self.num_workers, collate_fn=self.collate, ) return loader def val_dataloader(self, batch_size=None): \\\"\\\"\\\" 返回验证 DataLoader 生命周期阶段: Trainer.validate() 或 Trainer.fit() 内部验证调用 \\\"\\\"\\\" loader = DataLoader( self.val_dataset, batch_size=batch_size if batch_size is not None else self.batch_size, sampler=self.val_sampler, num_workers=self.num_workers, collate_fn=self.collate, ) return loader def test_dataloader(self): \\\"\\\"\\\" 返回测试 DataLoader 生命周期阶段: Trainer.test() 内部调用 \\\"\\\"\\\" loader = DataLoader( self.test_dataset, batch_size=self.batch_size, sampler=self.test_sampler, num_workers=self.num_workers, collate_fn=self.collate, ) return loader\",\"_datamodules 字典中保存了 VLMo 所使用到的所有数据集对应的 DataModule 实现类:\",\"_datamodules = { \\\"vg\\\": VisualGenomeCaptionDataModule, \\\"f30k\\\": F30KCaptionKarpathyDataModule, \\\"coco\\\": CocoCaptionKarpathyDataModule, \\\"gcc\\\": ConceptualCaptionDataModule, \\\"sbu\\\": SBUCaptionDataModule, \\\"wikibk\\\": WikibkDataModule, \\\"vqa\\\": VQAv2DataModule, \\\"nlvr2\\\": NLVR2DataModule, }\",\"当子实现类比较多的时候，自然会存在一些重复性操作，因此 VLMo 模型的代码实现中额外抽取了一个抽象类 BaseDataModule 用于定义重复性的模版流程，以此来简化子实现类需要做的操作:\",\"class BaseDataModule(LightningDataModule): def __init__(self, _config): \\\"\\\"\\\" 基础 DataModule 类，支持图文/文本数据集 Args: _config: 配置字典，包含数据路径、batch_size、tokenizer 等信息 \\\"\\\"\\\" super().__init__() # 数据目录 self.data_dir = _config[\\\"data_root\\\"] # DataLoader 参数 self.num_workers = _config[\\\"num_workers\\\"] self.batch_size = _config[\\\"per_gpu_batchsize\\\"] self.eval_batch_size = self.batch_size # 数据处理参数 self.image_size = _config[\\\"image_size\\\"] self.max_text_len = _config[\\\"max_text_len\\\"] self.draw_false_image = _config[\\\"draw_false_image\\\"] self.draw_false_text = _config[\\\"draw_false_text\\\"] self.image_only = _config[\\\"image_only\\\"] self.text_only = _config[\\\"text_only\\\"] # 数据增强/transform 配置 self.train_transform_keys = ( [\\\"default_train\\\"] if len(_config[\\\"train_transform_keys\\\"]) == 0 else _config[\\\"train_transform_keys\\\"] ) self.val_transform_keys = ( [\\\"default_val\\\"] if len(_config[\\\"val_transform_keys\\\"]) == 0 else _config[\\\"val_transform_keys\\\"] ) # tokenizer tokenizer = _config[\\\"tokenizer\\\"] self.tokenizer = get_pretrained_tokenizer(tokenizer) self.vocab_size = self.tokenizer.vocab_size # collator: 用于 MLM（mask language model）训练 collator = ( DataCollatorForWholeWordMask if _config[\\\"whole_word_masking\\\"] else DataCollatorForLanguageModeling ) self.mlm_collator = collator( tokenizer=self.tokenizer, mlm=True, mlm_probability=_config[\\\"mlm_prob\\\"] ) # setup 状态标志，确保 setup 只执行一次 self.setup_flag = False @property def dataset_cls(self): \\\"\\\"\\\" 子类必须实现 返回 dataset 类（通常是 Dataset 子类） \\\"\\\"\\\" raise NotImplementedError(\\\"return tuple of dataset class\\\") @property def dataset_name(self): \\\"\\\"\\\" 子类必须实现 返回数据集名称 \\\"\\\"\\\" raise NotImplementedError(\\\"return name of dataset\\\") def set_train_dataset(self): \\\"\\\"\\\" 构建训练数据集 生命周期阶段: setup() 调用 \\\"\\\"\\\" self.train_dataset = self.dataset_cls( self.data_dir, self.train_transform_keys, split=\\\"train\\\", image_size=self.image_size, max_text_len=self.max_text_len, draw_false_image=self.draw_false_image, draw_false_text=self.draw_false_text, image_only=self.image_only, ) def set_val_dataset(self): \\\"\\\"\\\" 构建验证数据集 生命周期阶段: setup() 调用 \\\"\\\"\\\" self.val_dataset = self.dataset_cls( self.data_dir, self.val_transform_keys, split=\\\"val\\\", image_size=self.image_size, max_text_len=self.max_text_len, draw_false_image=self.draw_false_image, draw_false_text=self.draw_false_text, image_only=self.image_only, ) # 如果存在“无干扰”验证数据集类，额外构建 if hasattr(self, \\\"dataset_cls_no_false\\\"): self.val_dataset_no_false = self.dataset_cls_no_false( self.data_dir, self.val_transform_keys, split=\\\"val\\\", image_size=self.image_size, max_text_len=self.max_text_len, draw_false_image=0, draw_false_text=0, image_only=self.image_only, ) def make_no_false_val_dset(self, image_only=False): \\\"\\\"\\\" 构建无干扰验证数据集（用于评估） \\\"\\\"\\\" return self.dataset_cls_no_false( self.data_dir, self.val_transform_keys, split=\\\"val\\\", image_size=self.image_size, max_text_len=self.max_text_len, draw_false_image=0, draw_false_text=0, image_only=image_only, ) def make_no_false_test_dset(self, image_only=False): \\\"\\\"\\\" 构建无干扰测试数据集（用于评估） \\\"\\\"\\\" return self.dataset_cls_no_false( self.data_dir, self.val_transform_keys, split=\\\"test\\\", image_size=self.image_size, max_text_len=self.max_text_len, draw_false_image=0, draw_false_text=0, image_only=image_only, ) def set_test_dataset(self): \\\"\\\"\\\" 构建测试数据集 生命周期阶段: setup() 调用 \\\"\\\"\\\" self.test_dataset = self.dataset_cls( self.data_dir, self.val_transform_keys, split=\\\"test\\\", image_size=self.image_size, max_text_len=self.max_text_len, draw_false_image=self.draw_false_image, draw_false_text=self.draw_false_text, image_only=self.image_only, ) def setup(self, stage): \\\"\\\"\\\" 数据集构建钩子 生命周期阶段: Trainer.fit(), Trainer.validate(), Trainer.test() 内部调用 \\\"\\\"\\\" if not self.setup_flag: # 构建 train/val/test 数据集 self.set_train_dataset() self.set_val_dataset() self.set_test_dataset() # 给 dataset 注入 tokenizer self.train_dataset.tokenizer = self.tokenizer self.val_dataset.tokenizer = self.tokenizer self.test_dataset.tokenizer = self.tokenizer self.setup_flag = True # 标记 setup 已完成 def train_dataloader(self): \\\"\\\"\\\" 构建训练 DataLoader 生命周期阶段: Trainer.fit() 内部调用 \\\"\\\"\\\" loader = DataLoader( self.train_dataset, batch_size=self.batch_size, shuffle=True, # 训练集通常打乱 num_workers=self.num_workers, pin_memory=True, collate_fn=self.train_dataset.collate, ) return loader def val_dataloader(self): \\\"\\\"\\\" 构建验证 DataLoader 生命周期阶段: Trainer.validate() 或 Trainer.fit() 内部验证调用 \\\"\\\"\\\" loader = DataLoader( self.val_dataset, batch_size=self.eval_batch_size, shuffle=False, num_workers=self.num_workers, pin_memory=True, collate_fn=self.val_dataset.collate, ) return loader def test_dataloader(self): \\\"\\\"\\\" 构建测试 DataLoader 生命周期阶段: Trainer.test() 内部调用 \\\"\\\"\\\" loader = DataLoader( self.test_dataset, batch_size=self.eval_batch_size, shuffle=False, num_workers=self.num_workers, pin_memory=True, collate_fn=self.test_dataset.collate, ) return loader\",\"VLMo 在训练或验证数据集可能会加入一些“干扰样本”：\",\"draw_false_image=1：给文本配上错误图像\",\"draw_false_text=1：给图像配上错误文本\",\"这种策略有助于模型学习跨模态对齐能力，增强鲁棒性，但它会让数据本身有“噪声”。\",\"为什么需要无干扰数据集？\",\"在训练中，你希望模型看到“有干扰”的数据，提高判别能力；\",\"在评估阶段，你希望衡量模型在真实匹配样本上的性能，这时候就要去掉干扰，即 draw_false_image=0、draw_false_text=0；\",\"这保证了评估指标（如准确率、召回率等）反映的是模型对正确样本的能力，而不是对抗干扰样本的能力。\",\"具体实现:\",\"make_no_false_val_dset → 构建无干扰的验证集，保证验证指标真实可靠；\",\"make_no_false_test_dset → 构建无干扰的测试集，用于最终评估模型效果；\",\"可以选择 image_only=True 或 False 来控制是否只用图像作为输入。\",\"有了 BaseDataModule 类负责完成通用模版流程的抽取，子类需要做的事情就非常简单了，只需要告知父类自己的数据集名和数据集类的具体实现即可:\",\"class CocoCaptionKarpathyDataModule(BaseDataModule): def __init__(self, *args, **kwargs): super().__init__(*args, **kwargs) @property def dataset_cls(self): return CocoCaptionKarpathyDataset @property def dataset_cls_no_false(self): return CocoCaptionKarpathyDataset @property def dataset_name(self): return \\\"coco\\\"\",\"当 VLMo 通过 LightningDataModule 完成 DataSet 的 prepare 和 set_up 后，下一步便可以通过 DataLoader 来正常获取一个批次的数据了，这里以 CocoCaptionKarpathyDataset 子实现类为例，看一下数据的形式:\",\"class CocoCaptionKarpathyDataset(BaseDataset): def __init__(self, *args, split=\\\"\\\", **kwargs): assert split in [\\\"train\\\", \\\"val\\\", \\\"test\\\"] self.split = split if split == \\\"train\\\": names = [\\\"coco_caption_karpathy_train\\\", \\\"coco_caption_karpathy_restval\\\"] elif split == \\\"val\\\": names = [\\\"coco_caption_karpathy_val\\\"] elif split == \\\"test\\\": names = [\\\"coco_caption_karpathy_test\\\"] super().__init__(*args, **kwargs, names=names, text_column_name=\\\"caption\\\") def __getitem__(self, index): suite = self.get_suite(index) if \\\"test\\\" in self.split: _index, _question_index = self.index_mapper[index] iid = self.table[\\\"image_id\\\"][_index].as_py() iid = int(iid.split(\\\".\\\")[0].split(\\\"_\\\")[-1]) suite.update({\\\"iid\\\": iid}) return suite\",\"通过 CocoCaptionKarpathyDataset 的 __getitem__ 方法，每次可以获取一条样本数据，具体形式如下:\",\"基类 BaseDataset 中提供了 collate 方法，用于 DataLoader 积攒起一批样本数据后，回调该钩子方法完成合适的批量数据格式组织:\",\"class BaseDataset(torch.utils.data.Dataset): def collate(self, batch, mlm_collator): batch_size = len(batch) ... return dict_batch\",\"该方法实现过程比较复杂，但其主要负责将输入的 batch 数据按 key 进行聚合 , 同时对输入的文本数据回调 mlm_collator 钩子方法，完成 Masked Language Modeling（MLM） 任务 , 生成两个新的 key : text_ids_mlm 和 text_labels_mlm 用于表示 MLM 后的 input_ids 和 mask标签。\",\"batch中只有一条数据\",\"按key进行聚合\",\"PyTorch 的 CrossEntropyLoss（尤其是 Hugging Face Transformers 的实现里）中，-100 会被当作 ignore_index，即这些位置不参与 loss 计算\"]},\"275\":{\"h\":\"模型实现\",\"t\":[\"从本节开始，我们将进入 VLMo 模型代码解析的核心部分，首先是其实现的钩子方法 training_step ，该方法负责完成具体的一轮训练实现:\",\"class VLMo(pl.LightningModule): def training_step(self, batch, batch_idx): # 记录一下本轮训练需要推进的学习任务有几个: ['itm', 'itc', 'mlm'] (预训练阶段有三个) vlmo_utils.set_task(self) # 调用 VLMo 的 forward 方法 output = self(batch) # 累加所有学习任务结束后的损失 total_loss = sum([v for k, v in output.items() if \\\"loss\\\" in k]) return total_loss\",\"def set_task(pl_module): pl_module.current_tasks = [ k for k, v in pl_module.hparams.config[\\\"loss_names\\\"].items() if v >= 1 ] return\",\"VLMo 模型的前向传播阶段会根据学习任务列表，分别进行多次独立的前向传播完成对应学习任务推进损失的计算，同时将损失记录在字典中:\",\" def forward(self, batch): ret = dict() if len(self.current_tasks) == 0: ret.update(self.infer(batch)) return ret # Masked Language Modeling if \\\"mlm\\\" in self.current_tasks: ret.update(objectives.compute_mlm(self, batch)) # Textonly Masked Language Modeling if \\\"textmlm\\\" in self.current_tasks: ret.update(objectives.compute_textonly_mlm(self, batch)) # Contrastive loss for pretraining if \\\"itc\\\" in self.current_tasks: ret.update(objectives.compute_itc(self, batch)) # Contrastive loss for finetuning if \\\"irtr\\\" in self.current_tasks: ret.update(objectives.compute_irtr(self, batch)) # Image Text Matching with global hard negative, must use with itc if \\\"itm\\\" in self.current_tasks: ret.update(objectives.compute_itm_hardneg(self, batch, ret[\\\"itc_i2t_logits\\\"], ret[\\\"itc_t2i_logits\\\"])) # Visual Question Answering if \\\"vqa\\\" in self.current_tasks: ret.update(objectives.compute_vqa(self, batch)) # Natural Language for Visual Reasoning 2 if \\\"nlvr2\\\" in self.current_tasks: ret.update(objectives.compute_nlvr2(self, batch)) return ret\",\"下面会分小节独立对每个学习任务的计算过程进行详解:\"]},\"276\":{\"h\":\"Masked Language Modeling\",\"t\":[\"第一个学习目标是 MLM 任务，该任务的学习目标是根据未被掩码的图像序列和文本序列，去预测被掩码的 Token 原来的标签; 具体代码实现如下所示:\",\"def infer( self, batch, mask_text=False, # 是否对文本做MLM掩码（Mask Language Modeling） mask_image=False, # 是否对图像做mask（当前代码未使用） image_token_type_idx=1, # 图像 token 类型的索引（用于 token_type_embeddings） image_embeds=None, # 可选：外部直接传入图像embedding image_masks=None, # 可选：外部直接传入图像mask ): # 1. 选择图像键名 (去除多视角图像选择逻辑) imgkey = \\\"image\\\" # 2. 确定是否使用 MLM 数据（_mlm 后缀） do_mlm = \\\"_mlm\\\" if mask_text else \\\"\\\" # 3. 取出文本相关的张量 text_ids = batch[f\\\"text_ids{do_mlm}\\\"] # 文本 token ID text_labels = batch[f\\\"text_labels{do_mlm}\\\"] # 文本标签（训练时可能是-100占位） text_masks = batch[f\\\"text_masks\\\"] # 文本 attention mask（padding位置为0） # 4. 将 token ID 转成嵌入向量 text_embeds = self.text_embeddings(text_ids) # 5. 取出图像并做视觉编码 img = batch[imgkey][0] # 图像张量（通常是 [B, C, H, W]） image_embeds, image_masks = self.transformer.visual_embed(img) # image_embeds: 图像的 patch embedding # image_masks: 图像的 attention mask # 6. 转成 long 类型（以防下游 embedding 索引出错） image_masks = image_masks.long() # 7. 给文本和图像 embedding 添加 token type embedding（区分模态） text_embeds, image_embeds = ( text_embeds + self.token_type_embeddings(torch.zeros_like(text_masks)), # 文本类型 idx=0 image_embeds + self.token_type_embeddings( torch.full_like(image_masks, image_token_type_idx) # 图像类型 idx=image_token_type_idx ), ) # 8. 将文本和图像序列拼接 co_embeds = torch.cat([text_embeds, image_embeds], dim=1) # 拼接 embedding co_masks = torch.cat([text_masks, image_masks], dim=1) # 拼接 mask # 9. 输入 transformer encoder x = co_embeds relative_position_bias_list = self.get_rel_pos_bias(self.text_imag_relative_position_index) for i, blk in enumerate(self.transformer.blocks): # 每个 block 都处理文本+图像的联合序列 x = blk( x, mask=co_masks, modality_type=\\\"vl\\\", relative_position_bias=relative_position_bias_list[i] ) # 10. LayerNorm 归一化 x = self.transformer.norm(x) # 11. 拆回文本特征和图像特征 text_feats, image_feats = ( x[:, : text_embeds.shape[1]], # 前半部分是文本 x[:, text_embeds.shape[1] :], # 后半部分是图像 ) # 12. 获取 CLS token 的池化特征 cls_feats = self.pooler(x) # 一般是 x[:,0] 做线性变换 # 但这里保留 raw_cls_feats 也就是未pooler的 # 13. 返回推理结果字典 ret = { \\\"text_feats\\\": text_feats, # 文本的序列特征 \\\"image_feats\\\": image_feats, # 图像的序列特征 \\\"cls_feats\\\": cls_feats, # CLS token 经过pooler的特征 \\\"raw_cls_feats\\\": x[:, 0], # CLS token的原始特征 \\\"image\\\": img, # 原始图像张量 \\\"text_labels\\\": text_labels, # 文本标签 \\\"text_ids\\\": text_ids, # 文本 token ID \\\"text_masks\\\": text_masks, # 文本 attention mask } return ret\",\"def compute_mlm(pl_module, batch): # 1. 调用 pl_module 的 infer 方法，开启 mask_text=True # 表示对输入文本做 MLM 掩码，mask_image=False 表示不对图像做掩码 # 返回的 infer 字典中包含文本/图像的特征、标签等信息 infer = pl_module.infer(batch, mask_text=True, mask_image=False) # 2. 将文本特征输入 MLM 预测头（mlm_score），得到预测的 token logits (上下文编码投影到词空间) # mlm_logits 形状通常为 [batch_size, seq_len, vocab_size] mlm_logits = pl_module.mlm_score(infer[\\\"text_feats\\\"]) # 3. 取出 MLM 任务的标签 # 标签中非 mask 位置一般是 -100（会被交叉熵忽略） mlm_labels = infer[\\\"text_labels\\\"] # 4. 计算 MLM 的交叉熵损失 # - 将 logits 展平为 [batch_size*seq_len, vocab_size] # - 将 labels 展平为 [batch_size*seq_len] # - ignore_index=-100 表示这些位置不计入损失 mlm_loss = F.cross_entropy( mlm_logits.view(-1, pl_module.hparams.config[\\\"vocab_size\\\"]), mlm_labels.view(-1), ignore_index=-100, ) # 5. 将 MLM 损失乘以权重 0.25（可能是多任务训练中给 MLM 任务的损失权重） ret = { \\\"mlm_loss\\\": mlm_loss * 0.25, \\\"mlm_logits\\\": mlm_logits, \\\"mlm_labels\\\": mlm_labels, \\\"mlm_ids\\\": infer[\\\"text_ids\\\"], # 原始文本 token id } # 6. 判断当前是训练阶段还是验证阶段 phase = \\\"train\\\" if pl_module.training else \\\"val\\\" # 7. 将 MLM 损失记录到 pl_module 的对应指标（train_mlm_loss 或 val_mlm_loss） loss = getattr(pl_module, f\\\"{phase}_mlm_loss\\\")(ret[\\\"mlm_loss\\\"]) # 8. 计算 MLM 预测准确率（忽略 -100 的位置） acc = getattr(pl_module, f\\\"{phase}_mlm_accuracy\\\")( ret[\\\"mlm_logits\\\"], ret[\\\"mlm_labels\\\"] ) # 9. 记录损失和准确率到日志（方便 TensorBoard / WandB 可视化） pl_module.log(f\\\"mlm/{phase}/loss\\\", loss) pl_module.log(f\\\"mlm/{phase}/accuracy\\\", acc) # 10. 返回结果字典（损失、预测值、标签、文本id） return ret\"]},\"277\":{\"h\":\"Contrastive loss for pretraining\",\"t\":[\"第二个学习目标是 ITC 任务，该任务的学习目标是采用对比学习策略，最大化相似度矩阵对角线的相似度得分，同时最小化非对角线的非匹配样本相似度得分。\",\"def infer_image( self, batch, mask_image=False, # 是否对图像进行 mask（传参保留，但当前实现未使用） image_token_type_idx=1, # 图像 token type id（区分 text=0, image=1） image_embeds=None, # 预计算好的图像 embedding（可选） image_masks=None, # 预计算好的图像 mask（可选） ): # ====== Step 1: 从 batch 取图像 ====== imgkey = \\\"image\\\" img = batch[imgkey][0] # batch[\\\"image\\\"] 是一个列表，取第 0 个元素作为输入图像 # ====== Step 2: 图像编码（patch embedding + mask） ====== # visual_embed 会把图像切成 patch，映射到 embedding 空间，并返回对应的 mask image_embeds, image_masks = self.transformer.visual_embed(img) # ====== Step 3: mask 处理 ====== # 将 mask 转为 long 类型，并放到图像所在的设备上 image_masks = image_masks.long().to(device=img.get_device()) # ====== Step 4: 加上 token type embedding ====== # 给图像 token embedding 加上类型 embedding（值固定为 image_token_type_idx=1） image_embeds = image_embeds + self.token_type_embeddings( torch.full_like(image_masks, image_token_type_idx) ) # ====== Step 5: 初始化 transformer 输入 ====== co_embeds = image_embeds # 融合输入 = 图像 embedding co_masks = image_masks # 融合 mask = 图像 mask x = co_embeds all_hidden_states = [] # 存储每层 hidden states，供后续 VL block 使用 # ====== Step 6: 计算相对位置偏置 ====== relative_position_bias_list = self.get_rel_pos_bias(self.relative_position_index) # ====== Step 7: 单模态图像编码（Image-only Blocks） ====== for i, blk in enumerate(self.transformer.blocks): x = blk( x, mask=co_masks, modality_type=\\\"image\\\", # 单模态模式 = 图像 relative_position_bias=relative_position_bias_list[i] ) all_hidden_states.append(x) # 保存该层输出 # ====== Step 8: 多模态编码（VL-Blocks） ====== # 从 vlffn_start_layer_index-1 层的输出作为起点 vlffn_hiddens = all_hidden_states[self.vlffn_start_layer_index - 1] # 从指定层开始，走 VL 模式（Vision-Language 融合） for vlffn_index in range(self.vlffn_start_layer_index, self.num_layers): vlffn_hiddens = self.transformer.blocks[vlffn_index]( vlffn_hiddens, mask=co_masks, modality_type=\\\"vl\\\", # 融合模式 relative_position_bias=relative_position_bias_list[vlffn_index] ) # ====== Step 9: 单模态最终输出 ====== vffn_hiddens = all_hidden_states[-1] # 最后一层（图像模式）hidden states vffn_hiddens = self.transformer.norm(vffn_hiddens) # LayerNorm 归一化 text_feats, image_feats = ( None, # 文本特征为空 vffn_hiddens, # 图像特征序列 ) # ====== Step 10: ITC 用的图像 CLS 特征 ====== cls_feats = self.itc_image_proj(vffn_hiddens[:, 0]) # 取 [CLS] token cls_feats = cls_feats / cls_feats.norm(dim=-1, keepdim=True) # L2 归一化 # ====== Step 11: VL 融合后的 CLS 特征 ====== vlffn_hiddens = self.transformer.norm(vlffn_hiddens) # 归一化 cls_vlffn_feats = self.itc_vl_image_proj(vlffn_hiddens[:, 0]) # 投影到 ITC 空间 cls_vlffn_feats = cls_vlffn_feats / cls_vlffn_feats.norm(dim=-1, keepdim=True) # ====== Step 12: 打包返回结果 ====== ret = { \\\"text_feats\\\": text_feats, # 文本特征（None） \\\"image_feats\\\": image_feats, # 图像特征（序列输出） \\\"cls_feats\\\": cls_feats, # 单模态 ITC CLS 特征 \\\"cls_vlffn_feats\\\": cls_vlffn_feats, # 跨模态 ITC CLS 特征 \\\"raw_cls_feats\\\": x[:, 0], # 原始 CLS token（最后一次 forward 的） \\\"image_masks\\\": image_masks, # 图像 mask \\\"text_labels\\\": None, # 文本标签（空） \\\"text_ids\\\": None, # 文本 ID（空） \\\"text_masks\\\": None, # 文本 mask（空） } return ret\",\"def infer_text( self, batch, mask_text=False, ): # 如果开启了 Masked Language Modeling（MLM），就从 batch 里取对应的 \\\"_mlm\\\" 字段 do_mlm = \\\"_mlm\\\" if mask_text else \\\"\\\" text_ids = batch[f\\\"text_ids{do_mlm}\\\"] # 输入 token id 序列 text_labels = batch[f\\\"text_labels{do_mlm}\\\"] # MLM 的标签（预测目标），正常推理时为 -100 text_masks = batch[f\\\"text_masks\\\"] # attention mask（哪些位置有效） # 将输入 token id 转换为 embedding 向量 text_embeds = self.text_embeddings(text_ids) # 加上 token_type_embeddings（区分模态，这里 text 全是 0） text_embeds = text_embeds + self.token_type_embeddings(torch.zeros_like(text_masks)) # co_* 表示“当前模态（text）的输入” co_embeds = text_embeds co_masks = text_masks # 初始化 transformer 输入 x = co_embeds all_hidden_states = [] # 获取相对位置偏置（transformer attention 中的 bias） relative_position_bias_list = self.get_rel_pos_bias(self.text_relative_position_index) # ====== 第一阶段：单模态 Transformer 编码 ====== # 遍历 transformer 的所有 Block，每个 block 按 \\\"text\\\" 模式运行 for i, blk in enumerate(self.transformer.blocks): x = blk( x, mask=co_masks, modality_type=\\\"text\\\", # 单模态模式（仅文本） relative_position_bias=relative_position_bias_list[i] ) all_hidden_states.append(x) # 记录每层输出，供后续 VL block 使用 # ====== 第二阶段：跨模态 Transformer 编码 ====== # 从 vlffn_start_layer_index-1 层的 hidden states 作为输入 vlffn_hiddens = all_hidden_states[self.vlffn_start_layer_index - 1] # 再次遍历后半部分 block，但这次切换成 \\\"vl\\\" 模式（允许跨模态交互） for vlffn_index in range(self.vlffn_start_layer_index, self.num_layers): vlffn_hiddens = self.transformer.blocks[vlffn_index]( vlffn_hiddens, mask=co_masks, modality_type=\\\"vl\\\", # 融合模式（Vision-Language） relative_position_bias=relative_position_bias_list[vlffn_index] ) # ====== 单模态输出 ====== lffn_hiddens = all_hidden_states[-1] # 最后一层（text 模式）的输出 lffn_hiddens = self.transformer.norm(lffn_hiddens) # 层归一化 text_feats, image_feats = ( lffn_hiddens, # 单模态文本特征 None, # 图像为空 ) # 提取 [CLS] token 的 embedding，并投影到对比学习空间（ITC） cls_feats = self.itc_text_proj(lffn_hiddens[:, 0]) cls_feats = cls_feats / cls_feats.norm(dim=-1, keepdim=True) # L2 归一化 # ====== 跨模态输出 ====== vlffn_hiddens = self.transformer.norm(vlffn_hiddens) # 层归一化 # 提取 VL 融合后的 [CLS] embedding，用于 ITM/VQA 等任务 cls_vlffn_feats = self.itc_vl_text_proj(vlffn_hiddens[:, 0]) cls_vlffn_feats = cls_vlffn_feats / cls_vlffn_feats.norm(dim=-1, keepdim=True) # ====== 打包返回结果 ====== ret = { \\\"text_feats\\\": text_feats, # 单模态文本特征序列 \\\"image_feats\\\": image_feats, # 图像特征（None） \\\"cls_feats\\\": cls_feats, # 单模态 [CLS] 特征（ITC 用） \\\"cls_vlffn_feats\\\": cls_vlffn_feats, # 融合 [CLS] 特征（ITM/VQA 用） \\\"raw_cls_feats\\\": x[:, 0], # 原始 [CLS] 输出（未投影） \\\"image_masks\\\": None, # 图像 mask（None） \\\"text_labels\\\": text_labels, # 文本标签（MLM 或 -100） \\\"text_ids\\\": text_ids, # 文本输入 ID \\\"text_masks\\\": text_masks, # 文本 mask } return ret\",\"# The implementation of image-text contrastive refers to open_clip (https://github.com/mlfoundations/open_clip) def compute_itc(pl_module, batch, aggregate=True): # 1. 分别对图像和文本做前向推理，提取 ITC 所需特征 infer_imag = pl_module.infer_image(batch, mask_image=False) # 图像推理 infer_text = pl_module.infer_text(batch, mask_text=False) # 文本推理 # 2. 取出图像和文本的 CLS 特征（单模态 ITC 特征） image_features = infer_imag[\\\"cls_feats\\\"] text_features = infer_text[\\\"cls_feats\\\"] # 3. 取出 ITC 训练时的对比缩放因子（logit_scale），并取指数保证其 > 0 logit_scale = pl_module.logit_scale.exp().mean() # 4. 取出经过 VL-FFN（跨模态融合层）的 CLS 特征（跨模态 ITC 特征） image_vlffn_features = infer_imag[\\\"cls_vlffn_feats\\\"] text_vlffn_features = infer_text[\\\"cls_vlffn_feats\\\"] # 5. 跨模态 ITC 的缩放因子 logit_vl_scale = pl_module.logit_vl_scale.exp().mean() # ========== 处理分布式训练下的负样本扩展 ========== if aggregate: ... else: # 7. 单机训练时，直接计算相似度 logits_per_image = logit_scale * image_features @ text_features.t() logits_per_text = logit_scale * text_features @ image_features.t() # 8. 构造 ground truth 标签：第 i 个样本对应第 i 个正样本 ground_truth = torch.arange(len(logits_per_image)).long().to(device=logits_per_image.get_device()) # 9. 计算单模态 ITC loss（对称 CE，image→text + text→image） itc_loss = ( F.cross_entropy(logits_per_image.float(), ground_truth) + F.cross_entropy(logits_per_text.float(), ground_truth) ) / 2 # 10. 计算跨模态 VL-FFN ITC loss (仅在分布式环境下启用) itc_vlffn_loss = ( F.cross_entropy(logits_per_vlffn_image.float(), ground_truth) + F.cross_entropy(logits_per_vlffn_text.float(), ground_truth) ) / 2 # 11. 总 loss：两者平均再乘权重 itc_total_loss = (itc_loss + itc_vlffn_loss) * 0.5 # 12. 返回结果字典 ret = { \\\"itc_loss\\\": itc_total_loss, # 总 ITC 损失 \\\"itc_i2t_logits\\\": logits_per_image, # image→text logits \\\"itc_t2i_logits\\\": logits_per_text, # text→image logits \\\"itc_labels\\\": ground_truth, # 标签 \\\"itc_logit_scale\\\": logit_scale, # 单模态 logit 缩放因子 \\\"itc_logit_vl_scale\\\": logit_vl_scale, # 跨模态 logit 缩放因子 } # ========== 训练/验证过程中的日志记录 ========== phase = \\\"train\\\" if pl_module.training else \\\"val\\\" # 13. 记录 loss 和缩放因子 loss = getattr(pl_module, f\\\"{phase}_itc_loss\\\")(ret[\\\"itc_loss\\\"]) scale = getattr(pl_module, f\\\"{phase}_itc_logit_scale\\\")(ret[\\\"itc_logit_scale\\\"]) # 14. 单模态 ITC 准确率 i2t_acc = getattr(pl_module, f\\\"{phase}_itc_i2t_accuracy\\\")(ret[\\\"itc_i2t_logits\\\"], ret[\\\"itc_labels\\\"]) t2i_acc = getattr(pl_module, f\\\"{phase}_itc_t2i_accuracy\\\")(ret[\\\"itc_t2i_logits\\\"], ret[\\\"itc_labels\\\"]) pl_module.log(f\\\"itc/{phase}/loss\\\", loss) pl_module.log(f\\\"itc/{phase}/logit_scale\\\", scale) pl_module.log(f\\\"itc/{phase}/i2t_accuracy\\\", i2t_acc) pl_module.log(f\\\"itc/{phase}/t2i_accuracy\\\", t2i_acc) # 15. 跨模态 VL-FFN ITC 的日志记录 vl_scale = getattr(pl_module, f\\\"{phase}_itc_vl_logit_scale\\\")(ret[\\\"itc_logit_vl_scale\\\"]) vl_i2t_acc = getattr(pl_module, f\\\"{phase}_itc_vl_i2t_accuracy\\\")(logits_per_vlffn_image, ret[\\\"itc_labels\\\"]) vl_t2i_acc = getattr(pl_module, f\\\"{phase}_itc_vl_t2i_accuracy\\\")(logits_per_vlffn_text, ret[\\\"itc_labels\\\"]) pl_module.log(f\\\"itc/{phase}/vl_logit_scale\\\", vl_scale) pl_module.log(f\\\"itc/{phase}/vl_i2t_accuracy\\\", vl_i2t_acc) pl_module.log(f\\\"itc/{phase}/vl_t2i_accuracy\\\", vl_t2i_acc) return ret\",\"跨模态 VL-FFN ITC Loss\",\"1. 为什么只在分布式环境下启用？\",\"代码实现逻辑：在 compute_itc 中，VL-FFN ITC loss 只在 aggregate=True 分支下计算，而 aggregate=True 对应分布式环境；单机模式（aggregate=False）默认不计算 VL-FFN ITC。\",\"主要动机：\",\"负样本数量：ITC loss 对负样本依赖大，VL-FFN ITC 特征较特殊，单机 batch 内负样本有限，训练不稳定；分布式环境通过 all_gather 扩展了负样本数量。\",\"资源开销：VL-FFN ITC 需要额外存储和计算 VL-FFN 特征，单机环境下显存/算力消耗较大；分布式环境充分利用多卡资源。\",\"理论上可在单机计算：禁用只是实现选择，可根据需要在单机环境加入 VL-FFN ITC 计算，但可能效果受限。\",\"2. 跨模态 VL-FFN ITC Loss 的作用\",\"单模态对齐：像 CLIP 那样，保证 encoder 自身就能学到基本的跨模态检索能力。\",\"跨模态对齐：在融合层之后，进一步对齐“混合表征”，使得 VL Blocks 也被直接监督，而不是只靠 ITM/MLM 任务间接学习。\"]},\"278\":{\"h\":\"Image-Text Matching\",\"t\":[\"第三个学习目标是 ITM 任务，该任务的学习目标是通过硬负样本策略，将正匹配的图文对与相似但不匹配的负样本区分开来，从而训练模型学会细粒度跨模态对齐。\",\" # Image Text Matching with global hard negative, must use with itc if \\\"itm\\\" in self.current_tasks: ret.update(objectives.compute_itm_hardneg(self, batch, ret[\\\"itc_i2t_logits\\\"], ret[\\\"itc_t2i_logits\\\"]))\",\"回顾 VLMo 模型的 forward 方法可知，再计算 ITM 学习目标之前，需要先完成 ITC 学习目标的计算，利用 ITC 提供的相似度矩阵完成 hard negative examples 的挖掘。\",\"def compute_itm_hardneg(pl_module, batch, sim_i2t, sim_t2i): # 获取正负样本数量及 batch size pos_len = batch[\\\"text_ids\\\"].size(0) neg_len = batch[\\\"text_ids\\\"].size(0) bsz = batch[\\\"text_ids\\\"].size(0) # 构建 ITM 标签：正样本为 1，负样本为 0 itm_labels = torch.cat([torch.ones(pos_len), torch.zeros(neg_len), torch.zeros(neg_len)]).to( pl_module.device ) # 拷贝 batch，防止原 batch 被修改 batch = {k: v for k, v in batch.items()} # 正样本推理 infer_pos = pl_module.infer(batch, mask_text=False, mask_image=False) batch_text_ids = infer_pos[\\\"text_ids\\\"] batch_text_masks = infer_pos[\\\"text_masks\\\"] batch_image = infer_pos[\\\"image\\\"] with torch.no_grad(): world_size = dist.get_world_size() rank = dist.get_rank() # 初始化各 GPU 上的 tensor，用于收集所有 GPU 的 batch 数据 gathered_text_ids = [ torch.zeros_like(batch_text_ids) for _ in range(world_size) ] gathered_text_masks = [ torch.zeros_like(batch_text_masks) for _ in range(world_size) ] gathered_image = [ torch.zeros_like(batch_image) for _ in range(world_size) ] # 分布式收集所有 GPU 的 tensor（多 GPU 环境） dist.all_gather(gathered_text_ids, batch_text_ids) dist.all_gather(gathered_text_masks, batch_text_masks) dist.all_gather(gathered_image, batch_image) # 合并收集的 tensor，排除当前 GPU 自己的部分 all_text_ids = torch.cat( [batch_text_ids] + gathered_text_ids[:rank] + gathered_text_ids[rank + 1 :] ) all_text_masks = torch.cat( [batch_text_masks] + gathered_text_masks[:rank] + gathered_text_masks[rank + 1 :] ) all_image = torch.cat( [batch_image] + gathered_image[:rank] + gathered_image[rank + 1 :] ) with torch.no_grad(): # 计算图像到文本、文本到图像的相似度权重 weights_i2t = F.softmax(sim_i2t[:bsz, :].float(), dim=1) weights_t2i = F.softmax(sim_t2i[:bsz, :].float(), dim=1) # 将对角线置零，避免选中正样本作为负样本 weights_i2t.fill_diagonal_(0) weights_t2i.fill_diagonal_(0) # 为每个图像选择一个负文本 images_neg = [] for b in range(bsz): neg_idx = torch.multinomial(weights_t2i[b], 1).item() images_neg.append(all_image[neg_idx]) images_neg = torch.stack(images_neg, dim=0) # 为每个文本选择一个负图像 text_ids_neg = [] text_masks_neg = [] for b in range(bsz): neg_idx = torch.multinomial(weights_i2t[b], 1).item() text_ids_neg.append(all_text_ids[neg_idx]) text_masks_neg.append(all_text_masks[neg_idx]) text_ids_neg = torch.stack(text_ids_neg, dim=0) text_masks_neg = torch.stack(text_masks_neg, dim=0) # 构建负样本 batch 并进行推理 batch_imgs_neg = {\\\"image\\\":[images_neg], \\\"text_ids\\\":batch[\\\"text_ids\\\"], \\\"text_labels\\\":batch[\\\"text_labels\\\"], \\\"text_masks\\\":batch[\\\"text_masks\\\"]} infer_imags_neg = pl_module.infer(batch_imgs_neg, mask_text=False, mask_image=False) batch_text_neg = {\\\"image\\\":batch[\\\"image\\\"], \\\"text_ids\\\":text_ids_neg, \\\"text_labels\\\":batch[\\\"text_labels\\\"], \\\"text_masks\\\":text_masks_neg} infer_text_neg = pl_module.infer(batch_text_neg, mask_text=False, mask_image=False) # 合并正负样本特征 all_cls_feats = torch.cat([infer_pos[\\\"cls_feats\\\"], infer_imags_neg[\\\"cls_feats\\\"], infer_text_neg[\\\"cls_feats\\\"]], dim=0) # 计算 ITM logits 和 loss itm_logits = pl_module.itm_score(all_cls_feats) itm_loss = F.cross_entropy(itm_logits, itm_labels.long()) # 构建返回字典 ret = { \\\"itm_loss\\\": itm_loss, \\\"itm_logits\\\": itm_logits, \\\"itm_labels\\\": itm_labels, } # 根据训练/验证阶段计算并记录 loss 与 accuracy phase = \\\"train\\\" if pl_module.training else \\\"val\\\" loss = getattr(pl_module, f\\\"{phase}_itm_loss\\\")(ret[\\\"itm_loss\\\"]) acc = getattr(pl_module, f\\\"{phase}_itm_accuracy\\\")( ret[\\\"itm_logits\\\"], ret[\\\"itm_labels\\\"] ) pl_module.log(f\\\"itm/{phase}/loss\\\", loss) pl_module.log(f\\\"itm/{phase}/accuracy\\\", acc) return ret\"]},\"279\":{\"h\":\"ViLT 论文\",\"t\":[\"ViLT: Vision-and-Language Transformer Without Convolution or Region Supervision 论文简析\",\"论文链接: ViLT: Vision-and-Language Transformer Without Convolution or Region Supervision 代码链接: https://github.com/dandelin/vilt\"]},\"280\":{\"h\":\"Introduction\",\"t\":[\"视觉-语言预训练（VLP）领域中，传统的视觉特征提取主要有两种典型实现方案：\",\"Region Feature（区域特征）：通常使用预训练的目标检测器（如基于 Visual Genome 数据集训练的检测模型）来定位图像中的物体区域，并提取每个区域的特征。这种方法能够捕获较为精细的对象信息，是许多早期VLP模型的标准做法，但计算复杂且处理速度较慢。\",\"Grid Feature（网格特征）：用卷积神经网络（如 ResNet）对整张图像进行处理，将图像划分为固定大小的网格，通过卷积提取每个网格的视觉特征。这种方式避免了目标检测的步骤，提取速度相对更快，但仍依赖卷积架构，计算资源消耗仍然较大。\",\"ViLT模型提出了一种极简化的视觉嵌入方案，摒弃了传统的目标检测和卷积视觉嵌入器，采用无卷积的浅层线性投影直接将图像块（patch）嵌入，并与文本token一同输入transformer处理。这样，ViLT不仅极大降低了模型参数和计算负担，实现了比基于区域特征的模型快数十倍、比基于网格特征的模型快至少四倍的推理速度，还在多项视觉-语言任务中取得了竞争力甚至更优的性能。\",\"此外，ViLT首次引入了全词掩码和图像增强技术于视觉-语言预训练，进一步推动了模型的下游表现，展示了其轻量化设计在效率与性能上的优势。\",\"Contribution:\",\"第一个基于patch projection的多模态预训练模型，其是首个使用patch projection来做visual embedding的方法。\",\"证明了可以将BERT的方法和Vison Transformer结合起来用于多模态transformer。\",\"体现了全词掩码在预训练时以及图像增强在微调时的重要性。\"]},\"281\":{\"h\":\"Motivation\",\"t\":[\"目前参数量最小的多模态Transformer方法。ViLT使用预训练的ViT来初始化交互的transformer，这样就可以直接利用交互层来处理视觉特征，不需要额外增加一个视觉encoder（如Faster-RCNN）。\"]},\"282\":{\"h\":\"Method\",\"t\":[\"现有的视觉语言模型的三种结构类别：\",\"VE = Vision Embedding\",\"TE = Text Embedding\",\"MI = Modality Interaction\",\"上图是4种不同类型的VLP模型示意图。其中每个矩形的高表示相对计算量大小，VE、TE和MI分别是visual embedding、text embedding和modality interaction的简写。\",\"作者提出这4种类型的主要依据有两点：\",\"在参数或者计算上，两种模态是否保持平衡。\",\"在网络深层中，两种模态是否相互作用。\",\"VSE、VSE++和SCAN属于(a)类型。对图像和文本独立使用encoder，图像的更重，文本的更轻，使用简单的点积或者浅层attention层来表示两种模态特征的相似性。\",\"CLIP属于(b)类型。每个模态单独使用重的transformer encoder，使用池化后的图像特征点积计算特征相似性。\",\"ViLBERT、UNTER和Pixel-BERT属于(c)类型。这些方法使用深层transformer进行交互作用，但是由于VE仍然使用重的卷积网络进行特征抽取，导致计算量依然很大。\",\"作者提出的ViLT属于(d)类型。ViLT是首个将VE设计的如TE一样轻量的方法，该方法的主要计算量都集中在模态交互上。\"]},\"283\":{\"h\":\"Modality Interaction Schema\",\"t\":[\"模态交互部分可以分成两种方式：一种是single-stream(如BERT和UNITER)，另一种是dual-stream(如ViLBERT和LXMERT)。其中single-stream是对图像和文本concate然后进行交互操作，而dual-stream是不对图像和文本concate然后进行交互操作。ViLT延用single-stream的交互方式，因为dual-stream会引入额外的计算量。\",\"现有的VLP模型的text embedding基本上都使用类BERT结构(图1)，但是visual embedding存在着差异。在大多数情况下，visual embedding是现有VLP模型的瓶颈。visual embedding的方法总共有三大类，其中region feature方法通常采用Faster R-CNN二阶段检测器提取region的特征，grid feature方法直接使用CNN提取grid的特征，patch projection方法将输入图片切片投影提取特征。ViLT是首个使用patch projection来做visual embedding的方法。\"]},\"284\":{\"h\":\"Model Structure\",\"t\":[\"作者提出的ViLT可以认为是目前最简单的多模态Transformer方法。ViLT使用预训练的ViT来初始化交互的transformer，这样就可以直接利用交互层来处理视觉特征，不需要额外增加一个视觉encoder。\",\"文本特征输入部分，将文本看成一个词序列，通过word embedding matrix转化成word embedding，然后和position embedding进行相加，最后和modal-type embedding进行concate。\",\"图像特征输入部分，将图像切块看成一个图像块序列，通过linear projection转化成visual embedding，然后和postion embedding进行相加，最后和modal-type embedding进行concate。\",\"其中word embedding和visual embedding通过可学习的modal-type embedding标志位来区分，其中0标志位表示word embedding部分，1标志位表示visual embedding部分。\",\"wrod embedding和visual embedding分别都嵌入了一个额外的可学习 [class] embedding，方便和下游任务对接。\"]},\"285\":{\"h\":\"Pretraining Objectives\",\"t\":[\"ViLT预训练的优化目标有两个：一个是image text matching(ITM)，另一个是masked language modeling(MLM)。\",\"ImageText Matching：随机以0.5的概率将文本对应的图片替换成不同的图片，然后对文本标志位对应输出使用一个线性的ITM head将输出feature映射成一个二值logits，用来判断图像文本是否匹配。另外ViLT还设计了一个word patch alignment (WPA)来计算textual subset和visual subset的对齐分数。\",\"Masked Language Modeling：MLM的目标是通过文本的上下文信息去预测masked的文本tokens。随机以0.15的概率mask掉tokens，然后文本输出接两层MLP预测mask掉的tokens。\",\"Whole Word Masking：另外ViLT还使用了whole word masking技巧。whole word masking是将连续的子词tokens进行mask的技巧，避免了只通过单词上下文进行预测。比如将“giraffe”词tokenized成3个部分[“gi”, “##raf”, “##fe”]，可以mask成[“gi”, “[MASK]”, “##fe”]，模型会通过mask的上下文信息[“gi”，“##fe”]来预测mask的“##raf”，就会导致不利用图像信息。\"]},\"286\":{\"h\":\"Conclusion\",\"t\":[\"本文提出的方法在效率上大大提升且表现出相似的性能，相比于region feature的方法速度快了60倍，相比于grid feature的方法快了4倍，而且下游任务表现出相似甚至更好的性能。\",\"缺点：\",\"1、性能不够高，在一些数据集上的表现比不过C类方法，有可能因为对于现有的任务来说，因为数据集的bias，或者这个任务需要更多的视觉信息，因此需要更多得视觉部分，最后的效果才能好。\",\"2、虽然推理时间快，但是训练速度很慢。只是结构上简化了多模态学习，但一般人还是玩不起。\"]},\"287\":{\"h\":\"多模态常用改编Bert代码实现\",\"t\":[\"多模态论文中常用的改编版本的Bert代码实现记录\",\"本文改编Bert代码讲解基于BLIP项目展开，代码链接: BLIP/models/med.py\"]},\"288\":{\"h\":\"多模态 Bert 前向传播流程\",\"t\":[\"本节我们将对多模态Bert的前向传播基本流程进行讲解，所给代码删除了大量非核心逻辑，如需了解各类优化手段，请阅读源码进行学习。\"]},\"289\":{\"h\":\"1. 整体流程总览（BertModel）\",\"t\":[\"class BertModel(BertPreTrainedModel): def forward( self, input_ids=None, attention_mask=None, position_ids=None, encoder_hidden_states=None, # 图像模态特征 encoder_attention_mask=None, # 图像掩码 is_decoder=False, mode='multimodal', # 控制是否启用 cross-attention ): # 1. 词嵌入 + 位置编码 embedding_output = self.embeddings(input_ids=input_ids, position_ids=position_ids) # 2. 编码阶段（Text-only 或 Cross-modal） sequence_output = self.encoder( embedding_output, attention_mask=extended_attention_mask, # 可用于多头自注意力的文本 padding mask encoder_hidden_states=encoder_hidden_states, encoder_attention_mask=encoder_extended_attention_mask, # 可用于多头自注意力的图像 padding mask mode=mode, ) # 3. 池化输出（用于分类任务） pooled_output = self.pooler(sequence_output) if self.pooler is not None else None return BaseModelOutputWithPoolingAndCrossAttentions( last_hidden_state=sequence_output, pooler_output=pooled_output, )\",\"池化输出实现:\",\"class BertPooler(nn.Module): def __init__(self, config): super().__init__() self.dense = nn.Linear(config.hidden_size, config.hidden_size) self.activation = nn.Tanh() def forward(self, hidden_states): # 1. 拿到能够代表整段文本或者整个多模态表示的 CLS Token first_token_tensor = hidden_states[:, 0] # 2. 非线性变换 pooled_output = self.dense(first_token_tensor) pooled_output = self.activation(pooled_output) return pooled_output\"]},\"290\":{\"h\":\"2. 编码器：BertEncoder\",\"t\":[\"class BertEncoder(nn.Module): def __init__(self, config): self.layer = nn.ModuleList([BertLayer(config, i) for i in range(config.num_hidden_layers)]) def forward( self, hidden_states, attention_mask=None, encoder_hidden_states=None, encoder_attention_mask=None, mode='multimodal', ): for i in range(self.config.num_hidden_layers): layer_module = self.layer[i] hidden_states = layer_module( hidden_states, attention_mask, encoder_hidden_states, encoder_attention_mask, mode=mode, ) return hidden_states\",\"多模态关键点：\",\"多模态时，每个 Layer 都有机会执行 cross-attention。\",\"encoder_hidden_states 来自视觉模型（如 ViT 的输出），将图像特征注入到文本流中。\"]},\"291\":{\"h\":\"3. Transformer 层：BertLayer\",\"t\":[\"class BertLayer(nn.Module): def forward( self, hidden_states, attention_mask=None, encoder_hidden_states=None, encoder_attention_mask=None, mode=None, ): # 1. 自注意力（Self-Attention） attention_output = self.attention(hidden_states, attention_mask) # 2. 多模态交叉注意力（Cross-Attention） if mode == 'multimodal': attention_output = self.crossattention( attention_output, attention_mask, encoder_hidden_states, encoder_attention_mask, ) return attention_output\",\"多模态关键点：\",\"自注意力捕捉文本内部的依赖；\",\"跨模态注意力（CrossAttention）让文本 Query 关注图像 Key 和 Value，实现信息融合。\"]},\"292\":{\"h\":\"4. Attention 模块：BertAttention\",\"t\":[\"class BertAttention(nn.Module): def forward( self, hidden_states, attention_mask=None, encoder_hidden_states=None, encoder_attention_mask=None, ): self_outputs = self.self( hidden_states, attention_mask, encoder_hidden_states, encoder_attention_mask, ) # attention 后应用一个 MLP return self.output(self_outputs, hidden_states)\",\"MLP 实现:\",\"class BertSelfOutput(nn.Module): def __init__(self, config): super().__init__() self.dense = nn.Linear(config.hidden_size, config.hidden_size) self.LayerNorm = nn.LayerNorm(config.hidden_size, eps=config.layer_norm_eps) self.dropout = nn.Dropout(config.hidden_dropout_prob) def forward(self, hidden_states, input_tensor): hidden_states = self.dense(hidden_states) hidden_states = self.dropout(hidden_states) hidden_states = self.LayerNorm(hidden_states + input_tensor) return hidden_states\"]},\"293\":{\"h\":\"5. 核心计算：BertSelfAttention\",\"t\":[\"class BertSelfAttention(nn.Module): def forward( self, hidden_states, attention_mask=None, encoder_hidden_states=None, encoder_attention_mask=None, ): # 获取 Query mixed_query_layer = self.query(hidden_states) # 判断是否为 Cross Attention is_cross_attention = encoder_hidden_states is not None if is_cross_attention: key_layer = self.transpose_for_scores(self.key(encoder_hidden_states)) value_layer = self.transpose_for_scores(self.value(encoder_hidden_states)) attention_mask = encoder_attention_mask else: key_layer = self.transpose_for_scores(self.key(hidden_states)) value_layer = self.transpose_for_scores(self.value(hidden_states)) query_layer = self.transpose_for_scores(mixed_query_layer) # 计算 Attention 分数（缩放点积注意力） attention_scores = torch.matmul(query_layer, key_layer.transpose(-1, -2)) attention_scores = attention_scores / math.sqrt(self.attention_head_size) # 加 Mask if attention_mask is not None: attention_scores = attention_scores + attention_mask # Softmax 归一化为权重 attention_probs = nn.Softmax(dim=-1)(attention_scores) # Dropout（来自 Transformer 原始实现） attention_probs_dropped = self.dropout(attention_probs) # 应用注意力权重 context_layer = torch.matmul(attention_probs_dropped, value_layer) # Reshape context_layer = context_layer.permute(0, 2, 1, 3).contiguous() new_context_layer_shape = context_layer.size()[:-2] + (self.all_head_size,) return context_layer.view(*new_context_layer_shape)\"]},\"294\":{\"h\":\"6. 小结\",\"t\":[\"多模态交互核心(Cross Attention):\",\"项目\",\"说明\",\"Query\",\"来自文本（attention_output）\",\"Key/Value\",\"来自图像（encoder_hidden_states）\",\"作用\",\"让文本动态关注图像区域，建立 Token 与视觉 Patch 的对齐\",\"应用\",\"文本问图（VQA）、图文检索、图文生成等多模态任务\",\"总结:\",\" +--------------------------+ | Text Embeddings | +-----------+--------------+ | [Transformer Encoder] | ┌────────┴───────────┐ │ Self-Attention │ │ (Text <-> Text) │ └────────┬───────────┘ │ ┌────────▼───────────┐ │ Cross-Attention │ <--- 图像特征作为 Key / Value │ (Text <-> Image) │ └────────┬───────────┘ │ FeedForward + LayerNorm + Residual\"]},\"295\":{\"h\":\"自回归语言建模\",\"t\":[\"BertLMHeadModel 是基于 BERT 构建的 语言建模头（Language Modeling Head）模型，其主要用于 自回归语言建模（Causal Language Modeling, CLM），尤其是在 多模态生成任务中充当解码器。它通常用于像 UNITER、VLBERT、MiniGPT-4、BLIP 等多模态架构中的文本生成部分。\",\"class BertLMHeadModel(BertPreTrainedModel): def __init__(self, config): self.bert = BertModel(config, add_pooling_layer=False) self.cls = BertLMPredictionHead(config) def forward( self, input_ids=None, attention_mask=None, position_ids=None, encoder_hidden_states=None, encoder_attention_mask=None, labels=None, is_decoder=True, reduction='mean', mode='multimodal', ): # 1. 调用BertModel outputs = self.bert( input_ids, attention_mask=attention_mask, position_ids=position_ids, encoder_hidden_states=encoder_hidden_states, encoder_attention_mask=encoder_attention_mask, is_decoder=is_decoder, mode=mode, ) # 2. 解码 sequence_output = outputs[0] prediction_scores = self.cls(sequence_output) # 3. 返回预测得分 if return_logits: return prediction_scores[:, :-1, :].contiguous() # 返回预测出来的: [x2,x3,...,xn] , 丢掉 X(n+1) # 4. 计算 next-token prediction 损失 lm_loss = None if labels is not None: # 4.1 模型预测出来的: [x2,x3,...,xn] , 丢掉 X(n+1) 和 标签: [x2,x3,...,xn] , 丢掉 X(1) shifted_prediction_scores = prediction_scores[:, :-1, :].contiguous() labels = labels[:, 1:].contiguous() # 4.2 计算交叉熵损失 loss_fct = CrossEntropyLoss(reduction=reduction, label_smoothing=0.1) lm_loss = loss_fct(shifted_prediction_scores.view(-1, self.config.vocab_size), labels.view(-1)) if reduction=='none': lm_loss = lm_loss.view(prediction_scores.size(0),-1).sum(1) return CausalLMOutputWithCrossAttentions( loss=lm_loss, logits=prediction_scores, )\",\"# 对输入进行非线性变换: 投影 + 激活 + 归一化 class BertPredictionHeadTransform(nn.Module): def __init__(self, config): super().__init__() self.dense = nn.Linear(config.hidden_size, config.hidden_size) # 默认采用GELU激活函数 if isinstance(config.hidden_act, str): self.transform_act_fn = ACT2FN[config.hidden_act] else: self.transform_act_fn = config.hidden_act self.LayerNorm = nn.LayerNorm(config.hidden_size, eps=config.layer_norm_eps) def forward(self, hidden_states): hidden_states = self.dense(hidden_states) hidden_states = self.transform_act_fn(hidden_states) hidden_states = self.LayerNorm(hidden_states) return hidden_states class BertLMPredictionHead(nn.Module): def __init__(self, config): self.transform = BertPredictionHeadTransform(config) self.decoder = nn.Linear(config.hidden_size, config.vocab_size, bias=False) def forward(self, hidden_states): # 1. 非线性变换 hidden_states = self.transform(hidden_states) # 2. 解码: 将(seq_len,hidden_size)中每个word映射到词空间 hidden_states = self.decoder(hidden_states) return hidden_states\"]},\"296\":{\"h\":\"庖丁解牛CLIP\",\"t\":[\"多模态模型CLIP原理与图片分类，文字搜索图像实战演练\",\"CLIP原始论文链接\"]},\"297\":{\"h\":\"引言\",\"t\":[\"2021 年可谓是视觉 Transformer（Vision Transformer）大放异彩的一年。自谷歌提出 ViT 之后，众多基于视觉 Transformer 的研究如潮水般涌来，广泛应用于各类计算机视觉任务。与此同时，OpenAI 在 2021 年 1 月发布的 DALL-E 和 CLIP，同样给计算机视觉领域带来了巨大影响。这两个模型都属于融合图像与文本的多模态模型，其中 DALL-E 是基于文本输入来生成图像的模型，而 CLIP 则是以文本作为监督信号，训练出具有可迁移能力的视觉模型。和 ViT 类似，DALL-E 和 CLIP 的出现也掀起了新一轮的研究热潮。\"]},\"298\":{\"h\":\"介绍\",\"t\":[\"CLIP的英文全称为Contrastive Language-Image Pre-training，它代表着一种基于对比文本-图像对的预训练方法，同时也指运用该方法构建的模型。CLIP属于基于对比学习的多模态模型。与计算机视觉（CV）领域中的一些对比学习方法，像MoCo和SimCLR有所不同，CLIP的训练数据采用的是文本-图像对，也就是一张图像搭配与之对应的文本描述。在训练过程中，借助对比学习机制，期望模型能够学习到文本和图像之间的匹配关系。\"]},\"299\":{\"h\":\"训练\",\"t\":[\"CLIP包含两个核心模型，分别是文本编码器（Text Encoder）和图像编码器（Image Encoder）。其中，文本编码器的作用是提取文本的特征，在实现时可采用自然语言处理（NLP）领域常用的文本Transformer模型；而图像编码器则用于提取图像的特征，在实际应用中可以选用常见的卷积神经网络（CNN）模型，也可以采用视觉Transformer模型。\",\"这里对提取的文本特征和图像特征进行对比学习。对于一个包含个文本-图像对的训练batch，将个文本特征和个图像特征两两组合，CLIP模型会预测出个可能的文本-图像对的相似度，这里的相似度直接计算文本特征和图像特征的余弦相似性（cosine similarity），即上图所示的矩阵。这里共有个正样本，即真正属于一对的文本和图像（矩阵中的对角线元素），而剩余的个文本-图像对为负样本，那么CLIP的训练目标就是最大个正样本的相似度，同时最小化个负样本的相似度，对应的伪代码实现如下所示：\",\"# image_encoder - ResNet or Vision Transformer # text_encoder - CBOW or Text Transformer # I[n, h, w, c] - minibatch of aligned images # T[n, l] - minibatch of aligned texts # W_i[d_i, d_e] - learned proj of image to embed # W_t[d_t, d_e] - learned proj of text to embed # t - learned temperature parameter # 分别提取图像特征和文本特征 I_f = image_encoder(I) #[n, d_i] T_f = text_encoder(T) #[n, d_t] # 对两个特征进行线性投射，得到相同维度的特征，并进行l2归一化 I_e = l2_normalize(np.dot(I_f, W_i), axis=1) T_e = l2_normalize(np.dot(T_f, W_t), axis=1) # 计算缩放的余弦相似度：[n, n] logits = np.dot(I_e, T_e.T) * np.exp(t) # 对称的对比学习损失：等价于N个类别的cross_entropy_loss labels = np.arange(n) # 对角线元素的labels loss_i = cross_entropy_loss(logits, labels, axis=0) loss_t = cross_entropy_loss(logits, labels, axis=1) loss = (loss_i + loss_t)/2\",\"为了训练CLIP模型，OpenAI从网络上收集了总计4亿对文本和图像，这些数据在论文中被称为WebImageText。若以文本单词数量来衡量，其规模与GPT-2训练时使用的WebText数据集相似。然而，从数据对的数量来看，它比谷歌的JFT-300M数据集还要多出1亿对，因此这是一个非常庞大的数据集。\",\"尽管CLIP是一个多模态模型，但其主要目的是训练可迁移的视觉模型。在论文中，文本编码器（Text Encoder）选择了一个包含6300万参数的Transformer模型，而图像编码器（Image Encoder）则采用了两种不同的架构：\",\"一种是常用的CNN架构ResNet。\",\"另一种是基于 Transformer 的ViT。\",\"ResNet包含五种不同尺寸的模型：ResNet50、ResNet101、RN50x4、RN50x16和RNx64（后三种模型是按照EfficientNet的缩放规则对ResNet分别放大4倍、16倍和64倍得到的），而ViT则选择了三种不同尺寸的模型：ViT-B/32、ViT-B/16和ViT-L/14。\",\"所有模型均训练了32个周期，使用AdamW优化器，并且在训练过程中采用了一个相对较大的批次大小：32768。由于数据量巨大，最大的ResNet模型RN50x64需要在592个V100 GPU上训练18天，而最大的ViT模型ViT-L/14则需要在256个V100 GPU上训练12天，这表明训练CLIP模型需要消耗大量的资源。对于ViT-L/14模型，还在336的分辨率下额外进行了一个周期的微调（finetune）以增强性能，论文发现这个模型的效果最佳，并将其标记为ViT-L/14@336，论文中进行对比实验的CLIP模型也采用了这一配置。\"]},\"300\":{\"h\":\"推理\",\"t\":[\"我们已经探讨了CLIP模型的运作机制，它由两个部分组成：一个视觉模型和一个文本模型。那么，如何将这个预训练的视觉模型应用到新的任务中呢？CLIP模型的一个显著优势是它能够进行zero-shot图像分类，这意味着它能够在没有任何特定任务训练数据的情况下，直接对图像进行分类。这不仅展示了CLIP的强大功能，也是其一大亮点。实现zero-shot分类的过程相当直接，可以概括为以下两个主要步骤：\",\"构建描述文本并提取特征：首先，根据任务的分类需求，为每个类别创建一个描述性的文本，例如“A photo of {label}”。这些文本随后被输入到文本编码器（Text Encoder）中，以生成相应的文本特征。如果有个类别，那么就会得到个文本特征。\",\"图像特征提取与分类：接下来，将待分类的图像输入到图像编码器（Image Encoder）中，以获取图像特征。然后，这些图像特征会与之前得到的个文本特征进行余弦相似度计算（这一过程与训练时相同）。最终，选择与图像特征相似度最高的文本所对应的类别，作为图像的分类预测结果。此外，这些相似度值可以被视为logits，通过softmax函数转换后，可以得到每个类别的预测概率。\",\"通过这种方式，CLIP模型能够在没有特定任务训练数据的情况下，直接对图像进行分类，这展示了其在图像分类任务中的灵活性和强大能力。\",\" 显然，我们通过利用CLIP模型的多模态能力，为特定任务动态构建了一个分类器。在这个过程中，文本编码器（Text Encoder）生成的文本特征相当于分类器的权重，而图像编码器（Image Encoder）提取的图像特征则是分类器的输入数据。以下是一个官方给出的CLIP模型的示例 ，该示例中的任务涉及8个类别:\",\"我们首先创建了各类别的文本描述，然后提取了相应的文本特征；\",\"然后我们读取要预测的图像，输入Image Encoder提取图像特征，并计算与文本特征的余弦相似度。\",\"# 1. 提取文本特征 texts = [ \\\"a page of text about segmentation\\\", \\\"a facial photo of a tabby cat\\\", \\\"a portrait of an astronaut with the American flag\\\", \\\"a rocket standing on a launchpad\\\", \\\"a red motorcycle standing in a garage\\\", \\\"a person looking at a camera on a tripod\\\", \\\"a black-and-white silhouette of a horse\\\", \\\"a cup of coffee on a saucer\\\" ] text_tokens = clip.tokenize([\\\"This is \\\" + desc for desc in texts]).cuda() with torch.no_grad(): text_features = model.encode_text(text_tokens).float() # 2. 提取图像特征 image_input = torch.tensor(np.stack(images)).cuda() with torch.no_grad(): image_features = model.encode_image(image_input).float() # 3. 计算余弦相似度 image_features /= image_features.norm(dim=-1, keepdim=True) text_features /= text_features.norm(dim=-1, keepdim=True) similarity = text_features.cpu().numpy() @ image_features.cpu().numpy().T\",\"相似度如下所示，可以看到对于要预测的8个图像，按照最大相似度，其均能匹配到正确的文本标签：\",\"进一步地，我们也可以对得到的余弦相似度计算softmax，得到每个预测类别的概率值：\",\"text_probs = (100.0 * image_features @ text_features.T).softmax(dim=-1) top_probs, top_labels = text_probs.cpu().topk(5, dim=-1)\",\"得到的预测概率如下所示，可以看到8个图像，CLIP模型均能够以较高的置信度给出正确的分类结果：\"]},\"301\":{\"h\":\"文本描述生成\",\"t\":[\"在使用CLIP模型进行zero-shot分类时，除了模型本身的应用，文本描述的生成也是一个关键环节。在之前的例子中，我们使用了“A photo of {label}”这样的格式来生成文本描述，但实际上，我们还有其他的选择。例如，我们可以直接使用类别标签作为文本描述。这种方法实际上与NLP领域的一个研究方向——prompt learning或prompt engineering——紧密相关。关于这一领域的详细综述，可以参考论文《Pre-train, Prompt, and Predict: A Systematic Survey of Prompting Methods in Natural Language Processing》。\",\"简单来说，prompt learning的核心思想是通过设计合适的prompt（提示），使得预训练模型能够直接应用于下游任务。这与传统的预训练加微调的方法有所不同。论文指出，如果我们直接使用类别标签作为文本描述，由于这些文本往往只是一个单词，缺乏具体的上下文，并且与CLIP模型的训练数据不完全一致，因此在效果上可能不如使用“A photo of {label}”这种格式（在ImageNet数据集上可以提升1.3%的效果）。\",\"此外，论文还实验了使用80个不同的prompt进行集成，结果发现在ImageNet数据集上能够带来3.5%的性能提升。具体的实验结果可以参考CLIP公开的notebook。\"]},\"302\":{\"h\":\"花卉图片分类\",\"t\":[\"本节我们将基于CLIP预训练模型实现Zero-Shot推理，训练使用到的数据集和AlexNet保持一致，因此这里就不再给出数据集下载链接了。\",\"图片分类实战 – 分别基于LeNet，AlexNet，VGG进行实现\",\"# 预训练模型名称 model_name = \\\"openai/clip-vit-large-patch14\\\" # 定义当前目录 current_dir = os.getcwd() model_dir = os.path.join(current_dir, model_name.replace(\\\"/\\\", \\\"_\\\")) # 检查当前目录是否有预训练权重文件，如果没有则下载 def download_pretrained_weights_if_needed(model_name, save_dir): if not os.path.exists(save_dir): try: print(f\\\"Downloading {model_name} to {save_dir}...\\\") snapshot_download(repo_id=model_name, local_dir=save_dir, local_dir_use_symlinks=False) print(f\\\"{model_name} downloaded successfully.\\\") except Exception as e: print(f\\\"Error downloading {model_name}: {e}\\\") download_pretrained_weights_if_needed(model_name, model_dir) # 加载模型和处理器 model = CLIPModel.from_pretrained(model_dir) processor = CLIPProcessor.from_pretrained(model_dir) device = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\") model = model.to(device)\",\"在 openai/clip-vit-large-patch14 这个 CLIP 预训练模型中，图像编码器采用了 Vision Transformer（ViT）架构，具体使用的是 ViT-L/14 版本，文本编码器使用的是基于 Transformer 的架构。\",\"# 函数：生成文本嵌入 def text_embedding(texts): inputs = processor(text=texts, return_tensors=\\\"pt\\\", padding=True).to(device) with torch.no_grad(): embeddings = model.get_text_features(**inputs) return embeddings.cpu().numpy()\",\"这个函数的作用是将输入的文本转化为对应的嵌入表示（embedding）。它通过处理器对输入文本进行处理，使其符合模型的输入要求，然后利用模型获取文本特征，最后将结果转换为 numpy 数组格式返回，方便后续的计算和比较。\",\"def get_image_embeddings(image_paths): images = [] for image_path in image_paths: try: image = Image.open(image_path).convert(\\\"RGB\\\") images.append(image) except Exception as e: print(f\\\"Error loading image {e}\\\") if not images: return None inputs = processor(images=images, return_tensors=\\\"pt\\\").to(device) with torch.no_grad(): image_features = model.get_image_features(**inputs) return image_features.cpu().numpy()\",\"该函数作用是针对给定的图片路径，读取图片并将其转换为合适的格式后，通过模型获取图片的特征嵌入。如果在读取图片过程中出现错误，会进行相应的错误提示并返回 None。\",\"def cosine_similarity(vec1, vec2): vec1 = np.array(vec1) vec2 = np.array(vec2) return np.dot(vec1, vec2.T) / (np.linalg.norm(vec1, axis=1, keepdims=True) * np.linalg.norm(vec2, axis=1))\",\"在图文检索中，我们常常需要衡量文本嵌入和图片嵌入之间的相似度，这里采用了余弦相似度的计算方法。它将输入的向量转换为 numpy 数组后，按照余弦相似度的数学公式来计算两者的相似度数值。\",\"首先，我们需要根据上面给出的花卉数据集下载链接，将数据下载到当前项目目录下:\",\"其次，我们从flower_photos目录下读取出所有图片的路径:\",\"# 递归遍历目录获取所有图片路径 def get_all_image_paths(directory): image_paths = [] for root, _, files in os.walk(directory): for file in files: file_extension = os.path.splitext(file)[1].lower() if file_extension in ['.png', '.jpg', '.jpeg']: image_paths.append(os.path.join(root, file)) return image_paths image_paths = get_all_image_paths(\\\"./flower_photos\\\")\",\"同时将flower_photos下的子目录名作为我们的候选待匹配分类文本列表，并改造为a photo of 子目录名的格式，然后计算每个分类文本对应的文本嵌入向量:\",\"# 获取候选分类名列表 def get_candidates(directory): candidates = [] for sub_dir in os.listdir(directory): sub_dir_path = os.path.join(directory, sub_dir) if os.path.isdir(sub_dir_path): candidates.append(f\\\"a photo of {sub_dir}\\\") return candidates candidates = get_candidates(\\\"./flower_photos\\\") text_embeddings = text_embedding(candidates)\",\"最后:\",\"分批次从图像列表中取出一批图像，获取其对应的图像嵌入向量列表\",\"计算这批图像嵌入向量中每一个图像嵌入向量和我们所有分类文本嵌入向量的余弦相似度\",\"针对每个图像嵌入向量取出和其相似度最高的那个文本嵌入向量的索引\",\"判断预测是否正确，统计正确率\",\"# 测试图片分类正确率 def accuracy(image_paths, candidates, text_embeddings, batch_size=64): correct_count = 0 total_count = len(image_paths) num_batches = (total_count + batch_size - 1) // batch_size # 分批次预测 for i in range(num_batches): start_idx = i * batch_size end_idx = min(start_idx + batch_size, total_count) # 取出当前批次的图像列表，并获得该批次图像列表对应的图像嵌入向量列表 batch_image_paths = image_paths[start_idx:end_idx] image_embeddings = get_image_embeddings(batch_image_paths) if image_embeddings is not None: # 计算图像嵌入向量列表中每个图像对应的嵌入向量和传入的分类文本嵌入向量的余弦相似度 similarities = cosine_similarity(image_embeddings, text_embeddings) # 针对每个图像嵌入向量获取和其相似度最高的分类文本嵌入向量索引下标 predicted_indices = np.argmax(similarities, axis=1) for j, predicted_index in enumerate(predicted_indices): # 针对每张图像，根据上述计算得到的和其相似度最高的分类文本索引，从候选分类文本集合中取出其分类名词 predicted_category = candidates[predicted_index].split(\\\" \\\")[-1] # 用当前图片外层目录的名字作为其分类名词 actual_category = os.path.basename(os.path.dirname(batch_image_paths[j])) # 比较两个分类名词是否相等 if predicted_category == actual_category: correct_count += 1 accuracy = correct_count / total_count return accuracy # 图片分类 def flowerClassify(): image_paths = get_all_image_paths(\\\"./flower_photos\\\") candidates = get_candidates(\\\"./flower_photos\\\") text_embeddings = text_embedding(candidates) start_time = time.time() acc = accuracy(image_paths, candidates, text_embeddings, batch_size=64) end_time = time.time() print(f\\\"Time taken to test accuracy: {end_time - start_time:.2f} seconds\\\") print(f\\\"Accuracy: {acc * 100:.2f}%\\\")\",\"Time taken to test accuracy: 396.62 seconds Accuracy: 95.48%\"]},\"303\":{\"h\":\"文字搜索图像\",\"t\":[\"上面的花卉分类案例相当于使用图像去匹配最合适的文本描述，而这里我们将会反转这个逻辑，用文本描述去匹配最合适的图片内容。\",\"为了实现文字搜索图像的功能，我们只需要在计算出相似度得分矩阵后，以每个文本描述为一行，取出该行中得分最大的那一列，即为与当前文本描述相似度最高的那副图片，具体代码实现如下：\",\"# 找到与文本最匹配的图片 def find_most_matching_image(text, image_paths): text_emb = text_embedding([text]) image_embeddings = get_image_embeddings(image_paths) if image_embeddings is None: return None similarities = cosine_similarity(text_emb, image_embeddings) most_matching_index = np.argmax(similarities) return image_paths[most_matching_index]\",\"下面来实际展示一下效果，首先我们用data目录充当我们的图片库来源:\",\" 遍历data目录，拿到所有图片路径:\",\"# 遍历 data 目录获取所有图片路径 def get_images_from_data_dir(): data_dir = os.path.join(current_dir, 'data') if not os.path.exists(data_dir): print(f\\\"Data directory {data_dir} does not exist.\\\") return [] return get_all_image_paths(data_dir)\",\"这里以搜索向日葵花为例，我们首先获取图片库中所有图片，然后计算出和当前文本描述相似度最高的那副图片，并将图片展示出来:\",\"# 根据文字搜索图片 def searchPicByText(): image_paths = get_images_from_data_dir() query_text = \\\"a photo of a sunflowers\\\" most_matching_image = find_most_matching_image(query_text, image_paths) if most_matching_image: print(f\\\"The most matching image for '{query_text}' is: {most_matching_image}\\\") try: img = Image.open(most_matching_image) plt.imshow(img) plt.axis('off') plt.title(f\\\"Most matching image for '{query_text}'\\\") plt.show() except Exception as e: print(f\\\"Error opening image: {e}\\\") else: print(\\\"No matching image found.\\\")\",\"图片库中的图片： 运行上述代码，搜索出来的图片:\"]},\"304\":{\"h\":\"完整代码\",\"t\":[\"import time from matplotlib import pyplot as plt from transformers import CLIPProcessor, CLIPModel import torch from PIL import Image import numpy as np import warnings import os from huggingface_hub import snapshot_download warnings.filterwarnings(\\\"ignore\\\") # 模型名称 model_name = \\\"openai/clip-vit-large-patch14\\\" # 定义当前目录 current_dir = os.getcwd() model_dir = os.path.join(current_dir, model_name.replace(\\\"/\\\", \\\"_\\\")) # 检查当前目录是否有预训练权重文件，如果没有则下载 def download_pretrained_weights_if_needed(model_name, save_dir): if not os.path.exists(save_dir): try: print(f\\\"Downloading {model_name} to {save_dir}...\\\") snapshot_download(repo_id=model_name, local_dir=save_dir, local_dir_use_symlinks=False) print(f\\\"{model_name} downloaded successfully.\\\") except Exception as e: print(f\\\"Error downloading {model_name}: {e}\\\") download_pretrained_weights_if_needed(model_name, model_dir) # 加载模型和处理器 model = CLIPModel.from_pretrained(model_dir) processor = CLIPProcessor.from_pretrained(model_dir) device = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\") model = model.to(device) # 函数：生成文本嵌入 def text_embedding(texts): inputs = processor(text=texts, return_tensors=\\\"pt\\\", padding=True).to(device) with torch.no_grad(): embeddings = model.get_text_features(**inputs) return embeddings.cpu().numpy() def get_image_embeddings(image_paths): images = [] for image_path in image_paths: try: image = Image.open(image_path).convert(\\\"RGB\\\") images.append(image) except Exception as e: print(f\\\"Error loading image {e}\\\") if not images: return None inputs = processor(images=images, return_tensors=\\\"pt\\\").to(device) with torch.no_grad(): image_features = model.get_image_features(**inputs) return image_features.cpu().numpy() def cosine_similarity(vec1, vec2): vec1 = np.array(vec1) vec2 = np.array(vec2) return np.dot(vec1, vec2.T) / (np.linalg.norm(vec1, axis=1, keepdims=True) * np.linalg.norm(vec2, axis=1)) # 递归遍历目录获取所有图片路径 def get_all_image_paths(directory): image_paths = [] for root, _, files in os.walk(directory): for file in files: file_extension = os.path.splitext(file)[1].lower() if file_extension in ['.png', '.jpg', '.jpeg']: image_paths.append(os.path.join(root, file)) return image_paths # 获取候选分类名列表 def get_candidates(directory): candidates = [] for sub_dir in os.listdir(directory): sub_dir_path = os.path.join(directory, sub_dir) if os.path.isdir(sub_dir_path): candidates.append(f\\\"a photo of {sub_dir}\\\") return candidates # 测试图片分类正确率 def accuracy(image_paths, candidates, text_embeddings, batch_size=64): correct_count = 0 total_count = len(image_paths) num_batches = (total_count + batch_size - 1) // batch_size for i in range(num_batches): start_idx = i * batch_size end_idx = min(start_idx + batch_size, total_count) batch_image_paths = image_paths[start_idx:end_idx] image_embeddings = get_image_embeddings(batch_image_paths) if image_embeddings is not None: similarities = cosine_similarity(image_embeddings, text_embeddings) predicted_indices = np.argmax(similarities, axis=1) for j, predicted_index in enumerate(predicted_indices): predicted_category = candidates[predicted_index].split(\\\" \\\")[-1] actual_category = os.path.basename(os.path.dirname(batch_image_paths[j])) if predicted_category == actual_category: correct_count += 1 accuracy = correct_count / total_count return accuracy # 图片分类 def flowerClassify(): image_paths = get_all_image_paths(\\\"./flower_photos\\\") candidates = get_candidates(\\\"./flower_photos\\\") text_embeddings = text_embedding(candidates) start_time = time.time() acc = accuracy(image_paths, candidates, text_embeddings, batch_size=64) end_time = time.time() print(f\\\"Time taken to test accuracy: {end_time - start_time:.2f} seconds\\\") print(f\\\"Accuracy: {acc * 100:.2f}%\\\") ##################################################################################################3 # 遍历 data 目录获取所有图片路径 def get_images_from_data_dir(): data_dir = os.path.join(current_dir, 'data') if not os.path.exists(data_dir): print(f\\\"Data directory {data_dir} does not exist.\\\") return [] return get_all_image_paths(data_dir) # 找到与文本最匹配的图片 def find_most_matching_image(text, image_paths): text_emb = text_embedding([text]) image_embeddings = get_image_embeddings(image_paths) if image_embeddings is None: return None similarities = cosine_similarity(text_emb, image_embeddings) most_matching_index = np.argmax(similarities) return image_paths[most_matching_index] # 根据文字搜索图片 def searchPicByText(): image_paths = get_images_from_data_dir() query_text = \\\"a photo of a sunflowers\\\" most_matching_image = find_most_matching_image(query_text, image_paths) if most_matching_image: print(f\\\"The most matching image for '{query_text}' is: {most_matching_image}\\\") try: img = Image.open(most_matching_image) plt.imshow(img) plt.axis('off') plt.title(f\\\"Most matching image for '{query_text}'\\\") plt.show() except Exception as e: print(f\\\"Error opening image: {e}\\\") else: print(\\\"No matching image found.\\\")\"]},\"305\":{\"h\":\"小结\",\"t\":[\"在计算机视觉领域，常见的迁移学习方法是首先在大规模数据集（如ImageNet）上进行预训练，然后在具体的下游任务上进行微调。这种预训练通常是基于有监督学习的，需要大量的数据标注，因此成本较高。近年来，出现了一些基于自监督的方法，包括基于对比学习的方法（如MoCo和SimCLR）和基于图像掩码的方法（如MAE和BeiT）。自监督方法的优势在于不再需要标注数据。然而，无论是有监督还是自监督方法，在迁移到下游任务时，都需要进行有监督微调，无法实现zero-shot学习。对于有监督模型，由于它们在预训练数据集上采用固定类别数的分类器，因此在新的数据集上需要定义新的分类器来重新训练。对于自监督模型，代理任务通常是辅助进行表征学习，在迁移到其他数据集时也需要加上新的分类器进行有监督训练。\",\"然而，在NLP领域，基于自回归或语言掩码的预训练方法已经相对成熟，预训练模型很容易直接zero-shot迁移到下游任务，例如OpenAI的GPT-3。这种差异一方面是由于文本和图像属于两个完全不同的模态，另一个原因是NLP模型可以利用从互联网上收集的大量文本。因此，问题来了：能否基于互联网上的大量文本来预训练视觉模型？\",\"实际上，之前已经有一些研究工作探讨了使用文本作为监督信号来训练视觉模型。例如，2016年的工作《Learning Visual Features from Large Weakly Supervised Data》将这个问题转化为一个多标签分类任务，预测图像对应的文本的词袋模型；2017年的工作《Learning Visual N-Grams from Web Data》进一步扩展了这个方法来预测n-grams。最近的一些工作采用新的模型架构和预训练方法来从文本学习视觉特征，例如VirTex基于transformer的语言模型，ICMLM基于语言掩码的方法，ConVIRT基于对比学习的方法。总体来看，这方面的工作并不多，主要是因为这些方法难以实现较高的性能，例如2017年的那篇工作只在ImageNet上实现了11.5%的zero-shot性能，这远远低于ImageNet上的SOTA。此外，还有另一个方向，即基于文本弱监督来提升性能，例如谷歌的BiT和ViT基于JFT-300M数据集来预训练模型在ImageNet上取得SOTA。JFT-300M数据集是谷歌从互联网上收集的，通过一些自动化的手段将web text转化为18291个类别，但存在一定的噪声。尽管谷歌基于JFT-300M数据集取得了较好的结果，但这些模型仍然采用固定类别的softmax分类器进行预训练，这大大限制了它们的迁移能力和扩展性。\",\"谷歌采用的弱监督方法与以往方法的一个主要区别在于规模，或者说在于计算能力和数据集的规模。JFT-300M数据集的规模达到了上亿级别，谷歌利用强大的计算能力进行了预训练。相比之下，VirTex、ICMLM和ConVIRT仅在10万级别的数据上训练了几天。为了弥补数据规模上的差距，OpenAI从网络上收集了4亿条数据进行实验。然而，新的问题出现了：应该采用什么样的方法来进行训练。\",\"OpenAI首先尝试了VirTex模型，该模型联合训练一个CNN和文本transformer来预测图像的文本描述（image caption），但发现这种方法的训练效率（根据ImageNet数据集上的zero-shot性能评估）还不如直接预测词袋模型（bag of words），两者的训练效率相差3倍。如果进一步采用ConVIRT，即基于对比学习的方法，训练效率可以提高4倍。出现这种差异的原因不难理解，因为训练数据集中的文本-图像对是从互联网收集的，存在一定的噪声，即文本和图像可能不完全匹配。在这种情况下，适当降低训练目标反而可能取得更好的效果。\",\"从任务难度来看，排序为：Transformer Language Model > Bag of Words Prediction > Bag of Words Contrastive (CLIP)。由于训练数据量和模型计算量较大，训练效率成为一个至关重要的因素。因此，作者最终选择了对比学习方法来进行训练。\"]},\"306\":{\"h\":\"庖丁解牛BLIP2\",\"t\":[\"庖丁解牛BLIP2\",\"论文: https://arxiv.org/abs/2301.12597 代码: https://github.com/salesforce/LAVIS/tree/main/projects/blip2\"]},\"307\":{\"h\":\"背景\",\"t\":[\"多模态模型在过往发展的过程中，曾有一段时期一直在追求更大的网络架构（image encoder 和 text encoder/decoder）和 数据集，从而导致更大的训练代价。例如CLIP，400M数据，需要数百个GPU训练数十天，如何降低模型训练成本，同时具有很好的性能？\",\"这就是BLIP-2的起因，回顾下之前的多模态网络设计，三个模块（图像分支、文本分支、融合模块）:\",\"多模态网络设计\",\"(a) 早期的图文多模态：图像分支依赖目标检测器，模态融合比较弱，如VSE++。\",\"(b) 重点训练图像和文本特征提取，模态融合比较轻量，如CLIP。\",\"(c) 图像特征提取和模态融合都很重。\",\"(d) 侧重模态融合，特征提取网络相对轻量，如ViLT。\",\"模块\",\"(a)\",\"(b)\",\"(c)\",\"(d)\",\"理想情况\",\"视觉分支\",\"重\",\"重\",\"重\",\"轻\",\"重\",\"文本分支\",\"轻\",\"重\",\"轻\",\"轻\",\"重\",\"融合模块\",\"轻\",\"轻\",\"重\",\"重\",\"轻\",\"性能\",\"一般\",\"好\",\"好\",\"一般\",\"好\",\"训练代价\",\"中\",\"非常高\",\"非常高\",\"高\",\"中\",\"BLIP-2 基于 BLIP 架构，利用已有的ViT 和 LLM（均冻结）+ 一个的轻量Q-Former模块做模态融合，大幅降低训练成本。具有很强的zero-shot image-to-text generation能力，同时因LLM而具有了视觉推理能力。\"]},\"308\":{\"h\":\"模型结构\",\"t\":[\"BLIP-2 框架按照 Two-Stage 策略预训练轻量级查询 Transformer 以弥合模态差距。\",\"Stage 1: 不同模态数据的提取与融合。\",\"Stage 2: 把数据转换成LLM能识别的格式。\",\"Two-Stage流程\",\"从冻结的Image Encoder引到Vision-Language表征学习。\",\"从冻结的LLM引到Vision-Language生成学习，实现Zero Shot图文生成。\"]},\"309\":{\"h\":\"Stage 1: Representation Learning （表征学习）\",\"t\":[\"tage 1: Representation Learning （表征学习）\",\"Q-Former 由两个transformer模块组成，输入包含三部分：\",\"冻结参数的Image Encoder提取的图像embeddings\",\"Learned Queries\",\"Queries是一组可学习的embeddings，是第一个transformer模块的input，可认为是模型参数一部分\",\"推理时，Queries被用来从image encoder输出的embeddings里提取与input text最相关的视觉信息\",\"Input Text\",\"Stage 1 使用 图像-文本对 进行预训练，目标是训练好 Q-Former，以便 Queries 可以学习到如何更好地结合文本提取图片信息。\",\"对于Q-Former，一种比较好理解的方式：把Q-Former类比为一个Self-attention模块\",\"Q：learned queries\",\"K：input text\",\"V：image embeddings from Image Encoder\",\"Blip2Qformer核心代码实现如下:\",\"利用 query tokens 从 image embeddings 中提取与 text 最相关的视觉信息\",\"将输入的 input text 进行编码 , 然后使用第一个CLS Token 作为 input text representation\",\"class Blip2Qformer(Blip2Base): ... def forward(self, samples): image = samples[\\\"image\\\"] # (B,C,H,W) text = samples[\\\"text_input\\\"] # (B,seq_len) # frozen vit 将图片编码成 (B, seq_len, hidden_size) image_embeds = self.ln_vision(self.visual_encoder(image)) # 构建padding mask标注哪些image token是有效的 (B,seq_len) image_atts = torch.ones(image_embeds.size()[:-1], dtype=torch.long).to( image.device ) # 初始化query tokens (B,seq_len,hidden_size) query_tokens = self.query_tokens.expand(image_embeds.shape[0], -1, -1) # query tokens 从 image embeddings 中提取与 text 最相关的视觉信息 # query_output (B,seq_len,hidden_size) query_output = self.Qformer.bert( query_embeds=query_tokens, encoder_hidden_states=image_embeds, encoder_attention_mask=image_atts, use_cache=True, return_dict=True, ) image_feats = F.normalize( self.vision_proj(query_output.last_hidden_state), dim=-1 ) # 将input text 进行编码，维度为 (B,seq_len,hidden_size) text_tokens = self.tokenizer( text, padding=\\\"max_length\\\", truncation=True, max_length=self.max_txt_len, return_tensors=\\\"pt\\\", ).to(image.device) text_output = self.Qformer.bert( text_tokens.input_ids, attention_mask=text_tokens.attention_mask, # padding mask return_dict=True, ) # 取第一个cls token作为input text representation，维度为 (B,hidden_size) text_feat = F.normalize( self.text_proj(text_output.last_hidden_state[:, 0, :]), dim=-1 ) ...\",\"以上代码注释中统一用B代替image_batch和text_batch，以及seq_len和hidden_size也是同样处理手段，大家注意区分。\",\"为了训练好Q-Former，第一阶段设计了三个训练目标，分别如下:\"]},\"310\":{\"h\":\"1、Image-Text Contrastive Learning (ITC Loss, CLIP-like)\",\"t\":[\"目的: Image representation 与 Text representation，以最大化互信息\",\"自注意力掩码策略: Uni-modal Self-attention Mask（单模态自注意力）\",\"Queries 和 Text 仅能和自己的 tokens 做 attention（Query和Query、Text和Text）\",\"Uni-modal Self-attention Mask\",\"image_feats 中每个 image_feat 与 text_feat 计算一个 similarity score ，选择最大值作为这个图文对的相似度 :\",\"similarity score\",\"如何计算loss的: “in-batch negatives”，该方法正是CLIP在VLP领域发扬光大的。以下引用CLIP论文图做说明：\",\"in-batch negatives\",\"###============== Image-text Contrastive ===================### # 计算每个query token 和 text_feat 的相似度 , 得到相似度矩阵 (B,B,seq_len) # image_feats (B,seq_len,hidden_size) 变为 (B,1,seq_len,hidden_size) # text_feat (B,hidden_size) 变为 (B,hidden_size,1) sim_q2t = torch.matmul( image_feats.unsqueeze(1), text_feat.unsqueeze(-1) ).squeeze() # image-text similarity: aggregate across all query tokens # 保留和text_feat相似度最大的那个query token作为最后的相似度得分 , 维度为 (B,B) sim_i2t, _ = sim_q2t.max(-1) sim_i2t = sim_i2t / self.temp # 反过来计算text_feat 和 每个query token的相似度 , 得到相似度矩阵 (B,B,seq_len) # image_feats 维度变为 (B,hidden_size,seq_len) # text_feat (B,hidden_size) 变为 (B,1,1,hidden_size) sim_t2q = torch.matmul( text_feat.unsqueeze(1).unsqueeze(1), image_feats.permute(0, 2, 1) ).squeeze() # text-image similarity: aggregate across all query tokens # 保留和text_feat相似度最大的那个query token作为最后的相似度得分 , 维度为 (B,B) sim_t2i, _ = sim_t2q.max(-1) sim_t2i = sim_t2i / self.temp # 生成比标签 targets = torch.arange(image.size(0), device=image.device) # 计算 图文对比 Loss loss_itc = ( # sim_i2t 形状是 (B, B)，每一行表示一张图像和所有文本之间的相似度。 F.cross_entropy(sim_i2t, targets, label_smoothing=0.1) + F.cross_entropy(sim_t2i, targets, label_smoothing=0.1) ) / 2\"]},\"311\":{\"h\":\"2、Image-Text Matching (ITM Loss，二分类task)\",\"t\":[\"目的：通过学习image-text pair是否match，以细粒度对齐 Image representation 与 Text representation\",\"自注意力掩码策略: Bi-directional Self-attention Mask（双向自注意力）\",\"Queries 和Text都能和所有的tokens 做attention\",\"Bi-directional Self-attention Mask\",\"每个output query embedding送到二分类器中，得到一个logit；所有logits的平均作为最终的matching score:\",\"matching score\",\" ###============== Image-text Matching ===================### text_input_ids_world = text_tokens.input_ids text_attention_mask_world = text_tokens.attention_mask image_embeds_world = image_embeds with torch.no_grad(): # bs (batch size) ， diag_indices = [0,1,2,...,bs-1] diag_indices = torch.arange(bs, device=sim_t2i.device) # 把相似度矩阵对角线元素置为负无穷大，以避免模型将匹配图文对挑选为负样本 # (0,0) , (1,1) ... (bs-1,bs-1) 位置处设置为 -10000 sim_t2i[diag_indices, diag_indices] = -10000 sim_i2t[diag_indices, diag_indices] = -10000 weights_t2i = F.softmax(sim_t2i, dim=1) weights_i2t = F.softmax(sim_i2t, dim=1) # 为每个文本选择一个负样本图像 image_embeds_neg = [] for b in range(bs): neg_idx = torch.multinomial(weights_t2i[b], 1).item() image_embeds_neg.append(image_embeds_world[neg_idx]) image_embeds_neg = torch.stack(image_embeds_neg, dim=0) # 为每个图像选择一个负样本文本 text_ids_neg = [] text_atts_neg = [] for b in range(bs): neg_idx = torch.multinomial(weights_i2t[b], 1).item() text_ids_neg.append(text_input_ids_world[neg_idx]) text_atts_neg.append(text_attention_mask_world[neg_idx]) text_ids_neg = torch.stack(text_ids_neg, dim=0) text_atts_neg = torch.stack(text_atts_neg, dim=0) # 构建输入文本列表: [正样本batch，负样本batch1，负样本batch2] ，维度为 (3*bs,seq_len) text_ids_all = torch.cat( [text_tokens.input_ids, text_tokens.input_ids, text_ids_neg], dim=0 ) text_atts_all = torch.cat( [text_tokens.attention_mask, text_tokens.attention_mask, text_atts_neg], dim=0, ) # 构建query tokens列表: [正样本batch，负样本batch1，负样本batch2] ，维度为 (3*bs,seq_len,hidden_size) query_tokens_itm = self.query_tokens.expand(text_ids_all.shape[0], -1, -1) query_atts_itm = torch.ones(query_tokens_itm.size()[:-1], dtype=torch.long).to( image.device ) # 构建query和text的padding mask ，维度为 (3*bs,seq_len) attention_mask_all = torch.cat([query_atts_itm, text_atts_all], dim=1) # 构建输入图像列表: [正样本batch，负样本batch1，负样本batch2] ，维度为 (3*bs,seq_len,hidden_size) image_embeds_all = torch.cat( [image_embeds, image_embeds_neg, image_embeds], dim=0 ) image_atts_all = torch.ones(image_embeds_all.size()[:-1], dtype=torch.long).to( image.device ) # 1. 将输入文本转换为嵌入列表后和query tokens 在seq_len维度上拼接起来，维度为 (3*bs,text_seq_len + query_tokens_seq_len,hidden_size) # 2. 将文本和query tokens拼接得到的结果和图像嵌入进行cross attention计算，编码后得到输出的结果 output_itm = self.Qformer.bert( text_ids_all, query_embeds=query_tokens_itm, attention_mask=attention_mask_all, encoder_hidden_states=image_embeds_all, encoder_attention_mask=image_atts_all, return_dict=True, ) # 取 (3*bs,text_seq_len + query_tokens_seq_len,hidden_size) 中 query tokens部分的结果，维度为 (3*bs,query_tokens_seq_len,hidden_size) vl_embeddings = output_itm.last_hidden_state[:, : query_tokens_itm.size(1), :] # 把query tokens部分的每个位置都映射到2维匹配空间，维度为 (3*bs,query_tokens_seq_len,2) vl_output = self.itm_head(vl_embeddings) # 取每个位置的平均作为最终的匹配得分，维度为 (3*bs,2) logits = vl_output.mean(dim=1) # 构建匹配标签: [正样本batch=1，负样本batch1=0，负样本batch2=0] ，维度为 (3*bs) itm_labels = torch.cat( [torch.ones(bs, dtype=torch.long), torch.zeros(2 * bs, dtype=torch.long)], dim=0, ).to(image.device) # 计算交叉熵损失 loss_itm = F.cross_entropy(logits, itm_labels)\",\"当文本和query tokens同时输入BertModel时，BertEmbeddings会将text embeddings和query tokens的embeddings在seq_len维度上拼接起来。\",\"class BertEmbeddings(nn.Module): ... def forward( self, input_ids=None, position_ids=None, query_embeds=None, past_key_values_length=0, ): # 计算序列长度 if input_ids is not None: seq_length = input_ids.size()[1] else: seq_length = 0 # 如果未提供位置id，则自动生成 if position_ids is None: position_ids = self.position_ids[ :, past_key_values_length : seq_length + past_key_values_length ].clone() # 词嵌入与位置嵌入相加，若有query_embeds则拼接 if input_ids is not None: embeddings = self.word_embeddings(input_ids) if self.position_embedding_type == \\\"absolute\\\": position_embeddings = self.position_embeddings(position_ids) embeddings = embeddings + position_embeddings if query_embeds is not None: embeddings = torch.cat((query_embeds, embeddings), dim=1) else: embeddings = query_embeds embeddings = self.LayerNorm(embeddings) embeddings = self.dropout(embeddings) return embeddings\",\"下图展示了 Image-Text Matching 的完整计算流程，关于BertModel的代码解析部分，将会在下文进行详细讲解:\",\"Image-Text Matching\"]},\"312\":{\"h\":\"3、Image-Grounded Text Generation (ITG Loss, GPT-like)\",\"t\":[\"目的：让Q-Former学习“图生文”的能力，即给定Input Image，生成Text\",\"自注意力掩码策略：Multimodal Causal Self-attention Mask（多模态因果自监督）\",\"Queies 可以和所有自己的tokens做attention\",\"Text 可以和所有的query tokens 及 当前token之前的text tokens做attention\",\"Multimodal Causal Self-attention Mask\",\"视觉编码阶段:\",\"图像通过视觉编码器（如 ViT）编码为图像特征 image_embeds。Query tokens 通过 cross-attention 吸收图像特征，再通过 self-attention 生成压缩的视觉表示。缓存 query tokens 的 self-attention 的 past_key_values（而非 cross-attention 的 key/value）。\",\"QFormer 会使用 past_key_values 缓存和复用 EncoderLayer 中 self-attention 的 key/value :\",\"BertSelfAttention: 自注意力和交叉注意力流程统一化，每次计算后返回本次可能需要缓存的key & value\",\"class BertSelfAttention(nn.Module): ... def forward( self, hidden_states, attention_mask=None, head_mask=None, encoder_hidden_states=None, encoder_attention_mask=None, past_key_value=None, output_attentions=False, ): # 判断是否为交叉注意力 is_cross_attention = encoder_hidden_states is not None # 交叉注意力则key和value都来自图像,key来自query tokens if is_cross_attention: key_layer = self.transpose_for_scores(self.key(encoder_hidden_states)) value_layer = self.transpose_for_scores(self.value(encoder_hidden_states)) attention_mask = encoder_attention_mask # 如果有缓存的key,value传入, 此时先用text embedding计算出key和value # 再和缓存的key,value在seq_len的维度拼接起来 elif past_key_value is not None: key_layer = self.transpose_for_scores(self.key(hidden_states)) value_layer = self.transpose_for_scores(self.value(hidden_states)) key_layer = torch.cat([past_key_value[0], key_layer], dim=2) # (Batch,Heads,Seq_len,Hidden_size) value_layer = torch.cat([past_key_value[1], value_layer], dim=2) else: # 自注意力 key_layer = self.transpose_for_scores(self.key(hidden_states)) value_layer = self.transpose_for_scores(self.value(hidden_states)) # 交叉注意力: 传入图像，则q来自query tokens # 自注意力: q来自query tokens 或者 text embedding mixed_query_layer = self.query(hidden_states) query_layer = self.transpose_for_scores(mixed_query_layer) # * 缓存key和value past_key_value = (key_layer, value_layer) # 计算注意力分数 attention_scores = torch.matmul(query_layer, key_layer.transpose(-1, -2)) attention_scores = attention_scores / math.sqrt(self.attention_head_size) if attention_mask is not None: # 应用注意力掩码 attention_scores = attention_scores + attention_mask # softmax归一化得到注意力概率 attention_probs = nn.Softmax(dim=-1)(attention_scores) if is_cross_attention and self.save_attention: self.save_attention_map(attention_probs) attention_probs.register_hook(self.save_attn_gradients) # dropout防止过拟合 attention_probs_dropped = self.dropout(attention_probs) # 计算上下文表示 context_layer = torch.matmul(attention_probs_dropped, value_layer) context_layer = context_layer.permute(0, 2, 1, 3).contiguous() new_context_layer_shape = context_layer.size()[:-2] + (self.all_head_size,) context_layer = context_layer.view(*new_context_layer_shape) outputs = ( (context_layer, attention_probs) if output_attentions else (context_layer,) ) # outputs 列表最后一个记录了缓存的key和value outputs = outputs + (past_key_value,) return outputs\",\"BertLayer: 负责组织自注意力和交叉注意力的运算流程\",\"class BertLayer(nn.Module): ... def forward( self, hidden_states, # query tokens attention_mask=None, # query token padding mask head_mask=None, encoder_hidden_states=None, # image tokens encoder_attention_mask=None, # image padding mask past_key_value=None, output_attentions=False, query_length=0, ): self_attn_past_key_value = ( past_key_value[:2] if past_key_value is not None else None ) # 自注意力运算 self_attention_outputs = self.attention( hidden_states, attention_mask, head_mask, output_attentions=output_attentions, past_key_value=self_attn_past_key_value, # 缓存的key和value ) attention_output = self_attention_outputs[0] outputs = self_attention_outputs[1:-1] present_key_value = self_attention_outputs[-1] # 交叉注意力运算 if query_length > 0: query_attention_output = attention_output[:, :query_length, :] if self.has_cross_attention: cross_attention_outputs = self.crossattention( query_attention_output, attention_mask, head_mask, encoder_hidden_states, encoder_attention_mask, output_attentions=output_attentions, ) query_attention_output = cross_attention_outputs[0] outputs = ( outputs + cross_attention_outputs[1:-1] ) ... outputs = (layer_output,) + outputs outputs = outputs + (present_key_value,) # outputs 列表最后一个记录了缓存的key和value return outputs\",\"BertEncoder: 负责组织多个 BertLayer 叠加的运算流程\",\"class BertEncoder(nn.Module): ... def forward( self, hidden_states, # query tokens attention_mask=None, # query tokens padding mask head_mask=None, encoder_hidden_states=None, # images encoder_attention_mask=None, # images padding mask past_key_values=None, use_cache=None, output_attentions=False, output_hidden_states=False, return_dict=True, query_length=0, ): ... for i in range(self.config.num_hidden_layers): layer_module = self.layer[i] ... # 如果有缓存，则计算当前层BertLayer时，会从缓存中取出对应层先前缓存的key&value past_key_value = past_key_values[i] if past_key_values is not None else None layer_outputs = layer_module( hidden_states, attention_mask, layer_head_mask, encoder_hidden_states, encoder_attention_mask, past_key_value, output_attentions, query_length, ) hidden_states = layer_outputs[0] # 每一层BertLayer产生的key&value都会进行缓存 if use_cache: next_decoder_cache += (layer_outputs[-1],) ... return BaseModelOutputWithPastAndCrossAttentions( last_hidden_state=hidden_states, past_key_values=next_decoder_cache, hidden_states=all_hidden_states, attentions=all_self_attentions, cross_attentions=all_cross_attentions, )\",\"Image-Grounded Text Generation 学习目标\",\" ... query_output = self.Qformer.bert( query_embeds=query_tokens, encoder_hidden_states=image_embeds, encoder_attention_mask=image_atts, use_cache=True, # 缓存key&value return_dict=True, ) ... ##================= Image Captioning ========================## # 这一部分的目标是：根据图像特征，使用 Q-Former 解码器生成文本描述（caption） # Step 1: 准备 decoder 的输入 token IDs decoder_input_ids = text_tokens.input_ids.clone() # 将第一个 token 替换为 BOS（Begin Of Sentence）标记，表示“开始生成句子” decoder_input_ids[:, 0] = self.tokenizer.bos_token_id # Step 2: 构造训练目标 labels # 将 padding token 替换为 -100，这是 CrossEntropyLoss 默认忽略的标签值 labels = decoder_input_ids.masked_fill( decoder_input_ids == self.tokenizer.pad_token_id, -100 ) # Step 3: 构建 attention_mask（包含 query tokens 和 文本 token 的 mask） # query_atts 是 query tokens 的 attention mask，全为 1（因为都是有效 token） query_atts = torch.ones(query_tokens.size()[:-1], dtype=torch.long).to(image.device) # 将 query token 的 mask 和文本 token 的 mask 拼接在一起 attention_mask = torch.cat([query_atts, text_tokens.attention_mask], dim=1) # Step 4: 调用 Q-Former 解码器进行文本生成 lm_output = self.Qformer( decoder_input_ids, # 输入 token ID 序列（如 [BOS], dog, is...） attention_mask=attention_mask, # 指明哪些位置是有效的（非 padding） past_key_values=query_output.past_key_values, # 编码器输出的 key/value，包含图像信息 return_dict=True, # 返回字典格式结果 labels=labels, # 训练目标，用于计算 loss ) # Step 5: 提取语言模型损失 loss_lm = lm_output.loss # 使用交叉熵损失衡量生成与真实之间的差异\",\"文本生成阶段:\",\"将缓存的 past_key_values 作为文本解码器的初始状态。\",\"文本 token 在自回归生成时，通过 self-attention 复用缓存的视觉信息。\",\"BertLMHeadModel: 自回归语言建模任务（如文本生成）\",\"class BertLMHeadModel(BertPreTrainedModel): ... def forward( self, input_ids=None, attention_mask=None, position_ids=None, head_mask=None, query_embeds=None, encoder_hidden_states=None, encoder_attention_mask=None, labels=None, past_key_values=None, use_cache=True, output_attentions=None, output_hidden_states=None, return_dict=None, return_logits=False, is_decoder=True, reduction=\\\"mean\\\", ): ... # 调用 BertModel 进行文本编码 (结合缓存的attention key&value) outputs = self.bert( input_ids, attention_mask=attention_mask, position_ids=position_ids, head_mask=head_mask, query_embeds=query_embeds, encoder_hidden_states=encoder_hidden_states, encoder_attention_mask=encoder_attention_mask, past_key_values=past_key_values, use_cache=use_cache, output_attentions=output_attentions, output_hidden_states=output_hidden_states, return_dict=return_dict, is_decoder=is_decoder, ) sequence_output = outputs[0] ... # self.cls 是一个分类头（BertOnlyMLMHead），它将每个 token 的向量映射到词汇表空间（logits） prediction_scores = self.cls(sequence_output) ... lm_loss = None if labels is not None: # 因为我们要预测下一个 token，所以把 logits 和 labels 错位对齐： # shifted_prediction_scores: 所有 token 的预测（除了最后一个） shifted_prediction_scores = prediction_scores[:, :-1, :].contiguous() # labels: 所有 token 的真实值（从第二个开始） labels = labels[:, 1:].contiguous() loss_fct = CrossEntropyLoss(reduction=reduction, label_smoothing=0.1) lm_loss = loss_fct( shifted_prediction_scores.view(-1, self.config.vocab_size), labels.view(-1), ) if reduction == \\\"none\\\": lm_loss = lm_loss.view(prediction_scores.size(0), -1).sum(1) ... return CausalLMOutputWithCrossAttentions( loss=lm_loss, logits=prediction_scores, past_key_values=outputs.past_key_values, hidden_states=outputs.hidden_states, attentions=outputs.attentions, cross_attentions=outputs.cross_attentions, )\",\"BertModel 的 forward 方法中，当is_decoder=True时，会在get_extended_attention_mask方法中，构建一个下三角矩阵作为因果掩码矩阵。\"]},\"313\":{\"h\":\"Stage 2: Generative Learning（生成学习）\",\"t\":[\"Stage 2 是为了把 Q-Former 和冻结参数的 LLM 连接起来，以利用 LLM 的文本生成能力。\",\"支持两种LLM（decoder only、encoder-decoder based）:\",\"Generative Learning\",\"首先输入图片，直接输入冻结参数的 Image Encoder，得到图像的表征。\",\"然后图像的表征和 Queries 一起送入 Q-Former，得到 Queries 的输出 ，使用全连接 (FC) 层将 线性投影到与 LLM 的text embedding相同维度。\",\"后将投影后的 添加到 input text embeddings前面，Queries 的输出蕴含了视觉信息，送入LLM时，充当了soft visual prompts 。\",\"由于 Q-Former 已经过预训练以提取语言信息视觉表示，因此它有效地充当信息瓶颈，将最有用的信息提供给 LLM，同时删除不相关的视觉信息。这减少了LLM学习视觉语言对齐的负担，从而缓解了灾难性的遗忘问题。\",\"Blip2Qformer 的generate方法负责完成图像描述生成（图文到文本）:\",\"class Blip2Qformer(Blip2Base): ... def generate( self, samples, # 输入样本，包含图像和可选文本 use_nucleus_sampling=False, # 是否使用核采样（top-p采样） num_beams=3, # beam search的beam数量 max_length=30, # 生成文本的最大长度 min_length=10, # 生成文本的最小长度 top_p=0.9, # 核采样的概率阈值 repetition_penalty=1.0, # 重复惩罚系数 ): # 1. 图像编码阶段 image = samples[\\\"image\\\"] # 通过视觉编码器（如ViT）提取图像特征 (B, 257, D) image_embeds = self.ln_vision(self.visual_encoder(image)) # 2. 处理beam search扩展 if not use_nucleus_sampling: # 如果是beam search，需要复制图像特征以匹配beam数量 # (B, 257, D) -> (B*num_beams, 257, D) image_embeds = image_embeds.repeat_interleave(num_beams, dim=0) else: # 核采样时不扩展beam num_beams = 1 # 创建图像注意力掩码（全1，表示所有图像token有效） image_atts = torch.ones(image_embeds.size()[:-1], dtype=torch.long).to( image.device ) # 3. 准备生成参数 model_kwargs = { \\\"encoder_hidden_states\\\": image_embeds, # 图像特征作为cross-attention的输入 \\\"encoder_attention_mask\\\": image_atts, # 图像注意力掩码 } # 4. 初始化文本输入（以BOS token开头） # 形状: (batch_size, 1)，初始为[BOS] input_ids = ( torch.LongTensor(image.size(0), 1) .fill_(self.tokenizer.bos_token_id) .to(image.device) ) # 5. 扩展可学习的query tokens # query_tokens形状: (batch_size, num_query_tokens, D) query_tokens = self.query_tokens.expand(image_embeds.shape[0], -1, -1) # 6. 调用Q-Former的生成方法 outputs = self.Qformer.generate( input_ids=input_ids, # 初始文本token [BOS] query_embeds=query_tokens, # 可学习query tokens max_length=max_length, # 最大生成长度 min_length=min_length, # 最小生成长度 num_beams=num_beams, # beam数量 do_sample=use_nucleus_sampling, # 是否采样 top_p=top_p, # 核采样参数 eos_token_id=self.tokenizer.sep_token_id, # 结束符 pad_token_id=self.tokenizer.pad_token_id, # 填充符 **model_kwargs # 图像特征和掩码 ) # 7. 解码生成的token id为文本 captions = self.tokenizer.batch_decode(outputs, skip_special_tokens=True) return captions\"]},\"314\":{\"h\":\"庖丁解牛VIT\",\"t\":[\"多模态模型VIT原理与图片分类实战演练\",\"Vision Transformer是2021年谷歌在ICLR上提出的算法，它首次将NLP领域火热的Transformer模型架构移植到了CV领域，打破了这两个领域壁垒，并取得不错的成效。\",\"Vision Transformer的模型结构相比于Transformer来说更简单，在Transformer模型中，主要包含Encoder和Decoder结构，而ViT(Vision Transformer)仅借鉴了Encoder结构。\",\"ViT原论文中最核心的结论是: 当拥有足够多的数据进行预训练的时候，ViT的表现就会超过CNN，突破transformer缺少归纳偏置的限制，可以在下游任务中获得较好的迁移效果。\",\"归纳偏置:\",\"归纳偏置能够帮助学习算法缩小搜索范围，快速找到合适的模型。\",\"例如，在图像分类任务中，如果没有任何归纳偏置，学习算法需要在所有可能的函数空间中搜索最优模型，这几乎是不可能完成的任务。而通过引入特定的归纳偏置，如局部性和平移不变性（CNN 所具备的），可以将搜索范围限制在满足这些性质的模型子空间内，大大提高学习效率。\",\"但是当训练数据集不够大的时候，ViT的表现通常比同等大小的ResNets要差一些，因为Transformer和CNN相比缺少归纳偏置（inductive bias），即一种先验知识，提前做好的假设。CNN具有两种归纳偏置，一种是局部性（locality/two-dimensional neighborhood structure），即图片上相邻的区域具有相似的特征；一种是平移不变形（translation equivariance）。当CNN具有以上两种归纳偏置，就有了很多先验信息，需要相对少的数据就可以学习一个比较好的模型。\"]},\"315\":{\"h\":\"原理\",\"t\":[\"本文将通过一个花卉分类的实战案例结合ViT原论文，来帮助大家梳理清楚Vision Transformer的核心流程实现。\"]},\"316\":{\"h\":\"0. 数据下载\",\"t\":[\"实验采用的是花蕊数据集，共5个类别，约4000多个样本。\",\"数据集下载：https://pan.baidu.com/s/137mO-7PY1jDq1Wp0NNyT3A?pwd=qvmq\",\"数据集加载代码:\",\"def read_split_data(root: str, val_rate: float = 0.2): random.seed(0) # 保证随机结果可复现 assert os.path.exists(root), \\\"dataset root: {} does not exist.\\\".format(root) # 遍历文件夹，一个文件夹对应一个类别 flower_class = [cla for cla in os.listdir(root) if os.path.isdir(os.path.join(root, cla))] # 排序，保证顺序一致 flower_class.sort() # 生成类别名称以及对应的数字索引 class_indices = dict((k, v) for v, k in enumerate(flower_class)) json_str = json.dumps(dict((val, key) for key, val in class_indices.items()), indent=4) with open('class_indices.json', 'w') as json_file: json_file.write(json_str) train_images_path = [] # 存储训练集的所有图片路径 train_images_label = [] # 存储训练集图片对应索引信息 val_images_path = [] # 存储验证集的所有图片路径 val_images_label = [] # 存储验证集图片对应索引信息 every_class_num = [] # 存储每个类别的样本总数 supported = [\\\".jpg\\\", \\\".JPG\\\", \\\".png\\\", \\\".PNG\\\"] # 支持的文件后缀类型 # 遍历每个文件夹下的文件 for cla in flower_class: cla_path = os.path.join(root, cla) # 遍历获取supported支持的所有文件路径 images = [os.path.join(root, cla, i) for i in os.listdir(cla_path) if os.path.splitext(i)[-1] in supported] # 获取该类别对应的索引 image_class = class_indices[cla] # 记录该类别的样本数量 every_class_num.append(len(images)) # 按比例随机采样验证样本 val_path = random.sample(images, k=int(len(images) * val_rate)) for img_path in images: if img_path in val_path: # 如果该路径在采样的验证集样本中则存入验证集 val_images_path.append(img_path) val_images_label.append(image_class) else: # 否则存入训练集 train_images_path.append(img_path) train_images_label.append(image_class) print(\\\"{} images were found in the dataset.\\\".format(sum(every_class_num))) print(\\\"{} images for training.\\\".format(len(train_images_path))) print(\\\"{} images for validation.\\\".format(len(val_images_path))) plot_image = True if plot_image: # 绘制每种类别个数柱状图 plt.bar(range(len(flower_class)), every_class_num, align='center') # 将横坐标0,1,2,3,4替换为相应的类别名称 plt.xticks(range(len(flower_class)), flower_class) # 在柱状图上添加数值标签 for i, v in enumerate(every_class_num): plt.text(x=i, y=v + 5, s=str(v), ha='center') # 设置x坐标 plt.xlabel('image class') # 设置y坐标 plt.ylabel('number of images') # 设置柱状图的标题 plt.title('flower class distribution') plt.show() return train_images_path, train_images_label, val_images_path, val_images_label\",\"自定义一个MyDataSet类来封装我们加载得到的数据集:\",\"from torch.utils.data import Dataset from PIL import Image import torch class MyDataSet(Dataset): \\\"\\\"\\\"自定义数据集\\\"\\\"\\\" def __init__(self, images_path: list, images_class: list, transform=None): \\\"\\\"\\\" 初始化自定义数据集类 :param images_path: 包含所有图像文件路径的列表 :param images_class: 包含所有图像对应类别的列表，与 images_path 中的图像一一对应 :param transform: 图像预处理的转换操作，默认为 None \\\"\\\"\\\" self.images_path = images_path self.images_class = images_class self.transform = transform def __len__(self): \\\"\\\"\\\" 返回数据集中图像的数量 :return: 数据集中图像的数量 \\\"\\\"\\\" return len(self.images_path) def __getitem__(self, item): \\\"\\\"\\\" 根据索引获取数据集中的图像和对应的标签 :param item: 图像的索引 :return: 经过预处理的图像和对应的标签 \\\"\\\"\\\" # 打开指定索引的图像文件 img = Image.open(self.images_path[item]) # RGB为彩色图片，L为灰度图片 # 检查图像是否为 RGB 模式，如果不是则抛出异常 if img.mode != 'RGB': raise ValueError(\\\"image: {} isn't RGB mode.\\\".format(self.images_path[item])) # 获取对应图像的标签 label = self.images_class[item] # 如果定义了图像预处理转换操作，则对图像进行处理 if self.transform is not None: img = self.transform(img) return img, label @staticmethod def collate_fn(batch): \\\"\\\"\\\" 自定义的批量数据处理函数，用于将一个批次的数据组合成一个张量 :param batch: 一个批次的数据，包含图像和对应的标签 :return: 组合后的图像张量和标签张量 \\\"\\\"\\\" # 官方实现的default_collate可以参考 # https://github.com/pytorch/pytorch/blob/67b7e751e6b5931a9f45274653f4f653a4e6cdf6/torch/utils/data/_utils/collate.py # 将一个批次的数据拆分为图像和标签两个元组 images, labels = tuple(zip(*batch)) # 将图像元组堆叠成一个四维张量，维度为 (batch_size, channels, height, width) images = torch.stack(images, dim=0) # 将标签元组转换为一个一维张量 labels = torch.as_tensor(labels) return images, labels\",\"两点注意:\",\"当使用 DataLoader 从数据集（Dataset）中加载数据时，它会将多个样本收集起来形成一个批次，但默认的组合方式可能不满足所有需求，这时就可以自定义 collate_fn 函数。\",\"@staticmethod 是 Python 中的一个装饰器，用于将一个方法定义为静态方法。静态方法是类中的一种特殊方法，它与类的实例和类本身都没有直接关联，可以直接通过类名调用，不需要创建类的实例。\"]},\"317\":{\"h\":\"1. 图片预处理\",\"t\":[\"预处理这个步骤在论文里并没有详细说明，但是对于ViT这个结构而言，输入的图片尺寸并不是自定义的，ViT-B/16为例，输入的图片尺寸必须为224x224。\",\"在 ViT - B/16 中，“B” 代表的是模型的基础（Base）版本 ，“16” 表示每个图像块的大小是 16x16 像素；ViT 通常在大规模数据集（如 ImageNet）上进行预训练，而预训练过程中使用的输入图像尺寸通常固定为 224x224。在预训练时，模型的参数是根据这个特定尺寸的输入数据进行优化和学习的。当我们在其他任务中使用预训练好的模型时，为了充分利用预训练的权重，也需要保持输入图像尺寸与预训练时一致，这样可以保证模型的特征提取能力和性能。\",\"因此，首先需要对输入图片进行尺寸变化，具体方式可以是直接缩放(Resize)，也可以进行随机裁剪(RandomResizedCrop)。\",\"对数据集和验证集划分之后，这里对训练集的处理方式是随机切成224x224像素的图片，然后进行水平翻转，再进行归一化和标准化处理；对验证集的处理方式是先Resize成256x256的图片，再从中心位置裁剪成224x224，再进行归一化和标准化处理。\",\"# 定义一个字典 data_transform，用于存储训练集和验证集的图像预处理转换操作 data_transform = { # 训练集的预处理转换操作 \\\"train\\\": transforms.Compose([ # 随机裁剪输入图像，将裁剪后的图像调整为 224x224 大小 # 这是一种数据增强的方式，通过随机裁剪可以增加训练数据的多样性，提高模型的泛化能力 transforms.RandomResizedCrop(224), # 以 0.5 的概率随机水平翻转图像 # 同样是数据增强的手段，增加了图像的多样性，有助于模型学习到不同方向的特征 transforms.RandomHorizontalFlip(), # 将 PIL 图像或 NumPy 数组转换为 PyTorch 的张量（Tensor） # 同时会将像素值从 [0, 255] 范围缩放到 [0, 1] 范围 transforms.ToTensor(), # 对图像进行归一化处理 # 第一个参数 [0.5, 0.5, 0.5] 是图像每个通道的均值，第二个参数 [0.5, 0.5, 0.5] 是图像每个通道的标准差 # 归一化有助于模型更快地收敛，提高训练的稳定性 transforms.Normalize([0.5, 0.5, 0.5], [0.5, 0.5, 0.5]) ]), # 验证集的预处理转换操作 \\\"val\\\": transforms.Compose([ # 将图像的短边缩放为 256 像素，长边按比例缩放 # 这一步是为了保证图像的整体比例不变，后续再进行裁剪操作 transforms.Resize(256), # 从图像的中心位置裁剪出 224x224 大小的图像 # 验证集不需要进行数据增强，只需要将图像调整到合适的大小 transforms.CenterCrop(224), # 将 PIL 图像或 NumPy 数组转换为 PyTorch 的张量（Tensor） # 同样会将像素值从 [0, 255] 范围缩放到 [0, 1] 范围 transforms.ToTensor(), # 对图像进行归一化处理，参数与训练集的归一化参数相同 # 保证训练集和验证集的数据处理方式一致 transforms.Normalize([0.5, 0.5, 0.5], [0.5, 0.5, 0.5]) ]) }\",\"下面我们将用于图片变换的transforms流水线和上面自定义的MyDataSet类都封装到DataLoader去。\",\"train_images_path, train_images_label, val_images_path, val_images_label = read_split_data(data_path) # 实例化训练数据集 train_dataset = MyDataSet(images_path=train_images_path, images_class=train_images_label, transform=data_transform[\\\"train\\\"]) # 实例化验证数据集 val_dataset = MyDataSet(images_path=val_images_path, images_class=val_images_label, transform=data_transform[\\\"val\\\"]) train_loader = torch.utils.data.DataLoader(train_dataset, batch_size=batch_size, shuffle=True, collate_fn=train_dataset.collate_fn) val_loader = torch.utils.data.DataLoader(val_dataset, batch_size=batch_size, shuffle=False, collate_fn=val_dataset.collate_fn)\"]},\"318\":{\"h\":\"2. 图片切割\",\"t\":[\"Transformer需要输入的是一维的Token，对于二维的图像，一种朴素的想法就是把一个个像素点拉平，这样就成了一个一维序列。但是这样造成的一个后果是计算量太庞大，比如一张224x224的图片，变成1维度之后就成了50176，相当于直接输入一篇五万字的文章，模型难以计算。\",\"那么，一个改进的想法就是把一张图片分成nxn个Patch，每一个Patch作为一个Token，这样计算量就大大减小了。\",\"以ViT-B/16为例，将输入图片(224x224)按照16x16大小的Patch进行划分，划分后可以得到共个Patch。每个Patch是三通道的小图片，shape为(16, 16, 3)，将其展平就变成了一个长度为768的向量。\",\"每一个向量作为一个单独的输入，那样我们总共有196个向量，在代码中，可以变成一个[196,768]的矩阵，进行并行输入。\",\"这一步的操作在论文中是直接采用切割的处理办法，但是实际的代码实现中，采用了一种更巧妙的解决思路，就是利用一个卷积核大小为16x16，步距为16，卷积核个数为768的卷积层来进行实现。\",\"再来回顾我们的卷积层计算公式：\",\"输入为[224,244,3]，经过卷积层变成[14,14,768]，再映射为[196,768]。\",\"这样，就完成了从图片到Token之间的转换，我们通过自定义一个PatchEmbed类完成上述工作。\",\"class PatchEmbed(nn.Module): \\\"\\\"\\\" 2D Image to Patch Embedding 该类的作用是将二维图像分割成多个图像块（patch），并将这些图像块嵌入到一个低维向量空间中 \\\"\\\"\\\" def __init__(self, img_size=224, patch_size=16, in_c=3, embed_dim=768, norm_layer=None): \\\"\\\"\\\" 初始化 PatchEmbed 类 :param img_size: 输入图像的尺寸，默认为 224。如果传入一个整数，则表示图像是正方形，边长为该整数； :param patch_size: 每个图像块的尺寸，默认为 16。同样，如果传入一个整数，则表示图像块是正方形，边长为该整数； :param in_c: 输入图像的通道数，默认为 3（对应 RGB 图像） :param embed_dim: 嵌入维度，即每个图像块经过卷积操作后得到的特征向量的维度，默认为 768 :param norm_layer: 归一化层，默认为 None。如果传入一个归一化层类，则使用该层进行归一化；否则使用 nn.Identity() 表示不进行归一化 \\\"\\\"\\\" super().__init__() # 将 img_size 和 patch_size 转换为元组形式，如果传入的是整数，则将其转换为 (整数, 整数) 的形式 img_size = (img_size, img_size) patch_size = (patch_size, patch_size) self.img_size = img_size self.patch_size = patch_size # 计算网格大小，即图像在水平和垂直方向上分别可以划分的图像块数量 self.grid_size = (img_size[0] // patch_size[0], img_size[1] // patch_size[1]) # 计算图像块的总数，即网格大小的乘积 self.num_patches = self.grid_size[0] * self.grid_size[1] # 定义一个二维卷积层，用于将输入图像分割成多个图像块并进行嵌入 # in_c 是输入通道数，embed_dim 是输出通道数（也就是卷积核的数量） # kernel_size 是卷积核的大小，这里设置为图像块的大小 # stride 是卷积核的步长，这里设置为图像块的大小，确保卷积操作不会重叠 self.proj = nn.Conv2d(in_c, embed_dim, kernel_size=patch_size, stride=patch_size) # 如果传入了归一化层类，则使用该层进行归一化；否则使用 nn.Identity() 表示不进行归一化 self.norm = norm_layer(embed_dim) if norm_layer else nn.Identity() def forward(self, x): \\\"\\\"\\\" 前向传播函数 :param x: 输入的图像张量，形状为 [B, C, H, W]，其中 B 是批量大小，C 是通道数，H 是图像高度，W 是图像宽度 :return: 经过处理后的图像块嵌入张量，形状为 [B, num_patches, embed_dim] \\\"\\\"\\\" # 获取输入图像张量的形状 B, C, H, W = x.shape # 注意下面的embed_dim代表的是卷积核的数量，也就是经过卷积后拼接得到的特征图(输出通道)数量 # H`和 W`代表输出特征图的宽和高 # 首先使用卷积层对输入图像进行处理，得到形状为 [B, embed_dim, H', W'] 的特征图 # 然后将特征图的最后两维展平为一维，得到形状为 [B, embed_dim, num_patches] 的张量 # 最后交换第 1 维和第 2 维，得到形状为 [B, num_patches, embed_dim] 的张量 # 这里的 num_patches 是图像块的总数 x = self.proj(x).flatten(2).transpose(1, 2) # 对处理后的张量进行归一化操作 x = self.norm(x) return x\",\"用一个简化版的例子说明上述过程:\",\"核心要点: 将卷积后的通道维数作为embedding的维度，卷积后剩余的长和宽相乘作为时间维度，由此把图片转换为序列的embedding形式。\"]},\"319\":{\"h\":\"3. 添加[class]token\",\"t\":[\"在上面的结构图中可以看到，输入Encoder的最左侧部分添加了一个0*这个Token，这个就是额外添加的一个[class]token，单独用来处理类别信息，经过Encoder之后，需要单独将这个Token再提取出来，输入到MLP Head之中再输出分类结果。\",\"这也是为什么结构图中MLP Head的位置是和这个[class]token对齐。\",\"这里简单介绍一下CLS TOKEN的作用:\",\"[CLS] Token 的作用是通过训练过程中损失值的降低，模型学会如何通过注意力机制将图像的有效信息汇聚到 [CLS] Token 中，从而完成图像分类任务。\",\"初始化： \",\"[CLS] Token 是一个随机初始化的向量，初始时没有任何语义信息。\",\"位置编码被添加到 patch 嵌入中，以保留图像的空间信息。\",\"前向传播： \",\"输入图像被分割成 patches，并通过线性变换映射到嵌入空间。\",\"[CLS] Token 被添加到 patch 嵌入序列的开头。\",\"通过多层 Transformer Encoder，模型计算每个 patch 嵌入（包括 [CLS] Token）与其他 patch 嵌入的关系。\",\"注意力汇聚： \",\"在每一层 Transformer 中，[CLS] Token 通过自注意力机制与其他 patch 嵌入交互。\",\"模型学会将图像中与分类任务相关的信息汇聚到 [CLS] Token 中。\",\"损失计算与反向传播： \",\"[CLS] Token 的输出向量被输入到分类头中，用于预测图像的类别。\",\"通过计算损失（如交叉熵损失），模型更新参数，使得 [CLS] Token 能够更好地聚合图像信息。\",\"收敛： \",\"随着训练的进行，损失值逐渐降低，模型学会如何通过注意力机制将图像的有效信息汇聚到 [CLS] Token 中。\",\"最终，[CLS] Token 的输出向量能够很好地表示图像的全局特征，用于分类任务。\",\"[CLS] Token 能起作用的原因在于：\",\"注意力机制的特性： \",\"自注意力机制能够捕捉图像中任意两个 patches 之间的关系。\",\"[CLS] Token 通过与其他 patches 的交互，能够动态地聚合图像信息。\",\"训练目标的引导： \",\"训练过程中，损失函数直接作用于 [CLS] Token 的输出。\",\"模型被强制学会将图像的有效信息汇聚到 [CLS] Token 中，以最小化损失。\",\"全局特征表示： \",\"[CLS] Token 位于序列的开头，能够通过多层 Transformer 逐步聚合全局信息。\",\"最终，[CLS] Token 的输出向量能够很好地表示图像的全局特征。\",\"class VisionTransformer(nn.Module): def __init__(self, img_size=224, patch_size=16, in_c=3, num_classes=1000, embed_dim=768, embed_layer=None): \\\"\\\"\\\" Args: img_size (int, tuple): 输入图像的尺寸 patch_size (int, tuple): 图像块的尺寸 in_c (int): 输入图像的通道数 num_classes (int): 分类任务的类别数 embed_dim (int): 嵌入维度 embed_layer (nn.Module): 图像块嵌入层 \\\"\\\"\\\" super(VisionTransformer, self).__init__() # 保存分类任务的类别数 self.num_classes = num_classes # 保存嵌入维度，同时作为特征数量，以保持与其他模型的一致性 self.num_features = self.embed_dim = embed_dim # 只有一个特殊标记（分类标记） self.num_tokens = 1 # 创建图像块嵌入层 self.patch_embed = embed_layer(img_size=img_size, patch_size=patch_size, in_c=in_c, embed_dim=embed_dim) # 计算图像块的数量 num_patches = self.patch_embed.num_patches # 创建可学习的分类标记 self.cls_token = nn.Parameter(torch.zeros(1, 1, embed_dim)) # 使用截断正态分布初始化分类标记 nn.init.trunc_normal_(self.cls_token, std=0.02) ... def forward_features(self, x): # [B, C, H, W] -> [B, num_patches, embed_dim] # 将输入图像进行图像块嵌入 x = self.patch_embed(x) # [B, 196, 768] # [1, 1, 768] -> [B, 1, 768] # 扩展分类标记以匹配输入批次大小 cls_token = self.cls_token.expand(x.shape[0], -1, -1) # 将分类标记和图像块嵌入拼接 x = torch.cat((cls_token, x), dim=1) # [B, 197, 768] ... # 返回分类标记对应的特征,x[:,0]对应维度为[B,1,768] return x[:,0]; def forward(self, x): # 提取输入图像的特征 x = self.forward_features(x) # 通过分类头 -- [B,1,768] x = self.head(x) return x\"]},\"320\":{\"h\":\"4. 添加位置编码\",\"t\":[\"在Transformer中，位置编码的作用是为了记忆输入的语序信息。ViT中，同样需要位置编码来记录各图像块之间的位置信息。\",\"这里主要有两种位置编码思路，一种思路是在转换之前(14,14)的图像块矩阵添加二维(2-D)位置编码，另一种思路是在转换后(196+1)这个维度上添加一维(1-D)位置编码。\",\"论文作者也对其做了实验，实验结果如下表所示：\",\" 可以看到，添加一维位置编码和二维位置编码并没有太大的差异。作者随后也对一维位置编码的结果进行了可视化，结果如下图所示：\",\" 上图中是每一个Patch中各位置的位置编码相似性度量，越接近黄色的位置代表越靠近位置编码的中心位置，可以看到，即使是一维位置编码，同样可以比较好地记录二维信息。\",\"class VisionTransformer(nn.Module): def __init__(self, img_size=224, patch_size=16, in_c=3, num_classes=1000, embed_dim=768, depth=12, num_heads=12, mlp_ratio=4.0, qkv_bias=True, qk_scale=None, representation_size=None, drop_ratio=0., attn_drop_ratio=0., drop_path_ratio=0., embed_layer=None, norm_layer=None, act_layer=None): super(VisionTransformer, self).__init__() # 保存分类任务的类别数 self.num_classes = num_classes # 保存嵌入维度，同时作为特征数量，以保持与其他模型的一致性 self.num_features = self.embed_dim = embed_dim # 只有一个特殊标记（分类标记） self.num_tokens = 1 # 创建图像块嵌入层 self.patch_embed = embed_layer(img_size=img_size, patch_size=patch_size, in_c=in_c, embed_dim=embed_dim) # 计算图像块的数量 num_patches = self.patch_embed.num_patches # 创建可学习的分类标记 self.cls_token = nn.Parameter(torch.zeros(1, 1, embed_dim)) # 创建可学习的位置嵌入 self.pos_embed = nn.Parameter(torch.zeros(1, num_patches + self.num_tokens, embed_dim)) # 创建丢弃层，用于位置嵌入后的随机丢弃 self.pos_drop = nn.Dropout(p=drop_ratio) ... # 权重初始化 # 使用截断正态分布初始化位置嵌入 nn.init.trunc_normal_(self.pos_embed, std=0.02) # 使用截断正态分布初始化分类标记 nn.init.trunc_normal_(self.cls_token, std=0.02) ... def forward_features(self, x): # [B, C, H, W] -> [B, num_patches, embed_dim] # 将输入图像进行图像块嵌入 x = self.patch_embed(x) # [B, 196, 768] # [1, 1, 768] -> [B, 1, 768] # 扩展分类标记以匹配输入批次大小 cls_token = self.cls_token.expand(x.shape[0], -1, -1) # 将分类标记和图像块嵌入拼接 x = torch.cat((cls_token, x), dim=1) # [B, 197, 768] # 加上位置嵌入并进行随机丢弃 x = self.pos_drop(x + self.pos_embed) ... # 返回分类标记对应的特征 return x[:, 0] def forward(self, x): # 提取输入图像的特征 x = self.forward_features(x) # 通过分类头 x = self.head(x) return x\",\"上面代码实现中使用的是可学习位置嵌入，具体解释如下:\",\"可学习位置嵌入（learnable positional embedding）是指位置嵌入的参数是可以在模型训练过程中通过反向传播算法进行更新的。具体来说，在模型初始化时，位置嵌入会被初始化为一组特定的值（通常是随机初始化或者初始化为零），然后在训练过程中，这些值会根据模型的损失函数不断调整，以使得模型能够学习到最适合当前任务的位置表示。\"]},\"321\":{\"h\":\"5. Encoder\",\"t\":[\"ViT虽然采用的是Transformer Encoder的结构，但是和Transformer原始的Encoder还是有所区别，我将两者的结构进行对比，如下图所示，左侧为Transformer原始的Encoder结构。\",\" 可以看到，大致上两者结构是相同的，主要区别在于Norm层的顺序，原始Transformer的Norm层在多头注意力和前馈网络之后，而ViT将其放到前面，这里的原因，论文里没有做解释。\",\"关于Norm层，ViT仍是采用Transformer中用到Layer Normalization，计算公式如下：\",\"Norm层之后同样是多头注意力层(Multi-Head Attention)，和Transformer中的一样。\",\"后面的MLP是个单独的结构，就是两个线性层+GELU激活函数+Dropout的结构 ：\",\" MLP Block 中第一个线性层把输入特征投影到一个更高维度的空间后，不同特征之间能够进行更多样的组合。这有助于模型发现输入数据中更复杂的模式和关系。第二个线性层再把高维特征映射回原来的维度，这样就可以提取出对最终任务有帮助的特征组合。\",\"单一的线性层只能进行线性变换，其表达能力是有限的。在两个线性层之间通常会插入一个非线性激活函数（如 GELU），这样就能让 MLP 学习到输入数据的非线性特征。第一个线性层将输入特征映射到更高维度的空间，在这个高维空间里，数据的分布更加稀疏，也就为非线性激活函数提供了更多可以学习的特征组合，从而增强了模型的表达能力。\",\"class Block(nn.Module): def __init__(self, dim, num_heads, mlp_ratio=4., qkv_bias=False, qk_scale=None, drop_ratio=0., attn_drop_ratio=0., drop_path_ratio=0., act_layer=nn.GELU, norm_layer=nn.LayerNorm): super(Block, self).__init__() # 第一个归一化层，对输入进行归一化处理 self.norm1 = norm_layer(dim) # 多头自注意力层 self.attn = Attention(dim, num_heads=num_heads, qkv_bias=qkv_bias, qk_scale=qk_scale, attn_drop_ratio=attn_drop_ratio, proj_drop_ratio=drop_ratio) # DropPath 层，用于随机深度，当 drop_path_ratio 大于 0 时使用，否则使用恒等映射 self.drop_path = DropPath(drop_path_ratio) if drop_path_ratio > 0. else nn.Identity() # 第二个归一化层，对经过注意力层的输出进行归一化处理 self.norm2 = norm_layer(dim) # 计算 MLP 的隐藏维度 mlp_hidden_dim = int(dim * mlp_ratio) # 创建 MLP 层 self.mlp = Mlp(in_features=dim, hidden_features=mlp_hidden_dim, act_layer=act_layer, drop=drop_ratio) def forward(self, x): # 残差连接：输入加上经过归一化和注意力层处理后的输出 x = x + self.drop_path(self.attn(self.norm1(x))) # 残差连接：输入加上经过归一化和 MLP 层处理后的输出 x = x + self.drop_path(self.mlp(self.norm2(x))) return x\",\"class Mlp(nn.Module): \\\"\\\"\\\" MLP as used in Vision Transformer, MLP-Mixer and related networks \\\"\\\"\\\" def __init__(self, in_features, hidden_features=None, out_features=None, act_layer=nn.GELU, drop=0.): super().__init__() # 如果未指定 out_features，则默认为 in_features out_features = out_features or in_features # 如果未指定 hidden_features，则默认为 in_features hidden_features = hidden_features or in_features # 第一个全连接层，将输入特征映射到隐藏特征空间 self.fc1 = nn.Linear(in_features, hidden_features) # 激活函数层，默认使用 GELU 激活函数 self.act = act_layer() # 第二个全连接层，将隐藏特征映射到输出特征空间 self.fc2 = nn.Linear(hidden_features, out_features) # Dropout 层，用于防止过拟合 self.drop = nn.Dropout(drop) def forward(self, x): # 通过第一个全连接层 x = self.fc1(x) # 通过激活函数层 x = self.act(x) # 应用 Dropout x = self.drop(x) # 通过第二个全连接层 x = self.fc2(x) # 再次应用 Dropout x = self.drop(x) return x\",\"一个block之后维度依然和输入相同，都是197 x 768 ，因此可以堆叠多个block。\"]},\"322\":{\"h\":\"6. 多头自注意力\",\"t\":[\"ViT中的多头自注意力模块实现逻辑和Transformer基本一致，主要的区别就是去掉了Paddding_Mask和Casual_Mask部分相关的掩码逻辑。\",\"下面所给出的代码实现，注意是通过一个线性层来同时计算qkv三个矩阵，这样可以提升计算效率。\",\"class Attention(nn.Module): def __init__(self, dim, # 嵌入层维度 num_heads=8, # 注意力头的数量，默认为8 qkv_bias=False, # 是否在生成Q、K、V时使用偏置，默认为False qk_scale=None, # 缩放因子，用于调整注意力分数，若为None则使用默认值 attn_drop_ratio=0., # 注意力矩阵的丢弃率，默认为0 proj_drop_ratio=0.): # 投影层的丢弃率，默认为0 super(Attention, self).__init__() self.num_heads = num_heads # 保存注意力头的数量 head_dim = dim // num_heads # 计算每个注意力头的维度 self.scale = qk_scale or head_dim ** -0.5 # 确定缩放因子，若qk_scale未指定，则使用默认的缩放因子 # 定义一个线性层，将输入的维度dim映射到dim * 3，用于同时生成查询（Q）、键（K）和值（V） self.qkv = nn.Linear(dim, dim * 3, bias=qkv_bias) # 定义注意力矩阵的丢弃层，防止过拟合 self.attn_drop = nn.Dropout(attn_drop_ratio) # 定义投影层，将多头注意力的输出进行线性变换 self.proj = nn.Linear(dim, dim) # 定义投影层的丢弃层，防止过拟合 self.proj_drop = nn.Dropout(proj_drop_ratio) # 没有padding_mask, casual_mask def forward(self, x): # [batch_size, num_patches + 1, total_embed_dim] # 获取输入张量x的形状，B为批量大小，N为序列长度（包含分类token），C为输入token的总维度 B, N, C = x.shape # qkv(): -> [batch_size, num_patches + 1, 3 * total_embed_dim] # reshape: -> [batch_size, num_patches + 1, 3, num_heads, embed_dim_per_head] # permute: -> [3, batch_size, num_heads, num_patches + 1, embed_dim_per_head] # 通过qkv线性层将输入x映射到dim * 3的维度，然后调整形状并重新排列维度 # 下面的3是因为我们用一次矩阵运算得到了拼接在一起的Q,K,V矩阵，这里需要将其分离开来 qkv = self.qkv(x).reshape(B, N, 3, self.num_heads, C // self.num_heads).permute(2, 0, 3, 1, 4) # [batch_size, num_heads, num_patches + 1, embed_dim_per_head] # 从qkv张量中分离出查询（Q）、键（K）和值（V） # 注意: Q,K,V计算来源相同,因此是自注意力 q, k, v = qkv[0], qkv[1], qkv[2] # make torchscript happy (cannot use tensor as tuple) # transpose: -> [batch_size, num_heads, embed_dim_per_head, num_patches + 1] # @: multiply -> [batch_size, num_heads, num_patches + 1, num_patches + 1] # 将Q和K的转置相乘，得到注意力分数矩阵，再乘以缩放因子scale attn = (q @ k.transpose(-2, -1)) * self.scale # 对注意力分数矩阵应用softmax函数，得到注意力权重矩阵 attn = attn.softmax(dim=-1) # 对注意力权重矩阵应用丢弃层，防止过拟合 attn = self.attn_drop(attn) # @: multiply -> [batch_size, num_heads, num_patches + 1, embed_dim_per_head] # transpose: -> [batch_size, num_patches + 1, num_heads, embed_dim_per_head] # reshape: -> [batch_size, num_patches + 1, total_embed_dim] # 将注意力权重矩阵与V相乘，得到每个注意力头的输出 # 对输出进行维度交换和形状调整，将多个注意力头的输出合并为一个张量 x = (attn @ v).transpose(1, 2).reshape(B, N, C) # 通过投影层对合并后的张量进行线性变换 x = self.proj(x) # 对投影后的结果应用丢弃层，防止过拟合 x = self.proj_drop(x) return x\",\"关于多头注意力机制流程不太清楚的，可以看这篇文章。\"]},\"323\":{\"h\":\"7. MLP Head\",\"t\":[\"在Transformer Encoder输出结果之后，需要再将第一个添加的Class Token提取出来，然后输入到MLP Head进行分类。在论文中，作者先是在ImageNet21K上进行预训练，MLP Head结构由Linear+tanh激活函数+Linear组成，但是迁移到其它数据集训练时，只需要用一个一个Linear即可。\",\"class VisionTransformer(nn.Module): def __init__(self, img_size=224, patch_size=16, in_c=3, num_classes=1000, embed_dim=768, depth=12, num_heads=12, mlp_ratio=4.0, qkv_bias=True, qk_scale=None, representation_size=None, drop_ratio=0., attn_drop_ratio=0., drop_path_ratio=0., embed_layer=None, norm_layer=None, act_layer=None): super(VisionTransformer, self).__init__() # 保存分类任务的类别数 self.num_classes = num_classes # 保存嵌入维度，同时作为特征数量，以保持与其他模型的一致性 self.num_features = self.embed_dim = embed_dim # 只有一个特殊标记（分类标记） self.num_tokens = 1 # 如果没有提供归一化层，则使用默认的 LayerNorm，epsilon 为 1e-6 norm_layer = norm_layer or partial(nn.LayerNorm, eps=1e-6) # 如果没有提供激活函数层，则使用 GELU 激活函数 act_layer = act_layer or nn.GELU # 创建图像块嵌入层 self.patch_embed = embed_layer(img_size=img_size, patch_size=patch_size, in_c=in_c, embed_dim=embed_dim) # 计算图像块的数量 num_patches = self.patch_embed.num_patches # 创建可学习的分类标记 self.cls_token = nn.Parameter(torch.zeros(1, 1, embed_dim)) # 创建可学习的位置嵌入 self.pos_embed = nn.Parameter(torch.zeros(1, num_patches + self.num_tokens, embed_dim)) # 创建丢弃层，用于位置嵌入后的随机丢弃 self.pos_drop = nn.Dropout(p=drop_ratio) # 创建Encoder Block块序列 self.blocks = nn.Sequential(*[ Block(dim=embed_dim, num_heads=num_heads, mlp_ratio=mlp_ratio, qkv_bias=qkv_bias, qk_scale=qk_scale, drop_ratio=drop_ratio, attn_drop_ratio=attn_drop_ratio, drop_path_ratio=dpr[i], norm_layer=norm_layer, act_layer=act_layer) for i in range(depth) ]) # 创建归一化层 self.norm = norm_layer(embed_dim) ############################# MLP Head ############################################ # 更新特征数量为表示层的维度 self.num_features = representation_size # 创建预输出层，包含一个线性层和一个 Tanh 激活函数 self.pre_logits = nn.Sequential(OrderedDict([ (\\\"fc\\\", nn.Linear(embed_dim, representation_size)), (\\\"act\\\", nn.Tanh()) ])) # 分类头 # 如果类别数大于 0，则创建线性分类头，否则为恒等映射 self.head = nn.Linear(self.num_features, num_classes) if num_classes > 0 else nn.Identity() ########################################################################### # 权重初始化 # 使用截断正态分布初始化位置嵌入 nn.init.trunc_normal_(self.pos_embed, std=0.02) # 使用截断正态分布初始化分类标记 nn.init.trunc_normal_(self.cls_token, std=0.02) # 应用自定义的权重初始化函数 self.apply(_init_vit_weights) def forward_features(self, x): # [B, C, H, W] -> [B, num_patches, embed_dim] # 将输入图像进行图像块嵌入 x = self.patch_embed(x) # [B, 196, 768] # [1, 1, 768] -> [B, 1, 768] # 扩展分类标记以匹配输入批次大小 cls_token = self.cls_token.expand(x.shape[0], -1, -1) # 将分类标记和图像块嵌入拼接 x = torch.cat((cls_token, x), dim=1) # [B, 197, 768] # 加上位置嵌入并进行随机丢弃 x = self.pos_drop(x + self.pos_embed) # 通过Encoder Block块序列 x = self.blocks(x) # 进行归一化 x = self.norm(x) # 返回分类标记对应的特征 -- 先交给预输出层进行处理 return self.pre_logits(x[:, 0]) def forward(self, x): # 提取输入图像的特征 x = self.forward_features(x) # 通过分类头 -- 映射到分类空间中去 x = self.head(x) return x\",\"self.pre_logits 模块可以看作是一个特征预处理模块，它位于最终分类头之前。通过将特征映射到特定的维度并进行非线性变换，该模块可以为后续的分类任务提供更具区分性和稳定性的特征表示，从而提高模型的分类性能。\",\"输出结果之后，再和真实标签做交叉熵损失，这样就可以完成ViT的训练过程。\",\"def train_one_epoch(model, optimizer, data_loader, device, epoch): ... # 遍历数据加载器中的每个批次数据 for step, data in enumerate(data_loader): # 解包数据，得到图像和对应的标签 images, labels = data # 累加当前批次的样本数到总样本数中 sample_num += images.shape[0] # 将图像数据移动到指定设备上，并通过模型进行前向传播，得到预测结果 pred = model(images.to(device)) # 从预测结果中找出每个样本预测概率最大的类别索引 pred_classes = torch.max(pred, dim=1)[1] # 计算预测正确的样本数，并累加到累计正确样本数中 accu_num += torch.eq(pred_classes, labels.to(device)).sum() # 计算预测结果与真实标签之间的交叉熵损失 loss = loss_function(pred, labels.to(device)) # 进行反向传播，计算梯度 loss.backward() ...\"]},\"324\":{\"h\":\"效果对比\",\"t\":[\"在论文中，作者将ViT和之前图像分类领域比较强的ResNet模型进行了对比测试，结果如下：\",\" 可以看到，右图中，作者使用了谷歌制作的JFT-300M数据集，当数据量小于30M时，ViT的效果表现不如ResNet，但是当数据量逐渐增大时，ViT才会慢慢超越ResNet。由此可见ViT工作的局限性，它必须要在超大数据集上进行预训练，然后再拿到其它数据集上做迁移学习，才会有好的效果。\",\"关于ViT模型的不同版本，论文里也做了说明： 其中的Layers就是Transformer Encoder中重复堆叠Encoder Block的次数，Hidden Size就是对应通过Embedding层后每个token的dim（向量的长度），MLP size是Transformer Encoder中MLP Block第一个全连接的节点个数（是Hidden Size的四倍），Heads代表Transformer中Multi-Head Attention的heads数。\",\"在深度学习领域，当提到模型参数量时，“M” 通常是 “million” 的缩写，代表 “百万”。所以参数量为 86M 就意味着模型大约有 86×1000000 = 8600000（八百六十万）个可训练参数。\",\"与之类似的还有 “B”，它是 “billion” 的缩写，代表 “十亿”。例如参数量为 1.2B 就表示模型大约有 1.2×1000000000 = 1200000000（十二亿）个可训练参数。\"]},\"325\":{\"h\":\"注意力可视化\",\"t\":[\"ViT这篇论文长达二十多页，里面包含了非常丰富的成果，其中包括注意力可视化。由于作者是首次将Transformer应用到图像领域，里面包含了注意力机制，那么作者就想把注意力得到的结果(也就是Q-K矩阵乘积)换源到图像上，得到结果如下图所示：\",\"可以看到，模型自动学习到了如果注意画面中的分类主体。\"]},\"326\":{\"h\":\"混合模型探索\",\"t\":[\"在论文的最后，作者又探索了一种混合模型(Hybrid)，就是将传统CNN和Transformer进行结合。\",\"下表中对比了ViT、ResNet和混合模型在不同图像分类数据集上的测试结果，可以看到当Epochs增大时，ResNet和混合模型的效果均不如ViT模型。\",\"混合模型的常见结合方式:\",\"CNN 作为特征提取器，Transformer 作为编码器 \",\"先用 CNN 对输入数据进行初步的特征提取，利用 CNN 的局部特征提取能力快速捕捉图像的底层特征。例如，在图像分类任务中，可以使用预训练的 ResNet 等 CNN 模型提取图像的特征图。\",\"然后将 CNN 提取的特征图转换为序列形式，输入到 Transformer 中进行进一步的处理。Transformer 可以利用其自注意力机制捕捉特征之间的长距离依赖关系，对特征进行更深入的建模。\",\"交错堆叠 CNN 和 Transformer 模块 \",\"在模型架构中，将 CNN 层和 Transformer 层交错堆叠。例如，先经过一层或多层 CNN 进行局部特征提取，然后再经过一层 Transformer 捕捉全局信息，如此反复。这样可以在模型的不同阶段交替利用 CNN 和 Transformer 的优势。\",\"在 Transformer 中引入卷积操作 \",\"在 Transformer 的架构中融入卷积操作，例如在多头自注意力机制或前馈网络中引入卷积层。这样可以为 Transformer 赋予局部特征提取的能力，同时保留其捕捉长距离依赖的优势。\"]},\"327\":{\"h\":\"加载预训练模型\",\"t\":[\"上面已经给出了数据集加载以及ViT模型核心代码实现了，下面我们将进入训练流程；首先说明，本次训练是基于预训练好的ViT-B/16这个模型进行微调，整体结构图如下：\",\"具体为vit_base_patch16_224_in21k这个模型:\",\"vit：代表 Vision Transformer。\",\"base：表示模型的规模。\",\"patch16：意味着在处理图像时，会将输入图像分割成大小为 16×16 像素的图像块（patches）。\",\"224：指的是输入图像的尺寸为 224×224 像素。在预训练和使用该模型时，需要将输入图像调整为这个固定的尺寸。\",\"in21k：该模型是在 ImageNet - 21k 数据集上进行预训练的。ImageNet - 21k 是一个大规模的图像数据集，包含大约 21000 个类别和 1.4 亿张图像。在如此大规模的数据集上进行预训练，模型能够学习到丰富的图像特征和模式，具有较强的泛化能力。\",\"def vit_base_patch16_224_in21k(num_classes: int = 21843, has_logits: bool = True): \\\"\\\"\\\" ViT-Base model (ViT-B/16) from original paper (https://arxiv.org/abs/2010.11929). ImageNet-21k weights @ 224x224, source https://github.com/google-research/vision_transformer. weights ported from official Google JAX impl: https://github.com/rwightman/pytorch-image-models/releases/download/v0.1-vitjx/jx_vit_base_patch16_224_in21k-e5005f0a.pth \\\"\\\"\\\" model = VisionTransformer(img_size=224, patch_size=16, embed_dim=768, depth=12, num_heads=12, representation_size=768 if has_logits else None, num_classes=num_classes) return model # 加载预训练好的vit_base_patch16_224_in21k模型权重文件 model = vit_base_patch16_224_in21k(num_classes=5, has_logits=False).to(device) weights_dict = torch.load(args.weights, map_location=device) model.load_state_dict(weights_dict, strict=False)\",\"加载该模型后，训练了10个epoch，验证集上准确率达到了98.5%。整体模型还是比较大的，预训练权重大小为393MB，但是训练速度还是挺快的，因为在代码中有个冻结权重的操作，主干部分全部冻结，仅训练分类头。\",\"for name, para in model.named_parameters(): # 除head, pre_logits外，其他权重全部冻结 if \\\"head\\\" not in name and \\\"pre_logits\\\" not in name: para.requires_grad_(False) else: print(\\\"training {}\\\".format(name))\",\"训练与评估流程的代码为模版代码，考虑篇幅原因，这里不再贴出，大家可以自行拉取项目完整代码进行学习:\",\"https://pan.baidu.com/s/1rkdjdlR37O7gSr9j1mhjBg?pwd=vket\"]},\"328\":{\"h\":\"总结\",\"t\":[\"Vision Transformer证明了使用Transformer结构可以有效处理图像数据，并且取得了与卷积神经网络（CNN）相媲美的效果。\",\"统一多模态的可能性：使用Transformer架构为未来的多模态统一提供了可能性。\",\"图像到文本的桥梁：架起了图像空间到文本空间的桥梁。\",\"ViT核心：如何将二维图像转换为一维时间序列？通过将图像切成小片（Patches），并按行优先排序来实现。\"]},\"329\":{\"h\":\"开源项目\"},\"330\":{\"h\":\"API记录之Numpy篇\",\"t\":[\"API记录之Numpy篇\"]},\"331\":{\"h\":\"Numpy\"},\"332\":{\"h\":\"np.linspace\",\"t\":[\"np.linspace 是 NumPy 中生成等间隔数列的函数。基本用法：\",\"import numpy as np # 在 0 到 1 之间生成 5 个等间隔数 arr = np.linspace(0, 1, 5) print(arr) # 输出: [0. 0.25 0.5 0.75 1. ]\",\"参数说明：\",\"start：起始值\",\"stop：结束值\",\"num：生成的样本数量（默认 50）\",\"endpoint：是否包含 stop（默认 True）\",\"retstep：是否返回步长（True 返回 (array, step)）\"]},\"333\":{\"h\":\"np.concatenate\",\"t\":[\"np.concatenate 用于沿指定轴将多个数组拼接在一起。\",\"import numpy as np a = np.array([1, 2]) b = np.array([3, 4]) # 沿默认轴（axis=0）拼接 c = np.concatenate([a, b]) print(c) # 输出: [1 2 3 4] # 对二维数组沿不同轴拼接 a2 = np.array([[1, 2], [3, 4]]) b2 = np.array([[5, 6], [7, 8]]) # 沿行拼接（axis=0） c2 = np.concatenate([a2, b2], axis=0) # [[1 2] # [3 4] # [5 6] # [7 8]] # 沿列拼接（axis=1） c3 = np.concatenate([a2, b2], axis=1) # [[1 2 5 6] # [3 4 7 8]]\"]},\"334\":{\"h\":\"API记录之Python篇\",\"t\":[\"API记录之Python篇\"]},\"335\":{\"h\":\"Python\"},\"336\":{\"h\":\"作用域\",\"t\":[\"Python 的作用域遵循 LEGB（Local → Enclosing → Global → Built-in） 原则。\",\"Local：函数或代码块内部定义的名字。\",\"Enclosing：外层函数的作用域。\",\"Global：模块文件的顶层作用域。\",\"Built-in：Python 内置命名空间。\",\"关键点是：\",\"➡️ Python 没有像 C/C++ 那样的“块级作用域”。\",\"也就是说，在 if、for、while 这些代码块里定义的变量，并不会限制在这个代码块内部，而是直接存在于函数作用域里。\",\"Python 代码块与作用域对照表:\",\"代码块类型\",\"示例\",\"是否产生新作用域？\",\"说明\",\"模块（module）\",\"一个 .py 文件\",\"✅\",\"文件顶层的名字都在模块作用域内（全局作用域）。\",\"函数定义（def / lambda）\",\"def f(): ...\",\"✅\",\"每次调用函数都会创建一个新的局部作用域（Local）。\",\"类定义（class）\",\"class A: ...\",\"✅\",\"类体代码在独立的命名空间里执行，成员存入类的属性字典。\",\"if / else / elif\",\"if cond: x = 1\",\"❌\",\"不产生新作用域，变量提升到所在函数/模块作用域。\",\"for / while\",\"for i in range(3): ...\",\"❌\",\"循环变量在循环体外仍然可见。\",\"try / except / finally\",\"try: ... except: ...\",\"❌\",\"不产生新作用域，里面的变量外面也能用。\",\"with\",\"with open(...) as f:\",\"❌\",\"不产生新作用域，f 在外面仍然可见。\",\"推导式 (Python 3.x)\",\"[x for x in range(5)]\",\"✅（局部作用域）\",\"列表/字典/集合/生成器推导式里的循环变量 只在推导式内部有效，不会泄漏到外部（Python 2 会泄漏）。\"]},\"337\":{\"h\":\"位置参数与关键字参数\",\"t\":[\"位置参数（Positional Argument）：按 位置顺序 传入函数的参数。\",\"关键字参数（Keyword Argument）：用 key=value 的形式明确指定的参数。\",\"场景\",\"位置参数 *\",\"关键字参数 **\",\"调用时\",\"解包 tuple/list\",\"解包 dict\",\"定义时\",\"收集成 tuple\",\"收集成 dict\"]},\"338\":{\"h\":\"闭包与高阶导数\"},\"339\":{\"h\":\"什么是高阶函数？\",\"t\":[\"高阶函数（Higher-Order Function）满足以下两个条件之一即可：\",\"函数接收另一个函数作为参数；\",\"函数返回一个函数。\",\"Python 中的 map、sorted、functools.partial 都是高阶函数。\",\"比如这个函数就是高阶函数：\",\"def outer(func): # 接收函数作为参数 def inner(): print(\\\"调用前\\\") func() print(\\\"调用后\\\") return inner # 返回一个函数\"]},\"340\":{\"h\":\"什么是闭包？\",\"t\":[\"闭包是一个函数，它“记住”了它定义时的 外部作用域变量，即使外部函数已经执行完毕，这些变量依然存在。\",\"例如：\",\"def outer(): x = 10 def inner(): print(x) # inner 记住了 x return inner f = outer() f() # 输出 10\",\"这里 inner 是一个闭包，因为它引用了 outer 中的变量 x，而 outer 已经返回了。\",\"正常情况下：局部变量会在函数执行完后被释放; 但如果我们在内部函数中引用了外部函数的变量，Python 会自动把这些变量“绑定”到这个内部函数上，也就是形成闭包, 变量“被引用”而不会释放。\"]},\"341\":{\"h\":\"装饰器的实现用到了什么？\",\"t\":[\"现在看一个典型的装饰器例子：\",\"def my_decorator(func): # ✅ 高阶函数（接收函数并返回函数） def wrapper(*args, **kwargs): # ✅ wrapper 是闭包（记住了 func） print(\\\"Before call\\\") result = func(*args, **kwargs) print(\\\"After call\\\") return result return wrapper @my_decorator def greet(name): print(f\\\"Hello, {name}\\\")\",\"my_decorator 是 高阶函数，因为它接收 func 并返回 wrapper。\",\"wrapper 是 闭包，因为它访问了其外部作用域的变量 func，并在被调用时依然保留这个引用。\",\"“装饰器 = 高阶函数 + 闭包” 的意思是：\",\"一个装饰器的实现，必须用高阶函数（来接收和返回函数），而在返回的内部函数中，依赖闭包机制来记住原函数的引用，从而实现对原函数行为的增强或修改。\"]},\"342\":{\"h\":\"装饰器\",\"t\":[\"装饰器是 Python 中的一种语法结构，本质是一个 函数（或类），它接收一个函数或类作为参数，对其进行加工，并返回一个新的函数或类对象。\",\"简而言之：\",\"装饰器 = 高阶函数 + 闭包\",\"装饰器主要用于在 不修改原始函数代码的前提下，动态增加其功能，这在日志记录、性能测试、权限校验等场景中非常常见。\"]},\"343\":{\"h\":\"最基本的函数装饰器\",\"t\":[\"def my_decorator(func): def wrapper(): print(\\\"调用前\\\") func() print(\\\"调用后\\\") return wrapper @my_decorator def say_hello(): print(\\\"Hello\\\") say_hello()\",\"输出：\",\"调用前 Hello 调用后\",\"说明：\",\"@my_decorator 相当于：say_hello = my_decorator(say_hello)\",\"wrapper() 是闭包，持有对 func 的引用。\",\"返回的 wrapper 函数替代了原来的 say_hello 函数。\"]},\"344\":{\"h\":\"带参数的函数装饰器\",\"t\":[\"装饰器支持原函数有参数的情况：\",\"def my_decorator(func): def wrapper(*args, **kwargs): print(\\\"开始\\\") result = func(*args, **kwargs) print(\\\"结束\\\") return result return wrapper @my_decorator def add(a, b): return a + b print(add(3, 5))\",\"使用 *args 和 **kwargs 是为了支持任意参数签名。\"]},\"345\":{\"h\":\"带参数的装饰器（装饰器工厂）\",\"t\":[\"如果你希望装饰器 本身接受参数，则需要再多一层函数嵌套：\",\"def log(prefix): def decorator(func): def wrapper(*args, **kwargs): print(f\\\"{prefix} 开始调用 {func.__name__}\\\") result = func(*args, **kwargs) print(f\\\"{prefix} 结束调用 {func.__name__}\\\") return result return wrapper return decorator @log(\\\"DEBUG\\\") def multiply(a, b): return a * b\",\"执行顺序：\",\"@log(\\\"DEBUG\\\") 先返回 decorator\",\"然后 decorator(multiply) 返回 wrapper\"]},\"346\":{\"h\":\"使用 保留原函数元信息\",\"t\":[\"装饰器会改变函数的元信息:\",\"def my_decorator(func): def wrapper(*args, **kwargs): print(\\\"Before call\\\") return func(*args, **kwargs) return wrapper @my_decorator def greet(name): \\\"\\\"\\\"Say hello to someone\\\"\\\"\\\" print(f\\\"Hello, {name}\\\") print(greet.__name__) # ⚠️ 输出 wrapper，不是 greet print(greet.__doc__) # ⚠️ 输出 None，不是函数原文档\",\"@my_decorator 返回的是 wrapper 函数，所以 greet 实际上变成了 wrapper，它的名字和文档字符串也被覆盖了，所以使用装饰器会导致原函数的 __name__、__doc__ 等属性丢失。\",\"Python 提供了 functools.wraps(func) 装饰器，作用是：\",\"把原函数的 __name__、__doc__、__module__ 等元信息“复制”到 wrapper 函数上，让被装饰函数看起来仍然像原来的函数。\",\"import functools def my_decorator(func): @functools.wraps(func) # ✅ 这一步很关键 def wrapper(*args, **kwargs): print(\\\"Before call\\\") return func(*args, **kwargs) return wrapper @my_decorator def greet(name): \\\"\\\"\\\"Say hello to someone\\\"\\\"\\\" print(f\\\"Hello, {name}\\\") print(greet.__name__) # ✅ greet print(greet.__doc__) # ✅ Say hello to someone\",\"这在调试、文档生成、类型检查、元编程、反射中都非常重要。例如：\",\"help(greet)：没有 wraps 就看不到真实文档了\",\"使用 inspect 模块查看参数、注解、类型签名会失效\",\"多个装饰器嵌套时更容易出错\"]},\"347\":{\"h\":\"装饰类方法（普通方法 / 类方法 / 静态方法）\",\"t\":[\"def log_method(func): @wraps(func) def wrapper(*args, **kwargs): print(f\\\"调用方法 {func.__name__}\\\") return func(*args, **kwargs) return wrapper class MyClass: @log_method def hello(self): print(\\\"Hello from method\\\")\"]},\"348\":{\"h\":\"装饰整个类\",\"t\":[\"def decorate_class(cls): cls.version = \\\"1.0\\\" return cls @decorate_class class MyService: pass print(MyService.version) # 1.0\"]},\"349\":{\"h\":\"装饰器的底层原理与执行过程\",\"t\":[\"本质：装饰器 = 函数替换器\",\"一个装饰器：\",\"@decorator def func(): pass\",\"等价于：\",\"func = decorator(func)\",\"即：把 func 传给 decorator 函数，并用它的返回值替换 func 本身。\"]},\"350\":{\"h\":\"多个装饰器叠加时的执行顺序（从内到外）\",\"t\":[\"@d1 @d2 def func(): pass\",\"等价于：\",\"func = d1(d2(func))\",\"即，先应用最内层的 d2，再由外层 d1 包裹起来。\"]},\"351\":{\"h\":\"类装饰器\",\"t\":[\"类装饰器通常通过实现 __call__ 方法来模拟函数行为：\",\"class MyDecorator: def __init__(self, func): self.func = func def __call__(self, *args, **kwargs): print(\\\"调用前\\\") result = self.func(*args, **kwargs) print(\\\"调用后\\\") return result @MyDecorator def greet(name): print(f\\\"Hi, {name}\\\") greet(\\\"Alice\\\")\"]},\"352\":{\"h\":\"总结\",\"t\":[\"类型\",\"例子\",\"含义\",\"最基本装饰器\",\"@func\",\"f = func(f)\",\"装饰器工厂\",\"@decorator(x)\",\"f = decorator(x)(f)\",\"对象方法装饰器\",\"@obj.method\",\"f = obj.method(f)\",\"对象方法工厂\",\"@obj.method(args)\",\"f = obj.method(args)(f)\"]},\"353\":{\"h\":\"典型应用场景举例\",\"t\":[\"日志记录：\",\"def log(func): @wraps(func) def wrapper(*args, **kwargs): print(f\\\"调用 {func.__name__} 参数: {args}, {kwargs}\\\") return func(*args, **kwargs) return wrapper\",\"权限控制：\",\"def require_admin(func): @wraps(func) def wrapper(*args, **kwargs): if not user_is_admin(): raise PermissionError(\\\"需要管理员权限\\\") return func(*args, **kwargs) return wrapper\",\"性能测试（统计函数运行时间）：\",\"import time def timing(func): @wraps(func) def wrapper(*args, **kwargs): start = time.time() result = func(*args, **kwargs) print(f\\\"{func.__name__} 耗时: {time.time() - start:.4f}s\\\") return result return wrapper\"]},\"354\":{\"h\":\"地板除 “//”\",\"t\":[\"// 是 地板除（floor division） 运算符，表示向下取整的除法。\",\"表达式\",\"结果\",\"类型\",\"7 / 3\",\"2.333...\",\"float\",\"7 // 3\",\"2\",\"int\"]},\"355\":{\"h\":\"Ellipsis (...)\",\"t\":[\"Ellipsis（用 ... 表示）是 Python 中的语法，用于表示 多维索引中的省略维度。在多维数组或张量索引时，... 可以代替多个冒号 :，表示选择剩余所有维度。\",\"示例：\",\"import torch x = torch.randn(2, 3, 4, 5) # 取第 0 维第 1 个元素，后面所有维度都选中 y = x[1, ...] # 等价于 x[1, :, :, :] print(y.shape) # torch.Size([3, 4, 5]) # 在最后加维度 z = x[..., None] # shape: [2, 3, 4, 5, 1]\",\"总结：... 用于 简化多维索引 或 保留剩余维度。\"]},\"356\":{\"h\":\"API记录之Pytorch篇\",\"t\":[\"API记录之Pytorch篇\"]},\"357\":{\"h\":\"Pytorch\"},\"358\":{\"h\":\"stack\",\"t\":[\"torch.stack() 是 PyTorch 中用于将多个形状相同的张量沿一个新维度拼接的函数。\",\"torch.stack(tensors, dim=0, *, out=None)\",\"tensors：一个可迭代对象（如列表、元组），其中包含多个形状相同的 Tensor。\",\"dim：插入新维度的位置（默认是 0）。这个新维度就是拼接的那一维。\",\"out：可选输出张量，用于写入结果。\",\"例子如下:\",\"注意:\",\"所有张量必须具有完全相同的 shape。\",\"如果你想把一个 batch 中的多个样本打包成一个大 tensor，通常会用 torch.stack()。\"]},\"359\":{\"h\":\"transpose\",\"t\":[\"y = x.transpose(dim0, dim1)\",\"只交换两个指定维度，常用于 2D 或 3D 张量，如图像转置、RNN 输入调整等。\"]},\"360\":{\"h\":\"permute\",\"t\":[\"y = x.permute(dims)\",\"可以任意重新排列所有维度，是 transpose 的泛化，支持多维度同时交换。\",\"transpose() 和 permute() 返回的张量虽然是视图（view），但它们的 内存布局（strides）被改变。如果你接下来要对它们执行 .view() 或某些要求内存连续的操作，就必须先调用 .contiguous()。\",\"执行 transpose(0, 2) 后:\"]},\"361\":{\"h\":\"view\",\"t\":[\"view: 在不复制数据的前提下，返回具有新形状（shape）的张量视图（view）。\",\"new_tensor = x.view(shape)\",\".view() 只适用于连续内存的张量，某些操作（如 permute, transpose）会改变张量的 stride（内存步长），使其变得 非连续。此时必须先 .contiguous() 再 .view()：\",\"x = torch.randn(2, 3, 4) y = x.permute(0, 2, 1) # 改变维度顺序 z = y.contiguous().view(2, -1) # 否则可能报错\",\".view() 不会复制数据，是原张量的一个视图（共享内存）\"]},\"362\":{\"h\":\"reshape\",\"t\":[\"reshape: 返回具有新形状的张量。必要时会复制数据，否则返回视图。 相比 .view()，reshape() 不要求原始张量是连续的，这是它最大的优势。\",\"new_tensor = x.reshape(shape)\",\"在 PyTorch 中，reshape() 在多数情况下会返回原张量的视图（不复制数据），但当张量的内存布局不连续（例如经过了 permute()、transpose() 等操作），或新形状无法与原内存布局兼容时，reshape() 就会进行数据复制以创建新的张量。此外，如果张量来源于 expand()（广播视图），或者跨设备/特殊操作后的中间结果，也可能触发复制。因此，若希望确保内存效率，建议在 reshape 前使用 .is_contiguous() 检查，必要时用 .contiguous() 转为连续张量。\"]},\"363\":{\"h\":\"repeat\",\"t\":[\"tensor.repeat() 是 PyTorch 中用于沿指定维度重复张量内容的操作，它会复制数据，从而扩展张量的形状（不是视图）。\",\"repeated_tensor = x.repeat(repeat_1, repeat_2, ..., repeat_n)\",\"参数个数必须和 x 的维度数相同。\",\"每个 repeat_i 表示该维度上复制的次数。\",\"import torch x = torch.tensor([[1, 2], [3, 4]]) x = x.repeat(2,3) print(x) output: tensor([[1, 2, 1, 2, 1, 2], [3, 4, 3, 4, 3, 4], [1, 2, 1, 2, 1, 2], [3, 4, 3, 4, 3, 4]])\"]},\"364\":{\"h\":\"expand\",\"t\":[\"tensor.expand() 是 PyTorch 中用于扩展张量尺寸但不复制数据的一种高效方法，它通过广播（broadcasting）机制生成新的视图，节省内存。\",\"expanded_tensor = x.expand(size_1, size_2, ..., size_n)\",\"参数个数必须和 x.dim() 相同，或可以通过在前面添加维度来自动广播。\",\"某一维如果是 -1，表示保持原来的大小。\",\"x = torch.tensor([[1], [2], [3]]) # shape: [3, 1] x.expand(3, 4) # → 每行复制 4 次，但不占用额外内存 # tensor([[1, 1, 1, 1], # [2, 2, 2, 2], # [3, 3, 3, 3]])\",\"使用 -1 保留维度：\",\"x = torch.randn(3, 1, 5) # shape: [3, 1, 5] x.expand(-1, 4, -1) # shape → [3, 4, 5]\",\"核心原则：只有原始维度 = 1 的位置，才能通过 expand 变大；其他位置必须 相等。\",\"x = torch.tensor([[1, 2, 3]]) # shape: [1, 3] y = x.expand(2, 3) # ✅ 第 0 维是 1 → 可以扩展成 2 # ❌ 第 1 维是 3 → 目标仍是 3，虽然没变，但也不能写成 6！ x.expand(2, 6) # ❌ 报错！因为第 1 维是 3，不能变成 6\",\"特性\",\".expand()\",\".repeat()\",\"是否复制数据\",\"❌ 否（返回视图，节省内存）\",\"✅ 是（创建新张量，开销大）\",\"是否支持广播\",\"✅ 支持（自动按维度扩展）\",\"❌ 不支持，必须精确指定每维重复次数\",\"是否可用于改变维度\",\"❌ 否（维度必须兼容）\",\"✅ 是\",\"常用于\",\"高效广播，如 attention、masking 等\",\"实际复制，如构造重复输入\"]},\"365\":{\"h\":\"@torch.no_grad()\",\"t\":[\"在这个装饰器修饰的函数内，PyTorch 不会跟踪计算图，也不会计算梯度。\",\"这样可以减少内存使用和计算开销，因为不需要保存中间变量用于反向传播。\",\"适用于只需要前向推理且不需要更新模型参数的场景。\"]},\"366\":{\"h\":\"register_buffer\",\"t\":[\"# nn.Module 类中提供的方法 register_buffer(name: str, tensor: Optional[torch.Tensor], persistent: bool = True)\",\"name (str)\",\"缓冲区的名称（字符串）。\",\"之后可以用 model.name 访问，比如 model.queue。\",\"tensor (torch.Tensor 或 None)\",\"要注册的张量。\",\"这个张量会成为模型的一个成员，但不会被视为可训练参数。\",\"也可以传 None，表示先占位，后面再赋值。\",\"persistent (bool，默认 True，PyTorch 1.8以后支持)\",\"如果为 True，该缓冲区会包含在 state_dict() 中，即会被保存和加载。\",\"如果为 False，缓冲区不会保存到 state_dict()，常用于临时缓存数据。\",\"register_buffer的作用和意义：\",\"它会把一个张量（tensor）作为模型的缓冲区注册，不会被当作模型的可训练参数（不会出现在model.parameters()里，也不会参与梯度计算或优化）。\",\"但是，缓冲区会被自动保存到模型的状态字典（state_dict）中，也会被加载（load）和保存（save）。\",\"常用于保存一些模型的状态信息，但这些信息不需要训练，比如：均值、方差、队列、掩码等。\"]},\"367\":{\"h\":\"einsum\",\"t\":[\"einsum 是 爱因斯坦求和约定（Einstein Summation） 的简写，是一个非常强大且直观的张量操作工具。\",\"相比 matmul、bmm、torch.matmul 这类 API，einsum 让你显式指定维度之间怎么相乘/求和/保留。\",\"torch.einsum(\\\"维度规则\\\", [tensor1, tensor2, ...])\",\"引号中是 对每个 tensor 的维度命名\",\"相同的维度字母表示要做 点积/求和\",\"没有重复的维度字母表示保留该维度\",\"einsum 表达式\",\"等价操作\",\"输出形状\",\"含义\",\"\\\"nc,nc->n\\\"\",\"(q * k).sum(dim=1)\",\"(N,)\",\"每个 query 与其正样本的点积\",\"\\\"nc,ck->nk\\\"\",\"torch.matmul(q, queue)\",\"(N, K)\",\"每个 query 与所有负样本的相似度\"]},\"368\":{\"h\":\"where\",\"t\":[\"torch.where(condition, x, y)\",\"condition：一个布尔型张量，用来判断条件是否成立。\",\"返回一个新张量：\",\"当 condition 对应位置为 True 时，取 x 中对应位置的元素；\",\"当 condition 对应位置为 False 时，取 y 中对应位置的元素。\"]},\"369\":{\"h\":\"torch.nn.functional.pad\",\"t\":[\"text = F.pad(text, (1, 0), value=0)\",\"text：待填充的张量，比如形状是 (batch_size, seq_len)。\",\"(1, 0)：指定填充的方式，这里是一个长度为2的元组 (padding_left, padding_right)，表示在最后一个维度的左侧填充1个元素，右侧填充0个元素。\",\"value=0：用来填充的数值，这里是用0填充。\",\" x = torch.tensor([1, 2, 3, 4, 5]) print(\\\"Original tensor:\\\", x) # 在最后一个维度左边填充1个0，右边不填充 padded_1 = F.pad(x, (1, 0), value=0) print(\\\"Pad (1, 0):\\\", padded_1) # 在最后一个维度左边不填充，右边填充2个9 padded_2 = F.pad(x, (0, 2), value=9) print(\\\"Pad (0, 2) with 9:\\\", padded_2) # 在最后一个维度两边各填充2个-1 padded_3 = F.pad(x, (2, 2), value=-1) print(\\\"Pad (2, 2) with -1:\\\", padded_3)\",\"output:\",\"Original tensor: tensor([1, 2, 3, 4, 5]) Pad (1, 0): tensor([0, 1, 2, 3, 4, 5]) Pad (0, 2) with 9: tensor([1, 2, 3, 4, 5, 9, 9]) Pad (2, 2) with -1: tensor([-1, -1, 1, 2, 3, 4, 5, -1, -1])\"]},\"370\":{\"h\":\"rearrange\",\"t\":[\"rearrange 是一个来自 einops（Einstein Operations）库的函数，用于对张量（Tensor）进行灵活、直观的重排、维度变换、转置、扩展等操作。\",\"from einops import rearrange output = rearrange(tensor, pattern)\",\"tensor 是输入张量。\",\"pattern 是一个字符串，描述输入和输出维度的对应关系，类似模式匹配。\",\"rearrange(x, 'b c h w -> b h w c') # 交换维度顺序 x = torch.randn(4) # shape (4,) y = rearrange(x, 'b -> b 1') # 变成 (4,1)，增加一个维度 x = torch.randn(2, 3, 4) y = rearrange(x, 'b c d -> b (c d)') # 把c和d合并成一个维度 x = torch.randn(2, 12) y = rearrange(x, 'b (c d) -> b c d', c=3) # 把12拆分成3和4\"]},\"371\":{\"h\":\"Tensor.uniform_\",\"t\":[\"Tensor.uniform_(from=0, to=1)\",\"把一个 已有的张量，用 均匀分布随机数填充。\",\"生成的值在 [from, to) 范围内，默认是 [0, 1)。\",\"加上 _ 说明是原地修改：直接在原张量上进行操作，不创建新张量。\"]},\"372\":{\"h\":\"torch.unique_consecutive\",\"t\":[\"作用：返回输入张量中 连续不重复的元素，类似于 NumPy 的 np.unique，但它只去掉 相邻重复值，而不是全局去重。\",\"torch.unique_consecutive( input, return_inverse=False, return_counts=False, dim=None ) -> (Tensor, Optional[Tensor], Optional[Tensor])\",\"input：输入张量。\",\"return_inverse：如果为 True，会额外返回一个张量，表示每个元素在唯一值张量中的索引。\",\"return_counts：如果为 True，会额外返回每个唯一值的 连续出现次数。\",\"dim：指定操作的维度。如果为 None，默认会展平为 1D 处理。\",\"示例1:\",\"import torch x = torch.tensor([1, 1, 2, 2, 3, 1, 1]) out = torch.unique_consecutive(x) print(out) # tensor([1, 2, 3, 1])\",\"这里没有去掉最后那个 1，因为它和前面的 3 不相邻。\",\"示例2：返回计数:\",\"out, counts = torch.unique_consecutive(x, return_counts=True) print(out) # tensor([1, 2, 3, 1]) print(counts) # tensor([2, 2, 1, 2])\",\"示例3: 返回反向索引:\",\"out, inverse = torch.unique_consecutive(x, return_inverse=True) print(out) # tensor([1, 2, 3, 1]) print(inverse) # tensor([0, 0, 1, 1, 2, 3, 3])\",\"示例4: 指定维度:\",\"x = torch.tensor([[1, 1, 2], [1, 2, 2], [3, 3, 3]]) out = torch.unique_consecutive(x, dim=0) print(out) # tensor([[1, 1, 2], # [1, 2, 2], # [3, 3, 3]])\",\"这里按 行 去重，只要相邻两行完全相同就会合并。\"]},\"373\":{\"h\":\"torch.cumsum\",\"t\":[\"作用：对张量沿指定维度做 累加求和（cumulative sum），返回一个新的张量。\",\"torch.cumsum(input, dim, *, dtype=None, out=None) -> Tensor\",\"input: 输入张量\",\"dim: 沿着哪个维度计算累积和\",\"dtype: 指定输出数据类型（可选），如果不指定就保持输入 dtype\",\"out: 输出张量（可选）\",\"返回值: 返回一个和 input 形状相同的张量，元素是按 dim 累加后的值。\",\"示例1: 一维张量\",\"import torch x = torch.tensor([1, 2, 3, 4]) y = torch.cumsum(x, dim=0) print(y) # tensor([ 1, 3, 6, 10])\",\"示例2: 二维张量\",\"x = torch.tensor([[1, 2, 3], [4, 5, 6]]) y = torch.cumsum(x, dim=0) # 沿着行方向 print(y) # tensor([[ 1, 2, 3], # [ 5, 7, 9]])\"]},\"374\":{\"h\":\"torch.Tensor 的 chunk 方法\",\"t\":[\"作用: 用于将张量沿指定维度 分块，基本用法如下：\",\"import torch x = torch.arange(8) # [0,1,2,3,4,5,6,7] # 将张量沿 dim=0 平均分成 4 块 chunks = x.chunk(4, dim=0) for c in chunks: print(c)\",\"输出：\",\"tensor([0, 1]) tensor([2, 3]) tensor([4, 5]) tensor([6, 7])\",\"参数说明:\",\"chunks：要分成的块数\",\"dim：沿哪个维度分块，默认 dim=0\",\"返回值：一个 tuple，包含切分后的张量块\",\"如果张量不能整除块数，前几个块会比后面的多一个元素。\",\"返回的是 tuple 而不是 list。\",\"举个二维例子：\",\"x = torch.arange(16).view(4, 4) chunks = x.chunk(2, dim=0) # 按行分成2块 for c in chunks: print(c)\",\"输出：\",\"tensor([[0, 1, 2, 3], [4, 5, 6, 7]]) tensor([[ 8, 9, 10, 11], [12, 13, 14, 15]])\"]},\"375\":{\"h\":\"torch.randperm\",\"t\":[\"torch.randperm(n) 返回一个长度为 n 的一维张量，包含 0 ~ n-1 的整数，顺序被随机打乱。常用于随机打乱索引，例如：\",\"idx = torch.randperm(5) # 可能输出: tensor([3, 0, 4, 1, 2])\"]},\"376\":{\"h\":\"torch.randint\",\"t\":[\"torch.randint(low, high, size) 返回在 [low, high) 区间内随机生成整数的张量，形状由 size 指定。示例：\",\"x = torch.randint(0, 10, (3, 2)) # 可能输出: tensor([[7, 1], # [3, 9], # [0, 4]])\"]},\"377\":{\"h\":\"torch.bincount\",\"t\":[\"torch.bincount(input, weights=None, minlength=0) 用于统计 非负整数张量input 中每个整数出现的次数，返回一个一维张量。\",\"参数:\",\"input：非负整数张量，一维。\",\"weights（可选）：与 input 同长度的浮点张量，用于加权计数。\",\"minlength（可选）：输出张量的最小长度，如果统计结果长度小于 minlength，在末尾补 0。\",\"返回值:\",\"一维张量 counts，counts[i] 表示整数 i 在 input 中的出现次数（或加权和，如果指定 weights）。\",\"例如:\",\"普通计数：\",\"x = torch.tensor([0, 1, 1, 3]) torch.bincount(x) # 输出: tensor([1, 2, 0, 1])\",\"加权计数：\",\"x = torch.tensor([0, 1, 1, 3]) w = torch.tensor([0.5, 1.0, 2.0, 1.5]) torch.bincount(x, weights=w) # 输出: tensor([0.5, 3.0, 0.0, 1.5])\",\"指定最小长度：\",\"x = torch.tensor([0, 1, 1]) torch.bincount(x, minlength=5) # 输出: tensor([1, 2, 0, 0, 0])\"]},\"378\":{\"h\":\"Tensor.new_zeros\",\"t\":[\"Tensor.new_zeros(*size, dtype=None, device=None) 是 PyTorch 的一个 张量创建方法，它根据已有张量的属性创建一个全零张量。\",\"作用:\",\"生成形状为 size 的全零张量。\",\"张量会和调用它的原张量 在同一设备上（CPU/GPU），并且默认继承原张量的数据类型，除非通过 dtype 指定。\",\"例子:\",\"x = torch.randn(3, 4, device='cuda') # 原张量在 GPU y = x.new_zeros(2, 5) # 在 GPU 上创建 2x5 的全零张量 print(y.device) # 输出: cuda:0\"]},\"379\":{\"h\":\"tensor.scatter_add_\",\"t\":[\"tensor.scatter_add_(dim, index, src)\",\"dim：指定沿哪一维累加。\",\"0 表示按行累加（不同样本累加到不同的簇行）。\",\"1 表示按列累加（按列索引累加元素）。\",\"index：与 src 同形状的整数张量，表示 src 中的每个元素要加到目标张量的哪个位置。\",\"如果 dim=0，index[i,j] 表示 src[i,j] 要加到 tensor[index[i,j], j]。\",\"如果 dim=1，index[i,j] 表示 src[i,j] 要加到 tensor[i, index[i,j]]。\"]},\"380\":{\"h\":\"API记录之杂类篇\",\"t\":[\"API记录之杂类篇\"]},\"381\":{\"h\":\"模型\"},\"382\":{\"h\":\"ResNet18\",\"t\":[\"ResNet18是一种深度残差网络，它由18层组成。它的结构包括一个输入层、四个残差块和一个输出层。每个残差块包含两个3x3的卷积层，每个卷积层后面都跟着一个Batch Normalization和ReLU激活函数。此外，每个残差块还包含一条跨层的连接线，将输入直接连接到输出。这种设计使得网络能够更好地处理深层特征，并且可以避免梯度消失问题。ResNet18在图像分类任务中表现出色，可以用于训练大型数据集，如ImageNet。\"]},\"383\":{\"h\":\"Bert\",\"t\":[\"pooler_output 的输出用于捕获整个句子的全局语义信息:\"]},\"384\":{\"h\":\"公式&定理\"},\"385\":{\"h\":\"通用近似定理\",\"t\":[\"以下内容来自: << 神经网络与深度学习 >> 4.3.1 通用近似定理\",\"根据通用近似定理，对于具有线性输出层和至少一个使用“挤压”性质的激活函数的隐藏层组成的前馈神经网络，只要其隐藏层神经元的数量足够，它可以以任意的精度来近似任何一个定义在实数空间中的有界闭集函数．所谓“挤压”性质的函数是指像Sigmoid函数的有界函数，但神经网络的通用近似性质也被证明对于其他类型的激活函数，比如ReLU，也都是适用的．\",\"个人对上述内容的理解\",\"通用近似定理中“隐藏层神经元的数量足够”这一条件，与多项式逼近（如泰勒展开）中 '增加阶数提高精度' 的思想有深刻的相似性，但神经网络的非线性基函数组合比传统多项式逼近更灵活。以下是具体分析：\",\"逼近方式\",\"多项式逼近（泰勒展开）\",\"神经网络逼近\",\"基函数\",\"单项式基 \",\"非线性激活后的基 \",\"组合方式\",\"线性加权和 \",\"线性加权和 \",\"逼近原理\",\"增加阶数 提高精度\",\"增加神经元数量 提高精度\",\"函数空间\",\"多项式函数空间\",\"自适应生成的非线性函数空间\",\"关键共同点：\",\"两者都通过增加基函数的数量（多项式阶数/神经元数量）来扩大逼近空间的容量，从而提升对目标函数的拟合精度。\",\"神经网络的独特优势:\",\"自适应基函数\",\"多项式逼近的基函数是固定的（如 ），而神经网络的基函数 的形状和位置（由权重 决定）可通过训练动态调整，更灵活适应目标函数。\",\"示例：拟合分段函数时，ReLU神经元可自动学习“转折点”，而多项式需极高阶数才能近似突变。\",\"维度诅咒的缓解\",\"在高维空间（）中，多项式逼近需要 项（指数增长），而神经网络通过非线性激活和分层结构，可能以 神经元实现相同精度。\",\"对非平滑函数的适应性\",\"泰勒展开要求函数无限可微，而神经网络（如使用ReLU）可逼近连续但不可微的函数（如 ）。\",\"案例：逼近区间 上的 \",\"多项式逼近: 需高阶泰勒展开 ，且高次项易导致震荡（龙格现象）。\",\"神经网络逼近: 仅需4个Tanh神经元即可高精度拟合，因基函数 能自适应频率和相位。\",\"理论限制的相似性:\",\"逼近精度与代价的权衡\",\"多项式：高阶项导致数值不稳定（如大数相减损失精度）。\",\"神经网络：神经元过多易过拟合，且训练难度增加（梯度消失/爆炸）。\",\"全局逼近 vs 局部逼近\",\"多项式：调整某一系数会影响全局拟合。\",\"神经网络：可通过局部神经元（如ReLU）实现分段逼近，更适应局部特征。\",\"现代深度学习的延伸: 深层神经网络通过函数复合（Function Composition）能够以指数级减少所需的神经元数量，核心原因在于层次化的函数构造方式比单层网络的线性组合更高效。这与多项式逼近等传统方法有本质区别，具体可以从以下几个方面理解：\",\"1. 函数复合 vs. 线性组合：数学本质对比\",\"单层网络（线性组合）：\",\"单隐藏层神经网络的输出形式为：\",\"它通过一组非线性基函数（(\\\\sigma)）的加权和逼近目标函数，类似于多项式逼近中的基函数组合。要逼近复杂函数，可能需要大量神经元（(N) 极大）。\",\"深层网络（函数复合）：\",\" 层网络的输出是多次复合的结果：\",\"每一层 都是一个非线性变换（如 ）。通过逐层抽象，深层网络可以逐步构造出更复杂的函数。\",\"关键区别：\",\"单层网络依赖基函数的数量（宽度）来增加表达能力。\",\"深层网络依赖函数的嵌套深度，通过分层组合简单函数，实现复杂功能。\",\"2. 为什么函数复合更高效？\",\"(1) 分治策略（Divide-and-Conquer）\",\"深层网络将复杂函数分解为多个简单步骤，每一层只需学习局部特征，最后组合成全局解。例如：\",\"目标函数：拟合一个“锯齿波”\",\"单层网络：需要大量神经元构造多个“转折点”。\",\"深层网络：每层学习一个转折点，通过复合实现指数级增长的分段线性区域（如 层ReLU网络可生成 个分段）。\",\"(2) 指数级表达能力\",\"理论结果：\",\"Telgarsky (2016) 证明：用深度 的ReLU网络可以构造具有 个线性区域的函数，而单层网络需要 个神经元才能达到相同效果。\",\"直观理解：每一层的非线性变换（如ReLU）相当于对输入空间进行一次“折叠”，深度叠加导致表达能力爆炸式增长。\",\"网络类型\",\"所需神经元/层数\",\"表达能力增长方式\",\"单层宽网络\",\" 神经元\",\"线性增长（基函数叠加）\",\"深层网络\",\" 层，每层 神经元\",\"指数增长（函数复合）\",\"(3) 参数复用与模块化\",\"深层网络通过共享参数（如卷积核）和模块化设计（如残差块），进一步减少冗余：\",\"示例：CNN中，同一卷积核在不同位置重复使用，避免为每个像素单独建模。\",\"3. 与多项式逼近的对比\",\"多项式逼近通过增加阶数（如泰勒展开）提升精度，但存在两大局限：\",\"全局性：调整某一系数会影响整个函数，难以局部修正。\",\"维度灾难：高维输入时，多项式项数 爆炸式增长。\",\"而神经网络的函数复合：\",\"局部性：每层聚焦不同抽象层次（如边缘→纹理→物体）。\",\"维度友好：通过分层降维（如池化）逐步压缩信息。\",\"4. 实例说明\",\"案例1：逼近“多次折叠”的函数\",\"目标函数：\",\"单层网络：需数百个神经元拟合嵌套正弦波。\",\"深层网络：3层即可，每层对应一个 操作。\",\"案例2：图像分类\",\"单层网络：需直接建模像素到类别的复杂映射，参数量极大。\",\"深层CNN：逐层提取边缘→纹理→部件→物体，参数量更少。\",\"5. 理论支持\",\"深度分离定理（Depth Separation Theorem）: 存在某些函数，用浅层网络逼近需要指数级神经元，而深层网络只需多项式数量（如 Eldan & Shamir, 2016）。\",\"电路理论类比: 深层网络类似布尔电路中的分层设计（如AND-OR门组合），比单层电路更高效。\",\"6. 深层网络的代价\",\"虽然深度减少了神经元数量，但带来了：\",\"优化难度：梯度消失/爆炸问题。\",\"过拟合风险：需正则化（如Dropout）。\",\"计算开销：并行化要求更高。\",\"总结:\",\"神经网络通过非线性激活函数生成的动态基函数组合，实现了比多项式逼近更高效的函数近似。虽然“增加神经元数量”与“提高多项式阶数”在思想上都体现了用更多自由度提升精度，但神经网络的自适应基函数和分层结构使其：\",\"对高维和非平滑函数更鲁棒\",\"避免了手工设计基函数的局限性\",\"在实践中通过梯度下降自动学习逼近策略\"]},\"386\":{\"h\":\"ROI Pooling\",\"t\":[\"在目标检测任务中，比如 Faster R-CNN，我们会从一张图片中生成多个候选区域（ROI），这些区域的大小各不相同。而神经网络的全连接层只能接受固定大小的输入，这就产生了一个问题：\",\"如何将不同尺寸的ROI特征，统一变为相同尺寸？\",\"ROI Pooling 的目标就是: 从不同大小的 ROI 区域中提取固定大小的特征（例如 7×7），同时保留最有代表性的空间信息。\",\"ROI Pooling 的操作流程可以分为三个步骤:\",\"映射 ROI 到特征图空间\",\"假设输入图像经过卷积得到一个特征图（例如从 ResNet 输出的特征图），而我们检测到一个 ROI（例如在原图上坐标为 ）。\",\"由于特征图的尺寸比原图小（通常是原图的 1/16），我们需要先将 ROI 坐标 映射到特征图上：\",\"其中 stride 是特征图相对于原图的缩放比例。\",\"将该 ROI 划分成固定数量的网格区域\",\"例如我们希望将每个 ROI 转换成 7×7 的特征图，那么就把该 ROI 分成 7 行 × 7 列的 小块（每一小块大小不同，但数目固定）。\",\"每个小块做 max pooling\",\"对每个小块区域做 最大池化（Max Pooling），取出该区域内的最大值，这样就将原本不定尺寸的 ROI 转换成一个固定大小的特征图（例如 7×7）。\",\"假设某个 ROI 映射到特征图上之后是一个大小为 14×14 的区域，我们希望输出一个 7×7 的固定大小特征图。\",\"将 14×14 区域划分为 7×7 的网格（每个网格是 2×2 大小）\",\"对每个 2×2 的小格子做最大池化 → 输出一个 7×7 特征图\",\"⚠️ ROI Pooling 有一个问题：量化误差。\",\"ROI Pooling 的划分方式中涉及到了取整（floor/ceil），这在某些场景下会导致位置偏差、信息丢失。\",\"为了更精确，Mask R-CNN 提出了更先进的方法：ROI Align，它使用双线性插值来避免量化误差，使得检测/分割性能更好。\"]},\"387\":{\"h\":\"ROI Align\",\"t\":[\"ROIAlign 是 Mask R-CNN 中为了解决 RoIPooling 引起的对齐误差问题而提出的关键组件。\",\"RoIPool（Region of Interest Pooling） 是 Faster R-CNN 中的标准组件，用于将任意大小的候选框（RoI）转换为固定大小（例如 7×7）的特征图，以便送入全连接层进行分类和回归。\",\"问题： RoIPool 在处理浮点型的 RoI 坐标时进行了两次量化（quantization）操作：\",\"RoI 边界坐标的量化（例如将 x/16 向下取整）；\",\"池化 bin 分割时的量化（每个 bin 的边界坐标再取整）。\",\"这会导致特征图上的空间对齐误差（misalignment），尤其对 像素级别任务如分割 影响显著。\",\"RoIAlign目标：消除量化误差，实现精确的像素级对齐。\",\"实现步骤如下：\",\"不进行任何量化\",\"保留浮点型的 RoI 坐标值（例如 x/16 而不是 [x/16]），也不对 bin 边界进行离散化。\",\"对每个 bin 采样多个点（如 2×2）\",\"将 RoI 分成固定数量的 bin（例如 7×7）。\",\"每个 bin 中选定若干个浮点坐标点（通常为4个采样点，中心或等距分布）。\",\"+----------+ | * * | | | | | | * * | +----------+\",\"每个 * 就是一个采样点，它们分布在 4 个角的中间位置，平均对称。\",\"使用双线性插值（Bilinear Interpolation）提取特征值\",\"由于坐标是浮点数，不对应实际的 feature map 网格点，因此使用四邻域双线性插值从特征图中获取精确的 feature 值。\",\"你要在 (3.6, 5.2) 点上取值： - 它离 (3,5) 的距离是 (1 - 0.6) * (1 - 0.2) = 0.4 * 0.8 = 0.32 - 它离 (4,5) 的距离是 0.6 * 0.8 = 0.48 - 它离 (3,6) 的距离是 0.4 * 0.2 = 0.08 - 它离 (4,6) 的距离是 0.6 * 0.2 = 0.12 于是你把这 4 个点的值按这个比例加起来，就得到了 (3.6, 5.2) 的值。 就像你在地图上两个村庄中间估算温度时，不会只看一个村，而是综合周围村子的情况加权得出。\",\"每个撒下去的小数点都用周围的4个整数点去“平均估计”（双线性插值）;\",\"对采样点的值进行聚合\",\"可以采用 max 或 average（论文推荐 average）。\",\"每个 bin 的最终输出为这些采样点值的聚合结果。\",\"图示（见论文 Figure 3）：\",\"实线为 RoI，虚线为 feature map 网格，黑点为采样点，通过插值获得值后聚合。\",\"RoIAlign 就是：\",\"先把目标区域平均切成小格子（比如 7×7）；\",\"在每个小格子里撒几个点（比如 2×2）；\",\"每个撒下去的小数点都用周围的4个整数点去“平均估计”（双线性插值）；\",\"最后把所有点的值求平均，就得到了这个格子的特征。\"]},\"388\":{\"h\":\"上采样\",\"t\":[\"torch.nn.functional.interpolate( input, size=None, scale_factor=None, mode='nearest', align_corners=None, recompute_scale_factor=None )\",\"参数\",\"说明\",\"input\",\"输入张量，形状 [N, C, H, W]（2D）或 [N, C, D, H, W]（3D）\",\"size\",\"输出的目标尺寸 (H_out, W_out)，与 scale_factor 互斥\",\"scale_factor\",\"缩放因子 (fH, fW)，用于等比例放大或缩小\",\"mode\",\"插值方式： 'nearest', 'bilinear', 'bicubic', 'trilinear', 'area'\",\"align_corners\",\"对双线性或双三次插值是否对齐角点，默认 None\",\"recompute_scale_factor\",\"是否重新计算缩放因子，默认 None\"]},\"389\":{\"h\":\"最近邻 (nearest) 插值\",\"t\":[\"最近邻插值是最简单的一种上采样方法：\",\"对于要插值的每个输出像素点，找到它在输入中的 最近的一个像素，直接把这个像素的值赋给输出像素。\",\"不会对像素值进行加权平均或平滑处理，所以原本的格子边界保持得很清晰。\",\"适合用于 离散格子 或 掩码、标签图，因为不会引入新的中间值。\",\"公式描述：\",\"假设输入特征图大小为 (H_in, W_in)，输出大小为 (H_out, W_out)：\",\"其中 round 表示取最接近的整数索引。\",\"一个简单的例子如下所示:\",\"输入 X: [[10, 20], [30, 40]] --放大两倍--> 输出 Y: [[10, 10, 20, 20], [10, 10, 20, 20], [30, 30, 40, 40], [30, 30, 40, 40]]\"]},\"390\":{\"h\":\"双线性 (bilinear) 插值\",\"t\":[\"双线性插值是一种常用的图像放大/缩小方法，它的核心思想是 对输出像素使用周围四个输入像素的加权平均，从而获得平滑的过渡效果。\",\"输入：一幅图像 H_in × W_in\",\"输出：目标大小 H_out × W_out\",\"对输出图像中的每个像素，找到它在输入图像对应的浮点坐标 (x, y)，并使用其周围的 2×2 像素进行插值。\",\"假设输出坐标映射到输入坐标 (x, y)，周围四个像素为：\",\"(x0, y0) ---- (x1, y0) | | | | (x0, y1) ---- (x1, y1)\",\"对应的像素值分别为 Q11, Q21, Q12, Q22\",\"插值公式：\",\"直观理解：x方向和y方向的线性插值的叠加 → 因此叫“双线性”\",\"特点\",\"说明\",\"平滑\",\"输出图像像素值是周围四个输入像素加权平均，边界过渡自然\",\"精度高于最近邻\",\"不会产生块状感，适合图像缩放\",\"适合连续值\",\"对热力图、注意力图、彩色图像非常友好\",\"较慢\",\"需要计算权重和加权平均，比最近邻计算量大\"]},\"391\":{\"h\":\"余弦相似度\",\"t\":[\"余弦相似度（Cosine Similarity）是一种常用的衡量两个向量相似度的方法，特别常用于文本向量、推荐系统、信息检索等场景。\",\"公式如下：\",\"其中：\",\" ：两个向量（维度相同）。\",\" ：向量的点积。\",\" ：向量 的欧几里得范数（长度）。\",\"。\",\" ：向量 和 之间的夹角。\",\"取值范围：\",\"，其中：\",\"越接近 1 表示两个向量方向越接近（相似度高）。\",\"越接近 0 表示两个向量几乎正交（不相似）。\",\"越接近 -1 表示两个向量方向相反。\"]},\"392\":{\"h\":\"L1 归一化（L1 Normalization）\",\"t\":[\"定义：把向量中每个元素除以向量元素的绝对值之和，使得归一化后的向量的 L1 范数 = 1。\",\"公式：\",\"特点：\",\"保留向量的方向信息，但缩放到总和为 1。\",\"常用于特征和概率分布处理，比如文本的 TF-IDF 向量。\"]},\"393\":{\"h\":\"L2 归一化（L2 Normalization）\",\"t\":[\"定义：把向量中每个元素除以向量的欧几里得长度，使得归一化后的向量的 L2 范数 = 1。\",\"公式：\",\"特点：\",\"保留向量方向，但长度固定为 1。\",\"在计算余弦相似度、梯度下降等场景中非常常用。\",\"L1 归一化 → 保证绝对值之和 = 1（稀疏向量处理好）。\",\"L2 归一化 → 保证长度 = 1（方向为主，长度固定）。\"]},\"394\":{\"h\":\"API记录之框架篇\",\"t\":[\"API记录之框架篇\"]},\"395\":{\"h\":\"timm 库\",\"t\":[\"timm 是 PyTorch Image Models 的缩写，是 Ross Wightman 开发和维护的一个 PyTorch 视觉模型库，在计算机视觉领域非常常用。它在科研与工业界都很受欢迎，因为它集合了大量常见与前沿的图像模型，同时提供了高质量的实现和训练权重。\",\"特点:\",\"模型丰富\",\"收录了数百种视觉模型，包括：\",\"经典模型：ResNet、DenseNet、EfficientNet、MobileNet\",\"Transformer 系列：ViT、DeiT、Swin Transformer、ConvNeXt\",\"最新论文模型：EVA、ConvNeXt V2、MaxViT 等\",\"你几乎可以把它当成 视觉模型的“模型仓库”。\",\"预训练权重\",\"提供了大量在 ImageNet-1k / ImageNet-21k 上训练好的权重，开箱即用。\",\"可以直接加载预训练模型用于 迁移学习 / finetune。\",\"统一接口\",\"使用简单，几乎所有模型都能通过同样的方式调用：\",\"import timm model = timm.create_model('resnet50', pretrained=True) x = torch.randn(1, 3, 224, 224) y = model(x)\",\"API 统一，降低了不同架构之间的切换成本。\",\"实用工具\",\"timm.data：包含数据增强（RandAugment、Mixup、CutMix 等）。\",\"timm.optim：包含优化器（AdamP、RAdam、Lookahead 等）。\",\"timm.scheduler：学习率调度器（CosineAnnealing、OneCycle、TanhDecay 等）。\",\"timm.loss：封装了多种损失函数（Label Smoothing、SoftTarget CrossEntropy 等）。\",\"这些设计让训练流程非常完整。\",\"高效实现\",\"很多模型在 timm 里做了 速度和显存优化，常常比官方实现更高效。\",\"支持混合精度训练、channels-last 等特性。\"]},\"396\":{\"h\":\"create_model 与 @register_model 装饰器\",\"t\":[\"create_model：timm 提供的统一入口，用于按名字实例化模型。\",\"model = timm.create_model('resnet50', pretrained=True)\",\"@register_model：用于将自定义模型注册到 timm 模型库，才能通过 create_model 调用。\",\"@register_model def my_model(pretrained=False, **kwargs): return MyModel(**kwargs)\",\"前者是用模型，后者是加模型。\"]},\"397\":{\"h\":\"scikit-learn 库\"},\"398\":{\"h\":\"train_test_split\",\"t\":[\"train_test_split（来自 sklearn.model_selection）用于把一个或多个并行数组按比例切分成训练集和测试集，常用于机器学习的数据准备。\",\"def train_test_split( *arrays, test_size=None, train_size=None, random_state=None, shuffle=True, stratify=None, )\",\"*arrays：一个或多个数组（如 X, y），长度必须相同。返回值是按输入顺序交错的切分结果：X_train, X_test, y_train, y_test, ...。\",\"test_size：float（0~1，表示比例）或 int（样本数）或 None。若都为 None，默认 test_size=0.25。\",\"train_size：同 test_size，可用来显式指定训练集大小（优先级低于 test_size）。\",\"random_state：整数或 RandomState，用于可重复的随机化（只在 shuffle=True 时生效）。\",\"shuffle：是否先打乱样本（默认 True）。设为 False 时按原序切分。\",\"stratify：用于分层采样的标签数组（与输入长度相同），保证切分后各类比例与原始数据一致；如果提供了 stratify，必须 shuffle=True。\",\"简单例子:\",\"from sklearn.model_selection import train_test_split import numpy as np X = np.arange(10).reshape(10,1) # 10 个样本特征 y = np.array([0,0,0,0,1,1,1,1,1,1]) # 不平衡标签 X_train, X_test, y_train, y_test = train_test_split( X, y, test_size=0.3, random_state=42, stratify=y ) print(X_train.shape, X_test.shape) # (7,1) (3,1) print(np.bincount(y_train), np.bincount(y_test)) # 输出会显示训练/测试集中 0/1 类的比例与原始近似一致\",\"注意点:\",\"给多个数组（如 X, y, z）时，返回对应数量的切分结果。\",\"stratify 用于类别任务，能避免切分导致某类在测试集中缺失。\",\"若需固定切分可用 random_state；想保留原序列则 shuffle=False。\"]},\"399\":{\"h\":\"compute_class_weight\",\"t\":[\"compute_class_weight 是 scikit-learn 提供的一个函数，用于根据样本分布计算每个类别的权重，常用于 类别不平衡 的分类任务。\",\"sklearn.utils.class_weight.compute_class_weight( class_weight, classes, y )\",\"class_weight\",\"'balanced'：自动计算权重，和类别频率成反比。\",\"dict：手动指定某些类别的权重，如 {0: 1.0, 1: 5.0}。\",\"None：不计算，所有类别权重为 1。\",\"classes\",\"所有类别的 唯一标签数组（如 [0, 1, 2]）。\",\"y\",\"训练数据的标签数组（如 [0,0,1,2,2,2]）。\",\"返回值:\",\"weights：一维数组，长度与 classes 相同，表示每个类别的权重。\",\"计算公式（balanced 模式）：\",\"其中：\",\"：样本总数\",\"：类别数\",\"：第 j 类的样本数\",\"示例:\",\"from sklearn.utils.class_weight import compute_class_weight import numpy as np y = np.array([0, 0, 1, 2, 2, 2]) # 样本标签 classes = np.unique(y) weights = compute_class_weight('balanced', classes=classes, y=y) print(\\\"类别权重:\\\", dict(zip(classes, weights)))\",\"输出：\",\"类别权重: {0: 1.0, 1: 3.0, 2: 0.67}\",\"说明：\",\"类别 0 有 2 个样本 → 权重较低\",\"类别 1 只有 1 个样本 → 权重最高\",\"类别 2 有 3 个样本 → 权重最低\"]},\"400\":{\"h\":\"python 内置 collections 库\"},\"401\":{\"h\":\"Counter\",\"t\":[\"Counter 是 Python 内置库 collections 提供的一个计数器类，用于统计可迭代对象中各元素出现的次数。\",\"from collections import Counter Counter(iterable) # 输入一个可迭代对象 Counter(mapping) # 输入一个字典 Counter(a=2, b=3, ...) # 输入关键字参数\",\"返回的是一个字典的子类，键为元素，值为出现次数。\",\"查询一个未出现的元素时，计数为 0。\",\"支持常见的字典操作，还扩展了计数相关方法。\",\"常用方法:\",\"most_common(n)：返回出现次数最多的前 n 个元素及其频数。\",\"elements()：按出现次数依次返回元素（迭代器）。\",\"update(iterable)：更新计数。\",\"subtract(iterable)：减少计数。\",\"例子:\",\"from collections import Counter all_labels = [0, 1, 0, 2, 1, 0, 2, 2, 2] label_counts = Counter(all_labels) print(label_counts) # Counter({2: 4, 0: 3, 1: 2}) print(label_counts[2]) # 4 print(label_counts.most_common(1)) # [(2, 4)] print(list(label_counts.elements())) # [0, 0, 0, 1, 1, 2, 2, 2, 2]\"]},\"402\":{\"h\":\"pytorch 内置 采样库\"},\"403\":{\"h\":\"WeightedRandomSampler\",\"t\":[\"WeightedRandomSampler 是 PyTorch 提供的一个采样器，用于在构建 DataLoader 时 按权重采样样本，常用于类别不平衡的数据集。\",\"torch.utils.data.WeightedRandomSampler( weights, num_samples, replacement=True )\",\"weights\",\"一维数组/列表，长度等于样本数。\",\"每个元素表示对应样本被采样的概率权重。\",\"权重越大，被抽到的概率越高。\",\"num_samples\",\"采样的样本数（即每个 epoch 中从数据集中抽多少个样本）。\",\"通常设为 len(dataset) 或 len(train_labels)。\",\"replacement\",\"是否有放回采样：\",\"True：可以重复采样同一样本。\",\"False：无放回采样（但这时 num_samples 不能超过数据集大小）。\",\"举例:\",\"train_label_counts = Counter(train_labels) # 计算每个样本的权重：类别样本越少，权重越高 train_sample_weights = [1.0 / train_label_counts[label] for label in train_labels] # 构建加权随机采样器 train_sampler = WeightedRandomSampler( weights=train_sample_weights, num_samples=len(train_labels), # 每个epoch采样样本数=总样本数 replacement=True # 允许重复采样 )\",\"思路：类别数量少 → 权重大 → 更容易被采到。\",\"目的：让每个类别在训练过程中被抽到的机会接近均衡，从而缓解类别不平衡问题。\"]},\"404\":{\"h\":\"Attention运算过程中维度变换的理解\",\"t\":[\"Attention运算过程中维度变换的理解\",\"在注意力机制（特别是 Transformer 中的 自注意力机制）中，Q（Query）、K（Key）、V（Value） 的维度对最终注意力输出的结果维度有直接影响。我们来一步步分析这个过程：\"]},\"405\":{\"h\":\"一、注意力机制的基本流程\",\"t\":[\"在标准的 缩放点积注意力（Scaled Dot-Product Attention） 中，计算公式如下：\",\"其中：\",\"：query的数量（如句子长度）\",\"：key/value的数量（也通常是句子长度）\",\"：每个 query 和 key 的维度\",\"：每个 value 的维度\"]},\"406\":{\"h\":\"二、Q、K、V 的初始维度对结果的影响\"},\"407\":{\"h\":\"1.\",\"t\":[\"这是注意力权重矩阵的来源。\",\"所以\",\"👉 这个矩阵表示的是每个 query 对应所有 key 的相似度（即注意力得分），共个值。\"]},\"408\":{\"h\":\"2.\",\"t\":[\"对每一行做 softmax，得到归一化的注意力权重：\",\"输入：\",\"输出：仍是\"]},\"409\":{\"h\":\"3.\",\"t\":[\"注意力权重：\",\"Value 矩阵：\",\"结果：\",\"👉 最终输出的维度是，也就是和输入的 query 数量一致，但每个输出向量的维度由 value 的维度决定。\"]},\"410\":{\"h\":\"三、总结：输入维度 → 输出维度\",\"t\":[\"输入\",\"维度\",\"含义\",\"Query (Q)\",\"查询向量，n 是序列长度\",\"Key (K)\",\"键向量，用于匹配查询\",\"Value (V)\",\"值向量，实际携带信息\",\"输出\",\"维度\",\"含义\",\"Attention Output\",\"每个 query 聚合了所有 value 的加权信息\"]},\"411\":{\"h\":\"四、如何理解这个过程？\",\"t\":[\"我们可以从以下角度理解：\"]},\"412\":{\"h\":\"✅ 1.\",\"t\":[\"每个 Query 都是在寻找最相关的 Key。\",\"根据相关性（注意力权重），从对应的 Value 中提取信息。\",\"最终每个 Query 得到一个融合了上下文信息的向量。\"]},\"413\":{\"h\":\"✅ 2.\",\"t\":[\"控制了相似度计算的维度，影响模型容量和梯度稳定性。\",\"决定了输出的信息维度，可以独立于设计。\",\"这种分离的设计让模型更灵活，比如多头注意力中可以分别控制每个 head 的表达能力。\"]},\"414\":{\"h\":\"✅ 3.\",\"t\":[\"类似数据库查询： \",\"Query 是你输入的问题；\",\"Key 是数据库中的索引；\",\"Value 是数据库中的内容；\",\"Attention 就是根据问题找到相关内容并返回。\"]},\"415\":{\"h\":\"五、例子说明（以 Transformer 为例）\",\"t\":[\"假设我们在 Transformer 中：\",\"输入是一个 batch of sequences，shape 为\",\"我们通过线性变换得到： \",\"那么最终输出为：\",\"如果使用多头注意力（Multi-head Attention），我们会拼接多个这样的头，最后再经过一个线性层映射回原始维度。\"]},\"416\":{\"h\":\"六、常见疑问解答\"},\"417\":{\"h\":\"❓Q: 为什么 和 可以不同？\",\"t\":[\"因为它们的作用不同：\",\"是用于计算相似度的维度；\",\"是用于信息表达的维度；\",\"两者解耦可以让模型更灵活地分配资源。\"]},\"418\":{\"h\":\"❓Q: 为什么要除以 ？\",\"t\":[\"防止内积过大导致 softmax 梯度消失。 当较大时，QK^T 的数值会很大，除以可以缓解这个问题。\"]},\"419\":{\"h\":\"七、可视化示意\",\"t\":[\"Q: [n x dk] K: [m x dk] V: [m x dv] ↓ ↓ ↓ Q @ K.T → [n x m] ↓ ↓ ↓ softmax → [n x m] V → [m x dv] ↓__________________________↓ ↓ Output → [n x dv]\"]},\"420\":{\"h\":\"Pytorch张量存储与访问原理\",\"t\":[\"Pytorch张量存储与访问原理\"]},\"421\":{\"h\":\"引言\",\"t\":[\"张量（Tensor）是数学和物理学中用于表示多维数组的一个概念，在机器学习、深度学习等领域也得到了广泛应用，简单来说，张量可以被视为一种广义的矩阵，它可以拥有任意数量的维度。我们生成一个3*3 的张量,如下所示:\",\"import torch t = torch.tensor([[1,2,3],[4,5,6],[7,8,9]]) print(t, t.shape) output: tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) torch.Size([3, 3])\",\"我们知道，计算机的内存（RAM）本质上是一个线性、一维的存储空间。每一个存储单元（通常是字节，byte）都有一个唯一的地址，这些地址从 0 开始顺序排列，形成一个连续的一维空间。因此不论张量是多少维的，最终都会被映射为一维。在映射机制里，涉及两个重要概念，连续性(contiguity rule)和步长(strides)。\"]},\"422\":{\"h\":\"连续性\",\"t\":[\"连续性: 数据元素在内存空间的排列顺序，主要包括行优先和列优先两类，Pytorch 默认使用行优先方式。\",\"在行优先顺序（Row-major order）中，，内存先存储第 0 行的所有元素，接着是第 1 行的所有元素，依此类推。对于上述代码中的矩阵，其在内存中行优先布局:\",\"1,2,3,4,5,6,7,8,9\",\"在列优先顺序（Column-major order）中，内存先存储第 0 列的所有元素，接着是第 1 列的所有元素，依此类推。对于上述代码中的矩阵，其在内存中列优先布局:\",\"1,4,7,2,5,8,3,6,9\"]},\"423\":{\"h\":\"步长\",\"t\":[\"步长解决的是如何将多维张量中的 (i, j) 或 (i, j, k, …) 索引映射到内存中的地址，比如在内存中从一个索引移动到另一个索引时，沿着某个特定维度需要跨越多少个元素（不一定是字节）。\",\"行优先存储模式的步长，如下例所示:\",\"import torch x = torch.tensor([[1, 2, 3], [4, 5, 6]]) print(\\\"Tensor:\\\") print(x) print(\\\"Strides:\\\", x.stride()) # 输出: (3, 1) # 行优先（Row-major）二维布局 - 形状（Shape）：`[2, 3]`（2 行，3 列） - 典型步长（Strides）：`[3, 1]` 解释： - 第一个维度（“行”维度）的步长是 `3`，意味着如果你从第 `i` 行移动到第 `i+1` 行，你需要在内存中跳过 `3` 个元素。 - 第二个维度（“列”维度）的步长是 `1`，意味着相邻列的元素在内存中也是相邻的。\",\"列优先存储模式的步长，如下例所示:\",\"import numpy as np import torch #创建一个 NumPy 的列优先（column-major）数组 a = np.array([[1, 2, 3], [4, 5, 6]], order='F') # 'F' 表示 Fortran order（列优先） x = torch.from_numpy(a) print(x) print(\\\"Strides:\\\", x.stride()) #输出：(1，2) #列优先（Column-major）二维布局 - 形状（Shape）：`[2, 3]`（2 行，3 列） - 典型步长（Strides）：`[1, 2]` 解释： - 第一个维度（“行”维度）的步长是 `1`，意味着从第 `i` 行移动到第 `i+1` 行只需要在内存中前进一步。 - 第二个维度（“列”维度）的步长是 `2`，意味着从第 `j` 列跳转到第 `j+1` 列时，你需要跳过 `2` 个元素\",\"再来看一个多维张量的例子:\",\"import torch t = torch.arange(0, 24).reshape(1, 2, 3, 4) print(t.stride()) torch.arange(0, 24) 创建了一个一维张量，包含从 0 到 23 的 24 个数字： [ 0, 1, 2, ..., 23] 然后 .reshape(1, 2, 3, 4) 将其重塑为一个 4 D 张量，其形状是： (第0维: batch=1, 第1维: channel=2, 第2维: height=3, 第3维: width=4) 也就是说这个张量可以看作是一个 batch size 为 1、有 2 个通道、每个通道有 3 行 4 列的数据。 tensor([[[[ 0, 1, 2, 3], [ 4, 5, 6, 7], [ 8, 9, 10, 11]], [[12, 13, 14, 15], [16, 17, 18, 19], [20, 21, 22, 23]]]]) 执行 print(t.stride())，输出为： (24, 12, 4, 1) 这表示在内存中访问该张量时，每个维度上的“步长”分别是： dim=0 (batch) 24 要跳到下一个 batch 需要移动 24 个元素（但因为 batch=1，实际上没用） dim=1 (channel) 12 要跳到下一个通道需要移动 12 个元素 dim=2 (height/行) 4 要跳到下一行需要移动 4 个元素 dim=3 (width/列) 1 要跳到下一列只需要移动 1 个元素\"]},\"424\":{\"h\":\"张量变换操作\"},\"425\":{\"h\":\"切片(Slice)\",\"t\":[\"切片，指从一个大的数据结构中提取出一部分连续的数据子集，如下所示:\",\"import torch # 创建一个张量 tensor = torch.tensor([[1, 2, 3], [4, 5, 6], [7, 8, 9]]) # 获取第二行 print(tensor[1, :]) # 输出: tensor([4, 5, 6]) # 获取第二列 print(tensor[:, 1]) # 输出: tensor([2, 5, 8]) # 获取子张量：前两行、前两列 print(tensor[:2, :2]) # 输出: tensor([[1, 2], # [4, 5]]) # 每隔一行 + 每隔一列 print(tensor[::2, ::2]) # 输出: tensor([[1, 3], # [7, 9]])\",\"切片索引语法: tensor[start:stop:step]\",\"对一个张量（或矩阵）进行“切片”时，实际上并没有复制内存中的任何数据值。相反，这是通过“零拷贝”的方式，调整以下三个要素来创建一个新的视图（view）。\",\"这三个关键要素是：\",\"起始偏移量 (Base offset / Data pointer offset): 表示新视图从原始内存块中的哪个位置开始; 它是一个指向内存中某个元素的指针偏移量。\",\"形状 (Shape): 描述这个新视图的维度大小; 例如：原张量是 3x4，切片后可能是 2x3 或 1x4。\",\"步长 (Strides): 指明在每个维度上移动一个索引单位时，需要跨越多少个内存元素; 通过调整步长，可以实现按行、列或其他任意模式访问数据。\",\"具体的，假设有一个 3×4 的张量（即形状为 [3, 4]），在内存中是行优先存储：\",\"[[A00, A01, A02, A03], [A10, A11, A12, A13], [A20, A21, A22, A23]]\",\"对应的内存布局为一维数组：\",\"[A00, A01, A02, A03, A10, A11, A12, A13, A20, A21, A22, A23]\",\"如果我们做如下切片操作（取第1行到第3行，第1列到第3列）：\",\"sub_tensor = tensor[1:, 1:3]\",\"结果是一个形状为 [2, 2] 的新视图：\",\"[[A11, A12], [A21, A22]]\",\"但此时并没有复制任何数据，而是通过以下方式创建了一个新的“视图”，数据还是指向内存中已有的数据。\",\"属性\",\"值\",\"说明\",\"数据指针偏移\",\"指向 A11 的位置\",\"即内存地址偏移 5（从 A00 开始数）\",\"形状（shape）\",\"[2, 2]\",\"表示两行两列\",\"步长（strides）\",\"[4, 1]\",\"行步长为 4（跳过一行），列步长为 1（逐列）\",\"其下标索引公式可表示为:\"]},\"426\":{\"h\":\"转置(Transpose)\",\"t\":[\"转置,可以理解为对多维张量的各个维度（轴）进行重新排列。\",\"比如，对于一个二维矩阵（形状为 [m, n]），最简单的转置就是将行和列交换，得到一个新的形状为 [n, m] 的矩阵。对于更高维的张量，”转置” 通常意味着对各个轴进行更一般的排列组合。例如，将一个形状为 [D0, D1, D2] 的张量转置为 [D2, D0, D1]。\",\"转置包括逻辑转置和物理转置。\",\"基于步长的逻辑转置（零拷贝）：我们可以通改变对内存中数据缓冲区的解读方式来实现逻辑上的转置，而不是真正地重新排列数据。\",\"比如，在一个简单的二维情况（行优先布局）中：\",\"原始的步长可能是 strides = [n, 1]，对应一个形状为 [m, n] 的数组。\",\"当进行转置时，只需将这些步长交换为 [1, m]，就可以“按转置顺序”来读取数据。\",\"这种方法不需要复制数据，但要注意的是，如果原始数据是按行优先方式存储的，这种转置后的布局在缓存访问上可能效率较低。具体示例如下所示:\",\"import torch # 创建一个张量 t = torch.tensor([[1, 2, 3], [4, 5, 6]]) print(\\\"Original tensor:\\\") print(t) print(\\\"Strides:\\\", t.stride()) # 输出: (3, 1) # 逻辑转置 t_trans = t.t() # 或者使用 t.transpose(0, 1) print(\\\"\\\\nTransposed view:\\\") print(t_trans) print(\\\"Strides after transpose:\\\", t_trans.stride()) # 输出: (1, 3)\",\"物理转置（拷贝）：实际创建一个新的数据缓冲区，并将元素按照转置后的位置写入新内存，使转置后的数据在新的布局中是连续存储的。虽然这种方式需要花费时间和内存来完成拷贝，但它能为后续许多针对转置数据的操作带来更好的内存局部性（memory locality），比如在 TensorRT、ONNX Runtime等加速库中可以更好地利用缓存从而提升性能。\",\"import torch # 创建一个张量 t = torch.tensor([[1, 2, 3], [4, 5, 6]]) # 创建一个连续的转置副本 t_trans_contig = t.t().contiguous() print(\\\"\\\\nPhysically transposed and contiguous tensor:\\\") print(t_trans_contig) print(\\\"Strides after contiguous:\\\", t_trans_contig.stride()) # 输出: (2, 1) print(\\\"Is contiguous?\\\", t_trans_contig.is_contiguous()) # 应为 True\",\"值得注意的是，逻辑转置中，转置后的矩阵步长是(1,3)，而物理转置中，转置后的步长是(2,1)。\",\"这里解释一下，前提条件是行优先存储，在逻辑转置中，转置前\",\"[[1, 2, 3], [4, 5, 6]]\",\"底层数据存储为[1,2,3,4,5,6]，转置后\",\"[[1, 4], [2, 5], [3, 6]]\",\"底层内存中的数据并没有被重新排列！还是：[1, 2, 3, 4, 5, 6]，只是访问方式变了 —— 现在我们按“列优先”的方式去读这个数组，所以正确的strides是(1,3)。\",\"而在物理转置中，由于使用了.contiguous()，内存空间得以连续布局，数据在底层存储为[1, 4, 2, 5, 3, 6]，这个新内存布局使得每一行是连续的，因此步长为 (2,1)。\",\"我们可以把 .contiguous() 理解为：“我不管你现在怎么解读这块内存，我现在要把你的数据重新整理成行优先、连续存储的方式。”\"]},\"427\":{\"h\":\"广播(BroadCast)\",\"t\":[\"广播，是在张量（或数组）运算中非常常见且强大的一种机制，它允许不同形状的张量进行逐元素（element-wise）操作，而不需要显式复制数据。\",\"我们使用了一个示例来说明这一概念：对两个张量 a 和 b 进行相加操作，其中 a.shape = [4, 3]，b.shape = [1, 3]，如下图所示\",\"该图展示了 广播（Broadcast） 在数组运算中的底层实现原理，重点在于 如何通过调整步幅（strides）实现数据虚拟扩展，而非物理复制数据。\",\"数组 a：形状为 4×3，假设为常规行优先存储（如 strides=[3,1]）。\",\"数组 b：原始形状为 1×3，数据内容 [1, 2, 3]，初始步幅 strides=[3,1]。\",\"将 b 从 1×3虚拟扩展为 4×3，使其能与 a 进行逐元素运算（如加法）。将维度大小为 1 的轴扩展至目标大小（此处将行维度从 1 扩展到 4）。\",\"广播通过 设置步幅为 0 实现虚拟扩展：\",\"调整后的 b 属性：\",\"shape = [4, 3]，扩展后的逻辑形状。\",\"data = [1, 2, 3]，物理数据未改变。\",\"strides = [0, 1]，行维度步幅 0：表示在行方向移动时，内存地址不变（复用同一行数据），列维度步幅 1：与原始步幅一致，按元素大小（假设为 1 字节）步进。\",\"扩展后的 b 在逻辑上表现为每行都是 [1, 2, 3]，但物理内存中数据不复制。根据公式\",\"对任意行 i（0 ≤ i <4），代入调整后的步幅 strides=[0, 1]，所有行均指向原始数据的第 j 个元素，实现虚拟复制\"]},\"428\":{\"h\":\"维度问题\",\"t\":[\"3 轴张量，形状：[3, 2, 5] 的多种呈现方式\",\"四阶张量的例子\",\"TensorFlow/PyTorch中使用比较多的tensor的阶为4，shape为[Batch,Height,Weight,Features]\",\"n阶张量的排列规律如下图所示\",\"可以将规律总结为：从shape列表的最右边往左遍历，最开始三个阶按照“下-右-里”的顺序排列，然后打包成一个group，再将整个group按照“下-右-里”的顺序排列，满三次后再打包成一个group，如此往复循环。\",\"本部分图片来源: 张量简介\"]},\"429\":{\"h\":\"杂谈\"},\"430\":{\"h\":\"conda虚拟环境管理\",\"t\":[\"conda虚拟环境管理\"]},\"431\":{\"h\":\"一、创建新环境\",\"t\":[\"基本语法：\",\"conda create --name <环境名> [包名]\",\"可使用 -name（或 n）来命名环境。\",\"示例1：创建一个空环境（只包含 Python）\",\"conda create --name myenv\",\"示例2：创建环境时指定 Python 版本\",\"conda create --name myenv python=3.9\",\"示例3：创建环境并安装一些常用包\",\"conda create --name myenv python=3.8 numpy pandas\"]},\"432\":{\"h\":\"二、激活（切换）环境\",\"t\":[\"激活环境的命令：\",\"conda activate <环境名>\",\"示例：\",\"conda activate lmaffordance3d\",\"激活后，你的终端提示符通常会显示当前环境的名字，例如：\",\"(myenv) user@machine:~$\"]},\"433\":{\"h\":\"三、退出当前环境\",\"t\":[\"要退出当前激活的环境，返回 base 环境：\",\"conda deactivate\"]},\"434\":{\"h\":\"四、查看所有已创建的环境\",\"t\":[\"你可以使用以下命令查看你所有的 conda 环境：\",\"conda env list # 或者 conda info --envs\",\"输出示例：\",\"# conda environments: # base * /home/user/anaconda3 myenv /home/user/anaconda3/envs/myenv testenv /home/user/anaconda3/envs/testenv\",\"注：带星号 * 的表示当前激活的环境。\"]},\"435\":{\"h\":\"五、删除已创建的环境\",\"t\":[\"如果你想删除某个环境，可以使用：\",\"conda env remove -n myenv\",\"如需进一步帮助，可使用：\",\"conda create --help conda activate --help\"]},\"436\":{\"h\":\"六、查看当前激活的环境\",\"t\":[\"查看当前conda激活的环境:\",\"conda info\"]},\"437\":{\"h\":\"七、查看当前环境已安装的包\",\"t\":[\"查看当前环境已安装的包：\",\"conda list\"]},\"438\":{\"h\":\"八、在当前环境下安装包\",\"t\":[\"根据 requirements.txt 安装所需要的依赖包:\",\"conda activate 你的环境名 # 先激活你的conda环境 pip install -r requirements.txt\",\"重要说明：\",\"在激活的 Conda 环境中使用 pip install，包会安装到该环境的 site-packages 中，不会影响其他环境或系统 Python\",\"如果未激活任何环境时使用 pip install，包可能会安装到基础环境或系统 Python 中\",\"建议总是先激活 Conda 环境再使用 pip，以避免安装到错误的位置\",\"可以使用 which pip 或 where pip (Windows) 确认你使用的是 Conda 环境中的 pip\",\"pip install 安装失败的包，尝试使用conda install命令安装即可，再不行尝试源码编译安装(例如某些包在arm64系统上没有预先编译好的版本)。\",\"特性\",\"pip\",\"conda\",\"默认仓库\",\"PyPI（Python Package Index）\",\"Anaconda 官方仓库 / conda-forge\",\"包类型\",\"仅 Python 包（纯 Python 或源码）\",\"预编译的二进制包（含非 Python 依赖）\",\"非 Python 依赖\",\"不管理（如 FFmpeg、HDF5）\",\"自动安装（如 CUDA、MKL）\"]},\"439\":{\"h\":\"九、常见错误\",\"t\":[\"CondaError: Run 'conda init' before 'conda activate’\",\"conda init 如果是 bash： source ~/.bashrc 如果是 zsh： bash conda activate lavis\"]},\"440\":{\"h\":\"常用评估指标\",\"t\":[\"常用评估指标\"]},\"441\":{\"h\":\"二元分类场景\"},\"442\":{\"h\":\"混淆矩阵 (confusion_matrix)\",\"t\":[\"二元分类器的每个输出有四种可能的结果，如果我们将标准答案作为列，将模型的预测作为行，则会得到以下表格（称为混淆矩阵）：\",\"实际正例\",\"实际负例\",\"预测为正例\",\"真正例 (TP)：垃圾邮件被正确分类为垃圾邮件。\",\"假正例 (FP)：非垃圾邮件被误分类为垃圾邮件。\",\"预测为负例\",\"假负例 (FN)：垃圾邮件被误分类为非垃圾邮件。\",\"真负例 (TN)：非垃圾邮件被正确分类为非垃圾邮件。\",\"请注意，每行的总和表示所有预测正例 (TP + FP) 和所有预测负例 (FN + TN)，无论其有效性如何。与此同时，每个列中的总和会显示所有真实正例 (TP + FN) 和所有真实负例 (FP + TN)，而不会考虑模型分类。\",\"如果实际正例的总数与实际负例的总数不接近，则表示数据集不平衡。不平衡数据集的一个示例可能是一组数以千计的云彩照片，其中您感兴趣的罕见云彩类型（例如卷云）只出现了几次。\"]},\"443\":{\"h\":\"准确率 (accuracy)\",\"t\":[\"准确性是指所有分类（无论是正类还是负类）正确分类的比例。其数学定义为：\",\"在垃圾邮件分类示例中，准确率衡量的是所有电子邮件正确分类所占的比例。\",\"完美的模型没有假正例和假负例，因此准确率为 1.0，即 100%。\",\"由于准确率包含混淆矩阵中的所有四种结果（TP、FP、TN、FN），因此在类别数量相近且平衡的数据集的情况下，准确率可以作为衡量模型质量的粗略指标。\",\"不过，如果数据集不平衡，或者一种错误（假负例或假正例）的代价高于另一种错误（大多数实际应用中都是如此），则最好改为针对其他指标进行优化。\",\"对于严重不均衡的数据集（其中一个类别出现的频率非常低，例如 1%），如果模型 100% 都预测为负类别，则其准确性得分为 99%，尽管该模型毫无用处。\"]},\"444\":{\"h\":\"召回率 (recall) / 真正例率\",\"t\":[\"真正例率 (TPR)，即所有实际正例被正确分类为正例的比例，也称为召回率。\",\"在数学上，召回率的定义为：\",\"假负例是指被误分类为负例的实际正例，因此会出现在分母中。在垃圾邮件分类示例中，召回率衡量的是被正确分类为垃圾邮件的垃圾邮件电子邮件的比例。\",\"假设一个完美的模型不会出现假负例，因此其召回率 (TPR) 为 1.0，也就是说，检测率为 100%。\",\"在实际正例数量非常少的不平衡数据集中，召回率比准确率更有意义，因为它衡量的是模型正确识别所有正例实例的能力。对于疾病预测等应用，正确识别阳性病例至关重要。假负例通常比假正例的后果更严重。\"]},\"445\":{\"h\":\"误报概率 / 假正例率\",\"t\":[\"假正例率 (FPR) 是指被错误地归类为正例的所有实际负例所占的比例，也称为误报概率。其数学定义为：\",\"假正例是被错误分类的实际负例，因此会出现在分母中。在垃圾邮件分类示例中，FPR 用于衡量被错误分类为垃圾邮件的合法电子邮件的比例，或模型的误报率。\",\"完美的模型不会产生假正例，因此其假正例率为 0.0，也就是说，假正例率为 0%。\",\"在实际负例数量非常少（例如总共 1-2 个示例）的不平衡数据集中，FPR 作为一个指标就没有那么有意义和实用。\"]},\"446\":{\"h\":\"精确率\",\"t\":[\"精确率是指模型所有正类别分类中实际为正类别的分类所占的比例。在数学上，其定义为：\",\"在垃圾邮件分类示例中，精确率衡量的是被归类为垃圾邮件且实际上是垃圾邮件的电子邮件所占的比例。\",\"假设有一个完美的模型，则其假正例数为零，因此精确率为 1.0。\",\"在实际正例数量非常少（例如总共 1-2 个示例）的不平衡数据集中，精确率作为指标的意义和实用性较低。\",\"随着假正例的减少，精确率会提高；随着假负例的减少，召回率会提高。提高分类阈值往往会减少假正例的数量并增加假负例的数量，而降低阈值则会产生相反的效果。因此，精确率和召回率通常呈现反向关系，提高其中一个会降低另一个。\",\"分类阈值: 模型输出的概率值大于某个值时，模型才会将该样本分类为正类。\"]},\"447\":{\"h\":\"指标的选择和权衡\",\"t\":[\"在评估模型和选择阈值时，您选择优先考虑的指标取决于特定问题的成本、收益和风险。在垃圾邮件分类示例中，通常最好优先考虑召回率（抓取所有垃圾邮件）或准确率（尝试确保被标记为垃圾邮件的电子邮件实际上是垃圾邮件），或者在达到某个最低准确性水平的情况下，兼顾这两者。\",\"指标\",\"指南\",\"准确率\",\"作为平衡数据集的模型训练进度/收敛情况的粗略指标。对于模型效果，请仅与其他指标搭配使用。避免使用不平衡的数据集。考虑使用其他指标。\",\"召回率（真正例率）\",\"当假负例的代价高于假正例时使用，有病的人不能诊断为健康。\",\"假正例率\",\"当假正例的代价高于假负例时使用，误报很可怕。\",\"精确率\",\"当正例预测的准确性非常重要时，请使用此方法。\"]},\"448\":{\"h\":\"F1 得分\",\"t\":[\"F1 得分是精确率和召回率的调和平均数（一种平均值）。\",\"在数学上，它可按下式计算：\",\"此指标可平衡精确率和召回率的重要性，对于类别不平衡的数据集，优先于准确率。当精确率和召回率均为 1.0 的满分时，F1 得分也会为 1.0 的满分。更广泛地说，当精确率和召回率的值接近时，F1 得分也会接近它们的值。当精确率和召回率相差很大时，F1 将与较差的指标相似。\"]},\"449\":{\"h\":\"ROC 曲线和 AUC\",\"t\":[\"上一部分介绍了一系列模型指标，所有这些指标都是基于单个分类阈值值计算得出的。但是，如果您想评估模型在所有可能阈值下的质量，则需要使用不同的工具。\"]},\"450\":{\"h\":\"ROC (Receiver Operating Characteristic)\",\"t\":[\"ROC 曲线直观地显示了所有阈值下的模型性能。名称的长版本“接收器操作特性”源自二战雷达检测。\",\"绘制 ROC 曲线的方法是：计算每个可能的阈值（在实践中，是按选定的间隔）的真正例率 (TPR) 和假正例率 (FPR)，然后将 TPR 与 FPR 绘制到图表中。\",\"完美的模型在某个阈值下的 TPR 为 1.0，FPR 为 0.0，如果忽略所有其他阈值，则可以用 (0, 1) 点表示，也可以用以下方式表示：\",\"图 1. 假设的理想模型的 ROC 和 AUC\"]},\"451\":{\"h\":\"AUC （曲线下面积）\",\"t\":[\"ROC 曲线下面积 (AUC) 表示，如果给定随机选择的正例和负例，模型将正例排在负例之上的概率。\",\"上面的完美模型包含边长为 1 的正方形，其曲线下面积 (AUC) 为 1.0。这意味着，模型将随机选择的正例正确排在随机选择的负例之上的概率为 100%。\",\"更具体地说，AUC 为 1.0 的垃圾邮件分类器始终会为随机垃圾邮件分配比随机合规电子邮件更高的垃圾邮件概率。每封电子邮件的实际分类取决于您选择的阈值。\",\"对于二元分类器，如果模型的效果与随机猜测或抛硬币的效果完全一样，则其 ROC 曲线为从 (0,0) 到 (1,1) 的对角线。AUC 为 0.5，表示正确对随机正例和负例进行排名的概率为 50%。\",\"在垃圾邮件分类器示例中，AUC 为 0.5 的垃圾邮件分类器仅在 50% 的情况下会将随机垃圾邮件的垃圾邮件概率设为高于随机合法邮件的垃圾邮件概率。\",\"图 2. 完全随机猜测的 ROC 和 AUC\"]},\"452\":{\"h\":\"精确率与召回率曲线\",\"t\":[\"如果数据集在类别之间大致平衡，AUC 和 ROC 非常适合比较模型。当数据集不均衡时，准确率-召回率曲线 (PRC) 和这些曲线下的面积可以更好地直观比较模型性能。精确率/召回率曲线的创建方法是，在 y 轴上绘制精确率，在 x 轴上绘制所有阈值下的召回率。\",\"图 3. 精确率与召回率曲线\"]},\"453\":{\"h\":\"用于选择模型和阈值的 AUC 和 ROC\",\"t\":[\"AUC 是比较两个不同模型性能的有效衡量指标，前提是数据集大致平衡。曲线下面积较大的模型通常是更好的模型。\",\"图 4. 两个假设模型的 ROC 和 AUC。右侧曲线的 AUC 较高，表示该模型优于左侧曲线对应的模型。\",\"ROC 曲线上最接近 (0,1) 的点表示给定模型效果最佳的阈值范围。我们选择的阈值取决于哪个指标对特定用例而言最重要。请考虑下图中的点 A、B 和 C，每个点都代表一个阈值：\",\"图 5. 三个标记的点，表示阈值。\",\"如果假正例（误报）的代价很高，则可能有必要选择 FPR 较低的阈值（例如 A 点），即使 TPR 会降低也是如此。反之，如果假正例成本较低，而假负例（漏掉的真正例）成本较高，则点 C 的阈值（可最大限度地提高 TPR）可能更为合适。如果费用大致相当，点 B 在 TPR 和 FPR 之间可能提供最佳平衡。\"]},\"454\":{\"h\":\"数学知识点\",\"t\":[\"数学知识点\"]},\"455\":{\"h\":\"协方差矩阵\",\"t\":[\"协方差是两个变量“是否一起变化”的度量:\",\"如果两个变量 一起变大或一起变小，协方差是正的；\",\"如果一个变量变大时另一个变小，协方差是负的；\",\"如果两个变量 无关，协方差接近 0。\",\"数学定义（以两个变量为例）:\",\"直观上，它表示：\",\"“X 和 Y 的偏离平均值的乘积”的期望。\",\"扩展到多个变量：协方差矩阵\",\"如果你有 多个变量（如 ），你就可以把它们两两之间的协方差，组成一个 矩阵，这个矩阵就叫：\",\"协方差矩阵的结构，以三个变量为例（比如身高、体重、年龄）：\",\"注意：\",\"对角线上的元素：，也就是每个变量自己的方差。\",\"非对角线上的元素：表示变量之间的相关性（协方差）。\",\"这个矩阵是 对称的（因为 ）。\",\"图像直观理解（二维协方差矩阵），如果我们画出一个二维正态分布：\",\"当两个变量 不相关，协方差 = 0 → 分布是一个 圆形。\",\"当两个变量 正相关，协方差 > 0 → 分布是一个 沿对角线方向拉长的椭圆。\",\"当两个变量 负相关，协方差 < 0 → 椭圆朝反对角线方向倾斜。\",\"在深度学习与生成模型中，协方差矩阵可以用来：\",\"场景\",\"用法\",\"多元高斯分布\",\"表达不同维度之间的“联合关系”\",\"高斯混合模型（GMM）\",\"不同类别的“形状”和“方向”由协方差控制\",\"马氏距离\",\"衡量点与均值之间的距离，但考虑变量相关性\",\"主成分分析（PCA）\",\"通过协方差矩阵找出“主要变化方向”（特征值分解）\",\"高斯过程（GP）\",\"协方差函数定义样本之间的相似性结构\",\"一个例子帮助理解，假设我们有如下样本（身高和体重）：\",\"人\",\"身高（cm）\",\"体重（kg）\",\"A\",\"170\",\"65\",\"B\",\"180\",\"75\",\"C\",\"160\",\"55\",\"先计算每一维的均值，再计算协方差矩阵（不展开计算细节）后，你会得到：\",\"这意味着：\",\"身高和体重的方差都为 100；\",\"协方差为 100，说明它们强烈正相关。\",\"总结:\",\"名词\",\"含义\",\"协方差（cov）\",\"度量两个变量是否同步变化\",\"协方差矩阵（）\",\"所有变量两两之间协方差的矩阵表示\",\"对角线\",\"每个变量自己的方差\",\"非对角线\",\"表示不同变量之间的线性相关性\",\"应用\",\"多元高斯、高斯过程、GMM、PCA、马氏距离等\"]},\"456\":{\"h\":\"马氏距离\"},\"457\":{\"h\":\"欧几里得距离（Euclidean Distance）\",\"t\":[\"公式是：\",\"直观理解：\",\"它就是我们平时量两个点之间“直线距离”的方法。\",\"它对每个维度的偏差一视同仁，不考虑各维度数据的分布特征。\",\"换句话说，哪怕某个维度的数据本来波动很大（方差大），它在这个维度上的偏差也会被直接算入距离，导致整体距离变大。\"]},\"458\":{\"h\":\"马氏距离（Mahalanobis Distance）\",\"t\":[\"公式是：\",\"其中 是数据的协方差矩阵。\",\"直观理解：\",\"它不仅考虑两个点之间的差异，还考虑数据在各个维度上的方差大小和维度间的相关性。\",\" 是协方差矩阵的逆，起到了“标准化”的作用，把数据的不同尺度和相关性都考虑进来。\"]},\"459\":{\"h\":\"尺度差异性\",\"t\":[\"欧几里得距离计算方式：\",\"它直接对每个维度的偏差做平方加总。\",\"如果某个维度的数值范围很大（如年龄：0~100），另一个维度很小（如身高标准化后波动在 ），那么前者的变化会主导整个距离。\",\"这会导致尺度大的特征“支配”了距离判断，从而导致偏差。\",\"马氏距离定义如下：\",\"其中 是样本协方差矩阵， 是它的逆矩阵。\",\"假设我们有一个样本点 ，均值是 ，方差是 ，那么协方差矩阵就是：\",\"此时马氏距离变为：\",\"👉 这就是我们熟悉的 标准差单位距离（z-score 距离）。\",\"结论：马氏距离会自动把不同特征的偏差按标准差进行“标准化”。\",\"在高维空间中：\",\" 是一个 的协方差矩阵；\",\"它包含了每个特征的方差（主对角线），和特征间的协方差（非对角元素）；\",\" 相当于一个“加权标准化器”，对不同方向的偏差做缩放和正交旋转。\",\"设两维特征的协方差矩阵是：\",\"说明：\",\"第一个维度方差是 100，第二个维度方差是 1；\",\"马氏距离中对第一个维度的偏差乘上 ，惩罚少；\",\"第二个维度的偏差乘上 1，惩罚多。\",\"这就实现了 对每个维度根据尺度差异进行惩罚调整 —— 偏差大但常见的就不判定为“远”，偏差小但罕见的要严惩。\",\"你可以把马氏距离想成是：\",\"“在考虑数据分布形状后，重新拉直空间、拉平数据”的距离度量。\",\"原始空间中，数据可能沿某个方向拉长、压扁；\",\"马氏距离通过协方差矩阵逆变换，把这些方向“拉回正态”；\",\"变换后再用欧几里得距离度量 —— 就能反映“真实统计意义上的远近”。\"]},\"460\":{\"h\":\"总结\",\"t\":[\"欧几里得距离适合所有维度的尺度和方差差不多时，或者你不在意尺度差异。\",\"马氏距离适合不同维度尺度差别大、方差差异大且可能相关的情况，更能反映真实的“统计距离”。\"]},\"461\":{\"h\":\"注意力图可视化\",\"t\":[\"注意力图可视化\"]},\"462\":{\"h\":\"注意力图可视化\"},\"463\":{\"h\":\"ViT 模型\",\"t\":[\"本文基于 DINO 论文开源的代码实现进行讲解: visualize_attention.py\",\"步骤如下:\",\"下载预先训练的模型权重: https://github.com/facebookresearch/dino\",\"指定待处理图像路径后，对输入图像进行预处理\",\" # 图像预处理：调整大小、转换为张量、标准化 transform = pth_transforms.Compose([ pth_transforms.Resize(args.image_size), pth_transforms.ToTensor(), pth_transforms.Normalize((0.485, 0.456, 0.406), (0.229, 0.224, 0.225)), ]) img = transform(img) # 确保图像尺寸能被 patch_size 整除（减去余数，确保可以整除) w, h = img.shape[1] - img.shape[1] % args.patch_size, img.shape[2] - img.shape[2] % args.patch_size img = img[:, :w, :h].unsqueeze(0) # 增加批次维度\",\"计算输出特征图的尺寸\",\" # 计算特征图的尺寸 w_featmap = img.shape[-2] // args.patch_size h_featmap = img.shape[-1] // args.patch_size\",\"获取最后一层的自注意力权重矩阵 & 获取 CLS Token 对其他 Token 的注意力权重\",\" # 获取最后一层的自注意力权重 attentions = model.get_last_selfattention(img.to(device)) nh = attentions.shape[1] # 注意力头数量 , [b,h,seq,seq] # 只保留输出 patch 的注意力权重 (排除 [CLS] token) # attentions[0, :, 0, 1:] 表示： # - 0: 批次索引 # - : : 所有注意力头 # - 0: 输出位置 (第一个 patch) # - 1: 从第二个位置开始 (排除 [CLS] token) attentions = attentions[0, :, 0, 1:].reshape(nh, -1)\",\"class Attention(nn.Module): ... def forward(self, x): B, N, C = x.shape qkv = self.qkv(x).reshape(B, N, 3, self.num_heads, C // self.num_heads).permute(2, 0, 3, 1, 4) q, k, v = qkv[0], qkv[1], qkv[2] attn = (q @ k.transpose(-2, -1)) * self.scale attn = attn.softmax(dim=-1) attn = self.attn_drop(attn) x = (attn @ v).transpose(1, 2).reshape(B, N, C) x = self.proj(x) x = self.proj_drop(x) return x, attn # 获取最后一层的自注意力权重矩阵 attn\",\"多头自注意力中每个Head会根据分配给自己的这部分特征维度，计算当前位置和其他位置的特征相似度，从而得到一个相似度权重矩阵。比如: Head1根据身高计算相似度，Head2根据体重计算相似度，Head3根据年龄计算相似度，分别得到三个从不同视角下计算出来的相似度矩阵。\",\"CLS Token 的目标是抽取有利于当前学习任务的图像重要特征信息汇总，因此我们重点关注每个头对应的注意力权重矩阵上，CLS Token 对图像中哪些 patch 投注了更高的注意力，就说明这些区域对当前学习任务特别重要 (每个头关注的区域或许不太一样，因为每个头只能根据分配给自己的这部分特征，决定哪些区域更重要)。\",\"生成注意力热力图\",\" # 重塑注意力权重为 2D 特征图 attentions = attentions.reshape(nh, w_featmap, h_featmap) # 插值到原始图像尺寸，使用最近邻插值保持 patch 边界清晰 attentions = nn.functional.interpolate(attentions.unsqueeze(0), scale_factor=args.patch_size, mode=\\\"nearest\\\")[0].cpu().numpy()\",\"可视化出每个头对应的注意力热力图，这样可以看出每个头分别关注图像的哪部分区域\",\" # 保存每个注意力头的热力图 for j in range(nh): fname = os.path.join(args.output_dir, f\\\"attn-head{j}.png\\\") plt.imsave(fname=fname, arr=attentions[j], format='png') print(f\\\"{fname} 已保存。\\\")\",\"如果我们希望强化高注意力权重区域，我们便可以采样DINO模型代码中采用的注意力掩码矩阵技巧，将注意力图中注意力权重大于指定阈值的区域进行高亮显示; 注意力掩码矩阵生成逻辑如下所示:\",\" if args.threshold is not None: # 只保留一定百分比的注意力质量 val, idx = torch.sort(attentions) val /= torch.sum(val, dim=1, keepdim=True) # 归一化 cumval = torch.cumsum(val, dim=1) # 累积和 th_attn = cumval > (1 - args.threshold) # 阈值化 # 恢复原始顺序 idx2 = torch.argsort(idx) for head in range(nh): th_attn[head] = th_attn[head][idx2[head]] # 重塑为 2D 特征图 th_attn = th_attn.reshape(nh, w_featmap, h_featmap).float() # 插值到原始图像尺寸(注意力掩码矩阵) th_attn = nn.functional.interpolate(th_attn.unsqueeze(0), scale_factor=args.patch_size, mode=\\\"nearest\\\")[0].cpu().numpy()\",\"当执行完插值得到原始图像尺寸大小时，其实就得到了注意力掩码矩阵，最后便是根据注意力掩码矩阵应用在原图像上，即将掩码矩阵中值为1处，进行高亮即可，效果如下:\"]},\"464\":{\"h\":\"语义分割中常用的损失函数\",\"t\":[\"语义分割中常用的损失函数\"]},\"465\":{\"h\":\"语义分割\",\"t\":[\"语义分割是计算机视觉领域中的一项任务，旨在将图像中的每个像素分类为不同的语义类别。与对象检测任务不同，语义分割不仅需要识别图像中的物体，还需要对每个像素进行分类，从而实现对图像的细粒度理解和分析。\",\"语义分割可以被看作是像素级别的图像分割，其目标是为图像中的每个像素分配一个特定的语义类别标签。每个像素都被视为图像的基本单位，因此语义分割可以提供更详细和准确的图像分析结果。\",\"语义分割 vs 分类 :\",\"在语义分割任务中，由于需要对每个像素进行分类，因此需要使用像素级别的损失函数。\",\"语义分割任务中，图像中各个类别的像素数量通常不均衡，例如背景像素可能占据了大部分。\",\"语义分割任务需要对图像中的每个像素进行分类，同时保持空间连续性。\"]},\"466\":{\"h\":\"损失函数\"},\"467\":{\"h\":\"Dice Loss\",\"t\":[\"Dice Loss 是一种常用于语义分割任务的损失函数，尤其在目标区域较小、类别不平衡（class imbalance）的情况下表现优异。它来源于 Dice 系数（Dice Coefficient） ，又称为 Sørensen-Dice 系数 ，是衡量两个样本集合之间重叠程度的一种指标。\",\"Dice 系数衡量的是预测掩码与真实标签之间的相似性，公式如下：\",\"其中：\",\" ：模型预测出的功能区域（如经过 sigmoid 后的概率值）；\",\" ：Ground Truth 掩码（二值化或软标签）；\",\" ：预测为正类且实际也为正类的部分（交集）；\",\" ：预测和真实中所有正类区域之和；\",\"⚠️ 注意：Dice 系数范围是 [0, 1]，越大越好。\",\"Dice Loss 为了将其作为损失函数使用，我们通常取其补集：\",\"有时也会加入一个平滑项 ϵ 防止除以零：\",\"Dice Loss 的优势:\",\"优势\",\"描述\",\"对类别不平衡不敏感,更关注“有没有覆盖正确区域”，而不是“有多少点被正确分类”\",\"不像 BCE Loss 那样对负样本过多敏感\",\"直接优化 IoU 的替代指标\",\"Dice 和 IoU 表现类似，但更易梯度下降\",\"支持 soft mask 输入\",\"可处理连续概率值，不需要先 threshold\",\"更关注整体区域匹配\",\"而不是逐点分类\",\"代码实现:\",\"class DiceLoss(nn.Module): def __init__(self, weight=None, size_average=True): \\\"\\\"\\\" 初始化函数，支持加权和平均损失。 参数: weight (Tensor): 各类别的权重（可选） size_average (bool): 是否对 batch 中的样本取平均 loss \\\"\\\"\\\" super(DiceLoss, self).__init__() # 该参数未在当前代码中使用，但保留接口以备后续扩展 self.weight = weight # 控制是否对 batch 内 loss 取均值或求和 self.size_average = size_average def forward(self, inputs, targets, smooth=1): \\\"\\\"\\\" 前向传播函数，计算 Dice Loss。 参数: inputs (Tensor): 模型输出的预测值（logits 或 raw output），形状为 [B, N] targets (Tensor): 真实标签（ground truth mask），形状为 [B, N] smooth (float): 平滑项，防止除零错误，默认为 1 返回: dice_loss (Tensor): 计算得到的 Dice Loss \\\"\\\"\\\" # 如果你的模型最后没有 sigmoid 层，则需要在这里激活，否则应注释掉这行 inputs = F.sigmoid(inputs) # 将 logits 映射到 [0,1] 区间 # 将输入展平成一维张量，便于后续计算 # inputs: [B*N] # targets: [B*N] inputs = inputs.view(-1) targets = targets.view(-1) # 计算交集：预测与 GT 的重合部分 intersection = (inputs * targets).sum() # 计算 Dice Coefficient，加入 smooth 防止除以零 dice_score = (2. * intersection + smooth) / (inputs.sum() + targets.sum() + smooth) # 返回 Dice Loss，用 1 - Dice Coefficient # 值越小表示匹配越好 return 1 - dice_score\"]},\"468\":{\"h\":\"BCE-Dice Loss\",\"t\":[\"BCE-Dice Loss是将Dice Loss和标准的二元交叉熵（Binary Cross-Entropy, BCE）损失结合在一起的一种损失函数，通常用于分割模型中。它结合了两种 loss 的优点：\",\"BCE Loss ：关注每个点的分类误差；\",\"Dice Loss ：关注整体区域匹配度；\",\"Binary Cross Entropy Loss（BCE Loss）\",\"公式（逐点）：\",\"其中：\",\"：真实标签（binary 或 soft mask）；\",\"：模型输出的概率值；\",\"特点：\",\"对每个点单独计算分类误差；\",\"强调预测与 GT 的一致性；\",\"在类别平衡时效果好，但在前景远少于背景时容易偏向负样本；\",\"Dice Loss\",\"公式（简化版）：\",\"其中：\",\"：预测概率；\",\"：真实标签；\",\"：平滑项，防止除以零；\",\"特点：\",\"不依赖绝对数量，而是关注预测和 GT 的交并比；\",\"更适合前景极少的小区域识别；\",\"能缓解类别不平衡问题；\",\"为什么要把它们结合起来？\",\"模型\",\"缺陷\",\"补充方式\",\"BCE Loss\",\"对前景响应弱，易受类别不平衡影响\",\"加入 Dice Loss 增强区域匹配\",\"Dice Loss\",\"对单个点的分类精度不够敏感\",\"加入 BCE Loss 提高逐点判别能力\",\"组合后的优势：\",\"优势\",\"描述\",\"✔️ 抗类别不平衡能力强\",\"Dice Loss 起主导作用\",\"✔️ 对细节更敏感\",\"BCE Loss 提升边缘识别精度\",\"✔️ 支持 soft mask 输入\",\"可处理连续值掩码\",\"✔️ 更稳定地收敛\",\"两者互补，避免训练震荡\",\"代码实现:\",\"class DiceBCELoss(nn.Module): def __init__(self, weight=None, size_average=True): \\\"\\\"\\\" 初始化函数，构建一个组合损失函数 Dice + BCE。 参数: weight (Tensor): 可选参数，用于类别加权； size_average (bool): 是否对 batch 内样本取平均 loss（已弃用）； \\\"\\\"\\\" super(DiceBCELoss, self).__init__() # 这里暂时未使用 weight 和 size_average，保留接口以备扩展 def forward(self, inputs, targets, smooth=1): \\\"\\\"\\\" 前向传播函数，计算预测输出与真实标签之间的 Dice Loss 与 BCE Loss 的加权和。 参数: inputs (Tensor): 模型输出的 logits 或 raw 分数，形状为 [B, N] targets (Tensor): 真实掩码（ground truth mask），形状为 [B, N] smooth (float): 平滑项，防止除零错误，默认为 1 返回: Dice_BCE (Tensor): Dice + BCE 组合损失值 \\\"\\\"\\\" # 如果模型最后没有 sigmoid 层，这里需要激活 # 如果已经包含 sigmoid，则应注释掉这一行 inputs = F.sigmoid(inputs) # 将输入映射到概率空间 [0, 1] # 将输入和目标展平成一维张量，便于后续计算 # inputs: [B*N] # targets: [B*N] inputs = inputs.view(-1) targets = targets.view(-1) # 计算交集：预测值和真实值都为 1 的区域 intersection = (inputs * targets).sum() # 计算 Dice Loss： # Dice Coefficient = (2 * intersection) / (inputs_sum + targets_sum) # Dice Loss = 1 - Dice Coefficient inputs_sum = inputs.sum() targets_sum = targets.sum() dice_score = (2. * intersection + smooth) / (inputs_sum + targets_sum + smooth) dice_loss = 1 - dice_score # 计算 Binary Cross Entropy Loss（BCE） # 注意：F.binary_cross_entropy 默认要求 inputs 已经经过 sigmoid BCE = F.binary_cross_entropy(inputs, targets, reduction='mean') # 组合损失：BCE + Dice Loss Dice_BCE = BCE + dice_loss return Dice_BCE\"]},\"469\":{\"h\":\"Jaccard/Intersection over Union (IoU) Loss\",\"t\":[\"Jaccard Loss，也称为Intersection over Union (IoU) Loss，是一种常用的损失函数，用于语义分割任务中评估模型的分割结果与真实分割标签之间的相似性。它基于Jaccard指数（Jaccard Index），也称为 交并比（Intersection over Union, IoU）指标，用于度量两个集合之间的重叠程度。\",\"Jaccard Index（IoU）\",\"其中：\",\"：模型输出的概率值或二值化结果；\",\"：ground truth 掩码；\",\"分子是预测和 GT 的交集；\",\"分母是两者的并集；\",\"⚠️ IoU 值 ∈ [0, 1]，越大越好。\",\"Jaccard Loss（IoU Loss）\",\"为了将 IoU 转换为可优化的损失函数，我们取其补集：\",\"这样，损失越小表示预测越接近真实标签。\",\"为了避免除以零，通常加入平滑项 ：\",\"Jaccard Loss 有以下几个优点：\",\"特性\",\"描述\",\"✔️ 对类别不平衡不敏感\",\"不像 BCE Loss 那样偏向背景点\",\"✔️ 关注整体区域匹配\",\"强调预测与 GT 的空间一致性\",\"✔️ 更适合评估边界模糊区域\",\"如功能区域边缘不确定性较高\",\"与其他 Loss 的对比\",\"损失函数\",\"是否支持 soft mask\",\"是否对类别不平衡敏感\",\"是否直接优化 IoU\",\"输出范围\",\"BCE Loss\",\"❌ 否（需二值化）\",\"✅ 是\",\"❌ 否\",\"[0, ∞)\",\"Focal Loss\",\"✅ 是（加权）\",\"✅ 是（缓解）\",\"❌ 否\",\"[0, ∞)\",\"Dice Loss\",\"✅ 是\",\"✅ 是\",\"近似于 IoU\",\"[0, 1]\",\"Jaccard (IoU) Loss\",\"✅ 是\",\"✅ 是\",\"✅ 是\",\"[0, 1]\",\"虽然 Dice Loss 在实际训练中更稳定，但 Jaccard Loss 更贴近最终评估指标（IoU），适合在推理阶段作为验证标准。\",\"代码实现:\",\"class IoULoss(nn.Module): def __init__(self, weight=None, size_average=True): \\\"\\\"\\\" 初始化函数，构建一个基于 IoU（交并比）的损失函数。 参数: weight (Tensor): 可选参数，用于类别加权（未使用） size_average (bool): 是否对 batch 内样本取平均 loss（已弃用） \\\"\\\"\\\" super(IoULoss, self).__init__() # weight 和 size_average 在此实现中未使用，保留接口以备后续扩展 def forward(self, inputs, targets, smooth=1): \\\"\\\"\\\" 前向传播函数，计算预测输出与真实标签之间的 IoU Loss。 参数: inputs (Tensor): 模型输出的原始 logit 或经过 sigmoid 的概率值； 形状为 [B, N] targets (Tensor): ground truth 掩码，形状为 [B, N] smooth (float): 平滑项，防止除零错误，默认为 1 返回: iou_loss (Tensor): 计算得到的 IoU Loss \\\"\\\"\\\" # 如果模型最后没有 sigmoid 层，则在这里激活 # 如果已经包含 sigmoid，则应注释掉这一行 inputs = torch.sigmoid(inputs) # 将输入映射到 [0,1] 区间 # 将输入和目标展平成一维张量便于计算 # inputs: [B*N] # targets: [B*N] inputs = inputs.view(-1) targets = targets.view(-1) # 计算交集（Intersection），等价于 TP（True Positive） intersection = (inputs * targets).sum() # 计算并集：Union = input + target - intersection total = (inputs + targets).sum() union = total - intersection # 计算 IoU Score，加入平滑项防止除以零 iou_score = (intersection + smooth) / (union + smooth) # IoU Loss = 1 - IoU score，这样越接近 1，loss 越小 iou_loss = 1. - iou_score return iou_loss\"]},\"470\":{\"h\":\"Focal Loss\",\"t\":[\"Focal Loss 是一种针对类别不平衡（Class Imbalance）问题的损失函数改进方案，由何恺明团队在2017年论文《Focal Loss for Dense Object Detection》中提出，主要用于解决目标检测任务中前景-背景类别极端不平衡的问题（如1:1000）。其核心思想是通过调整难易样本的权重，使模型更关注难分类的样本。\",\"Focal Loss 基于交叉熵损失进行扩展，将样本的权重进行动态调整。与交叉熵损失函数相比，Focal Loss引入了一个衰减因子，其中 pt 是预测的概率值。这个衰减因子能够使得易分类的样本（ pt较高 ）的权重降低，从而减少对分类正确样本的贡献。\",\"核心思想:\",\"(1) 类别不平衡的问题\",\"在分类任务中（尤其是目标检测），负样本（背景）往往远多于正样本（目标），导致：\",\"模型被大量简单负样本主导，难以学习有效特征。\",\"简单样本的梯度贡献淹没难样本的梯度。\",\"(2) Focal Loss 的改进\",\"降低易分类样本的权重：对模型已经分类正确的样本（高置信度）减少损失贡献。\",\"聚焦难分类样本：对分类错误的样本（低置信度）保持高损失权重。\",\"Focal Loss 基于标准交叉熵损失（Cross-Entropy Loss）改进而来。\",\"(1) 标准交叉熵损失（CE Loss）\",\"其中：\",\"p 是模型预测的概率（经过sigmoid/softmax）。\",\"y 是真实标签（0或1）。\",\"(2) Focal Loss 定义\",\"：类别平衡权重（通常），用于平衡正负样本数量差异。\",\"：调节因子（通常），控制难易样本的权重衰减程度。\",\"γ 参数用于抑制容易分类的样本，而 α 参数用于平衡正负类别的权重。两者解决的是不同维度的问题：\",\"α：防止前景点（功能区域）被背景淹没，解决数据集中“类别数量不平衡”的问题（数据集级别）；\",\"γ：防止模型只关注简单样本，忽略难分类样本，解决模型训练时“简单样本主导梯度”的问题（样本级别）；\",\"综上，先通过 α 平衡类别数量，再通过 γ 抑制简单样本，两者协同提升模型性能。\",\"关键参数的作用:\",\"参数\",\"作用\",\"典型值\",\"控制难易样本权重：• ：退化为CE Loss• ：显著抑制简单样本\",\"0.5 ~ 5\",\"平衡正负样本数量：• ：正样本较少时增加权重\",\"0.25 ~ 0.75\",\"难样本vs易样:\",\"易分类样本（如 p=0.9 ）： 接近0，损失被大幅降低。\",\"难分类样本（如 p=0.1 ）： 接近1，损失几乎不受影响。\",\"假设两个正样本：\",\"易样本：（模型已自信分类）\",\"标准 CE Loss：\",\"Focal Loss（）：损失权重降低 100 倍！\",\"难样本：（模型分类错误）\",\"标准 CE Loss：\",\"Focal Loss（）：损失权重仅降低 20%。\",\"应用场景：\",\"目标检测（如RetinaNet）： 解决前景（目标）与背景的极端不平衡问题。\",\"医学图像分割： 病灶区域像素远少于正常组织。\",\"任何类别不平衡的分类任务： 如欺诈检测、罕见疾病诊断等。\",\"优缺点:\",\"优点\",\"缺点\",\"显著提升难样本的分类性能\",\"需调参（）\",\"抑制简单样本的梯度主导\",\"对噪声标签敏感\",\"兼容大多数分类模型\",\"计算量略高于CE Loss\",\"Focal Loss 通过 动态调整样本权重，使模型聚焦难分类样本。\",\"参数选择：\",\"：一般从2开始调优（值越大，简单样本抑制越强）。\",\"：根据正负样本比例调整（如正样本少则增大 ）。\",\"适用场景：类别不平衡越严重，Focal Loss 效果越显著。\",\"代码实现:\",\"# 设置全局参数（可调） ALPHA = 0.8 # 控制正样本（目标点）与负样本（非目标点）之间的损失权重； # 若前景点稀疏（如 grasping area），建议设为较高值（如 0.25~0.75）； GAMMA = 2 # 聚焦参数，用于抑制易分类样本，放大难分类样本的影响； class FocalLoss(nn.Module): def __init__(self, weight=None, size_average=True): \\\"\\\"\\\" 初始化函数，构建一个基于 BCE 的改进版 Focal Loss。 参数: weight (Tensor): 可选参数，用于类别加权（未使用）； size_average (bool): 是否对 batch 内样本取平均 loss（已弃用）； \\\"\\\"\\\" super(FocalLoss, self).__init__() # 当前实现未使用 weight 和 size_average，保留接口以备扩展 def forward(self, inputs, targets, alpha=ALPHA, gamma=GAMMA, smooth=1): \\\"\\\"\\\" 前向传播函数，计算预测输出与真实标签之间的 Focal Loss。 参数: inputs (Tensor): 模型输出的原始 logit 或经过 sigmoid 的概率值； 形状为 [B, N]（batch_size × 点数） targets (Tensor): ground truth 掩码，形状为 [B, N] alpha (float): 平衡因子，控制正类（功能区域）和负类（非功能区域）之间的损失权重； 前景点少 → alpha 高（如 0.75），防止被背景淹没； gamma (float): 聚焦参数，抑制 easy examples，放大 hard examples； smooth (float): 平滑项，防止除零错误，默认为 1 返回: focal_loss (Tensor): 计算得到的 Focal Loss 值 \\\"\\\"\\\" # 如果模型最后没有 sigmoid 层，则在这里激活 inputs = torch.sigmoid(inputs) # 将输入展平便于后续计算 # inputs: [B*N], 表示每个点属于功能区域的概率； # targets: [B*N], 表示每个点是否属于目标功能区域（soft/hard label）； inputs = inputs.view(-1) targets = targets.view(-1) # Step 1: 计算 Binary Cross Entropy Loss（BCE） # 这里使用 'mean' reduction，表示对 batch 内取平均 ce_loss = F.binary_cross_entropy(inputs, targets, reduction='mean') # Step 2: 计算 pt = exp(-ce_loss)，即 e^{-ce_loss} pt = torch.exp(-ce_loss) # shape: scalar # Step 3: 按类别分配 alpha alpha = torch.where(targets == 1, alpha, 1 - alpha) # Step 4: 构建 Focal Weight： # focal_weight = α * (1 - pt)^γ # 目的是：让难分类样本获得更大的 loss 权重，从而引导模型学习更多语义信息 focal_weight = alpha * (1 - pt) ** gamma # Step 5: 最终 Focal Loss = focal_weight × ce_loss focal_loss = focal_weight * ce_loss return focal_loss\",\"关于计算 p_t（模型对真实类别的预测概率）代码解析:\",\"pt = torch.exp(-ce_loss) # p_t = softmax(output)[target_class]\",\"ce_loss = F.cross_entropy(...) → 这是交叉熵损失；\",\"-ce_loss → 负号；\",\"torch.exp(-ce_loss) → 求 exp（自然指数）；\",\"但实际上这行代码的意图是计算 ，即模型对真实类别的预测概率（confidence）, 这里采用的方法是一种“技巧性近似”。对于一个样本，交叉熵损失为：\",\"所以：\",\"pt = torch.exp(-ce_loss)\",\"这个表达式其实是通过 CE loss 反推出来的 ，因为：\"]},\"471\":{\"h\":\"Tversky Loss\",\"t\":[\"Tversky Loss的设计灵感来自Tversky指数（Tversky index），它是一种用于度量集合之间相似性的指标，同时也是 Dice Loss 的一种泛化形式，通过引入两个可调节参数来增强模型对假阳性（False Positives）和假阴性（False Negatives）的敏感度控制。\",\"Tversky Loss 的核心是 Tversky 系数：\",\"然后损失就是：\",\"其中：\",\"TP ：真阳性（True Positive）= 预测为正类，且真实也为正类的样本数\",\"FP ：假阳性（False Positive）= 预测为正类，但真实是负类的样本数\",\"FN ：假阴性（False Negative）= 预测为负类，但真实是正类的样本数\",\"α 和 β 是两个可调节的超参数\",\"α 越大，FP 的影响就越大 → 模型更不喜欢“误报”\",\"β 越大，FN 的影响就越大 → 模型更不喜欢“漏报”\",\"如果你设置 α>β ，说明你更讨厌“误检”\",\"如果你设置 β>α ，说明你更讨厌“漏检”\",\"分母中的 TP+α⋅FP+β⋅FN 构成了一个“加权惩罚项”\",\"例如：\",\"α=0.3, β=0.7 → 更重视召回率（Recall）\",\"α=0.7, β=0.3 → 更重视精确率（Precision）\",\"当 alpha=beta=0.5 时，Tversky指数简化为Dice系数，该系数也等于F1得分。\",\"当 alpha=beta=1 时，公式转化为Tanimoto系数，而当 alpha+beta=1 时，得到一组F-beta得分。\",\"# 设置默认参数：当 alpha = beta = 0.5 时，等价于 Dice Loss ALPHA = 0.5 # 控制假阳性（FP）的权重 BETA = 0.5 # 控制假阴性（FN）的权重 class TverskyLoss(nn.Module): def __init__(self, weight=None, size_average=True): \\\"\\\"\\\" 初始化函数 参数： weight: 可选，类别权重（用于处理类别不平衡） size_average: 如果为 True，则返回所有样本损失的平均值 \\\"\\\"\\\" super(TverskyLoss, self).__init__() # 本类中不直接使用 weight 和 size_average，但保留它们作为接口兼容 self.weight = weight self.size_average = size_average def forward(self, inputs, targets, smooth=1, alpha=ALPHA, beta=BETA): \\\"\\\"\\\" 前向传播计算损失值 参数： inputs: 模型输出的预测结果（logits），形状如 (N, H, W) 或 (N, C, H, W) targets: 真实标签（ground truth），形状与 inputs 相同 smooth: 平滑系数，防止除以零 alpha: FP 的惩罚权重 beta: FN 的惩罚权重 返回： loss: 计算得到的 Tversky Loss \\\"\\\"\\\" # 如果模型最后一层没有 Sigmoid 激活函数，请取消下面这行注释 # 对输出应用 Sigmoid 函数，将 logits 转换为概率 [0,1] inputs = F.sigmoid(inputs) # 将输入和目标张量展平为一维，便于后续计算 TP、FP、FN inputs = inputs.view(-1) targets = targets.view(-1) # 真阳性（True Positive）：预测为正且实际也为正的像素数量 TP = (inputs * targets).sum() # 假阳性（False Positive）：预测为正但实际为负的像素数量 FP = ((1 - targets) * inputs).sum() # 假阴性（False Negative）：预测为负但实际为正的像素数量 FN = (targets * (1 - inputs)).sum() # 计算 Tversky 系数（相似度指标） # 分母中：TP + α·FP + β·FN Tversky = (TP + smooth) / (TP + alpha * FP + beta * FN + smooth) # 最终损失是 1 - Tversky，这样在训练中最小化损失就等于最大化重叠度 return 1 - Tversky\"]},\"472\":{\"h\":\"Lovasz Hinge Loss\",\"t\":[\"Lovasz Hinge Loss的设计思想是，在计算IoU得分之前，根据预测误差对预测结果进行排序，然后累积计算每个误差对IoU得分的影响。然后，将该梯度向量与初始误差向量相乘，以最大程度地惩罚降低IoU得分的预测结果。\",\"https://github.com/bermanmaxim/LovaszSoftmax\"]},\"473\":{\"h\":\"Combo Loss\",\"t\":[\"Combo Loss 是一种结合了多个损失函数优点的混合损失函数，特别适用于图像分割任务。它将 Dice Loss 和 交叉熵损失（CrossEntropy Loss） 相结合，并引入一个可调节的权重参数，使得模型在训练过程中可以更灵活地平衡这两部分损失。\",\"核心思想：\",\"Combo Loss = α × CrossEntropy + (1 - α) × Dice Loss\",\"或者更广义地：\",\"Combo Loss = α × 分类误差（CE）+ β × 区域重叠误差（Dice）\",\"其中 α + β = 1，α 控制分类误差的重要性，β 控制区域匹配误差的重要性。\",\"数学定义:\",\"假设我们有预测概率图 ，真实标签 ，那么：\",\"交叉熵损失（Binary Cross Entropy）：\",\"Dice Loss：\",\"Combo Loss 定义为：\",\"其中：\",\"：控制两个损失之间的权重比例\",\"若 ：仅使用交叉熵损失\",\"若 ：仅使用 Dice Loss\",\"为什么使用 Combo Loss:\",\"优势\",\"描述\",\"✔️ 兼顾像素级精度和区域重叠度\",\"CE 关注每个像素的分类准确性，Dice 关注整体区域匹配程度\",\"✔️ 对类别不平衡问题鲁棒\",\"在前景像素远少于背景像素时表现良好（如医学图像）\",\"✔️ 更稳定的训练过程\",\"避免单一损失可能带来的训练不稳定性\",\"✔️ 可调性强\",\"通过调整 α 参数，适应不同任务需求\",\"对比其他损失函数：\",\"损失函数\",\"是否关注像素分类？\",\"是否关注区域匹配？\",\"是否可调？\",\"是否适合类别不平衡？\",\"CrossEntropy Loss\",\"✅\",\"❌\",\"❌\",\"❌\",\"Dice Loss\",\"❌\",\"✅\",\"❌\",\"✅\",\"Tversky Loss\",\"❌\",\"✅ ✅\",\"✅\",\"✅ ✅\",\"Combo Loss\",\"✅ ✅\",\"✅\",\"✅\",\"✅ ✅\",\"代码实现:\",\"# 超参数设置说明： ALPHA = 0.5 # 控制交叉熵中正负样本的权重 # 如果 ALPHA < 0.5：对假阳性（FP）惩罚更重（更关注精确率） # 如果 ALPHA > 0.5：对假阴性（FN）惩罚更重（更关注召回率） CE_RATIO = 0.5 # 控制交叉熵损失和 Dice 损失之间的权重分配 # CE_RATIO 越大，交叉熵在总损失中的占比越高 class ComboLoss(nn.Module): def __init__(self, weight=None, size_average=True): \\\"\\\"\\\" 初始化函数 参数： weight: 可选，类别权重（用于处理类别不平衡） size_average: 如果为 True，则返回所有样本损失的平均值 \\\"\\\"\\\" super(ComboLoss, self).__init__() # 这里不直接使用 weight 和 size_average，但保留作为接口兼容 self.weight = weight self.size_average = size_average def forward(self, inputs, targets, smooth=1, alpha=ALPHA, beta=BETA, eps=1e-9): \\\"\\\"\\\" 前向传播计算 Combo Loss 参数： inputs: 模型输出的概率值（经过 Sigmoid），形状如 (N, H, W) targets: 真实标签，形状与 inputs 相同，值为 0 或 1 smooth: 平滑系数，防止除以零 alpha: 控制 FP/FN 的惩罚比例（用于交叉熵部分） eps: 防止 log(0) 出现的小常数 返回： combo_loss: 计算得到的 Combo Loss \\\"\\\"\\\" # 将输入和目标张量展平为一维，便于后续计算 inputs = inputs.view(-1) targets = targets.view(-1) # 计算 Dice Loss 所需的交集 intersection = (inputs * targets).sum() # Dice Score（区域匹配度） dice_score = (2. * intersection + smooth) / (inputs.sum() + targets.sum() + smooth) # 加入数值稳定性处理，防止 log(0) 出现 NaN # torch.clamp(x, min=a, max=b) 是 PyTorch 中的一个函数，用于将张量 x 中的每个元素限制在 [a, b] 区间内： # 这里把所有 inputs 中的值限制在区间 [eps, 1.0 - eps] 内，防止出现 0 或 1 的极端值。 inputs = torch.clamp(inputs, eps, 1.0 - eps) # 加权交叉熵损失（Weighted Cross Entropy） # 根据 ALPHA 参数调整正类和负类的权重 weighted_ce = - (ALPHA * targets * torch.log(inputs)) - ((1 - ALPHA) * (1 - targets) * torch.log(1 - inputs)) # 对损失求均值 weighted_ce = weighted_ce.mean() # Combo Loss 是交叉熵和 Dice Loss 的加权组合 # 注意：这里使用的是负的 Dice Score（因为要最小化损失） combo_loss = (CE_RATIO * weighted_ce) - ((1 - CE_RATIO) * dice_score) return combo_loss\",\"上面代码实现中使用的是加权交叉熵损失:\"]},\"474\":{\"h\":\"如何选择?\",\"t\":[\"任务需求：根据特定的分割任务的需求和特点，选择适合的损失函数。例如，对于类别不平衡的数据集，可以考虑使用Tversky Loss或Combo Loss等能够处理不平衡情况的损失函数。\",\"实验评估：在实验中，使用不同的损失函数进行训练，并评估它们在验证集或测试集上的性能。比较它们在IoU、准确率、召回率等指标上的表现，选择性能最佳的损失函数。\",\"超参数调整：一些损失函数具有额外的超参数，如Tversky Loss中的alpha和beta，可以通过调整这些超参数来进一步优化损失函数的性能。\"]},\"475\":{\"h\":\"通俗易懂解读BPE分词算法实现\",\"t\":[\"通俗易懂解读BPE分词算法实现\",\"BPE（Byte Pair Encoding，字节对编码）是一种基于频率统计的子词分词算法 ，广泛用于现代自然语言处理任务中，特别是在像 BERT、GPT 和 LLaMA 这样的大模型中。它的核心思想是通过不断合并最常见的字符对来构建一个高效的词汇表。\",\"BPE 的核心思想:\",\"从字符级别开始，逐步合并高频的字符对。\",\"最终生成一个既能表示常见单词，又能拆解未知词的子词词汇表 。\",\"可以有效控制词汇表大小，同时避免“未登录词”问题（OOV, Out-of-Vocabulary）。\"]},\"476\":{\"h\":\"预训练过程\",\"t\":[\"BPE 算法预训练工作流程:\",\"训练语料为: Hello World , Hey Wow\",\"1. 读取训练语料，同时完成断句分词任务\",\"# filepaths: 训练语料所在的文件列表 def create_vocab(filepaths: List[str]) -> Dict[str, int]: # 获取所有单词和每个单词的出现次数词典 vocab = defaultdict(int) for path in tqdm(filepaths, desc='Creating vocabulary'): text = open(path, 'r', encoding='utf-8-sig').read() # 利用NLTK库提供的sent_tokenize方法完成断句功能，即将原文本按照空格，句号等标点符号结合语义进行断句。 sentences = sent_tokenize(text) # 遍历句子列表 for sentence in sentences: # 利用NLTK库提供的wordpunct_tokenize方法完成分词功能 tokens = wordpunct_tokenize(sentence) # 记录每个词的出现次数 for token in tokens: vocab[token] += 1 # vocab: 记录每个词的出现次数的词典 return vocab\",\"2. 过滤掉vocab中的低频词\",\"def truncate_vocab(vocab: Dict[str, int], mincount: int) -> None: tokens = list(vocab.keys()) for token in tokens: if vocab[token] < mincount: del(vocab[token])\",\"示例中设置为了1，不会过滤掉任何词。\",\"3. 数据预处理\",\"将训练语料中的每个单词按字符拆分，并在结尾加上特殊标记 </w> 表示单词结束。\",\"def prepare_bpe_vocab(vocab: Dict[str, int]) -> Dict[str, int]: bpe_vocab = {} # 遍历vocab中所有词 for token in vocab: # 每个词的每个字符后都加上空格，同时末尾加上 </w> 表示单词结束 ntoken = ' '.join(list(token)) + ' </w>' bpe_vocab[ntoken] = vocab[token] return bpe_vocab\",\"4. 经历N次迭代，合并前N个最频繁的字符对\",\" # 一共合并merges个高频字符对后,才结束词汇表的构建 for i in trange(merges, desc='Merging'): # 1. 获取每个相邻字符对的出现次数 pairs = get_stats(vocab) # 2. 获取当前最高频的字符对 best = max(pairs, key=pairs.get) # 3. 合并当前最高频的字符对 vocab = merge_vocab(best, vocab) ######记录历史合并的最高频子词对及其频率(传统BPE算法没有这一步)###### merged_pair_freqs = defaultdict(int) # 一共合并merges个高频字符对后,才结束词汇表的构建 for _ in trange(merges, desc='Merging'): # 1. 获取每个相邻字符对的出现次数 pairs = get_stats(vocab) # 2. 获取当前最高频的字符对 best_pair = max(pairs.items(), key=lambda x: x[1]) ######记录该子词对的全局频率(传统BPE算法没有这一步)###### best_subword = ''.join(best_pair[0]) best_freq = best_pair[1] merged_pair_freqs[best_subword] += best_freq # 3. 合并当前最高频的字符对 vocab = merge_vocab(best_pair[0], vocab)\",\"4.1 获取每个相邻字符对的出现次数\",\"def get_stats(vocab: Dict[str, int]) -> Dict[Tuple[str, str], int]: pairs = defaultdict(int) for word, freq in vocab.items(): # 对经过预处理的vocab中的每个词按空格进行切分 symbols = word.split() # 统计每个相邻字符对的出现次数 for i in range(len(symbols)-1): pairs[symbols[i],symbols[i+1]] += freq return pairs\",\"首轮统计展示\",\"4.2 获取当前最高频的字符对\",\"4.3 合并当前最高频的字符对\",\"def merge_vocab(pair: Tuple[str, str], v_in: Dict[str, int]) -> Dict[str, int]: # 1. 将传入的最高频字符对中的两个字符用空格拼接起来，如: \\\"H e\\\" bigram = re.escape(' '.join(pair)) v_out = {} # 2. 正则匹配含有“H e”的所有单词，并且“H”和“e”必须为两个独立的词，而不能为\\\"HH e\\\"或者\\\"H ee\\\"形式 p = re.compile(r'(?<!\\\\S)' + bigram + r'(?!\\\\S)') # 3. 遍历vocab中所有词 for word in v_in: # 3.1 用正则匹配并替换匹配上的 \\\"H e\\\" 为 “He” w_out = p.sub(''.join(pair), word) v_out[w_out] = v_in[word] # 4. 返回合并最高频字符对后的vocab return v_out\",\"5.根据N轮迭代合并后的Vocab来构建最终的频次表(每个子词的出现次数)\",\"def count_byte_freqs(vocab: Dict[str, int]) -> Dict[str, int]: freqs = defaultdict(int) for word in vocab: # 1. 按空格切分 bytes_ = word.split(' ') # 2. 每个子词出现次数加1 for byte in bytes_: freqs[byte] += 1 # 3. 添加一些特殊词 for token in ['<line/>', '</line>', '<pad>', '<unk>']: freqs[token] += 1 return freqs\",\"6.根据频次表构建最终的词汇表\",\"def create_vocab_maps(freqs: Dict[str, int]) -> (Dict[str, int], Dict[int, str]): # 1. 按照 词频从高到低 的顺序排序 ordered_freqs = sorted(freqs.items(), key=lambda x: x[1], reverse=True) vocab_to_idx, idx_to_vocab = {}, {} for i in range(len(ordered_freqs)): # 2. 构建词汇表 word, freq = ordered_freqs[i] vocab_to_idx[word] = i idx_to_vocab[i] = word return vocab_to_idx, idx_to_vocab\",\"7. freqs = 最终子词频率 + 历史最高频合并对的频率(传统BPE算法没有这一步)\",\" freqs.update(merged_pair_freqs)\",\"8. 通常最后会将预训练生成的频次表和词汇表写入文件保存\",\" def save(self, path: str) -> None: # 1. 频次表记录合并规则，也就是有哪些子词以及这些子词的出现次数，作为分词时的合并规则和优先选择权 with open(f'{path}/freqs.json', 'w', encoding='utf-8') as outfile: json.dump(self.freqs, outfile, indent=4, ensure_ascii=False) # 2. 常规的词汇表 with open(f'{path}/vocab_to_idx.json', 'w', encoding='utf-8') as outfile: json.dump(self.vocab_to_idx, outfile, indent=4, ensure_ascii=False) with open(f'{path}/idx_to_vocab.json', 'w', encoding='utf-8') as outfile: json.dump(self.idx_to_vocab, outfile, indent=4, ensure_ascii=False)\",\"BPE 算法预训练过程完整代码如下\",\" def train_bpe(filepaths: List[str], mincount: int, merges: int) -> 'BytePairTokenizer': vocab = create_vocab(filepaths) truncate_vocab(vocab, mincount) vocab = prepare_bpe_vocab(vocab) merged_pair_freqs = defaultdict(int) # (传统BPE算法没有这一步) for _ in trange(merges, desc='Merging'): pairs = get_stats(vocab) best_pair = max(pairs.items(), key=lambda x: x[1]) best_subword = ''.join(best_pair[0]) # (传统BPE算法没有这一步) best_freq = best_pair[1] # (传统BPE算法没有这一步) merged_pair_freqs[best_subword] += best_freq # (传统BPE算法没有这一步) vocab = merge_vocab(best_pair[0], vocab) freqs = count_byte_freqs(vocab) vocab_to_idx, idx_to_vocab = create_vocab_maps(freqs) freqs.update(merged_pair_freqs) # (传统BPE算法没有这一步) return BytePairTokenizer(freqs, vocab_to_idx, idx_to_vocab)\"]},\"477\":{\"h\":\"分词过程\",\"t\":[\"1.对输入的文本进行断句加分词\",\" # 使用NLTK库提供的sent_tokenize方法进行分词 lines = sent_tokenize(open(filepath, encoding='utf-8-sig').read()) tokens = [] # 遍历所有句子 for line in lines: if len(line) > 1: tokens += get_line_ids(line, tokenizer)\",\"def get_line_ids(line: str, tokenizer: BytePairTokenizer) -> List[int]: # 对每个句子进行分词 tokens = wordpunct_tokenize(line) # 将每个词从str转换为list列表形式，同时列表末尾追加</w> tokens = [list(t) + ['</w>'] for t in tokens] ...\",\"以输入 \\\"Hello World\\\" 为例\",\"2. 对当前句子中每个词进行子词合并加词ID映射，最后得到当前句子对应的Token列表\",\"def get_line_ids(line: str, tokenizer: BytePairTokenizer) -> List[int]: ... lineids = [] for token in tokens: # 2.1 对每个词进行子词合并，直到无法合并为止 token = tokenizer.merge_bytes(token) # 2.2 将当前词列表中每个子词映射为字典中对于的词ID ids = tokenizer.get_byte_ids(token) lineids += ids sol_id = tokenizer.get_byte_id('<line/>') eol_id = tokenizer.get_byte_id('</line>') lineids = [sol_id] + lineids + [eol_id] return lineids\",\"2.1 对每个词进行子词合并，直到无法合并为止\",\" # 对当前词的子词进行合并，直到无法合并为止 def merge_bytes(self, bytes_: List[str]) -> List[str]: bytes_, merged = self.merge_max_pair(bytes_) while merged: bytes_, merged = self.merge_max_pair(bytes_) return bytes_ def merge_max_pair(self, bytes_: List[str]) -> (List[str], bool): # 1. 取出出现次数最多的字符对 max_pair = self.get_max_pair_idxs(bytes_) merged = True if max_pair is not None else False if merged: # 2. 合并该字符对 bytes_ = bytes_[:max_pair[0]] + \\\\ [''.join(bytes_[max_pair[0]:max_pair[1]+1])] + \\\\ bytes_[max_pair[1]+1:] return bytes_, merged def get_max_pair_idxs(self, bytes_) -> Tuple[int, int]: pairs = {} # 1. 遍历所有相邻字符对的组合 for i in range(1, len(bytes_)): pair = ''.join(bytes_[i-1:i+1]) # 2. 判断每个字符对是否存在于频次表中，如果存在记录出现次数 if pair in self.freqs: pairs[(i-1, i)] = self.freqs[pair] # 3. 取出出现次数最多的字符对 return None if len(pairs) == 0 else max(pairs, key=pairs.get)\",\"2.2 将当前词列表中每个子词映射为字典中对于的词ID\",\" def get_byte_ids(self, bytes_): ids = [] for byte in bytes_: if byte in self.vocab_to_idx: ids.append(self.vocab_to_idx[byte]) else: ids.append(self.vocab_to_idx[self.unk]) return ids\"]},\"478\":{\"h\":\"附录\",\"t\":[\"BPE 分词器完整代码实现:\",\"from typing import Tuple, Dict, List from collections import defaultdict import json, re from nltk import wordpunct_tokenize, sent_tokenize from tqdm import trange, tqdm class BytePairTokenizer: def __init__(self, freqs: Dict[str, int], vocab_to_idx: Dict[str, int], idx_to_vocab: Dict[int, str]): \\\"\\\"\\\" Initialize byte pair tokenizer Args: freqs: frequency dictionary of vocabulary vocab_to_index: map of vocabulary words to indices index_to_vocab: map of vocabulary indices to words \\\"\\\"\\\" self.vocab_to_idx = vocab_to_idx self.idx_to_vocab = idx_to_vocab self.freqs = freqs self.sol = '<line/>' self.eol = '</line>' self.pad = '<pad>' self.unk = '<unk>' self.eow = '</w>' def get_sol(self) -> str: return self.sol def get_eol(self) -> str: return self.eol def get_pad(self) -> str: return self.pad def get_unk(self) -> str: return self.unk def get_eow(self) -> str: return self.eow def get_byte(self, byte_id: int) -> str: return self.idx_to_vocab[byte_id] def get_byte_id(self, byte: str) -> int: unk_id = self.vocab_to_idx[self.unk] bid = self.vocab_to_idx[byte] if byte in self.vocab_to_idx else unk_id return bid def get_byte_ids(self, bytes_): \\\"\\\"\\\" Get byte ids for each byte in provided list \\\"\\\"\\\" ids = [] for byte in bytes_: if byte in self.vocab_to_idx: ids.append(self.vocab_to_idx[byte]) else: ids.append(self.vocab_to_idx[self.unk]) return ids def get_bytes(self, byte_ids: List[int]) -> List[str]: \\\"\\\"\\\" Given a list of byte ids return corresponding bytes Args: byte_ids: list of byte ids Returns: (List[str]): list of bytes \\\"\\\"\\\" tokens = [] for byte_id in byte_ids: tokens.append(self.idx_to_vocab[byte_id]) return tokens def merge_bytes(self, bytes_: List[str]) -> List[str]: \\\"\\\"\\\" Return list of bytes with max pair merged Args: bytes_: list to merge max pair in Returns: (List[str]): list of bytes with all max pair occurrences merged \\\"\\\"\\\" bytes_, merged = self.merge_max_pair(bytes_) while merged: bytes_, merged = self.merge_max_pair(bytes_) return bytes_ def merge_max_pair(self, bytes_: List[str]) -> (List[str], bool): \\\"\\\"\\\" Takes in a list of bytes and merges the max pair if possible Args: bytes_: list of bytes to merge max pair in Returns: (bytes_): list of bytes with max pair merged (bool): flag indicating whether merge occurred \\\"\\\"\\\" max_pair = self.get_max_pair_idxs(bytes_) merged = True if max_pair is not None else False if merged: bytes_ = bytes_[:max_pair[0]] + \\\\ [''.join(bytes_[max_pair[0]:max_pair[1]+1])] + \\\\ bytes_[max_pair[1]+1:] return bytes_, merged def get_max_pair_idxs(self, bytes_) -> Tuple[int, int]: \\\"\\\"\\\" Get index of maximum byte pair in list of bytes Args: bytes_: list of bytes to find maximum pair from Returns: (Tuple[int, int]): maximum frequency byte pair \\\"\\\"\\\" pairs = {} for i in range(1, len(bytes_)): pair = ''.join(bytes_[i-1:i+1]) if pair in self.freqs: pairs[(i-1, i)] = self.freqs[pair] return None if len(pairs) == 0 else max(pairs, key=pairs.get) def save(self, path: str) -> None: with open(f'{path}/freqs.json', 'w', encoding='utf-8') as outfile: json.dump(self.freqs, outfile, indent=4, ensure_ascii=False) with open(f'{path}/vocab_to_idx.json', 'w', encoding='utf-8') as outfile: json.dump(self.vocab_to_idx, outfile, indent=4, ensure_ascii=False) with open(f'{path}/idx_to_vocab.json', 'w', encoding='utf-8') as outfile: json.dump(self.idx_to_vocab, outfile, indent=4, ensure_ascii=False) @staticmethod def load(path: str) -> 'BytePairTokenizer': with open(f'{path}/freqs.json', 'r', encoding='utf-8') as infile: freqs = json.load(infile) with open(f'{path}/vocab_to_idx.json', 'r', encoding='utf-8') as infile: vocab_to_idx = json.load(infile) with open(f'{path}/idx_to_vocab.json', 'r', encoding='utf-8') as infile: idx_to_vocab = json.load(infile) return BytePairTokenizer(freqs, vocab_to_idx, idx_to_vocab) @staticmethod def train_bpe(filepaths: List[str], mincount: int, merges: int) -> 'BytePairTokenizer': vocab = create_vocab(filepaths) truncate_vocab(vocab, mincount) vocab = prepare_bpe_vocab(vocab) merged_pair_freqs = defaultdict(int) for _ in trange(merges, desc='Merging'): pairs = get_stats(vocab) if not pairs: break best_pair = max(pairs.items(), key=lambda x: x[1]) best_subword = ''.join(best_pair[0]) best_freq = best_pair[1] merged_pair_freqs[best_subword] += best_freq vocab = merge_vocab(best_pair[0], vocab) freqs = count_byte_freqs(vocab) vocab_to_idx, idx_to_vocab = create_vocab_maps(freqs) freqs.update(merged_pair_freqs) return BytePairTokenizer(freqs, vocab_to_idx, idx_to_vocab) def create_vocab(filepaths: List[str]) -> Dict[str, int]: \\\"\\\"\\\" Create dictionary of vocabulary frequencies in given list of files Args: filepaths: list of filepaths to collect vocabulary from Returns: (Dict[str, int]): dictionary mapping vocabulary terms to their frequency \\\"\\\"\\\" vocab = defaultdict(int) for path in tqdm(filepaths, desc='Creating vocabulary'): text = open(path, 'r', encoding='utf-8-sig').read() sentences = sent_tokenize(text) for sentence in sentences: tokens = wordpunct_tokenize(sentence) for token in tokens: vocab[token] += 1 return vocab def truncate_vocab(vocab: Dict[str, int], mincount: int) -> None: \\\"\\\"\\\" Truncate vocabulary dictionary based on a minimum count Args: vocab: frequency mapping dictionary to truncate mincount: minimum count for members of dictionary (words with lower frequencies will be removed) \\\"\\\"\\\" tokens = list(vocab.keys()) for token in tokens: if vocab[token] < mincount: del(vocab[token]) def prepare_bpe_vocab(vocab: Dict[str, int]) -> Dict[str, int]: \\\"\\\"\\\" Prepare vocabulary frequency dictionary for byte-pair generation. End-of-word byte '</w>' added to words, every character separated by space Args: vocab: vocabulary frequency dictionary to prepare Returns: (Dict[str, int]): byte-pair ready vocabulary frequency dictionary \\\"\\\"\\\" bpe_vocab = {} for token in vocab: ntoken = ' '.join(list(token)) + ' </w>' bpe_vocab[ntoken] = vocab[token] return bpe_vocab def get_stats(vocab: Dict[str, int]) -> Dict[Tuple[str, str], int]: \\\"\\\"\\\" Count all bytepairs in a dictionary containing vocabulary frequencies Args: vocab: dictionary mapping words to their frequency Returns: (Dict[Tuple[str, str], int]): dictionary containing byte pair frequencies \\\"\\\"\\\" pairs = defaultdict(int) for word, freq in vocab.items(): symbols = word.split() for i in range(len(symbols)-1): pairs[symbols[i],symbols[i+1]] += freq return pairs def merge_vocab(pair: Tuple[str, str], v_in: Dict[str, int]) -> Dict[str, int]: \\\"\\\"\\\" Merge all instances of given byte pair in vocabulary frequency dictionary Args: pair: byte pair to merge v_in: vocabulary to merge byte pair int Returns: (Dict[str, int]): resulting vocabulary with all instances of given byte pair merged \\\"\\\"\\\" bigram = re.escape(' '.join(pair)) v_out = {} p = re.compile(r'(?<!\\\\S)' + bigram + r'(?!\\\\S)') for word in v_in: w_out = p.sub(''.join(pair), word) v_out[w_out] = v_in[word] return v_out def count_byte_freqs(vocab: Dict[str, int]) -> Dict[str, int]: freqs = defaultdict(int) for word in vocab: bytes_ = word.split(' ') for byte in bytes_: freqs[byte] += 1 for token in ['<line/>', '</line>', '<pad>', '<unk>']: freqs[token] += 1 return freqs def create_vocab_maps(freqs: Dict[str, int]) -> (Dict[str, int], Dict[int, str]): \\\"\\\"\\\" Create map of vocabulary terms to indices and vice versa. Word indices are in order of their frequency in the provided vocabulary Args: freqs: dictionary mapping vocabulary terms to their frequencies Returns: (Dict[str, int]): dictionary mapping vocab to indices (Dict[int, str]): dictionary mapping indices to vocab \\\"\\\"\\\" ordered_freqs = sorted(freqs.items(), key=lambda x: x[1], reverse=True) vocab_to_idx, idx_to_vocab = {}, {} for i in range(len(ordered_freqs)): word, freq = ordered_freqs[i] vocab_to_idx[word] = i idx_to_vocab[i] = word return vocab_to_idx, idx_to_vocab\"]},\"479\":{\"h\":\"其他方向\"},\"480\":{\"h\":\"大模型微调(Fine Tuning)知识扫盲\",\"t\":[\"大模型微调(Fine Tuning)知识扫盲\"]},\"481\":{\"h\":\"什么是大模型 ？\",\"t\":[\"开始之前，为了方便大家理解，我们先对大模型做一个直观的抽象。\",\"本质上，现在的大模型要解决的问题，就是一个序列数据转换的问题：\",\"输入序列 X = [x1, x2, ..., xm]\",\"输出序列Y = [y1, y2, …, yn]\",\"X和Y之间的关系是：Y = WX。\",\"我们所说的“大模型”这个词：“大”是指用于训练模型的参数非常多，多达千亿、万亿；而“模型”指的就是上述公式中的矩阵W。\",\"在这里，矩阵W就是通过机器学习，得出的用来将X序列，转换成Y序列的权重参数组成的矩阵。\",\"需要特别说明：这里为了方便理解，做了大量的简化。在实际的模型中，会有多个用于不同目的的权重参数矩阵，也还有一些其它参数。\"]},\"482\":{\"h\":\"为什么要对大模型进行微调 ？\",\"t\":[\"通常，要对大模型进行微调，有以下一些原因：\",\"因为大模型的参数量非常大，训练成本非常高，每家公司都去从头训练一个自己的大模型，这个事情的性价比非常低；\",\"Prompt Engineering的方式是一种相对来说容易上手的使用大模型的方式，但是它的缺点也非常明显。因为通常大模型的实现原理，都会对输入序列的长度有限制，Prompt Engineering 的方式会把Prompt搞得很长。\",\"越长的Prompt，大模型的推理成本越高，因为推理成本是跟Prompt长度的平方正向相关的。\",\"另外，Prompt太长会因超过限制而被截断，进而导致大模型的输出质量打折口，这也是一个非常严重的问题。\",\"对于个人使用者而言，如果是解决自己日常生活、工作中的一些问题，直接用Prompt Engineering的方式，通常问题不大。\",\"但对于对外提供服务的企业来说，要想在自己的服务中接入大模型的能力，推理成本是不得不要考虑的一个因素，微调相对来说就是一个更优的方案。\",\"Prompt Engineering的效果达不到要求，企业又有比较好的自有数据，能够通过自有数据，更好的提升大模型在特定领域的能力。这时候微调就非常适用。\",\"要在个性化的服务中使用大模型的能力，这时候针对每个用户的数据，训练一个轻量级的微调模型，就是一个不错的方案。\",\"数据安全的问题。如果数据是不能传递给第三方大模型服务的，那么搭建自己的大模型就非常必要。通常这些开源的大模型都是需要用自有数据进行微调，才能够满足业务的需求，这时候也需要对大模型进行微调。\"]},\"483\":{\"h\":\"如何对大模型进行微调 ？\",\"t\":[\"从参数规模的角度，大模型的微调分成两条技术路线：\",\"一条是对全量的参数，进行全量的训练，这条路径叫全量微调FFT(Full Fine Tuning)。\",\"一条是只对部分的参数进行训练，这条路径叫PEFT(Parameter-Efficient Fine Tuning)。\",\"FFT的原理，就是用特定的数据，对大模型进行训练，将W变成，相比W ，最大的优点就是上述特定数据领域的表现会好很多。\",\"但FFT也会带来一些问题，影响比较大的问题，主要有以下两个：\",\"一个是训练的成本会比较高，因为微调的参数量跟预训练的是一样的多的；\",\"一个是叫灾难性遗忘(Catastrophic Forgetting)，用特定训练数据去微调可能会把这个领域的表现变好，但也可能会把原来表现好的别的领域的能力变差。\",\"PEFT主要想解决的问题，就是FFT存在的上述两个问题，PEFT也是目前比较主流的微调方案。\",\"从训练数据的来源、以及训练的方法的角度，大模型的微调有以下几条技术路线：\",\"监督式微调SFT(Supervised Fine Tuning) : 用人工标注的数据，用传统机器学习中监督学习的方法，对大模型进行微调；\",\"基于人类反馈的强化学习微调RLHF(Reinforcement Learning with Human Feedback) : 把人类的反馈，通过强化学习的方式，引入到对大模型的微调中去，让大模型生成的结果，更加符合人类的一些期望；\",\"基于AI反馈的强化学习微调RLAIF(Reinforcement Learning with AI Feedback) : 原理大致跟RLHF类似，但是反馈的来源是AI。这里是想解决反馈系统的效率问题，因为收集人类反馈，相对来说成本会比较高、效率比较低。\",\"不同的分类角度，只是侧重点不一样，对同一个大模型的微调，也不局限于某一个方案，可以多个方案一起。\",\"微调的最终目的，是能够在可控成本的前提下，尽可能地提升大模型在特定领域的能力。\"]},\"484\":{\"h\":\"常用的PEFT方案\",\"t\":[\"从成本和效果的角度综合考虑，PEFT是目前业界比较流行的微调方案。接下来介绍几种比较流行的PEFT微调方案。\"]},\"485\":{\"h\":\"Prompt Tuning\",\"t\":[\"Prompt Tuning的出发点，是基座模型(Foundation Model)的参数不变，为每个特定任务，训练一个少量参数的小模型，在具体执行特定任务的时候按需调用。\",\"Prompt Tuning的基本原理是在输入序列X之前，增加一些特定长度的特殊Token，以增大生成期望序列的概率。\",\"具体来说，就是将变成，。\",\"Prompt Tuning是发生在Embedding这个环节的。如果将大模型比做一个函数：，那么Prompt Tuning就是在保证函数本身不变的前提下，在X前面加上了一些特定的内容，而这些内容可以影响X生成期望中Y的概率。\",\"Prompt Tuning的具体细节,可以参见：The Power of Scale for Parameter-Efficient Prompt Tuning。\"]},\"486\":{\"h\":\"Prefix Tuning\",\"t\":[\"Prefix Tuning的灵感来源是，基于Prompt Engineering的实践表明，在不改变大模型的前提下，在Prompt上下文中添加适当的条件，可以引导大模型有更加出色的表现。\",\"Prefix Tuning的出发点，跟Prompt Tuning的是类似的，只不过它们的具体实现上有一些差异。\",\"Prompt Tuning是在Embedding环节，往输入序列X前面加特定的Token。而Prefix Tuning是在Transformer的Encoder和Decoder的网络中都加了一些特定的前缀。\",\"具体来说，就是将Y=WX中的W，变成。\",\"Prefix Tuning也保证了基座模型本身是没有变的，只是在推理的过程中，按需要在W前面拼接一些参数。\",\"Prefix Tuning的具体细节,可以参见：Prefix-Tuning: Optimizing Continuous Prompts for Generation。\"]},\"487\":{\"h\":\"LoRA\",\"t\":[\"LoRA是跟Prompt Tuning和Prefix Tuning完全不相同的另一条技术路线。\",\"LoRA背后有一个假设：我们现在看到的这些大语言模型，它们都是被过度参数化的。而过度参数化的大模型背后，都有一个低维的本质模型。\",\"通俗讲人话：大模型参数很多，但并不是所有的参数都是发挥同样作用的；大模型中有其中一部分参数，是非常重要的，是影响大模型生成结果的关键参数，这部分关键参数就是上面提到的低维的本质模型。\",\"LoRA的基本思路，包括以下几步：\",\"首先, 要适配特定的下游任务，要训练一个特定的模型，将Y=WX变成Y=(W+∆W)X，这里面∆W主是我们要微调得到的结果；\",\"其次，将∆W进行低维分解∆W=AB (∆W为m * n维，A为m * r维，B为r * n维，r就是上述假设中的低维)；\",\"接下来，用特定的训练数据，训练出A和B即可得到∆W，在推理的过程中直接将∆W加到W上去，再没有额外的成本。\",\"另外，如果要用LoRA适配不同的场景，切换也非常方便，做简单的矩阵加法即可：(W + ∆W) - ∆W + ∆W'。\",\"关于LoRA的具体细节,可以参见LoRA: Low-Rank Adaptation of Large Language Models。\"]},\"488\":{\"h\":\"QLoRA\",\"t\":[\"LoRA 效果已经非常好了，可以媲美全量微调的效果了，那为什么还要有个QLoRA呢？\",\"这里先简单介绍一下，量化（Quantization）。\",\"量化，是一种在保证模型效果基本不降低的前提下，通过降低参数的精度，来减少模型对于计算资源的需求的方法。\",\"量化的核心目标是降成本，降训练成本，特别是降后期的推理成本。\",\"QLoRA就是量化版的LoRA，它是在LoRA的基础上，进行了进一步的量化，将原本用16bit表示的参数，降为用4bit来表示，可以在保证模型效果的同时，极大地降低成本。\",\"论文中举的例子，65B的LLaMA的微调要780GB的GPU内存；而用了QLoRA之后，只需要48GB。效果相当惊人！\",\"关于QLoRA的具体细节,可以参见：QLoRA: Efficient Finetuning of Quantized LLMs。\",\"PEFT 的微调方法，还有很多种，限于篇幅原因，不再这里一一介绍。感兴趣的朋友，可以阅读这篇论文：Scaling Down to Scale Up: A Guide to Parameter-Efficient Fine-Tuning。\",\"相关阅读资料:\",\"近代自然语言处理技术发展的“第四范式”\",\"Pre-train, Prompt, and Predict: A Systematic Survey of Prompting Methods in Natural Language Processing\"]},\"489\":{\"h\":\"通俗易懂讲解LoRA微调\",\"t\":[\"通俗易懂讲解LoRA微调\",\"论文链接: LoRA: Low-Rank Adaptation of Large Language Models\"]},\"490\":{\"h\":\"符合认知的大模型微调流程\",\"t\":[\"符合我们直接观念所想的大模型微调流程为:\",\"准备与下游任务相关的数据集\",\"选择合适的预训练好的大模型\",\"在特定任务相关的数据集上执行有监督全量参数微调，将预训练模型的参数 调整为适合下游任务的 \",\"其中第三步通过反向传播全量更新模型参数的过程如下：\",\"图1: 反向传播更新模型参数过程\",\"上述的全量微调流程问题在于大模型的参数量往往特别大，也就是 占据了特别大的内存资源和计算资源，有没有办法能够减少 所占的内存资源和计算资源呢？\",\"图2: 低秩分解\",\"我们可以利用矩阵分解技术，将原始的 矩阵从 参数量降低到 级别的参数量，如下图所示:\",\"图3: 待微调的参数量下降到原来的9%\",\"这样一来，我们微调大模型的流程就变为了(前两步不变)：\",\"初始化低秩矩阵：对于需要微调的密集层，初始化两个低秩矩阵 和 ，其维度分别为 和 ，其中 是低秩的秩，远小于原始矩阵的维度。\",\"冻结预训练模型参数：在微调过程中，保持预训练模型的原始参数 不变，只对低秩矩阵 和 进行训练。\",\"执行微调训练：在准备好的数据集上，通过反向传播算法更新低秩矩阵 和 的参数，使得模型在下游任务上的表现逐渐优化。\",\"合并参数（可选）：在微调完成后，如果需要，可以将低秩矩阵 和 的更新量与原始参数 合并，得到最终适用于下游任务的模型参数 。\",\"这在LoRA这篇论文中也被称为低秩分解自适应技术。\",\"图4: 常规微调 VS LoRA微调\"]},\"491\":{\"h\":\"大模型微调大致发展历史\",\"t\":[\"大公司或者研究机构，都是有足够资源的来开发大模型，但是对于一般的小公司或者个人来说，要想开发自己的大模型几乎不可能，要知道像 ChatGPT 这样的大模型，一次训练的成本就在上千亿美元。\",\"那么那些小公司或者个人，又怎么能够利用这些开源的大模型，在自己的数据上继续训练，从而应用于自己的业务场景？有没有低成本的方法微调大模型？\",\"答案是有的。目前主流的方法包括2019年 Houlsby N 等人提出的 Adapter Tuning，2021年微软提出的 LORA，斯坦福提出的 Prefix-Tuning，谷歌提出的 Prompt Tuning，2022年清华提出的 P-tuning v2。\",\"这些方法都有各自的特点，从个人使用情况来说，LORA 的效果会好于其它几种方法。其它方法都有各自的一些问题：\",\"Adapter Tuning 增加了模型层数，引入了额外的推理延迟\",\"Prefix-Tuning 难于训练，且预留给 Prompt 的序列挤占了下游任务的输入序列空间，影响模型性能\",\"P-tuning v2 很容易导致旧知识遗忘，微调之后的模型，在之前的问题上表现明显变差\",\"基于上述背景，LORA 得益于前人的一些关于内在维度（intrinsic dimension）的发现：\",\"模型是过参数化的，它们有更小的内在维度，模型主要依赖于这个低的内在维度（low intrinsic dimension）去做任务适配。\",\"假设模型在任务适配过程中权重的改变量是低秩（low rank）的，由此提出低秩自适应（LoRA）方法。\",\"LoRA 允许我们通过优化适应过程中密集层变化的秩分解矩阵，来间接训练神经网络中的一些密集层，同时保持预先训练的权重不变。\"]},\"492\":{\"h\":\"LoRA 微调\",\"t\":[\"图5: LoRA 微调流程\",\"LoRA 的思想很简单:\",\"在 LoRA 论文中，在原始预训练语言模型（Pre - trained Language Model，简称 PLM）旁添加一条旁路，进行一次降维再升维的操作，以此来模拟所谓的内在秩（intrinsic rank）。\",\"训练的时候固定 PLM 的参数，只训练降维矩阵 A 与升维矩阵 B 。而模型的输入输出维度不变，输出时将 BA 与 PLM 的参数叠加。\",\"用随机高斯分布初始化 A ，用 0 矩阵初始化 B ，保证训练的开始此旁路矩阵依然是 0 矩阵。\",\"图6: 随机高斯分布初始化 A ，用 0 矩阵初始化 B\",\"假设要在下游任务微调一个预训练语言模型（如 GPT-3），则需要更新预训练模型参数，公式表示如下：\",\"其中， 是预训练模型初始化的参数， 就是需要更新的参数。如果是全参数微调，则它的参数量 （如果是 GPT-3，则 ）。从这可以看出要全参数微调大语言模型，代价是非常高的。\",\"而对于 LoRA 来说，只需要微调 。\",\"具体来看，假设预训练的矩阵为 ，它的更新可表示为：\",\"其中秩 。\",\"在 LoRA 的训练过程中， 是固定不变的，只有 和 是训练参数。\",\"在前向过程中， 与 都会乘以相同的输入 ，最后相加：\",\"LoRA 的这种思想有点类似于残差连接，同时使用这个旁路的更新来模拟 Full Fine-Tuning 的过程。并且，Full Fine-Tuning 可以被看作是 LoRA 的特例（当 等于 时）。\",\"在推理过程中，LoRA 也几乎未引入额外的 Inference Latency，只需要计算 即可。\",\"LoRA 与 Transformer 的结合也很简单，仅在 QKV Attention 的计算中增加一个旁路。\"]},\"493\":{\"h\":\"矩阵A和B为什么不能同时为零？\",\"t\":[\"在前面我们介绍了，用随机高斯分布初始化 ，用 0 矩阵初始化 。矩阵 为什么不也用 0 初始化？\",\"这主要是因为如果矩阵 也用 0 初始化，那么矩阵 的梯度就始终为 0，无法更新参数，导致 。这里简单推理一下。\",\"对于 ，设 ，则：\",\"因此：\",\"如果矩阵 也用 0 初始化，那么上面的梯度就变成了 0，所以矩阵 不能用 0 初始化。\",\"同样，我们看一下矩阵 初始化为 0 的影响。\",\"由于矩阵 的参数会发生更新，而 矩阵又不是 0 矩阵，因此后面 ，所以矩阵 可以用 0 初始化。\"]},\"494\":{\"h\":\"秩的选择\",\"t\":[\"论文实验结果显示，对于一般的任务， r=1,2,4,8 就足够了。而一些领域差距比较大的任务可能需要更大的 r 。\",\"同时，增加 r 值变大并不能提升微调的效果，这可能是因为参数量增加需要更多的语料。\",\"图7: 秩的选择\"]},\"495\":{\"h\":\"注意\",\"t\":[\"q进行 LoRA 高效的模型微调，重点是保持参数尺寸最小化。\",\"使用 PEFT 库来实现 LoRA，避免复杂的编码需求。\",\"将 LoRA 适应扩展到所有线性层，增强整体模型的能力。\",\"保持偏置和层归一化可训练，因为它们对模型的适应性至关重要，并且不需要低秩适应。\",\"应用量化低秩适应（Quantized LoRA，简称 QLoRA）以节省 GPU 显存并训练模型，从而能够训练更大的模型。\",\"量化是一种在深度学习领域用于减少模型内存占用和计算量的技术。在模型训练和推理过程中，神经网络的权重矩阵通常以高精度的浮点数（如 32 位浮点数）形式存储和计算，这会占用大量的内存资源并消耗较多的计算资源。量化通过将这些高精度的浮点数转换为低精度的整数（如 4 位或 8 位整数）来实现数据的压缩。\",\"在 LoRA 微调的场景中，QLoRA 就是利用量化技术的一个变体。它将权重矩阵量化为 4 位或 8 位整数，在不损失太多性能的情况下减少了模型的大小，使得模型可以在资源有限的设备上进行训练和部署，同时还能适应更多的参数。\",\"基于大模型的内在低秩特性，增加旁路矩阵来模拟全参数微调，LoRA 通过简单有效的方案来达成轻量微调的目的。它的应用自不必提，可以将现在的各种大模型通过轻量微调变成各个不同领域的专业模型。\",\"此外，考虑 OpenAI 对 GPT 模型的认知，GPT 的本质是对训练数据的有效压缩，从而发现数据内部的逻辑与联系，LoRA 的思想与之有相通之处，原模型虽大，但起核心作用的参数是低秩的，通过增加旁路，达到四两拨千斤的效果。\"]},\"496\":{\"h\":\"Prompt Engineering 知识扫盲\",\"t\":[\"Prompt Engineering 知识扫盲\"]},\"497\":{\"h\":\"什么是Prompt Engineering?\",\"t\":[\"Prompt (提示词) 是人类发给各种人工智能模型、用以完成特定任务的指令。\",\"Prompt Engineering (提示词工程) 是指我们为了让LLM能够更好地完成我们给它的任务，我们对Prompt进行优化、调整的过程。\",\"可能会有人这么问，LLM已经这么强了，直接丢给它个指令，让他去执行就好了，为什么还需要Prompt Engineering呢？\",\"确实像OpenAI的GPT4这样的LLM已经非常强了，很多简单的任务，我们直接用自然语言丢给他就去执行就好了。但是，对于一些复杂的问题，Prompt写得好不好，直接影响着大模型给出答案的正确与否。\",\"本质上，LLM是一个概率模型，它只是在给定的信息的前提下，给出概率最大的结果，它并不保证结果的合理性和正确性。\",\"要让LLM给出的结果尽可能地合理、正确，这是我们使用LLM的人的职责。\",\"这就是我们要去学习Prompt Engineering的原因。\"]},\"498\":{\"h\":\"如何写好Prompt?\"},\"499\":{\"h\":\"要明确,要具体\",\"t\":[\"我们发给LLM的批令，越明确、越具体，对于LLM越友好。\",\"举个例子，我们让LLM对一段文字进行总结：\",\"Prompt 2相比Prompt 1，对输出有了更加明确具体的要求，这样LLM输出的内容也会更加贴合我们的需求。另外，我们还用了'###'作为分隔符，进一步帮LLM明确要求。\",\"我们在给LLM发指令的时候，第一个关键点，就是我们要把给LLM做的任务尽可能细化，把要求尽可能明确、具体地描述出来。\"]},\"500\":{\"h\":\"给LLM更多的时间去思考\",\"t\":[\"《思考快与慢》这本书里介绍了我们人类大脑的“系统1”和“ 系统2”。\",\"系统1是快思考系统，反应很快，但可能会出错。\",\"系统2是慢思考系统，需要更长的反应时间，进行思考、推理，但结果会更加靠谱。\",\"默认情况下，LLM就像是一个快思考的系统，他利用自己已掌握的知识，快速给出答案，但并不能保证结果的正确性。\",\"为了让LLM给出的答案更加靠谱，我们需要通过Prompt Engineering 的方式，把LLM的慢思考调动起来。\",\"这就是“给LLM更多的时间去思考”背后的大致逻辑。\",\"给LLM更多的时间去思考，一个简单的技巧是在你的Prompt后面，加上这样一句话“Let’s think step by step”。这句话会引导LLM，会去分步骤思考，效果会比不加这句话要好。\",\"另一个技巧，在Prompt中加入一些例子，让LLM照着例子进行推理、思考。这一块的技巧性很强，我们在接下来的部分，介绍几种具体的技巧。\"]},\"501\":{\"h\":\"思维链技术：Chain-of-Thought\",\"t\":[\"这是《Chain-of-Thought Prompting Elicits Reasoning in Large Language Models》这篇论文里讲的一个Prompt Engineering的技巧。\",\"CoT(Chain-of-Thought) 的核心思想是，在Prompt中加入一些示例，来引导LLM展现出更好的推理能力。\",\"这里的关键是在Prompt中加入的示例，在这些示例中，我们会用自然语言描述一系列的推理过程，并最终引导出示例问题的正确结果。\",\"这个过程有点像，我们教小孩做应用题，我们先给小孩子分析讲解一些示例。然后再把新的问题让小孩子来解决。小孩子根据从示例中学习到的推理、分析能力，最终解出了新的问题。\",\"下面我们来看论文中给的CoT的例子：\",\"左侧是常规的Prompt，右侧是CoT Prompt\",\"蓝色标记出的部分是提供给LLM的示例。绿色标记出的部分是LLM输出的推理过程。\",\"在使用CoT这种Prompt Engineering技巧的时候，有几个注意点：\",\"CoT是LLM足够大（参数足够多，通常是在1000亿参数）时才涌现出来的能力。因此，在一些不够大的LLM上，CoT的效果并不明显。\",\"通常，在Prompt中加入的示例不是1条，而是多条。具体要考虑解决的问题类型，以及Prompt的长度（因为LLM的Prompt长度通常都是有长度限制的）。\"]},\"502\":{\"h\":\"自一致性技术：Self-Consistency\",\"t\":[\"这是《Self-Consistency Improves Chain of Thought Reasoning in Language Models》 这篇论文里讲的另一个Prompt Engineering的技巧。\",\"Self-Consistency技术是在CoT技术的基础之上，进行的进一步优化，目的是为了让LLM的推理能力能够更进一步提升。\",\"Self-Consistency的大致原理是这样：\",\"利用CoT Prompting技巧，写好Prompt；\",\"不要让LLM只生成最合适的唯一一个结果，而是利用LLM结果的多样性，生成多种不同推理路径所得的结果的集合；\",\"从结果集合中投票选择，选出投票最多的结果，做为最终的答案。\",\"这里有像我们人类解决问题的过程，如果我们用多种不同的方法去求解，大多数方法求解出来结果都一样的答案，那很有可能就是我们最终的答案。\",\"下面我们来看论文中给的Self-Consistency的例子：\",\"在上面的例子中，虚线之上是标准的CoT的过程，它得到的结果是错的。虚线之下是Self-Consistency的过程，得到的三个答案中，有1个是错的，有2个是正确的。最终答案是大多数投票的结果，是正确的。\"]},\"503\":{\"h\":\"从易至难技术：Least-to-Most\",\"t\":[\"这是《Least-to-Most Prompting Enables Complex Reasoning in Large Language Models》 这篇论文中介绍的方法。\",\"CoT的特点是同类型问题的迁移思考，因此，如果给的例子是比较简单的问题，而给的问题却是难度大很多的问题，这时候CoT的效果就不尽如人意。\",\"LtM(Least-to-Most)主是为了解决CoT这种从易到难的迁移能力不足而诞生的。\",\"LtM的核心思想是：教LLM把复杂问题，拆解成一系列的简单问题，通过解决这一系列的简单问题，来最终得到复杂问题的结果。\",\"LtM的过程包含两个阶段：\",\"分解阶段：把复杂问题分解成一系列的简单子问题。这个阶段的Prompt中要包含分解问题的示例，要和分解的问题；\",\"解决子问题阶段：这个阶段的Prompt中包含三部分内容：一是完整的LtM的例子；二是已解决的子问题及其答案列表；三是接下来要解答的子问题。\",\"这里也非常像我们人类学习解决复杂问题的过程，我们通过把复杂问题拆解成一个个的简单问题，通过把一个个的简单问题解决掉，最终把复杂问题也解决了。\",\"下面我们来看看论文中LtM的例子：\",\"从上图中，我们可以对LtM Prompting有一个直观的认知，通过引导LLM解决子问题，一步步引导LLM得出复杂问题的结果。\"]},\"504\":{\"h\":\"应用层\"},\"505\":{\"h\":\"GPT-1 论文\",\"t\":[\"GPT-1 论文\",\"论文: Improving Language Understanding by Generative Pre-Training\"]},\"506\":{\"h\":\"摘要\",\"t\":[\"自然语言理解包含了广泛的多样性任务，比如文本蕴涵，问答，语义相似度评估，文本分离。然而大规模的未标注的文本语料是丰富，而特定任务学习的标注数据有非常少，使得要充分做区分地训练模型非常有挑战性。作者证明通过在丰富的无标签文本语料库生成预训练generative pre-training语言模型，然后在每项具体任务上判别性微调discriminative fine-tuning，可以实现巨大的收益。对比之前的方法，作者在微调阶段使用任务感知的输入转换来实现有效的迁移，仅仅需要小小修改模型架构。通用的任务未知task-agnostic模型优于那些为每个任务精心设计的模型，在12个研究任务中9个提升到SOTA。如，作者在常识推理(Stories Close Test)上提升8.9%， 在问答上提升5.7%(RACE)，文本蕴含提升1.5%(MultiNLI)。\"]},\"507\":{\"h\":\"简介\",\"t\":[\"在NLP中，有效地从无标记的原始文本中学习的能力能减轻对监督学习的依赖。大部分深度学习方法需要大量人工标注的数据，这限制了它们在许多缺乏标记数据领域的适用性。在这种情况下，模型能从无标记数据中充分利用语义信息，为收集更多的标注数据提供了更多一个有价值的替代方案，标注数据昂贵又耗时。进一步来说，即便是那些有大量标注数据的场景，无监督学习得到的好的表示也能提供显著的提升。最有说服力的证据就是到目前为止大量使用预训练的词嵌入来提升一系列NLP任务表现。\",\"无论到什么程度，从无标注文本中充分利用词级别以外的信息是有挑战性的，有两个主要原因。\",\"不清楚在学习文本表示时，什么样的优化目标是最高效的迁移。近期研究考虑过各种各样的目标，如语言模型，机翻，语句连贯性，每种方法在不同任务上都优于其它方法。\",\"对于将这些学习到的表征迁移到目标任务的最有效方法，目前还没有达成共识。已有的技术涉及对模型架构进行特定任务的修改、使用复杂的学习方案以及添加辅助学习目标的组合。这些不确定性使得开发有效的语言处理半监督学习方法变得困难。\",\"在本文中，作者用无监督的预训练和监督的微调组合来探索关于语言理解任务半监督方法。目标是学习一个全局表示，迁移它来稍微适应一系列广泛的任务。作者假设采用一个大型无标记文本语料库和几个人工标记训练样本的数据集(目标任务)。该设置不需要这些目标任务和无标记语料库是一个领域的。并采用两段式训练流程。首先，在无标记数据上使用语言模型目标来学习神经网络初始化的参数。接着，使用对应特定任务的监督目标来调整这些参数。(预训练+微调)\",\"对于作者的模型架构，使用的是Transformer，它被证明在许多任务上有很强的表现，如机翻，文本生成，句法解析。该模型在文本上处理长期依赖提供了更结构化的内存，相比其他替代方案如RNN，Transformer跨各种各样任务的迁移性能更强。在迁移阶段，作者利用源于遍历式(traversal-style)方法的特定任务的输入改写，其将结构化文本输入处理为单一的连续字符序列。如作者在实验中证明的，这些改写使得在预训练模型架构上用最小的修改就会有效。\",\"作者在四种类型的语言理解任务评估作者的方法——自然语言推断NLI，问答，语义相识度，和文本分类。作者通用的任务未知task-agnostic模型优于那些为每个任务精心设计的模型，在12个研究任务中9个提升到SOTA。\",\"常识推理提升8.9%(Stories Cloze Test)\",\"问答提升5.6%(RACE)\",\"文本蕴含提升5.5%(MultiNLI)\",\"GLUE多任务提升5.5%.\",\"也分析了在四种不同设置下预训练模型的零次(zero-shot)表现，证明其确实为下游任务获取到了有用的语言知识。\"]},\"508\":{\"h\":\"相关工作\",\"t\":[\"NLP半监督学习: 预训练对于获取不同级别信息的需要，如从词级别信息到更高的(段落级别或者句子级别的)词嵌入。\",\"无监督预训练: 无监督预训练+监督微调方式，Transformer比LSTM能获取长距离信息。\",\"辅助训练目标: 添加一个无监督训练目标是半监督学习的一种替代形式。如POS tag，语义组块chuking, NER， 以及语言模型来提升标记的语义角色。\"]},\"509\":{\"h\":\"框架\",\"t\":[\"作者训练流程有两个阶段:\",\"在大规模文本语料上学习高容量的语言模型\",\"微调阶段，用标记的数据对特定任务微调模型\"]},\"510\":{\"h\":\"无监督预训练\",\"t\":[\"给定一个无监督学习的语料tokens ，使用标准的语言模型目标并最大化其似然：\",\"这里 是上下文窗口大小，条件概率 是参数 的神经网络模型。这些参数会以随机梯度下降训练。\",\"在作者的实验中，语言模型使用多层的 Transformer decoder（Transformer 的变种 ）。该模型在上下文 token 上使用多头自注意力操作，接一个逐位置的前馈层来生成目标字符的分布输出（比原本少了一个多头自注意力 ）：\",\"公式如下：\",\"这里 是上下文字符向量， 是层数， 是字符嵌入矩阵， 是位置嵌入矩阵。\"]},\"511\":{\"h\":\"有监督微调\",\"t\":[\"在训练公式 （ 1 ） 中的目标函数模型后，作者在监督学习目标任务上调整参数。假设有标记数据集 ，每个实例有输入字符的序列构成 ，对应着标签 。输入通过作者的预训练模型会得到最好的 transformer block 的激活状态 ，将其喂进一个参数为 的添加的线性输出层来预测 有：\",\"给出最大化的目标函数为：\",\"作者还发现加入语言模型作为辅助目标来微调有助于学习：(a) 提升监督模型的泛化能力；(b) 加速收敛。这跟之前的工作一样，观测发现用辅助目标能提升性能。尤其是，作者用以下优化（加权 ）目标：\",\"总之，作者额外要微调的参数只有 ，以及分割字符嵌入矩阵。\"]},\"512\":{\"h\":\"特定任务输入转换\",\"t\":[\"文本分类：直接微调模型\",\"问答或文本蕴含：输入是结构化的，如有序句子对，三元组（文档，问题和答案）\",\"因为作者的预训练模型是用连续的文本序列训练的，需要做些修改以便用在这些任务上。之前的工作提出了在迁移表征顶部学习特定任务的架构。这种方法重新引入了大量特定任务的定制化输入，并且不会对额外的架构组件使用迁移学习。相反，作者使用遍历式方法，就是将结构化输入转换为有序序列以便作者预训练能处理。这些输入转换使作者避免跨任务架构的大改。作者在下面部分和可视化插图 1 提供了这些输入的简洁描述。所有的转换包括添加随机初初始化的开始和结束标记 。\",\"文本蕴含：拼接前提文本 和假设 为 token 序列，用 $ 符来分隔两者。\",\"相似度：对于相似任务，两个比较的句子没有内在顺序。为了反映这点，作者修改输入序列来包含 2 种可能的顺序（用分隔符分隔），并独立地处理 2 个序列表示 ，逐元素相加然后送入线性输出层。\",\"问答和常识推理：对于这些任务，给定文档 ，一个问题 和一个可能答案集 。将文档和问题跟每个可能答案拼接起来，再在其中添加一个分隔符得到 。每个这些序列用作者的模型独立处理后通过一个 softmax 层归一化来生成所有可能答案的分布。\"]},\"513\":{\"h\":\"实验\"},\"514\":{\"h\":\"设置\",\"t\":[\"无监督预训练：BOOKS CORPUS 数据集预训练模型。长文本能让生成模型学习到长依赖信息的条件概率。ELMO 方法处理 1B Word benchmarks，在句子级别打乱顺序以破坏长距离结构信息，达到非常低的 18.4 困惑度。\",\"模型的具体配置:\",\"Transformer 架构：12 层有自注意力头（768 维隐藏层，12 个注意力头）transformer decoder 结构。\",\"逐位置前馈神经网络（position-wise feed-forward networks）：3072 维内部隐藏层。\",\"Adam 优化器方案：最大 lr=2.5e-4。开始 2000 次从 0 线性上升更新，再使用 cosine 方案退火到 0。\",\"采样与训练：从 512 连续 tokens 中随机采样得到 64 小批次样本，训练 100 轮。\",\"层归一化：改进版的 layerNorm，以 权重初始化。\",\"词汇表与正则化：40,000 合并的 BPE 词汇表，残差，嵌入和注意力层以 0.1 的 Dropout 来正则化。\",\"改进版 L2 正则：所有无偏差或增益权重设置为 。\",\"激活函数：GELU 作为激活函数。\",\"位置嵌入：使用学习的位置嵌入，而不是原始 Transformer 的正余弦曲线。\",\"数据清洗与分词：使用 ftfy 清洗原始 BooksCorpus，去掉字符和空格，再使用 spaCy tokenize。\",\"微调的细节:\",\"除非指定，使用无监督预训练超参数设置。分类层使用 0.1 的 Dropout。大部分任务，lr=6.25e-5，批大小为 32。在大部分任务中基本上 3 轮训练就足够了。lr 用以训练步数的 0.2% 预热衰减方案。 设置为 0.5。\"]},\"515\":{\"h\":\"监督微调\",\"t\":[\"微调任务和数据集如下：\",\"NLI 就是识别文本蕴含。涉及读取一对句子，判断它们之间的关系，是蕴含，矛盾或中立。因为存在各种变化现象，如词汇蕴含，共指，词汇和句法歧义，所以还是很有挑战性的。\",\"下表2是作者模型和之前SOTA模型NLI的结果比较：\",\"RTE数据集比较小，只有2490样本，只达到了56.0%准确率。\",\"问答和常识推理 结果如下表3，RACE数据集由初高中考试题构成。在Story Cloze和RACE提升明显。证明模型具有有效处理上下文长距离的信息的能力。\",\"语义相似度 语义相似度(或释义发现)任务涉及预测两个句子在语义上是否相等。挑战在于识别语句是否是概念改写，理解反面，处理句法歧义。使用的数据集：\",\"MRPC Microsoft Research Paraphrase corpus 是一些句子对，有的是同义的，有的是不同义的。\",\"QQP Quora Question Pairs 美国知识问答网站 Quora 上的问题答案数据集\",\"STS-B Semantic Textual similarity benchmark 语义文本相似度数据集，样本为文本对，评判两个文本语义信息的相似度，分数为1-5。\",\"在STS-B上有1个点的绝对提升，比Single-task BiLSTM + ELMo + Attn有4.2%的绝对提升。\",\"分类 两个不同分类任务的评估结果，也在上表4中。CoLA——Corpus of Linguistic Acceptability语言可接受性语料库，纽约大学发布的有关语法的数据集，该任务主要是对一个给定句子，判定其是否语法正确，因此CoLA属于单个句子的文本二分类任务。\",\"SST-2——The Stanford Sentiment Treebank, 主要针对电影评论来做情感分类，因此SST属于单个句子的文本分类任务（其中SST-2是二分类，SST-5是五分类，SST-5的情感极性区分的更细致)。\",\"CoLA上取得45.4，SST-2取得91.3的准确率，整体得分72.8。\",\"总体而言，在12个数据集上的9个取得SOTA结果，比许多情况下的ensemble模型要好。而且能适应不同大小数据集。\"]},\"516\":{\"h\":\"分析\",\"t\":[\"层数的迁移学习影响: 从预训练到微调迁移学习过程中，如下表2，在MultiNLI和RACE上的性能随着层数的变化而变化。作者观察标准结果，在MultiNLI上转移embedding能提升结果，每一层Transformer层能带来9%额外的提升。这表明预训练模型中的每一层都包含了解决目标问题有用的功能。\",\"零样本表现 最好要弄清楚为什么预训练模型会有效？一种假设是，与LSTMs相比，潜在生成式模型（underlying generative model）在应用到很多任务时可以提高语言建模的能力并且transformer更具结构化的注意力记忆（attentional memory）有助于迁移。在零样本上，LSTM表现高方差，表明在迁移中，Transformer架构导入偏差是有帮助的。\",\"对于CoLA（语言可接受性），样本的得分是用生成模型分配的tokens的平均对数概率，在阈值下进行预测的。\",\"对于SST-2(情感分析)，给每个实例样本加一个 very token,来限制语言模型的输出分布只有 positive和 nagative, 就是猜测被分配到高的概率值的token作为预测值。\",\"对于RACE(问答)，在文档和问题给定条件下，将生成模型分配的平均对数概率高的token作为答案。\",\"对于DPRD(威诺格拉德模式), 用两个可能的替换说法来代替定义的代词，在这之后用生成模型分配的剩下序列的平均token对数概率高的作为结果。\",\"消融研究 不同的消融研究如下表5.\",\"首先，作者在微调时用辅助的LM目标来检查作者模型的性能。在NLI和QQP任务上辅助LM目标有帮助。总之，就是大数据集有效，小数据集没有。\",\"其次，分析比较2048单元的单层LSTM和Transformer，二者都加同样的辅助LM，LSTM会掉5.6平均分数。\",\"最后，直接在监督学习任务上训练，不要预训练，这会导致在跨任务上性能降低14.8%.\"]},\"517\":{\"h\":\"结论\",\"t\":[\"作者介绍了一种框架，用任务未知的生成式预训练模型和判别式微调在自然语言理解上取得了很强的效果。通过在长篇连续文本的多样化语料库上预训练，作者模型获得了重要的世界知识和处理长距离依赖的能力，然后能成功迁移学习解决判别式任务，如问答，语义相似度评估，蕴含确定和文本分类，在12个的9个数据集取得了SOTA结果。\",\"使用无监督预训练来提升在判别式任务上的表现是机器学习研究的长期目标。作者的工作表明，实现显著的性能提升确实是可能的，并给出了提示Transformer类模型和长距离依赖的文本数据集最好用这种方法来训练。\"]},\"518\":{\"h\":\"GPT-2 论文\",\"t\":[\"GPT-2 论文\",\"论文链接: Language Models are Unsupervised Multitask Learners\"]},\"519\":{\"h\":\"摘要\",\"t\":[\"这篇论文《Language Models are Unsupervised Multitask Learners》由OpenAI团队提出，介绍了GPT-2模型，展示了大规模语言模型在无监督多任务学习中的潜力。GPT-2通过训练一个包含45百万网页链接的WebText数据集，能够在零样本（zero-shot）设置下完成多种自然语言处理任务，如问答、翻译、摘要和阅读理解等，无需任务特定的监督训练。研究发现，模型容量对任务性能至关重要，更大的模型在多个基准测试中达到了最先进水平。论文还探讨了模型泛化与记忆的关系，并指出GPT-2在生成连贯文本方面的能力，为构建通用语言处理系统提供了新思路。\"]},\"520\":{\"h\":\"简介\",\"t\":[\"当前机器学习系统的局限性\",\"当前的机器学习系统虽然在特定任务上表现出色，但依赖于大量标注数据和监督学习，导致其泛化能力有限。这些系统往往对数据分布或任务定义的微小变化非常敏感，表现为“狭窄的专家”而非通用的多任务处理者。作者指出，这种局限性部分源于单任务、单领域的数据集训练模式，限制了模型在多样化场景中的应用能力。\",\"多任务学习的挑战与机遇\",\"多任务学习（Multitask Learning）被视为提升模型通用性的潜在途径，但其在自然语言处理（NLP）领域的进展仍处于早期阶段。现有研究通常仅联合训练少量任务（如10-17个任务），而机器学习系统通常需要数百至数千个任务示例才能实现良好的泛化。作者认为，单纯依赖人工标注和设计任务目标难以满足多任务学习的规模化需求，因此需要探索更高效的学习范式。\",\"预训练与迁移学习的趋势\",\"近年来，预训练结合监督微调的方法在NLP任务中表现突出。从早期的词向量（如Word2Vec）到上下文感知的循环神经网络（如ELMo），再到基于自注意力机制的Transformer架构（如BERT、GPT），模型的迁移能力逐渐增强。然而，这些方法仍依赖监督数据。作者提出，语言模型本身可能通过无监督学习捕捉任务相关的知识，从而减少对显式监督的依赖。\",\"论文的核心假设与目标\",\"本文的核心假设是：足够大的语言模型在多样化文本训练下，能够通过预测任务的自然语言描述（如问答、翻译的文本示例）间接学习任务，而无需参数调整或架构修改。作者通过实验验证这一假设，证明GPT-2在零样本设置下能完成多种任务，部分任务性能接近或超越监督基线模型。这一发现为构建通用语言系统提供了新方向，同时揭示了模型容量与任务性能之间的紧密关联。\",\"研究意义\",\"论文强调，无监督任务学习是预训练技术成功的关键因素之一。尽管零样本性能尚不完美，但结果表明语言模型在无监督条件下已具备初步的多任务处理能力，为未来探索更通用的AI系统奠定了基础。\"]},\"521\":{\"h\":\"方法\",\"t\":[\"1. 语言建模的核心框架\",\"论文的核心方法是基于语言建模（Language Modeling, LM），即通过无监督学习估计文本序列的概率分布。给定一个符号序列 ((s_1, s_2, ..., s_n))，语言模型通过链式法则计算联合概率：\",\"这一框架允许模型不仅生成文本，还能计算任意条件概率，例如预测缺失的单词或句子。近年来，Transformer 架构（Vaswani et al., 2017）的引入显著提升了语言模型的表达能力，使其能够建模长距离依赖关系。\",\"2. 多任务学习的概率视角\",\"传统监督学习通常建模 ，而通用系统需要能够根据任务描述动态调整行为，即建模 。作者指出，McCann et al. (2018) 的MQAN（Multi-task Question Answering Network） 已经证明，任务可以通过自然语言描述（如“translate to French, English text, French text”）来指定。本文进一步假设，语言模型本身可以通过观察任务的自然语言演示（如问答对、翻译示例）来隐式学习任务，而无需显式监督。\",\"3. 训练数据集：WebText\",\"为了训练一个能够泛化到多种任务的语言模型，论文构建了一个新的数据集 WebText，其关键特点是：\",\"数据来源：从 Reddit 上爬取高赞（≥3 karma）的外链网页，确保内容经过人工筛选，质量高于 Common Crawl 等原始网络数据。\",\"规模与处理：初步版本包含约800万篇文档（40GB文本），去重并移除了 Wikipedia 数据以避免测试集污染。\",\"多样性目标：涵盖广泛的主题和写作风格，以增加模型接触不同任务（如翻译、摘要）自然演示的机会。\",\"4. 输入表示：改进的字节对编码（BPE）\",\"传统语言模型通常依赖单词或字符级输入，但存在词汇表限制或效率问题。本文采用字节级 BPE（Byte Pair Encoding），其优势包括：\",\"词汇表灵活性：基础词汇仅需256个字节，可表示任意 Unicode 字符串，避免传统 BPE 对 Unicode 编码的冗余扩展（如130,000+基词）。\",\"改进的合并策略：防止跨字符类别的合并（如“dog”与“dog!”被分开），减少词汇碎片化，同时允许空格合并以提高压缩效率。\",\"兼容性：支持对任何文本（无论预处理方式）直接计算概率，便于跨数据集评估。\",\"5. 模型架构：GPT-2 的改进\",\"GPT-2 基于 Transformer 架构，延续了 GPT-1（Radford et al., 2018）的设计，但进行了以下优化：\",\"层归一化调整：移至每个子模块的输入（类似预激活残差网络），并在最终自注意力块后增加额外层归一化。\",\"初始化优化：残差层权重按 缩放（ 为残差层数），缓解深层网络的梯度问题。\",\"扩展配置：词汇表增至50,257，上下文窗口从512扩展到1024 tokens，批大小提升至512。\",\"6. 实验设置与模型规模\",\"论文训练了 4种不同规模的模型（参数从117M到1.5B），以研究模型容量对性能的影响：\",\"最小模型（117M）与原始 GPT 相当，中等模型（345M）匹配 BERT-Large，最大模型 GPT-2（1.5B） 参数量远超 GPT-1。\",\"所有模型在 WebText 上仍表现欠拟合（held-out perplexity 持续下降），表明进一步扩大数据或模型可能提升性能。\",\"7. 任务执行的零样本机制\",\"GPT-2 的零样本能力依赖于任务提示（Task Prompting），即通过自然语言描述或示例引导模型生成目标输出。例如：\",\"翻译任务：输入“english sentence = french sentence”示例后，模型在“english sentence =”提示下生成翻译。\",\"摘要任务：在文章末尾添加“TL;DR:”触发摘要生成。\",\"问答任务：输入文档+对话历史+“A:”引导答案生成。\",\"这种方法无需微调，完全依赖语言模型对任务上下文的理解能力。\",\"总结\",\"无监督多任务学习的可行性证明：语言模型通过预测多样化文本中的任务演示（如翻译对、问答），隐式学习任务逻辑。\",\"数据与架构创新：WebText 的高质量数据、字节级 BPE 的通用性，以及 GPT-2 的规模化改进，共同支撑了零样本泛化能力。\",\"任务提示的关键作用：自然语言指令可作为隐式任务描述，激活模型的相关能力。\",\"这些设计使 GPT-2 成为首个在零样本设置下接近监督模型性能的大规模语言模型，为后续研究（如 GPT-3 的少样本学习）奠定了基础。\"]},\"522\":{\"h\":\"实验\",\"t\":[\"1. 实验设计与模型配置\",\"论文系统评估了不同规模的GPT-2模型（117M、345M、762M和1.5B参数）在多个NLP任务上的零样本（zero-shot）性能。所有模型均采用相同的架构，但层数、隐藏层维度和参数量不同（见表2）。实验的关键发现是：模型容量与任务性能呈对数线性关系，更大的模型在几乎所有任务上都显著优于小模型。作者特别指出，即使是最大的1.5B模型，在WebText验证集上仍未完全收敛（underfitting），表明进一步扩大模型和数据规模可能带来额外提升。\",\"2. 语言建模任务评估\",\"GPT-2在8个标准语言建模数据集上进行了测试，包括Penn Treebank（PTB）、WikiText-2、LAMBADA等。结果显示：\",\"跨领域泛化能力：GPT-2在7/8的数据集上刷新了零样本SOTA，特别是在小数据集（如PTB）和长程依赖任务（如LAMBADA）上提升显著。\",\"预处理的影响：由于GPT-2使用字节级BPE，可以避免传统tokenization的损失。通过可逆去token化（invertible detokenizers）处理，GPT-2的困惑度（perplexity）进一步降低了2.5-5点。\",\"例外情况：在One Billion Word Benchmark（1BW）上表现较差，作者归因于该数据集的句子级打乱破坏了长程依赖。\",\"3. 具体任务表现分析\",\"3.1 Children's Book Test（CBT）\",\"CBT测试模型对不同词类（命名实体、名词等）的预测能力。GPT-2在验证集（避免与WebText重叠）上达到：\",\"常见名词准确率93.3%（原SOTA 85.7%）\",\"命名实体准确率89.1%（原SOTA 82.3%）\",\"分析表明，模型容量增加直接缩小了与人类表现的差距（图2）。\",\"3.2 LAMBADA\",\"该任务要求预测句子的最后一个词，需要至少50个token的上下文理解。GPT-2将：\",\"困惑度从99.8降至8.6\",\"准确率从19%提升至52.66%\",\"通过添加停用词过滤器（避免生成非结尾词），准确率进一步提升至63.24%，超过此前需依赖上下文词约束的SOTA方法。\",\"3.3 Winograd Schema Challenge\",\"测试常识推理能力（共273个样例）。GPT-2以70.7%的准确率超越前SOTA（Trinh & Le, 2018）7个百分点。作者指出，尽管数据集小，但结果与人类表现（约95%）的差距已显著缩小。\",\"3.4 阅读理解（CoQA）\",\"在对话式问答数据集上，GPT-2仅通过文档+历史对话+“A:”提示生成答案，达到55 F1：\",\"匹配或超过3/4监督基线的性能\",\"但远低于人类（89 F1）和BERT SOTA\",\"错误分析显示，模型倾向于使用简单的检索启发式（如用文档中的人名回答\\\"who\\\"问题）。\",\"3.5 摘要生成（CNN/Daily Mail）\",\"通过“TL;DR:”提示+Top-k采样（k=2）生成摘要：\",\"ROUGE分数仅略高于随机选句基线\",\"但定性分析显示生成内容类似摘要, 移除提示后性能下降6.4点，证明自然语言指令可激活任务特定行为。\",\"3.6 翻译（WMT-14）\",\"尽管WebText几乎无平行语料，GPT-2通过示例提示：\",\"英→法：5 BLEU（低于词对齐基线）\",\"法→英：11.5 BLEU（超过部分无监督方法）\",\"作者推测英语语言模型的强大概率补偿了翻译知识的不足。\",\"3.7 问答（Natural Questions）\",\"在事实型问答测试中：\",\"精确匹配准确率4.1%（远低于监督系统30-50%）\",\"但对高置信度预测（top 1%），准确率达63.1%\",\"表明模型容量是限制因素（最小模型仅1.0%准确率）。\",\"4. 记忆与泛化分析\",\"4.1 数据重叠检测\",\"使用Bloom过滤器统计测试集与WebText的8-gram重叠率：\",\"平均重叠率3.2%（与常规训练-测试重叠率5.9%相比更低）\",\"极端案例：WikiText-103测试集1.6%重叠（因文章复用段落）\",\"对性能影响：LAMBADA去除重叠样本后，困惑度仅从8.6→8.7\",\"4.2 训练集与测试集性能对比\",\"图4显示，WebText训练集和测试集的困惑度同步下降，表明：\",\"即使1.5B模型仍欠拟合\",\"性能提升非源于记忆，而是真实泛化能力\",\"4.3 生成样本分析\",\"表13展示GPT-2在非分布数据（如“独角兽新闻”）上的生成能力：\",\"能生成连贯但虚构的内容\",\"证实模型并非简单记忆，而是组合学到的知识\",\"5. 实验结论\",\"规模定律：模型容量与零样本性能强相关，1.5B参数模型在多数任务上逼近或超越监督基线。\",\"任务通用性：单一语言模型可处理翻译、问答、摘要等多样化任务，仅需自然语言提示。\",\"数据质量：WebText的多样性和规模是关键，但数据重叠对结果影响有限。\",\"局限性：摘要、翻译等任务表现仍远逊于专业系统，显示无监督学习的当前边界。\",\"这些实验为后续研究（如GPT-3的少样本学习）提供了重要基准，证明无监督预训练在多任务迁移中的巨大潜力。\"]},\"523\":{\"h\":\"讨论\",\"t\":[\"无监督任务学习作为预训练技术成功的关键因素。研究表明，当语言模型在足够多样化的文本数据上训练时，能够通过预测任务的自然语言演示（如翻译对、问答示例）隐式学习任务逻辑，而无需显式监督。这一发现为理解当前预训练模型的有效性提供了新视角，并表明在极限情况下，语言模型可能直接学会执行任务。\",\"作者同时指出GPT-2的局限性：虽然在阅读理解等任务上接近监督基线，但在摘要、翻译等任务上的表现仍远未达到实用水平。这种性能差异揭示了当前方法的边界，表明模型容量和训练数据规模仍需进一步扩大。特别值得注意的是，GPT-2的完全抽象式输出（如问答时生成而非抽取答案）与传统指针网络方法形成鲜明对比，这为未来探索更灵活的文本生成方式提供了启示。\",\"未来研究方向，包括探索GPT-2的微调潜力（如在GLUE等基准上的表现），以及研究双向表示（如BERT）与单向语言模型的互补性。这些发现为后续GPT-3等更大规模模型的开发奠定了基础，推动学界重新思考语言模型在多任务学习中的角色。\"]},\"524\":{\"h\":\"总结\",\"t\":[\"本文通过GPT-2模型证明了大规模语言模型在无监督多任务学习中的强大潜力。当模型在足够大且多样化的文本数据（WebText）上训练时，仅通过语言建模目标就能在零样本设置下完成多种NLP任务，并在7/8的语言建模基准上达到SOTA水平。这一发现表明，高容量模型通过最大化文本序列的似然估计，可以自发地学习执行任务，而无需明确的监督信号。\",\"研究结果对构建通用语言系统具有重要意义：首先，它验证了单一模型架构通过规模扩展即可实现多任务处理的可能性；其次，展示了自然语言本身作为任务描述符的有效性。尽管当前零样本性能仍有限，但这一方向为减少对人工标注数据的依赖提供了新思路。\",\"最后，论文指出这仅是通向更通用AI系统的初步探索。作者开放了模型代码和小型预训练模型，鼓励后续研究继续探索更大规模语言模型的行为边界，以及如何更好地利用其隐含学习到的多任务能力。这项工作为后续GPT系列模型的发展奠定了理论基础和方法框架。\"]},\"525\":{\"h\":\"GPT-3 论文\",\"t\":[\"GPT-3 论文\",\"论文链接: Language Models are Few-Shot Learners\"]},\"526\":{\"h\":\"摘要\",\"t\":[\"这篇论文介绍了GPT-3，一个具有1750亿参数的自回归语言模型，通过大规模训练显著提升了少样本学习能力。GPT-3在多种自然语言处理任务中表现出色，包括翻译、问答和文本生成等，甚至在零样本和单样本设置下也能取得有竞争力的结果。研究还探讨了数据污染问题、模型局限性及其社会影响，如偏见和能源消耗。实验表明，模型规模的扩大带来了性能的持续提升，但某些任务仍存在挑战。论文强调了GPT-3在通用语言系统发展中的潜力及其可能带来的广泛社会影响。\"]},\"527\":{\"h\":\"简介\",\"t\":[\"1. 背景与动机\",\"近年来，自然语言处理（NLP）领域逐渐转向预训练语言模型，并采用更灵活的任务无关（task-agnostic）方法进行下游迁移学习。早期的模型（如词向量、RNN）依赖任务特定的架构，而现代模型（如Transformer）可直接微调，无需额外架构调整。然而，现有方法仍需要针对每个任务进行大规模监督数据微调，这限制了模型的广泛应用。相比之下，人类仅需少量示例或简单指令即可完成新任务，因此论文探索如何让语言模型具备类似的少样本学习能力。\",\"2. 现有方法的局限性\",\"当前基于微调的方法存在三个主要问题：\",\"数据需求高：每个任务需要数千至数十万标注样本，难以覆盖广泛的语言任务。\",\"泛化能力有限：模型容易过拟合训练数据的虚假相关性（spurious correlations），导致在分布外数据上表现不佳。\",\"与人类学习方式不匹配：人类可通过少量示例或自然语言指令快速适应新任务，而现有模型难以实现类似能力。\",\"3. 元学习与上下文学习的潜力\",\"论文提出通过元学习 (meta-learning) 提升模型的少样本学习能力，即在预训练阶段让模型隐式学习多种技能，并在推理时通过上下文（in-context learning）快速适应新任务。此前的研究（如GPT-2）已初步验证了上下文学习的可行性，但性能远低于微调方法。论文假设，模型规模的扩大可能显著提升上下文学习能力，因为更大容量的模型能吸收更多任务相关的模式。\",\"4. GPT-3 的目标与贡献\",\"论文训练了GPT-3（1750亿参数），比此前最大的非稀疏语言模型大10倍，并系统评估其在零样本（zero-shot）、单样本（one-shot）和少样本（few-shot）设置下的表现。实验覆盖了翻译、问答、常识推理等多样化任务，结果显示：\",\"在少样本设置下，GPT-3 接近或超越部分任务的微调模型性能。\",\"模型规模与少样本学习能力呈正相关，表明缩放定律（scaling laws）在此类任务中依然适用。\",\"同时，论文也分析了模型在自然语言推理（NLI）等任务上的局限性，并探讨了数据污染和社会影响等问题。\",\"5. 研究意义\",\"GPT-3 的成果表明，超大规模语言模型可以显著减少对任务特定数据的需求，推动更通用、灵活的语言系统发展。然而，其局限性（如计算成本、偏见问题）也提示了未来改进方向，如结合双向架构或多模态训练。论文最终强调，这一研究为探索语言模型的元学习机制和实际应用奠定了基础。\"]},\"528\":{\"h\":\"方法\",\"t\":[\"1. 四种任务设定方法的比较\",\"作者首先定义了语言模型执行任务的四种方式：\",\"Fine-tuning（微调）：在任务特定数据集上更新模型权重，通常需要数千到数十万个标注样本，性能最佳，但泛化能力弱，且每个任务都需新数据。\",\"Few-shot learning（少样本学习）：在推理时为模型提供10-100个任务示例作为上下文，无需参数更新，显著减少数据需求。\",\"One-shot learning（单样本学习）：提供一条示例和任务描述，有时更贴近人类学习习惯。\",\"Zero-shot learning（零样本学习）：仅提供任务描述，不给任何示例，是最具挑战也最通用的形式。\",\"如图 2.1 所示（Figure 2.1），这些方法在数据需求和任务适应能力之间形成一个光谱，GPT-3主要研究后三种方法，强调它们在无需微调的情况下就能取得良好效果，尤其是few-shot设定下的表现令人惊喜。\",\"2. 模型架构与规模设计\",\"GPT-3模型架构基本沿用GPT-2，包括预归一化、可逆tokenizer等设计，但采用稀疏注意力机制（Sparse Transformer）以提升效率。作者训练了从125M到175B参数的8个模型（见表 2.1），以研究性能与规模之间的关系。所有模型共享最大上下文窗口为2048 tokens。模型训练过程中采用混合并行策略以适应大规模参数训练。\",\"3. 数据集构成与过滤策略\",\"GPT-3的训练数据主要来自以下五个来源（见表 2.2）：\",\"Common Crawl（经过过滤，占比60%）\",\"WebText2、Books1、Books2、Wikipedia（合计40%）\",\"为保证数据质量，作者对Common Crawl执行了质量过滤和模糊去重，并引入高质量参考语料。重要的是，数据在训练中并非按体量采样，而是按质量设权重采样，高质量数据被重复使用，而Common Crawl这类数据在整个训练中只被读取一次左右。\",\"4. 训练过程与资源分配\",\"大模型使用较大的batch size和较小的学习率（详见表 2.1）。训练依赖微软提供的高带宽GPU集群，采用模型层间和矩阵级别的并行方式进行。所有模型都使用3000亿tokens进行训练，训练策略遵循了《Scaling Laws for Neural Language Models》一文的建议。\",\"如图 2.2 所示（Figure 2.2），GPT-3虽然模型更大，但实际训练所需的计算资源与较小模型相当，这得益于更高效的数据利用率。\",\"5. 评估方法与设定\",\"在few-shot设定下，模型的每个测试样本前会插入K条示例（K通常为10-100，取决于是否能容纳在2048 token窗口中）。对于没有训练集的数据集，示例从开发集提取；对于多选题，GPT-3比较不同答案的语言模型概率（归一化处理）；对于生成类任务，则使用beam search输出，并按F1、BLEU或精确匹配评估。最终结果在公开测试集或开发集上报告。\",\"总结\",\"GPT-3的研究方法基于“任务不可知”的设定，通过大规模预训练和精心设计的上下文输入，在不进行梯度更新的前提下实现任务适应。这种“以上下文为接口”的元学习方法，加上参数规模的扩展，使得GPT-3在多个任务上展现出超越以往fine-tuned方法的能力，为未来通用语言智能系统奠定了基础。\"]},\"529\":{\"h\":\"结果\",\"t\":[\"1. 模型性能随规模扩展而持续提升\",\"作者首先展示了8个不同规模的模型在训练过程中的表现，发现无论是在训练损失还是实际任务中的表现，都随着模型参数的增长而呈现平滑的幂律提升趋势（见图 3.1 和图 3.3）。这表明大模型能够更好地吸收语言知识和上下文信息。\",\"2. GPT-3在语言建模和完形填空任务中的表现\",\"GPT-3在传统语言建模任务（如PTB）中零样本设定下创下新SOTA（PPL 20.5），远优于此前结果（PPL 35.8）。在LAMBADA数据集上，few-shot设置下准确率达到86.4%，比原SOTA高出18%（见图 3.2）。此外，在StoryCloze和HellaSwag等故事完形任务中，GPT-3也表现出明显的few-shot优势。\",\"3. 在封闭式问答任务中接近甚至超越SOTA\",\"GPT-3在TriviaQA、WebQuestions 和 Natural Questions这三个问答任务中，在没有使用外部检索信息（closed-book）或微调的前提下，仅通过few-shot设定就达到了与微调SOTA模型相当甚至更优的水平。尤其在TriviaQA中，few-shot得分达到71.2%，超越了一些基于检索系统的模型（如RAG）。\",\"4. 多语言翻译能力显著提升\",\"尽管训练数据中非英语文本仅占7%，GPT-3在英法、英德、英罗等语言对的few-shot翻译任务中，已超越多项无监督NMT方法的表现（见表 3.4 和图 3.4）。尤其在翻译为英语的方向上，GPT-3展现出更强的语言建模优势。\",\"5. 常识推理与Winograd类任务\",\"GPT-3在Winograd Schema Challenge中零样本即可取得88.3%的准确率，接近人类水平，且在更具挑战性的Winogrande数据集上few-shot得分达到77.7%，逼近fine-tuned大型模型表现（见图 3.5）。但对于如WiC（语义一致性）任务，GPT-3表现较差（仅为49.4%），显示在一些语义比较任务上仍存在明显短板。\",\"6. 阅读理解与逻辑推理任务表现不一\",\"在阅读理解任务中（如CoQA、DROP、QuAC、SQuADv2），GPT-3在few-shot设定下表现优异，尤其在CoQA中few-shot得分（85.0 F1）仅比人类低几分（见图 3.7）。但在结构化或需要多步推理的任务中（如DROP、RACE、QuAC），表现则不及微调模型，显示GPT-3对复杂语义结构的掌握仍有提升空间。\",\"7. SuperGLUE整体表现良好，但有短板\",\"在SuperGLUE基准测试中，GPT-3在少样本（32个示例）设定下，在BoolQ、ReCoRD等任务上表现接近SOTA，在COPA任务中仅落后1-2分。但在如WiC、CB、MultiRC等任务上显著低于fine-tuned模型（见表 3.8 和图 3.8）。这说明GPT-3在识别细粒度语义差异上仍有明显不足。\",\"8. NLI和Adversarial推理任务仍具挑战性\",\"在自然语言推理任务（如RTE和ANLI）中，即使是GPT-3 175B也只能在few-shot设定下稍高于随机水平（约33%），表现远不如fine-tuned模型（见图 3.9）。尤其在ANLI这种对抗性构建的数据集上，GPT-3展示了推理能力的不足。\",\"9. 在合成任务和灵活性测试中展现强大泛化能力\",\"GPT-3在设计的算术、字母重排、新词使用、语法纠错等任务中，只需提供极少量的示例就能成功完成，这表明其具有一定程度的推理和快速适应能力。这些任务测试了GPT-3的few-shot元学习能力，显示其对“任务模式”的提取并非依赖微调。\",\"总结\",\"GPT-3在多数NLP任务中，在zero-, one-, few-shot设定下均展示了强大的任务适应能力，尤其在few-shot情境下，其表现多次逼近甚至超越传统fine-tuned模型。与此同时，一些任务（如对抗性推理、语义比较等）仍暴露出其推理深度与语言理解的局限，提示未来需在结构理解与逻辑泛化方面进一步改进。\"]},\"530\":{\"h\":\"局限性\",\"t\":[\"1. GPT-3 并非通用智能：能力分布不均\",\"尽管GPT-3在多个任务上取得了令人印象深刻的成绩，但作者明确指出，它并不是一个通用智能系统，其表现呈现出高度任务依赖性：在某些任务中可与SOTA模型媲美，但在其他任务（如自然语言推理、逻辑比较）中则表现平庸甚至接近随机。\",\"这种“选择性优势”意味着GPT-3更像是一个巨大的“模式匹配引擎”，而非真正理解语言和任务的系统。\",\"2. 缺乏鲁棒的系统性泛化能力\",\"GPT-3的few-shot能力主要依赖于识别任务格式和输出模式，而不是进行真正意义上的概念抽象和泛化。作者指出，目前尚不清楚模型在推理任务中是否“学会”了新知识，还是只是记住了相似的训练样本。这种 泛化机制的模糊性 是目前元学习方法的一个重要限制。\",\"3. Prompt依赖性强，输入微小变动影响大\",\"GPT-3对提示（prompt）形式和内容高度敏感。不同的措辞、问题格式甚至换行方式都可能造成性能大幅波动。\",\"这意味着few-shot效果难以稳定复现，缺乏可控性与鲁棒性，在实际部署中可能导致意外错误。\",\"4. 上下文窗口限制性能提升\",\"尽管GPT-3的上下文窗口扩大到2048 tokens，相比前代模型大幅提升，但这仍然限制了few-shot学习中可用的示例数量（尤其是在长文本任务中）。作者认为，有限上下文容量成为当前few-shot学习的“瓶颈”。\",\"5. 无法利用结构化监督信号\",\"GPT-3完全不依赖梯度更新，因此无法像微调方法那样从结构化监督中持续优化。在特定任务上（如NER、结构化问答、程序生成等），GPT-3的表现明显弱于专门微调过的模型。这表明它在需要长期优化和知识整合的任务中仍有较大局限。\",\"6. 推理与数学能力仍然有限\",\"GPT-3虽然能完成基础算术和简单逻辑题，但在 多步推理、抽象代数、数理一致性等方面 表现仍然较弱。这限制了其在金融、科研、工程等高精度领域的适用性。\",\"7. 模型不可解释性问题严重\",\"GPT-3的推理过程完全由大量参数和非线性变换组成，目前尚无有效方式解释它为何会给出某一答案。这种不可解释性限制了其在高风险领域的应用，如医疗、法律、金融决策等。\",\"总结\",\"虽然GPT-3在few-shot学习方面展现出极强的能力，但其本质仍是一个“超大规模、强记忆型的语言预测器”，而非具备深层理解与推理能力的系统。它面临的问题包括任务适应不均、prompt敏感性高、缺乏结构化监督利用能力、推理有限、以及缺乏透明性等。这些限制提示我们，在使用GPT-3及其衍生模型时，仍需谨慎评估其边界与适用性，并探索更强的系统性泛化能力和稳健性。\"]},\"531\":{\"h\":\"相关工作\",\"t\":[\"1. 从词向量到上下文表示的发展历程\",\"该部分首先回顾了自然语言处理（NLP）领域中语言表示学习的演进：\",\"早期方法（如 word2vec、GloVe）关注学习固定词向量；\",\"后续方法（如 ELMo、ULMFiT）引入上下文，支持基于上下文的词表示；\",\"Transformer 时代：BERT、GPT 系列、XLNet 等模型将预训练语言模型推向主流，支持更广泛的下游任务，通过微调在多个任务上实现了SOTA。\",\"GPT-3继承了这一发展路线，并将参数规模推至前所未有的高度，强化了“无任务特定架构”的方法论。\",\"2. 微调范式与任务适应能力的关系\",\"在GPT-3之前，大多数SOTA模型依赖于“预训练 + 微调”范式，即先在大语料上预训练，再在具体任务数据上进行监督微调（如BERT、T5）。这种方法虽然效果强大，但依赖大量任务标注数据，不利于迁移与泛化。\",\"GPT-3的核心创新之一，是系统性地探索 无梯度更新的few-shot学习（in-context learning），挑战了传统对“适应任务必须微调”的假设。\",\"3. 元学习与few-shot学习的启发\",\"作者借鉴了 元学习（meta-learning） 的理念，即模型在“外循环”中获得广泛能力，在“内循环”中快速适应新任务。GPT-3通过扩展模型容量，在预训练阶段学习泛化模式，在推理阶段用文本输入指定任务，实质是一种“隐式元学习”机制。\",\"这与Few-shot Learning领域中如MAML、Prototypical Networks、Matching Networks等方法异曲同工，但不同于它们使用结构明确的元任务，GPT-3完全通过文本学习并表达任务结构。\",\"4. 模型规模扩展趋势与“Scaling Laws”\",\"文中引用了Kaplan等人提出的“神经语言模型的规模定律（Scaling Laws）”，即验证集损失随着模型规模、数据量和计算量按幂律缩放。在这一理论指导下，GPT-3以175B参数扩展至前代模型的10倍以上。\",\"GPT-3验证了一个关键假设：few-shot能力会随着模型规模的增加而显著增强，补足了先前few-shot模型（如 GPT-2、CTRL、T5）表现不稳定的问题。\",\"5. 多任务与多语言学习的基础\",\"GPT-3并未对每个任务建立单独的模型，而是通过单一语言建模目标，实现任务统一与跨任务迁移，呼应了T5等模型的“文本到文本”框架。同时，它在某种程度上也具备一定的多语言能力，尽管其非英语性能仍有限。\",\"此外，文中提到了一些少量使用in-context设定的早期尝试（如 GPT-2 的zero-shot prompt），但GPT-3是首次系统性、大规模地在zero-, one-, few-shot条件下进行全面评估的工作。\",\"总结\",\"GPT-3站在了词向量、上下文建模、transformer架构、微调范式、元学习和模型扩展趋势等多个重要研究方向的交汇点上。它在技术上并非从零出发，而是有机融合并推升了这些已有成果，将预训练语言模型从“参数调优”时代推向了“推理即编程”的新范式。\"]},\"532\":{\"h\":\"结论\",\"t\":[\"作者指出，GPT-3 展示了强大的in-context learning（上下文学习）能力，在不进行任何梯度更新的前提下，仅通过自然语言提示和示例，即可在多种语言任务中实现从零样本到少样本的泛化，部分任务甚至达到或超越微调模型的水平。尽管仍存在局限，但结果表明：随着模型规模扩展，大规模语言模型在任务通用性与灵活性方面具有巨大潜力，为未来通用语言智能系统的发展提供了重要方向。\"]},\"533\":{\"h\":\"InstructGPT 论文\",\"t\":[\"InstructGPT 论文\",\"论文链接: Training language models to follow instructions with human feedback\"]},\"534\":{\"h\":\"摘要\",\"t\":[\"本研究指出，仅通过增加语言模型的规模，并不能显著提升其对用户意图的理解与遵循能力。为了解决这一问题，作者提出一种通过人类反馈对模型进行微调的方法，用以更好地对齐模型行为与用户意图。\",\"具体方法包括：首先利用人工演示数据对GPT-3进行监督学习微调；然后通过人类对多个模型输出的偏好进行排序，训练奖励模型，并结合强化学习进一步优化模型。最终所得的InstructGPT模型，即使参数量远小于原始GPT-3（例如1.3B对比175B），在用户偏好评估中仍表现更优。此外，InstructGPT在输出真实性、减少有害内容生成等方面也有所改进，且在公开NLP任务上的性能损失极小。研究表明，人类反馈微调是一种有效的模型对齐手段，尽管仍有提升空间。\"]},\"535\":{\"h\":\"简介\",\"t\":[\"作者指出，大型语言模型（如GPT-3）虽然具备强大的自然语言处理能力，但它们常常偏离用户意图，表现出诸如捏造事实、生成有害或无关文本、不遵循指令等问题。这是因为它们的训练目标是最大化互联网文本的下一个词预测概率，而非“安全且有用地遵循用户指令”，这造成了目标的不一致，即“对齐问题”（alignment problem）。\",\"为解决这一问题，本文提出了一种对齐语言模型与用户意图的策略：通过人类反馈进行强化学习（Reinforcement Learning from Human Feedback, RLHF）。该方法包括三个关键步骤：\",\"监督学习微调（SFT）：收集人类示范数据，微调预训练的GPT-3模型；\",\"奖励模型训练（RM）：收集人类对模型多个输出的排序偏好，训练出一个能预测人类偏好的奖励模型；\",\"强化学习微调（PPO）：使用奖励模型的反馈，采用Proximal Policy Optimization算法进一步优化模型行为。\",\"作者称这些过程使得模型输出更符合人类偏好，但强调这种对齐是相对于特定人群（即标注者和研究者）的偏好，并非广义上的“人类价值”。\",\"通过图1的结果可见，即便是只有1.3B参数的InstructGPT模型，其输出也比175B的原始GPT-3更受人类偏好，显示出这种人类反馈驱动的微调策略极具潜力。图1中显示的不同模型在人类偏好评估中的胜率清晰反映了该方法的有效性，表明训练目标的改变（从“预测下一个词”转向“优化人类偏好”）能带来质的改善。\",\"此外，作者采用了“有帮助（helpful）、诚实（honest）、无害（harmless）”三大原则来评估模型对齐效果，强调未来开发和部署语言模型时需格外关注其社会影响及安全性。\",\"总之，本文引入了一种有效的对齐方法，为语言模型行为与用户意图之间架起了桥梁，为AI安全和实用性的发展提供了关键路径。\"]},\"536\":{\"h\":\"相关工作\",\"t\":[\"一、基于人类反馈的模型对齐（Alignment via Human Feedback）\",\"InstructGPT 的核心技术基础是 “强化学习来自人类反馈（RLHF）”，旨在将模型输出行为与人类意图对齐。这一方法起初应用于强化学习场景：\",\"用人类偏好训练强化学习代理 : Christiano et al., 2017 提出了一种通过人类偏好比较训练代理的强化学习方法。\",\"在模拟环境中用人类反馈改进行为策略 : Ibarz et al., 2018将人类偏好学习应用于模仿学习。\",\"RLHF 后来被应用于语言任务，如摘要：\",\"风格延续任务中的偏好学习 : Ziegler et al., 2019\",\"文本摘要中的奖励建模与 PPO 微调 : Stiennon et al., 2020\",\"此外，该方向在对话系统（Jaques et al., 2019）、机器翻译（Bahdanau et al., 2016）、语义解析（Lawrence and Riezler, 2018）、故事生成（Zhou and Xu, 2020）等任务中也得到了广泛实践。\",\"InstructGPT 的工作属于对上述方法的泛化：将 RLHF 用于对齐语言模型在广泛任务分布下的行为。\",\"二、训练语言模型以遵循自然语言指令（Instruction Following）\",\"另一相关研究方向是使用自然语言指令训练模型以实现跨任务泛化：\",\"FLAN：使用数十个 NLP 数据集、配以自然语言任务说明进行微调。 （Wei et al., 2021）\",\"T0 / T0++：将 NLP 基准任务转换为指令格式，通过多任务微调训练语言模型。 （Sanh et al., 2021）\",\"Natural Instructions：探索指令格式变化对模型泛化能力的影响。 （Mishra et al., 2021）\",\"InstructGPT 与上述方法的不同之处在于其训练数据源真实 API 用户提交的指令，更具 任务多样性与实用性。\",\"图 1 支持这一点：即使参数量远小于 GPT-3（1.3B vs. 175B），InstructGPT 模型依然在用户指令任务中获得更高的偏好评分。\",\"三、评估语言模型的风险与危害\",\"InstructGPT 还借鉴了对语言模型潜在风险的研究，这些研究强调：\",\"语言模型会生成有害或偏见内容（Bender et al., 2021；Gehman et al., 2020）\",\"TruthfulQA 提供了一个用于测试模型生成信息真实性的基准数据集 （Lin et al., 2021）\",\"偏见评估数据集：包括 Winogender（性别偏见）和 CrowS-Pairs（社会偏见）（Rudinger et al., 2018,Nangia et al., 2020）\",\"InstructGPT 在实验部分也采用了这些基准（见论文第 4 节），并指出：在对毒性任务加入“请尊重”提示时，InstructGPT 比 GPT-3 更少生成有害内容（见 Figure 7）。\",\"四、模型行为干预与有害输出缓解策略\",\"文献中也探索了多种控制模型输出的策略，这些方法为 InstructGPT 所采用的 RLHF 方式提供了对照方案：\",\"微调小型数据集以嵌入价值观 （Solaiman and Dennison, 2021）\",\"通过触发短语过滤预训练语料，以降低毒性输出倾向 （Ngo et al., 2021）\",\"使用外部语言模型引导生成方向（如 Plug-and-Play Language Models） （Dathathri et al., 2019）\",\"用正则化或投影技术缓解嵌入空间中的偏见 （Liang et al., 2021）\",\"尽管 InstructGPT 并未直接采用这些方法，但在强化学习微调中加入 KL 约束、预训练梯度（PPO-ptx）等机制，实际上也体现了对 对齐损失(alignment tax) 的控制。\",\"以下是对 InstructGPT 论文中第 3 节 “Methods and Experimental Details” 的详细总结，内容结构遵循原文小节安排（3.1–3.6），并结合论文图表（如图 2）以增强理解。部分内容需分多段呈现以保留关键信息。\"]},\"537\":{\"h\":\"方法\",\"t\":[\"InstructGPT 的方法主要基于 Stiennon et al. (2020) 和 Ziegler et al. (2019) 提出的 三步训练框架，用以实现语言模型对人类意图的对齐。该流程可参见论文图 2 的三步训练流程：\",\"监督微调（Supervised Fine-Tuning, SFT）: 使用人类标注者示范的优质输出，微调预训练 GPT-3 模型，得到初始策略模型。\",\"奖励模型训练（Reward Model, RM）: 收集一组模型输出对（针对同一输入），由人类标注者根据偏好进行排序。将这些排序用作训练奖励模型（RM）的监督信号，使其学会预测哪一输出更受偏好。\",\"使用 PPO 强化学习（Proximal Policy Optimization）微调模型: 以奖励模型为环境反馈信号，对 SFT 模型进一步使用 PPO 算法进行强化学习优化，从而得到最终的 InstructGPT 模型。\",\"图 2（Figure 2） 明确展示了这三步流程之间的数据流和优化路径，是 InstructGPT 方法的核心概括图。\",\"数据集构建（Dataset）\",\"InstructGPT 的训练数据主要来自以下两个来源：\",\"真实用户在 OpenAI API Playground 提交的 prompt\",\"提取并去重后用于训练 SFT、RM 和 PPO 模型。为确保训练集与评估集分离，按用户 ID 进行划分。\",\"为防止泄露隐私，对训练数据进行了 PII 过滤。\",\"标注者创作的 prompt（主要用于冷启动训练）\",\"分为三类：\",\"Plain（开放任务）\",\"Few-shot（带示例的任务）\",\"User-based（模拟用户需求的任务）\",\"三类子数据集：\",\"SFT 数据集（~13k prompts）用于监督微调\",\"RM 数据集（~33k prompts）用于训练奖励模型\",\"PPO 数据集（~31k prompts）为 PPO 模型提供输入\",\"表 1 显示了 API prompt 的任务分布：约 46% 为生成类任务，QA 和聊天合计约 23%，突出了真实用户需求的多样性。\",\"任务类型（Tasks）\",\"训练任务覆盖广泛，包括但不限于：\",\"文本生成（如创作、补全）\",\"问答（开放型和封闭型）\",\"对话、重写、摘要、分类、抽取等\",\"大部分任务通过自然语言指令表达意图。少量则通过 few-shot 示例或文本上下文隐式表达。标注者在判断指令时需考虑信息准确性、避免偏见与毒性，这为 InstructGPT 模型“helpful, honest, harmless”标准提供训练信号。\",\"人类数据采集（Human Data Collection）\",\"OpenAI 雇佣了约 40 名标注者（通过 Upwork 与 ScaleAI）参与数据标注，执行以下任务：\",\"提供高质量示范（用于 SFT）\",\"对模型输出进行偏好排序（用于 RM）\",\"对最终模型进行评估\",\"为了保证标注质量，OpenAI 设计了 筛选测试 来挑选具有敏感内容识别能力的标注者。训练过程中的一些 prompt 包含争议性内容，故特别强调标注者的社会敏感性。\",\"在人类偏好标注中，inter-annotator agreement 达到 73±1.5%，说明标注者之间达成了较高的一致性。论文还进行了一组 held-out 标注者实验，显示 InstructGPT 模型能够泛化到新标注者的偏好。\",\"模型结构与训练细节（Models）\",\"所有模型都基于 GPT-3 架构 ，在三个参数规模（1.3B、6B、175B）下进行训练，训练策略如下：\",\"SFT 模型训练\",\"使用标注者示范数据，训练 16 个 epoch\",\"使用余弦学习率衰减，0.2 的残差 dropout\",\"用奖励模型得分选择最佳模型（而非验证 loss）\",\"奖励模型（RM）训练\",\"输入为 prompt 和 response，输出为标量奖励\",\"在每个 prompt 上收集 K（4–9）个响应，由标注者排序，训练时将所有配对作为一个 batch，防止过拟合\",\"使用如下 pairwise ranking loss：\",\"loss(θ) = − (1 / C(K,2)) * E[log(σ(r_θ(x, y_w) − r_θ(x, y_l)))]\",\"其中 、 分别为更受欢迎和较差的响应。\",\"PPO 和 PPO-ptx 模型训练\",\"PPO 使用 RM 作为奖励函数\",\"为缓解对奖励函数的过度优化，引入 KL 惩罚项\",\"PPO-ptx 版本进一步加入 pretraining 任务的 log-likelihood 更新项，以防对齐过程中性能退化（alignment tax）\",\"PPO-ptx 目标函数如下：\",\"Objective = E[r − β * KL + γ * logP_pretrain]\",\"评估方式（Evaluation）\",\"为了衡量模型的“对齐程度”，InstructGPT 使用了综合性评估框架：\",\"A. API prompt 分布评估\",\"使用 held-out 用户的 prompt\",\"人类评估输出的偏好、质量（Likert 1–7）、以及一系列元数据（如是否 hallucinate、是否尊重约束）\",\"图 4 展示了模型在是否遵循指令、幻觉率等多个维度的性能\",\"B. 公共 NLP 数据集评估\",\"涉及 TruthfulQA（真实性）、RealToxicityPrompts（毒性）、Winogender/CrowS-Pairs（偏见）\",\"还评估模型在 SQuAD、DROP、HellaSwag、WMT 2015 等任务上的零样本表现\",\"显示模型在强化学习过程中存在轻微性能损失，但 PPO-ptx 可有效缓解（见图 29–34，原文）\"]},\"538\":{\"h\":\"结果\",\"t\":[\"1. 在 API prompt 分布上的实验结果:\",\"InstructGPT 的核心实验基于真实用户提交的指令性 prompts，在这些任务中：\",\"人类评估者显著偏好 InstructGPT 输出\",\"Figure 1 显示：在用户任务分布中，1.3B 的 InstructGPT 模型比 175B GPT-3 更受偏好。\",\"即使是少样本提示增强的 GPT-3（few-shot GPT-3），也不及 InstructGPT。\",\"例如，175B InstructGPT 输出相较于标准 GPT-3 的偏好比为 85% ± 3%，相比 few-shot GPT-3 为 71% ± 4%。\",\"PPO-ptx 与 PPO 模型均优于 SFT 和 GPT-3\",\"Figure 3 显示，在两类提示分布（GPT-3 与 InstructGPT 用户提交）上，InstructGPT 在所有规模下均优于 GPT-3。\",\"并且该优势在训练标注者和 held-out 标注者之间都保持一致，说明偏好并非训练数据过拟合造成。\",\"更好地遵循指令，减少幻觉，更适合作为用户助手\",\"Figure 4 展示了模型输出的多维质量元数据对比：\",\"InstructGPT 更少“幻觉”（hallucination）\",\"更能遵守“指令中的显式约束”\",\"更常“尝试正确完成任务”\",\"更适合用于“客户助手场景”\",\"2. 在公开 NLP 数据集上的实验结果\",\"在 TruthfulQA 上更真实、更少编造\",\"Figure 6 显示，在 TruthfulQA 基准上，PPO 和 PPO-ptx 模型显著提升回答的真实性与信息性。\",\"例如，在加入指导性提示（instruction+QA）时，InstructGPT 倾向于不作伪答（如选择“I have no comment”），而 GPT-3 则容易自信地给出错误答案。\",\"InstructGPT 输出更少毒性内容，尤其在有“尊重”提示下\",\"使用 RealToxicityPrompts 数据集 + Perspective API 自动打分 + 人类评估。\",\"Figure 7 显示：\",\"有“请保持尊重”提示时，InstructGPT 显著比 GPT-3 更少生成有毒文本。\",\"无提示时，两者毒性差异减小。\",\"若刻意要求生成毒性内容，InstructGPT 反而更“有效”执行（更高毒性），说明其任务执行能力更强，但未具内置限制。\",\"在偏见测试中未表现出优势\",\"在 CrowS-Pairs 和 Winogender 数据集上，InstructGPT 和 GPT-3 偏见水平相当，有时更低 entropy 表示模型更“确信”其回答，但不一定更公正。\",\"使用 PPO-ptx 缓解了对齐损失（alignment tax）\",\"原始 PPO 模型在 SQuAD、DROP 等任务上表现退化。\",\"但通过在 RL 过程中混入预训练目标（PPO-ptx），可基本恢复甚至超越 GPT-3 性能（见附录图 29–34）。\",\"3. 定性分析与模型行为观察\",\"模型泛化能力强：能处理非训练分布指令\",\"InstructGPT 可：\",\"处理 非英语指令，如法语（尽管有时仍用英文回应）\",\"总结并解释 代码片段\",\"Figure 8 示例显示：\",\"GPT-3 未能回答“列表 C 的作用”问题，InstructGPT 给出较为合理的解释（虽然也不完全正确）\",\"模型仍存在简单错误与对“荒谬”指令的顺从\",\"InstructGPT 在面对带错误前提的指令时，可能不会质疑，而是“默认接受并执行”。\",\"它也倾向于过度规避风险，在回答简单问题时冗长解释或“过于中性”。\",\"Figure 9 展示：\",\"对“冥想后吃袜子有何用”这类指令，GPT-3 胡编乱造；InstructGPT 则写出听起来“认真合理”的答案，但仍在胡说。\",\"对“炮弹打南瓜”的问题，InstructGPT没能直接回答（如“炸碎”），而是列举可能性并犹豫。\",\"总结：InstructGPT 的结果证明了 RLHF 的有效性\",\"提升：输出更符合人类偏好，减少幻觉与毒性，对指令遵循度高。\",\"挑战：仍可生成有害内容，对荒谬命令未进行识别，任务复杂性上限未显现。\",\"泛化性：在代码、非英语指令等非监督数据上表现较好。\",\"控制手段：通过 PPO-ptx 控制 alignment tax，维持 NLP 性能。\"]},\"539\":{\"h\":\"讨论\",\"t\":[\"InstructGPT 是 OpenAI 迭代式对齐研究计划的一部分，目标是使现有模型更符合人类意图，同时构建适用于未来更强 AI 的通用方法。\",\"RLHF 是一种低成本高回报的对齐方法\",\"与预训练相比，使用 RLHF 对齐语言模型所需的计算成本极低：\",\"训练 GPT-3（175B）需约 3640 petaflop/s-days；\",\"而 InstructGPT 的 SFT 阶段只需 4.9 petaflop/s-days；\",\"PPO 微调也仅为 60 petaflop/s-days。\",\"与其训练更大的模型，不如在现有模型上投资对齐方法：例如，1.3B InstructGPT 的输出比 175B GPT-3 更受欢迎（见 Figure 1）。\",\"RLHF 能够泛化“指令跟随能力”\",\"模型在未明确训练的任务上也表现良好，如非英语任务、代码任务（见 Figure 8）。\",\"这意味着对齐方法不仅优化模型行为，还能提高其泛化能力，有助于构建更通用、适应性强的智能系统。\",\"可显著降低对齐带来的性能损失(alignment tax)\",\"原始 PPO 模型在一些公开 NLP 数据集上的性能下降（如 DROP、SQuAD）。\",\"但通过引入预训练梯度混合（PPO-ptx），可以在保持对齐的同时维持甚至提升性能（详见附录 Figure 29–34）。\",\"将抽象对齐技术成功应用于现实世界模型部署\",\"与以往在合成任务或小型模型上的研究不同，InstructGPT 将 RLHF 应用于真实的 API 模型中，验证了该技术在生产环境下的可行性和价值。\",\"我们到底在“对齐”谁？(Who Are We Aligning To ?)\",\"作者清晰指出当前模型对齐行为的“参考群体”是有局限的，实际对齐的是训练流程中的多重人为偏好叠加：\",\"标注者的偏好：训练数据和奖励信号均来自一组英语标注者（主要来自美国和东南亚），并非普遍“人类代表”。\",\"研究者的设计意图：OpenAI 研究团队定义了标注规则、标准与示例，标注者受其引导。\",\"API 用户行为：训练 prompt 来源于真实 API 用户提交，其任务形式和风格可能代表一类高频商业用途。\",\"用户 ≠ 社会：OpenAI API 用户为申请加入测试队列的群体，不代表所有潜在用户，更不代表所有受语言模型影响的人群。\",\"结论：当前对齐并非通用意义上的“人类价值对齐”，而是特定群体与目标下的实用性对齐。未来若需面向多元人群，可能需要模型具备多偏好条件控制能力。\",\"限制与盲点（Limitations）\",\"InstructGPT 在多个方面仍存在不足：\",\"模型行为问题：\",\"仍会生成有害、偏见或捏造内容。\",\"过度顺从错误指令：如“吃袜子”、“南瓜吸引炮弹”等（Figure 9）。\",\"复杂指令处理能力不足：多条件限制（如“用两句话总结 1930 年代法国电影”）仍表现不佳。\",\"数据收集问题：\",\"标注者人数有限（约40人），且偏好有偏，可能影响输出的一致性与代表性。\",\"多数比较数据仅有 1 位标注者进行判断，可能遗漏歧义与分歧点。\",\"语言多样性不足：训练数据主要为英文，非英语泛化能力未系统评估。\",\"作者建议未来采用更多元标注、歧义加权、以及特定群体优先原则（如针对少数群体敏感任务）。\",\"尚待探索的问题（Open Questions）\",\"作者列出多个值得进一步研究的问题：\",\"如何更有效缓解毒性与偏见？\",\"引入 adversarial 数据收集（如 Dinan et al., 2019b）；\",\"在预训练层面进行数据过滤（如 Ngo et al., 2021）；\",\"建立更强的拒绝机制以识别恶意请求。\",\"如何应对多价值体系的冲突？\",\"开发具备“偏好条件化能力”的模型（即对不同用户群体可调节输出风格/规范）；\",\"探索“社会契约式”对齐方法以处理价值多样性。\",\"如何建立更强的 reject 模型机制？\",\"当任务违反道德或逻辑前提时，模型应能自动识别并拒绝执行，而非“高质量完成”。\",\"社会影响与部署考量（Broader Impacts）\",\"正面影响：\",\"更符合用户指令、更具可控性、更少毒性，适合用于构建对话助手、总结系统、教育工具等。\",\"为“人类偏好引导型 AI”提供现实路径，降低部署风险。\",\"潜在风险：\",\"当前偏好群体有限，若未经适当调节可能导致某些群体观点被系统性排除；\",\"对齐本身可被滥用，尤其在军事、虚假宣传等敏感场景下；\",\"若拒绝机制不足，模型仍可能在对抗性攻击下暴露隐私、输出有害内容。\",\"作者强调，技术细节必须伴随规范治理与透明流程，否则对齐仅为形式上的“驯化”，而非本质的 AI 安全。\",\"总结:\",\"项目\",\"关键结论\",\"RLHF 价值\",\"成本低、泛化强、性能好，优于简单 scaling\",\"当前对齐对象\",\"并非“人类普遍价值”，而是 OpenAI 标注者 + 用户\",\"局限性\",\"模型顺从性过高、多样性不足、对抗性脆弱\",\"未来方向\",\"多群体条件对齐、拒绝模型、反毒性 adversarial 训练\",\"部署建议\",\"建议伴随伦理审查、偏好反馈机制、开放接口控制\"]},\"540\":{\"h\":\"KV-Cache 详解\",\"t\":[\"大模型加速技术之KV Cache详解\"]},\"541\":{\"h\":\"Why we need KV Cache ？\",\"t\":[\"生成式generative模型的推理过程很有特点，我们给一个输入文本，模型会输出一个回答（长度为N），其实该过程中执行了N次推理过程。即GPT类模型一次推理只输出一个token，输出token会与输入tokens 拼接在一起，然后作为下一次推理的输入，这样不断反复直到遇到终止符。\",\"如上描述是我们通常认知的GPT推理过程。代码描述如下：\",\"import torch from transformers import GPT2LMHeadModel, GPT2Tokenizer def main(): # 加载模型和 tokenizer model = GPT2LMHeadModel.from_pretrained(\\\"gpt2\\\").eval() tokenizer = GPT2Tokenizer.from_pretrained(\\\"gpt2\\\") # 初始输入 in_text = \\\"Open AI is a\\\" in_tokens = torch.tensor(tokenizer.encode(in_text)).unsqueeze(0) # [1, seq_len] token_eos = torch.tensor([198]) # line break symbol out_token = None i = 0 with torch.no_grad(): while out_token != token_eos: outputs = model(in_tokens) logits = outputs.logits out_token = torch.argmax(logits[0, -1, :], dim=-1, keepdim=True).unsqueeze(0) # [1, 1] in_tokens = torch.cat((in_tokens, out_token), dim=1) text = tokenizer.decode(in_tokens[0]) print(f'step {i} input: {text}', flush=True) i += 1 out_text = tokenizer.decode(in_tokens[0]) print(f'\\\\nInput: {in_text}') print(f'Output: {out_text}') if __name__ == \\\"__main__\\\": main()\",\"输出:\",\"step 0 input: Open AI is a new step 1 input: Open AI is a new way step 2 input: Open AI is a new way to step 3 input: Open AI is a new way to build step 4 input: Open AI is a new way to build AI step 5 input: Open AI is a new way to build AI that step 6 input: Open AI is a new way to build AI that is step 7 input: Open AI is a new way to build AI that is more step 8 input: Open AI is a new way to build AI that is more efficient step 9 input: Open AI is a new way to build AI that is more efficient and step 10 input: Open AI is a new way to build AI that is more efficient and more step 11 input: Open AI is a new way to build AI that is more efficient and more efficient step 12 input: Open AI is a new way to build AI that is more efficient and more efficient than step 13 input: Open AI is a new way to build AI that is more efficient and more efficient than traditional step 14 input: Open AI is a new way to build AI that is more efficient and more efficient than traditional AI step 15 input: Open AI is a new way to build AI that is more efficient and more efficient than traditional AI. step 16 input: Open AI is a new way to build AI that is more efficient and more efficient than traditional AI. Input: Open AI is a Output: Open AI is a new way to build AI that is more efficient and more efficient than traditional AI.\",\"在上面的推理过程中，每 step 内，输入一个 token序列，经过Embedding层将输入token序列变为一个三维张量 [b, s, h]，经过一通计算，最后经 logits 层将计算结果映射至词表空间，输出张量维度为 [b, s, vocab_size]。\",\"当前轮输出token与输入tokens拼接，并作为下一轮的输入tokens，反复多次。可以看出第 i+1 轮输入数据只比第 i 轮输入数据新增了一个 token，其他全部相同！\",\"因此第 i+1 轮推理时必然包含了第 i 轮的部分计算。KV Cache 的出发点就在这里，缓存当前轮可重复利用的计算结果，下一轮计算时直接读取缓存结果。\",\"上面所举例子并没有使用KV Cache进行推理,请注意。\"]},\"542\":{\"h\":\"Self-Attention Without Cache\",\"t\":[\"下图给出了无 Cache 情况下，类GPT式生成式模型进行推理的过程:\",\"这种方式的问题是: 每生成一个 token，就要重新计算所有之前 token 的 Q/K/V + Attention + FFN 。\"]},\"543\":{\"h\":\"Self-Attention With Cache\",\"t\":[\"下图给出了有 Cache 情况下，类GPT式生成式模型进行推理的过程:\"]},\"544\":{\"h\":\"Huggingface 官方代码实现\",\"t\":[\"本节将根据 Huggingface 官方代码实现进行 KV Cache 实现讲解 (只展示核心代码，移除了大量与本文无关的逻辑)。\",\"官方代码链接: https://github.com/huggingface/transformers/blob/main/src/transformers/models/gpt2/modeling_gpt2.py\",\"下面将给出使用了 KV Cache 进行推理的代码:\",\"import torch from transformers import GPT2Tokenizer, GPT2Config from modeling_gpt2 import GPT2LMHeadModel # copy from huggingface , 删除了大量无关代码 def generate_text(model, tokenizer, prompt, max_new_tokens=50, eos_token_id=198): model.eval() input_ids = tokenizer.encode(prompt, return_tensors=\\\"pt\\\") past_key_values = None output_ids = input_ids.clone() with torch.no_grad(): for step in range(max_new_tokens): outputs = model( input_ids=input_ids, past_key_values=past_key_values, use_cache=True ) logits = outputs.logits past_key_values = outputs.past_key_values next_token_logits = logits[:, -1, :] next_token = torch.argmax(next_token_logits, dim=-1, keepdim=True) output_ids = torch.cat([output_ids, next_token], dim=-1) if next_token.item() == eos_token_id: break input_ids = next_token # 采用KV Cache后，推理过程修改的关键: 下一步只送入新 token print(f\\\"step {step}: {tokenizer.decode(output_ids[0])}\\\", flush=True) return tokenizer.decode(output_ids[0]) def main(): config = GPT2Config() tokenizer = GPT2Tokenizer.from_pretrained(\\\"gpt2\\\") model = GPT2LMHeadModel(config) prompt = \\\"Once upon a time\\\" output = generate_text(model, tokenizer, prompt) print(\\\"\\\\nFinal output:\\\") print(output) if __name__ == \\\"__main__\\\": main()\",\"KV Cache 的引入是为了加速自回归模型的推理速度，具体体现在:\",\"每轮推理时，只需要计算当前轮新增 token 的 Q/K/V，而不需要重新计算所有之前 token 的 Q/K/V。\",\"缓存当前轮计算结果，下一轮推理时直接读取缓存结果。\",\"在首轮推理的过程中，我们传入的是 promt 提示词列表，并且 KV Cache 此时为空，还未进行初始化。因此首轮推理过程需要完成 promt 提示词列表的 keys 和 values 的缓存；由于 GPT2 由多层 GPT2Block 堆叠而成，而每一层 GPT2Block 都有一个 GPT2Attention 模块， 因此 KV Cache 需要准备好每一层 GPT2Attention 模块的 keys 和 values 缓存 (分层Cache - legacy_cache)。\",\"class GPT2Model(GPT2PreTrainedModel): def forward( self, input_ids=None, past_key_values=None, cache_position=None, attention_mask=None, position_ids=None, head_mask=None, use_cache=None, ): return_legacy_cache = False if use_cache: # 1. 首轮推理，先进行 Legacy Cache 初始化 if past_key_values is None: return_legacy_cache = True past_key_values = DynamicCache() # 2. 后续推理，将模型以元组形式返回的缓存重新封装为Legacy Cache形式 elif not isinstance(past_key_values, Cache): return_legacy_cache = True past_key_values = DynamicCache.from_legacy_cache(past_key_values) # 3. 词嵌入 inputs_embeds = self.wte(input_ids) # 4. 位置编码计算 if cache_position is None: # 4.1 已经缓存的词序列长度 past_seen_tokens = past_key_values.get_seq_length() if past_key_values is not None else 0 # 4.2 只为当前传入的词生成位置序列 cache_position = torch.arange( past_seen_tokens, past_seen_tokens + inputs_embeds.shape[1], device=inputs_embeds.device ) if position_ids is None: position_ids = cache_position.unsqueeze(0) # 添加batch维度 # 4.3 生成位置编码 position_embeds = self.wpe(position_ids) # 5. 词嵌入 + 位置编码 hidden_states = inputs_embeds + position_embeds.to(inputs_embeds.device) # 6. 进入堆叠GPT2Block模块前向传播流程 for i, block in enumerate(self.h): hidden_states = block( hidden_states, past_key_values if not (self.gradient_checkpointing and self.training) else None, # 训练时，不启用KV Cache cache_position, causal_mask, use_cache=use_cache, ) hidden_states = self.ln_f(hidden_states) hidden_states = hidden_states.view(output_shape) # 7. 将KV Cache用元组的形式进行返回 past_key_values = past_key_values if use_cache else None if return_legacy_cache: past_key_values = past_key_values.to_legacy_cache() return BaseModelOutputWithPastAndCrossAttentions( last_hidden_state=hidden_states, past_key_values=past_key_values, hidden_states=all_hidden_states, attentions=all_self_attentions, cross_attentions=all_cross_attentions, )\",\"下图展示的是步骤7中以元组形式返回的KV Cache结构:\",\"下面将展示GPT2Block模块的实现逻辑，由于不涉及KV Cache的实现细节，所以不过多展开:\",\"class GPT2Block(GradientCheckpointingLayer): def forward( self, hidden_states: Optional[tuple[torch.FloatTensor]], past_key_value: Optional[Cache] = None, cache_position: Optional[torch.LongTensor] = None, attention_mask: Optional[torch.FloatTensor] = None, use_cache: Optional[bool] = False, ) -> Union[tuple[torch.Tensor], Optional[tuple[torch.Tensor, tuple[torch.FloatTensor, ...]]]]: # 1. 归一化 residual = hidden_states hidden_states = self.ln_1(hidden_states) # 2. 自注意力运算 attn_output, self_attn_weights = self.attn( hidden_states, past_key_value=past_key_value, cache_position=cache_position, attention_mask=attention_mask, use_cache=use_cache, ) # 3. residual connection hidden_states = attn_output + residual # 4. 归一化 + MLP + residual connection residual = hidden_states hidden_states = self.ln_2(hidden_states) feed_forward_hidden_states = self.mlp(hidden_states) hidden_states = residual + feed_forward_hidden_states return hidden_states\",\"推理时的常规流程（无 KV Cache）， 每生成一个新 token，都要：\",\"重新输入全部历史 token\",\"对所有历史 token 重新计算 key 和 value\",\"这意味着重复计算，效率低，计算开销线性增长\",\"有了 KV Cache 后的改进：\",\"第一次输入完整句子，计算并缓存其 key/value；\",\"后续每次生成新 token 时：\",\"只计算新 token 的 query、key、value；\",\"把新 token 的 key/value 插入缓存中（代码中用 past_key_value.update(...) 完成）；\",\"attention 直接使用「历史缓存 key/value + 当前新 token 的 key/value」来完成；\",\"整个注意力的 query 只有一个（当前 token），key/value 是历史缓存 + 当前 token。\",\"class GPT2Attention(nn.Module): def __init__(self, config, is_cross_attention=False, layer_idx=None): self.c_attn = Conv1D(3 * self.embed_dim, self.embed_dim) # 输入维度: (batch,seq_len,embed_dim) , 变换后的输出维度: (batch,seq_len,3*embed_dim) self.c_proj = Conv1D(self.embed_dim, self.embed_dim) def forward( self, hidden_states: Optional[tuple[torch.FloatTensor]], past_key_value: Optional[Cache] = None, cache_position: Optional[torch.LongTensor] = None, attention_mask: Optional[torch.FloatTensor] = None, ) -> tuple[Union[torch.Tensor, tuple[torch.Tensor]], ...]: # 1. 一维卷积进行线性变换和升维，然后切分成query，key，value query_states, key_states, value_states = self.c_attn(hidden_states).split(self.split_size, dim=2) # 2. (batch,seq_len,-1,head_dim) , head_dim 是多头自注意力中每个头切分到的维度 shape_q = (*query_states.shape[:-1], -1, self.head_dim) shape_kv = (*key_states.shape[:-1], -1, self.head_dim) # 3. 维度统一: (batch,heads,seq_len,head_dim) query_states = query_states.view(shape_q).transpose(1, 2) key_states = key_states.view(shape_kv).transpose(1, 2) value_states = value_states.view(shape_kv).transpose(1, 2) # 4. KV Cache 不为空 if past_key_value is not None: # 4.1 cache_position 记录当前词对应输入词序列中的索引 cache_kwargs = {\\\"cache_position\\\": cache_position} # 4.2 将当前词的key和val进行缓存，根据所在GPTBlock层级(layer_idx说明)，和位于词序列的索引(cache_kwargs说明),插入对应层的list缓存中去，同时返回对应的key和val list key_states, value_states = past_key_value.update( key_states, value_states, self.layer_idx, cache_kwargs=cache_kwargs ) # 5. 进行经典的多头自注意力运算(不展开细聊) attn_output, attn_weights = attention_interface( self, query_states, # 当前输入词的query key_states, # cache key list + 输入词的key value_states, # cache val list + 输入词的val attention_mask, # padding mask dropout=self.attn_dropout.p if self.training else 0.0, ) attn_output = attn_output.reshape(*attn_output.shape[:-2], -1).contiguous() attn_output = self.c_proj(attn_output) attn_output = self.resid_dropout(attn_output) return attn_output, attn_weights\"]},\"545\":{\"h\":\"LLaMA-1论文\",\"t\":[\"LLaMA-1 论文\",\"论文链接: LLaMA: Open and Efficient Foundation Language Models\"]},\"546\":{\"h\":\"摘要\",\"t\":[\"LLaMA是一系列高效的基础语言模型，参数规模从7B到65B不等，其特点在于仅使用公开可用的数据集进行训练，而无需依赖专有数据。实验结果表明，LLaMA-13B在多数基准测试中优于GPT-3（175B），而LLaMA-65B则与Chinchilla-70B和PaLM-540B等顶尖模型表现相当。这些模型的发布旨在促进研究社区的开放访问和研究，部分模型甚至可以在单个GPU上运行。\"]},\"547\":{\"h\":\"简介\",\"t\":[\"模型规模与性能的重新思考\",\"论文指出传统观点认为模型参数越多性能越优（如GPT-3的175B参数），但Hoffmann等人（2022）的研究表明，在固定计算预算下，小模型+更多数据训练可能更优。例如，LLaMA-7B在1T tokens训练后性能持续提升（见图1训练损失曲线），而Hoffmann推荐的10B模型仅训练200B tokens即停止。这一发现挑战了单纯追求参数规模的范式。\",\"推理效率的核心目标\",\"LLaMA强调推理成本优化而非单纯训练速度。论文指出，虽然大模型训练更快达到目标性能，但小模型在长期训练后推理效率更高（如13B模型比GPT-3小10倍却性能更优）。这一设计理念直接反映在模型架构选择上（见表2的参数字段与学习率配置）。\",\"数据策略与开源兼容性\",\"与Chinchilla、PaLM等依赖未公开数据（如\\\"Books-2TB\\\"）不同，LLaMA仅使用公开数据（CommonCrawl 67%、C4 15%、GitHub 4.5%等，详见表1），使其完全可开源。这一策略虽限制数据量（总计1.4T tokens），但通过高效训练仍实现SOTA。\",\"性能验证与社会责任\",\"65B模型在常识推理（表3）、闭卷问答（表4-5）等任务上超越Chinchilla-70B\",\"代码生成（表8）和数学推理（表7）的竞争力\",\"同时分析模型偏见（表12-13）与毒性（表11），呼应AI伦理需求\"]},\"548\":{\"h\":\"方法\",\"t\":[\"1. 预训练数据与处理\",\"LLaMA采用纯公开数据混合，总规模1.4T tokens，主要来源包括：\",\"CommonCrawl（67%）：经CCNet流水线去重、语言识别（保留英文）和质量过滤（基于Wikipedia引用分类）。\",\"C4（15%）：补充多样性，启发式过滤低质量网页（如标点缺失）。\",\"代码与学术数据：GitHub（4.5%，MIT/Apache许可项目）、ArXiv（2.5%，移除宏定义和参考文献）、Stack Exchange（2%，按评分排序答案）。\",\"其他数据如Wikipedia（4.5%）和书籍（Gutenberg/Books3，4.5%）均经过严格去重（见表1的采样比例与磁盘大小）。\",\"Tokenizer：使用SentencePiece的BPE算法，数字拆分为独立字符，UTF-8回退到字节级处理。\",\"2. 模型架构改进\",\"基于Transformer的优化设计（对比原始架构）：\",\"预归一化（Pre-normalization）：采用RMSNorm对子层输入归一化（灵感来自GPT-3），提升训练稳定性。\",\"激活函数：替换ReLU为SwiGLU（PaLM方案），隐藏层维度设为 以平衡计算效率。\",\"位置编码：使用旋转位置嵌入（RoPE）（GPT-NeoX方案），替代绝对位置编码。\",\"详细参数配置见表2，例如65B模型维度为8192、64头注意力、80层。\",\"3. 训练优化策略\",\"优化器：AdamW（），余弦学习率调度（最终学习率为峰值10%），权重衰减0.1，梯度裁剪1.0。\",\"效率优化：\",\"内存管理：通过xformers库实现因果多头注意力的高效计算，避免存储注意力权重（参考Rabe & Staats 2021）。\",\"激活检查点（Checkpointing）：手动实现线性层反向传播，减少重计算（节省GPU内存）。\",\"并行策略：模型与序列并行（Korthikanti et al. 2022），重叠计算与GPU通信。\",\"如图1所示，65B模型在2048块A100（80GB）上训练速度达380 tokens/sec/GPU，1.4T tokens训练耗时约21天。\",\"总结\",\"LLaMA的方法论核心是通过数据质量优化（公开数据+严格过滤）、架构微调（SwiGLU/RoPE）和工程创新（内存/并行优化）实现高效训练。其设计始终围绕推理效率目标（如小模型长期训练），最终在多个基准测试中超越更大规模的闭源模型。\"]},\"549\":{\"h\":\"结果\",\"t\":[\"1. 常识推理（Common Sense Reasoning）\",\"零样本性能（表3）： LLaMA-65B在8个常识推理基准（如BoolQ、PIQA、ARC等）中全面超越Chinchilla-70B，并在多数任务上击败PaLM-540B（除BoolQ和WinoGrande）。例如：\",\"ARC挑战集：LLaMA-65B得分57.8，显著高于PaLM-540B的53.0。\",\"OpenBookQA：65B模型以60.2%准确率刷新SOTA。\",\"关键发现：LLaMA-13B性能优于GPT-3（175B），验证小模型+长训练的有效性。\",\"2. 闭卷问答（Closed-Book QA）\",\"NaturalQuestions（表4）与TriviaQA（表5）：\",\"65B模型在零样本和少样本（64-shot）设置下均达到SOTA（TriviaQA零样本68.2%，超越Chinchilla-70B的55.4%）。\",\"13B模型在单V100 GPU上推理时，性能仍优于GPT-3（如TriviaQA 64-shot 64.0% vs. GPT-3 57.2%）。\",\"训练动态：图2显示模型性能与训练token量强相关（如33B模型在1.4T tokens后HellaSwag分数提升至82.8）。\",\"3. 代码生成与数学推理\",\"代码生成（表8）: LLaMA-65B在HumanEval（pass@1 23.7%）和MBPP（37.7%）上超越未微调的PaLM-62B（15.9%/21.4%），接近PaLM-540B（26.2%/36.8%）。\",\"数学能力（表7）：\",\"GSM8k：65B模型未经数学微调即达50.9%（多数投票69.7%），优于Minerva-62B（52.4%）。\",\"MATH：65B模型（10.6%）表现接近PaLM-62B（8.8%），但远低于Minerva-540B（33.6%），凸显领域微调的重要性。\",\"4. 多任务理解（MMLU）与指令微调\",\"MMLU 5-shot（表9/16）: LLaMA-65B平均得分63.4%，落后于Chinchilla-70B（67.5%）和PaLM-540B（69.3%），主因是书籍数据量不足（仅177GB vs. 其他模型2TB）。\",\"指令微调（LLaMA-I）（表10）: 简单微调后，65B模型在MMLU上提升至68.9%，超越Flan-PaLM-62B（66.1%），证明指令适应的高效性。\",\"5. 偏见与毒性分析\",\"RealToxicityPrompts（表11）: 模型越大毒性倾向越高（65B Respectful类毒性分0.141 vs. 7B的0.081），与OPT等模型趋势一致。\",\"CrowS-Pairs（表12）: LLaMA-65B平均偏见得分66.6，优于OPT-175B（69.5），但宗教类别偏差显著（79.0）。\",\"WinoGender（表13）: 模型对非二元代词（their/them）的指代准确率（81.7%）高于性别化代词（his/him 72.1%），反映社会偏见。\",\"LLaMA的核心成果：\",\"效率突破：小模型（如13B）通过数据与训练优化达到大模型（GPT-3/Chinchilla）性能。\",\"多领域竞争力：在代码、数学等专业任务中，未微调模型即接近SOTA。\",\"可复现性：纯公开数据训练结果挑战了专有数据的必要性，但书籍/学术数据不足限制MMLU表现。\",\"责任缺陷：模型规模与毒性/偏见正相关，需后续治理（论文第5章重点讨论）。\"]},\"550\":{\"h\":\"指令微调\",\"t\":[\"方法与目标: LLaMA通过轻量级指令微调（遵循Chung et al., 2022的协议）优化LLaMA-65B，得到LLaMA-I，旨在提升任务泛化能力，无需复杂架构调整。\",\"关键性能提升（表10）\",\"MMLU 5-shot：微调后准确率从63.4%→68.9%，超越Flan-PaLM-62B（66.1%），但低于GPT-3.5（77.4%）。\",\"领域差异（表16 - 参考上文）：STEM（如Astronomy +9.2%）和人文任务（Philosophy +5.1%）提升显著。\",\"生成能力（附录D）\",\"代码生成：可输出规范代码（如HTML标签清理的正则表达式）。\",\"多轮交互：支持复杂对话（如象棋开局策略分析）。\",\"伦理响应：自动生成AI使用指南，强调责任约束。\",\"局限性与挑战\",\"数据不透明：微调数据规模/多样性未公开，可能限制泛化。\",\"逻辑缺陷：数学/推理任务仍存在幻觉（需后处理）。\",\"总结\",\"LLaMA-I证明小规模微调即可显著提升任务适应性，但透明性与可靠性仍需优化，为开源社区提供了可复现的基线（如后续Alpaca/Vicuna工作）。\"]},\"551\":{\"h\":\"Bias, Toxicity and Misinformation\",\"t\":[\"毒性生成评估（RealToxicityPrompts）\",\"使用PerspectiveAPI对100k提示生成内容进行毒性评分（0-1分）\",\"关键发现（表11）：\",\"模型规模与毒性正相关（65B毒性分0.141 vs 7B的0.081）\",\"\\\"Respectful\\\"提示仍可能触发毒性响应\",\"与Chinchiila（0.087）等模型趋势一致\",\"社会偏见分析\",\"CrowS-Pairs（表12）：\",\"平均偏见得分66.6（优于OPT-175B的69.5）\",\"宗教类别偏见最显著（79.0分）\",\"WinoGender（表13）：\",\"对非二元代词（their/them）指代准确率81.7%\",\"性别化代词（his/him）准确率低至72.1%\",\"\\\"gotcha\\\"测试显示职业性别刻板印象明显\",\"真实性缺陷（TruthfulQA）\",\"65B模型真实答案率仅57%（表14）\",\"在对抗性问题上易产生幻觉\",\"表现优于GPT-3但可靠性仍不足\",\"关键问题\",\"数据根源：CommonCrawl等网络数据隐含的社会偏见难以完全过滤\",\"规模悖论：能力提升伴随风险增加（如65B毒性最高）\",\"总结\",\"LLaMA呈现出与同类模型相似的偏见/毒性模式，凸显公开数据训练的固有挑战。需结合：\",\"1）更严格的数据清洗（如Wikipedia引用过滤）\",\"2）后处理技术（如perspectiveAPI过滤）\",\"3）社区治理框架\"]},\"552\":{\"h\":\"相关工作\",\"t\":[\"语言模型发展脉络\",\"从统计语言模型（n-gram）到神经网络（RNN/LSTM），最终演进至Transformer架构（Vaswani et al., 2017）\",\"关键里程碑：\",\"GPT系列（Radford et al., 2018, 2019, 2020）确立自回归范式\",\"BERT（Devlin et al., 2018）推动双向预训练\",\"T5（Raffel et al., 2020）统一文本到文本框架\",\"规模化研究\",\"计算律发现（Kaplan et al., 2020）揭示模型性能与规模的关系\",\"Chinchilla（Hoffmann et al., 2022）提出数据-计算最优平衡理论\",\"涌现能力研究（Wei et al., 2022）分析规模带来的质变\",\"开源模型进展\",\"OPT（Zhang et al., 2022）和BLOOM（Scao et al., 2022）推动开源大模型发展\",\"GPT-NeoX（Black et al., 2022）提供20B参数开源基线\"]},\"553\":{\"h\":\"总结\",\"t\":[\"LLaMA系列模型通过高效架构设计和纯公开数据训练，在多个基准测试中达到与更大规模专有模型相当的性能，同时保持开源可复现性，为AI研究的民主化提供了重要范例。\"]},\"554\":{\"h\":\"LLaMA-2论文\",\"t\":[\"LLaMA-2 论文\",\"论文链接: Llama 2: Open Foundation and Fine-Tuned Chat Models\"]},\"555\":{\"h\":\"摘要\"},\"556\":{\"h\":\"模型层\"},\"557\":{\"h\":\"RoBERTa 论文\",\"t\":[\"RoBERTa 论文\",\"论文链接: RoBERTa: A Robustly Optimized BERT Pretraining Approach\"]},\"558\":{\"h\":\"摘要\",\"t\":[\"RoBERTa是一项针对BERT预训练方法的优化研究，通过系统性的实验发现BERT存在训练不足的问题，并提出了一系列改进措施。这些改进包括更长的训练时间、更大的批次规模、更多的数据、移除下一句预测（NSP）目标、使用更长的序列以及动态调整掩码模式。实验结果表明，优化后的RoBERTa在多个基准测试（如GLUE、RACE和SQuAD）上达到了最先进的性能，甚至超越了后续提出的模型。研究强调了预训练中设计选择和数据规模的重要性，同时表明BERT的掩码语言模型目标在优化后仍具有竞争力。相关模型和代码已公开供进一步研究。\"]},\"559\":{\"h\":\"引言\",\"t\":[\"RoBERTa 是一项针对 BERT 预训练方法的复制研究，旨在通过系统性的实验评估不同超参数和数据规模对模型性能的影响。研究发现，BERT 的训练存在显著不足，通过优化训练策略（如延长训练时间、增大批次规模、使用更多数据等），RoBERTa 能够匹配甚至超越后续提出的多种模型（如 XLNet）。\",\"论文的主要改进包括：\",\"动态掩码（Dynamic Masking）（对比静态掩码，如表 1 显示动态掩码在 SQuAD 2.0 和 SST-2 任务上表现更优）；\",\"移除下一句预测（NSP）目标（实验表明 NSP 对性能影响有限，甚至可能损害模型表现，如表 2 对比不同输入格式）；\",\"更大批次训练（表 3 显示增大批次规模可提升模型困惑度和下游任务准确率）；\",\"更高效的字节级 BPE 编码（减少未知词影响）。\",\"此外，RoBERTa 引入了新数据集 CC-News（76GB），并验证了数据规模对预训练的关键作用。最终，RoBERTa 在 GLUE、SQuAD 和 RACE 上取得 SOTA 结果（如表 4、5、6），证明 BERT 的掩码语言模型目标在优化后仍具竞争力。\"]},\"560\":{\"h\":\"背景\",\"t\":[\"RoBERTa 基于 BERT 的架构和训练方法，但通过优化关键设计选择提升性能。BERT 采用 Transformer 结构，输入由两个文本片段（Segment）组成，并添加特殊标记（如 [CLS]、[SEP]）。其预训练任务包括：\",\"掩码语言模型（MLM）：随机选择 15% 的输入 token，其中 80% 替换为 [MASK]，10% 保持不变，10% 替换为随机 token。原始 BERT 使用静态掩码（即预处理时固定掩码模式），而 RoBERTa 改用动态掩码（每次输入时重新生成掩码），实验证明动态掩码效果更优（如表 1）。\",\"下一句预测（NSP）：判断两个片段是否连续。尽管 BERT 认为 NSP 对下游任务（如自然语言推理）有帮助，但 RoBERTa 的实验表明移除 NSP 可能提升性能（如表 2 对比不同输入格式）。\",\"优化策略：\",\"使用 Adam 优化器（, , ）。\",\"学习率采用线性预热（10,000 步）和衰减策略。\",\"原始 BERT 训练 1M 步，批次大小 256，序列长度 512。\",\"数据：BERT 使用 BookCorpus 和 Wikipedia（共 16GB），而 RoBERTa 扩展至更大规模数据（如 CC-News、OpenWebText 等，总计 160GB）。\",\"RoBERTa 通过调整这些关键因素（如动态掩码、移除 NSP、增大批次和数据规模），显著提升了 BERT 的预训练效率和下游任务表现。\"]},\"561\":{\"h\":\"实验步骤\",\"t\":[\"1. 模型实现与优化\",\"RoBERTa 基于 fairseq 工具包重新实现了 BERT，并优化了训练细节：\",\"学习率调整：相比原始 BERT 的固定学习率（1e-4），RoBERTa 针对不同设置调整峰值学习率和预热步数。\",\"Adam 优化器改进：发现 Adam 的 项对训练稳定性影响较大，调整 以提升大批次训练的稳定性（参考 Section 3.1）。\",\"序列长度：始终使用完整长度序列（512 tokens），而原始 BERT 会在训练初期使用较短序列。\",\"2. 训练硬件与效率\",\"采用 混合精度训练（FP16），在配备 8×32GB NVIDIA V100 GPU 的 DGX-1 机器上进行分布式训练，利用 Infiniband 互联提升效率。\",\"3. 数据配置\",\"RoBERTa 使用了 5 个英语语料库，总计超过 160GB 文本，包括：\",\"BookCorpus + Wikipedia（16GB，原始 BERT 数据）\",\"CC-News（76GB，新闻数据）\",\"OpenWebText（38GB，Reddit 高赞网页内容）\",\"Stories（31GB，故事类文本）\",\"通过控制数据规模（如对比 16GB vs. 160GB），RoBERTa 验证了更多数据能显著提升模型性能（参考 Section 5 和 Table 4）。\",\"4. 评估基准\",\"实验在三大基准任务上进行：\",\"GLUE：涵盖 9 项自然语言理解任务（如 MNLI、SST-2 等），采用单任务微调（非多任务学习）。\",\"SQuAD：\",\"V1.1：答案必存在于上下文中。\",\"V2.0：支持无答案问题，RoBERTa 增加了二分类器判断可答性（参考 Section 3.3）。\",\"RACE：长文本阅读理解任务，需从 4 个选项中选择正确答案，测试模型的长距离依赖能力。\"]},\"562\":{\"h\":\"训练步骤分析\",\"t\":[\"静态与动态掩码（Static vs. Dynamic Masking）\",\"原始BERT使用静态掩码，即在数据预处理阶段生成掩码模式并固定，通过复制数据来增加多样性。\",\"RoBERTa改为动态掩码，每次输入序列时生成新的掩码模式。实验表明，动态掩码性能略优于静态掩码（如表1所示），且更高效。因此，后续实验均采用动态掩码。\",\"在BERT和RoBERTa的预训练中，掩码（Masking） 是 Masked Language Modeling (MLM) 任务的核心步骤，即随机遮盖输入文本的部分单词，并让模型预测这些被遮盖的单词。\",\"1. 静态掩码（Static Masking）\",\"原始BERT的做法：\",\"在数据预处理阶段，一次性 对每个句子随机选择15%的单词进行掩码（其中80%替换为 [MASK]，10%保持不变，10%替换为随机单词）。\",\"由于BERT训练时会多次遍历数据（如40个epoch），为了避免每次训练时看到相同的掩码模式，BERT采用 数据复制 的方法：\",\"将训练数据复制 10份，每份采用不同的随机掩码模式。\",\"这样，每个句子在训练过程中会被看到 4次（40 epochs / 10 copies = 4次），但每次掩码不同。\",\"问题：\",\"数据复制增加了存储和计算开销。\",\"由于掩码模式是固定的（尽管有10种变体），模型可能过拟合这些特定的掩码模式，影响泛化能力。\",\"2. 动态掩码（Dynamic Masking）\",\"RoBERTa的改进：\",\"不再预先固定掩码模式，而是在 每次输入模型时动态生成掩码。\",\"例如，同一个句子在训练的不同批次（batch）中，可能会被掩码不同的单词。\",\"优势：\",\"减少存储开销：无需复制数据，节省内存。\",\"增加多样性：模型在训练过程中看到更多的掩码变体，提升泛化能力。\",\"更适合长训练周期：当训练步数远超过BERT的1M步时（如RoBERTa训练500K步），动态掩码能持续提供新的掩码模式，避免过拟合。\",\"输入格式与下一句预测（NSP）\",\"原始BERT使用“Segment-pair+NSP”输入格式，包含两个文档片段和NSP损失。\",\"RoBERTa对比了多种输入格式（如表2所示）：\",\"Sentence-pair+NSP：使用单句对，性能下降，可能因无法学习长距离依赖。\",\"Full-sentences：连续句子打包，去除NSP损失，性能优于原始BERT。\",\"Doc-sentences：限制输入来自同一文档，性能略优于Full-sentences，但因批次大小可变，最终选择Full-sentences格式。\",\"实验表明，去除NSP损失不仅未降低性能，反而有所提升，这与原始BERT的结论相反。\",\"大批量训练（Large Batch Training）\",\"原始BERT使用256的批次大小训练1M步。RoBERTa尝试增大批次至2K和8K，并调整学习率（如表3所示）。\",\"结果显示，大批量训练（如8K）在保持相同计算成本下，能提升掩码语言模型的困惑度和下游任务性能。因此，RoBERTa采用8K批次进行训练。\",\"文本编码（Text Encoding）\",\"原始BERT使用30K的字符级BPE词汇表。\",\"RoBERTa改用基于字节的BPE（50K词汇表），无需额外预处理。虽然早期实验显示性能略有下降，但其通用性优势使其成为最终选择。\",\"这些改进共同构成了RoBERTa的核心优化策略，显著提升了模型性能（如表4所示）。实验结果表明，BERT原始设计存在优化空间，而RoBERTa通过系统性的调整，在GLUE、SQuAD和RACE等任务上达到了新的 state-of-the-art 水平。\"]},\"563\":{\"h\":\"RoBERTa核心改进总结\",\"t\":[\"RoBERTa（Robustly Optimized BERT Approach）是对BERT预训练过程的系统性优化，通过调整训练策略、数据规模和模型设置，显著提升了性能。其主要改进包括：\"]},\"564\":{\"h\":\"\",\"t\":[\"动态掩码（Dynamic Masking）：\",\"原始BERT使用静态掩码（预处理阶段固定掩码模式），而RoBERTa改为每次输入时动态生成掩码，减少存储开销并提升泛化能力（见表1）。\",\"结果：动态掩码在SQuAD 2.0和SST-2任务上表现略优（F1 78.7 vs. 78.3）。\",\"移除NSP任务（Next Sentence Prediction）：\",\"BERT使用NSP任务（判断两个句子是否连续），但实验表明去除NSP后性能反而提升（见表2）。\",\"RoBERTa改用Full-sentences（连续句子打包，不跨文档）或Doc-sentences（单文档内句子打包），后者效果略优但计算复杂，最终选择Full-sentences。\",\"大批量训练（Large Batch Training）：\",\"BERT使用256的批次大小，RoBERTa增大至8K，并调整学习率（如1e-3）。\",\"结果：大批量训练提升MLM困惑度（3.77 vs. 3.99）和下游任务准确率（MNLI-m 84.6 vs. 84.7）（见表3）。\",\"字节级BPE（Byte-level BPE）：\",\"改用50K词汇表的字节级BPE编码，减少未登录词（OOV）问题，虽对部分任务性能略有影响，但通用性更强。\"]},\"565\":{\"h\":\"\",\"t\":[\"更大规模数据：\",\"BERT训练数据：16GB（BookCorpus + Wikipedia）。\",\"RoBERTa新增CC-News、OpenWebText等，总数据量达160GB。\",\"结果：数据量增加后，SQuAD 2.0 F1从87.3提升至87.7（见表4）。\",\"更长训练步数：\",\"BERT训练1M步，RoBERTa延长至300K~500K步（计算成本相当，因批次更大）。\",\"结果：500K步时，SQuAD 2.0 F1达89.4，超越XLNet（88.8）（见表4）。\"]},\"566\":{\"h\":\"\",\"t\":[\"GLUE基准：\",\"单任务微调：RoBERTa在9项任务中全面超越BERT和XLNet（MNLI-m 90.2 vs. 89.8）（见表5）。\",\"排行榜提交：以88.5平均分刷新SOTA，其中4项任务（MNLI、QNLI、RTE、STS-B）领先（见表5）。\",\"SQuAD 2.0：\",\"仅用SQuAD数据（无外部数据），F1达89.8，超越XLNet（89.1）（见表6）。\",\"RACE阅读理解：\",\"准确率83.2%，显著高于BERT（72.0）和XLNet（81.7）（见表7）。\"]},\"567\":{\"h\":\"\",\"t\":[\"BERT原始设计未充分优化：RoBERTa证明更长训练、更大批次、更多数据是关键。\",\"NSP任务非必要：去除后性能反而提升，与BERT结论相反。\",\"动态掩码与大批量训练：提升效率的同时改善泛化能力。\",\"开源贡献：发布模型、代码及新数据集CC-News。\",\"RoBERTa的改进表明，BERT的MLM目标本身足够强大，只需优化训练策略即可达到SOTA，无需复杂结构调整。\"]},\"568\":{\"h\":\"相关工作\",\"t\":[\"早期方法如ELMo、GPT和BERT通过不同训练目标（如语言建模、机器翻译、掩码语言建模）取得了显著进展，而后续工作通过多任务微调、实体嵌入、跨度预测和自回归预训练（如XLNet）进一步提升了性能。作者强调，这些改进通常依赖于更大模型和更多数据（如XLNet使用10倍于BERT的数据），而RoBERTa的目标是通过系统性地复现、简化和优化BERT的训练过程，为这些方法提供一个更清晰的性能基准，从而帮助社区更好地理解不同改进的相对贡献。\"]},\"569\":{\"h\":\"总结\",\"t\":[\"通过系统优化BERT的预训练策略（包括动态掩码、移除NSP任务、增大批次和训练数据、延长训练时间），RoBERTa在GLUE、SQuAD和RACE任务上实现了SOTA性能，证明了BERT原始设计的潜力尚未被充分挖掘；\",\"同时，研究揭示了模型性能提升的关键因素并非复杂结构改动，而是训练策略和数据规模的优化，相关代码、模型和CC-News数据集已开源以促进后续研究。\"]},\"570\":{\"h\":\"从\\\"零\\\"实现 Bert\",\"t\":[\"利用Pytorch从\\\"零\\\"实现Bert\",\"TinyBert 源码链接: https://github.com/BinaryOracle/TinyBert\"]},\"571\":{\"h\":\"Bert 是什么 ？\",\"t\":[\"BERT 全称为 Bidirectional Encoder Representation from Transformer，是 Google 以无监督的方式利用大量无标注文本「炼成」的语言模型，其架构为 Transformer 中的 Encoder（BERT = Encoder of Transformer）。\",\"以往为了解决不同的 NLP 任务，我们会为该任务设计一个最合适的神经网络架构并做训练，不同的 NLP 任务通常需要不同的模型，而设计这些模型并测试其 performance 是非常耗成本的（人力，时间，计算资源）。如果有一个能直接处理各式 NLP 任务的通用架构该有多好？\",\"随着时代演进，不少人很自然地有了这样子的想法，而 BERT 就是其中一个将此概念付诸实践的例子，Google 在预训练 BERT 时让它同时进行两个任务：\",\"漏字填空，即完型填空 (Masked Language Model)\",\"判断第 2 个句子在原始本文中是否跟第 1 个句子相接（Next Sentence Prediction）\"]},\"572\":{\"h\":\"Masked Language Model\",\"t\":[\"在 BERT 中，Masked LM（Masked Language Model）构建了语言模型，简单来说，就是随机遮盖或替换一句话里面的任意字或词，然后让模型通过上下文预测那一个被遮盖或替换的部分，之后做 Loss 的时候也只计算被遮盖部分的 Loss，这其实是一个很容易理解的任务，实际操作如下：\",\"随机把一句话中 15% 的 token（字或词）替换成以下内容：\",\"这些 token 有 80% 的几率被替换成 [MASK]，例如 my dog is hairy→my dog is [MASK]\",\"有 10% 的几率被替换成任意一个其它的 token，例如 my dog is hairy→my dog is apple\",\"有 10% 的几率原封不动，例如 my dog is hairy→my dog is hairy\",\"之后让模型预测和还原被遮盖掉或替换掉的部分，计算损失的时候，只计算在第 1 步里被随机遮盖或替换的部分，其余部分不做损失，其余部分无论输出什么东西，都无所谓。\",\"这样做的好处是，BERT 并不知道 [MASK] 替换的是哪一个词，而且任何一个词都有可能是被替换掉的，比如它看到的 apple 可能是被替换的词。这样强迫模型在编码当前时刻词的时候不能太依赖当前的词，而要考虑它的上下文，甚至根据上下文进行 \\\"纠错\\\"。比如上面的例子中，模型在编码 apple 时，根据上下文 my dog is，应该把 apple 编码成 hairy 的语义而不是 apple 的语义。\"]},\"573\":{\"h\":\"Next Sentence Prediction\",\"t\":[\"我们首先拿到属于上下文的一对句子，也就是两个句子，之后我们要在这两个句子中加一些特殊的 token：[CLS]上一句话[SEP]下一句话[SEP]。也就是在句子开头加一个 [CLS]，在两句话之间和句末加 [SEP]，具体地如下图所示：\",\"可以看到，上图中的两句话明显是连续的。如果现在有这么一句话 [CLS]我的狗很可爱[SEP]企鹅不擅长飞行[SEP]，可见这两句话就不是连续的。\",\"Token Embedding 就是正常的词向量，即 PyTorch 中的 nn.Embedding()\",\"Segment Embedding 的作用是用 embedding 的信息让模型分开上下句，我们给上句的 token 全 0，下句的 token 全 1，让模型得以判断上下句的起止位置，例如:\",\"[CLS]我的狗很可爱[SEP]企鹅不擅长飞行[SEP] 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1\",\"Position Embedding 和 Transformer 中的不一样，不是三角函数，而是学习出来的。\"]},\"574\":{\"h\":\"Multi-Task Learning\",\"t\":[\"BERT 预训练阶段实际上是将上述两个任务结合起来，同时进行，然后将所有的 Loss 相加。\"]},\"575\":{\"h\":\"Fine-Tuning\",\"t\":[\"BERT 的 Fine-Tuning 共分为 4 中类型: 文本分类，Token分类，推理任务，问答任务。\",\"如果现在的任务是 文本分类，首先在输入句子的开头加一个代表分类的符号 [CLS]，然后将该位置的 output，丢给 Linear Classifier，让其 predict 一个 class 即可。整个过程中 Linear Classifier 的参数是需要从头开始学习的，而 BERT 中的参数微调就可以了\",\"为什么要用第一个位置，即 [CLS] 位置的 output，个人理解是因为 BERT 内部是 Transformer，而 Transformer 内部又是 Self-Attention，所以 [CLS] 的 output 里面肯定含有整句话的完整信息，这是毋庸置疑的。但是 Self-Attention 向量中，自己和自己的值其实是占大头的，现在假设使用 的 output 做分类，那么这个 output 中实际上会更加看重 ，而 又是一个有实际意义的字或词，这样难免会影响到最终的结果。但是 [CLS] 是没有任何实际意义的，只是一个占位符而已，所以就算 [CLS] 的 output 中自己的值占大头也无所谓。当然你也可以将所有词的 output 进行 concat，作为最终的 output。\",\"如果现在的任务是 Token分类，将句子中各个字对应位置的 output 分别送入不同的 Linear，预测出该字的标签。其实这本质上还是个分类问题，只不过是对每个字都要预测一个类别。\",\"如果现在的任务是 NLI（自然语言推理）。即给定一个前提，然后给出一个假设，模型要判断出这个假设是 正确、错误还是不知道。这本质上是一个三分类的问题，和 Case 1 差不多，对 [CLS] 的 output 进行预测即可\",\"如果现在的任务是 问答任务，举例来说，如上图，将一篇文章，和一个问题（这里的例子比较简单，答案一定会出现在文章中）送入模型中，模型会输出两个数 s,e，这两个数表示，这个问题的答案，落在文章的第 s 个词到第 e 个词。具体流程我们可以看下面这幅图:\",\"首先将问题和文章通过 [SEP] 分隔，送入 BERT 之后，得到上图中黄色的输出。此时我们还要训练两个 vector，即上图中橙色和黄色的向量。首先将橙色和所有的黄色向量进行 dot product，然后通过 softmax，看哪一个输出的值最大，例如上图中 对应的输出概率最大，那我们就认为 s=2。\",\"同样地，我们用蓝色的向量和所有黄色向量进行 dot product，最终预测得 的概率最大，因此 e=3。最终，答案就是 s=2,e=3。\",\"你可能会觉得这里面有个问题，假设最终的输出 s>e 怎么办，那不就矛盾了吗？其实在某些训练集里，有的问题就是没有答案的，因此此时的预测搞不好是对的，就是没有答案。\"]},\"576\":{\"h\":\"从 “零” 开始的预训练\",\"t\":[\"从本节开始，我们将从\\\"零\\\"开始，体验Bert的预训练过程是如何实现的；\"]},\"577\":{\"h\":\"数据清洗\",\"t\":[\"首先我们需要准备一个小型语料库，确保在单台机器上，仅使用CPU就能完成整个训练过程，这里采用的是 wikitext-2 和 wikitext-103 两个开源数据集:\",\"WikiText 英语词库数据（The WikiText Long Term Dependency Language Modeling Dataset）是一个包含1亿个词汇的英文词库数据，这些词汇是从Wikipedia的优质文章和标杆文章中提取得到，包括WikiText-2和WikiText-103两个版本，相比于著名的 Penn Treebank (PTB) 词库中的词汇数量，前者是其2倍，后者是其110倍。每个词汇还同时保留产生该词汇的原始文章，这尤其适合当需要长时依赖(longterm dependency)自然语言建模的场景。\",\"Wikitext-103是超过 1 亿个语句的数据合集，全部从维基百科的 Good 与 Featured 文章中提炼出来。广泛用于语言建模，当中包括 fastai 库和 ULMFiT 算法中经常用到的预训练模型。\",\"WikiText2是Wikitext-103 的子集，主要用于测试小型数据集的语言模型训练效果。\",\"WIKITEXT-2\",\"WIKITEXT-103\",\"下载地址\",\"https://s3.amazonaws.com/fast-ai-nlp/wikitext-103.tgz\",\"https://s3.amazonaws.com/fast-ai-nlp/wikitext-2.tgz\",\"WikiText-2 和 WikiText-103 是两个广泛用于语言模型训练和评估的英文维基百科语料数据集 ，由 Salesforce 提出并开源。它们在 NLP 领域（特别是语言建模、预训练任务）中非常经典。\",\"将数据集压缩包下载到dataset目录下，并解压到当前目录下，然后使用prepare_data文件所提供代码对原始数据格式进行解析，得到对应的JSON格式文件:\",\"相关核心代码实现如下:\",\"def process_csv(file_path): \\\"\\\"\\\"处理CSV文件,返回处理后的句子列表\\\"\\\"\\\" all_sentences = [] with open(file_path, 'r', encoding='utf-8') as f: reader = csv.reader(f) for row in reader: # 使用NLTK库，将一整段文本按“句子”切分成一个句子列表。 # 处理每行文本：去除前后空格，过滤无效行 paragraph = [line.strip() for line in sent_tokenize(row[0]) if line.strip() and not line.strip().startswith('=') and not all(c in string.punctuation for c in line.strip())] # 过滤掉句子数少于2的行 paragraph = [line for line in paragraph if len(line.split('. ')) >= 2] # 确保句子数为偶数 if len(paragraph) % 2 != 0: paragraph = paragraph[:-1] all_sentences.extend(paragraph) return all_sentences def main(): # 处理两个CSV文件 test_sentences = process_csv('wikitext-2/test.csv') train_sentences = process_csv('wikitext-2/train.csv') # 写入JSON文件 train_output_path = 'wikitext-2/train.json' os.makedirs(os.path.dirname(train_output_path), exist_ok=True) with open(train_output_path, 'w', encoding='utf-8') as f: json.dump(train_sentences, f, indent=4, ensure_ascii=False) print(f\\\"成功生成JSON文件: {train_output_path}\\\") test_output_path = 'wikitext-2/test.json' os.makedirs(os.path.dirname(test_output_path), exist_ok=True) with open(test_output_path, 'w', encoding='utf-8') as f: json.dump(test_sentences, f, indent=4, ensure_ascii=False) print(f\\\"成功生成JSON文件: {test_output_path}\\\") if __name__ == \\\"__main__\\\": main()\"]},\"578\":{\"h\":\"分词器实现\",\"t\":[\"分词器的实现较为简单，首先是其初始化方法中需要完成：字典初始化，数据预加载(可挪到其他地方实现)。\",\"class Tokenizer: def __init__(self, vocab_file = None): vocab_data = None if vocab_file is not None: with open(vocab_file, 'r') as f: vocab_data = json.load(f) # 定义字典保存路径 dict_path = 'dataset/vocab_dict.json' # 尝试加载已保存的字典 if os.path.exists(dict_path): with open(dict_path, 'r', encoding='utf-8') as f: saved_dict = json.load(f) self.word2idx = saved_dict['word2idx'] self.idx2word = {int(k): v for k, v in saved_dict['idx2word'].items()} self.vocab_size = len(self.word2idx) else: # 首先加入特殊标记：PAD, CLS, SEP, MASK , UNK , 这些是 BERT 模型中常用的特殊 token self.word2idx = {f'{name}': idx for idx, name in enumerate(['PAD', 'CLS', 'SEP', 'MASK' , 'UNK'])} # 处理vocab_data为列表形式的情况 if isinstance(vocab_data, list): # 将所有文本合并成一个字符串 all_text = ' '.join(vocab_data) # 临时替换特殊标记 ，然后对句子进行分词 temp_text = all_text.replace('<unk>', 'UNK') sentences = word_tokenize(temp_text) # 获取所有单词并去重 word_list = list(set(sentences)) # 给每个普通词分配索引，从4开始（前面是特殊token）, 当前已经有的词数（4个特殊词） hold_place = len(self.word2idx) for idx, word in enumerate(word_list): if word == 'UNK': continue self.word2idx[word] = idx + hold_place else: raise ValueError(\\\"vocab_data must be a list\\\") # 创建反向映射：索引 → 单词 self.idx2word = {idx: word for word, idx in self.word2idx.items()} # 总词汇量 self.vocab_size = len(self.word2idx) # 确保映射是一一对应的 assert len(self.word2idx) == len(self.idx2word) # 保存字典到文件 with open(dict_path, 'w') as f: json.dump({ 'word2idx': self.word2idx, 'idx2word': self.idx2word }, f, indent=4) # 对列表数据进行解析 self.max_len = 103 if isinstance(vocab_data, list): self.word_ids = [] # 两两配对遍历 for i in range(0, len(vocab_data), 2): sent_a = vocab_data[i] sent_b = vocab_data[i+1] tokens_a = self.encode(sent_a) tokens_b = self.encode(sent_b) # 如果任一句子长度超过50，跳过这对 if len(tokens_a) > 50 or len(tokens_b) > 50: continue # 否则保存这两个句子的 token ID 列表 self.word_ids.append(tokens_a) self.word_ids.append(tokens_b)\",\"字典的构建过程太过粗糙，导致最终构建得到的字典过大并且还有很多噪声，从而模型训练学习到每个词的含义需要更大量的数据集且最终效果也不会很好，可考虑换成 HuggingFace 的 BertTokenizer / WordPieceTokenizer 实现。\",\"上面优化方向很多，比如: 去除含有低频词的句对，因为低频词出现次数极少，模型很难学到它们的语义表示。\",\"对外提供的编码和解码两个方法实现如下:\",\" def encode(self, text): return self.tokenize(text) def decode(self, tokens): return self.detokenize(tokens) def tokenize(self, text): sentences = word_tokenize(text) tokens = [] for word in sentences: if word in self.word2idx: tokens.append(self.word2idx[word]) else: # 如果遇到不存在于字典中的word，则使用UNK替换 tokens.append(self.word2idx['UNK']) return tokens def detokenize(self, tokens): return ' '.join([self.idx2word[token] for token in tokens])\",\"实际实现过程中，出于方便，还将一个工具方法整合到了分词器的实现之中，它是用于执行Bert MLM任务掩码策略的方法:\",\" # 执行Bert的掩码策略: 掩码候选位置，输入序列，掩码符号 def masking_procedure(self,cand_pos, input_ids, masked_symb): masked_pos = [] masked_tokens = [] # 对于所有掩码候选位置执行掩码策略： 80% 概率替换为[MASK]，10% 概率替换为随机词，10% 概率保持不变 for pos in cand_pos: masked_pos.append(pos) # 记录被掩码的位置 masked_tokens.append(input_ids[pos]) # 记录被掩码的原token if random.random() < p_mask: # 80% 概率替换为[MASK] input_ids[pos] = masked_symb elif random.random() > (p_mask + p_replace): # 10% 概率替换为随机词 rand_word_idx = random.randint(4, self.vocab_size - 1) input_ids[pos] = rand_word_idx else: # 10% 概率保持不变 pass return masked_pos, masked_tokens\"]},\"579\":{\"h\":\"Batch数据准备\",\"t\":[\"有了分词器后，我们需要读取并构建Batch数据，用于我们的预训练任务，该过程由make_data方法实现，具体步骤为:\",\"收集相同数量的相邻句对和非相邻句对。\",\"对每个句对构建用于NSP任务的样本，形式为: [CLS] + A + [SEP] + B + [SEP]。\",\"对每个句对构建用于MLM任务的样本，首先将[CLS] + A + [SEP] + B + [SEP]句子中20%的词执行掩码策略，而针对这20%需要被掩码的词之上，再按照80%用MASK掩码替换，10%用随机词替换，10%保持原样不动的形式进行处理；最后返回两个列表: 20%执行掩码的词的位置列表，20%执行掩码的词的原Token列表。\",\"将所有输入序列填充到等长max_len。\",\"返回构建得到的单个样本列表: [被掩码后的输入序列, 句子分隔列表 , 20%执行掩码的词的位置列表, 20%执行掩码的词的原Token列表, 是否为连贯的上下句]。\",\"所有样本列表构成Batch数据返回。\",\"def make_data(tokenizer): sentences = tokenizer.word_ids batch_data = [] len_sentences = len(sentences) # Step 1: 收集相邻句对 adjacent_pairs = [] for i in range(len_sentences - 1): a, b = i, i + 1 if len(sentences[a]) <= 50 and len(sentences[b]) <= 50: adjacent_pairs.append((a, b)) # Step 2: 随机生成等量的非相邻句对 non_adjacent_pairs = [] valid_indices = [i for i in range(len_sentences) if len(sentences[i]) <= 50] for a in valid_indices: candidates = [b for b in valid_indices if abs(a - b) > 1] if candidates: b = random.choice(candidates) non_adjacent_pairs.append((a, b)) # 打乱顺序 random.shuffle(adjacent_pairs) random.shuffle(non_adjacent_pairs) # 保证数量一致 min_count = min(len(adjacent_pairs), len(non_adjacent_pairs)) adjacent_pairs = adjacent_pairs[:min_count] non_adjacent_pairs = non_adjacent_pairs[:min_count] # 构建样本 for a, b in adjacent_pairs: sample = prepare_sample(tokenizer, a, b, is_next=True) batch_data.append(sample) for a, b in non_adjacent_pairs: sample = prepare_sample(tokenizer, a, b, is_next=False) batch_data.append(sample) return batch_data def prepare_sample(tokenizer, tokens_a_idx, tokens_b_idx, is_next): sentences = tokenizer.word_ids tokens_a = sentences[tokens_a_idx] tokens_b = sentences[tokens_b_idx] # 拼接 [CLS] + A + [SEP] + B + [SEP] input_ids = [tokenizer.word2idx['CLS']] + tokens_a + [tokenizer.word2idx['SEP']] + tokens_b + [ tokenizer.word2idx['SEP']] segment_ids = [0] * (1 + len(tokens_a) + 1) + [1] * (1 + len(tokens_b)) # MLM 准备 n_pred = min(max_pred, max(1, int(len(input_ids) * 0.2))) cand_pos = [ i for i, token in enumerate(input_ids) if token not in {tokenizer.word2idx['CLS'], tokenizer.word2idx['SEP'], tokenizer.word2idx['PAD'], tokenizer.word2idx['UNK']} ] random.shuffle(cand_pos) masked_pos, masked_tokens = tokenizer.masking_procedure(cand_pos[:n_pred], input_ids, tokenizer.word2idx['MASK']) # Padding def pad(seq, target_len, pad_value=tokenizer.word2idx['PAD']): seq += [pad_value] * (target_len - len(seq)) pad(input_ids, tokenizer.max_len) pad(segment_ids, tokenizer.max_len) if max_pred > n_pred: pad(masked_pos, max_pred) pad(masked_tokens, max_pred) return [input_ids, segment_ids, masked_tokens, masked_pos, is_next]\"]},\"580\":{\"h\":\"模型\",\"t\":[\"本文中的 Bert 模型整体实现也比较简单，其中关于BertEncoders编码并输出结果的整个过程如下图所示:\",\"NSP 任务会利用 CLS Token 作为整个输入序列的全局信息聚合表示，再经过非线性变换后，进行二分类任务，判断下一个句子是否是当前句子的后续句子，具体过程如下图所示:\",\"MLM 任务会利用 masked_pos 从BertEncoders编码输出结果中提取出被掩码的位置对应的嵌入向量，经过相同的非线性变换后，将这些掩码Token对应的嵌入向量映射到词向量空间中去，得到模型预测的这些掩码Token对应的真实词，具体过程如下图所示:\",\"核心代码实现如下:\",\"class BERT(nn.Module): def __init__(self, n_layers, vocab_size, max_len): \\\"\\\"\\\" 初始化一个简化版的 BERT 模型，支持 MLM（掩码语言建模） 和 NSP（下一句预测） 两个任务。 参数： n_layers: Transformer 编码器层数 vocab_size: 词表大小 max_len: 最大序列长度 \\\"\\\"\\\" super(BERT, self).__init__() # 1. 词嵌入 + 位置嵌入 + 句子嵌入 self.embedding = Embeddings(vocab_size, max_len) # 2. 多个 Transformer 编码器层堆叠 self.encoders = nn.ModuleList([ EncoderLayer() for _ in range(n_layers) ]) # 3. Pooler 层：用于提取 [CLS] token 的表示，用于 NSP 任务 self.pooler = Pooler() # 4. 下一句预测（NSP）分类器 self.next_cls = nn.Linear(d_model, 2) # 输出维度为 2，表示是否是连续句子 self.gelu = gelu # GELU 激活函数 # 5. 权重共享：Pooler 层与 FC 层共享权重 shared_weight = self.pooler.fc.weight # 获取 pooler 中的全连接层权重 self.fc = nn.Linear(d_model, d_model) # 创建新的线性层 self.fc.weight = shared_weight # 共享权重（weight tying） # 6. 权重共享：MLM 分类器共享词嵌入矩阵 shared_weight = self.embedding.word_emb.weight # 获取词嵌入层权重 self.word_classifier = nn.Linear(d_model, vocab_size, bias=False) self.word_classifier.weight = shared_weight # 权重共享（tie weights） def forward(self, tokens, segments, masked_pos): \\\"\\\"\\\" 前向传播逻辑 输入： tokens: [batch_size, seq_len]，token 的索引（已添加 [CLS], [SEP], [MASK] 等） segments: [batch_size, seq_len]，segment_id，区分句子 A 和 B masked_pos: [batch_size, max_pred]，记录被掩码的位置 输出： logits_cls: [batch_size, 2]，NSP 分类结果 logits_lm: [batch_size, max_pred, vocab_size]，MLM 预测结果 \\\"\\\"\\\" # 1. 词嵌入 + 位置嵌入 + 句子嵌入 output = self.embedding(tokens, segments) # shape: [batch_size, seq_len, d_model] # 2. 构造 padding mask（忽略填充部分） enc_self_pad_mask = get_pad_mask(tokens) # shape: [batch_size, seq_len, seq_len] # 3. 依次通过每个编码器层（Transformer Layer） for layer in self.encoders: output = layer(output, enc_self_pad_mask) # output shape: [batch_size, seq_len, d_model] # 4. NSP 任务：使用 [CLS] 标记进行下一句预测 hidden_pool = self.pooler(output[:, 0]) # 提取 [CLS] 位置的隐藏状态并池化 logits_cls = self.next_cls(hidden_pool) # 分类输出：[batch_size, 2] # 5. MLM 任务：恢复被掩码的词 # masked_pos: [batch_size, max_pred] # 扩展 masked_pos 到三维，便于从 output 中 gather 出被掩码位置的表示 masked_pos = masked_pos.unsqueeze(-1).expand(-1, -1, d_model) # shape: [batch, max_pred, d_model] # 使用 torch.gather 从 output 中取出被掩码位置的 token 表示 h_masked = torch.gather(output, dim=1, index=masked_pos) # shape: [batch_size, max_pred, d_model] # 通过全连接层 + GELU 激活函数 h_masked = self.gather(output, dim=1, index=masked_pos) # 再次提取被掩码位置的表示 h_masked = self.gelu(self.fc(h_masked)) # shape: [batch_size, max_pred, d_model] # 6. MLM 分类器：预测被掩码的词 logits_lm = self.word_classifier(h_masked) # shape: [batch_size, max_pred, vocab_size] # 返回两个任务的结果 return logits_cls, logits_lm\",\"完整的代码实现部分，大家参考仓库源码即可，本文不再全部Copy展示。\"]},\"581\":{\"h\":\"训练\",\"t\":[\"训练过程就比较常规了，有一点不同就是Bert预训练阶段的学习目标是: MLM Loss + NSP Loss ，具体核心代码实现如下:\",\"tokenizer = Tokenizer(\\\"dataset/wikitext-2/train.json\\\") batch_data = make_data(tokenizer) batch_tensor = [torch.LongTensor(ele) for ele in zip(*batch_data)] dataset = BERTDataset(*batch_tensor) dataloader = DataLoader(dataset, batch_size=32, shuffle=True) model = BERT(n_layers,tokenizer.vocab_size,tokenizer.max_len) lr = 1e-4 epochs = 100 # 优化器与学习率调度器 optimizer = AdamW(model.parameters(), lr=1e-4, weight_decay=0.01) # 损失函数 + 标签平滑 criterion1 = nn.CrossEntropyLoss(label_smoothing=0.1) criterion2 = nn.CrossEntropyLoss(label_smoothing=0.1,ignore_index=0) # 加载检查点 checkpoint_path = 'best_model.pth' if os.path.exists(checkpoint_path): model.load_state_dict(torch.load(checkpoint_path, weights_only=True, map_location=device)) print('Loaded checkpoint from', checkpoint_path) model.to(device) best_loss = float('inf') # training total_batches = len(dataloader) for epoch in range(epochs): avg_loss = 0 for batch_idx, one_batch in enumerate(dataloader): input_ids, segment_ids, masked_tokens, masked_pos, is_next = [ele.to(device) for ele in one_batch] logits_cls, logits_lm = model(input_ids, segment_ids, masked_pos) # NSP 任务损失 loss_cls = criterion1(logits_cls, is_next) # MLM 任务损失 loss_lm = criterion2(logits_lm.view(-1, tokenizer.vocab_size), masked_tokens.view(-1)) loss_lm = (loss_lm.float()).mean() # 总损失 loss = loss_cls + loss_lm avg_loss += loss.item() if (epoch + 1) % 1 == 0: print(f'Epoch:{epoch + 1} Batch:{batch_idx + 1}/{total_batches} \\\\t loss: {loss:.6f}') loss.backward() torch.nn.utils.clip_grad_norm_(model.parameters(), max_norm=1.0) optimizer.step() avg_loss /= total_batches # 保存最优模型 if avg_loss < best_loss: best_loss = avg_loss torch.save(model.state_dict(), f'best_model.pth') print(f'Saved best model with loss: {best_loss:.6f}') # 效果评估 evaluate_model()\",\"由于模型输出的logits_cls是一个二分类值，因此我们只需要根据is_next取出索引0或者1下标对应的值即可知道我们是否预测正确，并且使用预测结果计算NSP任务损失值。\",\"对于MLM任务损失计算来说，我们只会计算被随机遮盖或替换的部分，其余部分不做损失，因此模型返回的logits_lm也只包含被掩码的Token对应的模型预测真实词，同时通过masked_tokens可知这些被掩码Token对应的真实词作为Label，从而计算交叉熵损失就很简单了。\",\"这里需要注意一点，对于MLM任务损失计算来说，我们需要在其对应的CrossEntropyLoss中指定ignore_index=0，即忽略掉PAD部分的损失计算；\",\"这里PAD部分指的是对于不同的句子，它们都是按照其序列长度的20%比例进行的掩码，而对于较短的句子，其掩码数量可能会偏少，因此为了确保masked_tokens列表中所有句子掩码数量一致，需要对掩码数量不足max_pred的进行PAD填充。\",\"模型返回的logits_lm中同样含有PAD部分，但是我们在计算损失时指定了ignore_index=0，即忽略掉PAD部分的损失计算，因此不会影响最终的损失值计算。\",\"gather函数比较灵活，它可以在指定维度上，根据索引矩阵，从源张量中提取特定位置的元素，构造一个新的张量。\",\"对于每一个输出位置 (i,j)，如果 dim=1（列方向），那么它从 input [index[i][j]][j] 中取值。\",\"对于每一个输出位置 (i,j)，如果 dim=0（列方向），那么它从 input [i][index[i][j]] 中取值。\"]},\"582\":{\"h\":\"效果\",\"t\":[\"本文所展示的Bert预训练属于教学级别的，最终的训练效果也是一般，仅供参考和学习:\",\"MLM Task: Correct / Total = 3167 / 9027 | Accuracy = 0.3508 (预测正确的掩码词数量/总掩码的词数量)\",\"NSP Task: Correct / Total = 504 / 960 | Accuracy = 0.5250 (预测正确的句对数量/总句对数量)\"]},\"583\":{\"h\":\"Details\",\"t\":[\"本节将会对Bert模型实现的部分细节进行说明。\"]},\"584\":{\"h\":\"Padding Mask 如何生成并起作用的 ？\",\"t\":[\"首先模型会根据传入的Tokens列表生成一个Pad Mask矩阵，该 矩阵维度 和 Q@K.T 后得到的注意力得分矩阵维度相同\",\"def get_pad_mask(tokens, pad_idx=0): ''' suppose index of [PAD] is zero in word2idx tokens: [batch, seq_len] ''' batch, seq_len = tokens.size() pad_mask = tokens.data.eq(pad_idx).unsqueeze(1) # （batch,1,seq_len) pad_mask = pad_mask.expand(batch, seq_len, seq_len) # （batch,seq_len,seq_len) return pad_mask\",\"假设输入的Token序列为: [A,B,C,PAD,PAD,PAD] , 则生成的Pad Mask模样为:\",\"在注意力得分矩阵计算完毕后，我们会使用Pad Mask矩阵将注意力得分矩阵中对应位置的得分设置为一个非常小的值，这样在后续的Softmax计算中，这些位置的概率就会接近0，从而在注意力机制中就不会考虑到这些PAD部分的Token了。\",\"class ScaledDotProductAttention(nn.Module): def forward(self, Q, K, V, attn_mask): scores = torch.matmul(Q, K.transpose(-1, -2) / msqrt(d_k)) # scores: [batch, n_heads, seq_len, seq_len] scores.masked_fill_(attn_mask, -1e9) attn = nn.Softmax(dim=-1)(scores) # context: [batch, n_heads, seq_len, d_v] context = torch.matmul(attn, V) return context\",\"横着看是计算某个词与全局序列中其他词的相关度，后续需要利用该相关度完成当前词的全局上下文信息融合，我们只需要确保对于某个词的上下文融合不被PAD词参与即可，而无需考虑PAD词的全局上下文信息是否需要进行计算。\"]},\"585\":{\"h\":\"位置编码\",\"t\":[\"位置编码\"]},\"586\":{\"h\":\"绝对位置编码（Absolute Positional Encoding, APE）\"},\"587\":{\"h\":\"正弦/余弦位置编码（Sinusoidal Positional Encoding）\",\"t\":[\"正弦余弦位置编码（Sinusoidal Positional Encoding）是一种无需训练的位置编码方法，它通过固定的周期性函数（正弦和余弦）来为序列的不同位置提供唯一的编码。对于每个位置 和每个维度 ，位置编码通过以下公式计算：\",\" 表示位置索引，表示计算哪个位置的编码\",\" 表示编码维度， 是编码空间的总维度\",\" 和 通过正弦和余弦函数分裂映射到偶数和奇数的维度\",\"假设：我们要计算输入序列第 2 个位置 Token 对应的位置编码，编码的维度设定为 4 ，则：\",\"最终，位置 2 的编码向量为：，我们把它加到第二个 Token 的词嵌入向量上，就相当于给其注入了顺序信息。\",\"计算起来是比较容易的，如何去理解这个位置编码？请看下面这张图：\",\"这三张图分别打印了 128 个位置向量第 2、6、12 维度的编码值的变化，我们发现这些值呈现周期性的变化。另外，我们也可以发现，向量维度越高，其周期就越长。\",\"上图，我们打印了位置 1、5 的编码向量中的 sin 和 cos 计算得到的编码值。我们可以发现，基于正弦和余弦函数得到的位置编码可以保证唯一性。另外，也可以看到，向量的维度越高，编码值的波动就越小，向量就越接近。\",\"简单总结下：\",\"因为正弦和余弦函数都是周期函数，编码在不同维度上具有不同的周期性\",\"位置编码向量是唯一的，因为不同位置的编码由不同的正弦和余弦值组成\",\"低维度的编码值波动性很大（周期短），高纬度的编码值波动性较小（周期长）\",\"所以，可以得到一个简单的结论：\",\"低维分量（小 i）的变化较快，主要捕捉局部位置关系\",\"高维分量（大 i）的变化较慢，可以用于编码全局信息\",\"这个怎么去理解？我们把某个位置的向量大概划分为两部分：低维向量部分 + 高维向量部分，低纬向量部分数值波动幅度很大，在一个周期内只能包含少量相邻的位置，并且一定程度上也表达了位置的局部的相对信息，这就是捕捉局部位置关系。那么，对于高纬向量部分而言，它的波动幅度很小，一个周期能够包含更多的位置信息，这也是我们理解的编码全局位置信息的含义。\",\"所以，对于一个基于正弦余弦编码的位置向量，可以理解为该向量中隐含了一些局部和全局的位置信息。使得 Transformer 既能感知局部相对位置，也能感知全局位置信息，从而弥补其原生结构中缺少位置感知能力的缺陷。\",\"当然，这种位置编码方法也存在以下一些不足之处：\",\"随着序列长度的增加，位置编码的周期性可能导致不同位置之间的区分度逐渐降低，难以准确表示极长序列中各个位置的独特信息。\",\"虽然正弦余弦位置编码能够隐含地表达一定的局部位置信息，但由于它是固定的、不可学习的，并没有专门针对局部依赖关系进行优化，因此在建模局部依赖关系时能力相对不足。\",\"正弦余弦位置编码是一种基于三角函数的固定编码方式，它是一种静态的位置信息表示。而注意力机制更关注的是文本中不同位置之间的动态语义关联。这两种信息在表示形式和语义侧重点上存在差异，导致在融合时可能无法很好地相互补充。\",\"正弦余弦位置编码通常是高维向量，其计算量会随着维度的增加不仅需要更多的计算时间，还可能占用大量的内存空间，影响模型的运行效率。\",\"正余弦位置编码通过在不同维度上引入不同波长的正余弦信号，使得低维对局部位置变化敏感，高维对全局位置变化敏感。虽然位置和语义在所有维度上混合，但在训练中，模型可能学到一种“低维更多位置，高维更多语义”的分工模式。\"]},\"588\":{\"h\":\"基于可学习的嵌入\",\"t\":[\"可学习的位置编码（Learnable Positional Encoding, LPE）是一种通过梯度下降自动学习位置编码的方法，不同于固定编码（如正弦/余弦函数编码），它不依赖任何手工设计的公式，而是直接让模型在训练过程中优化位置信息。对于一个长度为 𝐿 的输入序列，每个位置 𝑖 都对应一个可学习的向量。当训练或测试时，将输入 Token 的编码和对应位置的可学习位置编码向量相加，从而赋予 Token 相应的位置信息。\",\"这种位置编码方式能够根据具体的任务和数据特点，模型可以学习到更适合该类文本的位置表示方式，捕捉文本中位置相关的语义和结构信息，这是固定的位置编码（例如：正弦余弦位置编码）难以做到的。但是也存在一些不足之处，例如：\",\"如果训练时 max_len=512，测试时输入 1024 长度的序列，模型就无法处理了\",\"需要存储 max_len×d_model 维度的参数，可能导致大模型训练更难收敛\"]},\"589\":{\"h\":\"相对位置编码（Relative Position Encoding, RPE）\",\"t\":[\"相对位置编码直接对 两个 token 之间的距离 建模。例如：\",\"token i 关注 token j 时，注意力分数不仅取决于它们的内容，还取决于 i - j 的相对位置。\",\"如果两个位置的相对距离相同，那么它们的相对位置信息也是相同的（模型可以更好泛化到更长的序列）。\"]},\"590\":{\"h\":\"Relative Position Representations (Shaw et al., 2018)\",\"t\":[\"普通自注意力打分公式：\",\"其中：\",\"Shaw 相对位置编码改成：\",\"这里：\",\" 是和相对距离 对应的向量（可训练）。\",\"只要知道 ，就能从一个 embedding table 里查到对应的 向量。\",\"下面先给出完整代码实现，然后再进行详细解析:\",\"import torch import torch.nn as nn import math class RelPosAttention(nn.Module): def __init__(self, d_model, n_heads, max_len): super().__init__() self.n_heads = n_heads self.d_k = d_model // n_heads self.W_q = nn.Linear(d_model, d_model) self.W_k = nn.Linear(d_model, d_model) self.W_v = nn.Linear(d_model, d_model) self.W_o = nn.Linear(d_model, d_model) self.rel_emb = nn.Embedding(2 * max_len - 1, self.d_k) # 相对位置向量表 self.max_len = max_len def forward(self, x): B, L, _ = x.size() assert L <= self.max_len, \\\"输入序列长度超过max_len\\\" Q = self.W_q(x).view(B, L, self.n_heads, self.d_k).transpose(1, 2) # (B, h, L, d_k) K = self.W_k(x).view(B, L, self.n_heads, self.d_k).transpose(1, 2) V = self.W_v(x).view(B, L, self.n_heads, self.d_k).transpose(1, 2) # ===== 1. 普通注意力部分 ===== content_score = torch.matmul(Q, K.transpose(-2, -1)) # (B, h, L, L) # ===== 2. 相对位置部分 ===== # 相对位置索引矩阵 rel_pos = torch.arange(L, device=x.device).unsqueeze(1) - torch.arange(L, device=x.device).unsqueeze(0) rel_pos += self.max_len - 1 # shift到[0, 2L-2] R = self.rel_emb(rel_pos) # (L, L, d_k) # 使用爱因斯坦求和公式计算 Q_i ⋅ R_{i-j} pos_score = torch.einsum('bhld,lmd->bhlm', Q, R) # ===== 3. 合并并归一化 ===== scores = (content_score + pos_score) / math.sqrt(self.d_k) attn = torch.softmax(scores, dim=-1) out = torch.matmul(attn, V) # (B, h, L, d_k) out = out.transpose(1, 2).contiguous().view(B, L, -1) return self.W_o(out)\",\"首先来看一下 Shaw 相对位置编码中的相对位置矩阵的详解:\",\"生成相对位置差矩阵\",\"rel_pos = torch.arange(L, device=x.device).unsqueeze(1) - torch.arange(L, device=x.device).unsqueeze(0)\",\"假设序列长度 L = 4，torch.arange(L) 是：\",\"[0, 1, 2, 3]\",\"unsqueeze(1) 变成列向量 shape (4,1)\",\"unsqueeze(0) 变成行向量 shape (1,4)\",\"做减法（广播规则）：\",\"[[ 0-0, 0-1, 0-2, 0-3], [ 1-0, 1-1, 1-2, 1-3], [ 2-0, 2-1, 2-2, 2-3], [ 3-0, 3-1, 3-2, 3-3]]\",\"结果是：\",\"[[ 0, -1, -2, -3], [ 1, 0, -1, -2], [ 2, 1, 0, -1], [ 3, 2, 1, 0]]\",\"含义：第 i 行第 j 列的值就是 i - j，即 token i 与 token j 的相对距离。\",\"平移到正索引区间\",\"rel_pos += self.max_len - 1\",\"Embedding 的索引必须是 非负整数，所以要把负值平移到正数区间。如果 max_len=4，self.max_len - 1 = 3，加 3 后：\",\"[[3, 2, 1, 0], [4, 3, 2, 1], [5, 4, 3, 2], [6, 5, 4, 3]]\",\"值域范围是 [0, 2*max_len-2]。这正好对应 self.rel_emb 的 embedding 表大小 (2*max_len - 1, d_k)。\",\"查表得到相对位置向量\",\"R = self.rel_emb(rel_pos) # shape: (L, L, d_k)\",\"self.rel_emb 是一个可训练的 embedding 表，每个相对距离对应一个向量。rel_pos 的形状是 (L, L)，查表后：\",\"第一维 = 查询位置 i\",\"第二维 = 被关注位置 j\",\"第三维 = 对应的相对位置编码向量 ，长度 d_k\",\"所以 R 是一个 (L, L, d_k) 张量。\",\"用爱因斯坦求和公式计算位置分数\",\"pos_score = torch.einsum('bhld,lmd->bhlm', Q, R)\",\"先看两个输入的形状:\",\"Q: (B, h, L, d_k)\",\"B = batch 大小\",\"h = 注意力头数\",\"L = 序列长度（查询 token 的位置）\",\"d_k = 每个头的向量维度（Q 向量长度）\",\"R: (L, L, d_k)\",\"第 1 维：查询位置 index \",\"第 2 维：被关注位置 index \",\"第 3 维：与相对位置 对应的向量（长度 d_k）\",\"爱因斯坦求和规则: 'bhld,lmd->bhlm'\",\"左边 Q 的维度：b h l d\",\"右边 R 的维度：l m d\",\"两者中相同字母代表要“配对”的轴：\",\"l：查询位置 i → 保持不变（参与配对但保留在输出里）\",\"d：向量维度 → 相同字母且不出现在输出，表示要相乘后求和（点积）\",\"不同字母：\",\"m：来自 R 的“被关注位置”维度，出现在输出\",\"b、h：来自 Q 的 batch 和头维度，直接保留\",\"我们想算：\",\"固定 batch b、head h、查询位置 l、被关注位置 m\",\"从 Q 里取对应的查询向量 \",\"从 R 里取对应的相对位置向量 \",\"对它们做向量点积（沿 d 维求和）\",\"为什么相对位置矩阵 不直接加到注意力分数里，而是还要和 做点积？\",\"在标准自注意力中，打分是：\",\"其中：\",\"：查询 token i 的内容向量\",\"：被关注 token j 的内容向量\",\"这两个向量都在同一个向量空间中（维度 d_k），点积才能得到一个有意义的相似度分数。Shaw 的做法是：\",\"第二项的解释：\",\" 也是在 d_k 维的向量空间中。\",\"用 和 做点积，把位置信息向量投影到和 Q_i 一致的表示空间。\",\"这样得到的结果是一个标量，可以直接和 Q·K 的结果相加。\",\"换句话说：\",\"K 部分带来内容相关性\",\"R 部分带来位置相关性\",\"二者都要在同一个“Q 向量的视角”下衡量，所以都用 做点积\",\"可以把注意力打分看作“你(i)对别人(j)的关注程度”，它可能由两部分组成：\",\"内容相似度：你关心和你内容类似的人（Q·K）\",\"位置偏好：你关心离你近的人（Q·R）\"]},\"591\":{\"h\":\"T5 相对位置偏置（Relative Position Bias, RPB）\",\"t\":[\"在自注意力里，注意力打分是\",\"T5 在这个分数上再加一个与“相对距离”相关的标量偏置：\",\" 是查询位置到键位置的相对距离。\",\"为了参数更省、泛化更好，T5 不为每个距离单独学一个参数，而是把距离映射到少量“桶”（bucket）：近距离用细桶、远距离用粗桶（对数分桶）。\",\"每个桶学一个标量偏置，通常 按头（per-head）独立学习（形状：[num_buckets, n_heads]），再广播到 (B, n_heads, L_q, L_k)。\",\"这样既让模型“偏好临近”或“惩罚太远”，又几乎不增加计算量。\",\"Shaw RPR：相对位置像“额外的 Key 特征”，参与点积计算\",\"T5 RPB：相对位置像“分数修正表”，只在 attention 分数上加偏置\",\"偏置表（bias table）怎么理解 ?\",\"bias_table = nn.Parameter(torch.zeros(num_buckets, H))\",\"num_buckets：表示“相对位置的分组数量”。\",\"T5 并不对每个相对位置都单独存一个偏置，而是把相对距离压缩到若干个桶（bucket）里。\",\"比如小距离 1、2、3 可以映射到同一个桶，远距离可能映射到不同桶。\",\"H：表示注意力头数，每个头的偏置可以不同。\",\"不同头可以学习到不同的相对位置偏置模式，比如一个头关注短距离，一个头关注长距离。\",\"偏置表作用:\",\"偏置表里的每个元素是一个标量，它对应某个相对位置桶 + 注意力头的偏置。\",\"它不会参与点积运算，只是直接加到注意力分数上：\",\"通过加偏置，模型可以编码“相对位置信息”，比如让模型偏向关注附近的 token。\",\"可以想象成一个小表格：\",\"桶 (bucket)\",\"head0\",\"head1\",\"head2\",\"0\",\"0.1\",\"-0.2\",\"0.05\",\"1\",\"0.3\",\"0.0\",\"0.1\",\"2\",\"-0.1\",\"0.2\",\"0.0\",\"…\",\"…\",\"…\",\"…\",\"每一列 = 一个头的所有偏置\",\"每一行 = 一个相对距离桶的偏置\",\"当模型计算注意力分数时，它会根据 query-key 的相对距离找到对应的桶，然后查表取出偏置，加到该头的注意力分数上。\",\"桶的作用是什么 ？\",\"我们已经有了 相对位置矩阵relative_position[i,j] = j - i ，例如长度 8 的序列：\",\"i\\\\j 0 1 2 3 4 5 6 7 0 0 1 2 3 4 5 6 7 1 -1 0 1 2 3 4 5 6 2 -2 -1 0 1 2 3 4 5 3 -3 -2 -1 0 1 2 3 4 ...\",\"每个元素表示 query i 对 key j 的相对距离\",\"问题：序列很长时，如果直接为每个距离学习偏置，参数量会非常大。\",\"桶映射的目的:\",\"把相对距离压缩到固定数量的桶里\",\"T5 的做法：小距离用独立桶，大距离用对数压缩的桶\",\"这样：\",\"短距离：每个距离有自己的偏置（细粒度）\",\"长距离：距离较大的 token 共享同一桶（粗粒度）\",\"优点：\",\"节省参数\",\"保持模型关注短距离精细信息，同时对长距离不必过于精细\",\"假设 num_buckets = 4（简化）：\",\"relative_position ≤ 1 → bucket 0\",\"relative_position = 2 → bucket 1\",\"relative_position = 3~4 → bucket 2\",\"relative_position > 4 → bucket 3\",\"对序列 [A,B,C,D]：\",\"relative_position: i\\\\j 0 1 2 3 0 0 1 2 3 1 -1 0 1 2 2 -2 -1 0 1 3 -3 -2 -1 0 映射到桶 (bucket): i\\\\j 0 1 2 3 0 0 0 1 2 1 0 0 0 1 2 1 0 0 0 3 2 1 0 0\",\"每个元素都变成了 0~num_buckets-1 的整数\",\"这个整数就是偏置查表的索引\",\"核心理解：\",\"相对位置桶 = “距离分组”\",\"通过桶映射，可以让模型 对短距离敏感，对长距离粗略处理\",\"桶号最终用来查 bias_table，得到每个 query-key 对的偏置\",\"整体流程 ?\",\"假设：\",\"batch size: B\",\"序列长度: L\",\"注意力头数: H\",\"相对位置桶数: num_buckets\",\"(1) 偏置表\",\"bias_table = nn.Parameter(torch.zeros(num_buckets, H))\",\"shape: (num_buckets, H)\",\"每个桶每个头都有一个标量偏置\",\"(2) 相对位置矩阵\",\"relative_position = memory_position - context_position # (L,L)\",\"shape: (L, L)\",\"值是 j-i，表示 query i 对 key j 的相对位置\",\"(3) 桶映射\",\"relative_buckets = relative_position_bucket(relative_position) # (L,L)\",\"shape: (L,L)\",\"每个元素是 0~num_buckets-1\",\"(4) 查表得到偏置\",\"bias = bias_table[relative_buckets] # (L,L,H) bias = bias.permute(2,0,1) # (H,L,L)\",\"bias_table[relative_buckets] 用每个 (i,j) 桶号查表\",\"得到 (L,L,H)，然后换维度到 (H,L,L)，方便加到注意力分数\",\"(5) 广播 batch\",\"注意力分数：\",\"attn_scores = Q @ K.transpose(-1,-2) # (B,H,L,L) attn_scores = attn_scores + bias.unsqueeze(0) # (B,H,L,L)\",\"bias.unsqueeze(0) shape → (1,H,L,L)\",\"自动广播到 batch 维度 (B,H,L,L)\",\"每个头有独立偏置，不同 batch 共用\",\"(6) 相加过程总结\",\"先算 原始注意力分数：Q @ K^T → (B,H,L,L)\",\"查表得到 相对位置偏置：bias → (H,L,L)\",\"加到注意力分数：\",\"最终 shape 仍然 (B,H,L,L)，用于 softmax\",\"代码实现如下:\",\"import torch import torch.nn as nn class T5RelativePositionBias(nn.Module): def __init__(self, num_buckets=32, max_distance=128, n_heads=12): super().__init__() self.num_buckets = num_buckets self.max_distance = max_distance self.n_heads = n_heads # 偏置表：每个 bucket 对每个 attention head 存一个标量 self.relative_attention_bias = nn.Embedding(num_buckets, n_heads) def _relative_position_bucket(self, relative_position): \\\"\\\"\\\" 将相对位置映射到 [0, num_buckets-1] 的桶索引。 设计目的： - 相对位置可能范围很大（如 -512 ~ +512） - 如果直接给每个位置都分配一个独立参数，参数量会很大 - 解决方法： 1. 对短距离用线性分桶（精确表示） 2. 对长距离用对数分桶（粗略表示） 3. 可选地分开处理方向（左/右） 参数： relative_position: torch.Tensor - 形状 (Lq, Lk) 或 (..., Lq, Lk) - 元素为 key_position - query_position 负数：key 在 query 左边 正数：key 在 query 右边 返回： ret: torch.LongTensor - 形状与 relative_position 相同 - 每个元素是该相对位置对应的桶编号 \\\"\\\"\\\" num_buckets = self.num_buckets # 桶的总数量，例如 32 max_distance = self.max_distance # 能映射的最大距离（超过按最大处理） ret = 0 # 初始化桶编号 # 1. 取反（T5 定义相对位置为 memory_pos - context_pos，这里保持一致性） n = -relative_position # n < 0 表示 key 在 query 右边，n > 0 表示 key 在 query 左边 # 2. 方向分桶（可选） # 如果 key 在 query 左边 (n < 0)，桶号加 num_buckets//2 # 这样前一半桶表示左方向，后一半桶表示右方向 ret += (n < 0).to(torch.long) * num_buckets // 2 # 3. 只取绝对值（方向信息已在上一步编码） n = torch.abs(n) # 4. 定义短距离线性映射的阈值 # 前一半桶（num_buckets//2）用于精确表示短距离 max_exact = num_buckets // 2 # 例如 num_buckets=32 时，max_exact=16 # 5. 判断哪些是短距离 is_small = n < max_exact # 布尔张量 # 6. 对长距离做对数映射 # - 将距离范围 [max_exact, max_distance] 映射到桶 [max_exact, num_buckets-1] # - 对数映射可以把大范围的距离压缩到少量桶 val_if_large = max_exact + ( (torch.log(n.float() / max_exact) / # 距离归一化并取对数 torch.log(max_distance / max_exact)) # 对数分母：归一化最大距离 * (num_buckets - max_exact) # 映射到长距离桶区间 ).to(torch.long) # 7. 防止溢出（大于最大桶号的全部压到最后一个桶） val_if_large = torch.min( val_if_large, torch.full_like(val_if_large, num_buckets - 1) ) # 8. 根据距离类别（短/长）选择桶编号 ret += torch.where(is_small, n, val_if_large) return ret def forward(self, query_length, key_length): \\\"\\\"\\\" 返回 shape (1, n_heads, query_length, key_length) 的偏置矩阵 \\\"\\\"\\\" # 计算相对位置矩阵 (i - j) context_pos = torch.arange(query_length)[:, None] # (Lq, 1) memory_pos = torch.arange(key_length)[None, :] # (1, Lk) relative_position = memory_pos - context_pos # (Lq, Lk) # 映射到桶索引 rp_bucket = self._relative_position_bucket(relative_position) # 查表获取偏置值 (Lq, Lk, n_heads) values = self.relative_attention_bias(rp_bucket) # 调整维度 → (1, n_heads, Lq, Lk)，方便加到 attention scores 上 values = values.permute(2, 0, 1).unsqueeze(0) return values\",\"Step 1 — 偏置表的定义\",\"self.relative_attention_bias = nn.Embedding(num_buckets, n_heads)\",\"形状 = (num_buckets, n_heads)\",\"表示每个 桶 对应每个 注意力头 的一个标量偏置\",\"为什么是 Embedding：\",\"桶号是整数索引（0~num_buckets-1）\",\"Embedding 可以高效查表\",\"Step 2 — 构造相对位置矩阵\",\"context_pos = torch.arange(query_length)[:, None] # (Lq, 1) memory_pos = torch.arange(key_length)[None, :] # (1, Lk) relative_position = memory_pos - context_pos # (Lq, Lk)\",\"(i,j) 元素 = j - i\",\"例如 L=4：\",\"[[0, 1, 2, 3], [-1, 0, 1, 2], [-2, -1, 0, 1], [-3, -2, -1, 0]]\",\"Step 3 — 相对位置桶映射\",\"rp_bucket = self._relative_position_bucket(relative_position)\",\"目的：把 [-max_len, +max_len] 映射到 0 ~ num_buckets-1\",\"T5策略：\",\"短距离（|n| < max_exact）→ 线性映射，每个距离单独一个桶\",\"长距离 → 对数映射，多个距离共享一个桶\",\"正负方向可能分桶（方向信息保留）\",\"结果：桶矩阵 shape (Lq, Lk)，值是整数\",\"Step 4 — 查表获取偏置\",\"values = self.relative_attention_bias(rp_bucket) # (Lq, Lk, n_heads)\",\"对 (i,j) 的桶号 rp_bucket[i,j]，查表得到 shape (n_heads,) 的偏置\",\"最终得到 (Lq, Lk, n_heads)，即每个位置对每个 head 的偏置值\",\"Step 5 — 调整维度以便加到注意力分数\",\"values = values.permute(2, 0, 1).unsqueeze(0) # (1, n_heads, Lq, Lk)\",\"attention 分数 shape = (batch, n_heads, Lq, Lk)\",\"偏置加法公式：\",\"unsqueeze(0) 是为了 batch 维度可广播\",\"Step 6 — 加到注意力分数的时机\",\"在 T5 的多头注意力里，这一步通常是这样做的：\",\"scores = torch.matmul(Q, K.transpose(-1, -2)) # (B, H, Lq, Lk) scores += position_bias # (1, H, Lq, Lk) 广播相加\",\"区别于 Shaw 2018 的做法（它在 Q·K 之前，把位置向量加到 K 里），T5 是在 attention scores 已经计算完之后 再加偏置。\",\"一句话总结：\",\"T5 RPB 用 桶映射 + 查表 的方式，为每个 query-key 对加一个与相对位置有关的标量偏置（每个 head 单独学习），它是在注意力分数计算完之后加上去的，因此只需要二维标量表，不需要像 Shaw 那样存整个向量矩阵。\"]},\"592\":{\"h\":\"图解 Bert\",\"t\":[\"图解Bert & Bert文本分类实战\"]},\"593\":{\"h\":\"环境搭建\",\"t\":[\"按序执行以下命令完成环境搭建:\",\"git clone https://github.com/DA-southampton/Read_Bert_Code.git cd Read_Bert_Code conda create -n Read_Bert_Code python=3.9.22 conda activate Read_Bert_Code\",\"本文使用的是谷歌的中文预训练模型：chinese_L-12_H-768_A-12.zip，模型有点大，我就不上传了，如果本地不存在，就点击这里直接下载,或者直接命令行运行\",\"wget https://storage.googleapis.com/bert_models/2018_11_03/chinese_L-12_H-768_A-12.zip\",\"预训练模型下载下来之后，进行解压，然后将tf模型转为对应的pytorch版本即可。对应代码如下:\",\"export BERT_BASE_DIR=/Users/zhandaohong/Read_Bert_Code/chinese_L-12_H-768_A-12 python convert_tf_checkpoint_to_pytorch.py \\\\ --tf_checkpoint_path$BERT_BASE_DIR/bert_model.ckpt \\\\ --bert_config_file$BERT_BASE_DIR/bert_config.json \\\\ --pytorch_dump_path$BERT_BASE_DIR/pytorch_model.bin\",\"转化成功之后，将模型放入到仓库对应位置：\",\"Read_Bert_Code/bert_read_step_to_step/prev_trained_model/\",\"并重新命名为：\",\" bert-base-chinese\",\"其次是准备训练数据，这里我准备做一个文本分类任务，使用的是Tnews数据集，这个数据集来源是这里，分为训练，测试和开发集，我已经上传到了仓库中，具体位置在\",\"Read_Bert_Code/bert_read_step_to_step/chineseGLUEdatasets/tnews\",\"需要注意的一点是，因为我只是为了了解内部代码情况，所以准确度不是在我的考虑范围之内，所以我只是取其中的一部分数据，其中训练数据使用1k，测试数据使用1k，开发数据1k。\",\"准备就绪，使用pycharm导入项目，准备调试，我的调试文件是run_classifier.py文件，对应的参数为\",\"--model_type=bert --model_name_or_path=prev_trained_model/bert-base-chinese --task_name=\\\"tnews\\\" --do_train --do_eval --do_lower_case --data_dir=./chineseGLUEdatasets/tnews --max_seq_length=128 --per_gpu_train_batch_size=16 --per_gpu_eval_batch_size=16 --learning_rate=2e-5 --num_train_epochs=4.0 --logging_steps=100 --save_steps=100 --output_dir=./outputs/tnews_output/ --overwrite_output_dir\",\"然后启动 run_classifier.py 文件进行调试即可 , 所参考源仓库未提供requirements.txt文件，因此需要大家自行完成运行时缺失依赖包的安装。\"]},\"594\":{\"h\":\"数据预处理\",\"t\":[\"输入数据格式\",\"{ \\\"guid\\\": \\\"train-0\\\", \\\"label\\\": \\\"104\\\", // 文本分类任务: 文本对应的标签 \\\"text_a\\\": \\\"股票中的突破形态\\\", \\\"text_b\\\": null // NSP任务: 用于判断给出的两个句子是否连续 }\",\"NSP (Next Sentence Prediction)\",\"文本分词 & 借助字典映射为word id\",\"\\\"股票中的突破形态\\\" --> ['股', '票', '中', '的', '突', '破', '形', '态'] --> [5500, 4873, 704, 4638, 4960, 4788, 2501, 2578]\",\"对于字典中不存在的词 , 用 [UNK] 表示, 对应的id为 100\",\"过长截断策略\",\"添加特殊Token标记\",\"原序列添加特殊Token标记图\",\"[101, 5500, 4873, 704, 4638, 4960, 4788, 2501, 2578, 102]\",\"BertTokenizer中的特殊token id:\",\"[CLS]: 101\",\"[SEP]: 102\",\"[MASK]: 103\",\"[UNK]: 100\",\"[PAD]: 0\",\" # BertTokenizer def build_inputs_with_special_tokens(self, token_ids_0, token_ids_1=None): if token_ids_1 is None: return [self.cls_token_id] + token_ids_0 + [self.sep_token_id] cls = [self.cls_token_id] sep = [self.sep_token_id] return cls + token_ids_0 + sep + token_ids_1 + sep\",\"创建句子辨识列表，用以区分不同的句子\",\"token_type_ids作用图解\",\" # BertTokenizer def create_token_type_ids_from_sequences(self, token_ids_0, token_ids_1=None): \\\"\\\"\\\" Creates a mask from the two sequences passed to be used in a sequence-pair classification task. A BERT sequence pair mask has the following format: 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 | first sequence | second sequence if token_ids_1 is None, only returns the first portion of the mask (0's). \\\"\\\"\\\" sep = [self.sep_token_id] cls = [self.cls_token_id] if token_ids_1 is None: return len(cls + token_ids_0 + sep) * [0] return len(cls + token_ids_0 + sep) * [0] + len(token_ids_1 + sep) * [1]\",\"创建用以区分special tokens部分的mask列表\",\"special_tokens_mask作用图解\",\" # BertTokenizer def get_special_tokens_mask(self, token_ids_0, token_ids_1=None, already_has_special_tokens=False): if token_ids_1 is not None: return [1] + ([0] * len(token_ids_0)) + [1] + ([0] * len(token_ids_1)) + [1] return [1] + ([0] * len(token_ids_0)) + [1]\",\"超长截断\",\" # PreTrainedTokenizer if max_length and len(encoded_inputs[\\\"input_ids\\\"]) > max_length: encoded_inputs[\\\"input_ids\\\"] = encoded_inputs[\\\"input_ids\\\"][:max_length] encoded_inputs[\\\"token_type_ids\\\"] = encoded_inputs[\\\"token_type_ids\\\"][:max_length] encoded_inputs[\\\"special_tokens_mask\\\"] = encoded_inputs[\\\"special_tokens_mask\\\"][:max_length]\",\"生成padding部分的mask列表\",\"attention_mask作用图解\",\" # 生成注意力掩码，真实token对应1，填充token对应0 attention_mask = [1 if mask_padding_with_zero else 0] * len(input_ids)\",\"所有序列都填充到max_length长度,不足长度用padding填充\",\"填充过程图\",\" # 记录输入长度 input_len = len(input_ids) # 计算需要填充的长度 --- 所有输入序列等长，都等于max_length padding_length = max_length - len(input_ids) # 右填充 input_ids = input_ids + ([pad_token] * padding_length) attention_mask = attention_mask + ([0 if mask_padding_with_zero else 1] * padding_length) token_type_ids = token_type_ids + ([pad_token_segment_id] * padding_length)\",\"数据集中每一个样本最终都会解析得到一个InputFeatures\",\"InputFeatures组成图解\",\"features.append( InputFeatures(input_ids=input_ids, attention_mask=attention_mask, token_type_ids=token_type_ids, label=label, input_len=input_len))\",\"label 是当前文本对应的类别标签 input_len 是序列实际长度(含special tokens)\",\"数据集预处理完后，将InputFeatures List列表组装起来得到需要的DataSet\",\"dataset = TensorDataset(all_input_ids, all_attention_mask, all_token_type_ids, all_lens,all_labels)\"]},\"595\":{\"h\":\"模型架构\"},\"596\":{\"h\":\"DataLoader\",\"t\":[\" train_sampler = RandomSampler(train_dataset) if args.local_rank == -1 else DistributedSampler(train_dataset) train_dataloader = DataLoader(train_dataset, sampler=train_sampler, batch_size=args.train_batch_size,collate_fn=collate_fn)\",\"DataLoader 设置的回调方法cllote_fn负责对返回的一个batch，在返回前进行预处理:\",\"def collate_fn(batch): all_input_ids, all_attention_mask, all_token_type_ids, all_lens, all_labels = map(torch.stack, zip(*batch)) max_len = max(all_lens).item() # 计算当前批次中所有序列的实际最大长度 all_input_ids = all_input_ids[:, :max_len] # 按照本批次序列中最大长度进行截断: max_length --> max_len all_attention_mask = all_attention_mask[:, :max_len] all_token_type_ids = all_token_type_ids[:, :max_len] return all_input_ids, all_attention_mask, all_token_type_ids, all_labels\"]},\"597\":{\"h\":\"BertEmbeddings\",\"t\":[\"input embeddings = token embeddings + segmentation embeddings + position embeddings\",\"class BertEmbeddings(nn.Module): def __init__(self, config): super(BertEmbeddings, self).__init__() self.word_embeddings = nn.Embedding(config.vocab_size, config.hidden_size, padding_idx=0) self.position_embeddings = nn.Embedding(config.max_position_embeddings, config.hidden_size) self.token_type_embeddings = nn.Embedding(config.type_vocab_size, config.hidden_size) self.LayerNorm = BertLayerNorm(config.hidden_size, eps=config.layer_norm_eps) self.dropout = nn.Dropout(config.hidden_dropout_prob) def forward(self, input_ids, token_type_ids=None, position_ids=None): seq_length = input_ids.size(1) if position_ids is None: # 为当前批次中的每个序列样本生成一个位置序列: (1,2,3,4,5,...) , 构成一个位置序列矩阵 position_ids = torch.arange(seq_length, dtype=torch.long, device=input_ids.device) position_ids = position_ids.unsqueeze(0).expand_as(input_ids) if token_type_ids is None: token_type_ids = torch.zeros_like(input_ids) words_embeddings = self.word_embeddings(input_ids) position_embeddings = self.position_embeddings(position_ids) # 位置编码为可学习的矩阵 token_type_embeddings = self.token_type_embeddings(token_type_ids) # 让模型自己学会区分不同的句子 embeddings = words_embeddings + position_embeddings + token_type_embeddings embeddings = self.LayerNorm(embeddings) embeddings = self.dropout(embeddings) return embeddings\",\"嵌入向量生成过程图\"]},\"598\":{\"h\":\"BertEncoder\"},\"599\":{\"h\":\"BertLayer\",\"t\":[\"BertLayer模型结构图\",\"class BertIntermediate(nn.Module): def __init__(self, config): super(BertIntermediate, self).__init__() self.dense = nn.Linear(config.hidden_size, config.intermediate_size) # (768,3072) # 激活函数 - GLEU if isinstance(config.hidden_act, str) or (sys.version_info[0] == 2 and isinstance(config.hidden_act, unicode)): self.intermediate_act_fn = ACT2FN[config.hidden_act] else: self.intermediate_act_fn = config.hidden_act def forward(self, hidden_states): hidden_states = self.dense(hidden_states) hidden_states = self.intermediate_act_fn(hidden_states) # 激活函数 - GLEU return hidden_states class BertOutput(nn.Module): def __init__(self, config): super(BertOutput, self).__init__() self.dense = nn.Linear(config.intermediate_size, config.hidden_size) # (3072,768) self.LayerNorm = BertLayerNorm(config.hidden_size, eps=config.layer_norm_eps) self.dropout = nn.Dropout(config.hidden_dropout_prob) def forward(self, hidden_states, input_tensor): hidden_states = self.dense(hidden_states) hidden_states = self.dropout(hidden_states) hidden_states = self.LayerNorm(hidden_states + input_tensor) return hidden_states class BertLayer(nn.Module): def __init__(self, config): super(BertLayer, self).__init__() self.attention = BertAttention(config) self.intermediate = BertIntermediate(config) self.output = BertOutput(config) def forward(self, hidden_states, attention_mask=None): attention_output = self.attention(hidden_states, attention_mask) intermediate_output = self.intermediate(attention_output) layer_output = self.output(intermediate_output, attention_output) return layer_output\"]},\"600\":{\"h\":\"BertEncoder\",\"t\":[\"BertEncoder模型结构图\",\"class BertEncoder(nn.Module): def __init__(self, config): super(BertEncoder, self).__init__() self.layer = nn.ModuleList([BertLayer(config) for _ in range(config.num_hidden_layers)]) def forward(self, hidden_states, attention_mask=None, head_mask=None): for i, layer_module in enumerate(self.layer): hidden_states = layer_module(hidden_states, attention_mask, head_mask[i]) return hidden_states\"]},\"601\":{\"h\":\"BertPooler\",\"t\":[\"BertPooler模型结构图\",\"class BertPooler(nn.Module): def __init__(self, config): super(BertPooler, self).__init__() self.dense = nn.Linear(config.hidden_size, config.hidden_size) self.activation = nn.Tanh() def forward(self, hidden_states): # We \\\"pool\\\" the model by simply taking the hidden state corresponding # to the first token. first_token_tensor = hidden_states[:, 0] # CLS Token Context Embeddings pooled_output = self.dense(first_token_tensor) pooled_output = self.activation(pooled_output) return pooled_output\"]},\"602\":{\"h\":\"BertModel\",\"t\":[\"BertModel模型结构图\",\"class BertModel(BertPreTrainedModel): def __init__(self, config): super(BertModel, self).__init__(config) self.embeddings = BertEmbeddings(config) self.encoder = BertEncoder(config) self.pooler = BertPooler(config) self.init_weights() def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None): extended_attention_mask = attention_mask.unsqueeze(1).unsqueeze(2) extended_attention_mask = extended_attention_mask.to(dtype=next(self.parameters()).dtype) # fp16 compatibility extended_attention_mask = (1.0 - extended_attention_mask) * -10000.0 embedding_output = self.embeddings(input_ids, position_ids=position_ids, token_type_ids=token_type_ids) sequence_output = self.encoder(embedding_output, extended_attention_mask, # padding mask ) pooled_output = self.pooler(sequence_output) outputs = (sequence_output, pooled_output,) return outputs\"]},\"603\":{\"h\":\"BertForSequenceClassification\",\"t\":[\"BertForSequenceClassification模型结构图\",\"class BertForSequenceClassification(BertPreTrainedModel): def __init__(self, config): super(BertForSequenceClassification, self).__init__(config) self.num_labels = config.num_labels self.bert = BertModel(config) self.dropout = nn.Dropout(config.hidden_dropout_prob) self.classifier = nn.Linear(config.hidden_size, self.config.num_labels) self.init_weights() def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None, labels=None): outputs = self.bert(input_ids, attention_mask=attention_mask, # padding mask token_type_ids=token_type_ids, position_ids=position_ids, head_mask=head_mask) # None ? pooled_output = outputs[1] # 对于分类任务来说，只需要去除CLS Token用于分类任务即可 pooled_output = self.dropout(pooled_output) logits = self.classifier(pooled_output) outputs = (logits,) + outputs[2:] # add hidden states and attention if they are here if labels is not None: if self.num_labels == 1: # We are doing regression loss_fct = MSELoss() loss = loss_fct(logits.view(-1), labels.view(-1)) else: loss_fct = CrossEntropyLoss() loss = loss_fct(logits.view(-1, self.num_labels), labels.view(-1)) outputs = (loss,) + outputs return outputs # (loss), logits, (hidden_states), (attentions)\"]},\"604\":{\"h\":\"BertAttention\"},\"605\":{\"h\":\"BertSelfAttention\",\"t\":[\"多头自注意力计算流程图\",\"class BertSelfAttention(nn.Module): def __init__(self, config): super(BertSelfAttention, self).__init__() self.output_attentions = config.output_attentions self.num_attention_heads = config.num_attention_heads self.attention_head_size = int(config.hidden_size / config.num_attention_heads) self.all_head_size = self.num_attention_heads * self.attention_head_size self.query = nn.Linear(config.hidden_size, self.all_head_size) self.key = nn.Linear(config.hidden_size, self.all_head_size) self.value = nn.Linear(config.hidden_size, self.all_head_size) self.dropout = nn.Dropout(config.attention_probs_dropout_prob) def transpose_for_scores(self, x): new_x_shape = x.size()[:-1] + (self.num_attention_heads, self.attention_head_size) x = x.view(*new_x_shape) return x.permute(0, 2, 1, 3) def forward(self, hidden_states, attention_mask=None, head_mask=None): mixed_query_layer = self.query(hidden_states) mixed_key_layer = self.key(hidden_states) mixed_value_layer = self.value(hidden_states) # view 成多头格式: (batch,heads,seq_len,d_k) query_layer = self.transpose_for_scores(mixed_query_layer) key_layer = self.transpose_for_scores(mixed_key_layer) value_layer = self.transpose_for_scores(mixed_value_layer) # Take the dot product between \\\"query\\\" and \\\"key\\\" to get the raw attention scores. attention_scores = torch.matmul(query_layer, key_layer.transpose(-1, -2)) # (batch,heads,d_k,seq_len) attention_scores = attention_scores / math.sqrt(self.attention_head_size) if attention_mask is not None: # Apply the attention mask is (precomputed for all layers in BertModel forward() function) attention_scores = attention_scores + attention_mask # Normalize the attention scores to probabilities. attention_probs = nn.Softmax(dim=-1)(attention_scores) # This is actually dropping out entire tokens to attend to, which might # seem a bit unusual, but is taken from the original Transformer paper. attention_probs = self.dropout(attention_probs) context_layer = torch.matmul(attention_probs, value_layer) context_layer = context_layer.permute(0, 2, 1, 3).contiguous() new_context_layer_shape = context_layer.size()[:-2] + (self.all_head_size,) context_layer = context_layer.view(*new_context_layer_shape) # 合并头结果 return context_layer\"]},\"606\":{\"h\":\"BertSelfOutput\",\"t\":[\"BertSelfOutput计算流程图\",\"class BertSelfOutput(nn.Module): def __init__(self, config): super(BertSelfOutput, self).__init__() self.dense = nn.Linear(config.hidden_size, config.hidden_size) self.LayerNorm = BertLayerNorm(config.hidden_size, eps=config.layer_norm_eps) self.dropout = nn.Dropout(config.hidden_dropout_prob) # 残差链接 + 层归一化 def forward(self, hidden_states, input_tensor): hidden_states = self.dense(hidden_states) hidden_states = self.dropout(hidden_states) hidden_states = self.LayerNorm(hidden_states + input_tensor) return hidden_states\"]},\"607\":{\"h\":\"BertAttention\",\"t\":[\"BertAttention计算流程图\",\"class BertAttention(nn.Module): def __init__(self, config): super(BertAttention, self).__init__() self.self = BertSelfAttention(config) self.output = BertSelfOutput(config) def forward(self, input_tensor, attention_mask=None): self_outputs = self.self(input_tensor, attention_mask) # 多头自注意力机制 attention_output = self.output(self_outputs, input_tensor) return attention_output\"]},\"608\":{\"h\":\"预训练\",\"t\":[\"预训练与微调\"]},\"609\":{\"h\":\"BertPredictionHeadTransform\",\"t\":[\"BertPredictionHeadTransform结构图\",\"class BertPredictionHeadTransform(nn.Module): def __init__(self, config): super(BertPredictionHeadTransform, self).__init__() self.dense = nn.Linear(config.hidden_size, config.hidden_size) if isinstance(config.hidden_act, str) or (sys.version_info[0] == 2 and isinstance(config.hidden_act, unicode)): self.transform_act_fn = ACT2FN[config.hidden_act] else: self.transform_act_fn = config.hidden_act self.LayerNorm = BertLayerNorm(config.hidden_size, eps=config.layer_norm_eps) def forward(self, hidden_states): hidden_states = self.dense(hidden_states) hidden_states = self.transform_act_fn(hidden_states) hidden_states = self.LayerNorm(hidden_states) return hidden_states\"]},\"610\":{\"h\":\"BertLMPredictionHead\",\"t\":[\"BertLMPredictionHead结构图\",\"class BertLMPredictionHead(nn.Module): def __init__(self, config): super(BertLMPredictionHead, self).__init__() self.transform = BertPredictionHeadTransform(config) # The output weights are the same as the input embeddings, but there is # an output-only bias for each token. self.decoder = nn.Linear(config.hidden_size, config.vocab_size, bias=False) self.bias = nn.Parameter(torch.zeros(config.vocab_size)) def forward(self, hidden_states): hidden_states = self.transform(hidden_states) hidden_states = self.decoder(hidden_states) + self.bias return hidden_states\"]},\"611\":{\"h\":\"BertPreTrainingHeads\",\"t\":[\"BertPreTrainingHeads结构图\",\"class BertPreTrainingHeads(nn.Module): def __init__(self, config): super(BertPreTrainingHeads, self).__init__() self.predictions = BertLMPredictionHead(config) self.seq_relationship = nn.Linear(config.hidden_size, 2) def forward(self, sequence_output, pooled_output): prediction_scores = self.predictions(sequence_output) # seq_relationship_score = self.seq_relationship(pooled_output) # 两个句子是否为上下句关系 return prediction_scores, seq_relationship_score\"]},\"612\":{\"h\":\"BertForPreTraining\",\"t\":[\"BertForPreTraining结构图\",\"class BertForPreTraining(BertPreTrainedModel): def __init__(self, config): super(BertForPreTraining, self).__init__(config) self.bert = BertModel(config) self.cls = BertPreTrainingHeads(config) def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None, masked_lm_labels=None, next_sentence_label=None): outputs = self.bert(input_ids, attention_mask=attention_mask, token_type_ids=token_type_ids, position_ids=position_ids, head_mask=head_mask) sequence_output, pooled_output = outputs[:2] # 隐藏层输出,CLS Token Embeddings prediction_scores, seq_relationship_score = self.cls(sequence_output, pooled_output) outputs = (prediction_scores, seq_relationship_score,) # 计算掩码语言损失 和 下一个句子预测损失 if masked_lm_labels is not None and next_sentence_label is not None: loss_fct = CrossEntropyLoss(ignore_index=-1) masked_lm_loss = loss_fct(prediction_scores.view(-1, self.config.vocab_size), masked_lm_labels.view(-1)) next_sentence_loss = loss_fct(seq_relationship_score.view(-1, 2), next_sentence_label.view(-1)) total_loss = masked_lm_loss + next_sentence_loss outputs = (total_loss,) + outputs return outputs # (loss), prediction_scores, seq_relationship_score, (hidden_states), (attentions)\"]},\"613\":{\"h\":\"其他下游任务\",\"t\":[\"Bert支持的下游任务图\"]},\"614\":{\"h\":\"问答任务\",\"t\":[\"在 BERT 的问答任务中，典型的输入是一个包含 问题（Question） 和 上下文（Context） 的文本对。例如：\",\"问题: “谁写了《哈姆雷特》？”上下文: “莎士比亚是英国文学史上最伟大的作家之一，他写了包括《哈姆雷特》、《麦克白》等著名悲剧。”\",\"输入格式（Tokenization 后的形式），在使用 BertTokenizer 编码后，输入会变成如下结构：\",\"[CLS] 问题 tokens [SEP] 上下文 tokens [SEP]\",\"BERT 的输出（Outputs），通过调用 self.bert(...)，你将得到一个包含多个元素的 tuple 输出：\",\"outputs = self.bert(input_ids, attention_mask=attention_mask, token_type_ids=token_type_ids)\",\"返回值形如：\",\"( sequence_output, # (batch_size, seq_length, hidden_size) pooled_output, # (batch_size, hidden_size) )\",\"主要输出项解释:\",\"✅ sequence_output: 最终每个 token 的表示\",\"形状：(batch_size, seq_length, hidden_size)\",\"是模型最后一层所有 token（包括问题和上下文）的隐藏状态。\",\"在问答任务中，我们主要使用它来预测答案的起始和结束位置。\",\"✅ pooled_output: 句子级别表示（不常用）\",\"形状：(batch_size, hidden_size)\",\"是 [CLS] token 经过一层全连接后的输出。\",\"在分类任务中更有用，在问答任务中一般不会使用这个输出。\",\"如何利用 BERT 输出做问答预测？\",\"在 BertForQuestionAnswering 中，使用了如下逻辑：\",\"logits = self.qa_outputs(sequence_output) # (batch_size, seq_length, 2) start_logits, end_logits = logits.split(1, dim=-1) # split into start and end start_logits = start_logits.squeeze(-1) # (batch_size, seq_length) end_logits = end_logits.squeeze(-1)\",\"qa_outputs 层的作用：\",\"是一个线性层：nn.Linear(config.hidden_size, 2)\",\"将每个 token 的 hidden_size 向量映射成两个分数：一个是该 token 作为答案开始的可能性，另一个是作为答案结束的可能性。\",\"输出解释：\",\"start_logits: 每个 token 是答案起点的得分（未归一化）。\",\"end_logits: 每个 token 是答案终点的得分。\",\"比如对于一个长度为 128 的序列，每个 token 都有一个对应的 start/end 分数：\",\"start_scores = torch.softmax(start_logits, dim=-1) # softmax 得到概率 end_scores = torch.softmax(end_logits, dim=-1) # 找出最可能是 start 和 end 的位置 start_index = torch.argmax(start_scores) end_index = torch.argmax(end_scores)\",\"如果 start_index <= end_index，那么可以组合这两个索引得到答案 span。\"]},\"615\":{\"h\":\"代码实现\",\"t\":[\"class BertForQuestionAnswering(BertPreTrainedModel): def __init__(self, config): super(BertForQuestionAnswering, self).__init__(config) self.num_labels = config.num_labels # 通常是 2，即 start 和 end self.bert = BertModel(config) self.qa_outputs = nn.Linear(config.hidden_size, config.num_labels) def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None, start_positions=None, end_positions=None): outputs = self.bert(input_ids, attention_mask=attention_mask, token_type_ids=token_type_ids, position_ids=position_ids) sequence_output = outputs[0] # (batch,seq_len,hidden_size) ---> (batch,seq_len,2) logits = self.qa_outputs(sequence_output) start_logits, end_logits = logits.split(1, dim=-1) start_logits = start_logits.squeeze(-1) # (batch,seq_len) end_logits = end_logits.squeeze(-1) outputs = (start_logits, end_logits,) # 计算交叉熵损失 if start_positions is not None and end_positions is not None: # sometimes the start/end positions are outside our model inputs, we ignore these terms # ignored_index = seq_len ignored_index = start_logits.size(1) # clamp_ 是 PyTorch 中的一个方法，用于将张量中的值限制在指定的范围内。 # 它的语法是 tensor.clamp_(min, max) ，表示将张量中的值限制在 min 和 max 之间。 # 如果值小于 min ，则将其设置为 min ；如果值大于 max ，则将其设置为 max 。 start_positions.clamp_(0, ignored_index) end_positions.clamp_(0, ignored_index) # ignore_index: 用于指定在计算损失时忽略的标签索引。 loss_fct = CrossEntropyLoss(ignore_index=ignored_index) # 分别计算答案起始下标和结束下标预测得到的交叉熵损失 start_loss = loss_fct(start_logits, start_positions) end_loss = loss_fct(end_logits, end_positions) total_loss = (start_loss + end_loss) / 2 outputs = (total_loss,) + outputs return outputs # (loss), start_logits, end_logits\"]},\"616\":{\"h\":\"易混淆\",\"t\":[\"BERT 是一个 基于上下文编码（Contextual Encoder） 的模型，不是自回归生成器。它不会“生成”新的文本，而是对输入文本中每个 token 的角色进行分类（如判断哪个是答案的开始、结束）。所以最终的答案只能来自原始输入文本中的某一段子串。\",\"📚 详细解释\",\"✅ BERT 是一个 Encoder-only 模型\",\"BERT 只包含 Transformer 的 encoder 部分。\",\"它的作用是给定一个完整的句子（或两个句子），对每个 token 生成一个上下文相关的表示（contextualized representation）。\",\"它不具有生成能力，不能像 GPT 这样的 decoder-only 模型那样逐词生成新内容。\",\"🔍 QA 任务的本质：定位答案 span 而非生成答案\",\"在 SQuAD 这类抽取式问答任务中：\",\"答案必须是原文中的连续片段（span）。\",\"所以模型的任务是：\",\"给出问题和上下文；\",\"在上下文中找到最可能的答案起始位置和结束位置；\",\"最终答案就是上下文中这两个位置之间的字符串。\",\"BERT 做的就是这个定位任务，而不是重新生成一个新的答案。\",\"🧩 输入与输出的关系\",\"answer_tokens = input_ids[0][start_index : end_index + 1] answer = tokenizer.decode(answer_tokens, skip_special_tokens=True)\",\"这段代码的意思是：\",\"start_index 和 end_index 是模型预测出的答案的起始和结束位置。\",\"我们从原始输入的 input_ids 中取出对应的 token ID 子序列。\",\"使用 tokenizer 把这些 token ID 解码成自然语言文本。\",\"得到的就是答案。\",\"这其实就是在说：\",\"“根据你的理解，答案应该在这段文字中的第 X 到第 Y 个词之间，请把这部分原文告诉我。”\",\"🧪 举个例子\",\"假设原始上下文是：\",\"The capital of France is Paris.\",\"经过 Tokenizer 编码后可能是：\",\"[CLS] the capital of france is paris [SEP]\",\"如果模型预测 start_index=5，end_index=5，那么对应的就是单词 \\\"paris\\\"，这就是答案。\",\"⚠️ 注意事项\",\"不能超出上下文范围\",\"start/end positions 必须落在上下文部分（即 token_type_id == 1 的区域）。\",\"否则答案可能不合理（比如取到了问题部分的内容）。\",\"特殊 token 不计入答案\",\"[CLS], [SEP] 等会被 skip_special_tokens=True 自动跳过。\",\"无法处理不在原文中的答案\",\"如果正确答案没有出现在上下文中，BERT 无法“编造”出来。\",\"这是抽取式问答模型的局限性。\",\"💡 对比：生成式 vs 抽取式问答\",\"类型\",\"模型代表\",\"是否能生成新文本\",\"答案是否必须在原文中\",\"示例\",\"抽取式\",\"BERT\",\"❌\",\"✅\",\"答案是原文中的一段\",\"生成式\",\"T5 / BART / GPT\",\"✅\",\"❌\",\"答案可以是任意文本\",\"如果你希望模型能“自己写答案”，那就需要使用生成式模型。\",\"✅ 总结\",\"问题\",\"回答\",\"为什么答案来自 input_ids？\",\"因为 BERT 是编码器模型，只做抽取式问答，答案必须是原文中的一段文本。\",\"BERT 能不能自己生成答案？\",\"不能，BERT 不具备生成能力，只能对输入文本中的 token 做分类。\",\"如何获取答案？\",\"根据预测的 start/end index，从 input_ids 中提取 token，并用 tokenizer 解码成自然语言。\"]},\"617\":{\"h\":\"Token分类任务\",\"t\":[\"Token 分类任务是指对输入文本中的每个 token 进行分类，常见的应用场景包括：\",\"命名实体识别 (NER)\",\"词性标注 (POS)\",\"语义角色标注 (SRL)\",\"class BertForTokenClassification(BertPreTrainedModel): def __init__(self, config): super(BertForTokenClassification, self).__init__(config) self.num_labels = config.num_labels self.bert = BertModel(config) self.dropout = nn.Dropout(config.hidden_dropout_prob) self.classifier = nn.Linear(config.hidden_size, config.num_labels) def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None, labels=None): outputs = self.bert(input_ids, attention_mask=attention_mask, token_type_ids=token_type_ids, position_ids=position_ids, head_mask=head_mask) sequence_output = outputs[0] # (batch,seq_len,hidden_size) sequence_output = self.dropout(sequence_output) logits = self.classifier(sequence_output) # （batch,seq_len,num_labels） outputs = (logits,) if labels is not None: loss_fct = CrossEntropyLoss() # Only keep active parts of the loss if attention_mask is not None: active_loss = attention_mask.view(-1) == 1 active_logits = logits.view(-1, self.num_labels)[active_loss] active_labels = labels.view(-1)[active_loss] loss = loss_fct(active_logits, active_labels) else: loss = loss_fct(logits.view(-1, self.num_labels), labels.view(-1)) outputs = (loss,) + outputs return outputs # (loss), scores\"]},\"618\":{\"h\":\"多项选择任务\",\"t\":[\"多项选择任务是指给定一个问题和多个候选答案，模型需要从中选择最合适的答案。常见的应用场景包括：\",\"阅读理解任务\",\"问答系统中的候选答案选择\",\"对话系统中的候选回复选择\",\"在 多项选择题（Multiple Choice） 任务中，BERT 的输入组织形式与普通分类或问答任务略有不同。你需要为每个选项分别构造一个完整的 BERT 输入序列，并将它们组合成一个批次进行处理。\",\"✅ 假设你有一个问题 + 4 个选项：\",\"问题：谁写了《哈姆雷特》？ A. 雨果 B. 歌德 C. 莎士比亚 D. 托尔斯泰\",\"对于这样的多选问题，BERT 的输入方式是：\",\"对每一个选项，都单独构造一个 [CLS] + 问题 + [SEP] + 选项内容 + [SEP] 的输入序列。\",\"也就是说，模型会对每个选项分别编码 ，然后从中选出最合适的那个。\",\"class BertForMultipleChoice(BertPreTrainedModel): def __init__(self, config): super(BertForMultipleChoice, self).__init__(config) self.bert = BertModel(config) self.dropout = nn.Dropout(config.hidden_dropout_prob) self.classifier = nn.Linear(config.hidden_size, 1) def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None, labels=None): # 获取选项个数 num_choices = input_ids.shape[1] # (batch_size, num_choices, seq_length) # 将选项展平，以便一起处理: (batch_size * num_choices, seq_length) input_ids = input_ids.view(-1, input_ids.size(-1)) attention_mask = attention_mask.view(-1, attention_mask.size(-1)) if attention_mask is not None else None token_type_ids = token_type_ids.view(-1, token_type_ids.size(-1)) if token_type_ids is not None else None position_ids = position_ids.view(-1, position_ids.size(-1)) if position_ids is not None else None outputs = self.bert(input_ids, attention_mask=attention_mask, token_type_ids=token_type_ids, position_ids=position_ids, head_mask=head_mask) pooled_output = outputs[1] # (batch_size * num_choices, hidden_size) pooled_output = self.dropout(pooled_output) logits = self.classifier(pooled_output) # (batch_size * num_choices, 1) reshaped_logits = logits.view(-1, num_choices) # (batch_size , num_choices, 1) outputs = (reshaped_logits,) if labels is not None: loss_fct = CrossEntropyLoss() loss = loss_fct(reshaped_logits, labels) outputs = (loss,) + outputs return outputs # (loss), reshaped_logits, (hidden_states), (attentions)\",\"在前向传播中，会将这些输入展平，变成：\",\"input_ids.view(-1, seq_length) # (batch_size * num_choices, seq_length)\",\"这样就能让 BERT 对每个选项分别进行编码。\",\"BERT 输出后，再对每个选项做分类打分，最后重新 reshape 成 (batch_size, num_choices) 形式，用于计算交叉熵损失。\"]},\"619\":{\"h\":\"图解Transformer\",\"t\":[\"图解Transformer & 机器翻译实战\"]},\"620\":{\"h\":\"环境\",\"t\":[\"本文基于 The Annotated Transformer 所提供的代码展开进行讲解。\",\"环境搭建遵从如下步骤即可:\",\"git clone https://github.com/harvardnlp/annotated-transformer cd annotated-transformer conda create -n annotated-transformer python=3.9.22 conda activate annotated-transformer pip install -r requirements.txt\",\"MacOS 用户本地运行时，需要将 requirements.txt 文件中的 torch == 1.11.0+cu113 改为 torch==1.11.0，因为CUDA不支持MacOS。\"]},\"621\":{\"h\":\"背景\",\"t\":[\"RNN等模型的缺点是需要顺序计算，从而很难并行。因此出现了Extended Neural GPU、ByteNet和ConvS2S等网络模型。这些模型都是以CNN为基础，这比较容易并行。但是和RNN相比，它较难学习到长距离的依赖关系。\",\"本文的Transformer使用了Self-Attention机制，它在编码每一词的时候都能够注意(attend to)整个句子，从而可以解决长距离依赖的问题，同时计算Self-Attention可以用矩阵乘法一次计算所有的时刻，因此可以充分利用计算资源(CPU/GPU上的矩阵运算都是充分优化和高度并行的)。\"]},\"622\":{\"h\":\"模型架构\",\"t\":[\"Transformer 模型架构图\",\"Transformer 是一种基于自注意力机制(Self-Attention) 的神经网络架构,其由七大主要部分构成:\",\"Encoder-Decoder 结构\",\"编码器(Encoder)：将输入序列（如句子）转换为一系列高维向量表示。\",\"解码器(Decoder)：根据编码器的输出生成目标序列（如翻译后的句子）。\",\"多头自注意力机制（Multi-Head Self-Attention）\",\"自注意力机制是 Transformer 的核心，它允许模型在处理每个词时关注输入序列中的所有词。\",\"多头自注意力机制通过并行计算多个注意力头，捕捉不同子空间的信息，从而增强模型的表达能力。\",\"位置编码（Positional Encoding）\",\"由于 Transformer 不使用传统的循环或卷积结构，它通过位置编码将序列中词的位置信息注入到输入中。位置编码通常使用正弦和余弦函数生成。\",\"前馈神经网络（Feed-Forward Neural Network）\",\"在自注意力机制之后，每个位置的输出会通过一个独立的前馈神经网络进行进一步处理。\",\"残差连接与层归一化（Residual Connection & Layer Normalization）\",\"每个子层（如自注意力层和前馈层）都使用了残差连接和层归一化，以加速训练并提高模型的稳定性。\",\"掩码机制（Masking）\",\"在解码器中，使用掩码机制确保模型在生成目标序列时只能看到当前及之前的词，而不能看到未来的词。\",\"在输入序列长度不一致时，通过填充掩码（Padding Mask）屏蔽填充部分的信息。\",\"输出层\",\"解码器的最终输出通过一个线性层和 Softmax 函数生成目标序列的概率分布。\"]},\"623\":{\"h\":\"Encoder-Decoder 结构\",\"t\":[\"EncoderDecoder模型结构图\",\"class EncoderDecoder(nn.Module): def __init__(self, encoder, decoder, src_embed, tgt_embed, generator): super(EncoderDecoder, self).__init__() self.encoder = encoder self.decoder = decoder self.src_embed = src_embed self.tgt_embed = tgt_embed self.generator = generator def forward(self, src, tgt, src_mask, tgt_mask): \\\"Take in and process masked src and target sequences.\\\" return self.decode(self.encode(src, src_mask), src_mask, tgt, tgt_mask) def encode(self, src, src_mask): return self.encoder(self.src_embed(src), src_mask) def decode(self, memory, src_mask, tgt, tgt_mask): return self.decoder(self.tgt_embed(tgt), memory, src_mask, tgt_mask)\"]},\"624\":{\"h\":\"Generator\",\"t\":[\"Generator模型结构图\",\"class Generator(nn.Module): # 根据Decoder的隐状态输出一个词 # d_model是Decoder输出的大小，vocab是词典大小 def __init__(self, d_model, vocab): super(Generator, self).__init__() self.proj = nn.Linear(d_model, vocab) # 全连接再加上一个softmax def forward(self, x): return F.log_softmax(self.proj(x), dim=-1)\"]},\"625\":{\"h\":\"Encoder 结构\"},\"626\":{\"h\":\"SublayerConnection\",\"t\":[\"SublayerConnection模型结构图\",\"class SublayerConnection(nn.Module): \\\"\\\"\\\" LayerNorm + sublayer(Self-Attenion/Dense) + dropout + 残差连接 为了简单，把LayerNorm放到了前面，这和原始论文稍有不同，原始论文LayerNorm在最后。 \\\"\\\"\\\" def __init__(self, size, dropout): super(SublayerConnection, self).__init__() self.norm = LayerNorm(size) self.dropout = nn.Dropout(dropout) def forward(self, x, sublayer): \\\"sublayer是传入的参数，参考DecoderLayer，它可以当成函数调用，这个函数的有一个输入参数\\\" return x + self.dropout(sublayer(self.norm(x)))\"]},\"627\":{\"h\":\"EncoderLayer\",\"t\":[\"EncoderLayer模型结构图\",\"# 编码器层 = 自注意力子层 + 前馈层 class EncoderLayer(nn.Module): def __init__(self, size, self_attn, feed_forward, dropout): super(EncoderLayer, self).__init__() self.self_attn = self_attn self.feed_forward = feed_forward # 自注意力子层 和 前馈层 各需要一个 self.sublayer = clones(SublayerConnection(size, dropout), 2) self.size = size def forward(self, x, mask): \\\"Follow Figure 1 (left) for connections.\\\" x = self.sublayer[0](x, lambda x: self.self_attn(x, x, x, mask)) return self.sublayer[1](x, self.feed_forward)\"]},\"628\":{\"h\":\"Encoder\",\"t\":[\"Encoder模型结构图\",\"class Encoder(nn.Module): \\\"Core encoder is a stack of N layers\\\" def __init__(self, layer, N): super(Encoder, self).__init__() self.layers = clones(layer, N) self.norm = LayerNorm(layer.size) def forward(self, x, mask): \\\"Pass the input (and mask) through each layer in turn.\\\" for layer in self.layers: x = layer(x, mask) return self.norm(x)\"]},\"629\":{\"h\":\"Decoder 结构\"},\"630\":{\"h\":\"DecoderLayer\",\"t\":[\"Decoder模型结构图\",\"# 解码器层 = 自注意力子层 + 源注意力子层 + 前馈层 class DecoderLayer(nn.Module): \\\"Decoder is made of self-attn, src-attn, and feed forward (defined below)\\\" def __init__(self, size, self_attn, src_attn, feed_forward, dropout): super(DecoderLayer, self).__init__() self.size = size self.self_attn = self_attn self.src_attn = src_attn self.feed_forward = feed_forward # 自注意力子层 + 源注意力子层 + 前馈层 各需要一个 self.sublayer = clones(SublayerConnection(size, dropout), 3) def forward(self, x, memory, src_mask, tgt_mask): \\\"Follow Figure 1 (right) for connections.\\\" m = memory x = self.sublayer[0](x, lambda x: self.self_attn(x, x, x, tgt_mask)) x = self.sublayer[1](x, lambda x: self.src_attn(x, m, m, src_mask)) return self.sublayer[2](x, self.feed_forward)\"]},\"631\":{\"h\":\"Decoder\",\"t\":[\"Decoder模型结构图\",\"# 解码器 = N个解码器层 + 层归一化 class Decoder(nn.Module): \\\"Generic N layer decoder with masking.\\\" def __init__(self, layer, N): super(Decoder, self).__init__() self.layers = clones(layer, N) self.norm = LayerNorm(layer.size) def forward(self, x, memory, src_mask, tgt_mask): # 输入,编码器隐藏层输出,源掩码,目标掩码 for layer in self.layers: x = layer(x, memory, src_mask, tgt_mask) return self.norm(x)\"]},\"632\":{\"h\":\"多头自注意力\",\"t\":[\"多头自注意力计算流程图\",\"class MultiHeadedAttention(nn.Module): def __init__(self, h, d_model, dropout=0.1): \\\"Take in model size and number of heads.\\\" super(MultiHeadedAttention, self).__init__() assert d_model % h == 0 # We assume d_v always equals d_k self.d_k = d_model // h # 每个头64维 self.h = h # 8个头 self.linears = clones(nn.Linear(d_model, d_model), 4) # W_q,W_k,W_v,W_projection self.attn = None self.dropout = nn.Dropout(p=dropout) def forward(self, query, key, value, mask=None): \\\"Implements Figure 2\\\" if mask is not None: # Same mask applied to all h heads. mask = mask.unsqueeze(1) nbatches = query.size(0) # 1) Do all the linear projections in batch from d_model => h x d_k query, key, value = [ lin(x).view(nbatches, -1, self.h, self.d_k).transpose(1, 2) # (batches,heads,seq_len,d_k) for lin, x in zip(self.linears, (query, key, value)) ] # 2) Apply attention on all the projected vectors in batch. x, self.attn = attention( query, key, value, mask=mask, dropout=self.dropout ) # 3) \\\"Concat\\\" using a view and apply a final linear. x = ( x.transpose(1, 2) .contiguous() .view(nbatches, -1, self.h * self.d_k) ) del query del key del value return self.linears[-1](x)\",\"def attention(query, key, value, mask=None, dropout=None): \\\"Compute 'Scaled Dot Product Attention'\\\" d_k = query.size(-1) scores = torch.matmul(query, key.transpose(-2, -1)) / math.sqrt(d_k) if mask is not None: scores = scores.masked_fill(mask == 0, -1e9) # 广播: (1,1,1,10) ---> (1,8,10,10) p_attn = scores.softmax(dim=-1) if dropout is not None: p_attn = dropout(p_attn) return torch.matmul(p_attn, value), p_attn\"]},\"633\":{\"h\":\"🚀 从零构建深度学习框架（一）：计算图与自动微分的起点\",\"t\":[\"1.TinyPytorch 第一阶段: 计算图与自动微分\",\"仓库链接: https://github.com/BinaryOracle/TinyPytorch 本节代码:\"]},\"634\":{\"h\":\"引言：揭开深度学习框架的神秘面纱\",\"t\":[\"深度学习框架中蕴藏着惊人的技术和有趣的机制，而本系列旨在揭开这些技术和机制的神秘面纱，帮助读者正确理解技术，体会它们的有趣之处。为此，本系列将带领读者从零开始创建一个深度学习框架——TinyPytorch。TinyPytorch尽量用最少的代码实现了现代深度学习框架的功能。第一阶段共包含10个步骤，让我们逐步构建起TinyPytorch的基础功能。\"]},\"635\":{\"h\":\"步骤1：作为\\\"箱子\\\"的变量\"},\"636\":{\"h\":\"变量的基本概念\",\"t\":[\"变量是TinyPytorch最重要的组成部分，可将其比作存放数据的\\\"箱子\\\"。在编程中，变量的作用是存储数据，而TinyPytorch的变量实现为Variable类，其核心功能是保存和管理数据。\"]},\"637\":{\"h\":\"代码实现\",\"t\":[\"class Variable: def __init__(self, data): self.data = data\"]},\"638\":{\"h\":\"使用示例\",\"t\":[\"import numpy as np data = np.array(1.0) x = Variable(data) print(x.data) # 输出 1.0 x.data = np.array(2.0) print(x.data) # 输出: 2.0\"]},\"639\":{\"h\":\"关键要点\",\"t\":[\"Variable类封装了NumPy的多维数组（ndarray）\",\"数据存储在data属性中\",\"支持数据的修改和读取\"]},\"640\":{\"h\":\"步骤2：创建变量的函数\"},\"641\":{\"h\":\"函数与计算图\",\"t\":[\"函数定义了变量之间的对应关系，通过计算图可以直观地表示变量与函数的关系。计算图用圆框表示变量，用方框表示函数，节点和箭头展示计算流程。\"]},\"642\":{\"h\":\"函数类的设计\",\"t\":[\"设计Function类作为基类，具体函数继承该类并实现forward方法。__call__方法处理输入输出的变量封装。\"]},\"643\":{\"h\":\"代码实现\",\"t\":[\"class Function: # 设定传入的input和返回的output均为Variable类型 def __call__(self, input): x = input.data y = self.forward(x) output = Variable(y) return output def forward(self, x): raise NotImplementedError() class Square(Function): def forward(self, x): return x ** 2\"]},\"644\":{\"h\":\"辅助函数\",\"t\":[\"为了方便使用，将函数类封装为Python函数：\",\"def square(x): return Square()(x)\"]},\"645\":{\"h\":\"步骤3：函数的连续调用\"},\"646\":{\"h\":\"复合函数的计算\",\"t\":[\"多个函数可以连续调用，形成复合函数。例如，计算，可以通过连续使用平方函数和指数函数实现。\"]},\"647\":{\"h\":\"代码示例\",\"t\":[\"class Exp(Function): def forward(self, x): return np.exp(x) def exp(x): return Exp()(x) A = Square() B = Exp() C = Square() x = Variable(np.array(0.5)) a = A(x) b = B(a) y = C(b) print(y.data) # 输出: 1.648721270700128\"]},\"648\":{\"h\":\"计算图的意义\",\"t\":[\"复合函数的计算图展示了函数的组合过程，而反向传播算法可以高效地求出每个变量的导数，这为自动微分奠定了基础。\"]},\"649\":{\"h\":\"步骤4：数值微分\"},\"650\":{\"h\":\"导数的定义\",\"t\":[\"导数是变化率的表示，函数在处的导数定义为：\"]},\"651\":{\"h\":\"数值微分的实现\",\"t\":[\"使用中心差分近似计算数值微分，公式为：\",\"本部分感兴趣的可以回顾高数中微分定义部分内容，中心差分近似可以问问GPT。\"]},\"652\":{\"h\":\"代码实现\",\"t\":[\"def numerical_diff(f, x, eps=1e-4): x0 = Variable(x.data - eps) x1 = Variable(x.data + eps) y0 = f(x0) y1 = f(x1) return (y1.data - y0.data) / (2 * eps)\"]},\"653\":{\"h\":\"数值微分的问题\",\"t\":[\"结果包含误差（精度丢失）\",\"计算成本高（尤其对于多变量函数）\",\"可用于梯度检验，验证反向传播的正确性\"]},\"654\":{\"h\":\"步骤5：反向传播的理论知识\"},\"655\":{\"h\":\"链式法则\",\"t\":[\"反向传播的理论基础是链式法则，对于复合函数，若由、、组成，则：\"]},\"656\":{\"h\":\"反向传播的方向\",\"t\":[\"反向传播按从输出到输入的顺序计算导数，与正向传播方向相反。这种方式在输出为标量的情况下计算效率更高，适合机器学习中损失函数的优化。\",\"反向传播用于计算输入X对输出Y大小变化的影响，如果没有Function作用于X上，即Y=X，那么影响因子R恒为1；\",\"如果存在Function作用在X上，那么Function可能会放大或者缩小X对输出Y大小变化的影响，也就是改变X对于Y的影响因子，此时R= 1 * F放缩因子；\",\"如果存在多个Function先后作用在X上，即Y=Fn(...F2(F1(X)))，那么此时影响因子R= 1 * F1放缩因子 * F2放缩因子 * ... * Fn放缩因子；\",\"对于Y=F2(F1(x)) + F3(x) , 此时影响因子R = 1 * F1放缩因子 * F2放缩因子 + 1 * F3放缩因子；\",\"实际此处的函数放缩因子也称为函数的导数，多元场景下也称为偏导数。\"]},\"657\":{\"h\":\"计算图的反向传播\",\"t\":[\"反向传播过程中，导数从输出端向输入端传播，每个函数节点需要计算其导数，并将结果传递给前一层变量。\"]},\"658\":{\"h\":\"步骤6：手动进行反向传播\"},\"659\":{\"h\":\"扩展Variable类\",\"t\":[\"为Variable类添加grad属性，用于存储导数：\",\"class Variable: def __init__(self, data): self.data = data self.grad = None\"]},\"660\":{\"h\":\"扩展Function类\",\"t\":[\"为Function类添加反向传播方法backward，并在__call__方法中保存输入输出变量：\",\"class Function: def __call__(self, input): x = input.data y = self.forward(x) output = Variable(y) self.input = input self.output = output return output def backward(self, gy): raise NotImplementedError()\",\"反向传播的核心是依据链式法则，沿计算图反向推导各变量的导数。而链式法则的计算需要知晓每个函数在正向传播时的输入值和输出值。\",\"例如，对于函数 ，其导数 依赖于输入x的具体值（如平方函数 的导数 ，需要知道正向传播时的 值）。记录input后，反向传播时可直接获取这些值，避免重复计算或存储额外数据。\",\"再例如，对于函数 ，其导数依赖于输出值。 函数的表达式为 ，其导数 ，即需要知道正向传播时的输出值 才能计算导数。\"]},\"661\":{\"h\":\"具体函数的反向传播\",\"t\":[\"以平方函数为例：\",\"class Square(Function): def backward(self, gy): x = self.input.data gx = 2 * x * gy return gx\"]},\"662\":{\"h\":\"反向传播的执行\",\"t\":[\"按反向顺序调用各函数的backward方法，手动传递导数：\",\"y.grad = np.array(1.0) b.grad = C.backward(y.grad) a.grad = B.backward(b.grad) x.grad = A.backward(a.grad)\"]},\"663\":{\"h\":\"步骤7：反向传播的自动化\"},\"664\":{\"h\":\"建立变量与函数的连接\",\"t\":[\"在Variable类中添加creator属性，记录创建该变量的函数；在Function类的__call__方法中，设置变量的creator：\",\"class Variable: def set_creator(self, func): self.creator = func class Function: def __call__(self, input): # 其他代码... output.set_creator(self)\"]},\"665\":{\"h\":\"自动反向传播的实现\",\"t\":[\"在Variable类中添加backward方法，通过递归或循环遍历计算图，自动执行反向传播：\",\"class Variable: def backward(self): f = self.creator if f is not None: x = f.input x.grad = f.backward(self.grad) x.backward()\",\"你品，你细品 ~ 🤔 (目前实现的版本无法实现上图中计算图多分支的结构，只能实现一条竖线形状的计算图结构的反向传播)\"]},\"666\":{\"h\":\"步骤8：从递归到循环\"},\"667\":{\"h\":\"递归实现的问题\",\"t\":[\"递归实现的反向传播在计算图较深时可能导致栈溢出，且效率较低。\"]},\"668\":{\"h\":\"循环实现反向传播\",\"t\":[\"使用列表保存待处理的函数，通过循环替代递归：\",\"class Variable: def backward(self): funcs = [self.creator] while funcs: f = funcs.pop() # 弹出列表尾部元素 x, y = f.input, f.output x.grad = f.backward(y.grad) if x.creator is not None: funcs.append(x.creator) # 追加到列表尾部\",\"由于目前只支持竖线形状的计算图，因此func列表同一时刻最多只存在一个func\"]},\"669\":{\"h\":\"循环实现的优势\",\"t\":[\"避免栈溢出\",\"提高执行效率\",\"更容易处理复杂计算图\"]},\"670\":{\"h\":\"步骤9：让函数更易用\"},\"671\":{\"h\":\"函数的Python化\",\"t\":[\"将函数类封装为Python函数，便于直接调用：\",\"def square(x): return Square()(x) def exp(x): return Exp()(x)\"]},\"672\":{\"h\":\"自动设置梯度\",\"t\":[\"在Variable的backward方法中自动初始化梯度：\",\"class Variable: def backward(self): if self.grad is None: self.grad = np.ones_like(self.data) # 其他代码...\"]},\"673\":{\"h\":\"数据类型检查\",\"t\":[\"确保Variable只接受ndarray实例，提高代码健壮性：\",\"class Variable: def __init__(self, data): if data is not None: if not isinstance(data, np.ndarray): raise TypeError(f'{type(data)} is not supported') self.data = data # 其他代码...\"]},\"674\":{\"h\":\"步骤10：测试\"},\"675\":{\"h\":\"单元测试\",\"t\":[\"使用Python的unittest模块编写测试用例，验证函数的正向传播和反向传播：\",\"import unittest class SquareTest(unittest.TestCase): def test_forward(self): x = Variable(np.array(2.0)) y = square(x) self.assertEqual(y.data, np.array(4.0)) def test_backward(self): x = Variable(np.array(3.0)) y = square(x) y.backward() self.assertEqual(x.grad, np.array(6.0))\"]},\"676\":{\"h\":\"梯度检验\",\"t\":[\"将数值微分的结果与反向传播的结果进行比较，验证反向传播的正确性：\",\"def numerical_diff(f, x, eps=1e-4): # 实现如前所述 class SquareTest(unittest.TestCase): def test_gradient_check(self): x = Variable(np.random.rand(1)) y = square(x) y.backward() num_grad = numerical_diff(square, x) self.assertTrue(np.allclose(x.grad, num_grad))\"]},\"677\":{\"h\":\"测试的重要性\",\"t\":[\"确保代码功能正确性\",\"发现潜在bug\",\"支持代码重构和扩展\"]},\"678\":{\"h\":\"第一阶段总结\",\"t\":[\"通过第一阶段的10个步骤，我们从零开始构建了TinyPytorch框架的基础功能：\",\"实现了变量和函数的基本结构\",\"完成了自动微分的核心算法——反向传播\",\"实现了数值微分作为梯度检验工具\",\"优化了反向传播的实现，从递归改为循环\",\"提高了框架的易用性和健壮性\",\"建立了测试机制，确保代码质量\",\"此时的TinyPytorch已经具备了自动微分的能力，可以处理简单的计算图，并为后续的功能扩展奠定了坚实基础。接下来的阶段将进一步扩展TinyPytorch，使其支持更复杂的计算和神经网络的构建。\"]},\"679\":{\"h\":\"🧮 从零构建深度学习框架（二）：自动反向传播与计算图进阶\",\"t\":[\"1.TinyPytorch 第二阶段: 自动反向传播与框架基础能力提升\",\"仓库链接: https://github.com/BinaryOracle/TinyPytorch 本节代码:\"]},\"680\":{\"h\":\"引言：从自动微分迈向通用框架\",\"t\":[\"深度学习框架之所以强大，不仅因为其前向计算功能，更因为其背后复杂而精妙的自动微分系统。本系列文章试图揭开这些机制背后的本质，帮助读者从零搭建属于自己的深度学习引擎。\",\"第一阶段中，我们构建了变量（Variable）与函数（Function）类，实现了基础的计算图结构与反向传播流程，并通过链式法则自动推导了导数。\",\"第二阶段将从第11步延续，全面扩展 TinyPytorch 的核心能力。在第一阶段，我们完成了计算图与手动反向传播的雏形。而在本阶段，我们将继续揭开深度学习框架的核心机制：实现真正意义上的自动反向传播、多输入/输出处理、计算图遍历优化、梯度累加、配置控制等。通过这 14 个步骤，TinyPytorch 将蜕变为一个更通用、更高效、更接近真实框架的自动微分系统。\"]},\"681\":{\"h\":\"步骤11: 多输入与多输出\",\"t\":[\"现实中的神经网络操作往往不仅仅接受一个输入，也可能产生多个输出，例如加法、乘法、切片、拼接等操作。因此我们扩展 Function 类以支持 可变参数输入与输出列表。\",\"class Function: def __call__(self, *inputs): xs = [x.data for x in inputs] ys = self.forward(*xs) if not isinstance(ys, tuple): ys = (ys,) outputs = [Variable(as_array(y)) for y in ys] for output in outputs: output.set_creator(self) self.inputs = inputs self.outputs = outputs return outputs if len(outputs) > 1 else outputs[0] def forward(self, xs): raise NotImplementedError() def backward(self, gys): raise NotImplementedError()\",\"这一扩展使我们的函数定义更接近 NumPy 风格，支持多个输入与输出，提高了灵活性。\",\"为了更好地支持多输入函数，我们学习和利用了 Python 中的几个语法技巧：\",\"*args：接收任意个数的位置参数，用于函数的输入接口；\",\"*xs 解包语法：在调用如 forward(*xs) 时展开变量列表；\",\"tuple 判断：让返回值始终封装为元组，统一处理逻辑。\"]},\"682\":{\"h\":\"步骤12: backward 的多输入实现\",\"t\":[\"在 Variable.backward() 中支持多输出节点：\",\"class Variable: ... def backward(self): if self.grad is None: self.grad = np.ones_like(self.data) funcs = [self.creator] while funcs: f = funcs.pop() gys = [output.grad for output in f.outputs] gxs = f.backward(*gys) if not isinstance(gxs,tuple): gxs = (gxs,) for x, gx in zip(f.inputs, gxs): x.grad = gx if x.creator is not None: funcs.append(x.creator)\",\"这里 gxs 和 f.inputs 的每个元素都是一一对应的。准确来说, 如果有第i个元素, 那么f.input[i]的导数值对应于gxs[i]。于是代码中使用zip 函数和 for 循环来设置每一对的导数。以上就是Variable类的新 backward 方法。\"]},\"683\":{\"h\":\"步骤13: 重置导数\",\"t\":[\"当我们使用同一个变量分别进行多次计算时，我们希望每次计算都能得到正确的导数。为了实现这一点，我们需要在每次计算之前将导数重置为0。\",\"下面为 Variable 类提供一个新的方法，实现变量导数的重置。\",\"class Variable: ... def cleargrad(self): self.grad = None\"]},\"684\":{\"h\":\"步骤14: 共享变量与梯度累加\",\"t\":[\"当某个变量被多次用作输入时（例如 z = x + x），反向传播过程中它的梯度应累加。\",\"这是因为同一个变量对输出的影响路径有多条。如果我们不进行累加，而是直接覆盖梯度值，就会导致只有最后一条路径上的梯度被保留，其他路径上的梯度信息将丢失。\",\"例如：\",\"x = Variable(np.array(3.0)) y = add(x, x) # x 被用作两次输入\",\"在反向传播过程中，x 的梯度来自两个路径：一条是第一个 x 到 y，另一条是第二个 x 到 y。如果我们不对这两个梯度求和，只保留一个，那么 x 的真实导数就会被低估一半，最终影响训练结果。\",\"因此，在实现中应当如下处理：\",\"class Variable: ... def backward(self): if self.grad is None: self.grad = np.ones_like(self.data) funcs = [self.creator] while funcs: f = funcs.pop() gys = [output.grad for output in f.outputs] gxs = f.backward(*gys) if not isinstance(gxs,tuple): gxs = (gxs,) for x, gx in zip(f.inputs, gxs): if x.grad is None: x.grad = gx else: x.grad = x.grad + gx # 正确的累加方式 if x.creator is not None: funcs.append(x.creator)\",\"这样才能确保所有路径的贡献都被纳入最终的梯度值。\"]},\"685\":{\"h\":\"步骤15: 梯度重复累加的问题\",\"t\":[\"在步骤14中，我们通过变量梯度非空则进行累加的改动，解决了共享变量梯度重置的问题，但是这一改动也引发了另一个问题：梯度重复累加。 观察下图，由于目前Variable.backward()的实现逻辑总是将函数追加到待处理列表的末尾，同时又优先处理列表末尾的函数，为\\\"先进先出\\\"的实现逻辑，因此对于存在多分支的复杂计算图而言，它也总是会沿着某个分支进行DFS直到\\\"叶节点\\\"，这会导致如下图所示的共享变量a的梯度被重复累加，导致x变量梯度计算错误。\",\"例子如下:\",\"x = Variable(np.array(2.0)) a = square(x) b = square(a) c = square(a) y = add(b, c) y.backward()\",\"上面的问题本质是因为函数调用顺序错误导致的，对于共享变量，我们要先计算出其梯度后，才能继续计算其前向的梯度，其实也就是按照拓扑排序的方式去遍历计算图。\"]},\"686\":{\"h\":\"步骤16: \\\"辈分\\\"机制\",\"t\":[\"为了解决上述的问题，我们可以采用拓扑排序，但是这里为了方便理解，我们采用更加暴力的“辈分排序”机制确保函数调用顺序的正确执行。\",\"我们可以获取到哪个函数生成了哪个变量，这就构成了函数与变量的\\\"辈分\\\"关系；我们可以通过变量的辈分来设置其创建者函数的辈分，如下图所示:\",\"我们在Variable类和Function类中增加实例变量generation，用其来表示函数(或变量)属于哪一代。\",\"class Variable: def __init__ (self , data): if data is not None: if not isinstance(data , np.ndarray): raise TypeError( '{} is not supported' .format(type(data))) self.data = data self.grad = None self.creator = None self.generation = 0 def set_creator(self, func): self.creator = func self.generation = func.generation + 1 ...\",\"Variable 类将 generation 初始化为 0。之后, 当 set_creator 方法被调用时, 它将 generation 的值设置为父函数的 generation 值加1。\",\"Function 类的 generation 被设置为多个输入变量中最大的generation的值。\",\"class Function: def __call__(self, *inputs): xs = [x.data for x in inputs] ys = self.forward(*xs) if not isinstance(ys, tuple): ys = (ys,) outputs = [Variable(as_array(y)) for y in ys] self.generation = max([x.generation for x in inputs]) for output in outputs: output.set_creator(self) self.inputs = inputs self.outputs = outputs return outputs if len(outputs) > 1 else outputs[0]\",\"通过以上修改, 在进行普通计算(即正向传播)时, 变量和函数中会设置好 generation 的值，我们便可以通过\\\"辈分\\\"按序取出元素。\",\"如上图所示，此时我们可以通过辈分来确保函数B和C先于函数A取出；我们只需要如下修改Variable变量的backward方法即可完成按照辈分获取函数的逻辑:\",\"class Variable: ... def backward(self): if self.grad is None: self.grad = np.ones_like(self.data) funcs = [] seen_set = set() # 防止同一个函数被多次添加到func列表中，从而避免一个函数的backward方法被错误地多次调用 def add_func(f): if f not in seen_set: funcs.append(f) seen_set.add(f) funcs.sort(key=lambda x : x.generation) add_func(self.creator) while funcs: f = funcs.pop() # 每次取出辈分最大的函数 gys = [output.grad for output in f.outputs] gxs = f.backward(*gys) if not isinstance(gxs,tuple): gxs = (gxs,) for x, gx in zip(f.inputs, gxs): if x.grad is None: x.grad = gx else: x.grad = x.grad + gx # 正确的累加方式 if x.creator is not None: add_func(x.creator)\"]},\"687\":{\"h\":\"步骤17: 循环引用与内存释放\",\"t\":[\"Python的内存管理主要依靠两种机制：引用计数和分代垃圾回收（GC）。在深度学习框架中，合理的内存管理至关重要，尤其当处理大规模数据时，不当的内存管理可能导致内存泄漏或程序崩溃。\",\"引用计数：Python通过跟踪对象的引用次数来管理内存。当对象的引用计数为0时，会被立即回收。以下情况会增加引用计数：\",\"使用赋值运算符（如a = obj()）\",\"向函数传递参数（如f(a)）\",\"向容器对象（列表、元组等）添加元素。\",\"循环引用指对象之间相互引用，导致引用计数无法归零，从而无法被自动回收。例如：\",\"a = Obj() b = Obj() c = Obj() a.b = b b.c = c c.a = a a = b = c = None # 此时a、b、c的引用计数仍为1，无法回收\",\"这种情况下，尽管用户不再访问这些对象，但因循环引用，引用计数无法降至0，需依赖垃圾回收机制处理。\",\"虽然Python的垃圾回收（GC）机制可以处理循环引用对象，但在对内存敏感的场景下依然存在问题，主要原因如下：\",\"回收时机非即时性: GC是一种后台机制，通常在内存不足或满足特定条件时才会触发，而非实时回收循环引用对象。例如，当TinyPytorch处理大量神经网络计算时，若存在循环引用，GC可能无法及时释放内存，导致内存占用持续升高，甚至引发内存不足错误。\",\"性能开销较高: GC需要扫描整个对象图来检测循环引用，这一过程对大规模计算框架（如TinyPytorch）而言可能产生显著的性能损耗。尤其在神经网络训练中，频繁的GC操作会影响计算效率，而弱引用可通过避免循环引用直接解决问题，减少GC触发频率。\",\"TinyPytorch中的循环引用:\",\"当前TinyPytorch框架中，Function和Variable实例存在循环引用：\",\"Function实例引用输入和输出的Variable实例（self.inputs和self.outputs）。\",\"Variable实例通过creator属性引用创建它的Function实例。\",\"解决方案：弱引用\",\"弱引用的优势:\",\"避免强引用导致的内存滞留: Function和Variable之间原本存在强引用循环（Function引用Variable，Variable通过creator引用Function）。若使用强引用，即使计算图不再被用户访问，循环引用仍会导致对象无法释放。而弱引用不会增加对象的引用计数，当用户不再引用Variable时，对象可被立即回收，无需等待GC。\",\"符合框架设计需求: TinyPytorch的计算图需要动态构建和销毁，弱引用能确保计算图在使用完毕后自动释放内存。例如，当用户执行完一次前向传播和反向传播后，计算图中的中间变量（如Function和临时Variable）应被及时回收，以释放内存供后续计算使用。\",\"GC与弱引用的互补关系\",\"GC作为兜底机制：GC可处理开发者未显式解决的循环引用，但无法替代弱引用在框架设计中的针对性优化。\",\"弱引用作为主动优化：在TinyPytorch中，通过弱引用主动打破Function与Variable之间的循环引用，能更精准地控制内存释放时机，避免因GC延迟导致的内存问题。\",\"使用Python的weakref模块创建弱引用，避免增加对象的引用计数：\",\"修改Function类：\",\"import weakref class Function: def __call__(self, *inputs): # 原有代码... self.outputs = [weakref.ref(output) for output in outputs] # 将强引用改为弱引用\",\"弱引用不会增加对象的引用计数，当Variable实例不再被其他对象引用时，会被正常回收。\",\"修改Variable类的backward方法：\",\"class Variable: def backward(self): # 原有代码... gys = [output().grad for output in f.outputs] # 通过output()获取实际对象\",\"使用output()从弱引用中获取Variable实例，避免直接引用导致循环。\",\"总结:\",\"循环引用会导致Python对象无法被正常回收，需通过弱引用解决。\",\"在TinyPytorch中，将Function对Variable的引用改为弱引用，避免内存泄漏。\",\"优化后的内存管理确保框架在处理大规模计算时的稳定性和效率。\"]},\"688\":{\"h\":\"步骤18: 优化内存消耗\",\"t\":[\"优化反向传播的内存消耗: TinyPytorch当前的反向传播会保留所有变量的导数，但在实际应用中，仅终端变量的导数需要被保留，中间变量的导数往往无用。为此，我们引入释放中间变量导数的机制。\",\"修改Variable.backward方法: 添加retain_grad参数，若为False（默认），则反向传播后清除中间变量的导数。\",\" class Variable: def backward(self, retain_grad=False): if self.grad is None: self.grad = np.ones_like(self.data) funcs = [] seen_set = set() def add_func(f): if f not in seen_set: funcs.append(f) seen_set.add(f) funcs.sort(key=lambda x: x.generation) add_func(self.creator) while funcs: f = funcs.pop() gys = [output().grad for output in f.outputs] gxs = f.backward(*gys) if not isinstance(gxs, tuple): gxs = (gxs,) for x, gx in zip(f.inputs, gxs): if x.grad is None: x.grad = gx else: x.grad = x.grad + gx if x.creator is not None: add_func(x.creator) if not retain_grad: for y in f.outputs: y().grad = None # 清除中间变量的导数\",\"验证案例：\",\" x0 = Variable(np.array(1.0)) x1 = Variable(np.array(1.0)) t = add(x0, x1) y = add(x0, t) y.backward() # retain_grad默认False print(y.grad, t.grad) # 输出：None None（中间变量导数被清除） print(x0.grad, x1.grad) # 输出：2.0 1.0（终端变量导数保留）\",\"中间变量y和t的导数被立即释放，减少内存占用。\",\"禁用反向传播的模式优化: 在推理阶段（如模型预测），无需计算导数，可通过禁用反向传播模式进一步节省内存。\",\"创建配置类Config：\",\"class Config: enable_backprop = True # 控制反向传播是否启用\",\"修改Function.__call__方法： 仅当Config.enable_backprop为True时，保留反向传播所需的计算图连接：\",\"class Function: def __call__(self, *inputs): xs = [x.data for x in inputs] ys = self.forward(*xs) if not isinstance(ys, tuple): ys = (ys,) outputs = [Variable(as_array(y)) for y in ys] if Config.enable_backprop: self.generation = max([x.generation for x in inputs]) for output in outputs: output.set_creator(self) self.inputs = inputs self.outputs = [weakref.ref(output) for output in outputs] return outputs if len(outputs) > 1 else outputs[0]\",\"模式切换示例：\",\"# 启用反向传播（默认模式） x = Variable(np.ones((100, 100, 100))) y = square(square(square(x))) # 保留中间结果，内存占用高 # 禁用反向传播（推理模式） Config.enable_backprop = False x = Variable(np.ones((100, 100, 100))) y = square(square(square(x))) # 不保留中间结果，内存占用低\",\"禁用模式下，计算完成后中间变量立即释放，内存使用量大幅降低。\",\"使用with语句便捷切换模式: 为避免手动修改Config属性，可通过contextlib模块实现with语句上下文管理。\",\"实现using_config函数：\",\"import contextlib @contextlib.contextmanager def using_config(name, value): old_value = getattr(Config, name) setattr(Config, name, value) try: yield finally: setattr(Config, name, old_value)\",\"封装no_grad函数：\",\"def no_grad(): return using_config('enable_backprop', False) # 使用示例 with no_grad(): x = Variable(np.array(2.0)) y = square(x) # 禁用反向传播，不构建计算图\",\"退出with块后，模式自动恢复，避免因忘记重置配置导致的错误。\",\"优化效果总结:\",\"内存释放机制：通过retain_grad参数及时清除中间变量导数，避免内存长期占用。\",\"推理模式优化：禁用反向传播后，计算过程不保留计算图连接，适合无需梯度的场景（如模型预测）。\",\"工程实践：with no_grad()语法简洁，便于在训练和推理阶段灵活切换，提升代码可读性和鲁棒性。\"]},\"689\":{\"h\":\"步骤19: Variable 功能增强\",\"t\":[\"为了便于区分和调试，在Variable类中添加name属性，支持为变量设置自定义名称：\",\"class Variable: def __init__(self, data, name=None): if data is not None: if not isinstance(data, np.ndarray): raise TypeError(f'{type(data)} is not supported') self.data = data self.name = name # 新增名称属性 self.creator = None self.grad = None self.generation = 0\",\"使用示例：\",\"x = Variable(np.array(1.0), name='input_x') y = Variable(np.array(2.0), name='input_y')\",\"变量名称可在计算图可视化等场景中显示，提升调试效率。\",\"使Variable实例具备ndarray的行为特征，隐藏数据封装细节：\",\"添加shape、ndim、size、dtype属性:\",\"class Variable: @property def shape(self): return self.data.shape # 获取数据形状 @property def ndim(self): return self.data.ndim # 获取维度数 @property def size(self): return self.data.size # 获取元素总数 @property def dtype(self): return self.data.dtype # 获取数据类型\",\"示例验证：\",\"x = Variable(np.array([[1, 2, 3], [4, 5, 6]])) print(x.shape) # 输出：(2, 3) print(x.ndim) # 输出：2 print(x.size) # 输出：6 print(x.dtype) # 输出：int64\",\"变量实例可直接访问ndarray的核心属性，使用户无需关心data属性。\",\"实现__len__方法：\",\"class Variable: def __len__(self): return len(self.data) # 返回第1维度的元素数\",\"示例：\",\"x = Variable(np.array([1, 2, 3, 4])) print(len(x)) # 输出：4 y = Variable(np.array([[1, 2], [3, 4]])) print(len(y)) # 输出：2\",\"自定义打印格式：\",\" class Variable: def __repr__(self): if self.data is None: return 'variable(None)' data_str = str(self.data).replace('\\\\n', '\\\\n' + ' ' * 9) return f'variable({data_str})'\",\"输出效果：\",\"x = Variable(np.array([1, 2, 3])) print(x) # 输出：variable([1 2 3]) y = Variable(np.array([[1, 2], [3, 4]])) print(y) # 输出： # variable([[1 2] # [3 4]])\",\"打印时自动对齐多行数据，并标注“variable”前缀，便于识别变量类型。\",\"可继续添加ndarray的其他属性（如T转置、flat迭代器等），或实现__getitem__、__setitem__方法以支持数组索引，进一步强化变量的“透明箱子”特性。\"]},\"690\":{\"h\":\"步骤20–22: 运算符重载\",\"t\":[\"乘法运算的实现与运算符重载：\",\"在深度学习框架中，乘法运算是最基础的操作之一。为了让Variable实例支持自然的乘法表达式（如a * b），我们需要实现Mul类来处理正向传播和反向传播，并将其绑定到*运算符上。\",\"正向传播：计算两个输入变量的乘积，即y = x0 * x1。\",\"反向传播：根据导数公式，若y = x0 * x1，则，。因此，反向传播时需要将上游传来的梯度gy分别乘以x1和x0，传递给下游变量。\",\"class Mul(Function): def forward(self, x0, x1): y = x0 * x1 return y def backward(self, gy): x0, x1 = self.inputs[0].data, self.inputs[1].data return gy * x1, gy * x0 # 将梯度分别乘以x1和x0\",\"为了方便使用，我们将Mul类封装为Python函数mul，并通过Variable.__mul__和Variable.__rmul__绑定乘法运算符，使其支持左右操作数为Variable的情况。由于乘法满足交换律，__mul__和__rmul__可共用同一实现。\",\"def mul(x0, x1): x1 = as_array(x1) return Mul()(x0, x1) Variable.__mul__ = mul # 处理a * b Variable.__rmul__ = mul # 处理b * a\",\"加法运算的运算符重载:\",\"加法运算的Add类已在上文中实现，其反向传播逻辑为将上游梯度原封不动地传递给两个输入变量（因为，）。类似地，我们将Add类绑定到+运算符：\",\"def add(x0, x1): x1 = as_array(x1) return Add()(x0, x1) Variable.__add__ = add # 处理a + b Variable.__radd__ = add # 处理b + a\",\"复合运算的验证:\",\"通过组合加法和乘法运算符，我们可以验证框架是否支持复杂表达式的自动微分。例如，计算y = a * b + c并求导：\",\"a = Variable(np.array(3.0)) b = Variable(np.array(2.0)) c = Variable(np.array(1.0)) y = a * b + c # 等价于 add(mul(a, b), c) y.backward() print(y.data) # 输出：7.0（3*2+1） print(a.grad) # 输出：2.0（∂y/∂a = b） print(b.grad) # 输出：3.0（∂y/∂b = a） print(c.grad) # 输出：1.0（∂y/∂c = 1）\",\"此例中，反向传播正确计算了每个变量的梯度，证明运算符重载与自动微分机制的一致性。\",\"(可选部分) 在Python中，运算符重载需要同时考虑左右运算符（如__add__和__radd__），这是由Python的运算符调度机制决定的。当表达式中的左右操作数类型不同时，Python会根据操作数的类型选择不同的方法调用路径。Python中，运算符的调用顺序遵循以下规则：\",\"左操作数优先：当执行表达式a OP b时，Python首先尝试调用左操作数a的__OP__方法。\",\"右操作数 fallback：如果左操作数未实现__OP__方法，或返回NotImplemented，则尝试调用右操作数b的__rOP__方法。\",\"以加法a + b为例：\",\"首先调用a.__add__(b)；\",\"若a未实现__add__或返回NotImplemented，则调用b.__radd__(a)。\",\"当操作数类型不同时（如Variable与数值、ndarray混合运算），必须通过__rOP__处理右操作数为自定义类型的情况。例如：\",\"x + 3：左操作数x是Variable，调用x.__add__(3)，可正常转换3为Variable；\",\"3 + x：左操作数3是int，不具备__add__方法处理Variable，因此需调用x.__radd__(3)。\",\"在Python的运算符重载中，以def __add__(self, other)为例，self和other是两个关键入参:\",\"self：在表达式a + b中，self指代左操作数a，即调用__add__方法的实例。\",\"other：在表达式a + b中，other指代右操作数b，即调用__radd__方法的实例。\",\"在 Python 的运算符重载中，以def radd(self, other)为例，self和other是两个关键入参：\",\"在表达式a + b中，若左操作数a不支持__add__方法（或返回NotImplemented），则会调用右操作数b的__radd__方法。此时，self指代右操作数b，即调用__radd__方法的实例\",\"在__radd__方法中，other指代左操作数a，其类型可能是原生数值、ndarray或Variable。\",\"支持与ndarray及数值类型的混合运算:\",\"为了提升框架的易用性，我们需要让Variable实例能与NumPy数组（ndarray）、Python数值类型（如int、float）直接进行运算。关键在于实现类型转换工具函数as_variable，将非Variable对象转换为Variable实例：\",\"def as_variable(obj): if isinstance(obj, Variable): return obj return Variable(obj) # 将ndarray或数值转换为Variable\",\"同时，修改Function类的__call__方法，在接收输入时自动将参数转换为Variable：\",\"class Function: def __call__(self, *inputs): inputs = [as_variable(x) for x in inputs] # 统一转换为Variable xs = [x.data for x in inputs] # 后续计算逻辑...\",\"并且在所有重载运算符函数实现中，将other参数统一转换为ndarray：\",\"def add(self, other): other = as_array(other) return Add()(self, other) def as_array(x): if np.isscalar(x): return np.array(x) return x\",\"这样，当执行x + np.array(3.0)或x + 3.0时，右侧的ndarray或数值会被自动转换为Variable，确保运算正常进行。\",\"处理运算符的左右操作数差异:\",\"以乘法为例，当表达式为3.0 * x时，Python会调用x的__rmul__方法（右乘）。由于乘法满足交换律，__rmul__可复用__mul__的实现：\",\"Variable.__rmul__ = mul # 与__mul__共用逻辑，支持3.0 * x\",\"类似地，对于不满足交换律的运算符（如减法），需要分别处理左右操作数。例如，2.0 - x需要调用x的__rsub__方法，此时需交换操作数顺序并调用Sub类：\",\"def rsub(x0, x1): return Sub()(x1, x0) # 实现a - b = Sub(b, a) Variable.__rsub__ = rsub\",\"运算符优先级与类型转换:\",\"为了确保Variable实例在混合运算中优先被处理，我们为Variable类添加__array_priority__属性，设置其优先级高于ndarray（默认优先级为100）：\",\"class Variable: __array_priority__ = 200 # 高于ndarray的优先级，确保类型转换优先\",\"这使得当表达式为np.array([2.0]) + x时，x的__radd__方法会被优先调用，保证运算按预期执行。\",\"负数运算（-）的实现:\",\"负数运算y = -x的正向传播简单地对输入取反，反向传播时将上游梯度取反（因为）：\",\"class Neg(Function): def forward(self, x): return -x def backward(self, gy): return -gy # 梯度取反\",\"绑定-运算符到neg函数：\",\"def neg(x): return Neg()(x) Variable.__neg__ = neg # 支持y = -x\",\"减法运算（-）的完整实现:\",\"减法运算y = x0 - x1的反向传播中，，，因此反向传播时需将上游梯度gy分别乘以1和-1：\",\"class Sub(Function): def forward(self, x0, x1): return x0 - x1 def backward(self, gy): return gy, -gy # 梯度分别乘以1和-1\",\"由于减法不满足交换律，需分别实现__sub__（处理x0 - x1）和__rsub__（处理x1 - x0）：\",\"def sub(x0, x1): return Sub()(x0, x1) def rsub(x0, x1): return Sub()(x1, x0) # 交换操作数实现a - b Variable.__sub__ = sub # 支持x0 - x1 Variable.__rsub__ = rsub # 支持x1 - x0\",\"除法运算（/）的实现:\",\"除法运算y = x0 / x1的导数公式为，，反向传播时需按此计算梯度：\",\"class Div(Function): def forward(self, x0, x1): return x0 / x1 def backward(self, gy): x0, x1 = self.inputs[0].data, self.inputs[1].data gx0 = gy / x1 gx1 = -gy * x0 / (x1 ** 2) return gx0, gx1 # 按导数公式计算梯度\",\"同样，需处理左右操作数的除法运算：\",\"def div(x0, x1): return Div()(x0, x1) def rdiv(x0, x1): return Div()(x1, x0) # 交换操作数实现a / b Variable.__truediv__ = div # 支持x0 / x1 Variable.__rtruediv__ = rdiv # 支持x1 / x0\",\"幂运算（**）的实现:\",\"幂运算y = x ** c中，c为常数指数，其导数公式为。反向传播时需按此计算梯度：\",\"class Pow(Function): def __init__(self, c): self.c = c # 保存指数 def forward(self, x): return x ** self.c def backward(self, gy): x = self.inputs[0].data c = self.c gx = c * (x ** (c - 1)) * gy # 导数公式：c·x^(c-1)·gy return gx\",\"绑定**运算符到pow函数：\",\"def pow(x, c): return Pow(c)(x) Variable.__pow__ = pow # 支持x ** c\",\"通过步骤20-22的实现，TinyPytorch框架实现了完整的运算符重载体系，使开发者能以自然的数学表达式编写代码（如y = (x + 3) ** 2 / 2），而无需调用特定函数。这种“可微分编程”的方式不仅降低了学习成本，还确保了复杂表达式的自动微分正确性，为后续实现神经网络层和优化算法奠定了基础。\"]},\"691\":{\"h\":\"步骤23: 项目模块化结构\",\"t\":[\"在Python开发中，模块、包和库是组织代码的重要方式：\",\"模块（module）：单个Python文件，如core.py，用于封装功能。\",\"包（package）：多个模块的集合，以目录形式存在，需包含__init__.py文件。\",\"库（library）：多个包的集合，通常用于实现完整功能（如TinyPytorch框架）。\",\"为将 TinyPytorch 的代码组织为可复用的包，从本章开始为每个Chapter设计如下目录结构：\",\"__init__.py # 包初始化文件 core.py # 核心功能（简化版） functions.py # 具体函数实现 utils.py # 工具函数\",\"core.py，包括：\",\"类定义：Config、Variable、Function及运算符相关类（Add、Mul等）。\",\"函数定义：using_config、no_grad、as_array、as_variable等工具函数，以及add、mul等运算符函数。\",\"__init__.py中导入核心类并初始化运算符重载:\",\"from chapter2.core import Variable from chapter2.core import Function from chapter2.core import using_config from chapter2.core import no_grad from chapter2.core import as_array from chapter2.core import as_variable from chapter2.core import setup_variable setup_variable() # 初始化运算符重载\",\"其中，setup_variable()函数负责绑定运算符方法：\",\"def setup_variable(): Variable.__add__ = add Variable.__radd__ = add Variable.__mul__ = mul Variable.__rmul__ = mul # 其他运算符绑定...\"]},\"692\":{\"h\":\"步骤24：复杂函数的求导\",\"t\":[\"优化问题中常使用特定函数评估算法性能，这些函数被称为测试函数。通过对复杂测试函数求导，可验证TinyPytorch框架处理高阶微分的能力。本步骤选取3个经典测试函数，演示TinyPytorch的自动微分功能。\",\"Sphere函数求导\",\"函数定义：，是简单的平方和函数，用于验证基础微分逻辑。\",\"代码实现：\",\"def sphere(x, y): z = x ** 2 + y ** 2 return z x = Variable(np.array(1.0)) y = Variable(np.array(1.0)) z = sphere(x, y) z.backward() print(x.grad, y.grad) # 输出：2.0 2.0\",\"结果验证：根据导数公式 、，在 处导数为(2.0, 2.0)，与运行结果一致。\",\"Matyas函数求导\",\"函数定义：，是包含交叉项的二维函数。\",\"代码实现：\",\"def matyas(x, y): z = 0.26 * (x ** 2 + y ** 2) - 0.48 * x * y return z x = Variable(np.array(1.0)) y = Variable(np.array(1.0)) z = matyas(x, y) z.backward() print(x.grad, y.grad) # 输出：0.04 0.04（近似值）\",\"结果分析：通过运算符重载，可直接将数学表达式转译为代码。若不使用运算符，需编写繁琐的函数调用（如sub(mul(0.26, add(pow(x, 2), pow(y, 2))), mul(0.48, mul(x, y))），凸显运算符重载的可读性优势。\",\"Goldstein-Price函数求导\",\"函数定义：\",\"该函数形式复杂，包含高次项和交叉项，是验证框架能力的理想案例。\",\"代码实现：\",\"def goldstein(x, y): z = (1 + (x + y + 1)** 2 * (19 - 14*x + 3*x**2 - 14*y + 6*x*y + 3*y** 2)) * \\\\ (30 + (2*x - 3*y)** 2 * (18 - 32*x + 12*x**2 + 48*y - 36*x*y + 27*y** 2)) return z x = Variable(np.array(1.0)) y = Variable(np.array(1.0)) z = goldstein(x, y) z.backward() print(x.grad, y.grad) # 输出：-5376.0 8064.0\",\"结果验证：通过梯度检验可知结果正确。TinyPytorch框架能自动处理复杂表达式的微分，无需手动推导导数公式，体现了自动微分的优势。\",\"TinyPytorch的核心能力总结\",\"自然代码表达：支持将数学公式直接转译为Python代码，如z = (x + y + 1)**2 * ...，无需额外接口。\",\"复杂计算图处理：无论计算图结构多复杂（如多层嵌套、高次运算），均能正确构建反向传播路径。\",\"可微分编程：将普通数值计算转换为可微分计算，使深度学习框架具备自动求导能力，为优化算法和神经网络训练奠定基础。\",\"深度学习框架的计算图范式: TinyPytorch采用Define-by-Run（动态计算图） 模式，与Define-and-Run（静态计算图）的对比如下：\",\"Define-by-Run：计算与图构建同时进行，如TinyPytorch中每一步运算都会动态创建计算图链接，支持Python原生控制流（if、while），调试便捷。\",\"Define-and-Run：先定义计算图再执行，需使用领域特定语言（如TensorFlow 1.x的tf.cond），适合大规模优化但灵活性较低。\",\"TinyPytorch的动态计算图模式使其在易用性和灵活性上表现突出，尤其适合研究和快速开发场景。\"]},\"693\":{\"h\":\"第二阶段总结\",\"t\":[\"这一阶段，我们构建了如下关键功能：\",\"扩展DeZero以处理多输入多输出函数，支持用+、*等运算符自然表达计算。\",\"修改Function类，通过列表处理可变长参数，优化正向传播实现。\",\"实现多元函数反向传播，解决变量重复使用时的梯度累加问题。\",\"引入“辈分”机制，确保复杂计算图反向传播顺序正确。\",\"使用弱引用解决循环引用，通过Config类和no_grad模式优化内存管理。\",\"重载运算符，支持Variable与数值、数组混合运算，提升代码可读性。\",\"为Variable添加shape等属性，使其行为更接近NumPy数组，优化打印等交互体验。\"]},\"694\":{\"h\":\"🧠 从零构建深度学习框架（三）：动态图可视化与高阶导数构建\",\"t\":[\"1.TinyPytorch 第三阶段: 高阶导数与深度学习优化进阶\",\"仓库链接: https://github.com/BinaryOracle/TinyPytorch 本节代码:\"]},\"695\":{\"h\":\"引言：从自动微分走向“可视化 + 高阶导数 + 灵活控制”\",\"t\":[\"随着 TinyPytorch 框架核心功能的日益完善，我们开始迈入更深入也更贴近真实深度学习框架设计的阶段。在前一阶段，我们实现了自动构建计算图与反向传播的基本机制，使得模型训练具备了基础的“学习”能力。\",\"在第三阶段，我们将从第25步继续出发，围绕计算图可视化、高阶导数构建、动态图控制与框架灵活性展开一系列扩展与优化：\",\"引入 Graphviz 实现计算图的可视化渲染，帮助开发者直观理解前向与反向传播路径；\",\"实现 create_graph=True 支持高阶导数的构建；\",\"引入 sin、cos、tanh 等函数节点，扩展函数库并验证高阶导数；\",\"构建泰勒展开、牛顿法等经典函数逼近与优化示例；\",\"完善框架的模块结构，优化 Function 与 Variable 的内存管理与执行流程。\",\"通过这 10 个步骤，TinyPytorch 不仅具备了现代框架应有的可视化与控制能力，还能够处理更复杂的自动微分任务，为后续的神经网络模块与训练机制打下坚实基础。我们将看到，它不仅是“能跑起来”，而是真正朝着“易用、清晰、高效”的方向进化。\"]},\"696\":{\"h\":\"步骤25: 可视化计算图\",\"t\":[\"当前TinyPytorch已能将复杂式子转化为代码，但需直观呈现计算图全貌以辅助调试与理解。为此引入第三方工具Graphviz，其支持节点和箭头构成的数据结构可视化，可用于展示TinyPytorch计算图。\",\"macOS安装：通过Homebrew执行 brew install graphviz。\",\"Ubuntu安装：执行 sudo apt install graphviz。\",\"验证安装：运行 dot -V，若显示版本信息（如dot - graphviz version 2.40.1）则安装成功。\",\"文件转换命令：使用dot sample.dot -T png -o sample.png将DOT格式文件转换为PNG图像，其中-T指定输出格式，-o指定输出文件名。\",\"DOT语言基础语法:\",\"简单节点定义：定义包含节点x和y的有向图，节点间用换行分隔。\",\"digraph g { x y }\",\"节点属性设置：定义节点ID为1，标签为x，颜色橙色并填充；shape=box可将节点设为矩形。\",\"digraph g { 1 [label=\\\"x\\\", color=orange, style=filled] 2 [label=\\\"y\\\", color=orange, style=filled, shape=box] }\",\"节点连接：使用->表示箭头连接，如1->2表示从节点1到节点3的有向边。\",\"digraph g { 1 [label=\\\"x\\\", color=orange, style=filled] 2 [label=\\\"y\\\", color=orange, style=filled] 1 -> 2 }\",\"TinyPytorch计算图转换为DOT语言:\",\"import numpy as np from chapter3 import Variable from chapter3 import get_dot_graph x0 = Variable(np.array(1.0)) x1 = Variable(np.array(1.0)) y = x0 + x1 x0.name = 'x0' x1.name = 'x1' y.name = 'y' txt = get_dot_graph(y, verbose=False) print(txt) with open('sample.dot', 'w') as f: f.write(txt)\",\"代码将变量y的计算图转换为DOT语言字符串，并保存为文件。verbose参数控制是否显示详细信息。\",\"输出的DOT语言示例包含变量节点（橙色圆形）和函数节点（浅蓝色矩形），如：\",\"digraph g { 4847712112 [label=\\\"y\\\", color=orange, style=filled] 4847712064 [label=\\\"Add\\\", color=lightblue, style=filled, shape=box] 4775983056 -> 4847712064 4847711968 -> 4847712064 4847712064 -> 4847712112 4775983056 [label=\\\"x0\\\", color=orange, style=filled] 4847711968 [label=\\\"x1\\\", color=orange, style=filled] }\",\"转换后的图像展示x0 + x1的计算图，包含Add函数节点和变量连接。\",\"核心函数实现原理:\",\"_dot_var函数：生成变量节点的DOT描述，使用id(v)作为节点唯一ID，支持显示变量名、形状和数据类型：\",\"def _dot_var(v, verbose=False): dot_var = '{} [label=\\\"{}\\\", color=orange, style=filled]\\\\n' name = '' if v.name is None else v.name if verbose and v.data is not None: if v.name is not None: name += ': ' name += str(v.shape) + ' ' + str(v.dtype) return dot_var.format(id(v), name)\",\"示例输出：4423761088 [label=\\\"x: (2, 3) float64\\\", color=orange, style=filled]。\",\"_dot_func函数：生成函数节点的DOT描述，使用函数类名作为标签：\",\"def _dot_func(f): # for function dot_func = '{} [label=\\\"{}\\\", color=lightblue, style=filled, shape=box]\\\\n' ret = dot_func.format(id(f), f.__class__.__name__) # for edge dot_edge = '{} -> {}\\\\n' for x in f.inputs: ret += dot_edge.format(id(x), id(f)) for y in f.outputs: # y is weakref ret += dot_edge.format(id(f), id(y())) return ret\",\"示例输出：4423742632 [label=\\\"Add\\\", color=lightblue, style=filled, shape=box]。\",\"计算图遍历逻辑：与反向传播类似，从输出变量出发遍历所有节点（变量和函数），生成DOT语言字符串。通过seen_set避免重复处理节点，使用funcs.append(f)和funcs.pop()实现后序遍历。\",\"def get_dot_graph(output, verbose=True): txt = '' funcs = [] seen_set = set() def add_func(f): if f not in seen_set: funcs.append(f) # funcs.sort(key=lambda x: x.generation) seen_set.add(f) add_func(output.creator) txt += _dot_var(output, verbose) while funcs: func = funcs.pop() txt += _dot_func(func) for x in func.inputs: txt += _dot_var(x, verbose) if x.creator is not None: add_func(x.creator) return 'digraph g {\\\\n' + txt + '}'\",\"可视化工具封装:\",\"plot_dot_graph函数：自动执行DOT文件转换并显示图像，支持保存为PNG、PDF等格式：\",\"def plot_dot_graph(output, verbose=True, to_file='graph.png'): dot_graph = get_dot_graph(output, verbose) tmp_dir = os.path.join(os.path.expanduser('~'), '.dezero') if not os.path.exists(tmp_dir): os.mkdir(tmp_dir) graph_path = os.path.join(tmp_dir, 'tmp_graph.dot') with open(graph_path, 'w') as f: f.write(dot_graph) extension = os.path.splitext(to_file)[1][1:] # Extension(e.g. png, pdf) cmd = 'dot {} -T {} -o {}'.format(graph_path, extension, to_file) subprocess.run(cmd, shell=True) # Return the image as a Jupyter Image object, to be displayed in-line. try: from IPython import display return display.Image(filename=to_file) except: pass\",\"该函数自动调用系统命令转换文件，并支持在Jupyter Notebook中直接显示图像。\",\"复杂函数可视化示例: 以Goldstein-Price函数为例\",\"import numpy as np from chapter3 import plot_dot_graph, Variable def goldstein(x, y): z = (1 + (x + y + 1)**2 * (19 - 14*x + 3*x**2 - 14*y + 6*x*y + 3*y**2)) * \\\\ (30 + (2*x - 3*y)** 2 * (18 - 32*x + 12*x**2 + 48*y - 36*x*y + 27*y**2)) return z x = Variable(np.array(1.0)) y = Variable(np.array(1.0)) z = goldstein(x, y) z.backward() x.name = 'x' y.name = 'y' z.name = 'z' plot_dot_graph(z, to_file='goldstein.png')\",\"可视化结果显示复杂计算图，包含多层Pow、Mul、Add等操作节点，验证DeZero对复杂表达式的计算图构建能力。\"]},\"697\":{\"h\":\"步骤26: 寻找函数最优解\",\"t\":[\"本步骤将处理Rosenbrock函数，其式子为：\",\"该函数的形状如下图所示，若画出其“山”的等高线，会发现线的形状类似香蕉，因此Rosenbrock函数也被称为“香蕉函数”。\",\"本步骤的目标是找到使Rosenbrock函数输出值最小的和。已知Rosenbrock函数的最小值在处，接下来将使用TinyPytorch验证是否能找到该最小值。\",\"Rosenbrock函数的严格定义是，其中和是常数。上述例子是、时的Rosenbrock函数，该函数常作为优化问题的基准函数使用。\",\"首先求Rosenbrock函数在处的导数和，使用TinyPytorch实现的代码如下：\",\"import numpy as np from chapter3 import Variable def rosenbrock(x0, x1): y = 100 * (x1 - x0 ** 2) ** 2 + (x0 - 1) ** 2 return y x0 = Variable(np.array(0.0)) x1 = Variable(np.array(2.0)) y = rosenbrock(x0, x1) y.backward() print(x0.grad, x1.grad)\",\"运行结果为：\",\"-2.0 400.0\",\"这里将数值数据封装在Variable中，通过backward()方法求导。得到的导数为-2.0，导数为400.0。梯度展示了各点上函数输出值增加最快的方向，在点上，值增加最快的方向是(-2.0,400.0)，那么值减少最快的方向是(2.0,-400.0)。\",\"梯度下降法解决问题:\",\"对于形状复杂的函数，其最大值可能不在梯度指示方向，最小值也可能不在梯度反方向，但从局部看，梯度表示函数输出值最大的方向。重复向梯度方向移动一定距离，再求梯度，可逐渐接近目标位置，这就是梯度下降法。若从好的起点开始，使用梯度下降法能高效找到目标值。\",\"使用梯度下降法寻找Rosenbrock函数最小值的代码如下:\",\"x0 = Variable(np.array(0.0)) x1 = Variable(np.array(2.0)) lr = 0.001 iters = 1000 for i in range(iters): y = rosenbrock(x0, x1) x0.cleargrad() x1.cleargrad() y.backward() x0.data -= lr * x0.grad x1.data -= lr * x1.grad\",\"代码中，迭代次数设为iters（iters是iterations的缩写），与梯度相乘的值设为lr=0.001（lr是learning rate的缩写，即学习率）。\",\"由于for语句反复使用Variable实例x0和x1求导，而每次反向传播时导数会累加，所以在反向传播前需调用各变量的cleargrad方法重置导数。\",\"运行代码，从输出信息可看到(x0,x1)值的更新过程，部分结果如下：\",\"iter 992: x0 = 0.682166, x1 = 0.463833 iter 993: x0 = 0.682388, x1 = 0.464137 iter 994: x0 = 0.682609, x1 = 0.464440 iter 995: x0 = 0.682830, x1 = 0.464743 iter 996: x0 = 0.683051, x1 = 0.465046 iter 997: x0 = 0.683271, x1 = 0.465348 iter 998: x0 = 0.683492, x1 = 0.465651 iter 999: x0 = 0.683712, x1 = 0.465953\",\"将计算结果绘制在图上，如下图所示，从图中可看出逐渐接近星号所指的目的地位置，但尚未到达。\",\"增加迭代次数设为 iters =10000，结果如下图所示，此时离目的地更近，(x0,x1)的值为(0.99449622,0.98900063)。\",\"若再增加迭代次数到 iters =50000，就会抵达(1.0,1.0)。\",\"包含绘图的完整代码:\",\"import numpy as np from matplotlib import pyplot as plt from chapter3 import Variable def rosenbrock(x0, x1): y = 100 * (x1 - x0 ** 2) ** 2 + (x0 - 1) ** 2 return y x0 = Variable(np.array(0.0)) x1 = Variable(np.array(2.0)) lr = 0.001 iters = 50000 x0_list = [] x1_list = [] for i in range(iters): y = rosenbrock(x0, x1) x0.cleargrad() x1.cleargrad() y.backward() x0.data -= lr * x0.grad x1.data -= lr * x1.grad x0_list.append(x0.data.copy()) x1_list.append(x1.data.copy()) print('iter %d: x0 = %f, x1 = %f' % (i, x0.data, x1.data)) # 绘制等高线图 x = np.linspace(-2, 2, 400) y = np.linspace(-1, 3, 400) X, Y = np.meshgrid(x, y) Z = (1 - X)**2 + 100 * (Y - X**2)**2 plt.figure(figsize=(8, 6)) cp = plt.contour(X, Y, Z, levels=np.logspace(-1, 3, 30), cmap='jet') plt.plot(x0_list, x1_list, 'o-', color='yellow', markersize=2, label='Gradient Descent Path') # 在 (1.0, 1.0) 处标记最优点 plt.plot(1.0, 1.0, marker='*', markersize=12, color='red', label='Minimum (1,1)') plt.xlabel('x0') plt.ylabel('x1') plt.title('Gradient Descent on Rosenbrock Function') plt.legend() plt.grid(True) plt.show()\",\"本步骤使用TinyPytorch实现了梯度下降法，找到了Rosenbrock函数最小值的位置，不过迭代次数较多，有5万次。实际上梯度下降法并不擅长处理Rosenbrock这种类型的函数，下一个步骤会介绍并实现另一种优化方法。\"]},\"698\":{\"h\":\"步骤27: 高阶导数\"},\"699\":{\"h\":\"🏗️ 从零构建深度学习框架（四）：计算图进阶与通用神经网络实现\",\"t\":[\"4.TinyPytorch 第四阶段: 通用网络层封装与模型训练流程构建\",\"仓库链接: https://github.com/BinaryOracle/TinyPytorch 本节代码:\"]},\"700\":{\"h\":\"引言：从自动微分迈向可训练的神经网络模型\",\"t\":[\"前三阶段的 TinyPytorch，已实现自动微分系统与基础函数操作。在第四阶段，我们将真正迈入“深度学习框架”的核心部分——从简单函数组合进化到模块化神经网络，实现可复用的层（Layer）、模型（Model）、优化器（Optimizer）等，最终完成一个能训练分类任务的通用框架。\",\"本阶段的目标是打造一个“小而全”的深度学习训练系统。我们将实现：\",\"网络层封装（如 Linear、ReLU 等）\",\"模型类 Model 与训练流程规范\",\"参数管理与清理机制\",\"SGD 优化器与 momentum 拓展\",\"批处理、数据加载器与数据集支持\",\"实际任务训练（分类任务 + MNIST 手写数字）\",\"第四阶段共 14 个步骤，从第44步到第57步，形成了一个具备如下特征的微型深度学习框架：\"]},\"701\":{\"h\":\"TinyPytorch\"},\"702\":{\"h\":\"1.前置知识\",\"t\":[\"智慧化知识库系统: 大语言模型应用开发基础知识速览。\"]},\"703\":{\"h\":\"大语言模型\",\"t\":[\"大语言模型（LLM，Large Language Model），也称大型语言模型，是一种旨在理解和生成人类语言的人工智能模型。\",\"LLM 通常指包含数百亿（或更多）参数的语言模型，它们在海量的文本数据上进行训练，从而获得对语言深层次的理解。目前，国外的知名 LLM 有 GPT、LLaMA、Gemini、Claude 和 Grok 等，国内的有 DeepSeek、通义千问、豆包、Kimi、文心一言、GLM 等。\",\"为了探索性能的极限，许多研究人员开始训练越来越庞大的语言模型，例如拥有 175B (1750 亿)参数的 GPT-3 和 540B（5400 亿）参数的 PaLM 。尽管这些大型语言模型与小型语言模型（例如 3.3 亿参数的 BERT 和 15 亿参数的 GPT-2）使用相似的架构和预训练任务，但它们展现出截然不同的能力，尤其在解决复杂任务时表现出了惊人的潜力，这被称为“涌现能力”。以 GPT-3 和 GPT-2 为例，GPT-3 可以通过学习上下文来解决少样本任务，而 GPT-2 在这方面表现较差。因此，科研界给这些庞大的语言模型起了个名字，称之为“大语言模型（LLM）”。LLM 的一个杰出应用就是 ChatGPT ，它是 GPT 系列 LLM 用于与人类对话式应用的大胆尝试，展现出了非常流畅和自然的表现。 语言建模的研究可以追溯到 20 世纪 90 年代，当时的研究主要集中在采用统计学习方法来预测词汇，通过分析前面的词汇来预测下一个词汇。但在理解复杂语言规则方面存在一定局限性。\",\"随后，研究人员不断尝试改进，2003 年深度学习先驱 Bengio 在他的经典论文 《A Neural Probabilistic Language Model》中，首次将深度学习的思想融入到语言模型中。强大的神经网络模型，相当于为计算机提供了强大的\\\"大脑\\\"来理解语言，让模型可以更好地捕捉和理解语言中的复杂关系。\",\"2018 年左右，Transformer 架构的神经网络模型开始崭露头角。通过大量文本数据训练这些模型，使它们能够通过阅读大量文本来深入理解语言规则和模式，就像让计算机阅读 整个互联网一样，对语言有了更深刻的理解，极大地提升了模型在各种自然语言处理任务上的表现。\",\"与此同时，研究人员发现，随着语言模型规模的扩大（增加模型大小或使用更多数据），模型展现出了一些惊人的能力，在各种任务中的表现均显著提升（Scaling Law）。这一发现标志着大型语言模型（LLM）时代的开启。\",\"通常大模型由三个阶段构成：预训练、后训练和在线推理。在 2024 年 9 月之前，大模型领域仅存在预训练阶段的 Scaling Law。然而，随着 OpenAI o1 的推出，后训练和在线推理阶段也各自拥有了 Scaling Law，即后训练阶段的强化学习 Scaling Law（RL Scaling Law）和在线推理阶段的 Inference Scaling Law（Test Time Scaling Law）。 随着各阶段计算量的增加，大模型的性能不断增长。\"]},\"704\":{\"h\":\"常见的LLM\",\"t\":[\"大语言模型的发展历程虽然只有短短不到五年的时间，但是发展速度相当惊人，截止 2024 年 6 月，国内外有超过百种大模型相继发布。下图按照时间线给出了 2019 年至 2024 年 6 月比较有影响力并且模型参数量超过 100 亿的大语言模型：\",\"接下来我们主要介绍几个国内外常见的大模型（包括开源和闭源）。\",\"OpenAI\",\"OpenAI 公司在 2018 年 提出的 GPT（Generative Pre-Training） 模型是典型的 生成式预训练语言模型 之一。 GPT 模型的基本原则是通过语言建模将世界知识压缩到仅解码器 (decoder-only) 的 Transformer 模型中，这样它就可以恢复(或记忆)世界知识的语义，并充当通用任务求解器。它能够成功的两个关键点：\",\"训练能够准确预测下一个单词的 decoder-only 的 Transformer 语言模型\",\"扩展语言模型的大小\",\"OpenAI 在 LLM 上的研究大致可以分为以下几个阶段：\",\"目前，GPT 系列已形成 知识型 与 推理型 两大技术分支。\",\"2022 年 11 月，OpenAI 发布了基于 GPT 模型（GPT-3.5 和 GPT-4）的会话应用 ChatGPT。由于与人类交流的出色能力，ChatGPT 自发布以来就引发了人工智能社区的兴奋。ChatGPT 本质上是一个 LLM 应用，是基于基座模型开发出来的，与基座模型有本质的区别。ChatGPT 上线后用户增长迅速，5 天注册人数突破 100 万，两个月后月活用户破亿，成为当时史上用户增长最快的消费级应用程序。\",\"随着不断迭代，ChatGPT 逐渐丰富了其功能：\",\"插件系统：允许开发者创建工具扩展 ChatGPT 的能力，实现网页浏览、数据分析和第三方服务调用\",\"实时语音和视频对话：用户可与 AI 进行自然的语音和视频交流，支持手势识别和情感表达\",\"多模态能力：能够分析和理解用户提供的图片、音频和视频，实现全面的多模态交互\",\"自定义指令与记忆功能：记住用户之前的交互习惯和偏好，提供个性化体验\",\"GPT 构建器平台：允许用户无需编程创建专用的 AI 助手，支持自定义知识库和行为模式\",\"数据分析与可视化：直接处理和分析上传的数据文件，生成图表和可视化报告\",\"知识型与推理型双模式：可在 GPT-4.5 (知识型) 和 o1/o3 (推理型) 之间切换，满足不同场景需求\",\"思维链展示：在推理型模型中可选择性展示思考过程，帮助用户理解推理步骤\",\"2023 年 3 月 发布的 GPT-4 引入了多模态能力，相比 GPT-3.5 的 1750 亿参数，GPT-4 规模显著扩大（推测约 1.8 万亿参数），在解决复杂任务和评估任务上展现出较大的性能提升。\",\"2024 年 5 月 发布的 GPT-4o（\\\"o\\\"代表\\\"omni\\\"全能）具备对文本、语音、图像三种模态的深度理解能力，主要特点包括：\",\"多模态融合：无缝理解和生成多种形式内容\",\"实时对话：响应速度比 GPT-4 快约 2 倍\",\"情感表达：在语音互动中传递更丰富的情感变化\",\"成本效益：API 定价降低约 50%\",\"2024 年 7 月 发布的 GPT-4o mini 是一款面向消费级应用的轻量级模型，价格更加亲民，适合日常对话和基础任务场景。\",\"2025 年 2 月 发布的 GPT-4.5 在知识广度、推理深度和创意表达方面有显著提升，特别强化了对客观事实的准确性，尤其是情商方面异常优秀。上下文长度扩展至 512K。是 OpenAI 的最后一个非思维链模型。\",\"主流知识型模型对比:\",\"模型名称\",\"上下文长度\",\"特点\",\"知识截止日期\",\"GPT-4\",\"16k\",\"经济，专门对话\",\"2021 年 9 月\",\"GPT-4o\",\"128k\",\"多模态，速度快\",\"2023 年 10 月\",\"GPT-4.5\",\"128k\",\"最强知识型，精准度高\",\"2023 年 10 月\",\"GPT-4o mini\",\"128k\",\"轻量知识型，性价比高\",\"2023 年 10 月\",\"2024 年 9 月 发布的 o1-mini、o1-preview 是专为复杂推理设计的模型，在回答前会先生成一段思维链（不公开），优先考虑精确性和推理步骤的正确性。\",\"超强推理能力：在数学、编程和逻辑推理等任务中表现卓越。\",\"解题过程可靠：注重解题中间步骤的正确性。\",\"问题分解能力：将复杂问题分解为可管理的子问题。\",\"自纠错机制：识别错误并主动纠正。\",\"2024 年 12 月 发布的 o1 比 o1-preview 可以在更快的时间内响应，思考的时间更短。\",\"2025 年 1 月 发布的 o3-mini 可以显示部分思维链，与 o1 相比，可以保持效果的情况下，响应速度更快。\",\"模型名称\",\"上下文长度\",\"特点\",\"知识截止日期\",\"o1\",\"128k\",\"强推理能力，慢\",\"2023 年 10 月\",\"o1 mini\",\"200k\",\"轻量推理，中速\",\"2023 年 10 月\",\"o3 mini\",\"200k\",\"超轻量推理，最快\",\"2023 年 10 月\",\"OpenAI 的模型战略形成了“知识型”和“推理型”两条互补产品线：\",\"知识型模型 专注于广泛知识覆盖和流畅对话体验。\",\"推理型模型 专注于精确推理和复杂问题求解，让用户可根据具体需求选择最适合的模型类型。\",\"Claude\",\"Claude 系列模型是由 OpenAI 离职人员创建的 Anthropic 公司开发的闭源语言大模型。\",\"最早的 Claude 于 2023 年 3 月 15 日发布。\",\"2024 年 3 月 4 日，更新至 Claude-3，包括 Claude 3 Haiku、Claude 3 Sonnet 和 Claude 3 Opus，它们的能力依次递增，旨在满足不同用户和应用场景的需求。\",\"2024 年 10 月，Anthropic 发布了 Claude 3.5 Sonnet，这是一款在推理和通用任务上有显著提升的模型。\",\"2025 年 5 月，Anthropic 又进一步发布了 Claude 4.0，包括了 Claude 4 Sonnet 和 Claude 4 Opus，均是混合推理模型，支持标准模式与推理思考模式，编码能力异常强大。支持多工具并行调用与精准指令解析，本地文件访问时内存管理升级，可规避捷径行为，强化复杂任务处理能力。\",\"模型名称\",\"上下文长度\",\"特点\",\"Claude 3.5 Haiku\",\"200k\",\"速度最快\",\"Claude 4 Sonnet\",\"200k\",\"最强性能，领先推理力\",\"Claude 4 Opus\",\"200k\",\"性能强大，费用最高\",\"Gemini\",\"Gemini 系列语言大模型由 Google 开发。\",\"2022 年 4 月，发布了初始版本（PaLM 后更名为 Gemini）。\",\"2025 年 2 月，Google 发布了 Gemini 2.0 系列模型，在性能和效率上有显著提升。包括 Gemini 2.0 Pro、Gemini 2.0 Flash、Gemini 2.0 Flash-Lite 是 Gemini 2.0 系列的三个版本，分别适用于不同的场景。同样，推出了其推理模型 Gemini 2.0 Flash Thinking。\",\"2025 年 3 月，Google 发布了 Gemini 2.5 Pro，性能有了进一步提升，推理能力和代码能力提升非常显著。\",\"模型名称\",\"上下文长度\",\"特点\",\"Gemini 2.5 Pro\",\"2M\",\"性能最强\",\"Gemini 2.0 Flash\",\"1M\",\"低延迟，性能强\",\"Gemini 2.0 Flash-Lite\",\"1M\",\"性价比最高\",\"Gemini 2.0 Flash Thinking\",\"1M\",\"思维链展示\",\"文心一言\",\"文心一言是基于百度文心大模型的知识增强语言大模型，于 2023 年 3 月 在国内率先开启邀测。文心一言的基础模型文心大模型于 2019 年发布 1.0 版，现已更新到 4.0 版本。更进一步划分，文心大模型包括 NLP 大模型、CV 大模型、跨模态大模型、生物计算大模型、行业大模型。文心一言的中文能力相对来说非常不错。 文心一言网页版分为 免费版 和 专业版：\",\"免费版 使用文心 3.5 版本，已经能够满足个人用户或小型企业的大部分需求。\",\"专业版 使用文心 4.0 版本，定价为 59.9 元/月，连续包月优惠价为 49.9 元/月。\",\"星火大模型\",\"讯飞星火认知大模型是科大讯飞发布的语言大模型，支持多种自然语言处理任务。\",\"2023 年 5 月，首次发布。\",\"2024年 10 月，讯飞星火发布模型 星火 4.0 Turbo。\",\"2025 年 1 月，讯飞发布了推理思考模型 讯飞星火 X1 和 星火语音同传模型。\",\"LLaMA\",\"LLaMA 系列模型是 Meta 开源的一组参数规模从 8B 到 405B 的基础语言模型。\",\"2023 年 2 月，发布 LLaMA。\",\"2023 年 7 月，发布了 LLaMA2 模型。\",\"2024 年 4 月，发布了 LLaMA3 模型。\",\"2024 年 7 月，发布了 LLaMA 3.1 模型。\",\"2024 年 12 月，发布了 LLaMA 3.3 模型（只开源了 70B 的指令模型）。\",\"它们都是在数万亿个字符上训练的，展示了如何仅使用公开可用的数据集来训练最先进的模型，而不需要依赖专有或不可访问的数据集。这些数据集包括 Common Crawl、Wikipedia、OpenWebText2、RealNews、Books 等。LLaMA 模型使用了大规模的数据过滤和清洗技术，以提高数据质量和多样性，减少噪声和偏见。LLaMA 模型还使用了高效的数据并行和流水线并行技术，以加速模型的训练和扩展其中 405B 参数模型是首个公开的千亿级开源模型，性能对标 GPT-4o 等商业闭源模型。 与 GPT 系列相同，LLaMA 模型也采用了 decoder-only 架构，同时结合了一些前人工作的改进。LLaMA 系列基本上是后续大模型的标杆：\",\"Pre-normalization（正则化）：为了提高训练稳定性，LLaMA 对每个 Transformer 子层的输入进行了 RMSNorm 归一化，这种归一化方法可以避免梯度爆炸和消失的问题，提高模型的收敛速度和性能。\",\"SwiGLU（激活函数）：将 ReLU 非线性替换为 SwiGLU 激活函数，增加网络的表达能力和非线性，同时减少参数量和计算量。\",\"旋转位置编码（RoPE, Rotary Position Embedding）：模型的输入不再使用位置编码，而是在网络的每一层添加了位置编码，RoPE 位置编码可以有效地捕捉输入序列中的相对位置信息，并且具有更好的泛化能力。\",\"分组查询注意力（GQA, Grouped-Query Attention）：通过将查询（query）分组并在组内共享键（key）和值（value），减少了计算量，同时保持了模型性能，提高了大型模型的推理效率（LLaMA2 只有 70B 采用）。\",\"LLaMA 3.1 于 2024 年 7 月 发布，提高了模型的性能和效率：\",\"更多的训练数据量：LLaMA3.1 在 15 万亿个 token 的数据上进行预训练，采用了更科学的数据配比。LLaMA3.1 接触到更多的文本信息，从而提高了其理解和生成文本的能力。\",\"更长的上下文长度：LLaMA 3.1 将上下文长度大幅提升至 128K token，支持处理极长的文档和对话历史，改善了对长文本的理解和生成能力，适用于更复杂的应用场景。\",\"分组查询注意力（GQA, Grouped-Query Attention）：通过将查询（query）分组并在组内共享键（key）和值（value），减少了计算量，同时保持了模型性能，提高了大型模型的推理效率（LLaMA2 只有 70B 采用）。\",\"更大的词表：LLaMA3.1 采用了 128K 的 tokenizer，是前两代 32K 的 4 倍，这使得其语义编码能力得到了极大的增强，从而显著提升了模型的性能。\",\"精细的指令遵循：通过改进的对齐技术，LLaMA 3.1 在遵循复杂指令、理解微妙提示方面表现更出色，使模型行为更可预测和可控。\",\"完善的工具使用：增强了 Function Calling 能力，使模型能够更准确地识别何时以及如何调用外部工具，提高了与外部系统集成的能力。 LLaMA 3.1 发布了 8B、70B 和 405B 三个规模的模型，分别提供基础版（Base）和指令微调版（Instruction），进一步扩展了 LLaMA 系列在开源社区的影响力和应用前景。\",\"DeepSeek\",\"DeepSeek 是由深度求索 (DeepSeek) 团队开发的开源大语言模型系列。首个版本于 2023 年 11 月 发布。DeepSeek 采用 decoder-only 架构，融合了 FlashAttention-2、RoPE 位置编码、SwiGLU 等先进技术，在多语言理解和代码生成等方面表现出色。\",\"2023 年 11 月 12 日：发布 DeepSeek 系列基础模型，包括 7B 和 67B 两种规模的 Base 和 Chat 版本。模型在 1.2 万亿 token 上进行训练，同时发布了 DeepSeek-Coder 专用代码生成模型。\",\"2024 年 3 月 15 日：发布 DeepSeek-V2 系列，提升了多语言能力、长文本理解和推理能力，同时发布了 DeepSeek-MoE 混合专家模型。\",\"2024 年 5 月 31 日：发布 DeepSeek-V2.5，性能得到进一步提升，上下文长度扩展至 128K tokens，并改进了工具调用和多模态能力。\",\"2024 年 10 月：发布 DeepSeek-V3，在推理能力、多语言理解和创意生成方面有显著提升，支持更复杂的系统提示词控制，并进一步提升了代码质量和多轮对话一致性。\",\"2025 年 2 月：\",\"DeepSeek-R1 推理型大模型：专注于复杂问题求解和精确推理能力，在数学、逻辑推理和结构化知识方面展现出卓越性能，类似于 OpenAI 的 o1 系列。并且是首个开源的推理型大模型，在多项基准测试中超越了 o1 系列。\",\"DeepSeek-R1-Zero：直接在大规模强化学习 (RL) 训练的模型，无需 SFT，在推理方面就十分出色。\",\"同时开源了用 Llama 和 Qwen 从 DeepSeek-R1 中蒸馏出的六个 dense 模型。其中 DeepSeek-R1-Distill-Qwen-32B 在各种基准测试中均优于 OpenAI-o1-mini。\",\"deepseek 目前采用的主要改进如下：\",\"多头潜在注意力 (MLA, Multi-head Latent Attention)：通过将键值 (KV) 缓存显著压缩为潜在向量来保证高效推理的同时不降低效果。\",\"DeepSeekMoE：通过稀疏计算以经济的成本训练强大的模型。\",\"一系列推理加速技术 借助 DeepSeekR1 的卓越能力，DeepSeek 成为了现象级爆火应用。7 天完成了 1 亿用户的增长，打破了 ChatGPT 的 2 个月的最快记录，成为史上增长最快的 AI 应用。\",\"通义千问\",\"通义千问是由阿里巴巴基于“通义”大模型研发，于 2023 年 4 月 正式发布。\",\"2023 年 9 月：阿里云开源了 Qwen（通义千问）系列工作。\",\"2024 年 6 月 6 日：正式开源了 Qwen2。\",\"2025 年 4 月 29 日：发布了全新升级的 Qwen3 系列模型。\",\"Qwen 系列均采用 decoder-only 架构，并结合 SwiGLU 激活、RoPE、GQA 等技术。中文能力相对来说是非常不错的开源模型。 目前，已经开源了 7 种模型大小：\",\"Dense 模型：0.6B、1.7B、4B、8B、14B、32B；\",\"MoE 模型：30B-A3B、235B-A22B。\",\"上下文长度：\",\"8B 以下模型的上下文长度为 32k；\",\"8B 以上模型的上下文长度为 128k。\",\"Qwen3 进一步增强了模型性能，改进了推理能力和指令遵循能力，同时保持了低资源部署的高效性，使其在长文本理解和复杂任务处理方面具有更强的优势。支持思考模式和非思考模式之间无缝切换，覆盖 119 种语言和方言。强化了模型的代码能力、Agent 能力，以及对 MCP 的支持。 同时还开源了代码模型和数学模型：\",\"Qwen2.5-Coder：1.5B、7B，以及即将推出的 32B。\",\"Qwen2.5-Math：1.5B、7B，以及 72B。\",\"在推理大模型方面：\",\"2024 年 11 月：发布并开源了 QwQ-32B-Preview 模型，仅用 32B 参数便在部分达到了 o1-mini 的推理水平。\",\"2025 年 3 月：发布并开源了 QwQ-32B，其性能可与具备 671B 参数（37B 激活参数）的 DeepSeek-R1 媲美。\",\"ChatGLM\",\"GLM系列模型是 清华大学和智谱 AI 等合作研发的语言大模型。\",\"2023 年 3 月，发布了 ChatGLM。\",\"2024 年 1 月，发布了 GLM4，并于 2024 年 6 月 正式开源。\",\"GLM-4-9B-Chat 支持多轮对话的同时，还具备网页浏览、代码执行、自定义工具调用（Function Call）和长文本推理（支持最大 128K 上下文）等功能。 开源了 对话模型 GLM-4-9B-Chat、基础模型 GLM-4-9B、长文本对话模型 GLM-4-9B-Chat-1M（支持 1M 上下文长度）、多模态模型 GLM-4V-9B 等全面对标 OpenAI。\"]},\"705\":{\"h\":\"LLM 的特点与能力\",\"t\":[\"大语言模型具有多种显著特点，这些特点使它们在自然语言处理和其他领域中引起了广泛的兴趣和研究。以下是大语言模型的一些主要特点：\",\"巨大的规模： LLM 通常具有巨大的参数规模，可以达到数十亿甚至数千亿个参数。这使得它们能够捕捉更多的语言知识和复杂的语法结构。\",\"预训练和微调： LLM 采用了预训练和微调的学习方法。首先在大规模文本数据上进行预训练（无标签数据），学习通用的语言表示和知识。然后通过微调（有标签数据）适应特定任务，从而在各种NLP 任务中表现出色。\",\"上下文感知： LLM 在处理文本时具有强大的上下文感知能力，能够理解和生成依赖于前文的文本内容。这使得它们在对话、文章生成和情境理解方面表现出色。\",\"多语言支持： LLM 可以用于多种语言，不仅限于英语。它们的多语言能力使得跨文化和跨语言的应用变得更加容易。\",\"多模态支持： 一些 LLM 已经扩展到支持多模态数据，包括文本、图像和声音。使得它们可以理解和生成不同媒体类型的内容，实现更多样化的应用。\",\"伦理和风险问题： 尽管 LLM 具有出色的能力，但它们也引发了伦理和风险问题，包括生成有害内容、隐私问题、认知偏差等。因此，研究和应用 LLM 需要谨慎。\",\"高计算资源需求： LLM 参数规模庞大，需要大量的计算资源进行训练和推理。通常需要使用高性能的 GPU 或 TPU 集群来实现。 大语言模型是一种具有强大语言处理能力的技术，已经在多个领域展示了潜力。它们为自然语言理解和生成任务提供了强大的工具，同时也引发了对其伦理和风险问题的关注。这些特点使 LLM 成为了当今计算机科学和人工智能领域的重要研究和应用方向。\"]},\"706\":{\"h\":\"\",\"t\":[\"区分大语言模型（LLM）与以前的预训练语言模型（PLM）最显著的特征之一是它们的 涌现能力。涌现能力是一种令人惊讶的能力，它在小型模型中不明显，但在大型模型中特别突出。类似物理学中的相变现象，涌现能力就像是模型性能随着规模增大而迅速提升，超过了随机水平，也就是我们常说的 量变引起质变。 涌现能力可以与某些复杂任务有关，但我们更关注的是其通用能力。接下来，我们简要介绍三个 LLM 典型的涌现能力：\",\"上下文学习：上下文学习能力是由 GPT-3 首次引入的。这种能力允许语言模型在提供自然语言指令或多个任务示例的情况下，通过理解上下文并生成相应输出的方式来执行任务，而无需额外的训练或参数更新。\",\"指令遵循：通过使用自然语言描述的多任务数据进行微调，也就是所谓的 指令微调。LLM 被证明在使用指令形式化描述的未见过的任务上表现良好。这意味着 LLM 能够根据任务指令执行任务，而无需事先见过具体示例，展示了其强大的泛化能力。\",\"逐步推理：小型语言模型通常难以解决涉及多个推理步骤的复杂任务，例如数学问题。然而，LLM 通过采用 思维链（CoT, Chain of Thought） 推理策略，利用包含中间推理步骤的提示机制来解决这些任务，从而得出最终答案。据推测，这种能力可能是通过对代码的训练获得的。 这些涌现能力让 LLM 在处理各种任务时表现出色，使它们成为了解决复杂问题和应用于多领域的强大工具。\"]},\"707\":{\"h\":\"\",\"t\":[\"在 2021 年，斯坦福大学等多所高校的研究人员提出了基座模型（foundation model）的概念，清晰了预训练模型的作用。这是一种全新的 AI 技术范式，借助于海量无标注数据的训练，获得可以适用于大量下游任务的大模型（单模态或者多模态）。这样，多个应用可以只依赖于一个或少数几个大模型进行统一建设。 大语言模型是这个新模式的典型例子，使用统一的大模型可以极大地提高研发效率。相比于每次开发单个模型的方式，这是一项本质上的进步。大型模型不仅可以缩短每个具体应用的开发周期，减少所需人力投入，也可以基于大模型的推理、常识和写作能力，获得更好的应用效果。因此，大模型可以成为 AI 应用开发的大一统基座模型，这是一个一举多得、全新的范式，值得大力推广。\"]},\"708\":{\"h\":\"\",\"t\":[\"让大语言模型真正火爆的契机，是基于对话聊天的 ChatGPT。业界很早就发现了用户对于对话交互的特殊偏好，陆奇在微软期间，就于 2016 年推进过“对话即平台（conversation as a platform）” 的战略。此外，苹果 Siri 、亚马逊 Echo 等基于语音对话的产品也非常受欢迎，反映出互联网用户对于聊天和对话这种交互模式的偏好。虽然之前的聊天机器人存在各种问题，但大型语言模型的出现再次让聊天机器人这种交互模式可以重新涌现。用户愈发期待像钢铁侠中“贾维斯”一样的人工智能，无所不能、无所不知。这引发我们对于 智能体（Agent） 类型应用前景的思考，Auto-GPT、微软 Jarvis 等项目已经出现并受到关注，相信未来会涌现出很多类似的以对话形态让助手完成各种具体工作的项目。\",\"LLM 已经在许多领域产生了深远的影响。在自然语言处理领域，它可以帮助计算机更好地理解和生成文本，包括写文章、回答问题、翻译语言等。在信息检索领域，它可以改进搜索引擎，让我们更轻松地找到所需的信息。在计算机视觉领域，研究人员还在努力让计算机理解图像和文字，以改善多媒体交互。 最重要的是，LLM 的出现让人们重新思考了 通用人工智能（AGI） 的可能性。AGI 是一种像人类一样思考和学习的人工智能。LLM 被认为是 AGI 的一种早期形式，这引发了对未来人工智能发展的许多思考和计划。\",\"总之，LLM 是一种令人兴奋的技术，它让计算机更好地理解和使用语言，正在改变着我们与技术互动的方式，同时也引发了对未来人工智能的无限探索。\"]},\"709\":{\"h\":\"检索增强生成（RAG, Retrieval-Augmented Generation）\",\"t\":[\"大型语言模型（LLM）相较于传统的语言模型具有更强大的能力，然而在某些情况下，它们仍可能无法提供准确的答案。为了解决大型语言模型在生成文本时面临的一系列挑战，提高模型的性能和输出质量，研究人员提出了一种新的模型架构：检索增强生成（RAG, Retrieval-Augmented Generation）。该架构巧妙地整合了从庞大知识库中检索到的相关信息，并以此为基础，指导大型语言模型生成更为精准的答案，从而显著提升了回答的准确性与深度。 目前 LLM 面临的主要问题有：\",\"信息偏差/幻觉： LLM 有时会产生与客观事实不符的信息，导致用户接收到的信息不准确。RAG 通过检索数据源，辅助模型生成过程，确保输出内容的精确性和可信度，减少信息偏差。\",\"知识更新滞后性： LLM 基于静态的数据集训练，这可能导致模型的知识更新滞后，无法及时反映最新的信息动态。RAG 通过实时检索最新数据，保持内容的时效性，确保信息的持续更新和准确性。\",\"内容不可追溯： LLM 生成的内容往往缺乏明确的信息来源，影响内容的可信度。RAG 将生成内容与检索到的原始资料建立链接，增强了内容的可追溯性，从而提升了用户对生成内容的信任度。\",\"领域专业知识能力欠缺： LLM 在处理特定领域的专业知识时，效果可能不太理想，这可能会影响到其在相关领域的回答质量。RAG 通过检索特定领域的相关文档，为模型提供丰富的上下文信息，从而提升了在专业领域内的问题回答质量和深度。\",\"推理能力限制： 面对复杂问题时，LLM 可能缺乏必要的推理能力，这影响了其对问题的理解和回答。RAG 结合检索到的信息和模型的生成能力，通过提供额外的背景知识和数据支持，增强了模型的推理和理解能力。\",\"应用场景适应性受限： LLM 需在多样化的应用场景中保持高效和准确，但单一模型可能难以全面适应所有场景。RAG 使得 LLM 能够通过检索对应应用场景数据的方式，灵活适应问答系统、推荐系统等多种应用场景。\",\"长文本处理能力较弱： LLM 在理解和生成长篇内容时受限于有限的上下文窗口，且必须按顺序处理内容，输入越长，速度越慢。RAG 通过检索和整合长文本信息，强化了模型对长上下文的理解和生成，有效突破了输入长度的限制，同时降低了调用成本，并提升了整体的处理效率。\"]},\"710\":{\"h\":\"工作流程\",\"t\":[\"RAG 是一个完整的系统，其工作流程可以简单地分为数据处理、检索、增强和生成四个阶段：\",\"数据处理阶段: 对原始数据进行清洗和处理; 将处理后的数据转化为检索模型可以使用的格式; 将处理后的数据存储在对应的数据库中。\",\"检索阶段: 将用户的问题输入到检索系统中，从数据库中检索相关信息。\",\"增强阶段: 对检索到的信息进行处理和增强，以便生成模型可以更好地理解和使用。\",\"生成阶段: 将增强后的信息输入到生成模型中，生成模型根据这些信息生成答案。\"]},\"711\":{\"h\":\"RAG VS Finetune\",\"t\":[\"在提升大语言模型效果中，RAG 和 微调（Finetune）是两种主流的方法。\",\"微调: 通过在特定数据集上进一步训练大语言模型，来提升模型在特定任务上的表现。\",\"RAG 和 微调的对比可以参考下表 :\",\"特征比较\",\"RAG\",\"微调\",\"知识更新\",\"直接更新检索知识库，无需重新训练。信息更新成本低，适合动态变化的数据。\",\"通常需要重新训练来保持知识和数据的更新。更新成本高，适合相对稳定的数据。\",\"数据处理\",\"对数据的处理和操作要求极低。\",\"依赖于构建高质量的数据集，有限的数据集可能无法显著提高性能。\",\"模型定制\",\"侧重于信息检索和融合外部知识，但可能无法充分定制模型行为或写作风格。\",\"可以根据特定风格或术语调整 LLM 行为、写作风格或特定领域知识。\",\"可解释性\",\"可以追溯到具体的数据来源，有较好的可解释性和可追踪性。\",\"黑盒子，可解释性相对较低。\",\"特征比较\",\"RAG\",\"微调\",\"计算资源\",\"需要额外的资源来支持检索机制和数据库的维护。\",\"依赖高质量的训练数\",\"推理延迟\",\"增加了检索步骤的耗时\",\"单纯 LLM 生成的耗时\",\"降低幻觉\",\"通过检索到的真实信息生成回答，降低了产生幻觉的概率。\",\"模型学习特定领域的数据有助于减少幻觉，但面对未见过的输入时仍可能出现幻觉。\",\"伦理隐私\",\"检索和使用外部数据可能引发伦理和隐私方面的问题。\",\"训练数据中的敏感信息需要妥善处理，以防泄露。\"]},\"712\":{\"h\":\"LangChain\",\"t\":[\"ChatGPT 的巨大成功激发了越来越多的开发者兴趣，他们希望利用 OpenAI 提供的 API 或者私有化模型，来开发基于大型语言模型的应用程序。尽管大型语言模型的调用相对简单，但要创建完整的应用程序，仍然需要大量的定制开发工作，包括 API 集成、互动逻辑、数据存储等等。\",\"为了解决这个问题，从 2022 年开始，许多机构和个人相继推出了多个开源项目，旨在帮助开发者们快速构建基于大型语言模型的端到端应用程序或工作流程。其中一个备受关注的项目就是 LangChain 框架。\",\"LangChain 框架是一个开源工具，充分利用了大型语言模型的强大能力，以便开发各种下游应用。它的目标是为各种大型语言模型应用提供通用接口，从而简化应用程序的开发流程。具体来说，LangChain 框架可以实现数据感知和环境互动，也就是说，它能够让语言模型与其他数据来源连接，并且允许语言模型与其所处的环境进行互动。\",\"利用 LangChain 框架，我们可以轻松地构建如下所示的 RAG 应用。在下图中，每个椭圆形代表了 LangChain 的一个模块，例如数据收集模块或预处理模块。每个矩形代表了一个数据状态，例如原始数据或预处理后的数据。箭头表示数据流的方向，从一个模块流向另一个模块。在每一步中，LangChain 都可以提供对应的解决方案，帮助我们处理各种任务。\"]},\"713\":{\"h\":\"核心组件\",\"t\":[\"LangChian 作为一个大语言模型开发框架，可以将 LLM 模型（对话模型、embedding 模型等）、向量数据库、交互层 Prompt、外部知识、外部代理工具整合到一起，进而可以自由构建 LLM 应用。 LangChain 主要由以下 6 个核心组件组成:\",\"模型输入/输出（Model I/O）：与语言模型交互的接口\",\"数据连接（Data connection）：与特定应用程序的数据进行交互的接口\",\"链（Chains）：将组件组合实现端到端应用。比如后续我们会将搭建检索问答链来完成检索问答。\",\"记忆（Memory）：用于链的多次运行之间持久化应用程序状态；\",\"代理（Agents）：扩展模型的推理能力。用于复杂的应用的调用序列；\",\"回调（Callbacks）：扩展模型的推理能力。用于复杂的应用的调用序列；\",\"在开发过程中，我们可以根据自身需求灵活地进行组合。\"]},\"714\":{\"h\":\"版本迭代\",\"t\":[\"在 LLM 技术领域的迅猛发展浪潮中，LangChain 作为一个不断进化的创新平台，持续推动着技术边界的拓展。2024 年 9 月 16 日，LangChain 正式发布了其稳定版本 v0.3，这一里程碑式的更新，为开发者带来了全面而强大的功能支持。其涵盖了模型的输入与输出处理、数据连接、链式操作、记忆机制、代理服务以及回调处理等关键组件，为 LLM 应用的开发和部署提供了坚实的基础。 同时，LangChain 的持续优化和功能迭代，未来将带来更多创新特性和性能提升。\",\"兼容性与支持：LangChain 兼顾了对 Python 和 JavaScript 的支持，同时保持了向后兼容性，确保开发者能够在升级过程中无缝过渡，享受到更加安全稳定的开发体验。\",\"架构改进：通过将核心组件 langchain-core 与合作伙伴包进行有效分离，LangChain 的架构设计变得更加条理清晰和稳固，为未来的系统化扩展和安全性提升奠定了坚实基础。\",\"可观察性：LangChain 通过与 LangSmith 的深度集成，提供了业界领先的调试和观测功能。这使得开发者能够对 LLM 应用中的每一步操作及其输入输出有一个清晰的认识，极大地简化了调试和问题排查的流程。\",\"广泛的集成：LangChain 拥有近 700 个集成，覆盖了从 LLM 到向量存储、工具和智能体（Agent）等多个技术领域，极大地降低了在各种技术栈上构建 LLM 应用的复杂度。\",\"可组合性：借助 LangChain 表达式语言（LCEL），开发者可以轻松地构建和定制 chain，充分利用数据编排框架的优势，包括批量处理、并行化操作和备选方案等高级功能。\",\"流式处理：LangChain 对流式处理进行了深度优化，确保所有利用 LCEL 创建的 chain 均能支持流式处理，包括中间步骤的数据流传输，从而为用户提供更加流畅的体验。\",\"输出解析：LangChain 提供了一系列强大的输出解析工具，确保 LLM 能够以结构化的格式返回信息，这对于 LLM 执行具体行动计划至关重要。\",\"检索能力：LangChain 引入了先进的检索技术，适用于生产环境，包括文本分割、检索机制和索引管道等，使得开发者能够轻松地将私有数据与 LLM 的能力相结合。\",\"工具使用与智能体：LangChain 提供了丰富的智能体和工具集合，并提供了定义工具的简便方法，支持智能体工作负载，包括让 LLM 调用函数或工具，以及如何高效地进行多次调用和推理，极大地提升了开发效率和应用性能。\"]},\"715\":{\"h\":\"生态圈\",\"t\":[\"LangChain Community: 专注于第三方集成，极大地丰富了 LangChain 的生态系统，使得开发者可以更容易地构建复杂和强大的应用程序，同时也促进了社区的合作和共享。\",\"LangChain Core: LangChain 框架的核心库、核心组件，提供了基础抽象和 LangChain 表达式语言（LCEL），提供基础架构和工具，用于构建、运行和与 LLM 交互的应用程序，为 LangChain 应用程序的开发提供了坚实的基础。我们后续会用到的处理文档、格式化 prompt、输出解析等都来自这个库。\",\"LangChain CLI: 命令行工具，使开发者能够通过终端与 LangChain 框架交互，执行项目初始化、测试、部署等任务。提高开发效率，让开发者能够通过简单的命令来管理整个应用程序的生命周期。\",\"LangServe: 部署服务，用于将 LangChain 应用程序部署到云端，提供可扩展、高可用的托管解决方案，并带有监控和日志功能。简化部署流程，让开发者可以专注于应用程序的开发，而不必担心底层的基础设施和运维工作。\",\"LangSmith: 开发者平台，专注于 LangChain 应用程序的开发、调试和测试，提供可视化界面和性能分析工具，旨在帮助开发者提高应用程序的质量，确保它们在部署前达到预期的性能和稳定性标准。\"]},\"716\":{\"h\":\"大模型开发\",\"t\":[\"我们将开发以大语言模型为功能核心、通过大语言模型的强大理解能力和生成能力、结合特殊的数据或业务逻辑来提供独特功能的应用称为大模型开发。开发大模型相关应用，其技术核心点虽然在大语言模型上，但一般通过调用 API 或开源模型来实现核心的理解与生成，通过 Prompt Enginnering 来实现大语言模型的控制，因此，虽然大模型是深度学习领域的集大成之作，大模型开发却更多是一个工程问题。\",\"在大模型开发中，我们一般不会去大幅度改动模型，而是将大模型作为一个调用工具，通过 Prompt Engineering、数据工程、业务逻辑分解等手段来充分发挥大模型能力，适配应用任务，而不会将精力聚焦在优化模型本身上。因此，作为大模型开发的初学者，我们并不需要深研大模型内部原理，而更需要掌握使用大模型的实践技巧。\",\"# 大语言模型 ## Prompt Engineering ## 数据工程 ## 业务逻辑分解 ## 验证迭代优化\",\"同时，以调用、发挥大模型为核心的大模型开发与传统的 AI 开发在整体思路上有着较大的不同。大语言模型的两个核心能力：指令遵循与文本生成提供了复杂业务逻辑的简单平替方案。\",\"传统的 AI 开发：首先需要将非常复杂的业务逻辑依次拆解，对于每一个子业务构造训练数据与验证数据，对于每一个子业务训练优化模型，最后形成完整的模型链路来解决整个业务逻辑。\",\"大模型开发：用 Prompt Engineering 来替代子模型的训练调优，通过 Prompt 链路组合来实现业务逻辑，用一个通用大模型 + 若干业务 Prompt 来解决任务，从而将传统的模型训练调优转变成了更简单、轻松、低成本的 Prompt 设计调优。\",\"同时，在评估思路上，大模型开发与传统 AI 开发也有质的差异。\",\"传统 AI 开发：需要首先构造训练集、测试集、验证集，通过在训练集上训练模型、在测试集上调优模型、在验证集上最终验证模型效果来实现性能的评估。\",\"大模型开发：流程更为灵活和敏捷。从实际业务需求出发构造小批量验证集，设计合理 Prompt 来满足验证集效果。然后，将不断从业务逻辑中收集当下 Prompt 的 Bad Case，并将 Bad Case 加入到验证集中，针对性优化 Prompt，最后实现较好的泛化效果。\"]},\"717\":{\"h\":\"基本流程\",\"t\":[\"结合上述分析，我们一般可以将大模型开发分解为以下几个流程：\",\"确定目标: 在进行开发前，我们首先需要确定开发的目标，即要开发的应用的应用场景、目标人群、核心价值。对于个体开发者或小型开发团队而言，一般应先设定最小化目标，从构建一个 MVP（最小可行性产品）开始，逐步进行完善和优化。\",\"设计功能: 在确定开发目标后，需要设计本应用所要提供的功能，以及每一个功能的大体实现逻辑。虽然我们通过使用大模型来简化了业务逻辑的拆解，但是越清晰、深入的业务逻辑理解往往也能带来更好的 Prompt 效果。同样，对于个体开发者或小型开发团队来说，首先要确定应用的核心功能，然后延展设计核心功能的上下游功能；\",\"搭建整体架构: 目前，绝大部分大模型应用都是采用的特定数据库 + Prompt + 通用大模型的架构。我们需要针对我们所设计的功能，搭建项目的整体架构，实现从用户输入到应用输出的全流程贯通。一般来说，我们推荐基于 LangChain 框架进行开发。LangChain 提供了 Chain、Tool 等架构的实现，我们可以基于 LangChain 进行个性化定制，实现从用户输入到数据库再到大模型最后输出的整体架构连接。\",\"搭建数据库: 个性化大模型应用需要有个性化数据库进行支撑。由于大模型应用需要进行向量语义检索，一般使用诸如 Chroma 的向量数据库。在该步骤中，我们需要收集数据并进行预处理，再向量化存储到数据库中。数据预处理一般包括从多种格式向纯文本的转化，例如 PDF、MarkDown、HTML、音视频等，以及对错误数据、异常数据、脏数据进行清洗。完成预处理后，需要进行切片、向量化构建出个性化数据库。\",\"Prompt Engineering: 优质的 Prompt 对大模型能力具有极大影响，我们需要逐步迭代构建优质的 Prompt Engineering 来提升应用性能。在该步中，我们首先应该明确 Prompt 设计的一般原则及技巧，构建出一个来源于实际业务的小型验证集，基于小型验证集设计满足基本要求、具备基本能力的 Prompt。\",\"验证迭代: 验证迭代在大模型开发中是极其重要的一步，一般指通过不断发现 Bad Case 并针对性改进 Prompt Engineering 来提升系统效果、应对边界情况。在完成上一步的初始化 Prompt 设计后，我们应该进行实际业务测试，探讨边界情况，找到 Bad Case，并针对性分析 Prompt 存在的问题，从而不断迭代优化，直到达到一个较为稳定、可以基本实现目标的 Prompt 版本。\",\"前后端搭建: 完成 Prompt Engineering 及其迭代优化之后，我们就完成了应用的核心功能，可以充分发挥大语言模型的强大能力。接下来我们需要搭建前后端，设计产品页面，让我们的应用能够上线成为产品。\",\"体验优化: 在完成前后端搭建之后，应用就可以上线体验了。接下来就需要进行长期的用户体验跟踪，记录 Bad Case 与用户负反馈，再针对性进行优化即可。\"]},\"718\":{\"h\":\"参考\",\"t\":[\"LLM 部分:\",\"A Survey of Large Language Models\",\"周枫：当我们谈论大模型时，应该关注哪些新能力？\",\"S型智能增长曲线：从Deepseek R1看Scaling Law的未来\",\"一文详尽之Scaling Law！\",\"QwQ: 思忖未知之界\",\"QwQ-32B: 领略强化学习之力\",\"RAG 部分:\",\"Retrieval-Augmented Generation for Large Language Models: A Survey\",\"面向大语言模型的检索增强生成技术：综述\"]},\"719\":{\"h\":\"2.大模型API使用\",\"t\":[\"智慧化知识库系统: LLM API的调用。\"]},\"720\":{\"h\":\"智慧化知识库系统\"},\"721\":{\"h\":\"AI Agent\"},\"722\":{\"h\":\"在线学习\"},\"723\":{\"h\":\"强化学习\"},\"724\":{\"h\":\"概率论基础知识\"},\"725\":{\"h\":\"概率论基础概念\",\"t\":[\"概率论基础概念(用到多少，学多少 =_=)\"]},\"726\":{\"h\":\"概率空间\",\"t\":[\"我们将概率空间定义为三元组 ，其中：\",\" 是样本空间，表示实验中所有可能的结果组成的集合；\",\" 是事件空间，即 的所有子集的集合；\",\" 是概率度量，是一个从事件 到 区间数值的映射（即 ），满足某些一致性要求。\"]},\"727\":{\"h\":\"离散随机变量\",\"t\":[\"最简单的情况是实验的结果是可数的。例如，掷一个三面骰子，其三个面分别标记为 “A”、“B”、“C”（为了简洁，我们用3面而不是6面）。此时：\",\"样本空间为 ，表示所有可能的实验结果；\",\"事件空间为 。\",\"其中每一个事件就是事件空间中的一个元素。例如：\",\"事件 表示骰子掷出面为 A 或 B；\",\"事件 表示骰子掷出面为 C。\",\"定义事件空间后，需要指定概率度量 ，即为事件空间中的每个集合赋予一个“权重”或“大小”。例如，设：\",\"，\",\"，\",\"。\",\"则复合事件的概率可通过求和得到，例如：\",\"。\",\"为简化记号，我们可以将每个样本空间中的结果映射为一个实数，这就定义了随机变量（random variable，记作 rv）：\",\"随机变量 = 一个把“事件结果”映射为“数值”的函数，它本身不随机，随机的是它作用的输入（样本 ）。\",\"，将每个结果 映射为实数 。\",\"例如，对三面骰子设：\",\"，\",\"，\",\"。\",\"再如，掷两次公平硬币，样本空间为：\",\"。\",\"设随机变量 表示“正面出现次数”，则：\",\"，\",\"，\",\"，\",\"。\",\"我们将随机变量可能的取值集合称为其状态空间，记作 。给定某个状态 ，定义：\",\"其中 ，称为 的原像。\",\"你有一个随机变量 ，它是一个函数，从样本空间 映射到实数；给定某个输出值 ，我们关心的是：随机变量等于这个值的概率是多少，即 。 但是：随机变量是函数，它本身不“随机”，真正随机的是实验结果 。所以，要知道“”的概率是多少，其实等价于问：\",\"有多少个 会导致 ，而这些 的总概率是多少？\",\"所以，我们这么定义：\",\"：是所有让 成立的样本点集合（这就是“原像”）；\",\"然后，：就是计算这些 的总概率。\",\"实验：投两次硬币\",\"定义随机变量 ：表示正面（H）的次数\",\"现在我们问：\",\"这等价于找出：\",\"哪些 会导致 ？\",\"答案是 \",\"如果每个 的概率都是 ，那么：\",\"这里， 称为概率质量函数（pmf，probability mass function）。继续上述例子，掷两次硬币的 pmf 为：\",\"，\",\"，\",\"。\",\"pmf 可用柱状图表示，也可用参数化函数表示。我们称 为随机变量 的概率分布。在上下文明确的情况下，常省略下标 。\",\"随机变量 把世界事件映射成数字；pmf 把这些数字映射成它们发生的概率。\"]},\"728\":{\"h\":\"连续随机变量\",\"t\":[\"我们也可以考虑结果为连续值的实验。这种情况下，假设样本空间是实数集合的子集：，并定义随机变量为恒等函数 。\",\"例如，测量某事件持续时间（单位：秒），设：\",\"。\",\"由于该集合是不可数的，无法像离散情形那样枚举所有子集。因此，我们需要借助Borel σ-代数（Borel sigma-field）来定义事件空间。其定义如下：\",\"集合 是一个 σ-代数（sigma-field）当且仅当：\",\"，且 ；\",\"若 ，则其补集 ；\",\"若 ，则 与 也属于 。\",\"Borel σ-代数是由半开区间 生成的最小 σ-代数。通过这些区间的并、交和补运算，我们可以得到：\",\"当我们讨论连续型随机变量（比如测量一个时间、距离或温度）时，它的样本空间是连续的，比如：\",\"在这种连续的空间里，所有可能的“事件”不是像离散情况那样简单地枚举出来的（比如 ），而可能是“无限多种可能的区间组合”。 比如我们可能想表示这些事件：\",\"“温度在 1 到 2 度之间” → 区间 (1, 2)\",\"“时间小于 5 秒” → 区间 \",\"“温度是 3 度或 7 度” → \",\"“测量值是无理数” → 这也算是一类事件！\",\"但是问题是：我们不能对“所有”这样的集合都定义概率！ 因为某些集合太“奇怪”或太“复杂”，会导致概率的定义出现矛盾或不收敛。 所以我们需要一个规则体系来规定“我们只对哪些集合定义概率” ——> 这个规则体系就是σ-代数（sigma-field）。\",\"σ-代数是一个集合的集合（简单理解：是你允许讨论的事件的全集合），它必须满足以下三条规则（你可以把它们理解成“合理事件空间”的要求）：\",\"包含整个样本空间和空集\",\"你总得允许“什么都不发生”（空事件）\",\"也得允许“一定会发生”（整个样本空间）\",\"如果你能谈某个事件，那它的补集你也得能谈\",\"比如：“温度小于 30 度” 这个事件存在，那“温度不小于 30 度”这个事件也应该存在\",\"如果你能谈一堆事件，那它们的并集和交集也得能谈\",\"比如你能谈“温度在 (0,1)”、“温度在 (1,2)”……，那“温度在 (0,2)”这种组合你也得能谈\",\"换句话说：σ-代数就是一种封闭的事件系统，允许你用基本事件构造更复杂事件，但不会跑出系统之外。 Borel σ-代数是专门为实数空间（）设计的一种 σ-代数，用来处理实数范围内的“正常”区间事件。 它的定义是：Borel σ-代数是由所有形如 的区间生成的最小 σ-代数。 也就是说，它从一些基本的“区间事件”出发，通过反复地做并集、交集、补集操作，构造出你所需要的所有“常见事件”。 比如：\",\"：开区间\",\"：闭区间\",\"、：半开区间\",\"：单点集\",\"任意有限/可数个区间并集交集……\",\"这些都属于 Borel σ-代数。 你可以把它理解成：我们定义概率，只在这些“结构正常的区间组合”上做，不碰那些太反直觉或病态的集合。 总结: Borel σ-代数是一种你可以安全地讨论概率的“事件集合体系”，它由一些基本区间（比如 ）出发，闭包得到所有“常规可测的集合”。\",\"在持续时间的例子中，可进一步限制事件空间只包含区间 ，其中 。\",\"为定义概率度量，我们为每个 赋一个非负权重 ，称为概率密度函数（pdf，probability density function）。\",\"对于事件 ，概率由积分给出：\",\"还可以定义累积分布函数（cdf）：\",\"从中可以计算区间概率：\",\"“概率分布”一词既可以指 pdf ，也可以指 cdf ，甚至指概率度量 本身。\",\"上述定义也可推广到多维空间 ，以及函数等更复杂的样本空间。\"]},\"729\":{\"h\":\"概率公理\",\"t\":[\"与事件空间相关联的概率规律，必须遵循概率公理（Kolmogorov 公理），具体如下：\",\"非负性（Non-negativity）：\",\"对任意事件 ，有\",\"规范性（Normalization）：\",\"整个样本空间的概率为 1：\",\"可加性（Additivity）：\",\"对于任意一列两两互不相交（即互斥）的事件 ，有\",\"在有限的情况下，比如只有两个互斥事件 和 ，上述公式简化为：\",\"这个公式对应的是“事件 或 发生”的概率（前提是这两个事件是互斥的）。\",\"从这些公理可以推导出一些常用结论：\",\"补集规则（Complement Rule）：\",\"其中， 表示事件 的补集。\",\"这个结论来自于：\",\"其他可推出的结论：\",\"：可通过反证法证明\",\"：可由补集规则推出，当 时，，所以 \",\"加法规则（Addition Rule）：\",\"对于任意两个事件（不要求互斥），有：\",\"这个公式适用于任意两个事件，即使它们可能有重叠。\"]},\"730\":{\"h\":\"条件概率\",\"t\":[\"考虑两个事件 和 。如果 ，则定义事件 在 已经发生的条件下的条件概率为：\",\"根据这个定义，可以得到乘法法则（multiplication rule）：\",\"条件概率衡量的是：在事件 已经发生的前提下，事件 发生的可能性有多大。\",\"然而，如果两个事件是无关的，那么一个事件的发生不会改变另一个事件的概率。更形式化地说，若满足以下条件，则称 与 是独立事件（independent events）：\",\"若 且 ，上式等价于：\",\"，或\",\"同理，若在某个事件 已知的条件下，事件 与 满足下式：\",\"则称 和 在给定 的条件下是条件独立的（conditionally independent）。\"]},\"731\":{\"h\":\"全概率公式（Law of total probability）\",\"t\":[\"根据条件概率的定义，还可以推导出全概率公式：\",\"若集合 构成样本空间 的一个划分（partition），那么对于任意事件 ，有：\",\"全概率公式: 一个事件总体概率 = 在不同情形下它发生的概率 × 各种情形本身的概率，加起来。 假设我们有一个检测疾病的筛查工具，我们要问：\",\"一个人检测为阳性的总体概率是多少？\",\"我们知道：\",\"人群中 1% 有病（记作 ），99% 无病（记作 ）；\",\"如果有病（），检测为阳性（）的概率是 0.9（即 ）；\",\"如果没病（），误报为阳性概率是 0.05（即 ）；\",\"问：一个人检测阳性的总体概率是多少？ 我们把“人是否患病”作为划分事件：\",\"：患病，\",\"：未患病，\",\"我们要算的事件是“检测为阳性”（）：\",\"所以，虽然你可能觉得“阳性概率应该很高”，但实际上总体阳性概率只有 5.85%，因为大多数人根本没病，而没病的人也有误报。\"]},\"732\":{\"h\":\"贝叶斯法则\",\"t\":[\"根据条件概率的定义，可以推导出贝叶斯法则（Bayes’ rule），也称为贝叶斯定理（Bayes’ theorem）。对于任意两个满足 且 的事件 和 ，有：\"]},\"733\":{\"h\":\"离散随机变量形式\",\"t\":[\"对于一个具有 个可能取值的离散随机变量 ，结合全概率公式，贝叶斯法则可以写为：\",\"其中：\",\"：称为先验概率（prior probability）\",\"：称为似然（likelihood）\",\"：称为后验概率（posterior probability）\",\"：为归一化常数，也叫作边缘似然（marginal likelihood）\"]},\"734\":{\"h\":\"连续随机变量形式\",\"t\":[\"对于一个连续型随机变量 ，贝叶斯法则写作：\",\"这就是贝叶斯法则在离散和连续两种情形下的表达方式，它提供了一种根据观测数据（事件 ）来更新我们对未知变量 的信念的机制，是整个贝叶斯推断的核心。\"]},\"735\":{\"h\":\"一些常见的概率分布\",\"t\":[\"在构建各种类型的模型时，我们会用到多种概率分布。以下小节总结了其中一些常见分布。\",\"交互式可视化网站： 🔗 https://ben18785.shinyapps.io/distribution-zoo/\"]},\"736\":{\"h\":\"离散分布\",\"t\":[\"本节讨论的是定义在（非负）整数子集上的一些离散型概率分布。\"]},\"737\":{\"h\":\"伯努利分布与二项分布（Bernoulli and Binomial distributions）\",\"t\":[\"设 ，二项分布（Binomial distribution）定义为：\",\"其中， 是从 个元素中选出 个的组合数（称为二项系数，读作 “N 选 x”）。\",\"如果 ，即 ，则二项分布退化为伯努利分布（Bernoulli distribution）：\",\"其中， 是分布的均值。\"]},\"738\":{\"h\":\"分类分布与多项分布（Categorical and Multinomial distributions）\",\"t\":[\"如果变量是多值离散型的（例如 ），我们可以使用分类分布（categorical distribution）：\",\"其中 表示选择类别 的概率， 是指示函数，表示当 时取 1，否则取 0。\",\"或者，也可以将 K 类变量 表示成一个 独热编码（one-hot）向量，这时分类分布可以写为：\",\"其中 表示当前样本属于第 类，其它元素为 0。\",\"如果 表示类别 在总共 次试验中出现的次数，那么就得到了多项分布（multinomial distribution）：\",\"其中，多项系数（multinomial coefficient）定义为：\"]},\"739\":{\"h\":\"泊松分布（Poisson distribution）\",\"t\":[\"设随机变量 。若 服从参数为 的泊松分布，记作 ，则其概率质量函数（pmf）为：\",\"其中， 是该分布的均值，同时也是方差，即：\"]},\"740\":{\"h\":\"负二项分布（Negative binomial distribution）\",\"t\":[\"假设我们有一个“盒子”（或称“容器”）中有 个球，其中：\",\" 个是红球\",\" 个是蓝球\",\"我们进行有放回抽样，直到抽出 个球。设 表示这 个球中蓝球的数量。可以证明：\",\"即： 服从二项分布。\"]},\"741\":{\"h\":\"转换视角：定义失败为红球，成功为蓝球\",\"t\":[\"现在我们重新定义抽红球为“失败”、抽蓝球为“成功”。我们继续抽球，直到观察到 次失败（红球）为止。\",\"设 表示在这过程中抽到的“成功”次数（即蓝球个数）。可以证明：\",\"也就是说， 服从 负二项分布（Negative binomial distribution），其概率质量函数定义为：\",\"其中 ，表示成功的次数。\",\"组合数 这表示从 次试验中选出 次成功的位置，剩下的是失败。 这里试验顺序重要，且第 次失败必须是第 次试验的结果（最后一次失败）。\",\"二项分布关注试验次数固定，成功次数随机。\",\"负二项分布关注成功次数固定，试验次数（失败次数）随机。\"]},\"742\":{\"h\":\"特殊情况说明\",\"t\":[\"如果 是实数，我们将组合数 替换为伽马函数表达式：\",\"利用了恒等式 。\"]},\"743\":{\"h\":\"数学期望与方差\",\"t\":[\"负二项分布的两个矩（均值和方差）为：\"]},\"744\":{\"h\":\"负二项分布的意义与优势\",\"t\":[\"这种含有两个参数的分布比泊松分布更具有建模灵活性，因为它可以单独控制均值与方差。这在模拟某些“传染性事件”时非常有用，例如某些事件之间是正相关的，它们的出现会导致比独立情形更大的方差。\",\"事实上，泊松分布是负二项分布的一个特例。可以证明：\",\"另一个特例是当 时，负二项分布变为几何分布（Geometric distribution）。\"]},\"745\":{\"h\":\"定义在实数上的连续分布\",\"t\":[\"在本节中，我们讨论一些定义在实数集合 上的一元连续分布，即 且 。\"]},\"746\":{\"h\":\"高斯分布（正态分布）\",\"t\":[\"最广泛使用的一元分布是高斯分布（Gaussian distribution），也叫正态分布（normal distribution）。\",\"高斯分布的概率密度函数（pdf）定义为：\",\"其中， 是归一化常数，用于确保整个密度函数的积分为 1。\",\"参数 表示分布的均值（mean），也是该分布的众数（mode）。\",\"参数 表示分布的方差（variance）。\",\"有时我们也会讨论高斯分布的精度（precision），即方差的倒数：。\",\"精度越高意味着分布越“窄”（即方差小），集中在 附近。\",\"高斯分布的累积分布函数（cdf）定义为：\",\"如果 、（即所谓的标准正态分布），我们简写为 。\"]},\"747\":{\"h\":\"半正态分布（Half-normal）\",\"t\":[\"在某些问题中，我们希望使用定义在非负实数上的分布。一种构造这类分布的方法是设定：\",\"由此诱导出的 的分布被称为半正态分布（half-normal distribution），其概率密度函数为：\",\"这个分布可以被看作是标准正态分布 在 0 处对折（folded over）后的结果。\"]},\"748\":{\"h\":\"学生 t 分布（Student t-distribution）\",\"t\":[\"高斯分布的一个问题在于它对离群点非常敏感，因为其概率密度随着与中心的平方距离增大而指数级衰减。一种更具鲁棒性的分布是 学生 t 分布（Student t-distribution），我们简称为Student 分布。它的概率密度函数（pdf）如下：\",\"其中：\",\" 是均值，\",\" 是尺度参数（注意：不是标准差），\",\" 被称为自由度（不过一个更恰当的术语可能是“正态程度” [Kru13]，因为当 趋于较大值时，该分布会表现得像高斯分布）。\",\"归一化常数 的表达式为：\",\"这里：\",\" 是Gamma 函数，定义为：\",\" 是Beta 函数，定义为：\"]},\"749\":{\"h\":\"柯西分布（Cauchy distribution）\",\"t\":[\"当 时，Student 分布被称为 柯西分布（Cauchy distribution） 或 洛伦兹分布（Lorentz distribution）。它的概率密度函数（pdf）定义为：\",\"其中：\",\"，即归一化常数。\",\"这个分布的一个显著特点是：它的尾部非常厚重（heavy tails），以至于定义均值的积分并不收敛（即没有期望值）。\",\"半柯西分布（half Cauchy distribution） 是一种基于均值为 0 的柯西分布进行“折叠”的版本，也就是说，它的概率密度函数全部集中在正实数轴上。\",\"因此，其形式为：\",\"更多分布使用到的时候再进行补充\"]},\"750\":{\"h\":\"高斯联合分布（Gaussian joint distributions）\",\"t\":[\"对于连续型随机变量，使用最广泛的联合概率分布是多元高斯分布（multivariate Gaussian 或 multivariate normal，简称 MVN）。\",\"这种分布之所以受欢迎，一方面是因为其数学处理非常方便，另一方面在许多实际问题中，高斯分布作为近似是相当合理的。事实上，在给定均值和协方差矩的约束下，高斯分布是熵最大的分布。鉴于它的重要性，本节将详细讨论高斯分布。\"]},\"751\":{\"h\":\"多元正态分布（The multivariate normal）\",\"t\":[\"在本节中，我们将详细介绍多元高斯分布，又称多元正态分布（MVN）。\"]},\"752\":{\"h\":\"定义（Definition）\",\"t\":[\"多元高斯分布的概率密度函数定义如下：\",\"其中：\",\" 是均值向量，\",\" 是 的协方差矩阵，\",\"归一化常数 保证整个 pdf 的积分为 1。\",\"指数中的表达式（忽略系数 -0.5）是数据向量 相对于均值 的马氏距离（Mahalanobis distance）平方，定义如下：\",\"在二维空间中，多元高斯分布被称为二维高斯分布（bivariate Gaussian distribution）。其概率密度函数可表示为：\",\"协方差矩阵形式为：\",\"其中：\",\" 是相关系数，定义为：\",\"图 2.8 展示了三种不同协方差矩阵下的二维多元高斯密度图：\",\"完全协方差矩阵（Full covariance matrix）: 有 个自由参数（由于 是对称的，所以除以 2）。\",\"对角协方差矩阵（Diagonal covariance matrix）: 只有 D 个自由参数，非对角线元素为 0，表示变量之间不相关。\",\"球形协方差矩阵（Spherical covariance matrix）: 也称为各向同性协方差矩阵（isotropic covariance matrix），只有一个自由参数 ，表示所有方向的方差相同。\",\"只有一个自由参数 ，表示所有方向的方差相同。\",\"当然可以，以下是你提供内容的逐段翻译与解释，保持原意清晰、结构一致：\"]},\"753\":{\"h\":\"高斯壳（Gaussian shells）\",\"t\":[\"在高维空间中，多元高斯分布的行为可能会显得非常反直觉。我们可以提出这样一个问题：\",\"如果我们从 中采样，其中 是维度数，我们应该预期这些样本大多会落在空间的哪里？\",\"由于概率密度函数的峰值（众数）位于原点 ，我们直觉上会认为：大多数样本应该靠近原点。\",\"然而，在高维空间中，高斯分布的“典型集合（typical set）”实际上是一个很薄的壳层或环带，其：\",\"与原点的距离为：\",\"壳层的厚度为：\"]},\"754\":{\"h\":\"直观解释如下：\",\"t\":[\"虽然密度函数以 的形式衰减 —— 即离原点越远，密度越小，但与此同时：\",\"球体的体积随半径 按 的速率快速增长；\",\"因为概率质量 = 密度 × 体积；\",\"所以，两者之间会出现一种“相互抵消的平衡点” —— 也就是在某个距离范围内，虽然密度在下降，但体积增加更快；\",\"大多数样本会集中在这个区域上 —— 也就是所谓的“高斯肥皂泡现象（Gaussian soap bubble phenomenon）”。\"]},\"755\":{\"h\":\"数学解释：为什么高斯样本集中在壳层上？\",\"t\":[\"考虑某个点 到原点的平方距离：\",\"期望平方距离为：\",\"方差为：\",\"相对标准差（变异系数）为：\",\"这意味着：\",\"尽管每个样本的距离是随机的；\",\"但当维度 越大时，它们的平方距离越来越集中在 附近；\",\"从而，距离本身越来越集中在 附近。\",\"这就是为什么我们说样本会集中在距离原点约为 的薄壳层上。\"]},\"756\":{\"h\":\"图像空间的含义（例如灰度图像）\",\"t\":[\"图 2.9b 展示了一些从如下高斯分布中采样的灰度图像：\",\"其中 是一张“全灰”的图片（每个像素亮度相同）。\",\"你可能以为既然是围绕全灰图采样，那么采样出来的图像应该也接近灰色。但事实恰恰相反：\",\"在高维图像空间中，几乎不可能采样到接近灰色的图像。\",\"这是因为样本几乎全部落在离 一定距离的“典型壳层”上，而不是密度最大的中心点（即灰色图像）。这非常反直觉，但却是高维高斯的真实现象。\"]},\"757\":{\"h\":\"概率论基础模型\",\"t\":[\"概率论基础模型(用到多少，学多少 =_=)\"]},\"758\":{\"h\":\"Bayes' rule\",\"t\":[\"Question One: What's the mean of Bayesian inference ?\",\"“推理”（inference）是指“从样本数据出发，得出带有一定置信度的一般性结论的行为”。术语“贝叶斯”（Bayesian）则用来指代那些使用概率理论来表示“置信度”（即确定程度）并利用 贝叶斯公式(Bayes’ rule) 根据观察数据更新置信度的方法。\",\"贝叶斯公式本身非常简单：它是一个用于计算在给定观测数据 情况下，某个未知（或隐藏）变量 可能取值的概率分布的公式：\",\"这个公式可以由以下恒等式直接推出：\",\"而这个恒等式又来自于概率的乘法法则（product rule）。\",\"在公式 (2.51) 中，术语 表示在我们看到任何数据之前，对 的可能取值的了解；这被称为先验分布（prior distribution）。如果 有 个可能的取值，那么 就是一个包含 个元素的向量，其中的概率和为 1。\",\"术语 表示在假设 的前提下，我们对可能出现的结果 的分布，这被称为观测分布（observation distribution）。当我们将其评估于实际观测结果 上时，就得到了函数 ，这被称为似然函数（likelihood）。需要注意的是，这其实是 的函数，因为 是已知的固定值，并且它不是一个概率分布，因为它的和不一定为 1 。\",\"将先验概率 与似然函数 相乘，可以得到未归一化的联合分布。我们可以通过除以 将其变为归一化分布，这个除数被称为边际似然（marginal likelihood），因为它是通过对未知量 进行边际化（即求和）得到的：\",\"通过对每个 计算 ，我们就得到了后验分布（posterior distribution），它表示我们在看到数据 之后，对 可能取值的最新信念状态。\",\"我们可以用一句话来总结贝叶斯公式：\",\"这里使用符号 （“正比于”）表示我们省略了分母，因为它只是一个与 无关的常数。\",\"使用贝叶斯公式，根据观测数据对某一感兴趣的未知量的分布进行更新的过程，被称为贝叶斯推理（Bayesian inference）或后验推理（posterior inference），也可以简称为概率推理（probabilistic inference）。\",\"Bayes 公式人话版本: “先有预期 + 接收信息 → 更新判断”\",\"：隐藏的“真相”或假设\",\"：你观测到的信息\",\"：你在没有观察任何信息前对 H 的先验信念\",\"：如果 H 是真的，你会看到这个信息的可能性\",\"：你在看到 Y 后对 H 的新判断（后验）\"]},\"759\":{\"h\":\"Inverse problems\",\"t\":[\"概率论的核心是：在已知世界状态 的前提下，预测某个结果 的分布。而逆概率问题关注的则是：通过观察结果 ，去推断世界的状态。我们可以把这看作是对 映射关系的反向求解。\",\"举个例子，设想我们要从一张二维图像 中推断出一个三维形状 。这是视觉场景理解中的一个经典问题。不幸的是，这是一个根本上的病态问题（ill-posed problem），如图 2.8 所示：同一个观测结果 ，可能对应多个潜在的隐藏状态 。同样地，我们也可以将自然语言理解看作是一个病态问题：听者必须从说话者表达出的（通常是模糊的）语言中，去推测其真正的意图 。\",\"为了解决这类反向问题，我们可以使用贝叶斯公式来计算后验概率，它描述了在观测到 的情况下，对各种可能世界状态 的概率分布。\",\"要实现这一点，需要给出：\",\"前向模型：描述在给定 的前提下，结果 是如何产生的；\",\"先验分布：用于排除或降低某些不太可能的世界状态。\"]},\"760\":{\"h\":\"组合分析\",\"t\":[\"组合分析\"]},\"761\":{\"h\":\"计数法则\",\"t\":[\"一共有 r 个实验 ， 第一个实验有 n1 种可能结果; 对应于第一个实验的每一种实验结果，第二个实验有 n2 种可能结果； 对应于头两个实验的每一种实验结果，第三个实验有 n3 种可能结果； 等等，那么，这 r 个实验一共有 n1 * n2 * ... * nr 种可能结果。\"]},\"762\":{\"h\":\"排列(考虑元素之间的顺序)\",\"t\":[\"n 个不同的元素，按任意顺序进行排列，总的排列方式共有: n*(n-1)(n-2)...32*1 = n!\",\"可用计数法则进行理解。\",\"n 个元素，如果其中 n1 个元素彼此相同，另 n2 个彼此相同，... ，nr 个也彼此相同，那么一共有 种不同的排列方式。\",\"总排列数 = 异排列数 * 每种异排列对应的重复排列数 --> 异排列数 = 总排列数 / 每种异排列对应的重复排列数\",\"例: 用 PEPPER 的 6 个字母进行排列，考察其中任一排列方式: PEPPER ，固定P,E,R的相对顺序不变，对P,E,R单独进行重排，会产生: 3! * 2! * 1! 种重复排列，如下所示:\"]},\"763\":{\"h\":\"组合(不考虑元素之间的顺序)\",\"t\":[\"n 个不同的元素中取 r 个\",\"总排列数 = 异排列数 * 每种异排列对应的全排列数 --> 异排列数 = 总排列数 / 每种异排列对应的全排列数\"]},\"764\":{\"h\":\"BEiT 论文\",\"t\":[\"BEiT: BERT Pre-Training of Image Transformers\",\"论文链接: BEiT: BERT Pre-Training of Image Transformers 代码链接: https://github.com/microsoft/unilm/tree/master/beit\"]},\"765\":{\"h\":\"摘要\",\"t\":[\"BEiT（Bidirectional Encoder representation from Image Transformers）是一种基于自监督学习的视觉Transformer预训练模型，其核心思想借鉴了BERT的掩码语言建模任务，提出掩码图像建模(MIM)方法。\",\"具体而言，BEiT将图像表示为两种视图——图像块（如16×16像素的局部区域）和离散视觉标记（通过图像分词器生成），在预训练阶段随机掩码部分图像块并让模型预测原始视觉标记，而非直接回归像素值。\",\"实验表明，BEiT在图像分类和语义分割等下游任务中表现优异，且能加速微调收敛。该方法避免了传统像素级重建的局限性，通过高层语义的离散标记学习更有效的视觉表示，为视觉Transformer的自监督预训练提供了新思路。\"]},\"766\":{\"h\":\"简介\",\"t\":[\"Transformer 在计算机视觉领域展现出强大潜力，但视觉 Transformer 通常比卷积神经网络（CNN）需要更多的训练数据。为解决这一问题，自监督预训练成为利用大规模无标注图像数据的关键方法。目前，对比学习和自蒸馏等方法已被探索，但 BERT 风格的掩码建模在视觉领域的应用尚未充分研究。\",\"BEiT 提出了一种基于 掩码图像建模（MIM） 的自监督预训练方法，其核心挑战在于：\",\"缺乏预定义词汇：与 NLP 不同，图像块没有现成的词汇表，无法直接使用 softmax 分类器预测所有可能的候选块。\",\"像素回归的局限性：直接预测掩码块的原始像素会导致模型过度关注短程依赖和高频细节，而非高层语义。\",\"BEiT 的解决方案是：\",\"使用 双视图表示（图 1）：图像块（输入）和视觉标记（目标）。视觉标记通过离散变分自编码器（dVAE）学习，形成离散化的语义表示。\",\"在预训练时，随机掩码约 40% 的图像块，并让模型基于上下文预测原始视觉标记，而非像素值。\",\"实验表明，BEiT 在图像分类和语义分割任务上优于从零训练的模型和其他自监督方法。此外，BEiT 无需人工标注即可通过自注意力机制学习语义区域和物体边界（如图 2 所示），证明了其自动捕获高层视觉知识的能力。\",\"BEiT 的贡献包括：\",\"提出 MIM 任务，为视觉 Transformer 提供理论解释（基于变分自编码器视角）。\",\"在多个下游任务（如分类、分割）上验证了其有效性。\",\"揭示了自监督预训练中自注意力机制对语义理解的自动学习能力。\"]},\"767\":{\"h\":\"方法\",\"t\":[\"给定一张输入图像 ，BEiT 会将其编码为上下文相关的向量表示。如图 1 所示，BEiT 通过自监督学习的方式，在一个掩码图像建模（Masked Image Modeling, MIM）任务上进行预训练。MIM 的目标是基于编码向量还原被遮挡的图像 patch。对于下游任务（如图像分类、语义分割等），我们会在预训练好的 BEiT 基础上添加任务层，并在特定数据集上对参数进行微调。\"]},\"768\":{\"h\":\"图像表示\",\"t\":[\"我们的方法中将图像表示为两种形式，即：图像 patch 和 视觉 token。这两种表示方式分别作为预训练中的输入和输出。\"]},\"769\":{\"h\":\"图像 Patch\",\"t\":[\"将二维图像划分为一系列 patch，这样标准的 Transformer 就可以直接处理图像数据。形式化地，假设图像 ，我们将其划分为 个 patch，patch 表示为 ，其中 是通道数， 是输入图像尺寸， 是每个 patch 的大小。\",\"图像 patch 会被展平为向量并线性投影，这类似于 BERT 中的词嵌入 。图像 patch 保留的是原始像素数据，用作 BEiT 的输入特征。\",\"在实验中，我们将每张 的图像划分为 的 patch 网格，每个 patch 为 。\"]},\"770\":{\"h\":\"视觉 Token\",\"t\":[\"类似自然语言，我们将图像表示为由“图像 tokenizer”获得的一系列离散 token，而不是原始像素。具体来说，我们将图像 编码为 ，其中词表 包含离散 token 的索引。\",\"我们采用 离散变分自编码器_dVAE 训练得到的图像 tokenizer。视觉 token 的学习包含两个模块：tokenizer 和 解码器。tokenizer 根据视觉词汇表将图像像素 映射为离散 token ；解码器 根据视觉 token 重建原始图像 。其重建目标函数如下：\",\"由于潜在的视觉 token 是离散的，模型训练过程是不可微的，因此采用 Gumbel-Softmax 松弛方法 来优化模型参数。此外，在 dVAE 训练过程中对 加入了均匀先验。\",\"我们将每张图像 token 化为 的视觉 token 网格。请注意，对于一张图像，视觉 token 的数量与图像 patch 的数量相同。词表大小设置为 。\"]},\"771\":{\"h\":\"主干网络：图像 Transformer\",\"t\":[\"我们遵循 ViT 的方法，采用标准的 Transformer 作为主干网络，从而可以在网络结构上直接与已有方法进行对比。\",\"Transformer 的输入是一系列图像 patch，记为 。每个 patch 首先通过一个线性映射层转换为 patch 嵌入，表示为 ，其中 。我们在 patch 序列前添加一个特殊的 token [S]，并将标准的 1D 可学习位置编码 加到 patch 嵌入中。\",\"因此，输入向量为：\",\"这个向量序列随后被送入 Transformer，由 层 Transformer Block 逐层编码：\",\"最终输出为：\",\"其中， 表示第 个图像 patch 的最终编码表示。\"]},\"772\":{\"h\":\"BEiT 的预训练：掩码图像建模（Masked Image Modeling）\",\"t\":[\"我们提出了一种 掩码图像建模（Masked Image Modeling，MIM） 任务。该任务通过随机遮挡一部分图像 patch，然后预测这些被遮挡位置对应的视觉 token。\",\"图 1 展示了我们方法的整体流程: 给定一张输入图像 ，我们将其划分为 个图像 patch（记作 ），并将其编码为 个视觉 token（）。\",\"我们随机遮挡大约 40% 的图像 patch，遮挡位置记作集合 ，满足 。接着，我们用一个可学习的嵌入向量 替换这些被遮挡的 patch。\",\"我们构造损坏图像的 patch 序列：\",\"然后将其输入 层 Transformer 编码器中。最终输出的隐藏向量 被视为输入 patch 的编码表示。\",\"对于每一个被遮挡的位置 ，我们使用 softmax 分类器来预测对应的视觉 token，具体如下：\",\"其中， 是损坏后的图像输入，、 是分类器的参数， 为视觉 token 词表的大小。\",\"预训练目标是最大化在损坏图像条件下，预测正确视觉 token 的对数似然，即：\",\"最大化每个样本中被遮挡位置的预测准确性，使模型能够从上下文恢复出缺失的高层语义表示。\",\"其中， 表示训练语料库， 是随机选中的掩码位置集合， 表示按照掩码位置 所遮挡后的损坏图像。\",\"我们并不是简单地随机选择 patch 来作为掩码位置，而是采用了块状遮挡（blockwise masking）策略。其具体方法总结如下（详见算法 1）：每次遮挡图像中的一个 patch 区块。对于每个遮挡块，要求最小包含 16 个 patch，然后随机选择一个遮挡块的宽高比，重复上述步骤直到遮挡的 patch 数量达到总数的 40%，即 ，其中 是图像中 patch 的总数，0.4 是设定的遮挡比例。\",\"该 MIM 任务深受 掩码语言建模（Masked Language Modeling）的启发，MLM 是自然语言处理中最成功的预训练目标之一。此外，块状遮挡或 n-gram 掩码策略也在 BERT 类模型中广泛使用。\",\"然而，如果直接采用像素级自编码（pixel-level auto-encoding）的方式进行视觉预训练，即还原被遮挡 patch 的原始像素，会促使模型更关注短程依赖和高频细节。而 BEiT 通过预测离散视觉 token 的方式克服了这一问题，离散 token 能够对图像内容进行更高级别的抽象总结。\",\"论文在 3.3 节中的消融实验表明，所提出的方法在性能上显著优于像素级自编码方案。\"]},\"773\":{\"h\":\"从变分自编码器的视角\",\"t\":[\"BEIT 的预训练可以看作是变分自编码器（Variational Autoencoder，VAE）的训练。设 表示原始图像， 表示被遮挡（masked）的图像， 表示视觉令牌（visual tokens）。考虑对数似然 的证据下界（ELBO），即从被破坏的图像恢复原始图像：\",\"其中：\",\" 表示图像编码器（image tokenizer），用于获取视觉令牌；\",\" 表示解码器（decoder），根据输入的视觉令牌重建原始图像；\",\" 根据遮挡图像恢复视觉令牌，这就是我们的掩码图像建模（Masked Image Modeling, MIM）预训练任务。\",\"我们采用与 VQ-VAE 类似的两阶段训练流程。第一阶段，我们获得图像编码器作为离散变分自编码器（discrete VAE）。具体地，第一阶段通过最小化重建损失\",\"并假设先验为均匀分布，实现方程 (2) 中的目标。\",\"第一阶段只训练一个“离散 VAE”（也就是 VQ-VAE），不管掩码图像，也不训练 BEIT 主体，只关注如何把图像变成 token，再重建图像。\",\"在标准 VAE 中，latent 变量 是有一个先验分布 的（通常是高斯），用于计算 KL 散度项：\",\"但在 BEIT 的第一阶段中，我们使用 VQ-VAE 的思路，它的 latent 是 离散的、来自 codebook 的。我们通常令先验为 uniform，即假设 codebook 中的每个 token 等概率地可能出现。 这会导致 KL 散度为常数（或不参与优化），所以训练中我们就可以只最小化重建损失。\",\"第二阶段，在保持 和 不变的情况下，学习先验分布 。我们将 简化为单点分布，即取视觉令牌的最大概率值\",\"此时，方程 (2) 可以重写为：\",\"其中第一项为阶段一：视觉令牌重建（Visual Token Reconstruction），第二项即为我们的 BEIT 预训练目标：掩码图像建模（Masked Image Modeling）。\"]},\"774\":{\"h\":\"预训练设置（Pre-Training Setup）\",\"t\":[\"为了公平比较，BEIT 的网络结构遵循 ViT-Base 的配置。我们使用一个包含 12 层的 Transformer，隐藏层维度为 768，注意力头数为 12，前馈网络的中间层维度为 3072。输入图像被切分为默认的 16×16 大小的 patch。\",\"我们直接使用训练好的图像 tokenizer，其视觉 token 的词表大小为 8192。\",\"BEIT 在 ImageNet-1K 的训练集上进行预训练，该数据集包含约 120 万张图像。增强策略包括随机缩放裁剪、水平翻转和颜色抖动。注意，我们在自监督学习中不使用图像标签。\",\"实验中我们使用 224 × 224 的图像分辨率输入，因此图像会被划分为 14 × 14 个 patch，对应相同数量的视觉 token。在预训练过程中，我们最多随机遮挡 75 个 patch（即约占图像 patch 总数的 40%）。\",\"预训练共进行约 50 万步（约 800 个 epoch），使用 2000 的 batch size。优化器采用 Adam，超参数为 β₁ = 0.9、β₂ = 0.999。学习率设为 1.5e-3，前 10 个 epoch 进行 warmup，并采用 cosine 退火进行学习率衰减。权重衰减系数为 0.05。我们使用 stochastic depth，比例为 0.1，禁用了 dropout。\",\"整个 50 万步训练过程在 16 张 Nvidia Tesla V100（32GB 显存）GPU 上运行，约耗时五天。\",\"我们发现恰当的初始化对于 Transformer 的稳定训练非常关键，尤其是在大规模预训练时。我们首先将所有参数在一个较小范围内随机初始化，比如 [−0.02, 0.02]。随后，对于第 层 Transformer，我们将自注意力模块和前馈网络中子层最后的线性投影矩阵的输出按 进行缩放（rescale）。\"]},\"775\":{\"h\":\"在下游视觉任务上微调 BEIT\",\"t\":[\"在完成 BEIT 的预训练后，我们在 Transformer 结构的基础上添加一个任务层，并在下游任务上微调所有参数，这一过程类似于 BERT 的微调方式。我们在本文中以图像分类和语义分割为例。实际上，将这种“预训练再微调”（pre-training-then-fine-tuning）范式应用于其他视觉任务也非常直接。\"]},\"776\":{\"h\":\"图像分类（Image classification）\",\"t\":[\"对于图像分类任务，我们直接使用一个简单的线性分类器作为任务层。具体而言：\",\"使用 平均池化（average pooling） 来汇聚所有 patch 的表示；\",\"然后将全局表示送入 softmax 分类器。\",\"类别概率的计算方式如下：\",\"其中：\",\" 表示第 个图像 patch 在最后一层的表示向量；\",\" 是分类器的权重矩阵；\",\" 是类别数。\",\"我们通过最大化带标签数据的似然函数，联合优化 BEIT 模型和 softmax 分类器的参数。\"]},\"777\":{\"h\":\"语义分割（Semantic segmentation）\",\"t\":[\"对于语义分割任务，我们采用 SETR-PUP 中使用的任务层设计。具体地：\",\"使用预训练的 BEIT 作为 backbone 编码器；\",\"加入多个 反卷积层（deconvolution layers） 构成解码器，用于输出分割结果。\",\"该模型同样采用端到端微调的方式，类似于图像分类的训练流程。\"]},\"778\":{\"h\":\"中间微调（Intermediate fine-tuning）\",\"t\":[\"在完成自监督预训练后，我们可以在一个数据量更丰富的中间数据集（如 ImageNet-1K）上进一步训练 BEIT，然后再将模型迁移到具体的下游任务上进行微调。\",\"这种“中间微调”策略在 NLP 中已经成为常规做法，我们在 BEIT 中也直接采用了类似的方法。\"]},\"779\":{\"h\":\"实验\"},\"780\":{\"h\":\"消融实验（Ablation Studies）\",\"t\":[\"我们分析了 BEIT 各组成部分的重要性。所有模型都在 ImageNet（分类）和 ADE20K（分割）任务上评估，预训练步数为 300 epoch（约为主实验 800 epoch 的 37.5%）。\",\"表 4 展示了不同变体的实验结果：\",\"去除 blockwise masking：即随机选择 mask 的 patch，而非以 block 为单位遮挡。发现 blockwise masking 尤其对语义分割帮助很大。\",\"去除视觉 token，改为像素重建：预训练目标变成恢复原始像素，效果明显变差，甚至不如从零训练的 Transformer。\",\"同时去除视觉 token 和 blockwise masking：进一步加剧性能下降。\",\"预测所有 token（即不遮挡）：性能也有所下降，说明遮挡带来的表示学习能力是关键。\",\"延长预训练时间（800 epoch）：显著提升下游任务性能。\",\"结论：视觉 token 与遮挡机制是 BEIT 有效的关键组成。\"]},\"781\":{\"h\":\"自注意力图的分析\",\"t\":[\"我们发现 BEIT 的自注意力机制可以自动学会区分图像中的语义区域，尽管预训练时没有用任何人工标注。\",\"我们使用 COCO 图像做可视化（避免出现在预训练数据中），展示了不同 reference patch 的注意力图。具体方法是：\",\"取最后一层 self-attention 的 query-key 乘积；\",\"对某个 patch 为 query，显示它关注哪些其他 patch。\",\"结果表明，BEIT 的 attention head 能够自动关注对象边界或同类区域，这种内在学习能力可能是 BEIT 能在下游任务上泛化得更好的原因之一，特别是在小样本数据集上。\"]},\"782\":{\"h\":\"相关工作\"},\"783\":{\"h\":\"自监督视觉预训练\",\"t\":[\"自监督视觉预训练方法可以大致分为三类：\"]},\"784\":{\"h\":\"1. 对比学习（Contrastive Learning）\",\"t\":[\"对比学习通过拉近相似图像（如不同数据增强后的同一图像）之间的距离，并拉远其他图像。典型代表包括：\",\"MoCo、SimCLR、SwAV、BYOL、Barlow Twins；\",\"近期的方法如 DINO、MoCo v3 也可用于 Transformer；\",\"iBOT 综合了 MIM 和对比学习。\",\"这些方法需要构造正负样本对，并依赖于数据增强的设计。\"]},\"785\":{\"h\":\"2. 生成式预训练（Generative Pretraining）\",\"t\":[\"这类方法试图从原始图像中恢复遮挡部分：\",\"iGPT 使用像素序列建模；\",\"ViT 使用 patch 分类作为监督任务；\",\"GANs（如 BigGAN）可用于图像生成，但不适合表征学习。\",\"像素恢复任务通常难以训练，且容易聚焦低级细节而非语义结构。\"]},\"786\":{\"h\":\"3. 目标预训练（Pretext Task）\",\"t\":[\"设计特定任务作为学习信号：\",\"旋转预测；\",\"图像 jigsaw 拼图；\",\"DAE、MAE 等自动编码器结构；\",\"这些方法训练稳定，但有效性有限。\",\"BEIT 提供了新方向：将图像预训练目标设计为 “语义 token 预测”，而非像素或对比目标。\"]},\"787\":{\"h\":\"离散表示学习（Discrete Representation Learning）\",\"t\":[\"使用离散表示（token）可以使模型从输入中学习更抽象的语义信息。关键代表包括：\",\"VQ-VAE 提出了 vector quantization 机制，将连续表示映射为离散 codebook；\",\"VQ-VAE-2 和 dVAE 进一步改进重建质量与稳定性；\",\"这些方法常用于图像生成（PixelCNN/VQ-GAN）和音频建模；\",\"BEIT 借助 dVAE 提供的视觉 token，将离散化思想引入图像预训练任务。\"]},\"788\":{\"h\":\"BERT 式的预训练方法（BERT-style Pretraining）\",\"t\":[\"BERT 是 NLP 中最成功的预训练方法之一，基于 “mask 掉 token 并预测它” 的思想，启发了 BEIT 的设计。\",\"BEIT 类似于图像领域的 “BERT”，输入为 patch，输出为被 mask 掉的 token；\",\"iGPT 也借鉴了 BERT 思路，但直接在像素上建模，学习成本高；\",\"MAE 是 BEIT 的后续工作之一，直接预测图像 patch 的像素；\",\"BEIT 是第一个真正从 token 层面借用 BERT 的图像模型。\"]},\"789\":{\"h\":\"多模态预训练（Multimodal Pretraining）\",\"t\":[\"在图像与文本结合任务中，使用 token 化的表示也非常常见：\",\"DALL·E、CLIP 将图像编码为离散 token；\",\"ViLT、UNITER 等通过共享 Transformer 编码图文对；\",\"图像 tokenizer（如 dVAE、VQ-GAN）是许多多模态生成模型的关键组成；\",\"BEIT 借鉴这种 token 化方法，为纯视觉模型设计了自监督 token 预测任务。\"]},\"790\":{\"h\":\"结论\",\"t\":[\"我们提出了 BEIT（Bidirectional Encoder representation from Image Transformers），一种基于图像 Transformer 的自监督预训练方法。受 BERT 在自然语言处理中的成功启发，BEIT 通过遮挡图像 patch 并预测相应的视觉 token，将 BERT 式的 Masked Language Modeling 思想成功引入视觉领域。\",\"我们的工作首次提出以 图像视觉 token 为预测目标，训练一个 BERT 风格的视觉 Transformer，从而实现强大的图像表征学习能力。在多个视觉任务中，如图像分类与语义分割，BEIT 展示出卓越的性能，超越了基于监督学习或对比学习的主流方法。\",\"此外，我们也展示了通过联合 dVAE、合适的 masking 策略与稳定的训练流程，可以使大规模图像预训练具备更强的可扩展性，为更大模型（如 BEIT-L）提供了稳定基础。\",\"我们相信，本研究为 统一视觉预训练框架 打下了基础，也为未来探索更强大的视觉理解与生成模型提供了方向。\"]},\"791\":{\"h\":\"BEiT 模型代码解读\",\"t\":[\"BEiT 模型代码解读\",\"论文解读: BEiT 论文解读\"]},\"792\":{\"h\":\"dVAE 预训练\",\"t\":[\"BEiT 模型的代码实现中定义了 两种变分自编码器（VAE），分别对应：\",\"DiscreteVAE：自研的 VQ-VAE 实现，基于 lucidrains/DALLE-pytorch 改写。\",\"Dalle_VAE：封装了 OpenAI 提供的预训练好的 DALL·E 编码器和解码器，直接加载 encoder.pkl 和 decoder.pkl。\"]},\"793\":{\"h\":\"DiscreteVAE 初始化\",\"t\":[\"本节我们会针对 DiscreteVAE 的代码实现展开讲解 ，首先是 DiscreteVAE 类的 __init__ 方法：\",\"class DiscreteVAE(BasicVAE): def __init__( self, image_size = 256, # 输入图像尺寸，假设为正方形，如 256x256 num_tokens = 512, # codebook 中 token 的种类数（即离散编码类别数） codebook_dim = 512, # 每个 token 的嵌入维度 num_layers = 3, # 编码器/解码器的下采样/上采样层数 hidden_dim = 64, # 每层卷积的通道数 channels = 3, # 输入图像通道数，通常为3（RGB图像） smooth_l1_loss = False, # 是否使用 smooth_l1 作为重建损失（否则用 mse） temperature = 0.9, # Gumbel Softmax 的温度参数 straight_through = False, # 是否启用 straight-through 近似采样（硬采样但梯度可导） kl_div_loss_weight = 0. # KL 散度项的损失权重（用于保持 token 使用的均匀性） ): # 保存超参数 self.image_size = image_size self.num_tokens = num_tokens self.num_layers = num_layers self.temperature = temperature self.straight_through = straight_through # 创建 codebook：token 编号 → 向量（[num_tokens, codebook_dim]） self.codebook = nn.Embedding(num_tokens, codebook_dim) enc_layers = [] # 编码器层列表 dec_layers = [] # 解码器层列表 enc_in = channels # 编码器初始输入通道（RGB图像为3） dec_in = codebook_dim # 解码器初始输入通道（token 嵌入维度） # 构建多层编码器和解码器（对称结构） for layer_id in range(num_layers): # 编码器：4x4卷积下采样 + ReLU enc_layers.append( nn.Sequential( nn.Conv2d(enc_in, hidden_dim, kernel_size=4, stride=2, padding=1), nn.ReLU() ) ) # 编码器残差块（增强特征提取） enc_layers.append( ResBlock( chan_in=hidden_dim, hidden_size=hidden_dim, chan_out=hidden_dim ) ) enc_in = hidden_dim # 下次输入通道设为隐藏通道 # 解码器：反卷积上采样 + ReLU dec_layers.append( nn.Sequential( nn.ConvTranspose2d(dec_in, hidden_dim, kernel_size=4, stride=2, padding=1), nn.ReLU() ) ) # 解码器残差块 dec_layers.append( ResBlock( chan_in=hidden_dim, hidden_size=hidden_dim, chan_out=hidden_dim ) ) dec_in = hidden_dim # 下次输入通道设为隐藏通道 # 编码器最终输出层：将通道映射到 num_tokens，得到 token 分类 logits enc_layers.append(nn.Conv2d(hidden_dim, num_tokens, kernel_size=1)) # 解码器最终输出层：映射回原图像通道数（通常为 3） dec_layers.append(nn.Conv2d(hidden_dim, channels, kernel_size=1)) # 将所有子模块组合为完整的 encoder 和 decoder 网络 self.encoder = nn.Sequential(*enc_layers) self.decoder = nn.Sequential(*dec_layers) # 重建损失函数：使用 Smooth L1 或 MSE self.loss_fn = F.smooth_l1_loss if smooth_l1_loss else F.mse_loss # KL 散度正则项的权重（默认 0，不启用） self.kl_div_loss_weight = kl_div_loss_weight\",\"残差块实现如下:\",\"class ResBlock(nn.Module): def __init__(self, chan_in, hidden_size, chan_out): super().__init__() self.net = nn.Sequential( nn.Conv2d(chan_in, hidden_size, 3, padding=1), nn.ReLU(), nn.Conv2d(hidden_size, hidden_size, 3, padding=1), nn.ReLU(), nn.Conv2d(hidden_size, chan_out, 1) ) def forward(self, x): return self.net(x) + x\"]},\"794\":{\"h\":\"DiscreteVAE 前向传播\",\"t\":[\"下面给出的是 DiscreteVAE 类的 forward 方法实现:\",\"def forward( self, img, # 输入图像 [B, C, H, W] return_loss = False, # 是否返回 loss return_recons = False, # 是否返回重建图像 return_logits = False, # 是否仅返回 logits temp = None # 覆盖默认温度参数 ): device = img.device num_tokens = self.num_tokens image_size = self.image_size kl_div_loss_weight = self.kl_div_loss_weight # 编码器前向传播，得到每个像素位置的 logits logits = self.encoder(img) # shape: [B, num_tokens, H', W'] # 若仅获取 logits（例如用于 DALL-E 中提取离散 token 索引），则直接返回 if return_logits: return logits # 使用 Gumbel Softmax 对 logits 进行采样，得到 soft one-hot 编码 temp = temp if temp is not None else self.temperature soft_one_hot = F.gumbel_softmax(logits, tau=temp, dim=1, hard=self.straight_through) # shape: [B, num_tokens, H', W'] # 查找 codebook 向量，获得连续隐变量 # einsum 相当于 soft_one_hot @ codebook.weight sampled = einsum('b n h w, n d -> b d h w', soft_one_hot, self.codebook.weight) # shape: [B, codebook_dim, H', W'] # 解码器重建图像 out = self.decoder(sampled) # shape: [B, C, H, W] # 如果不需要 loss，只返回重建图像 if not return_loss: return out # 计算重建损失 recon_loss = self.loss_fn(img, out) # KL 散度损失（可选，衡量 q(y) 与 uniform 的差异） logits = rearrange(logits, 'b n h w -> b (h w) n') # 展平空间维度 qy = F.softmax(logits, dim=-1) # 每个位置的 token 概率分布 log_qy = torch.log(qy + 1e-10) # 避免 log(0) log_uniform = torch.log(torch.tensor([1. / num_tokens], device=device)) kl_div = F.kl_div(log_uniform, log_qy, None, None, reduction='batchmean', log_target=True) # 加权总损失 loss = recon_loss + (kl_div * kl_div_loss_weight) # 如果不需要重建图像，仅返回 loss if not return_recons: return loss # 否则返回 loss 和重建图像 return loss, out\"]},\"795\":{\"h\":\"Gumbel Softmax\",\"t\":[\"传统的离散变量采样（比如从多分类分布中采样一个类别）是非可微的，不能直接用反向传播训练神经网络。Gumbel Softmax（也叫 Concrete distribution）是一种连续的可微近似方法，允许在训练时对离散随机变量进行“软采样”，实现端到端的梯度传播。 训练时用“软采样”表示类别概率的加权和；推理时可以用硬采样（one-hot）恢复离散的类别。\",\"Gumbel Softmax的采样过程分为两步：\",\"对每个类别的 logits（未归一化的对数概率）加上 Gumbel 噪声（用来模拟采样的随机性）\",\"对加噪声后的 logits 使用 softmax，并用温度参数控制“分布的平滑度”\",\"数学表达式：\",\"其中：\",\" 是第 类的概率（或 logits 经过 softmax 的概率）\",\" 是从 Gumbel(0,1) 分布采样的噪声，定义为 ，其中 \",\" 是温度参数，控制分布的“尖锐度”。温度越低，采样越接近 one-hot；温度高时更平滑。\",\"PyTorch 提供了 F.gumbel_softmax 函数来实现上述过程：\",\"soft_one_hot = F.gumbel_softmax(logits, tau=temp, dim=1, hard=self.straight_through)\",\"logits：输入的未归一化的 logits 张量。\",\"tau：温度参数 temp，控制分布的平滑度。\",\"dim=1：在类别维度上执行 softmax。\",\"hard：布尔值，是否使用硬采样 + 直通梯度。\",\"hard=False 返回的是软概率分布（连续值，可微）。\",\"hard=True 返回 one-hot 编码，但梯度仍由软样本近似（Straight-Through Estimator）。\",\"Gumbel Softmax 使模型在训练时可以对这些 logits 进行采样，得到一个“软”的 one-hot 向量，代表隐空间的离散编码。这个 soft one-hot 向量乘以 codebook 的 embedding 权重，得到连续的隐向量表示，用于解码器重建图像。\",\"当 hard=True 时，可以模拟硬采样（one-hot向量），方便离散索引的推断，同时仍保证梯度流通。\"]},\"796\":{\"h\":\"hard=True时，如何实现的？\",\"t\":[\"当 hard=self.straight_through 为 True 时，Gumbel-Softmax 采样过程使用了一种称为 Straight-Through Gumbel-Softmax 的技巧，它使得：\",\"前向传播时是one-hot 向量（离散），\",\"反向传播时仍保持连续可导（通过 softmax）\",\"在 VAE 或 BEiT 的离散编码器中，我们希望：\",\"对图像进行离散 token 编码（便于 Transformer 训练）\",\"但同时又希望这个采样过程能反向传播梯度\",\"这就引出了 Straight-Through Gumbel-Softmax：\",\"采样过程详解:\",\"soft_one_hot = F.gumbel_softmax(logits, tau=temp, dim=1, hard=True)\",\"等价于：\",\"y_soft = softmax((logits + GumbelNoise) / tau) # 连续分布，用于反向传播 index = argmax(y_soft) # 找到最大概率的 one-hot 索引 y_hard = one_hot(index) # 得到一个离散的 one-hot 向量 # 关键一步：straight-through trick y = y_hard.detach() - y_soft.detach() + y_soft\",\"y = y_hard.detach() - y_soft.detach() + y_soft\",\"y_hard.detach()：将 one-hot 向量从计算图中分离出来（不可导）\",\"y_soft.detach()：也分离出来，表示不在反向传播中参与梯度计算\",\"+ y_soft：把 soft 向量加入回来，用于反向传播\",\"➡️ 整体效果：\",\"方向\",\"数据流\",\"梯度流\",\"forward\",\"使用 one-hot 离散 token\",\"——\",\"backward\",\"使用 softmax 的连续梯度\",\"保持可导，稳定训练\"]},\"797\":{\"h\":\"smooth_l1_loss\",\"t\":[\"smooth_l1_loss 是 PyTorch 中的一种 回归损失函数，也被称为 Huber Loss 的一种变体，它结合了均方误差（MSE）和平均绝对误差（MAE）的优点，在处理 异常值/离群点鲁棒性更强。\",\"对于预测值 、目标值 ，以及误差 ：\",\"这个函数在误差较小时近似于 MSELoss，误差较大时退化为 L1Loss，从而避免了 MSE 对异常值特别敏感的问题。\",\"相比 MSE，使用 smooth_l1_loss 能让 VAE：\",\"对单个像素偏差较大的情况更加宽容（防止训练不稳定）\",\"更容易在训练中收敛，因为梯度变化更平滑\",\"smooth_l1_loss 是一个融合了 MSE 的平滑性与 L1 的鲁棒性的损失函数，常用于图像回归与重建任务中，能更好处理异常误差。\"]},\"798\":{\"h\":\"KL散度计算\",\"t\":[\" # KL 散度损失（可选，衡量 q(y) 与 uniform 的差异） logits = rearrange(logits, 'b n h w -> b (h w) n') # 展平空间维度: [B, num_tokens, H, W] 变为 [B, H*W, num_tokens] qy = F.softmax(logits, dim=-1) # 每个位置的 token 概率分布 log_qy = torch.log(qy + 1e-10) # 避免 log(0) log_uniform = torch.log(torch.tensor([1. / num_tokens], device=device)) kl_div = F.kl_div(log_uniform, log_qy, None, None, reduction='batchmean', log_target=True)\",\"在这段代码中，我们计算的是编码器输出分布 与一个先验分布 之间的 Kullback-Leibler 散度，记作：\",\"其中：\",\"：先验分布（理想中我们希望 encoder 生成的分布接近它）\",\"：encoder 对图像每个 patch 给出的 softmax 分布\",\"：codebook 中的 token 数，即 num_tokens\",\"在本代码中：\",\"，即是均匀分布\",\"所以 \",\"带入公式得到：\",\"也就是：\",\"这个损失鼓励 q 趋近于均匀，从而避免编码器只用很少几个 token。\"]},\"799\":{\"h\":\"log_target 参数\",\"t\":[\"F.kl_div(input, target, log_target=False)\",\"此时，input 是 log 概率，target 是概率，计算公式为：\",\"即：\",\"F.kl_div(log_q, p, log_target=False)\",\"F.kl_div(log_p, log_q, log_target=True)\",\"此时认为 两个参数都是 log 概率，底层计算公式变为：\",\"也就是 PyTorch 自动执行：\",\"KL = (p * (log_p - log_q)).sum()\",\"其中：\",\"⚠️ 注意：这种方式需要我们手动把两个分布都以 log 形式传进去。\"]},\"800\":{\"h\":\"为什么先验分布设置为均匀分布？\",\"t\":[\"这是为了满足 信息瓶颈 或 高效利用 codebook 的目标：\",\"VQ-VAE 的典型问题：code collapse\",\"编码器如果训练不当，可能会只偏好极少数几个 code（比如 512 个 code 中只用 10 个），这是 codebook collapse。\",\"结果就是：虽然理论上有 512 种可能的图像 patch 表达，但实际只用了极少数，模型表达能力受限。\",\"使用均匀先验的好处\",\"均匀分布意味着我们希望所有 token 被“平等地使用”。\",\"加上 KL 散度约束后，编码器会被正则化为“尽可能平均地使用每个 token”。\",\"这样可以提高 codebook 的使用率，提升模型的表达多样性。\",\"总结为一句话：\",\"使用均匀先验是为了鼓励编码器生成的离散 token 分布更加均衡，避免 code collapse，从而充分利用整个 codebook 的表示能力。\"]},\"801\":{\"h\":\"块状遮挡（blockwise masking）策略\",\"t\":[\"块状遮挡通过遮盖图像中的连续 patch 区域，更真实地模拟自然场景中的遮挡，增强模型对上下文的理解能力，避免信息泄漏，同时实现简单且与基于patch的模型结构高度契合，因此比像素级别遮挡更有效和实用。\",\"遮挡方式：\",\"将图像划分为 个 patch\",\"每次遮挡一个矩形块区域，如 4×4 或 6×3 的 patch 区域\",\"最终总共遮掉 num_masking_patches 个 patch\",\"相比于逐 patch 独立遮挡（如 random token masking），这种遮挡方式：\",\"遮挡方式\",\"特点\",\"对比优势\",\"随机单 patch 遮挡\",\"每个 patch 独立被遮或不遮\",\"遮挡区域零碎\",\"✅ 块状遮挡\",\"遮一片连续矩形区域\",\"更符合图像结构、语义连续\",\"块状掩码策略的具体实现代码如下所示，首先给出的是掩码生成器的初始化方法，重点注意各个参数的含义:\",\"class MaskingGenerator: def __init__( self, input_size, # 输入图像的 patch 网格大小（如 14 表示 14x14 patch） num_masking_patches, # 最终要 mask 掉的 patch 总数量 min_num_patches=4, # 每次生成一个遮挡块时，最小 patch 数 max_num_patches=None, # 每次遮挡块最多的 patch 数；默认等于 num_masking_patches min_aspect=0.3, # 遮挡块的最小宽高比（例如 h/w = 0.3） max_aspect=None): # 最大宽高比，默认取 1 / min_aspect（对称处理） # 如果输入是整数，则构造成正方形大小的 patch 网格 if not isinstance(input_size, tuple): input_size = (input_size, ) * 2 self.height, self.width = input_size # patch 网格的高和宽（例如 14x14） self.num_patches = self.height * self.width # 总共可用 patch 数量 self.num_masking_patches = num_masking_patches # 需要被 mask 的 patch 总数 self.min_num_patches = min_num_patches # 单个遮挡块的最小 patch 数 # 若 max_num_patches 未指定，则设为总遮挡目标数（不限制） self.max_num_patches = num_masking_patches if max_num_patches is None else max_num_patches # 如果未指定最大宽高比，默认与 min_aspect 互为倒数，保持对称性 max_aspect = max_aspect or 1 / min_aspect # 记录宽高比范围的对数形式，便于采样（log 均匀采样 → 平滑控制长宽比例分布） self.log_aspect_ratio = (math.log(min_aspect), math.log(max_aspect))\",\"下面将展示正式执行块状遮挡策略前的准备工作:\",\"def __call__(self): # 初始化一个全零的遮挡掩码，大小为输入图像的patch数目（height x width） mask = np.zeros(shape=self.get_shape(), dtype=np.int) mask_count = 0 # 当前已经遮挡的patch数量 # 循环直到遮挡的patch数量达到指定的遮挡总数 while mask_count < self.num_masking_patches: # 计算本轮最多还能遮挡的patch数 max_mask_patches = self.num_masking_patches - mask_count # 限制本次遮挡的patch数量不超过最大遮挡数 max_mask_patches = min(max_mask_patches, self.max_num_patches) # 尝试生成一个遮挡块，返回本次新增遮挡的patch数量 delta = self._mask(mask, max_mask_patches) if delta == 0: # 如果没有新增遮挡（即无法再生成有效遮挡块），跳出循环 break else: # 更新已遮挡patch数量 mask_count += delta # 返回最终生成的遮挡掩码（0表示未遮挡，1表示遮挡） return mask\",\"执行块状遮挡策略的核心代码实现如下:\",\"def _mask(self, mask, max_mask_patches): delta = 0 # 记录本次新增遮挡的patch数量 for attempt in range(10): # 最多尝试10次生成遮挡块 # 随机采样目标遮挡面积（patch数量），范围在[min_num_patches, max_mask_patches]之间 # random.uniform 是均匀采样，即每一个值被采样到的可能性完全相等 target_area = random.uniform(self.min_num_patches, max_mask_patches) # 随机采样遮挡块的长宽比（在log空间均匀采样后exp还原） aspect_ratio = math.exp(random.uniform(*self.log_aspect_ratio)) # 根据面积和长宽比计算遮挡块的高度和宽度（向最近整数取整） # h * w ≈ target_area # h / w ≈ aspect_ratio # h^2 = target_area * aspect_ratio; w^2 = target_area / aspect_ratio h = int(round(math.sqrt(target_area * aspect_ratio))) w = int(round(math.sqrt(target_area / aspect_ratio))) # 检查遮挡块尺寸是否小于输入图像patch尺寸，确保遮挡块可放入图像范围内 if w < self.width and h < self.height: # 随机采样遮挡块在图像上的左上角位置，确保遮挡块不会越界 top = random.randint(0, self.height - h) left = random.randint(0, self.width - w) # 计算遮挡块区域内已被遮挡的patch数 num_masked = mask[top: top + h, left: left + w].sum() # 判断当前遮挡块的有效新增遮挡数量 # 必须新增遮挡patch数>0且不超过最大允许遮挡数 if 0 < h * w - num_masked <= max_mask_patches: # 遍历遮挡块区域，将未遮挡的patch设置为遮挡（1），累计新增遮挡数量 for i in range(top, top + h): for j in range(left, left + w): if mask[i, j] == 0: mask[i, j] = 1 delta += 1 # 如果本次成功新增了遮挡patch，跳出尝试循环 if delta > 0: break # 返回本次新增的遮挡patch数量 return delta\"]},\"802\":{\"h\":\"数据集加载\",\"t\":[\"数据集的加载，我们需要重点关注应用于图像之上的Transform操作，核心代码实现如下:\",\"class DataAugmentationForBEiT(object): def __init__(self, args): # 通用图像增强流程，包括颜色抖动、随机水平翻转和双图采样（生成两张不同视角图像） self.common_transform = transforms.Compose([ transforms.ColorJitter(0.4, 0.4, 0.4), # 随机调整亮度、对比度、饱和度 transforms.RandomHorizontalFlip(p=0.5), # 以 0.5 的概率水平翻转 RandomResizedCropAndInterpolationWithTwoPic( size=args.input_size, # 第一张图的目标尺寸 second_size=args.second_input_size, # 第二张图的目标尺寸 interpolation=args.train_interpolation, # 第一张图的插值方式 second_interpolation=args.second_interpolation, # 第二张图的插值方式 ), ]) # patch_transform：针对输入 encoder 的图像变换（标准 ToTensor 和 Normalize） self.patch_transform = transforms.Compose([ transforms.ToTensor(), # 将 PIL 图像转为 [0,1] 的张量 transforms.Normalize( mean=torch.tensor(mean), # 按照选定均值归一化 std=torch.tensor(std)) # 按照选定方差归一化 ]) # visual_token_transform：用于离散 VAE 编码器的图像变换 if args.discrete_vae_type == \\\"dall-e\\\": # 如果使用 DALL-E 风格的 tokenizer，需使用 map_pixels（将像素从 [0,1] 映射到 [-1,1]） self.visual_token_transform = transforms.Compose([ transforms.ToTensor(), map_pixels, # 特殊像素映射操作（DALL-E 需要） ]) elif args.discrete_vae_type == \\\"customized\\\": # 若是自定义 tokenizer，使用 Inception 风格归一化 self.visual_token_transform = transforms.Compose([ transforms.ToTensor(), transforms.Normalize( mean=IMAGENET_INCEPTION_MEAN, std=IMAGENET_INCEPTION_STD, ), ]) else: raise NotImplementedError() # 不支持的 tokenizer 类型报错 # 初始化 MaskingGenerator，生成 block-wise 遮挡掩码 self.masked_position_generator = MaskingGenerator( args.window_size, # 图像分块尺寸（H, W） num_masking_patches=args.num_mask_patches, # 总共要 mask 掉的 patch 数量 max_num_patches=args.max_mask_patches_per_block, # 每个遮挡块最大 patch 数 min_num_patches=args.min_mask_patches_per_block, # 每个遮挡块最小 patch 数 ) def __call__(self, image): # 对输入图像做通用增强，返回两张不同视角图像 for_patches, for_visual_tokens = self.common_transform(image) # 分别对两张图做不同处理，生成 patch 图像、visual token 图像、遮挡掩码 return self.patch_transform(for_patches), self.visual_token_transform(for_visual_tokens), self.masked_position_generator() # 构建 BEiT 预训练用的数据集加载器 def build_beit_pretraining_dataset(args): transform = DataAugmentationForBEiT(args) # 实例化数据增强类 return ImageFolder(args.data_path, transform=transform) # 加载图像文件夹作为数据集，并应用 transform\",\"common_transform：共享的图像增强\",\"作用：对原始图像进行统一的图像增强（如颜色抖动、随机裁剪、水平翻转等），并生成两张不同的图像：\",\"一张用于喂给 Vision Transformer encoder（即 for_patches）\",\"一张用于传给视觉 tokenizer（即 for_visual_tokens）\",\"为什么要做两张图？\",\"是为了增强模型鲁棒性，但保持语义一致。BEiT 训练时，一边喂模型的是带遮挡的图像（encoder输入），一边是完整图像（tokenizer生成标签）。\",\"与 SimCLR、BYOL、DINO 等方法一样，图像增强是对比学习或自监督学习的基础。\",\"patch_transform：encoder 输入图像的标准化处理\",\"作用：将 for_patches 图像转换为 Tensor，并使用指定的均值和方差进行归一化处理，作为 Vision Transformer 的输入。\",\"为什么要归一化？\",\"Transformer 不像 CNN 有归一化操作，输入图像的数值尺度对训练稳定性和收敛非常重要。\",\"而 patch-wise transformer（如 ViT 或 BEiT）对输入的每个 patch 都很敏感，因此通常遵循 ImageNet 的 mean/std。\",\"visual_token_transform：VAE tokenizer 输入图像的标准化处理\",\"作用：处理 for_visual_tokens 图像，用于送入离散 VAE tokenizer，生成图像 patch 的 token 标签。\",\"如果使用 DALL·E 风格的 tokenizer，会使用 map_pixels 将图像从 [0, 1] 映射到 [−1, 1]。\",\"如果是自定义 tokenizer，使用 Inception 风格的均值方差进行归一化。\",\"为什么要特殊处理？\",\"视觉 tokenizer（如 DALL·E 的 VQ-VAE）对输入图像的数据分布非常敏感，训练和使用阶段都要一致。\",\"图像 token 是 BEiT 的训练目标（相当于 BERT 的词），其质量直接决定预训练效果。\"]},\"803\":{\"h\":\"BEiT主模型预训练\",\"t\":[\"下面给出的是BEiT主模型的预训练流程核心的代码实现:\",\"def main(args): # 1. 初始化 Vision Transformer 预训练模型 model = get_model(args) # 2. 构建 BEiT 预训练数据集（包括图像增强、遮挡、token 标签生成等） dataset_train = build_beit_pretraining_dataset(args) # 3. 加载离散 VAE 模型，用于将图像转换为离散的视觉 token（即 BEiT 的训练目标） d_vae = utils.create_d_vae( weight_path=args.discrete_vae_weight_path, # 离散VAE的权重路径 d_vae_type=args.discrete_vae_type, # 使用哪种类型的VAE（如\\\"dall-e\\\"或\\\"customized\\\"） device=device, # 使用的设备（GPU/CPU） image_size=args.second_input_size # 输入到VAE中的图像尺寸（通常小于主图像） ) # 4. 构建训练数据加载器 data_loader_train = torch.utils.data.DataLoader( dataset_train, sampler=sampler_train, # 用于分布式训练的采样器 batch_size=args.batch_size, # 每批次的图像数量 drop_last=True, # 如果最后一个batch数量不足，丢弃它 ) # 5. 训练过程：循环多个epoch for epoch in range(args.start_epoch, args.epochs): train_stats = train_one_epoch( model, # Vision Transformer 模型 d_vae, # 离散VAE，用于生成训练标签 data_loader_train, # 训练数据加载器 optimizer, # 优化器 device, # 设备 epoch, # 当前epoch数 loss_scaler, # 用于混合精度训练的loss scaler（如GradScaler） args.clip_grad, # 是否裁剪梯度 log_writer=log_writer, # 日志记录工具（如TensorBoard） start_steps=epoch * num_training_steps_per_epoch, # 当前epoch已训练的步数 lr_schedule_values=lr_schedule_values, # 当前epoch对应的学习率表 wd_schedule_values=wd_schedule_values, # 当前epoch对应的权重衰减表 )\",\"train_one_epoch 函数完成了 BEiT 预训练过程中的一个 epoch，包括以下步骤：\",\"生成视觉 token 作为标签（用 dVAE 编码器）；\",\"将图像送入模型并仅预测被 mask 的位置；\",\"使用交叉熵计算预测 token 和目标 token 的误差；\",\"反向传播并更新参数；\",\"def train_one_epoch(model: torch.nn.Module, d_vae: torch.nn.Module, data_loader: Iterable, optimizer: torch.optim.Optimizer, device: torch.device, epoch: int, loss_scaler, max_norm: float = 0, log_writer=None, lr_scheduler=None, start_steps=None, lr_schedule_values=None, wd_schedule_values=None): \\\"\\\"\\\" 执行模型的一个训练周期，包括前向传播、loss 计算、反向传播、参数更新。 \\\"\\\"\\\" for step, (batch, _) in enumerate(metric_logger.log_every(data_loader, print_freq, header)): # 每个 batch 包含： # - samples: 经过 patch_transform 的图像输入（供 Transformer 使用） # - images: 供离散 VAE 使用的图像输入（通常是不同尺寸的原图） # - bool_masked_pos: 遮挡掩码，表示哪些 patch 被 mask 掉了 samples, images, bool_masked_pos = batch with torch.no_grad(): # 使用 dVAE 将图像转为视觉 token（codebook 中的索引） # shape: [B, H*W] input_ids = d_vae.get_codebook_indices(images).flatten(1) # 展平掩码为 1D 向量，并转为布尔类型 bool_masked_pos = bool_masked_pos.flatten(1).to(torch.bool) # 提取被遮挡位置上的目标 token，作为训练标签 labels = input_ids[bool_masked_pos] with torch.cuda.amp.autocast(): # 前向传播： # - 输入为 samples（图像 patch） # - bool_masked_pos 指定模型只预测被遮挡的位置 # - return_all_tokens=False 表示只输出被 mask 的位置的预测结果 outputs = model(samples, bool_masked_pos=bool_masked_pos, return_all_tokens=False) # 计算交叉熵损失（只针对被 mask 的位置进行预测） loss = nn.CrossEntropyLoss()(input=outputs, target=labels) # 获取损失的标量值 loss_value = loss.item() # 如果 loss 出现 NaN 或 Inf，终止训练 if not math.isfinite(loss_value): print(\\\"Loss is {}, stopping training\\\".format(loss_value)) sys.exit(1) # 梯度清零 optimizer.zero_grad()\"]},\"804\":{\"h\":\"主模型代码实现\",\"t\":[\"VisionTransformerForMaskedImageModeling 的前向传播方法通过将输入图像切分为 patch 并编码为 token 表示，使用 [MASK] token 替换被遮挡的部分，然后加入位置编码并送入 Transformer 编码器提取上下文特征，最终通过分类头 lm_head 预测被遮挡位置的视觉 token，从而实现图像自监督预训练任务中的 masked image modeling。\",\"class VisionTransformerForMaskedImageModeling(nn.Module): def forward_features(self, x, bool_masked_pos): \\\"\\\"\\\" 前向特征提取： - 将图像转换为 patch embeddings - 用 [MASK] token 替换被遮挡的位置 - 加入 positional embedding - 送入 Transformer block 提取上下文特征 \\\"\\\"\\\" # 将输入图像 x 拆分为 patch，并投影为 token 表示（包括位置 mask） x = self.patch_embed(x, bool_masked_pos=bool_masked_pos) batch_size, seq_len, _ = x.size() # [B, N, D] # 准备 cls_token（每个样本一个） cls_tokens = self.cls_token.expand(batch_size, -1, -1) # [B, 1, D] # 准备 mask_token（用于替换被遮挡的位置） mask_token = self.mask_token.expand(batch_size, seq_len, -1) # [B, N, D] # 构造遮挡掩码 w（1 表示需要 mask 的位置），将被遮挡的 token 替换为 mask_token w = bool_masked_pos.unsqueeze(-1).type_as(mask_token) # [B, N, 1] x = x * (1 - w) + mask_token * w # 只在 mask 区域使用 mask_token，其它位置保留原 token # 拼接 cls_token 到序列最前面（ViT 默认行为） x = torch.cat((cls_tokens, x), dim=1) # [B, N+1, D] # 添加位置编码（如果存在） if self.pos_embed is not None: x = x + self.pos_embed # [B, N+1, D] # 应用 dropout（防止过拟合） x = self.pos_drop(x) # 计算相对位置偏置（如果定义了） rel_pos_bias = self.rel_pos_bias() if self.rel_pos_bias is not None else None # 逐层通过 transformer block 处理 for blk in self.blocks: x = blk(x, rel_pos_bias=rel_pos_bias) # 最终归一化输出 return self.norm(x) def forward(self, x, bool_masked_pos, return_all_tokens=False): \\\"\\\"\\\" 前向主函数： - 获取 transformer 提取的特征 - 只保留 patch token（排除 cls_token） - 决定是否返回所有 token 的输出，或仅返回被 mask 的位置预测结果 \\\"\\\"\\\" # 获取 transformer 输出（包含 cls_token） x = self.forward_features(x, bool_masked_pos=bool_masked_pos) # [B, N+1, D] # 去掉 cls_token，只保留 patch token x = x[:, 1:] # [B, N, D] if return_all_tokens: # 返回所有 patch 的预测结果（例如：可视化使用） # self.lm_head = nn.Linear(embed_dim, vocab_size) return self.lm_head(x) # [B, N, vocab_size] else: # 仅返回被遮挡位置的预测结果，用于 loss 计算 return self.lm_head(x[bool_masked_pos]) # [num_masked_tokens, vocab_size]\",\"patch_embed 方法负责将图像裁剪为一系列固定大小的 patch，然后将每个 patch 映射为一个 embed_dim 维的向量，从而形成可供 Transformer 处理的 token 序列。\",\"class PatchEmbed(nn.Module): \\\"\\\"\\\" Image to Patch Embedding 将输入图像划分为 patch，并通过一个卷积操作将每个 patch 映射为一个 embedding 向量 \\\"\\\"\\\" def __init__(self, img_size=224, patch_size=16, in_chans=3, embed_dim=768): super().__init__() # 将输入图像大小和 patch 大小转为 tuple 格式，例如 224 -> (224, 224) img_size = to_2tuple(img_size) patch_size = to_2tuple(patch_size) # 计算总 patch 数量 num_patches = (img_size[1] // patch_size[1]) * (img_size[0] // patch_size[0]) # 保存 patch 的二维结构形状 (height, width)，例如 (14, 14) self.patch_shape = (img_size[0] // patch_size[0], img_size[1] // patch_size[1]) self.img_size = img_size # 输入图像大小 self.patch_size = patch_size # 每个 patch 的大小 self.num_patches = num_patches # patch 的总数量 # 使用一个步长为 patch_size 的卷积操作来提取 patch 表示 # 输入维度为 in_chans（如3通道RGB），输出为 embed_dim（嵌入维度） self.proj = nn.Conv2d( in_chans, embed_dim, kernel_size=patch_size, stride=patch_size ) def forward(self, x, **kwargs): B, C, H, W = x.shape # 通过卷积将图像划分为 patch 并转换为 embedding 表示 # 输出形状: [B, embed_dim, H_patch, W_patch] x = self.proj(x) # 展平 patch 的空间维度为序列维度: [B, embed_dim, N_patches] -> [B, N_patches, embed_dim] x = x.flatten(2).transpose(1, 2) return x\"]},\"805\":{\"h\":\"DALL·E 论文解读\",\"t\":[\"DALL·E 论文解读\",\"论文链接: Zero-Shot Text-to-Image Generation 第三方代码实现: DALL-E\"]},\"806\":{\"h\":\"引言\",\"t\":[\"文本生成图像任务传统上是在固定的数据集上，借助复杂的模型架构、辅助损失函数或额外信息（如物体部分标签、分割掩码等）进行训练。虽然这些方法提升了生成效果，但生成图像中仍常见严重问题：\",\"现存问题：\",\"物体扭曲，形状不自然\",\"物体摆放不合逻辑，空间关系混乱\",\"前景与背景融合不自然，视觉体验差\",\"这些问题限制了模型在实际应用中的表现。 从2015年起，研究者尝试用不同生成模型改善文本到图像的转换。最初，Mansimov 等人用变分自编码器 DRAW 模型进行尝试；随后，Reed 等人用生成对抗网络提升了图像质量和泛化能力。此后，研究不断融合新的方法：\",\"多尺度生成器架构\",\"引入注意力机制和辅助损失\",\"利用额外条件信息，如除文本外的其他标签\",\"此外，基于能量模型的方法和优化预训练跨模态模型输入的方式也出现，进一步提升了样本质量。尽管如此，生成的图像依然存在明显的瑕疵。\",\"近期，大规模模型和海量数据的结合，尤其是自回归 Transformer 架构，已在文本、图像和音频领域取得显著成果。相比之下，文本生成图像的研究多基于较小数据集（如 MS-COCO、CUB-200），模型规模和数据量可能是性能瓶颈。本研究训练了一个参数量为 亿的自回归 Transformer，使用了从互联网收集的 亿图文对，结果表明：\",\"该模型能够灵活生成高质量图像，且通过自然语言实现控制\",\"在 MS-COCO 数据集的零样本测试中表现优异，不依赖任何训练标签\",\"人类评估显示，生成图像在 的情况下优于之前专门训练的模型\",\"模型具备一定的图像到图像转换能力，这一复杂任务以前通常需要专门设计的方案才能实现\",\"这表明，大规模统一建模方法具备强大的泛化与多任务能力。\"]},\"807\":{\"h\":\"方法\",\"t\":[\"我们的目标是训练一个 Transformer，以自回归的方式将文本和图像 token 作为单一的数据流进行建模。然而，若直接使用像素作为图像 token，对于高分辨率图像将需要大量的内存。似然（Likelihood）目标倾向于优先建模像素之间的短程依赖，因此，大量的模型容量会花在捕捉高频细节上，而非低频结构上——而低频结构才是使得物体在视觉上可被我们辨认的关键。\",\"为了解决这些问题，我们采用了类似的两阶段训练流程：\",\"阶段 1：我们训练一个离散变分自编码器（dVAE）¹，将每个 256×256 的 RGB 图像压缩成一个 32×32 的图像 token 网格，其中每个元素可以取 8192 种可能的值。这使得 Transformer 的上下文长度减少了 192 倍，而视觉质量没有显著下降（见图 1）。\",\"阶段 2：我们将最多 256 个 BPE 编码的文本 token 与 32×32 = 1024 个图像 token 拼接起来，训练一个自回归 Transformer 来建模文本和图像 token 的联合分布。\",\"整体流程可以被视作在最大化模型分布在图像 、标题 以及 RGB 图像编码 token 上的联合似然的证据下界（ELB）。我们对该分布建模的因式分解为：\",\"其下界为：\",\"其中：\",\" 表示由 dVAE 编码器在给定 RGB 图像 时生成的 32×32 图像 token 的分布；\",\" 表示由 dVAE 解码器在给定图像 token 时生成 RGB 图像的分布；\",\" 表示由 Transformer 建模的文本和图像 token 的联合分布。\",\"需要注意的是，该下界仅在 时成立，而在实践中我们发现使用更大的 值更有帮助。接下来的小节将更详细地介绍这两个阶段。\",\"关于上面部分公式的补充解读:\",\"：原始 RGB 图像\",\"：文本标题（caption）\",\"：由 dVAE 编码得到的图像 token（32×32 网格，每个位置是 8192 维离散值）\",\"这样一来，整个生成过程可以想成：\",\"先从 Transformer 的联合先验 中，生成一段文字 token 和对应的图像 token；\",\"再用 dVAE 解码器 把图像 token 变成像素级别的 RGB 图像。\",\"意思是： 图像和文本的联合概率，可以拆成 “根据文本和图像 token 生成像素图像” × “文本和图像 token 的联合概率”。\",\"这样分开好处是：\",\" 专门学好像素生成（dVAE 解码器）\",\" 专门学好文本与图像 token 的联合分布（Transformer）\",\"互不干扰，分工明确。\",\"ELBO 公式的含义\",\"因为 是离散变量，我们没法直接优化 ，只能最大化它的证据下界（ELBO）：\",\"第一项 : 就是重构项，要求 dVAE 解码出来的图像尽量接近原图。\",\"第二项 : 是正则项，要求编码器的输出分布 要接近先验分布 。 控制这项的权重（ 是标准 ELBO，实际中用更大值鼓励更均匀的码本利用）。\",\"两阶段如何对应这个公式\",\"阶段一（学 ）: 先只看图像部分，训练 dVAE\",\"：编码器把图像变成 token；\",\"：解码器重构图像；这一步不动 。\",\"阶段二（学 ）: 固定 dVAE 编码器/解码器，直接用编码后的 作为离散符号，与文本 token 一起训练 Transformer 学 。\",\"ELBO 公式推导过程\",\"这里：\",\"：dVAE 解码器\",\"：Transformer 先验\",\"我们希望得到：\",\"但由于 是潜变量，这个求和很难直接算。在变分推断中，我们会给 引入一个可计算的近似后验：\",\"然后套入 Jensen 不等式 （ 是凹函数，所以 ）：\",\"注意到：\",\"如果把 也一起看作潜变量的一部分（这里他们写作 ），就会得到文中那种 KL 形式：\",\"然后他们在 KL 前乘了一个经验选择的系数 （即 β-VAE 思想）。本质上就是：\",\"用变分后验 近似真实后验 ；\",\"代入 Jensen 不等式得到下界；\",\"分离出“重构项”和“KL 正则项”；\",\"在 KL 项前加权得到 β-ELBO。\"]},\"808\":{\"h\":\"阶段一：学习视觉码本（Visual Codebook）\",\"t\":[\"在第一阶段训练中，我们最大化关于 和 的 ELB，这相当于在图像上单独训练一个 dVAE。我们将初始先验 设为对 个码本向量的均匀分类分布，并将 设为由编码器输出的 32×32 网格上每个空间位置的 8192 维 logits 所参数化的分类分布。\",\"此时，ELB 的优化变得困难：由于 是离散分布，我们无法使用重参数化梯度来最大化它。通过结合在线聚类分配过程与直通估计器可以解决这一问题，但我们则使用 Gumbel-Softmax 松弛，将对 的期望替换为对 的期望，其中当温度 时，该松弛会变得精确。 的似然使用 对数拉普拉斯分布 进行评估（推导见附录 A.3）。\",\"我们使用 Adam 优化该松弛的 ELB，并采用指数加权的迭代平均（iterate averaging）。附录 A.2 给出了完整的超参数描述，但我们发现以下几点对稳定训练尤其重要：\",\"松弛温度与步长的退火策略：我们将 退火至 ，这样即可缩小松弛后的验证 ELB 与使用 而非 的真实验证 ELB 之间的差距；\",\"在编码器末端与解码器开头使用 1×1 卷积：我们发现，在松弛操作附近减小卷积感受野有助于其对真实 ELB 的泛化；\",\"对编码器和解码器残差块的输出激活乘以一个较小的常数，以确保初始化时的稳定训练。\",\"我们还发现，将 KL 权重增加到 能促进更好的码本利用率，并最终在训练结束时得到更小的重构误差。\"]},\"809\":{\"h\":\"阶段二：学习先验\",\"t\":[\"在第二阶段中，我们固定 和 ，通过最大化关于 的 ELB 来学习文本与图像 token 的先验分布。在这里， 由一个 120 亿参数的稀疏 Transformer 表示。\",\"给定一对文本-图像数据，我们将小写化的标题用 BPE 编码，最多 256 个 token，词汇表大小为 16,384；图像则用 32×32 = 1024 个 token 表示，词汇表大小为 8192。图像 token 由 dVAE 编码器 logits 通过 argmax 采样得到（不添加 Gumbel 噪声）。最后，将文本和图像 token 拼接，并作为单一的数据流进行自回归建模。\",\"该 Transformer 是一个 仅解码器（decoder-only） 架构，其中每个图像 token 在其 64 层自注意力层中的任一层都可以访问所有文本 token。完整架构见附录 B.1。模型中使用了三种不同的自注意力掩码：\",\"文本到文本部分使用标准的因果掩码；\",\"图像到图像部分则使用行、列或卷积注意力掩码。\",\"我们将文本标题的最大长度限制为 256 个 token，但在最后一个文本 token 与“图像起始 token”之间的“填充”位置处理方式并不完全确定。一种方法是在自注意力运算中将这些 token 的 logits 设为 。但我们选择为每个 256 文本位置单独学习一个特殊的填充 token，仅在无对应文本 token 时使用。在 Conceptual Captions 的初步实验中，我们发现这种做法虽然验证集损失更高，但在分布外的标题上表现更好。\",\"我们将文本与图像 token 的交叉熵损失分别按批次中该类型 token 的总数进行归一化。由于我们主要关注图像建模，将文本的交叉熵损失乘以 ，图像的交叉熵损失乘以 。目标函数使用 Adam 优化，并采用指数加权迭代平均；训练细节见附录 B.2。我们保留了大约 60.6 万张图像作为验证集，在收敛时未发现过拟合迹象。\"]},\"810\":{\"h\":\"数据收集\",\"t\":[\"我们在 Conceptual Captions 数据集上进行了最高至 12 亿参数模型的初步实验，该数据集包含 330 万对文本-图像对，是 MS-COCO 的扩展版本。\",\"为了扩展到 120 亿参数规模，我们从互联网收集了 2.5 亿对文本-图像数据，构建了一个与 JFT-300M 规模相当的数据集。该数据集不包含 MS-COCO，但包含 Conceptual Captions 以及经过筛选的 YFCC100M 子集。由于 MS-COCO 是从 YFCC100M 创建的，因此我们的训练数据中包含了一部分 MS-COCO 验证集图像（但不包括其标题）。在第 3 节的定量结果中，我们对此进行了控制，发现这对结果没有显著影响。关于数据收集过程的更多细节见附录 C。\"]},\"811\":{\"h\":\"采样生成\",\"t\":[\"我们用一个预训练的对比模型（如: CLIP）来对从 Transformer 生成的图像进行重新排序。给定一条文字描述和一张候选图像，这个对比模型会根据图像和文字的匹配程度给出一个评分。\",\"图 6 展示了当我们从更多的样本数量 N 中选出排名前 k 的图像时，效果是如何变化的。这个过程可以理解为一种由语言引导的搜索，也类似于 Xu 等人（2018）提出的辅助文本-图像匹配的训练方法。\",\"除非特别说明，文中所有用于展示效果和评测的样本，都是在没有调整温度（即温度 t=1，图 2 除外）的情况下生成的，并且都采用了用 N=512 个样本进行重排序的策略。\",\"混合精度训练和分布式优化部分略过。\"]},\"812\":{\"h\":\"DALL·E 模型代码解读\",\"t\":[\"DALL·E 模型代码解读\",\"论文链接: Zero-Shot Text-to-Image Generation 第三方代码实现: DALL-E\"]},\"813\":{\"h\":\"代码实现\",\"t\":[\"DALL·E 将 文本-图像生成 问题建模为一个自回归语言建模任务，即将文本 token 和图像 token 拼接起来，作为一个统一的序列进行训练，从而学会生成图像的离散表示。 具体的流程如下图所示:\",\"DALL-E 模型前向传播整体流程\"]},\"814\":{\"h\":\"模型初始化\",\"t\":[\"我们需要通过 DALL-E 模型的初始化流程，来熟悉模型中使用到的一些参数及其含义:\",\"def __init__( self, *, dim, # Transformer 的隐藏维度 vae, # 编码图像的 VAE 模型（用于 image token 的提取） num_text_tokens = 10000, # 文本词表大小（不含 position padding token） text_seq_len = 256, # 文本序列最大长度 depth, # Transformer block 层数 heads = 8, # Attention 头数 dim_head = 64, # 每个 attention head 的维度 reversible = False, # 是否使用 reversible transformer attn_dropout = 0., # attention dropout 概率 ff_dropout = 0, # feedforward dropout 概率 sparse_attn = False, # 是否使用稀疏 attention attn_types = None, # 多种 attention 类型（可选） loss_img_weight = 7, # 图像损失在最终 loss 中的权重 stable = False, # 是否使用 numerically stable 的 norm sandwich_norm = False, # 是否采用 sandwich norm 策略（前中后都加 layernorm） shift_tokens = True, # 是否对输入 token 做 right shift（训练） rotary_emb = True, # 是否使用 rotary embedding（相对位置编码） shared_attn_ids = None, # 用于模块共享的 attention 层 ID（可选） shared_ff_ids = None, # 用于模块共享的 feedforward 层 ID（可选） share_input_output_emb = False, # 是否输入输出 embedding 权重共享 optimize_for_inference = False, # 是否为推理模式优化结构 ):\",\"这里关于 text_seq_len 参数和文本词空间的构成需要简单说明一下:\",\"图像 Token 相关计算:\",\" image_size = vae.image_size # 输入图像大小（例如 256x256） num_image_tokens = vae.num_tokens # 图像 token 的词表大小 image_fmap_size = (image_size // (2 ** vae.num_layers)) # 编码后 feature map 的大小 image_seq_len = image_fmap_size ** 2 # 图像 token 序列长度（flatten 之后）\",\"vae.num_layers 是 VAE 编码器中的卷积层个数，每层下采样一次（一般是 stride=2）。 图像经过 VAE 编码器下采样后，特征图的边长 = 原图边长 / 2^层数\",\"图像输入经过 VAE 编码后，变成了 image_fmap_size × image_fmap_size 的二维 token map，展平后是 image_seq_len 长度的一维序列，供 Transformer 使用。\",\"文本 token 总数调整（添加 padding token）:\",\" num_text_tokens = num_text_tokens + text_seq_len # 每个位置预留一个特殊 padding token\",\"位置编码设置 :\",\" self.text_pos_emb = nn.Embedding(text_seq_len + 1, dim) if not rotary_emb else always(0) # 文本位置编码（+1 是为了 <BOS> token），如果用 rotary 就返回 0 self.image_pos_emb = AxialPositionalEmbedding(dim, axial_shape=(image_fmap_size, image_fmap_size)) if not rotary_emb else always(0) # 图像使用二维 axial 位置编码（默认）\",\"保存配置参数 :\",\" self.num_text_tokens = num_text_tokens self.num_image_tokens = num_image_tokens self.text_seq_len = text_seq_len self.image_seq_len = image_seq_len seq_len = text_seq_len + image_seq_len # 总序列长度 total_tokens = num_text_tokens + num_image_tokens # 总词表大小 self.total_tokens = total_tokens self.total_seq_len = seq_len\",\"冻结 VAE 权重（不参与训练）:\",\" self.vae = vae set_requires_grad(self.vae, False)\",\"构造 Transformer 主体 :\",\" self.transformer = Transformer( dim = dim, causal = True, # 自回归模型 seq_len = seq_len, depth = depth, heads = heads, dim_head = dim_head, reversible = reversible, attn_dropout = attn_dropout, ff_dropout = ff_dropout, attn_types = attn_types, image_fmap_size = image_fmap_size, sparse_attn = sparse_attn, stable = stable, sandwich_norm = sandwich_norm, shift_tokens = shift_tokens, rotary_emb = rotary_emb, shared_attn_ids = shared_attn_ids, shared_ff_ids = shared_ff_ids, optimize_for_inference = optimize_for_inference, )\",\"因为为每个 padding 位置保留了唯一 token id，Transformer 不再需要外部的 pad mask。\",\"输出 projection 层（Logits）:\",\" self.to_logits = nn.Sequential( nn.LayerNorm(dim), nn.Linear(dim, self.total_tokens), # 输出维度为整个 text + image 的 token vocab )\",\"构造 token embedding 层（输入）:\",\" if share_input_output_emb: # 如果启用权重共享，将 to_logits 的 Linear 拆分作为共享矩阵 self.text_emb = SharedEmbedding(self.to_logits[1], 0, num_text_tokens) self.image_emb = SharedEmbedding(self.to_logits[1], num_text_tokens, total_tokens) else: self.text_emb = nn.Embedding(num_text_tokens, dim) self.image_emb = nn.Embedding(num_image_tokens, dim)\",\"构造 Logits Mask:\",\" seq_range = torch.arange(seq_len) # 序列中每个 token 的位置编号（0~seq_len-1） logits_range = torch.arange(total_tokens) # 总词表中的每个 token id（0~total_tokens-1） seq_range = rearrange(seq_range, 'n -> () n ()') # 变成 shape (1, seq_len, 1) logits_range = rearrange(logits_range, 'd -> () () d') # 变成 shape (1, 1, total_tokens) logits_mask = ( ((seq_range >= text_seq_len) & (logits_range < num_text_tokens)) | ((seq_range < text_seq_len) & (logits_range >= num_text_tokens)) ) # 如果位置在图像段（text_seq_len之后），却输出 text token → 屏蔽 # 如果位置在文本段（text_seq_len之前），却输出 image token → 屏蔽 self.register_buffer('logits_mask', logits_mask, persistent=False) # 保存 mask 到 buffer（不会被模型训练修改）\",\"由于文本token和图像token被拼接在一起，作为统一的序列输入Transformer进行编码，\",\"且文本词空间和图像离散视觉词空间也通过视觉词索引偏移的方式完成了统一，\",\"因此才有了Transformer可以一次性预测出每个位置对应的Next Token能力，\",\"但问题就在于属于某个文本Token位置处的预测结果向量中，其反映的实际是整个统一词空间上的概率分布，如果概率最高的那个Token是图像Token，那么就会导致模态混乱了，\",\"为了解决这个问题，作者引入了 Logits Mask , 如果当前待预测Token位置属于文本词，则将其概率分布中的离散视觉词索引空间对应的概率分布设置为0，\",\"反之，如果当前待预测Token位置属于离散视觉词，则将其概率分布中的文本词索引空间对应的概率分布设置为0，\",\"具体来说:\",\"import torch # 假设配置 text_seq_len = 4 # 输入文本序列长度 image_seq_len = 2 # 每个图像由两个离散视觉token进行表示 total_seq_len = text_seq_len + image_seq_len # 总输入序列长度 num_text_tokens = 4 # 文本词表大小 num_image_tokens = 5 # 离散视觉词表大小 total_tokens = num_text_tokens + num_image_tokens # 总词表大小 # 构造 logits_mask seq_range = torch.arange(total_seq_len).view(1, total_seq_len, 1) logits_range = torch.arange(total_tokens).view(1, 1, total_tokens) logits_mask = ((seq_range >= text_seq_len) & (logits_range < num_text_tokens)) | \\\\ ((seq_range < text_seq_len) & (logits_range >= num_text_tokens)) # 将 logits_mask 转为 int 展示（True->1, False->0） logits_mask_int = logits_mask.int()[0] # 只展示第一个 batch 维度 print(logits_mask_int)\",\"输出结果:\",\"# 前4个位置为文本token，后2个位置为图像token tensor([[0, 0, 0, 0, 1, 1, 1, 1, 1], # 对于每个token来说，统一词空间大小为9，其中前4维为词空间索引，后5维为离散视觉词空间索引 [0, 0, 0, 0, 1, 1, 1, 1, 1], # 对于文本token，将离散视觉词空间索引对应的概率分布设置为0 (这里设置为1，是为了后续乘上一个最小值) [0, 0, 0, 0, 1, 1, 1, 1, 1], [0, 0, 0, 0, 1, 1, 1, 1, 1], [1, 1, 1, 1, 0, 0, 0, 0, 0], # 对于图像token，将文本词索引空间对应的概率分布设置为0 (这里设置为1，是为了后续乘上一个最小值) [1, 1, 1, 1, 0, 0, 0, 0, 0]], dtype=torch.int32)\"]},\"815\":{\"h\":\"前向传播流程\",\"t\":[\"本节最开始给出的前向传播流程图已经清晰展示了 DALL·E 模型的前向传播流程，下面我们通过代码详细来看一下具体实现细节:\",\"随机对输入的文本条件进行 Dropout\",\"def forward( self, text, image=None, return_loss=False, null_cond_prob=0., cache=None, ): # 获取 batch size、device 和 transformer 的最大序列长度 batch, device, total_seq_len = text.shape[0], text.device, self.total_seq_len # 以一定概率随机删除文本条件（用于训练时的条件 dropout） if null_cond_prob > 0: null_mask = prob_mask_like((batch,), null_cond_prob, device=device) text *= rearrange(~null_mask, 'b -> b 1') # 如果 null_mask=True，则整条 text 设为 0（即无条件）\",\" def prob_mask_like(shape, prob, device): return torch.zeros(shape, device = device).float().uniform_(0, 1) < prob\",\"DALL·E 的目标不是只会“根据文本生成图像”，还希望它能：\",\"有条件生成（text → image）\",\"无条件生成（随机 → image）\",\"通过让一部分样本在训练时不给文本输入，让模型也能学到“如何仅靠图像生成图像”。\",\"为每一个padding token分配一个唯一的词索引\",\" # self.num_text_tokens - self.text_seq_len 是计算 padding token 在文本词索引空间中的起始索引 text_range = torch.arange(self.text_seq_len, device=device) + (self.num_text_tokens - self.text_seq_len) text = torch.where(text == 0, text_range, text) # 将 padding token 替换为唯一的 token ID\",\"文本序列开头加上 <bos> token , 作为自回归预测的开始标志\",\" # 在文本序列开头加上 <bos> token（值为0） text = F.pad(text, (1, 0), value=0)\",\"文本 token embedding 与 位置编码\",\" # 文本 token embedding 与位置编码 tokens = self.text_emb(text) tokens += self.text_pos_emb(torch.arange(text.shape[1], device=device)) seq_len = tokens.shape[1] # 当前 token 序列长度（仅包含文本部分）\",\"输入图像编码为离散的视觉Token，视觉Token embedding 与 位置编码 ，最后与文本Token embedding 拼接，作为送入 Transformer 的输入\",\" # 如果输入了图像（且非空），处理图像 embedding if exists(image) and not is_empty(image): is_raw_image = len(image.shape) == 4 # 如果是原始图像（B, C, H, W） if is_raw_image: image_size = self.vae.image_size channels = self.vae.channels # 确保图像尺寸正确 assert tuple(image.shape[1:]) == (channels, image_size, image_size), \\\\ f'invalid image of dimensions {image.shape} passed in during training' # 使用 VAE 将原始图像编码为离散 codebook indices (after flatten) image = self.vae.get_codebook_indices(image) image_len = image.shape[1] image_emb = self.image_emb(image) # 图像 token embedding image_emb += self.image_pos_emb(image_emb) # 图像位置编码 # 将文本和图像的 embedding 拼接 tokens = torch.cat((tokens, image_emb), dim=1) seq_len += image_len # 更新总长度\",\"\\\"右移\\\": 删除序列最后一个token，因为其不参与Next Token Prediction；(训练优化Trick不进行讲解)\",\" # 如果 token 总长度超过模型最大长度，则裁剪掉最后一个 token（训练时末尾 token 不需要预测） if tokens.shape[1] > total_seq_len: seq_len -= 1 tokens = tokens[:, :-1] # 如果启用了稳定训练策略（stabilization trick） if self.stable: alpha = 0.1 tokens = tokens * alpha + tokens.detach() * (1 - alpha) # 如果使用了 KV Cache（用于推理阶段），只保留最后一个 token if exists(cache) and cache.get('offset'): tokens = tokens[:, -1:] # 送入 transformer 主体 out = self.transformer(tokens, cache=cache)\",\"投影到统一词空间，应用 logits mask ，防止跨模态预测\",\" # 如果启用了稳定策略，对输出做归一化 if self.stable: out = self.norm_by_max(out) # 得到每个位置上的分类 logits（预测 token） logits = self.to_logits(out) # 构造 logits mask：限制哪些位置可以预测哪些 token（防止跨模态预测） logits_mask = self.logits_mask[:, :seq_len] if exists(cache) and cache.get('offset'): logits_mask = logits_mask[:, -1:] max_neg_value = -torch.finfo(logits.dtype).max # -inf 替代值 logits.masked_fill_(logits_mask, max_neg_value) # 用 -inf 屏蔽不合法预测\",\"是否提前中断返回 logits\",\" # 更新 KV Cache 的偏移量（用于增量推理） if exists(cache): cache['offset'] = cache.get('offset', 0) + logits.shape[1] # 如果不要求计算损失，直接返回 logits if not return_loss: return logits\",\"计算文本token和视觉token预测结果与原Label的交叉熵损失\",\" # 训练时必须提供图像（否则无法计算图像 token 的预测损失） assert exists(image), 'when training, image must be supplied' # 将图像 token 的索引整体加偏移（让图像 token ID 与文本 token 不重叠） offsetted_image = image + self.num_text_tokens # 构造预测标签：文本去掉 <bos>（text[:, 1:]），接上图像 token labels = torch.cat((text[:, 1:], offsetted_image), dim=1) # logits 维度从 [B, N, C] 变成 [B, C, N]，以匹配 cross_entropy 的输入格式 logits = rearrange(logits, 'b n c -> b c n') # 计算文本部分的 cross-entropy loss（前 self.text_seq_len 个 token） loss_text = F.cross_entropy(logits[:, :, :self.text_seq_len], labels[:, :self.text_seq_len]) # 计算图像部分的 cross-entropy loss loss_img = F.cross_entropy(logits[:, :, self.text_seq_len:], labels[:, self.text_seq_len:]) # 按照权重加权融合 loss（图像损失通常占更大比例） loss = (loss_text + self.loss_img_weight * loss_img) / (self.loss_img_weight + 1) return loss\",\"在 DALL·E 的训练中，文本 token 和图像 token 的数量差别很大（通常图像 token 远多于文本 token），如果直接把它们的交叉熵损失简单相加，图像部分的 loss 会“淹没”文本部分，导致模型过度关注图像而忽视文本。为了解决这个不平衡问题，DALL·E 在合并两部分损失时引入了一个 图像损失权重self.loss_img_weight（通常设置为 7），具体做法如下：\",\"loss = (loss_text + self.loss_img_weight * loss_img) / (self.loss_img_weight + 1)\",\"loss_text：文本部分的平均交叉熵损失\",\"loss_img ：图像部分的平均交叉熵损失\",\"self.loss_img_weight：图像损失在总损失中的相对重要性系数（>1 时放大图像 loss）\",\"当 loss_img_weight = 7 时，公式相当于：\",\"也就是把文本损失和图像损失当作 1:7 的比例来融合。除以 (self.loss_img_weight + 1) 可以 保持总损失的数值 scale 大致与单一部分损失相同，否则会直接把 loss 放大 8 倍，不利于学习率等超参数设置。例如：\",\"若不除以，合并后 loss 规模 ≈ \",\"除以后 loss 规模 ≈ ，整体仍在合理区间\",\"通过给图像损失设置更高的权重，平衡文本和图像两部分的训练目标，同时保持总损失数值稳定。\"]},\"816\":{\"h\":\"Classifier-Free Guidance（无条件引导技术）\",\"t\":[\"Classifier-Free Guidance（CFG）本质上是一种“在同一个模型内部做有条件与无条件两种预测，然后按比例混合”以强化条件信号的方法。它的核心思想可以分为三个步骤：\",\"无条件预测\",\"令模型忽略输入的条件（例如将 null_cond_prob=1.0），只靠自身学到的“图像先验”去预测下一个 token／像素。输出我们记作\",\"有条件预测\",\"再次用原始的条件（如文本描述）去预测，得到\",\"线性混合强化\",\"将两者按下式混合：\",\"其中 （cond_scale）是一个大于 1 的放大系数。这样做的意义在于：\",\" 正好捕捉了“条件对输出的额外影响”，\",\"放大这个差值就能让模型更“听话”地跟随条件（例如更准确地按照提示文本生成图像），\",\"而基础的“无条件”部分保证了生成的多样性与样本质量。\",\"为什么它能工作？\",\"单模型实现：不需要额外训练一个对比判别器或辅助网络，只利用模型自身“有条件/无条件”两种模式。\",\"稳定平衡： 时退化为普通有条件生成； 时增强条件影响；如果条件本身模糊，过大 会丧失多样性。\",\"实际效果：在图像或序列生成任务中，CFG 能显著提升条件相关性（如文本与生成图像的紧密契合度），同时保留一定的随机性和自然度。\",\"这种技术被广泛应用于扩散模型、Transformer-based 自回归模型（如 DALL·E）等条件生成场景，是当前最简单、最高效的“无判别器”引导方法。\",\"具体代码实现过程如下:\",\" def forward_with_cond_scale(self, *args, cond_scale = 1, cache = None, **kwargs): if cond_scale == 1: return self(*args, **kwargs) prev_cache = cache.copy() if exists(cache) else None logits = self(*args, cache = cache, **kwargs) # discovery by Katherine Crowson # https://twitter.com/RiversHaveWings/status/1478093658716966912 null_cond_logits = self(*args, null_cond_prob = 1., cache = prev_cache, **kwargs) return null_cond_logits + (logits - null_cond_logits) * cond_scale\"]},\"817\":{\"h\":\"推理过程: 图文联合生成图像\",\"t\":[\"DALL-E 的推理过程实际执行过程中，不仅可以传入文本条件，还可以传入初始图像条件，从而实现图文联合生成 (text + image condition) , 具体代码实现如下:\",\"@torch.no_grad() # 不计算梯度，用于推理模式，节省显存 @eval_decorator # 将模型切换到 eval 模式（如关闭 dropout、norm 统计冻结等），确保一致性 def generate_images( self, text, # 输入的文本 token 序列（已经 embed 好的 token id） *, clip = None, # 可选：用于对生成图像进行 CLIP 打分的模型 filter_thres = 0.5, # Top-k 采样时的阈值，控制生成 token 的多样性 temperature = 1., # Gumbel softmax 的温度参数，控制采样随机性 img = None, # 可选：用于 image priming 的起始图像 num_init_img_tokens = None,# 用于 priming 的起始 image token 数量 cond_scale = 1., # CFG 强化系数（1 表示不强化） use_cache = False, # 是否启用 KV 缓存加速 ): # 一些常用变量的引用 vae, text_seq_len, image_seq_len, num_text_tokens = ( self.vae, self.text_seq_len, self.image_seq_len, self.num_text_tokens ) total_len = text_seq_len + image_seq_len # 整个序列的总长度 text = text[:, :text_seq_len] # 限制输入文本长度不超过最大 text_seq_len out = text # 初始化输出 token 序列 # -------------------------- # Optional: 图像 priming # -------------------------- if exists(img): image_size = vae.image_size assert img.shape[1:] == (3, image_size, image_size), \\\\ f'input image must have the correct image size {image_size}' # 编码图像为 VQ token 序列 indices = vae.get_codebook_indices(img) # 默认采样前 14 × 32 = 448 个图像 token（约占 43.75%） num_img_tokens = default(num_init_img_tokens, int(0.4375 * image_seq_len)) assert num_img_tokens < image_seq_len, 'priming token 数不能超过图像 token 总长度' # 仅使用前 num_img_tokens 个 image token 来进行条件 priming indices = indices[:, :num_img_tokens] # 将这些图像 token 拼接到文本后面作为起始序列 out = torch.cat((out, indices), dim = -1)\",\"Image Priming for Conditional Image Generation 也可以理解为是一种 图像引导生成（Image Conditioning），就像 文本 prompt 一样引导生成内容，只不过它是 图像 prompt 。\",\"并且我们只拼接一部分（如前 14×32 个 token ≈ 左上角区域）：给出一定图像引导，让模型知道「风格/结构/颜色」，但留出空间继续生成图像后续内容。\",\"模式\",\"条件输入\",\"效果\",\"文本生成图像\",\"仅文本 token\",\"从零生成完整图像\",\"图像补全\",\"文本 token + 部分图像 token（来自真实图像）\",\"在已有图像基础上补全未提供区域\",\" # -------------------------- # 生成 token 序列（从起始长度到 total_len） # -------------------------- prev_cache = None cache = {} if use_cache else None # KV 缓存机制（可加速 transformer 推理） for cur_len in range(out.shape[1], total_len): is_image = cur_len >= text_seq_len # 当前 token 属于图像部分 # 每一步构造 text / image token 序列（注意有 padding） text, image = out[:, :text_seq_len], out[:, text_seq_len:] # 使用 CFG 技术进行条件引导预测 logits logits = self.forward_with_cond_scale(text, image, cond_scale=cond_scale, cache=cache) # 取当前时间步（只关心最后一个 token 的 logits） logits = logits[:, -1, :] # top-k 采样（过滤掉概率低的 token） filtered_logits = top_k(logits, thres=filter_thres) # 使用 gumbel softmax 进行随机采样，得到一个 token id sample = gumbel_sample(filtered_logits, temperature=temperature, dim=-1) # 如果是 image token，需要减去偏移（因为 logit 空间 = [text_vocab, image_vocab]） sample -= (num_text_tokens if is_image else 0) # 拼接新生成的 token out = torch.cat((out, sample[:, None]), dim=-1) # 拆分输出序列 text_seq = out[:, :text_seq_len] # 最终文本 token 序列 img_seq = out[:, -image_seq_len:] # 最终图像 token 序列（后 image_seq_len 个） # 解码图像 token 为实际图片 images = vae.decode(img_seq) # 若提供了 CLIP，则使用其打分 if exists(clip): scores = clip(text_seq, images, return_loss=False) return images, scores return images\"]},\"818\":{\"h\":\"Top-K 采样\",\"t\":[\"Top-K 采样是一种常用的生成模型采样方法，用于从模型输出的 logits 中选择概率最高的 K 个 token 作为下一个 token。\",\"def top_k(logits, thres=0.5): # 获取最后一维的大小，即 token 的数量 num_logits = logits.shape[-1] # 根据阈值计算 top-k 的 k 值，确保至少选一个 # 例如 thres=0.5 表示保留 top 50% 的 logits k = max(int((1 - thres) * num_logits), 1) # 从 logits 中获取 top-k 的值 val 及其对应的索引 ind val, ind = torch.topk(logits, k) # 构造一个与 logits 相同形状的 tensor，初始值为 -inf（负无穷） # 用于屏蔽非 top-k 的 logits probs = torch.full_like(logits, float('-inf')) # 将 top-k 的值 scatter 到对应的位置（其余位置仍为 -inf） probs.scatter_(1, ind, val) # 返回经过筛选后的 logits，非 top-k 的位置为 -inf return probs\"]},\"819\":{\"h\":\"Gumbel Sampling\",\"t\":[\"Gumbel Sampling（Gumbel-Max 采样），它是一个常用于离散分布中采样的技巧，尤其适用于生成模型中从 logits 中以概率方式采样一个 token，避免直接用 softmax → multinomial。\",\"其中 ，这是一个从 Gumbel 分布采样的噪声。\",\"def gumbel_sample(t, temperature=1., dim=-1): # 将 logits t 除以温度 temperature（控制随机性），加上 Gumbel 噪声后取 argmax 采样 return ((t / temperature) + gumbel_noise(t)).argmax(dim=dim)\",\"在代码中：\",\"t 是 logits，即模型输出的每个 token 的打分；\",\"gumbel_noise(t) 为每个位置生成 Gumbel(0,1) 噪声；\",\"(t / temperature) 是用温度控制 logits 的“平滑程度”；\",\"argmax(dim=dim) 就是从分布中采样一个 token。\",\"temperature 控制采样的随机程度：\",\"趋近 0 → 趋近贪心采样（最大值）；\",\"趋近 ∞ → 更加随机，平滑采样。\",\"gumbel_noise 的加入使得采样变为“有噪声的 argmax”，而不是简单地选最大值。\"]},\"820\":{\"h\":\"“语言建模能力”的回溯性验证\",\"t\":[\"DALL·E 是一个 文本-图像联合建模（joint modeling） 的 Transformer：\",\"它的输入是 text_tokens + image_tokens 拼接而成的序列；\",\"输出是对整个序列的预测（自回归建模）；\",\"模型头部输出 logits，既可用于预测文本 token，也可用于预测图像 token。\",\"generate_texts 方法就是在 复用这个模型的 text 生成能力，可以视作：\",\"🔸 “测试 DALL·E 是否真正学会了语言建模部分”，\",\"🔸 “是否理解 prompt 的语言结构”。\",\"@torch.no_grad() # 表示该函数中不进行梯度计算，节省内存，提高推理效率 @eval_decorator # 将模型设置为 evaluation 模式，禁用 dropout 等训练行为 def generate_texts( self, tokenizer, # 分词器对象，用于将输入文本编码为 token 序列 text = None, # 输入文本（可为空字符串） *, filter_thres = 0.5, # top-k 采样的阈值，控制保留多少 logits 值 temperature = 1. # Gumbel Softmax 的温度系数，调节随机性 ): text_seq_len = self.text_seq_len # 设定文本序列的最大长度（固定） # 如果没有输入文本，默认从 token_id 为 0 的 token 开始（如 [BOS]） if text is None or text == \\\"\\\": text_tokens = torch.tensor([[0]]).cuda() else: # 编码输入文本为 token 序列，并添加 batch 维度 text_tokens = torch.tensor(tokenizer.tokenizer.encode(text)).cuda().unsqueeze(0) # 自回归生成，逐 token 采样直到达到目标长度 for _ in range(text_tokens.shape[1], text_seq_len): device = text_tokens.device # 获取 token 的嵌入向量 tokens = self.text_emb(text_tokens) # 添加位置编码（相对或绝对），保持 token 顺序感知 tokens += self.text_pos_emb(torch.arange(text_tokens.shape[1], device=device)) seq_len = tokens.shape[1] # 当前序列长度 # 送入 Transformer 模型获取输出（每个位置的表征） output_transf = self.transformer(tokens) # 如果开启了 stable 模式，则归一化输出，避免极端数值 if self.stable: output_transf = self.norm_by_max(output_transf) # 映射至 logits（预测下一个 token 的概率分布） logits = self.to_logits(output_transf) # 屏蔽非法的预测位置： # 确保在生成文本的阶段，只能预测文本 token，而不是图像 token logits_mask = self.logits_mask[:, :seq_len] max_neg_value = -torch.finfo(logits.dtype).max logits.masked_fill_(logits_mask, max_neg_value) # 仅取最后一个位置的 logits（用于下一个 token 的采样） logits = logits[:, -1, :] # top-k 过滤：仅保留最可能的 k 个 logits，其余设置为 -inf filtered_logits = top_k(logits, thres=filter_thres) # 使用 Gumbel Softmax 技术从过滤后的 logits 中采样一个 token sample = gumbel_sample(filtered_logits, temperature=temperature, dim=-1) # 将采样到的新 token 拼接到已有序列后 text_tokens = torch.cat((text_tokens, sample[:, None]), dim=-1) # 构建 padding token 的集合，用于后续解码时跳过填充 token padding_tokens = set(np.arange(self.text_seq_len) + (self.num_text_tokens - self.text_seq_len)) # 将 token 序列解码为可读文本，自动去掉 padding token texts = [tokenizer.tokenizer.decode(text_token, pad_tokens=padding_tokens) for text_token in text_tokens] # 返回 token 序列和解码后的文本 return text_tokens, texts\"]},\"821\":{\"h\":\"DiscreteVAE 离散化变分自编码器\",\"t\":[\"从本节开始，我们将快速过一下 DiscreteVAE 离散化变分自编码器 和 CLIP 模型的代码实现。\",\"本节开始为扩展阅读内容，已有前置知识的同学，可以选择跳过。\",\"首先来看一下 DiscreteVAE 的初始化方法:\",\"class DiscreteVAE(nn.Module): def __init__( self, image_size = 256, # 输入图像尺寸（宽高），要求是 2 的幂 num_tokens = 512, # codebook 中的 token 数量（离散表示空间的大小） codebook_dim = 512, # codebook 中每个向量的维度 num_layers = 3, # 编码器 / 解码器的层数（每层是一次下采样或上采样） num_resnet_blocks = 0, # 残差块的数量（用于提升表达能力） hidden_dim = 64, # 编码器 / 解码器中卷积通道的基础维度 channels = 3, # 图像通道数（RGB = 3） smooth_l1_loss = False, # 是否使用 Smooth L1 损失（否则使用 MSE） temperature = 0.9, # Gumbel Softmax 温度，控制离散采样的平滑程度 straight_through = False, # 是否使用 straight-through estimator（用于反向传播离散 token） reinmax = False, # 是否使用 Reinmax（一种用于离散变量的采样技术） kl_div_loss_weight = 0., # KL 散度损失的权重（通常为 0 或很小） normalization = ((*((0.5,) * 3), 0), (*((0.5,) * 3), 1)) # 图像标准化参数 ): super().__init__() assert log2(image_size).is_integer(), 'image size must be a power of 2' assert num_layers >= 1, 'number of layers must be greater than or equal to 1' has_resblocks = num_resnet_blocks > 0 self.channels = channels self.image_size = image_size self.num_tokens = num_tokens self.num_layers = num_layers self.temperature = temperature self.straight_through = straight_through self.reinmax = reinmax # codebook：token_id 到向量的映射，大小为 (num_tokens, codebook_dim) self.codebook = nn.Embedding(num_tokens, codebook_dim) hdim = hidden_dim # 构造编码器与解码器的通道列表（每层的通道数） enc_chans = [hidden_dim] * num_layers dec_chans = list(reversed(enc_chans)) # 解码器通道反转 enc_chans = [channels, *enc_chans] # 编码器输入通道从图像开始 # 如果有残差块，解码器第一层输入通道来自 ResBlock 输出 dec_init_chan = codebook_dim if not has_resblocks else dec_chans[0] dec_chans = [dec_init_chan, *dec_chans] # 形如 [(in1, out1), (in2, out2), ...] enc_chans_io, dec_chans_io = map(lambda t: list(zip(t[:-1], t[1:])), (enc_chans, dec_chans)) enc_layers = [] # 编码器网络层列表 dec_layers = [] # 解码器网络层列表 # 构建编码器和解码器的每一层（卷积 / 转置卷积 + ReLU） for (enc_in, enc_out), (dec_in, dec_out) in zip(enc_chans_io, dec_chans_io): enc_layers.append( nn.Sequential(nn.Conv2d(enc_in, enc_out, kernel_size=4, stride=2, padding=1), nn.ReLU()) ) dec_layers.append( nn.Sequential(nn.ConvTranspose2d(dec_in, dec_out, kernel_size=4, stride=2, padding=1), nn.ReLU()) ) # 添加 ResBlock（如果有） for _ in range(num_resnet_blocks): dec_layers.insert(0, ResBlock(dec_chans[1])) # 解码器最前面插入 ResBlock enc_layers.append(ResBlock(enc_chans[-1])) # 编码器末尾追加 ResBlock # 如果使用 ResBlock，还需要额外将 codebook_dim 映射到 decoder 通道数 if num_resnet_blocks > 0: dec_layers.insert(0, nn.Conv2d(codebook_dim, dec_chans[1], kernel_size=1)) # 编码器最终输出 token logits，维度是 num_tokens（注意：非 softmax） enc_layers.append(nn.Conv2d(enc_chans[-1], num_tokens, kernel_size=1)) # 解码器最终输出图像，维度是原始图像的通道数 dec_layers.append(nn.Conv2d(dec_chans[-1], channels, kernel_size=1)) # 打包成 nn.Sequential 模块 self.encoder = nn.Sequential(*enc_layers) self.decoder = nn.Sequential(*dec_layers) # 设置重建损失函数：MSE 或 Smooth L1 self.loss_fn = F.smooth_l1_loss if smooth_l1_loss else F.mse_loss self.kl_div_loss_weight = kl_div_loss_weight # KL损失的权重（可用于 soft quantization） # 图像标准化（mean, std），用于输入预处理 self.normalization = tuple(map(lambda t: t[:channels], normalization))\",\"下面给出 DiscreteVAE 的 forward 方法：\",\"def forward( self, img, # 输入图像，形状为 (B, C, H, W) return_loss = False, # 是否返回损失（训练时设为 True） return_recons = False, # 是否返回重建图像（可用于可视化对比） return_logits = False, # 是否返回 token logits（DALL·E 训练时提取 token 用） temp = None # 温度参数，用于 Gumbel-Softmax，控制采样平滑程度 ): device = img.device num_tokens = self.num_tokens image_size = self.image_size kl_div_loss_weight = self.kl_div_loss_weight # 图像尺寸检查 assert img.shape[-1] == image_size and img.shape[-2] == image_size, f'input must have the correct image size {image_size}' # 归一化输入图像（和训练时保持一致） img = self.norm(img) # 编码器输出 logits，形状为 (B, num_tokens, H/2^L, W/2^L) logits = self.encoder(img) # 若仅需要 token logits（比如训练 DALL·E 时获取离散 token） if return_logits: return logits # 采样温度参数：如果没传入，就用默认的 self.temperature temp = default(temp, self.temperature) # Gumbel Softmax 采样：输出 one-hot 向量或 soft one-hot（取决于 straight_through） one_hot = F.gumbel_softmax(logits, tau = temp, dim = 1, hard = self.straight_through) # Reinmax（改进的 straight-through Gumbel Softmax）逻辑 if self.straight_through and self.reinmax: # Reinmax 来自 https://arxiv.org/abs/2304.08612，增强采样精度 # 论文算法2实现 one_hot = one_hot.detach() # 不反向传播梯度 π0 = logits.softmax(dim = 1) # 原始 softmax 分布 π1 = (one_hot + (logits / temp).softmax(dim = 1)) / 2 # 平均分布 π1 = ((log(π1) - logits).detach() + logits).softmax(dim = 1) # 加入梯度修正 π2 = 2 * π1 - 0.5 * π0 # Reinmax 分布 one_hot = π2 - π2.detach() + one_hot # 将梯度传递给 one_hot # 将 one-hot 与 codebook 进行矩阵乘法，获取嵌入向量图（图像 latent 表示） # einsum: b (token) h w, token d -> b d h w sampled = einsum('b n h w, n d -> b d h w', one_hot, self.codebook.weight) # 解码器将 latent 表示还原为图像 out = self.decoder(sampled) # 如果不需要返回 loss，直接返回解码图像 if not return_loss: return out # 计算重建损失（MSE 或 Smooth L1） recon_loss = self.loss_fn(img, out) # KL 散度部分（用于将 token 分布逼近 uniform） # logits shape: (B, num_tokens, H, W) -> (B, HW, num_tokens) logits = rearrange(logits, 'b n h w -> b (h w) n') log_qy = F.log_softmax(logits, dim = -1) # q(y|x)：预测分布 log_uniform = torch.log(torch.tensor([1. / num_tokens], device = device)) # p(y) ~ U kl_div = F.kl_div(log_uniform, log_qy, None, None, 'batchmean', log_target = True) # 总损失 = 重建损失 + KL散度损失（可选） loss = recon_loss + (kl_div * kl_div_loss_weight) # 如果不需要重建图像，直接返回 loss if not return_recons: return loss # 否则返回损失 + 解码图像 return loss, out\",\"关于本部分代码细节的详细解释，可以参考之前这篇文章: BEiT 模型代码解读\",\"DALL-E 模型使用的是训练好的 DiscreteVAE , 其中我们最常使用 get_codebook_indices 方法获取输入图像对应的离散视觉 token 索引。\",\"@torch.no_grad() # 禁用梯度计算（推理模式，提高效率，节省显存） @eval_decorator # 将模型暂时设为 eval 模式（关闭 Dropout、BatchNorm 的动效） def get_codebook_indices(self, images): # 编码器 + projection，得到每个位置对应的 logits（未 softmax） # logits 形状: (B, num_tokens, H', W')，H'=W'=原图尺寸 / 2^L logits = self(images, return_logits = True) # 取最大概率的 token 索引：在 dim=1（token 类别维）上 argmax # 得到形状: (B, H', W')，即每个图像中每个 patch 的 token 索引 codebook_indices = logits.argmax(dim = 1).flatten(1) # flatten(1): 将 (B, H', W') 展平为 (B, H'*W')，方便后续处理 return codebook_indices\",\"其次我们会调用 decode 方法实现从离散视觉Token索引到图像的重建过程:\",\"def decode( self, img_seq # 输入图像的离散 token 序列，形状：(B, N) ): # 通过 codebook 查表，把每个 token 转换为向量（embedding） # image_embeds 形状: (B, N, D) image_embeds = self.codebook(img_seq) # 获取维度信息：B 批次大小，N token 个数，D embedding 维度 b, n, d = image_embeds.shape # 假设图像是正方形的，N = H' × W'，计算边长 h = w = int(sqrt(n)) # 重新排列：从 (B, N, D) 转换为 (B, D, H', W')，用于 ConvTranspose 解码 image_embeds = rearrange(image_embeds, 'b (h w) d -> b d h w', h = h, w = w) # 解码还原图像：使用 Decoder（转置卷积等） # 输出图像形状: (B, C, H, W) images = self.decoder(image_embeds) return images\"]},\"822\":{\"h\":\"生成质量判别器: CLIP\",\"t\":[\"我们可以借助预训练好的CLIP模型，作为图文匹配的判别器，以此来评判DALL-E模型的文生图质量:\",\"class CLIP(nn.Module): def __init__( self, *, dim_text = 512, # 文本嵌入维度 dim_image = 512, # 图像嵌入维度 dim_latent = 512, # 公共对齐空间的维度（用于计算相似度） num_text_tokens = 10000, # 文本词表大小 text_enc_depth = 6, # 文本 Transformer 层数 text_seq_len = 256, # 文本序列最大长度 text_heads = 8, # 文本 Transformer 头数 num_visual_tokens = 512, # 图像 patch token 数（未使用） visual_enc_depth = 6, # 图像 Transformer 层数 visual_heads = 8, # 图像 Transformer 头数 visual_image_size = 256, # 输入图像尺寸 visual_patch_size = 32, # patch 尺寸 channels = 3 # 图像通道数 ): super().__init__() # --- 文本编码器 --- self.text_emb = nn.Embedding(num_text_tokens, dim_text) # 文本 token embedding self.text_pos_emb = nn.Embedding(text_seq_len, dim_text) # 文本位置 embedding self.text_transformer = Transformer( causal = False, seq_len = text_seq_len, dim = dim_text, depth = text_enc_depth, heads = text_heads, rotary_emb = False ) self.to_text_latent = nn.Linear(dim_text, dim_latent, bias = False) # 映射到公共 latent 空间 # --- 图像编码器 --- assert visual_image_size % visual_patch_size == 0, 'Image dimensions must be divisible by the patch size.' num_patches = (visual_image_size // visual_patch_size) ** 2 # 图像中 patch 的数量 patch_dim = channels * visual_patch_size ** 2 # 每个 patch 的展平维度 self.visual_patch_size = visual_patch_size self.to_visual_embedding = nn.Linear(patch_dim, dim_image) # 将 patch 嵌入图像 token 空间 self.visual_pos_emb = nn.Embedding(num_patches, dim_image) # 图像 patch 的位置 embedding self.visual_transformer = Transformer( causal = False, seq_len = num_patches, dim = dim_image, depth = visual_enc_depth, heads = visual_heads, rotary_emb = False ) self.to_visual_latent = nn.Linear(dim_image, dim_latent, bias = False) # 映射到公共 latent 空间 # 温度参数（可学习，用于缩放余弦相似度） self.temperature = nn.Parameter(torch.tensor(1.)) def forward( self, text, # 输入文本，shape: [B, T] image, # 输入图像，shape: [B, C, H, W] text_mask = None, # 文本掩码（用于处理 padding） return_loss = False # 是否返回对比损失（训练阶段） ): b, device, p = text.shape[0], text.device, self.visual_patch_size # --- 文本编码 --- text_emb = self.text_emb(text) # 文本 token embedding text_emb += self.text_pos_emb(torch.arange(text.shape[1], device = device)) # 加上位置 embedding enc_text = self.text_transformer(text_emb, mask = text_mask) # 经过 Transformer 编码 # --- 图像编码 --- # 将图像切分为 patch，并展平每个 patch image_patches = rearrange(image, 'b c (h p1) (w p2) -> b (h w) (p1 p2 c)', p1 = p, p2 = p) image_emb = self.to_visual_embedding(image_patches) # 线性映射为 patch embedding image_emb += self.visual_pos_emb(torch.arange(image_emb.shape[1], device = device)) # 加位置 embedding enc_image = self.visual_transformer(image_emb) # 图像 Transformer 编码 # --- 获取图文 latent 表示 --- # 文本 latent: 取平均或 masked average（忽略 padding） if exists(text_mask): text_latents = masked_mean(enc_text, text_mask, dim = 1) else: text_latents = enc_text.mean(dim = 1) # 图像 latent: 直接平均所有 patch token image_latents = enc_image.mean(dim = 1) # 映射到公共 latent 空间 text_latents = self.to_text_latent(text_latents) image_latents = self.to_visual_latent(image_latents) # 对 latent 向量进行归一化（L2），以便计算余弦相似度 text_latents, image_latents = map(lambda t: F.normalize(t, p = 2, dim = -1), (text_latents, image_latents)) # 计算可学习温度值（以提升相似度分布的差异性） temp = self.temperature.exp() if not return_loss: # 推理模式下，计算每对 text-image 的相似度（点积 * 温度） sim = einsum('n d, n d -> n', text_latents, image_latents) * temp return sim # 训练模式下，计算所有样本之间的相似度矩阵（用于对比损失） sim = einsum('i d, j d -> i j', text_latents, image_latents) * temp # 构建标签，正样本在对角线（i==j） labels = torch.arange(b, device = device) # 双向对比损失：text -> image 和 image -> text，平均两个方向的 cross entropy loss = (F.cross_entropy(sim, labels) + F.cross_entropy(sim.t(), labels)) / 2 return loss\"]},\"823\":{\"h\":\"生成对抗网络 (GAN) 学习笔记\",\"t\":[\"生成对抗网络 (GAN) 学习笔记\"]},\"824\":{\"h\":\"前置知识\"},\"825\":{\"h\":\"最大似然估计（Maximum Likelihood Estimation, MLE）\",\"t\":[\"最大似然估计是一种利用观测数据反向推断模型参数的方法。直观地说，它假设数据生成过程已知（概率模型已定），但参数未知，我们通过已观测到的样本情况去“猜测”哪个参数值最合理。具体地，MLE 选取使得观测到的数据出现的概率（即似然）最大的参数值为估计结果。\",\"例如，如果我们抛硬币100次均出现正面，我们很自然地认为这枚硬币不是公平的，而最可能的是两面都为正面。这种根据实验结果推断最有可能的硬币属性，就是最大似然估计的直观思想。同样地，若10次抛硬币出现6次正面，我们倾向于估计硬币出现正面的概率为0.6，因为这个假设使得产生“6次正面”的可能性最大。更形式化地说，对于参数 的任意假设，定义似然函数，MLE 就是取使 最大的 。在统计学中，这个最大点称为参数的最大似然估计。\"]},\"826\":{\"h\":\"数学推导\",\"t\":[\"设样本数据为 ，假定其独立同分布于参数为 的某个概率分布。似然函数定义为在参数 给定下观测到该样本的联合概率或概率密度：\",\"若各观测独立，则\",\"其中 是单个样本的概率质量（或密度）函数。最大似然估计就是求解优化问题\",\"即寻找使似然函数取得最大值的参数。为了简化计算，通常取对数得到对数似然，由于对数是单调递增的， 的最大值处即对应 的最大值。对数似然展开为\",\"然后对 关于各参数求偏导并令其为零，即可得到极大似然估计的方程（似然方程），进而求出 。\",\"下面给出几个示例：\",\"离散分布（掷硬币）：设每次抛硬币结果 （1 表示正面），且独立同分布，。若 次抛掷中出现 次正面，则似然函数为 。取对数得 ，对 求导后令导数为零：，解得极大似然估计 。也就是说，硬币正面概率的 MLE 等于正面次数占总次数的比例。\",\"连续分布（正态分布）：假设 独立同分布于 ，似然函数为\",\"对 求导并令偏导数为零可知，MLE 解为样本均值和（无偏调整前的）样本方差：。换言之，在正态分布假设下，MLE 给出了直观的样本统计量作为参数估计。\"]},\"827\":{\"h\":\"信息论: 信息量，熵，交叉熵，KL散度\"},\"828\":{\"h\":\"1.\",\"t\":[\"信息论最核心的问题是：一个事件的发生给我们带来多少“惊讶”或“新信息”？\",\"公式：\",\"这里 是事件 发生的概率。\",\"概率越小 → 事件越罕见 → 信息量越大。\",\"对数底的选择：\",\"：信息单位是 bit（二进制比特）\",\"：信息单位是 nat（自然对数）\",\"例子：\",\"抛硬币得到正面（）：信息量 = bit\",\"抛硬币连续两次都正面（）：信息量 = bit\"]},\"829\":{\"h\":\"2.\",\"t\":[\"熵是平均信息量，用来衡量一个概率分布的不确定性。\",\"公式（离散分布）：\",\"熵越大，分布越“混乱”或不确定。\",\"如果事件概率全一样（均匀分布），熵最大。\",\"如果一个事件概率是 1（确定事件），熵为 0（没有不确定性）。\",\"例子：\",\"公平硬币： bit\",\"偏置硬币（正面 0.9）： bit\"]},\"830\":{\"h\":\"3.\",\"t\":[\"交叉熵衡量用分布 Q 去编码真实来自 P 的事件时的平均信息量。\",\"公式：\",\"解释：\",\"如果 ，交叉熵 = 熵，编码是最优的。\",\"如果 偏离 ，交叉熵会大于熵（编码变长）。\"]},\"831\":{\"h\":\"4.\",\"t\":[\"KL 散度就是交叉熵 - 熵：\",\"交叉熵可以看作是平均信息量 加上因为近似不准而多花的那部分成本，而那部分成本就是 KL 散度。\",\"也可以写成：\",\"含义：\",\"它表示：如果你用 Q 来近似 P，平均每个样本要多花多少信息量（比特 / nat）。\",\"它总是 （Gibbs 不等式），且当 时为 0。\",\"✅ 小结关系图：\",\"信息量 I(x) → 熵 H(P) = 平均 I(x) ↘ 交叉熵 H(P, Q) = 平均 -log Q(x) ↘ KL散度 = H(P, Q) - H(P) 注: 平均是指求期望\"]},\"832\":{\"h\":\"交叉熵损失（Cross-Entropy Loss）\",\"t\":[\"交叉熵损失是一种衡量两个概率分布差异的指标，常用在分类任务中，尤其是二分类和多分类问题。它用来衡量模型预测的概率分布 和真实标签分布 之间的距离。\",\"二分类交叉熵:\",\"对于标签 ，预测概率 ，交叉熵定义为：\",\"解释：\",\"如果真实是正类（），损失就是 ，预测越接近1损失越小。\",\"如果真实是负类（），损失就是 ，预测越接近0损失越小。\",\"多分类交叉熵(对单个样本):\",\"设真实标签是 one-hot 向量 ，预测概率分布是 ，其中 是类别数：\",\"即只对真实类别对应的概率取负对数。\"]},\"833\":{\"h\":\"JS散度（Jensen-Shannon divergence）\"},\"834\":{\"h\":\"1. JS散度是什么？（浅层直观）\",\"t\":[\"JS散度是衡量两个概率分布差异的一个方法。\",\"它是 KL散度的“对称改进版”，所以它总是非负且有限，且满足对称性：\",\"简单说，就是告诉你 和 两个分布相差多远。\"]},\"835\":{\"h\":\"2. 为什么要用JS散度而不是KL散度？\",\"t\":[\"KL散度不对称：\",\"KL散度有时会无穷大（如果 在 支持的区域为0，会导致 不存在）。\",\"JS散度解决了这些问题，变得对称且有界（最大值是 ）。\"]},\"836\":{\"h\":\"3. JS散度的数学定义\",\"t\":[\"给两个概率分布 和 ，定义它们的平均分布：\",\"JS散度定义为：\",\"其中， 是KL散度。\"]},\"837\":{\"h\":\"4. 直观理解JS散度\",\"t\":[\" 是 和 的“中间”分布。\",\"你先测量 与 的差异（KL散度），再测量 与 的差异，取平均。\",\"如果 和 很接近，那么它们都和 很接近，JS散度小。\",\"如果很不一样，JS散度就大。\",\"想象有两个人分别站在一条直线上的不同点，𝑃 和 Q 就是两个人的位置，M 是他们的中间点。你测量两个人到中间点的距离，取平均。这个平均距离越大，说明两个人相距越远。这样就公平、对称地反映了两人距离，而不是单方面去看某一个人的位置。\"]},\"838\":{\"h\":\"5. 举个简单例子\",\"t\":[\"假设：\",\"，\",\"（两个完全不同的分布，互斥事件）。\",\"那么：\",\"所以 \",\"这是最大值，表示两分布差异最大。\"]},\"839\":{\"h\":\"1-Lipschitz 函数\",\"t\":[\"一个函数 如果存在一个常数 （叫 Lipschitz 常数），使得：\",\"对任意 都成立，那么 叫做 K-Lipschitz 函数。\",\"K 越小：函数越平滑，变化越慢。\",\"K 越大：函数变化可能很陡，但仍有限制。\",\"当 时：\",\"这意味着：\",\"输入变化多少，输出的变化量最多等于输入变化量。\",\"相当于限制了函数的最大“斜率”是 1。\",\"想象你走山路：\",\"如果是 1-Lipschitz，走 1 米水平路，海拔最多变 1 米。\",\"如果是 2-Lipschitz，走 1 米水平路，海拔可能变 2 米，更陡。\",\"这个约束能防止函数的变化太快，让它比较“温和”。\"]},\"840\":{\"h\":\"原始 GAN\",\"t\":[\"GAN 是由 Ian Goodfellow 等人在2014年提出的一种生成模型，核心思想是通过两个神经网络之间的“对抗”训练，生成逼真的数据样本。\",\"GAN 里有两个角色：\",\"生成器（Generator，G）：负责从随机噪声生成“假数据”，目的是“骗过”判别器。\",\"判别器（Discriminator，D）：负责判断输入是真实数据还是生成器造出来的假数据。\",\"这两个网络互相对抗，判别器力求识别真假样本，生成器力求生成更逼真的样本“骗过”判别器。 GAN 是一个极大极小游戏，目标函数是：\",\"解释：\",\"：真实数据分布\",\"：随机噪声分布（通常是均匀或高斯）\",\"：判别器给输入 是真实数据的概率\",\"：生成器将噪声 转换成样本\",\"判别器想最大化识别真假的概率，生成器想最小化判别器识别生成样本为假的概率。\",\"传统GAN训练的完整流程:\",\"初始化生成器和判别器网络参数。\",\"训练判别器\",\"采样一批真实样本 。\",\"采样一批噪声 ，生成假样本 。\",\"计算判别器损失：\",\"用梯度下降更新判别器参数，增强它区分真假样本的能力。\",\"训练生成器\",\"再采样一批噪声 ，生成假样本 。\",\"计算生成器损失：\",\"这里生成器的目标是让判别器认为生成样本是真的（输出概率高）。\",\"用梯度下降更新生成器参数，使生成样本更逼真。\",\"重复步骤2和3，交替训练判别器和生成器，直到生成器能够生成看起来很真实的数据。\",\"代码实现:\",\"导包 + 参数准备\",\"import argparse import os import numpy as np import torchvision.transforms as transforms from torchvision.utils import save_image from torchvision import datasets from torch.autograd import Variable import torch.nn as nn import torch os.makedirs(\\\"images\\\", exist_ok=True) parser = argparse.ArgumentParser() parser.add_argument(\\\"--n_epochs\\\", type=int, default=200, help=\\\"number of epochs of training\\\") parser.add_argument(\\\"--batch_size\\\", type=int, default=64, help=\\\"size of the batches\\\") parser.add_argument(\\\"--lr\\\", type=float, default=0.0002, help=\\\"adam: learning rate\\\") parser.add_argument(\\\"--b1\\\", type=float, default=0.5, help=\\\"adam: decay of first order momentum of gradient\\\") parser.add_argument(\\\"--b2\\\", type=float, default=0.999, help=\\\"adam: decay of first order momentum of gradient\\\") parser.add_argument(\\\"--n_cpu\\\", type=int, default=8, help=\\\"number of cpu threads to use during batch generation\\\") parser.add_argument(\\\"--latent_dim\\\", type=int, default=100, help=\\\"dimensionality of the latent space\\\") parser.add_argument(\\\"--img_size\\\", type=int, default=28, help=\\\"size of each image dimension\\\") parser.add_argument(\\\"--channels\\\", type=int, default=1, help=\\\"number of image channels\\\") parser.add_argument(\\\"--sample_interval\\\", type=int, default=400, help=\\\"interval betwen image samples\\\") opt = parser.parse_args() print(opt) img_shape = (opt.channels, opt.img_size, opt.img_size) cuda = True if torch.cuda.is_available() else False\",\"生成器代码实现\",\"class Generator(nn.Module): def __init__(self): super(Generator, self).__init__() def block(in_feat, out_feat, normalize=True): layers = [nn.Linear(in_feat, out_feat)] if normalize: layers.append(nn.BatchNorm1d(out_feat, 0.8)) layers.append(nn.LeakyReLU(0.2, inplace=True)) return layers self.model = nn.Sequential( *block(opt.latent_dim, 128, normalize=False), *block(128, 256), *block(256, 512), *block(512, 1024), # np.prod 是 NumPy 里的一个函数，用来计算一个数组或元组 所有元素的乘积 nn.Linear(1024, int(np.prod(img_shape))), nn.Tanh() ) def forward(self, z): img = self.model(z) img = img.view(img.size(0), *img_shape) return img\",\"判别器代码实现\",\"class Discriminator(nn.Module): def __init__(self): super(Discriminator, self).__init__() self.model = nn.Sequential( # np.prod 是 NumPy 里的一个函数，用来计算一个数组或元组 所有元素的乘积 nn.Linear(int(np.prod(img_shape)), 512), nn.LeakyReLU(0.2, inplace=True), nn.Linear(512, 256), nn.LeakyReLU(0.2, inplace=True), nn.Linear(256, 1), nn.Sigmoid(), ) def forward(self, img): img_flat = img.view(img.size(0), -1) validity = self.model(img_flat) return validity\",\"数据，模型，优化器准备\",\"# Loss function adversarial_loss = torch.nn.BCELoss() # Initialize generator and discriminator generator = Generator() discriminator = Discriminator() if cuda: generator.cuda() discriminator.cuda() adversarial_loss.cuda() # Configure data loader os.makedirs(\\\"./data/mnist\\\", exist_ok=True) dataloader = torch.utils.data.DataLoader( datasets.MNIST( \\\"./data/mnist\\\", train=True, download=True, transform=transforms.Compose( [transforms.Resize(opt.img_size), transforms.ToTensor(), transforms.Normalize([0.5], [0.5])] ), ), batch_size=opt.batch_size, shuffle=True, ) # Optimizers optimizer_G = torch.optim.Adam(generator.parameters(), lr=opt.lr, betas=(opt.b1, opt.b2)) optimizer_D = torch.optim.Adam(discriminator.parameters(), lr=opt.lr, betas=(opt.b1, opt.b2)) Tensor = torch.cuda.FloatTensor if cuda else torch.FloatTensor\",\"训练\",\"# ---------- # Training # ---------- for epoch in range(opt.n_epochs): for i, (imgs, _) in enumerate(dataloader): # Adversarial ground truths valid = Variable(Tensor(imgs.size(0), 1).fill_(1.0), requires_grad=False) fake = Variable(Tensor(imgs.size(0), 1).fill_(0.0), requires_grad=False) # Configure input real_imgs = Variable(imgs.type(Tensor)) # ----------------- # Train Generator # ----------------- optimizer_G.zero_grad() # Sample noise as generator input z = Variable(Tensor(np.random.normal(0, 1, (imgs.shape[0], opt.latent_dim)))) # Generate a batch of images gen_imgs = generator(z) # Loss measures generator's ability to fool the discriminator g_loss = adversarial_loss(discriminator(gen_imgs), valid) g_loss.backward() optimizer_G.step() # --------------------- # Train Discriminator # --------------------- optimizer_D.zero_grad() # Measure discriminator's ability to classify real from generated samples real_loss = adversarial_loss(discriminator(real_imgs), valid) fake_loss = adversarial_loss(discriminator(gen_imgs.detach()), fake) d_loss = (real_loss + fake_loss) / 2 d_loss.backward() optimizer_D.step() print( \\\"[Epoch %d/%d] [Batch %d/%d] [D loss: %f] [G loss: %f]\\\" % (epoch, opt.n_epochs, i, len(dataloader), d_loss.item(), g_loss.item()) ) batches_done = epoch * len(dataloader) + i if batches_done % opt.sample_interval == 0: save_image(gen_imgs.data[:25], \\\"images/%d.png\\\" % batches_done, nrow=5, normalize=True)\",\"效果\"]},\"841\":{\"h\":\"推荐资料\",\"t\":[\"互怼的艺术：从零直达WGAN-GP\",\"能量视角下的GAN模型（一）：GAN＝“挖坑”＋“跳坑”\",\"WGAN的成功，可能跟Wasserstein距离没啥关系\"]},\"842\":{\"h\":\"PixelCNN 解读加代码实现\",\"t\":[\"PixelCNN 解读加代码实现\"]},\"843\":{\"h\":\"引言\",\"t\":[\"本文只涉及原始 PixelCNN 模型，不涉及后续的改进版本。 原始论文链接: Pixel Recurrent Neural Networks 改进版本: Conditional Image Generation with PixelCNN Decoders 继续改进: PixelCNN++: Improving the PixelCNN with Discretized Logistic Mixture Likelihood and Other Modifications\",\"PixelCNN 借用了 NLP 里的方法来生成图像。模型会根据前 i - 1 个像素输出第 i 个像素的概率分布。训练时，和多分类任务一样，要根据第 i 个像素的真值和预测的概率分布求交叉熵损失函数；采样时，直接从预测的概率分布里采样出第 i 个像素。\",\"这种模型最朴素的实现方法，是输入一幅图像的前 i - 1 个像素，输出第 i 个像素的概率分布，即第 i 个像素取某种颜色的概率的数组。为了方便讨论，我们先只考虑单通道图像，每个像素的颜色取值只有 256 种。因此，准确来说，模型的输出是 256 个经过 softmax 的概率。这样，我们得到了一个 V1.0 版本的模型。\",\"等等，模型不是叫「PixelCNN」吗？CNN 跑哪去了？的确，对于图像数据，最好还是使用 CNN，快捷又有效。因此，我们应该修改模型，令模型的输入为整幅图像和序号 i。我们根据序号 i，过滤掉 i 及 i 之后的像素，用 CNN 处理图像。输出部分还是保持一致。\",\"改进之后，V2.0 版本的模型确实能快速计算第i个像素的概率分布了。可是，CNN 是很擅长同时生成一个和原图像长宽相同的张量的，只算一个像素的概率分布还称不上高效。所以，我们可以让模型输入一幅图像，同时输出图像每一处的概率分布。\",\"这次的改进并不能加速采样。但是，在训练时，由于整幅训练图像已知，我们可以在一次前向传播后得到图像每一处的概率分布。假设图像有N个像素，我们就等于是在并行地训练N个样本，训练速度快了N倍！\",\"V3.0 版本的 PixelCNN 已经和论文里的 PixelCNN 非常接近了，我们来探讨一下网络的实现细节。相比普通的 CNN，PixelCNN 有一个特别的约束：第 i 个像素只能看到前 i-1 个像素的信息，不能看到第 i 个像素及后续像素的信息。对于 V2.0 版本只要输出一个概率分布的 PixelCNN ，我们可以通过一些简单处理过滤掉第 i 个像素之后的信息。而对于并行输出所有概率分布的 V3.0 版本，让每个像素都忽略后续像素的信息的方法就不是那么显然了。\"]},\"844\":{\"h\":\"掩码卷积\"},\"845\":{\"h\":\"空间掩码\",\"t\":[\"PixelCNN 论文里提出了一种掩码卷积机制，这种机制可以巧妙地掩盖住每个像素右侧和下侧的信息。具体来说，PixelCNN 使用了两类掩码卷积，我们把两类掩码卷积分别称为「A类」和「B类」。\",\"二者都是对卷积操作的卷积核做了掩码处理，使得卷积核的右下部分不产生贡献。A 类和 B 类的唯一区别在于卷积核的中心像素是否产生贡献。\",\"PixelCNN 的第一个卷积层使用 A 类掩码卷积，之后每一个卷积层都使用 B 类掩码卷积，如下图所示。\",\"为什么要先用一次 A 类掩码卷积，再每次使用 B 类掩码卷积呢？我们不妨来做一个实验。对于一个 7x7 的图像，我们先用 1 次 3x3 A 类掩码卷积，再用若干次 3x3 B 类掩码卷积。我们观察图像中心处的像素在每次卷积后的感受野（即输入图像中哪些像素的信息能够传递到中心像素上）。\",\"不难看出，经过了第一个 A 类掩码卷积后，每个像素就已经看不到自己位置上的输入信息了。再经过两次 B 类卷积，中心像素能够看到左上角大部分像素的信息。这满足 PixelCNN 的约束。\",\"而如果一直使用 A 类卷积，每次卷积后中心像素都会看漏一些信息（不妨对比下面这张示意图和上面那张示意图）。多卷几层后，中心像素的值就会和输入图像毫无关系。\",\"只是用 B 类卷积也是不行的。显然，如果第一层就使用 B 类卷积，中心像素还是能看到自己位置的输入信息。这打破了 PixelCNN 的约束。这下，我们能明白为什么只能先用一次 A 类卷积，再用若干次 B 类卷积了。\",\"利用两类掩码卷积，PixelCNN 满足了每个像素只能接受之前像素的信息这一约束。除此之外，PixelCNN 就没有什么特别的地方了。我们可以用任意一种 CNN 架构来实现PixelCNN。\"]},\"846\":{\"h\":\"通道掩码\",\"t\":[\"PixelCNN 是一种自回归生成模型，它的目标是在生成图像时，每个像素的值只能依赖于“它前面的像素”。 对于单通道灰度图像，这很简单：\",\"我们使用「空间掩码」，限制卷积时只能看到左边和上方的像素，不能看到当前像素和右下角的像素。\",\"但对于RGB 彩色图像来说，每个像素有 3 个子像素（R、G、B），我们还需要处理一个更复杂的问题：\",\"如何控制同一个像素内部的 R、G、B 三个通道之间的信息流动？\",\"这就引出了两类掩码的配合使用。\",\"掩码类型\",\"控制维度\",\"作用\",\"空间掩码\",\"高度 × 宽度 (h, w)\",\"限制某像素只能看到图像中“更早”的像素\",\"通道掩码\",\"输出通道 × 输入通道 (o, i)\",\"限制 RGB 通道之间的因果关系（如 G 不能看到 B）\",\"我们设卷积核的形状是 [o, i, h, w]，其中：\",\"o：输出通道数\",\"i：输入通道数\",\"h × w：卷积核的空间大小\",\"现在，假设你想生成一张 RGB 图像，我们将所有输入和输出通道都分成 3 组：\",\"通道编号\",\"含义\",\"i1 / o1\",\"对应 R 通道信息\",\"i2 / o2\",\"对应 G 通道信息\",\"i3 / o3\",\"对应 B 通道信息\",\"也就是说：\",\"输入通道 i 被拆分成 i1, i2, i3\",\"输出通道 o 被拆分成 o1, o2, o3\",\"Mask A（用于模型的第一层）：\",\"o1 (R) 不看任何输入（包括 i1/i2/i3）\",\"o2 (G) 只能看 i1 (R)\",\"o3 (B) 只能看 i1 和 i2 (R 和 G)\",\"也就是说，我们在生成当前像素的 R 通道时，不使用任何信息；生成 G 通道时，只能用 R 通道信息；生成 B 通道时，能用 R 和 G。\",\"Mask B（用于后续所有卷积层）：\",\"Mask B 是在 Mask A 的基础上允许通道看到自己当前值，更宽松。\",\"o1 可以看到 i1\",\"o2 可以看到 i1 + i2\",\"o3 可以看到 i1 + i2 + i3\",\"这让模型能更好地捕捉本通道的历史上下文，而不会因为约束太严而训练困难。\",\"空间上的掩码仍然使用传统 PixelCNN 的做法：\",\"只允许卷积核看到左边和上方的像素；\",\"对于 Mask A，还屏蔽掉卷积中心（不能看自己）；\",\"同时应用 Channel Mask A 和 Spatial Mask A\",\"对于 Mask B，保留卷积中心（允许看自己）。\",\"同时应用 Channel Mask B 和 Spatial Mask B\",\"这种掩码设计，能确保 PixelCNN 在生成每个像素时严格遵循「从左上到右下、从 R 到 G 到 B」的顺序，不泄露未来信息。\"]},\"847\":{\"h\":\"思考\",\"t\":[\"PixelCNN的核心思想是给图像的子像素定义一个先后顺序，之后让每个子像素的颜色取值分布由之前所有的子像素决定。实现PixelCNN时，可以用任意一种CNN架构，并注意两点：\",\"网络的输出是一个经softmax的概率分布。\",\"网络的所有卷积层要替换成带掩码的卷积层，第一个卷积层用A类掩码，后面的用B类掩码。\",\"学完了 PixelCNN，我们在闲暇之余来谈一谈 PixelCNN 和其他生成网络的对比情况。精通数学的人，会把图像生成问题看成学习一个图像的分布。每次生成一张图片，就是在图像分布里随机采样一张图。学习一个分布，最便捷的方法是定义一个带参数 的概率模型 ，最大化来自数据集的图像 的概率 。\",\"可问题来了：一个又方便采样，又能计算概率的模型不好设计。VAE 和 Diffusion 建模了把一个来自正态分布的向量变形成 的过程，并使用了统计学里的变分推理，求出了 的一个下界，再设法优化这个下界。GAN 干脆放弃了概率模型，直接拿一个神经网络来评价生成的图像好不好。\",\"PixelCNN 则正面挑战了建立概率模型这一任务。它把 定义为每个子像素出现概率的乘积，而每个子像素的概率仅由它之前的子像素决定。\",\"由于我们可以轻松地用神经网络建模每个子像素的概率分布并完成采样，PixelCNN 的采样也是很方便的。我们可以说 PixelCNN 是一个既方便采样，又能快速地求出图像概率的模型。\",\"相比与其他生成模型，PixelCNN 直接对 建模，在和概率相关的指标上表现优秀。很可惜，能最大化数据集的图像的出现概率，并不代表图像的生成质量就很优秀。因此，一直以来，以 PixelCNN 为代表的对概率直接建模的生成模型没有受到过太多的关注。可能只有少数必须要计算图像概率分布的任务才会用到 PixelCNN。\",\"除了能直接计算图像的概率外，PixelCNN 还有一个大特点：PixelCNN 能输出 离散的颜色值。VAE 和 GAN 这些模型都是把图像的颜色看成一个连续的浮点数，模型的输入和输出的取值范围都位于 -1 到 1 之间（有些模型是 0 到 1 之间）。而 PixelCNN 则输出的是像素取某个颜色的概率分布，它能描述的颜色是有限而确定的。假如我们是在生成 8 位单通道图像，那么网络就只输出 256 个离散的概率分布。能生成离散输出这一特性启发了后续很多生成模型。\",\"另外，这一特性也允许我们指定颜色的亮度级别。例如对于黑白手写数字数据集 MNIST，我们完全可以用黑、白两种颜色来描述图像，而不是非得用 256 个灰度级来描述图像。减少亮度级别后，网络的训练速度能快上很多。\",\"在后续的文献中，PixelCNN 被归类为了自回归生成模型。这是因为 PixelCNN 在生成图像时，要先输入空图像，得到第一个像素；把第一个像素填入空图像，输入进模型，得到第二个像素……也就是说，一个图像被不断地进模型、不断把上一个时刻的输出作为输入。这样用自己之前时刻的状态预测下一个状态的模型，在统计学里被称为自回归模型。\",\"如果你在其他图像生成文献中见到了「自回归模型」这个词，它大概率指的就是 PixelCNN 这种每次生成一个像素，该像素由之前所有像素决定的生成模型。\"]},\"848\":{\"h\":\"MINIST 数据集上的实战测试\",\"t\":[\"由于 MINIST 数据集中的图像都是单通道图像，也就意味着我们只需要实现空间掩码即可，简化了模型的实现细节。\",\"首先给出添加了空间掩码的卷积层实现:\",\"class MaskedCNN(nn.Conv2d): def __init__(self, mask_type, *args, **kwargs): self.mask_type = mask_type assert mask_type in ['A', 'B'], \\\"Unknown Mask Type\\\" # 断言检查 mask 类型必须是 A 或 B super(MaskedCNN, self).__init__(*args, **kwargs) # 调用父类 nn.Conv2d 的初始化函数 # 注册掩码张量为 buffer（不会作为可训练参数），初始值复制自卷积核的权重 self.register_buffer('mask', self.weight.data.clone()) # 获取卷积核尺寸：out_channels, in_channels, kernel_height, kernel_width _, depth, height, width = self.weight.size() # 将掩码全部置为 1（不屏蔽任何位置） self.mask.fill_(1) # 空间掩码设计，遮住当前像素及其右方、下方信息 if mask_type == 'A': # 对于 Mask A，屏蔽中心像素（即当前位置）及其右侧 self.mask[:, :, height // 2, width // 2:] = 0 # 屏蔽中心行上中心及其右侧的列 self.mask[:, :, height // 2 + 1:, :] = 0 # 屏蔽中心行以下所有行 else: # 对于 Mask B，保留中心像素，仅屏蔽其右侧 self.mask[:, :, height // 2, width // 2 + 1:] = 0 # 屏蔽中心行上中心右边的列 self.mask[:, :, height // 2 + 1:, :] = 0 # 屏蔽中心行以下所有行 def forward(self, x): # 每次前向传播时将掩码乘到卷积核上，强制屏蔽掉不允许看的区域 self.weight.data *= self.mask return super(MaskedCNN, self).forward(x)\",\"在每次前向传播前将不允许访问的卷积核位置置零，确保模型每个像素的输出 只能依赖于它左上方的像素（包括或不包括自己）。\",\"有了掩码卷积层后，我们便可以根据常规的卷积模型搭建策略来实现 PixelCNN 模型。\",\"import torch import torch.nn as nn class PixelCNN(nn.Module): \\\"\\\"\\\" PixelCNN 网络结构： 逐像素建模图像像素值的条件概率分布 P(x_i | x_{<i})。 使用 MaskedCNN 层控制像素生成顺序（A型和B型掩码），输出 256 类 softmax 概率。 \\\"\\\"\\\" def __init__(self, no_layers=8, kernel=7, channels=64, device=None): \\\"\\\"\\\" 参数说明： - no_layers: 卷积层总数（不包括输出层） - kernel: 卷积核大小（需为奇数，例如 7x7） - channels: 每层卷积的中间通道数 - device: 模型所在设备（可选） \\\"\\\"\\\" super(PixelCNN, self).__init__() self.no_layers = no_layers self.kernel = kernel self.channels = channels self.device = device # --- 第一层 --- # Mask 类型 A：不允许看到当前像素 # 输入通道为 1（灰度图），输出为 channels 维 # 通过设置 padding 来保证输出尺寸与输入一致 self.Conv2d_1 = MaskedCNN('A', 1, channels, kernel, stride=1, padding=kernel//2, bias=False) self.BatchNorm2d_1 = nn.BatchNorm2d(channels) self.ReLU_1 = nn.ReLU(True) # --- 后续几层 --- # Mask 类型 B：允许看到当前像素，但不允许看到未来像素（保持自回归结构） self.Conv2d_2 = MaskedCNN('B', channels, channels, kernel, 1, kernel//2, bias=False) self.BatchNorm2d_2 = nn.BatchNorm2d(channels) self.ReLU_2 = nn.ReLU(True) self.Conv2d_3 = MaskedCNN('B', channels, channels, kernel, 1, kernel//2, bias=False) self.BatchNorm2d_3 = nn.BatchNorm2d(channels) self.ReLU_3 = nn.ReLU(True) self.Conv2d_4 = MaskedCNN('B', channels, channels, kernel, 1, kernel//2, bias=False) self.BatchNorm2d_4 = nn.BatchNorm2d(channels) self.ReLU_4 = nn.ReLU(True) self.Conv2d_5 = MaskedCNN('B', channels, channels, kernel, 1, kernel//2, bias=False) self.BatchNorm2d_5 = nn.BatchNorm2d(channels) self.ReLU_5 = nn.ReLU(True) self.Conv2d_6 = MaskedCNN('B', channels, channels, kernel, 1, kernel//2, bias=False) self.BatchNorm2d_6 = nn.BatchNorm2d(channels) self.ReLU_6 = nn.ReLU(True) self.Conv2d_7 = MaskedCNN('B', channels, channels, kernel, 1, kernel//2, bias=False) self.BatchNorm2d_7 = nn.BatchNorm2d(channels) self.ReLU_7 = nn.ReLU(True) self.Conv2d_8 = MaskedCNN('B', channels, channels, kernel, 1, kernel//2, bias=False) self.BatchNorm2d_8 = nn.BatchNorm2d(channels) self.ReLU_8 = nn.ReLU(True) # --- 输出层 --- # 不再使用 Mask，使用 1x1 卷积将通道数映射为 256 类别 self.out = nn.Conv2d(channels, 256, kernel_size=1) def forward(self, x): \\\"\\\"\\\" 前向传播函数 输入： - x: shape = [batch_size, 1, height, width] （灰度图） 输出： - logits: shape = [batch_size, 256, height, width] 每个像素位置是一个 256 维的 logits，表示输出的 softmax 分布 \\\"\\\"\\\" x = self.Conv2d_1(x) x = self.BatchNorm2d_1(x) x = self.ReLU_1(x) x = self.Conv2d_2(x) x = self.BatchNorm2d_2(x) x = self.ReLU_2(x) x = self.Conv2d_3(x) x = self.BatchNorm2d_3(x) x = self.ReLU_3(x) x = self.Conv2d_4(x) x = self.BatchNorm2d_4(x) x = self.ReLU_4(x) x = self.Conv2d_5(x) x = self.BatchNorm2d_5(x) x = self.ReLU_5(x) x = self.Conv2d_6(x) x = self.BatchNorm2d_6(x) x = self.ReLU_6(x) x = self.Conv2d_7(x) x = self.BatchNorm2d_7(x) x = self.ReLU_7(x) x = self.Conv2d_8(x) x = self.BatchNorm2d_8(x) x = self.ReLU_8(x) return self.out(x)\",\"训练和无条件生成的代码实现如下所示:\",\"import torch import torch.nn as nn import torch.optim as optim from torchvision.utils import save_image from torchvision import datasets, transforms from torch.utils.data import DataLoader from Model import PixelCNN # 1. 数据预处理 transform = transforms.Compose([ transforms.ToTensor(), # 转为 [0, 1] transforms.Lambda(lambda x: (x * 255).long()) # 转为整数像素值 [0, 255] ]) train_dataset = datasets.MNIST(root='./data', train=True, download=True, transform=transform) train_loader = DataLoader(train_dataset, batch_size=64, shuffle=True) # 2. 模型实例化 if torch.backends.mps.is_available(): device = torch.device(\\\"mps\\\") elif torch.cuda.is_available(): device = torch.device(\\\"cuda\\\") else: device = torch.device(\\\"cpu\\\") model = PixelCNN(no_layers=8, kernel=7, channels=64, device=device).to(device) # 3. 损失函数与优化器 criterion = nn.CrossEntropyLoss() optimizer = optim.Adam(model.parameters(), lr=1e-3) # 4. 训练循环 for epoch in range(10): model.train() total_loss = 0 for batch_idx, (data, _) in enumerate(train_loader): data = data.to(device).float() # [B, 1, 28, 28] 归一化 target = data.squeeze(1).long() # [B, 28, 28] 像素标签 (0~255) # 前向传播 output = model(data / 255.0) # 归一化输入 output = output.permute(0, 2, 3, 1) # [B, H, W, 256] output = output.reshape(-1, 256) # 展平为分类输入 target = target.view(-1) # 展平为分类标签 loss = criterion(output, target) optimizer.zero_grad() loss.backward() optimizer.step() total_loss += loss.item() print(f\\\"Epoch [{epoch+1}/10] Loss: {total_loss / len(train_loader):.4f}\\\") # 生成参数 model.eval() image_size = 28 channels = 1 num_samples = 64 device = next(model.parameters()).device # 初始化采样张量（全零） samples = torch.zeros(num_samples, channels, image_size, image_size).to(device) # 像素级逐步采样 with torch.no_grad(): for i in range(image_size): for j in range(image_size): # 前向传播，获得每个像素的概率分布 output = model(samples) # [B, 256, H, W] probs = torch.softmax(output[:, :, i, j], dim=-1) # [B, 256] sampled = torch.multinomial(probs, 1).squeeze(-1) # [B] samples[:, 0, i, j] = sampled.float() / 255.0 # 写入归一化像素值 # 保存生成图像 save_image(samples, \\\"pixelcnn_generated.png\\\", nrow=8, padding=2) print(\\\"图像已生成并保存为 pixelcnn_generated.png\\\")\"]},\"849\":{\"h\":\"摘录\",\"t\":[\"本文摘录至 https://zhuanlan.zhihu.com/p/632209862 , 并对其进行了一些修改。\"]},\"850\":{\"h\":\"Pytorch 实现 VAE 和 CVAE\",\"t\":[\"本文将使用 PyTorch 实现变分自编码器（VAE）和 条件变分自编码器(CVAE)，并在 MNIST 数据集上进行训练与评估\"]},\"851\":{\"h\":\"实现VAE\"},\"852\":{\"h\":\"1. 安装和导入依赖\",\"t\":[\"import torch import torch.nn as nn import torch.nn.functional as F import torch.optim as optim from torchvision import datasets, transforms from torch.utils.data import DataLoader import matplotlib.pyplot as plt\"]},\"853\":{\"h\":\"2. 定义 VAE 模型\",\"t\":[\"class VAE(nn.Module): def __init__(self, input_dim=784, hidden_dim=400, latent_dim=20): super(VAE, self).__init__() # 编码器 self.fc1 = nn.Linear(input_dim, hidden_dim) self.fc_mu = nn.Linear(hidden_dim, latent_dim) self.fc_logvar = nn.Linear(hidden_dim, latent_dim) # 解码器 self.fc2 = nn.Linear(latent_dim, hidden_dim) self.fc3 = nn.Linear(hidden_dim, input_dim) def encode(self, x): h = F.relu(self.fc1(x)) return self.fc_mu(h), self.fc_logvar(h) def reparameterize(self, mu, logvar): std = torch.exp(0.5 * logvar) eps = torch.randn_like(std) return mu + eps * std def decode(self, z): h = F.relu(self.fc2(z)) return torch.sigmoid(self.fc3(h)) def forward(self, x): mu, logvar = self.encode(x) z = self.reparameterize(mu, logvar) return self.decode(z), mu, logvar\",\"重参数化技巧\",\"我们希望从一个高斯分布中采样隐变量：\",\"如果我们直接 z = torch.normal(mu, std) 这样采样，就不能反向传播到 mu 和 logvar，因为随机采样不可微！\",\"重参数化的关键思想: 将不可微的采样操作拆解为一个可微的确定性函数加一个随机变量。\",\"现在采样的是 ε（标准正态，和模型参数无关），而 μ 和 σ 参与的是可导的加法和乘法，可以进行梯度传播。\",\"为什么输出的是 log(σ²)（即对数方差）？\",\"确保方差 σ² 始终为正数\",\"方差必须 > 0，不能为负。但神经网络输出的是无约束的实数 ℝ，所以我们用一个变换把它映射为正数：\",\"无论 logvar 是什么，exp(logvar) 总是 > 0；\",\"避免了人为加 ReLU 或 clamp（数值不连续）等不稳定做法；\",\"模型可以自由学习 logvar ∈ ℝ，无需强行约束。\",\"数值稳定性更高\",\"对数空间中操作更稳定，比如在计算 KL 散度时：\",\"这里的 log σ² 正好可以直接来自模型输出，避免再求 log。\",\"为什么还要乘上 0.5？即 std = exp(0.5 * logvar)\",\"我们想要从 N(μ, σ²) 中重参数化采样，需要：\",\"但模型输出的是 logvar = log(σ²)，所以我们需要：\"]},\"854\":{\"h\":\"3. 定义损失函数（重构损失 + KL散度）\",\"t\":[\"def vae_loss(recon_x, x, mu, logvar): BCE = F.binary_cross_entropy(recon_x, x, reduction='sum') KLD = -0.5 * torch.sum(1 + logvar - mu.pow(2) - logvar.exp()) return BCE + KLD\",\"变分自编码器（VAE）训练的核心目标函数，等式右边的两项是:\",\"这就是我们在优化的 变分下界（ELBO），即最大化：\",\"第一项：重建对数似然 , 这项衡量的是：给定隐变量 z，重建样本 X 的能力。在实际中要通过具体分布建模 P(X|z)，并写出其对数形式。\",\"我们假设图像每个像素的值是伯努利分布，并且相互独立。\",\"Step 1：伯努利分布的概率密度函数\",\"对于一个二元变量 ，其伯努利分布定义为：\",\"其中：\",\"：为预测像素点为 1 的概率（即 decoder 输出）\",\"：为真实像素值\",\"Step 2：图像整体建模为像素独立\",\"我们假设图像共有 个像素点，每个像素点是独立的伯努利分布，所以整个图像的条件概率为：\",\"Step 3：取对数得到 log-likelihood\",\"对上式取对数：\",\"这就是我们在 VAE 中用于训练的 重建项！\",\"Step 4：对应到 Binary Cross Entropy（BCE）\",\"这正是 binary cross entropy loss 的形式（取负号）：\",\"在 PyTorch 中：\",\"F.binary_cross_entropy(recon_x, x, reduction='sum') # 就是 -log P(X|z)\",\"第二项：KL 散度项\",\"衡量的是：我们学习的编码器 Q(z|X) 与先验 P(z)（通常为标准正态分布 ）之间的距离。\",\"对于高斯分布，它有一个闭式解：\"]},\"855\":{\"h\":\"4. 数据加载\",\"t\":[\"transform = transforms.ToTensor() train_dataset = datasets.MNIST(root='./data', train=True, transform=transform, download=True) train_loader = DataLoader(train_dataset, batch_size=128, shuffle=True)\"]},\"856\":{\"h\":\"5. 训练模型\",\"t\":[\"device = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\") model = VAE().to(device) optimizer = optim.Adam(model.parameters(), lr=1e-3) epochs = 10 model.train() for epoch in range(epochs): train_loss = 0 for batch_idx, (data, _) in enumerate(train_loader): data = data.to(device).view(-1, 784) optimizer.zero_grad() recon_batch, mu, logvar = model(data) loss = vae_loss(recon_batch, data, mu, logvar) loss.backward() train_loss += loss.item() optimizer.step() print(f\\\"Epoch {epoch+1}, Loss: {train_loss / len(train_loader.dataset):.4f}\\\")\"]},\"857\":{\"h\":\"6. 模型评估\",\"t\":[\"model.eval() with torch.no_grad(): sample = next(iter(train_loader))[0].to(device)[:8] sample_flat = sample.view(-1, 784) recon, _, _ = model(sample_flat) recon = recon.view(-1, 1, 28, 28).cpu() # 显示原图和重建图像 fig, axs = plt.subplots(2, 8, figsize=(15, 4)) for i in range(8): axs[0, i].imshow(sample[i].cpu().squeeze(), cmap='gray') axs[0, i].axis('off') axs[1, i].imshow(recon[i].squeeze(), cmap='gray') axs[1, i].axis('off') axs[0, 0].set_title(\\\"Original\\\") axs[1, 0].set_title(\\\"Reconstruction\\\") plt.show()\",\"我们还可以从标准正态分布中采样一个向量 z ~ N(0, I)，然后送入 VAE 的 decode() 方法，生成图像。这是变分自编码器（VAE）最重要的能力之一：生成样本。\",\"VAE 的设计初衷之一就是在潜在空间中学习一个接近于标准正态分布 的分布。训练中，VAE 通过加入 KL 散度项让 q(z|x) 接近于标准正态分布。因此，在推理阶段可以从 中采样 z，并使用 decode(z) 生成新的图像。\",\"你可以在训练完成后加入如下代码来生成图像：\",\"with torch.no_grad(): # 从标准正态分布中采样 8 个 z 向量 z = torch.randn(8, 20).to(device) # 20 是 latent_dim 的大小 generated = model.decode(z).view(-1, 1, 28, 28).cpu() # 可视化生成图像 fig, axs = plt.subplots(1, 8, figsize=(15, 2)) for i in range(8): axs[i].imshow(generated[i].squeeze(), cmap='gray') axs[i].axis('off') plt.suptitle(\\\"Generated Images from z ~ N(0, I)\\\") plt.show()\",\"epoch 改为 100 个后的生成样本效果:\"]},\"858\":{\"h\":\"CVAE 实现\",\"t\":[\"条件变分自编码器（CVAE）是 VAE 的一个变种，它引入了条件变量，以实现对生成样本的控制。比如在 MNIST 中，c 可以是类别标签（0-9），使得模型能够生成指定数字的图像。\",\"CVAE 模型中的每一步都变成 条件化：\",\"部分\",\"普通 VAE\",\"CVAE 版本\",\"编码器输入\",\"解码器输入\",\"输出\",\"没有给出的步骤，均和VAE实现部分保持一致。\"]},\"859\":{\"h\":\"2. 定义 CVAE 模型\",\"t\":[\"class CVAE(nn.Module): def __init__(self, input_dim=784, label_dim=10, hidden_dim=400, latent_dim=20): super(CVAE, self).__init__() self.input_dim = input_dim self.label_dim = label_dim # 编码器：x 和 标签 c 连接 self.fc1 = nn.Linear(input_dim + label_dim, hidden_dim) self.fc_mu = nn.Linear(hidden_dim, latent_dim) self.fc_logvar = nn.Linear(hidden_dim, latent_dim) # 解码器：z 和 标签 c 连接 self.fc2 = nn.Linear(latent_dim + label_dim, hidden_dim) self.fc3 = nn.Linear(hidden_dim, input_dim) def encode(self, x, c): xc = torch.cat([x, c], dim=1) # concat image and condition h = F.relu(self.fc1(xc)) return self.fc_mu(h), self.fc_logvar(h) def reparameterize(self, mu, logvar): std = torch.exp(0.5 * logvar) eps = torch.randn_like(std) return mu + eps * std def decode(self, z, c): zc = torch.cat([z, c], dim=1) h = F.relu(self.fc2(zc)) return torch.sigmoid(self.fc3(h)) def forward(self, x, c): mu, logvar = self.encode(x, c) z = self.reparameterize(mu, logvar) return self.decode(z, c), mu, logvar\"]},\"860\":{\"h\":\"5. 训练过程\",\"t\":[\"device = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\") model = CVAE().to(device) optimizer = torch.optim.Adam(model.parameters(), lr=1e-3) for epoch in range(10): model.train() train_loss = 0 for x, y in train_loader: x = x.view(-1, 784).to(device) c = F.one_hot(y, num_classes=10).float().to(device) optimizer.zero_grad() recon_x, mu, logvar = model(x, c) loss = loss_function(recon_x, x, mu, logvar) loss.backward() train_loss += loss.item() optimizer.step() print(f\\\"Epoch {epoch+1}, Loss: {train_loss / len(train_loader.dataset):.4f}\\\")\"]},\"861\":{\"h\":\"6. 条件生成图像（指定标签）\",\"t\":[\"model.eval() with torch.no_grad(): z = torch.randn(10, 20).to(device) labels = torch.arange(0, 10).long() c = F.one_hot(labels, num_classes=10).float().to(device) gen_imgs = model.decode(z, c).view(-1, 1, 28, 28).cpu() fig, axs = plt.subplots(1, 10, figsize=(15, 2)) for i in range(10): axs[i].imshow(gen_imgs[i].squeeze(), cmap='gray') axs[i].axis('off') plt.show()\"]},\"862\":{\"h\":\"生成模型学习\"},\"863\":{\"h\":\"Tutorial on Variational Autoencoders 论文\",\"t\":[\"Tutorial on Variational Autoencoders 论文\",\"论文链接: Tutorial on Variational Autoencoders\"]},\"864\":{\"h\":\"引言\",\"t\":[\"生成建模是机器学习中的一个重要领域，目标是建立对数据点 所在的高维空间 上分布 的模型。以图像为例，每张图像包含成千上万个像素，这些像素之间存在复杂的依赖关系，比如相邻像素颜色相似且共同构成物体。生成模型的任务就是捕捉这些像素间的依赖。\",\"模型的具体含义取决于我们想用它完成什么。最基础的生成模型能够数值计算 ，让看起来真实的图像具有较高概率，而随机噪声的图像概率较低。然而，这样的模型不一定实用，因为知道某个图像不太可能出现，并不能帮助我们生成新的、真实的图像。\",\"实际应用中，人们更关心的是能否基于已有数据库，生成更多类似但不完全相同的新样本。比如：\",\"从图像数据库合成新的未见图像；\",\"从三维植物模型生成更多植被以填充游戏场景；\",\"从手写文本生成更多手写内容。\",\"这些生成工具对设计师等用户非常有用。\",\"我们假设数据来自一个未知的真实分布 ，目标是学习一个生成模型 ，使得从 中采样的样本尽量和真实分布相似。\",\"训练这类模型长期以来面临三大难题：\",\"需要对数据结构做强假设；\",\"进行严重近似，导致模型性能不佳；\",\"依赖计算量大、效率低的推断方法，如马尔可夫链蒙特卡洛（MCMC）。\",\"近年来，借助反向传播训练神经网络这一强大函数逼近器的突破，出现了基于神经网络的生成模型框架。其中变分自编码器（VAE）是一种非常流行的方法，具有如下优点：\",\"假设较弱，不强制对数据结构做过多限制；\",\"训练速度快，可通过反向传播高效优化；\",\"引入近似但误差较小，尤其是在高容量模型下。\",\"这些特点使得 VAE 快速流行，成为研究和应用的热门工具。\",\"论文面向对生成模型感兴趣但不熟悉变分贝叶斯方法的读者，主要偏重计算机视觉领域。教程起源于加州大学伯克利分校和卡内基梅隆大学的读书分享。\"]},\"865\":{\"h\":\"预备知识: 潜变量模型\",\"t\":[\"生成模型训练时，维度间的复杂依赖会增加难度。以生成手写数字图像为例，模型若先随机选择一个数字 （潜变量），再生成对应像素，比直接逐像素生成效果更好。潜变量 是指生成过程中的隐藏决策，虽然我们只能看到最终生成的字符，但不知道具体哪个潜变量设置产生了它。\",\"为了让模型能生成接近训练数据的样本，必须确保对数据集中的每个样本 ，存在一个或多个潜变量设置 ，使得模型能生成与 相似的结果。数学上，假设潜变量 服从概率密度 ，通过一个确定性函数族 生成样本。优化目标是调整参数 ，使得从 采样后生成的样本 高概率地类似训练集中的数据。\",\"用概率分布形式表达即为最大化\",\"其中 表示给定潜变量 时生成样本 的条件概率。这种最大似然方法保证模型倾向于生成训练样本及其相似样本，而非随机噪声。\",\"在变分自编码器中，常用的 是均值为 、协方差为 的高斯分布：\",\"这个设计使得模型输出能“软匹配”训练样本，便于通过梯度下降逐渐调整参数，增加数据的生成概率。如果使用确定映射（即 ），优化将难以进行。\",\"输出分布不一定是高斯分布，例如二值数据可用伯努利分布。关键是 需要可计算且关于参数 连续。后续为了简洁，文中将省略函数 中的参数 。\"]},\"866\":{\"h\":\"变分自编码器\",\"t\":[\"虽然 VAE 含有编码器和解码器结构，看起来像传统的自编码器，但它的数学基础与稀疏自编码器或去噪自编码器并不相同。VAE 的目标是近似最大化训练样本的概率：\",\"它最大的优势在于可以直接从中采样，而不像早期方法那样依赖 MCMC 等复杂的采样技术。\",\"VAE 需要解决两个核心问题：\",\"如何定义潜变量 ，即 应该包含哪些信息？\",\"如何计算 中对 的积分？\",\"针对第一个问题，以手写数字为例，一个合理的 不仅要包含数字的类别信息，还要包含书写角度、笔画粗细、风格等。而这些属性往往是相关联的，例如书写快导致角度大、笔画细。\",\"我们不希望人为规定 每个维度的含义或其之间的关系，因此 VAE 采取的策略是：\",\"直接假设 来自一个简单的分布，通常是标准正态分布 。\",\"为什么这样可行？因为任意复杂分布都可以通过把简单分布输入到一个足够复杂的函数中得到。例如：\",\"若 ，则 会产生环形分布（如图2所示）。\",\"所以，使用神经网络等强函数逼近器，我们可以将标准正态的 映射为模型所需的潜在因子空间，再进一步映射为图像 。\",\"在 VAE 中，生成图像的过程被建模为高斯分布：\",\"其中 是多层神经网络。前几层将 映射成潜在属性（例如数字类别、风格等），后几层则将这些属性解码为图像。\",\"这意味着：\",\"网络会自动学习潜在结构，只要这样的结构有助于拟合训练数据（即使最大似然更大）。\",\"现在剩下的问题是如何优化上述积分。一个直接的近似方法是采样多个 ，然后用 Monte Carlo 平均近似 ：\",\"但在高维空间中，这种方式效率极低，需要非常多的样本 才能得到准确估计。\",\"图3 中说明了这个问题的本质：\",\"图3(a)：目标图像 ，我们希望估计其 。\",\"图3(b)：模型生成的图像，看起来不像“2”，质量很差。\",\"图3(c)：仅比 偏移半个像素，看起来很像原图。\",\"问题在于：\",\"图3(c) 与 的欧式距离为 0.2693\",\"图3(b) 与 的欧式距离为 0.0387\",\"由于 是高斯分布，其值由 控制。\",\"如果我们希望图3(b) 对 贡献很小，就必须让 足够小。但这会导致图3(c) 也被“排除”，因为其距离并不小。\",\"设随机向量 ，其分布为维度为 的多元高斯分布，记作：\",\"其概率密度函数为：\",\"在 VAE 里，我们通常假设协方差矩阵是对角的，甚至直接是单位矩阵的倍数：\",\"此时公式简化为：\",\"其中 是欧几里得距离的平方，表示 与生成样本的距离。\",\"现存问题（如图3所示）：\",\"要排除错误样本（图3b），需要 非常小\",\"但这样也会排除相似的好样本（图3c）\",\"采样效率低，需大量 才能采到接近目标图像的样本\",\"虽然可以尝试用更好的相似性度量代替欧氏距离，但在复杂视觉任务中，这类度量难以设计，也难以训练。为此，VAE 选择不改变相似性度量，而是优化采样方式，以提高效率。这为后续的变分推断方法奠定了基础。\"]},\"867\":{\"h\":\"构建目标函数\",\"t\":[\"当我们尝试通过采样计算公式 (1) 中的 时，有没有捷径可走呢？实际上，对于大多数 值， 都会非常接近于 0，因此对 的估计几乎没有贡献。\",\"变分自编码器（VAE）的关键思想是：尝试只采样那些很可能生成 的 值，并利用这些 来估计 。为此，我们引入一个新的分布函数 ，它能够根据输入 生成一组可能生成 的潜变量 。希望这个 下高概率的 空间远小于先验分布 下高概率的区域。\",\"这使得我们可以更容易地计算：\",\"但问题来了：如果 是从一个任意分布 （不是标准正态分布 ）中采样的，我们该如何优化 呢？\",\"我们先从变分贝叶斯方法的基础出发：Kullback-Leibler 散度（KL 散度），它衡量两个概率分布之间的距离。我们用它来衡量 和后验分布 之间的差异：\",\"为了将 和 引入这个式子，我们对 应用贝叶斯公式，有：\",\"注意： 不依赖于 ，因此可以移出期望符号。\",\"我们从 KL 散度的定义开始：\",\"接下来使用 贝叶斯公式 展开 ：\",\"带入上式中：\",\"对右侧进行对数展开：\",\"将其带入 KL 散度的期望中：\",\"因为 与 无关，是一个常数，可以移出期望符号：\",\"最终得到目标公式：\",\"接着，我们将等式两边都取负号、重新排列，并将期望中的部分转换为另一个 KL 散度，从而得到：\",\"其中：\",\"左边是我们想要的目标 减去一个误差项（让 逼近真实后验分布 ）；\",\"右边则是我们可以实际优化的目标。\",\"由于我们关心的是给定样本 的 ，所以我们自然希望选择一个依赖于 的 ，并让其尽可能逼近 。于是有：\",\"这个公式（式 5）正是变分自编码器的核心思想，非常值得深入理解：\",\"左边的 是我们希望最大化的目标；\",\"减去的 KL 散度项会鼓励 生成那些可以还原 的 ；\",\"如果我们能让 ，那么这个误差项趋近于 0，我们就真正最大化了 ；\",\"更重要的是，这样一来我们就绕过了后验分布 无法精确计算的问题，用 代替它。\",\"同时，右边的结构也变得非常像一个自编码器： 像编码器（encoder）将 映射到 ，而 像解码器（decoder）将 还原为 。\",\"我们会在后续进一步探索这种“看起来像自编码器”的结构。\"]},\"868\":{\"h\":\"优化目标函数\",\"t\":[\"那么我们该如何对公式（5）右边的目标函数使用随机梯度下降进行优化呢？首先，我们需要更具体地定义 的形式。通常的选择是将其设为：\",\"其中 和 是带参数 的任意可学习的确定性函数（后续公式中将省略 以简化表示）。在实际中， 和 都由神经网络实现，并且通常会约束 为对角矩阵。\",\"这样的设定具有计算上的优势，因为它可以明确地定义如何计算公式右边的两项。最后一项 现在就变成了两个多元高斯分布之间的 KL 散度，其可以写成如下闭式表达：\",\"其中 表示分布的维度。\",\"在我们的设定中， ，因此这个公式可以简化为：\",\"现在来看公式（5）右边的第一项： 。我们可以使用采样来估计这个期望，但要获得准确的估计，就需要多次对 采样并输入解码器 ，这在计算上代价很高。\",\"因此，和随机梯度下降中常用的做法一样，我们通常只对 采样一次，并用该 下的 作为对 的近似。\",\"毕竟，我们已经在对从数据集 中采样得到的不同 执行随机梯度下降。\",\"最终我们要优化的目标是：\",\"若我们对该公式求梯度，由于期望的线性性质，可以将梯度操作符移入期望内。这样我们只需采样一个 和一个从 得到的 ，然后计算以下表达式的梯度：\",\"我们可以对多个样本的 和 计算该函数的梯度并进行平均，最终会收敛到公式（8）的真实梯度。\",\"然而，公式（9）存在一个重要问题： 不仅依赖于生成器 的参数，还依赖于编码器 的参数，但在公式（9）中这种依赖“消失了”。\",\"为了让 VAE 正常工作，我们必须推动 学会生成让 能够成功解码的 编码结果。\",\"换种方式理解这个问题：公式（9）描述的神经网络结构类似图4左侧所示的网络。其前向传播没有问题，若对多个 和 样本取平均，其输出就是期望值。但我们还需要将误差反向传播到一个从 中采样的 ，而“采样”这一操作本质上是非连续的、不可微的。\",\"虽然反向传播可以应对带噪输入（例如 dropout），但无法直接穿过一个采样操作的节点反向传播梯度。\",\"解决方案来自 Kingma 等人在 [1] 中提出的 “重参数化技巧”（reparameterization trick）：\",\"我们将采样从网络内部移动到输入层。具体做法是：\",\"先从标准正态分布采样 \",\"再计算 \",\"这样我们就可以将期望写为如下形式：\",\"该结构如图4右侧所示。\",\"注意：现在所有的期望都关于不依赖模型参数的分布，因此我们可以安全地将梯度符号移入期望中而不会影响等式成立。换言之，在固定 和 的情况下，该函数对 和 的参数是连续且可导的，所以反向传播可以计算出有效梯度用于随机梯度下降。\",\"需要指出的一点是：重参数化技巧仅适用于连续变量的分布。为了能写成 ，其中 是不学习的随机变量， 是一个关于 的连续函数，才能使其可微。\",\"因此，如果 或 是离散分布，就无法使用该技巧。因为在这种情况下，函数 要么忽略 ，要么在某处发生跳跃，即出现不连续性，这会导致无法对模型参数求导。\"]},\"869\":{\"h\":\"测试已学习的模型\",\"t\":[\"在测试阶段，当我们希望从训练好的模型中生成新样本时，过程非常简单：只需从标准正态分布中采样 ，然后将这个 输入到解码器中即可生成图像。这时我们不再使用编码器，也不会进行变换（如均值和方差的加权），直接使用标准高斯采样值。这个测试时的网络结构在图5中有示意。\",\"当我们希望评估某个测试样本 的似然概率 时，事情会变得复杂。因为真实的 无法直接计算。不过我们知道 KL 散度 是非负的，因此，公式 (5) 的右侧是 的下界：\",\"尽管这个下界仍然包含一个关于 的期望项，无法闭式求解，但可以通过对 进行采样来估计。\",\"与直接从 采样相比，从 中采样可以提供更快、更稳定的估计收敛。这种下界估计虽然不是完全精确，但可以作为判断模型是否捕捉到了某个特定数据点 的一种有用指标。\",\"因此，在测试阶段，直接从标准正态分布采样 并输入解码器就能生成图像；而当需要评估样本概率时，可以使用训练过程中的变分下界（ELBO）作为近似指标。\",\"在 训练阶段，VAE 的工作流程是这样的：\",\"给一个真实样本 （比如一张图像）。\",\"用 编码器 生成潜在变量 的分布参数：均值 和方差 。\",\"从这个分布中采样出一个 （使用 reparameterization trick）。\",\"用 解码器 根据 生成图像 。\",\"同时优化两个目标：重建损失（ 与 的相似程度） + KL 散度（让 尽量接近 ）。\",\"训练完成后，编码器的目标是让 尽可能逼近标准正态分布 。也就是说，模型已经学会了将数据编码到一个“标准正态空间”中。 因此在 测试时，我们就不需要真实的 了。我们可以：\",\"直接从 中采样一个 （比如 ）\",\"把这个 传给 训练好的解码器\",\"解码器会输出一个图像，这就是一个新的、合理的样本\",\"因为 VAE 在训练过程中不断把 分布“推近”标准正态分布，所以训练好的解码器知道：从标准正态分布中采样 ，应该能生成“像样”的图像。这也是变分推断的精髓所在。 原始的变分自编码器（VAE） 只能学习如何根据某种隐变量 来重建训练数据 ，并不能直接学会如何根据文本或其他条件信息来生成对应图像。\"]},\"870\":{\"h\":\"解读目标函数\",\"t\":[\"到目前为止，你应该已经相信 VAE 的学习过程是可行的，并且它确实在对整个数据集上的 进行某种形式的优化。然而，我们实际上并没有在精确地优化 ，因此本节旨在更深入地理解这个目标函数究竟在做什么。\",\"我们将讨论三个关键主题：\",\"首先，我们会探讨：在优化 的同时，还优化了 ，这一步到底引入了多少误差？\",\"接着，我们会从信息论（Information Theory）的角度描述 VAE 框架，特别是分析等式 (5) 右侧的表达式，并将其与基于最小描述长度（Minimum Description Length，简称 MDL）等其他方法联系起来。\",\"最后，我们会调查：VAE 是否拥有类似于稀疏自编码器中稀疏性惩罚项那样的“正则化参数”，也就是说，是否存在一种类似于手动控制模型约束程度的机制？\"]},\"871\":{\"h\":\"项引入的误差分析\",\"t\":[\"本模型之所以具备可计算性，依赖于我们作出的一个假设：即 可以被建模为具有某个均值 和方差 的高斯分布。如果 ，那么 （即模型生成的分布）才会在分布意义上收敛于真实分布。\",\"然而，确保 收敛为零并不是一件容易的事。即使我们假设 和 具有任意高的表达能力，后验分布 在一般情况下也不一定是高斯分布，尤其是当我们用任意函数 去定义 时。\",\"如果 是固定的，这可能意味着 永远不会为零。\",\"如果 固定，且对应的 不是高斯分布，那么我们用高斯近似的 来学习会引入误差，导致从标准正态分布采样得到的 经 decoder 生成的图像 难以还原原始数据。\",\"不过，好消息是，只要我们拥有足够高容量（high-capacity）的神经网络，那么就存在很多种函数 ，它们都可以生成我们希望逼近的输出分布。而这些函数都可以同样好地最大化 。因此，我们只需要找到一种函数 ，它既能最大化 ，又能让 对所有 都是高斯分布。\",\"这里提到的函数 是指 decoder 端的神经网络，即从潜在变量 映射到图像 的那个函数。\",\"如果这样的函数存在，那么 KL 散度 就会推动模型向这一特定参数化方式靠拢。\",\"那么，是否对我们想要逼近的所有分布都存在这样一种函数 呢？目前为止，作者并不清楚是否已经有任何人从一般意义上证明了这一点。\",\"但幸运的是，作者指出，在某些特定情形下，可以证明这样的函数确实存在：前提是标准差 相较于真实分布累积分布函数（CDF）的曲率来说足够小（至少在一维情形下）。相关证明可见附录 A。\",\"虽然在实际中这样的小 可能会带来问题，比如导致梯度尺度失衡，从而影响现有的机器学习算法，但至少我们知道，在这个特定条件下，VAE 的近似误差可以为零。这一点提供了理论上的安慰。\",\"这一发现也暗示，未来的理论研究有望揭示 VAE 在更实际设定下到底存在多少近似误差。作者认为，附录 A 中的证明方法可能可以推广到多维情形，但这部分工作尚留待未来完成。\"]},\"872\":{\"h\":\"信息论视角\",\"t\":[\"我们可以从信息论的角度，特别是“最小描述长度（Minimum Description Length, MDL）”的原则，来理解公式（5）右边的意义。这种视角也正是许多 VAE 的前辈模型（如 Helmholtz 机器 [16]、Wake-Sleep 算法 [17]、深度置信网络 [18] 和玻尔兹曼机 [19]）的动机来源。\",\"在信息论中， 可以看作是用理想编码方式构建给定样本 所需的总比特数。公式（5）右侧将这个编码过程拆分为两个步骤：\",\"第一步是构建潜变量 ，这需要一定的信息量。请注意，KL 散度的单位就是比特（更准确地说是 nat）。具体地， 表示：为了将一个无信息的样本（来自先验分布 ）转化为更有信息的样本（来自后验近似 ），所需的平均信息量。这种解释也叫作 KL 散度的“信息增益”视角。换句话说，它度量了：与从 中采样相比，从 中采样可以获得多少关于 的额外信息（更多内容可参考文献 [20, 21] 中的 “bits back” 理论）。\",\"第二步是利用 还原出 。 描述了：在给定 的情况下，重建 所需的信息量（即压缩 还原所需的最小比特数）。\",\"因此，总的信息量（）等于上述两个步骤的总和：即\",\"不过这里要注意一点：由于我们用的是近似的编码分布 ，它不是理想的后验 ，所以还会有一个误差项 ，代表我们因为编码器不完美而付出的额外“编码代价”。\"]},\"873\":{\"h\":\"VAE 与正则化参数\",\"t\":[\"从公式（5）的角度看，将 看作一个正则化项是很有意思的，这与稀疏自编码器（sparse autoencoders）中的稀疏正则化很相似 [10]。从这个视角出发，我们可以思考一个问题：变分自编码器是否也存在某种“正则化参数”？\",\"在稀疏自编码器的目标函数中，确实存在一个正则化参数 ，该目标函数的形式如下：\",\"其中 和 分别是编码器和解码器函数， 是 范数，用于鼓励编码结果稀疏。这个 是需要手动设置的。\",\"相比之下，变分自编码器（VAE）通常并没有这样的正则化参数，这其实是一个好处：程序员就少了一个需要调节的超参数。\",\"但在某些模型中，我们可以人为“制造出”一个看起来像正则化参数的东西。有些人可能会认为：通过将潜变量的分布从 改为 ，就可以引入一个类似 的调节参数。\",\"然而，事实证明，这种修改不会改变模型本质。原因如下：\",\"我们可以通过以下重参数方式，把这个 吸收到 和 中：\",\"令 \",\"令 \",\"令 \",\"这样处理之后，右侧的损失函数值（也就是公式5的右边）将与原来 的情况完全一致。此外，用来从模型中采样 的方式也没变，因为 。换句话说，这种重参数化只是数学上的变换，不会引入真正意义上的正则化因子。\",\"但还有另一种方式可以引入“正则化参数”的作用。回忆一下：对于连续型数据，一个比较合适的输出分布是：\",\"其中 是我们人为设定的一个值。因此，重构损失项可以写作：\",\"这里的 是一个常数，与 无关，所以在优化过程中可以忽略。\",\"这意味着在 VAE 的完整优化目标中， 只出现在公式右边的第二项中，而不会影响 KL 散度项。从这个意义上来说， 的作用就像是一个正则化参数 ，它控制着两个损失项之间的权重。\",\"不过，这种参数的存在依赖于我们对 的分布假设。\",\"如果 是连续变量，我们就会使用上述的高斯分布，并引入 来控制建模精度。\",\"但如果 是二值变量，我们会使用 Bernoulli（伯努利）分布作为输出模型。在这种情况下，正则化参数 就消失了。\",\"如果仍然希望引入一个调节项，那只能靠“技巧”——比如把 的维度复制多次（相当于人为扩大重构误差项的权重）。\",\"从信息论的角度看，这种现象是合理的：\",\"当 是二值变量时，我们可以明确地“数清楚”编码 所需的比特数，两个损失项的单位是一致的（都是比特）。\",\"但当 是连续变量时，每个样本理论上都包含“无限信息”。在这种情况下，我们必须设定 ，以决定我们允许模型“多不精确”，这样才能让总的信息量变得有限（否则就永远不能完全编码一个实数向量）。\"]},\"874\":{\"h\":\"条件变分自编码器\",\"t\":[\"让我们回到之前生成手写数字的例子。假设我们不仅想生成新的数字，而是想在一个由同一个人写成的数字串中添加数字。这类似于计算机图形学中的一个实际问题——“补洞”：给定一张用户已经去除了不需要物体的图像，目标是用看起来合理的像素填补这个空洞。\",\"这两个问题的一个重要难点是，合理输出的空间是多模态的：下一个数字或者补充的像素有许多可能。标准的回归模型在这种情况下会失败，因为训练目标通常会惩罚预测结果与真实结果之间的距离。在面对这种问题时，回归模型的最佳结果往往是“介于多种可能之间”的某种平均值。就数字生成而言，这通常表现为模糊无意义的“平均图像”，融合了所有可能的数字和各种可能的书写风格。\",\"我们需要的是一种算法，能输入一个字符串或图像，输出一个复杂的、多模态的概率分布，并从中采样。条件变分自编码器（CVAE）应运而生，它通过简单地对整个生成过程加上条件限制来修改上一节中的数学模型。\",\"CVAE使我们能够解决输入到输出是一对多映射的问题，而无需显式指定输出分布的结构。\",\"给定输入 和输出 ，我们希望建立一个模型 ，最大化真实数据的概率（这里为了与标准机器学习的习惯保持一致，重新定义了 ）。我们通过引入潜变量 来定义模型：\",\"其中， 是一个我们可以从数据中学习的确定性函数。\",\"我们可以将之前的公式（公式2到5）改写为条件形式：\",\"注意， 仍然是标准正态分布 ，因为我们的模型假设在测试时 与 独立采样。\",\"该模型的结构如图6所示。测试时，我们只需从 采样，即可得到 的样本。\"]},\"875\":{\"h\":\"推荐阅读\",\"t\":[\"Introduction: Variational Auto - Encoder\"]},\"876\":{\"h\":\"VQ-VAE 论文解读与代码实现\",\"t\":[\"VQ-VAE 论文解读与代码实现\"]},\"877\":{\"h\":\"引言\",\"t\":[\"近两年，有许多图像生成类任务的前沿工作都使用了一种叫做\\\"codebook\\\"的机制。追溯起来，codebook机制最早是在VQ-VAE论文中提出的。相比于普通的VAE，VQ-VAE能利用codebook机制把图像编码成离散向量，为图像生成类任务提供了一种新的思路。VQ-VAE的这种建模方法启发了无数的后续工作，包括声名远扬的Stable Diffusion。\",\"在这篇文章中，我将先以易懂的逻辑带领大家一步一步领悟VQ-VAE的核心思想，再介绍VQ-VAE中关键算法的具体形式，最后把VQ-VAE的贡献及其对其他工作的影响做一个总结。通过阅读这篇文章，你不仅能理解VQ-VAE本身的原理，更能知道如何将VQ-VAE中的核心机制活学活用。\"]},\"878\":{\"h\":\"从 AE 到 VQ-VAE\",\"t\":[\"为什么VQ-VAE想要把图像编码成离散向量？让我们从最早的自编码器（Autoencoder, AE）开始一步一步谈起。AE是一类能够把图片压缩成较短的向量的神经网络模型，其结构如下图所示。AE包含一个编码器 和一个解码器。在训练时，输入图像 会被编码成一个较短的向量 ，再被解码回另一幅长得差不多的图像 。网络的学习目标是让重建出来的图像 和原图像 尽可能相似。\",\"解码器可以把一个向量解码成图片。换一个角度看，解码器就是一个图像生成模型，因为它可以根据向量来生成图片。那么，AE可不可以用来做图像生成呢？很可惜，AE的编码器编码出来的向量空间是不规整的。也就是说，解码器只认识经编码器编出来的向量，而不认识其他的向量。如果你把自己随机生成出来的向量输入给解码器，解码器是生成不出有意义的图片的。AE不能够随机生成图片，所以它不能很好地完成图像生成任务，只能起到把图像压缩的作用。\",\"AE离图像生成只差一步了。只要AE的编码空间比较规整，符合某个简单的数学分布（比如最常见的标准正态分布），那我们就可以从这个分布里随机采样向量，再让解码器根据这个向量来完成随机图片生成了。VAE就是这样一种改进版的AE。它用一些巧妙的方法约束了编码向量，使得满足标准正态分布。这样，解码器不仅认识编码器编出的向量，还认识其他来自标准正态分布的向量。训练完成后，我们就可以扔掉编码器，用来自标准正态分布的随机向量和解码器来实现随机图像生成了。\",\"VAE的实现细节就不在这里赘述了，是否理解它对理解VQ-VAE没有影响。我们只需知道VAE可以把图片编码成符合标准正态分布的向量即可。让向量符合标准正态分布的原因是方便随机采样。同时，需要强调的是，VAE编码出来的向量是连续向量，也就是向量的每一维都是浮点数。如果把向量的某一维稍微改动0.0001，解码器还是认得这个向量，并且会生成一张和原向量对应图片差不多的图片。\",\"但是，VAE生成出来的图片都不是很好看。VQ-VAE的作者认为，VAE的生成图片之所以质量不高，是因为图片被编码成了连续向量。而实际上，把图片编码成离散向量会更加自然。比如我们想让画家画一个人，我们会说这个是男是女，年龄是偏老还是偏年轻，体型是胖还是壮，而不会说这个人性别是0.5，年龄是0.6，体型是0.7。因此，VQ-VAE会把图片编码成离散向量，如下图所示。\",\"把图像编码成离散向量后，又会带来两个新的问题。第一个问题是，神经网络会默认输入满足一个连续的分布，而不善于处理离散的输入。如果你直接输入0, 1, 2这些数字，神经网络会默认1是一个处于0, 2中间的一种状态。为了解决这一问题，我们可以借鉴NLP中对于离散单词的处理方法。为了处理离散的输入单词，NLP模型的第一层一般都是词嵌入层，它可以把每个输入单词都映射到一个独一无二的连续向量上。这样，每个离散的数字都变成了一个特别的连续向量了。\",\"我们可以把类似的嵌入层加到VQ-VAE的解码器前。这个嵌入层在VQ-VAE里叫做\\\"embedding space（嵌入空间）\\\"，在后续文章中则被称作\\\"codebook\\\"。\",\"离散向量的另一个问题是它不好采样。回忆一下，VAE之所以把图片编码成符合正态分布的连续向量，就是为了能在图像生成时把编码器扔掉，让随机采样出的向量也能通过解码器变成图片。现在倒好，VQ-VAE把图片编码了一个离散向量，这个离散向量构成的空间是不好采样的。VQ-VAE不是面临着和AE一样的问题嘛。\",\"这个问题是无解的。没错！VQ-VAE根本不是一个图像生成模型。它和AE一样，只能很好地完成图像压缩，把图像变成一个短得多的向量，而不支持随机图像生成。VQ-VAE和AE的唯一区别，就是VQ-VAE会编码出离散向量，而AE会编码出连续向量。\",\"可为什么VQ-VAE会被归类到图像生成模型中呢？这是因为VQ-VAE的作者利用VQ-VAE能编码离散向量的特性，使用了一种特别的方法对VQ-VAE的离散编码空间采样。VQ-VAE的作者之前设计了一种图像生成网络，叫做PixelCNN。PixelCNN能拟合一个离散的分布。比如对于图像，PixelCNN能输出某个像素的某个颜色通道取0~255中某个值的概率分布。这不刚好嘛，VQ-VAE也是把图像编码成离散向量。换个更好理解的说法，VQ-VAE能把图像映射成一个「小图像」。我们可以把PixelCNN生成图像的方法搬过来，让PixelCNN学习生成「小图像」。这样，我们就可以用PixelCNN生成离散编码，再利用VQ-VAE的解码器把离散编码变成图像。\",\"让我们来整理一下VQ-VAE的工作过程。\",\"训练VQ-VAE的编码器和解码器，使得VQ-VAE能把图像变成「小图像」，也能把「小图像」变回图像。\",\"训练PixelCNN，让它学习怎么生成「小图像」。\",\"随机采样时，先用PixelCNN采样出「小图像」，再用VQ-VAE把「小图像」翻译成最终的生成图像。\",\"到这里，我们已经学完了VQ-VAE的核心思想。让我们来总结一下。VQ-VAE不是一个VAE，而是一个AE。它的目的是把图像压缩成离散向量。或者换个角度说，它提供了把大图像翻译成「小图像」的方法，也提供了把「小图像」翻译成大图像的方法。这样，一个随机生成大图像的问题，就被转换成了一个等价的随机生成一个较小的「图像」的问题。有一些图像生成模型，比如PixelCNN，更适合拟合离散分布。可以用它们来完成生成「小图像」的问题，填补上VQ-VAE生成图片的最后一片空缺。\"]},\"879\":{\"h\":\"VQ-VAE 实现细节\",\"t\":[\"在上一节中，我们虽然认识了VQ-VAE的核心思想，但略过了不少实现细节，比如：\",\"VQ-VAE的编码器怎么输出离散向量。\",\"VQ-VAE怎么优化编码器和解码器。\",\"VQ-VAE怎么优化嵌入空间。\",\"在这一节里，我们来详细探究这些细节。\"]},\"880\":{\"h\":\"输出离散编码\",\"t\":[\"想让神经网络输出一个整数，最简单的方法是和多分类模型一样，输出一个Softmax过的概率分布。之后，从概率分布里随机采样一个类别，这个类别的序号就是我们想要的整数。比如在下图中，我们想得到一个由3个整数构成的离散编码，就应该让编码器输出3组logit，再经过Softmax与采样，得到3个整数。\",\"但是，这么做不是最高效的。得到离散编码后，下一步我们又要根据嵌入空间把离散编码转回一个向量。可见，获取离散编码这一步有一点多余。能不能把编码器的输出张量（它之前的名字叫logit）、解码器的输入张量embedding、嵌入空间直接关联起来呢？\",\"VQ-VAE 使用了如下方式关联编码器的输出与解码器的输入：假设嵌入空间已经训练完毕，对于编码器的每个输出向量 ，找出它在嵌入空间里的最近邻 ，把 替换成 作为解码器的输入。\",\"求最近邻，即先计算向量与嵌入空间 个向量每个向量的距离，再对距离数组取一个 argmin，求出最近的下标（比如图中的 ），最后用下标去嵌入空间里取向量。下标构成的数组（比如图中的 ）也正是 VQ-VAE 的离散编码。\",\"就这样，我们知道了 VQ-VAE 是怎么生成离散编码的。VQ-VAE 的编码器其实不会显式地输出离散编码，而是输出了多个「假嵌入」 。之后，VQ-VAE 对每个 在嵌入空间里找最近邻，得到真正的嵌入 ，把 作为解码器的输入。\",\"虽然我们现在能把编码器和解码器拼接到一起，但现在又多出了一个问题：怎么让梯度从解码器的输入 传到 ? 从 到 的变换是一个从数组里取值的操作，这个操作是求不了导的。我们在下一小节里来详细探究一下怎么优化 VQ-VAE 的编码器和解码器。\"]},\"881\":{\"h\":\"优化编码器和解码器\",\"t\":[\"为了优化编码器和解码器，我们先来制订一下 VQ-VAE 的整体优化目标。由于 VQ-VAE 其实是一个 AE，误差函数里应该只有原图像和目标图像的重建误差。\",\"或者非要从 VAE 的角度说也行。VQ-VAE 相当于输出了一个 one-hot 离散分布。假设输入图像 的离散编码 是 ，则分布中仅有 ，。令离散编码 的先验分布是均匀分布（假设不知道输入图像 ，每个离散编码取到的概率是等同的），则先验分布 和后验分布 的 KL 散度是常量。因此，KL 散度项不用算入损失函数里。理解此处的数学推导意义不大，还不如直接理解成 VQ-VAE 其实是一个 AE。\",\"但直接拿这个误差来训练是不行的。误差中， 是解码器的输入。从编码器输出 到 这一步是不可导的，误差无法从解码器传递到编码器上。要是可以把 的梯度直接原封不动地复制到 上就好了。\",\"VQ-VAE 使用了一种叫做\\\"straight-through estimator\\\"的技术来完成梯度复制。这种技术是说，前向传播和反向传播的计算可以不对应。你可以为一个运算随意设计求梯度的方法。基于这一技术，VQ-VAE 使用了一种叫做 （stop gradient，停止梯度）的运算：\",\"也就是说，前向传播时，sg 里的值不变；反向传播时，sg 按值为 0 求导，即此次计算无梯度。（反向传播其实不会用到式子的值，只会用到式子的梯度。反向传播用到的 loss 值是在前向传播中算的）。\",\"基于这种运算，我们可以设计一个把梯度从 复制到 的误差：\",\"也就是说，前向传播时，就是拿解码器输入 来算梯度。\",\"而反向传播时，按下面这个公式求梯度，等价于把解码器的梯度全部传给 。\",\"这部分的 PyTorch 实现如下所示。在 PyTorch 里，(x).detach() 就是 ，它的值在前向传播时取 ，反向传播时取 。\",\"1 L = x - decoder(z_e + (z_q - z_e).detach())\",\"通过这一技巧，我们完成了梯度的传递，可以正常地训练编码器和解码器了。\"]},\"882\":{\"h\":\"优化嵌入空间\",\"t\":[\"到目前为止，我们的讨论都是建立在嵌入空间已经训练完毕的前提上的。现在，我们来讨论一下嵌入空间的训练方法。\",\"嵌入空间的优化目标是什么呢？嵌入空间的每一个向量应该能概括一类编码器输出的向量，比如一个表示「青年」的向量应该能概括所有 14–35 岁的人的照片的编码器输出。因此，嵌入空间的向量应该和其对应编码器输出尽可能接近。如下面的公式所示， 是编码器的输出向量， 是其在嵌入空间的最近邻向量。\",\"但作者认为，编码器和嵌入向量的学习速度应该不一样快。于是，他们再次使用了停止梯度的技术，把上面那个误差函数拆成了两部分。其中， 控制了编码器的相对学习速度。作者发现，算法对 的变化不敏感， 取 0.1~2.0 都差不多。\",\"其实，在论文中，作者分别讨论了上面公式里的两个误差。第一个误差来自字典学习算法里的经典算法 Vector Quantisation (VQ)，也就是 VQ-VAE 里的那个 VQ，它用于优化嵌入空间。第二个误差叫做专注误差，它用于约束编码器的输出，不让它跑到离嵌入空间里的向量太远的地方。\",\"这样，VQ-VAE 总体的损失函数可以写成：（由于算上了重建误差，我们多加一个 用于控制不同误差之间的比例）\"]},\"883\":{\"h\":\"总结\",\"t\":[\"VQ-VAE是一个把图像编码成离散向量的图像压缩模型。为了让神经网络理解离散编码，VQ-VAE借鉴了NLP的思想，让每个离散编码值对应一个嵌入，所有的嵌入都存储在一个嵌入空间（又称”codebook”）里。这样，VQ-VAE编码器的输出是若干个「假嵌入」，「假嵌入」会被替换成嵌入空间里最近的真嵌入，输入进解码器里。\",\"VQ-VAE的优化目标由两部分组成：重建误差和嵌入空间误差。重建误差为输入图片和重建图片的均方误差。为了让梯度从解码器传到编码器，作者使用了一种巧妙的停止梯度算子，让正向传播和反向传播按照不同的方式计算。嵌入空间误差为嵌入和其对应的编码器输出的均方误差。为了让嵌入和编码器以不同的速度优化，作者再次使用了停止梯度算子，把嵌入的更新和编码器的更新分开计算。\",\"训练完成后，为了实现随机图像生成，需要对VQ-VAE的离散分布采样，再把采样出来的离散向量对应的嵌入输入进解码器。VQ-VAE论文使用了PixelCNN来采样离散分布。实际上，PixelCNN不是唯一一种可用的拟合离散分布的模型。我们可以把它换成Transformer，甚至是diffusion模型。如果你当年看完VQ-VAE后立刻把PixelCNN换成了diffusion模型，那么恭喜你，你差不多提前设计出了Stable Diffusion。\",\"可见，VQ-VAE最大的贡献是提供了一种图像压缩思路，把生成大图像的问题转换成了一个更简单的生成「小图像」的问题。图像压缩成离散向量时主要借助了嵌入空间，或者说”codebook”这一工具。这种解决问题的思路可以应用到所有图像生成类任务上，比如超分辨率、图像修复、图像去模糊等。所以近两年我们能看到很多使用了codebook的图像生成类工作。\"]},\"884\":{\"h\":\"代码实现\"},\"885\":{\"h\":\"训练阶段\",\"t\":[\"VQ-VAE 的训练阶段分为五个阶段:\",\"我们将基于MINIST数据集进行训练演示\",\"步骤 1️⃣：编码输入图像\",\"用 Encoder 将输入图像 编码为连续隐变量 ，维度通常为 。\",\"这是一个普通的 CNN 编码过程，信息仍是连续的。\",\"# ============================= # 编码器 # ============================= class Encoder(nn.Module): def __init__(self, in_channels=1, hidden_channels=128, z_channels=64): super().__init__() self.conv1 = nn.Conv2d(in_channels, hidden_channels, 4, stride=2, padding=1) # 28x28 -> 14x14 self.conv2 = nn.Conv2d(hidden_channels, z_channels, 4, stride=2, padding=1) # 14x14 -> 7x7 def forward(self, x): x = F.relu(self.conv1(x)) x = self.conv2(x) return x\",\"在 VQ-VAE 中，一张输入图像最终被编码为一个 二维的“索引矩阵”，这个矩阵的每一个元素对应于 codebook 中的一个嵌入向量（embedding vector），表示该位置的图像特征。\",\"不是编码为“一个嵌入向量”的原因\",\"单一嵌入向量（如普通 VAE）：只能保留全局信息，比如图像的类别、姿态等，但无法表达空间结构。\",\"二维嵌入索引矩阵：是每个图像区域（patch/block）对应一个离散 token，可保留局部+空间结构，适合还原复杂细节。\",\"目标不同：压缩 vs 生成\",\"传统 AE/VAE 通常用作图像压缩或聚类，输出一个固定维度的表示。\",\"VQ-VAE 是为生成任务设计的：最终需要还原整张图像，因此不能只用一个全局向量（太少了），而必须保留空间布局。\",\"步骤 2️⃣：量化连续隐变量（离散化）\",\"将 中的每个空间位置的向量与 codebook 中的离散向量（embedding vectors）比较。\",\"选取最相近的向量索引（最近邻搜索），即：\",\"每个位置被替换为最接近的 codebook 向量，形成量化后的表示 。\",\"# ============================= # 向量量化器 # ============================= class VectorQuantizer(nn.Module): def __init__(self, num_embeddings, embedding_dim, commitment_cost): super().__init__() self.embedding_dim = embedding_dim self.num_embeddings = num_embeddings self.beta = commitment_cost # 编码字典 self.embedding = nn.Embedding(num_embeddings, embedding_dim) self.embedding.weight.data.uniform_(-1.0 / num_embeddings, 1.0 / num_embeddings) def forward(self, z): # z: [B, C, H, W] z_perm = z.permute(0, 2, 3, 1).contiguous() # [B, H, W, C] z_flattened = z_perm.view(-1, self.embedding_dim) # [BHW, C] # 欧氏距离计算 dist = ( torch.sum(z_flattened ** 2, dim=1, keepdim=True) - 2 * torch.matmul(z_flattened, self.embedding.weight.t()) + torch.sum(self.embedding.weight ** 2, dim=1) ) # [BHW, num_embeddings] encoding_indices = torch.argmin(dist, dim=1) # [BHW] quantized = self.embedding(encoding_indices) # [BHW, C] # 恢复为 [B, H, W, C] quantized = quantized.view(z_perm.shape) # [B, H, W, C] # 再 permute 回 [B, C, H, W] quantized = quantized.permute(0, 3, 1, 2).contiguous() # 向量量化损失 e_latent_loss = F.mse_loss(quantized.detach(), z) # <== 现在维度一致了 q_latent_loss = F.mse_loss(quantized, z.detach()) loss = q_latent_loss + self.beta * e_latent_loss # straight-through estimator quantized = z + (quantized - z).detach() encoding_indices = encoding_indices.view(z_perm.shape[0], z_perm.shape[1], z_perm.shape[2]) # [B, H, W] return quantized, loss, encoding_indices\",\"步骤 3️⃣：解码离散表示\",\"将 输入 Decoder，还原为重建图像 。\",\"由于 Decoder 处理的是向量索引映射后的嵌入向量，仍然是连续空间中的解码。\",\"# ============================= # 解码器 # ============================= class Decoder(nn.Module): def __init__(self, z_channels=64, hidden_channels=128, out_channels=1): super().__init__() self.conv1 = nn.ConvTranspose2d(z_channels, hidden_channels, 4, stride=2, padding=1) # 7x7 -> 14x14 self.conv2 = nn.ConvTranspose2d(hidden_channels, out_channels, 4, stride=2, padding=1) # 14x14 -> 28x28 def forward(self, z): z = F.relu(self.conv1(z)) z = torch.sigmoid(self.conv2(z)) return z\",\"步骤 4️⃣：计算损失函数（包括三项）\",\"总损失由三个部分组成：\",\"重建误差（图像像素级别 MSE 或 BCE）：\",\"codebook 损失（VQ loss）：鼓励 codebook 向量靠近 encoder 输出：\",\"承诺损失（commitment loss）：鼓励 encoder 输出靠近 codebook 向量：\",\"其中 表示 stop gradient，防止梯度传播到某部分。\",\"总损失为：\",\"# ============================= # VQ-VAE 组合模型 # ============================= class VQVAE(nn.Module): def __init__(self, in_channels=1, z_channels=64, num_embeddings=512, commitment_cost=0.25): super().__init__() self.encoder = Encoder(in_channels, z_channels=z_channels) self.vq = VectorQuantizer(num_embeddings, z_channels, commitment_cost) self.decoder = Decoder(z_channels) def forward(self, x): z = self.encoder(x) quantized, vq_loss, encoding_indices = self.vq(z) x_recon = self.decoder(quantized) return x_recon, vq_loss, encoding_indices\",\"步骤 5️⃣：反向传播与参数更新\",\"使用 straight-through estimator（STE）将编码器的梯度绕过非可导的 nearest neighbor 操作，近似回传。\",\"三部分参数更新：\",\"Encoder 更新：通过 STE 反向传播 的损失；\",\"Codebook 更新：更新嵌入向量（支持 EMA 或普通梯度更新）；\",\"Decoder 更新：通过正常反向传播重建误差更新。\",\"# 加载数据集 transform = transforms.Compose([transforms.ToTensor()]) train_dataset = torchvision.datasets.MNIST(root='./data', train=True, transform=transform, download=True) train_loader = DataLoader(train_dataset, batch_size=128, shuffle=True) # 初始化模型 model = VQVAE().to(device) optimizer = torch.optim.Adam(model.parameters(), lr=1e-3) # 加载预训练模型（可选） model_loaded = False try: model.load_state_dict(torch.load(\\\"vqvae.pth\\\", map_location=device)) print(\\\"✅ 成功加载预训练的 VQ-VAE 模型权重\\\") model_loaded = True except FileNotFoundError: print(\\\"⚠️ 未找到预训练模型，开始从头训练\\\") # 训练模型 if not model_loaded: num_epochs = 10 for epoch in range(num_epochs): model.train() total_recon_loss = 0 total_vq_loss = 0 for x, _ in train_loader: x = x.to(device) x_recon, vq_loss, _ = model(x) recon_loss = F.mse_loss(x_recon, x) loss = recon_loss + vq_loss optimizer.zero_grad() loss.backward() optimizer.step() total_recon_loss += recon_loss.item() total_vq_loss += vq_loss.item() print(f\\\"Epoch [{epoch+1}/{num_epochs}], Recon Loss: {total_recon_loss:.4f}, VQ Loss: {total_vq_loss:.4f}\\\") # 保存模型 torch.save(model.state_dict(), \\\"vqvae.pth\\\") else: print(\\\"⏭️ 已加载预训练模型，跳过训练过程\\\")\"]},\"886\":{\"h\":\"生成阶段\",\"t\":[\"VQ-VAE：学习将图像压缩为离散 latent 表示，并能重建图像。\",\"PixelCNN：学习这些离散 latent 的分布，从而生成新的 latent 表示。\",\"解码阶段：用训练好的 VQ-VAE decoder，将 PixelCNN 采样的 latent 转换为图像。\",\"PixelCNN 模型实现如下(只有空间掩码卷积):\",\"class MaskedConv2d(nn.Conv2d): def __init__(self, mask_type, *args, **kwargs): super().__init__(*args, **kwargs) assert mask_type in ['A', 'B'] self.mask_type = mask_type self.register_buffer('mask', torch.ones_like(self.weight)) _, _, h, w = self.weight.size() yc, xc = h // 2, w // 2 self.mask[:, :, yc, xc+1:] = 0 self.mask[:, :, yc+1:] = 0 if mask_type == 'A': self.mask[:, :, yc, xc] = 0 def forward(self, x): self.weight.data *= self.mask return super().forward(x) class PixelCNN(nn.Module): def __init__(self, num_embeddings, in_channels=1, hidden_channels=64, num_layers=7): super().__init__() layers = [MaskedConv2d('A', in_channels, hidden_channels, kernel_size=7, padding=3), nn.ReLU()] for _ in range(num_layers - 2): layers.append(MaskedConv2d('B', hidden_channels, hidden_channels, 3, padding=1)) layers.append(nn.ReLU()) layers.append(nn.Conv2d(hidden_channels, num_embeddings, 1)) self.net = nn.Sequential(*layers) def forward(self, x): return self.net(x)\",\"基于已经训练好的VQ-VAE模型，再次扫描训练集，提取训练集中每个图像对应的离散 latent 索引列表\",\"# 假设：vqvae = VQVAE(...)，已经训练完毕或已加载权重 # 使用训练集提取离散 latent 索引 model.eval() all_indices = [] with torch.no_grad(): for img, _ in train_loader: z_e = model.encoder(img.to(device)) _, _, indices = model.vq(z_e) all_indices.append(indices.cpu()) # 拼接为 [B , H , W] all_indices = torch.cat(all_indices, dim=0)\",\"基于离散 latent 索引列表，训练 PixelCNN 模型，学习这些离散 latent 的分布规律：\",\"# PixelCNN 训练（学习 latent 索引分布） pixelcnn = PixelCNN(num_embeddings=512).to(device) optimizer = torch.optim.Adam(pixelcnn.parameters(), lr=1e-3) loss_fn = nn.CrossEntropyLoss() # 加载预训练 PixelCNN 模型（可选） pixelcnn_loaded = False try: pixelcnn.load_state_dict(torch.load(\\\"pixelcnn.pth\\\", map_location=device)) print(\\\"✅ 成功加载预训练的 PixelCNN 模型权重\\\") pixelcnn_loaded = True except FileNotFoundError: print(\\\"⚠️ 未找到预训练 PixelCNN 模型，开始从头训练\\\") if not pixelcnn_loaded: for epoch in range(10): total_loss = 0 for i in range(0, all_indices.size(0), 64): batch = all_indices[i:i+64].to(device) input = batch.unsqueeze(1).float() target = batch.long() # input 维度: (64,1,7,7) , logits 维度: (64,512,7,7) ，target 维度: (64,7,7) logits = pixelcnn(input) loss = loss_fn(logits, target) optimizer.zero_grad() loss.backward() optimizer.step() total_loss += loss.item() print(f\\\"[PixelCNN] Epoch {epoch+1} Loss: {total_loss:.4f}\\\") # 保存模型 torch.save(pixelcnn.state_dict(), \\\"pixelcnn.pth\\\") else: print(\\\"⏭️ 已加载预训练 PixelCNN 模型，跳过训练过程\\\")\",\"PixelCNN 学习的是 latent index 的分布\",\"PixelCNN 生成 latent 索引 → VQ-VAE 解码成图像\",\"def sample_latent(pixelcnn, shape, num_embeddings): pixelcnn.eval() with torch.no_grad(): B, H, W = shape sample = torch.zeros((B, 1, H, W)).to(device) # 初始化 sample for i in range(H): for j in range(W): logits = pixelcnn(sample) probs = F.softmax(logits[:, :, i, j], dim=-1) sample[:, 0, i, j] = torch.multinomial(probs, 1).squeeze(-1) return sample.squeeze(1).long() # [B, H, W] # 从 PixelCNN 生成 latent 索引 sampled_indices = sample_latent(pixelcnn, shape=(8, 7, 7), num_embeddings=512) # 还原为 codebook 嵌入向量 embeddings = model.vq.embedding.weight quantized = embeddings[sampled_indices.view(-1)].view(8, 7, 7, -1).permute(0, 3, 1, 2).contiguous() # 解码成图像 with torch.no_grad(): recon = model.decoder(quantized).cpu() # 可视化 import matplotlib.pyplot as plt for i in range(8): plt.subplot(2, 4, i+1) plt.imshow(recon[i][0], cmap='gray') plt.axis('off') plt.suptitle(\\\"Generated Images from PixelCNN + VQ-VAE\\\") plt.show()\",\"由于训练轮次很少，所以效果也比较差:\"]},\"887\":{\"h\":\"\",\"t\":[\"本文转载至: 轻松理解 VQ-VAE：首个提出 codebook 机制的生成模型\"]},\"888\":{\"h\":\"WGAN 学习笔记\",\"t\":[\"WGAN 学习笔记\"]},\"889\":{\"h\":\"\",\"t\":[\"404 Not Found\"]}},\"dirtCount\":0,\"index\":[[\"⏭️\",{\"1\":{\"885\":1,\"886\":1}}],[\"承诺损失\",{\"1\":{\"885\":1}}],[\"太少了\",{\"1\":{\"885\":1}}],[\"太大\",{\"1\":{\"112\":1}}],[\"太大则可能导致不相关的点增多\",{\"1\":{\"90\":1}}],[\"姿态等\",{\"1\":{\"885\":1}}],[\"岁的人的照片的编码器输出\",{\"1\":{\"882\":1}}],[\"青年\",{\"1\":{\"882\":1}}],[\"停止梯度\",{\"1\":{\"881\":1}}],[\"没错\",{\"1\":{\"878\":1}}],[\"没有给出的步骤\",{\"1\":{\"858\":1}}],[\"没有不确定性\",{\"1\":{\"829\":1}}],[\"没有重复的维度字母表示保留该维度\",{\"1\":{\"367\":1}}],[\"没有\",{\"1\":{\"346\":1}}],[\"没有像\",{\"1\":{\"336\":1}}],[\"没有padding\",{\"1\":{\"322\":1}}],[\"没有固定顺序\",{\"1\":{\"104\":1}}],[\"追溯起来\",{\"1\":{\"877\":1}}],[\"追加到列表尾部\",{\"1\":{\"668\":1}}],[\"介于多种可能之间\",{\"1\":{\"874\":1}}],[\"介绍了gpt\",{\"1\":{\"519\":1}}],[\"介绍几种具体的技巧\",{\"1\":{\"500\":1}}],[\"介绍\",{\"0\":{\"298\":1}}],[\"伯努利\",{\"1\":{\"873\":1}}],[\"伯努利分布的概率密度函数\",{\"1\":{\"854\":1}}],[\"伯努利分布与二项分布\",{\"0\":{\"737\":1}}],[\"吸收到\",{\"1\":{\"873\":1}}],[\"吸收图像特征\",{\"1\":{\"312\":1}}],[\"制造出\",{\"1\":{\"873\":1}}],[\"至少在一维情形下\",{\"1\":{\"871\":1}}],[\"端的神经网络\",{\"1\":{\"871\":1}}],[\"端到端的框架\",{\"1\":{\"250\":2}}],[\"永远不会为零\",{\"1\":{\"871\":1}}],[\"毕竟\",{\"1\":{\"868\":1}}],[\"式\",{\"1\":{\"867\":1}}],[\"式的\",{\"1\":{\"790\":1}}],[\"式的预训练方法\",{\"0\":{\"788\":1}}],[\"呢\",{\"1\":{\"867\":1,\"871\":1}}],[\"希望这个\",{\"1\":{\"867\":1}}],[\"希腊字母读音为\",{\"1\":{\"248\":1}}],[\"足够小\",{\"1\":{\"866\":1}}],[\"足够大的语言模型在多样化文本训练下\",{\"1\":{\"520\":1}}],[\"足够大\",{\"1\":{\"246\":2}}],[\"贡献很小\",{\"1\":{\"866\":1}}],[\"笔画细\",{\"1\":{\"866\":1}}],[\"笔画粗细\",{\"1\":{\"866\":1}}],[\"潜变量\",{\"1\":{\"865\":2}}],[\"潜变量模型\",{\"0\":{\"865\":1}}],[\"潜在风险\",{\"1\":{\"539\":1}}],[\"潜在生成式模型\",{\"1\":{\"516\":1}}],[\"潜在交互意图\",{\"1\":{\"28\":1}}],[\"ℝ\",{\"1\":{\"853\":2}}],[\"始终为正数\",{\"1\":{\"853\":1}}],[\"始终使用完整长度序列\",{\"1\":{\"561\":1}}],[\"ε\",{\"1\":{\"853\":1}}],[\"摘录\",{\"0\":{\"849\":1}}],[\"摘要等多样化任务\",{\"1\":{\"522\":1}}],[\"摘要生成\",{\"1\":{\"522\":1}}],[\"摘要任务\",{\"1\":{\"521\":1}}],[\"摘要和阅读理解等\",{\"1\":{\"519\":1}}],[\"摘要\",{\"0\":{\"5\":1,\"48\":1,\"188\":1,\"215\":1,\"506\":1,\"519\":1,\"526\":1,\"534\":1,\"546\":1,\"555\":1,\"558\":1,\"765\":1},\"1\":{\"521\":1,\"522\":1,\"537\":1}}],[\"灰度图\",{\"1\":{\"848\":2}}],[\"灰色\",{\"1\":{\"83\":1}}],[\"断言检查\",{\"1\":{\"848\":1}}],[\"干脆放弃了概率模型\",{\"1\":{\"847\":1}}],[\"干扰样本\",{\"1\":{\"274\":1}}],[\"跑哪去了\",{\"1\":{\"843\":1}}],[\"吗\",{\"1\":{\"843\":1}}],[\"＋\",{\"1\":{\"841\":1}}],[\"挖坑\",{\"1\":{\"841\":1}}],[\"挖掘物体的不变几何属性\",{\"1\":{\"26\":1}}],[\"挖掘其他可能交互意图\",{\"1\":{\"12\":1}}],[\"挖掘不变几何属性与潜在交互意图\",{\"1\":{\"8\":1}}],[\"骗过\",{\"1\":{\"840\":2}}],[\"温和\",{\"1\":{\"839\":1}}],[\"温度高时更平滑\",{\"1\":{\"795\":1}}],[\"温度越低\",{\"1\":{\"795\":1}}],[\"温度不小于\",{\"1\":{\"728\":1}}],[\"温度小于\",{\"1\":{\"728\":1}}],[\"温度是\",{\"1\":{\"728\":1}}],[\"温度在\",{\"1\":{\"728\":4}}],[\"温度超参数\",{\"1\":{\"248\":1}}],[\"温度系数\",{\"1\":{\"248\":1}}],[\"温度\",{\"1\":{\"179\":1,\"821\":1,\"822\":1}}],[\"温度参数\",{\"1\":{\"147\":1,\"248\":1,\"254\":1,\"795\":1,\"821\":1,\"822\":1}}],[\"海拔可能变\",{\"1\":{\"839\":1}}],[\"海拔最多变\",{\"1\":{\"839\":1}}],[\"米\",{\"1\":{\"839\":2}}],[\"米水平路\",{\"1\":{\"839\":2}}],[\"斜率\",{\"1\":{\"839\":1}}],[\"叫做pixelcnn\",{\"1\":{\"878\":1}}],[\"叫做\",{\"1\":{\"839\":1}}],[\"叫做个体判别\",{\"1\":{\"243\":1}}],[\"叫\",{\"1\":{\"839\":1}}],[\"想让神经网络输出一个整数\",{\"1\":{\"880\":1}}],[\"想象你走山路\",{\"1\":{\"839\":1}}],[\"想象有两个人分别站在一条直线上的不同点\",{\"1\":{\"837\":1}}],[\"想保留原序列则\",{\"1\":{\"398\":1}}],[\"浅层直观\",{\"0\":{\"834\":1}}],[\"浅蓝色矩形\",{\"1\":{\"696\":1}}],[\"↘\",{\"1\":{\"831\":2}}],[\"抛硬币连续两次都正面\",{\"1\":{\"828\":1}}],[\"抛硬币得到正面\",{\"1\":{\"828\":1}}],[\"惊讶\",{\"1\":{\"828\":1}}],[\"熵为\",{\"1\":{\"829\":1}}],[\"熵最大\",{\"1\":{\"829\":1}}],[\"熵越大\",{\"1\":{\"829\":1}}],[\"熵是平均信息量\",{\"1\":{\"829\":1}}],[\"熵\",{\"0\":{\"827\":1},\"1\":{\"830\":1,\"831\":2}}],[\"π2\",{\"1\":{\"821\":3}}],[\"π1\",{\"1\":{\"821\":4}}],[\"π0\",{\"1\":{\"821\":2}}],[\"宽高\",{\"1\":{\"821\":1}}],[\"宽度\",{\"1\":{\"204\":1,\"385\":1,\"846\":1}}],[\"宽度3200\",{\"1\":{\"197\":1}}],[\"顺序感知\",{\"1\":{\"820\":1}}],[\"顺序被随机打乱\",{\"1\":{\"375\":1}}],[\"地跟随条件\",{\"1\":{\"816\":1}}],[\"地板除\",{\"0\":{\"354\":1},\"1\":{\"354\":1}}],[\"地板等\",{\"1\":{\"101\":1}}],[\"淹没\",{\"1\":{\"815\":1}}],[\"却输出\",{\"1\":{\"814\":2}}],[\"松弛温度与步长的退火策略\",{\"1\":{\"808\":1}}],[\"松弛\",{\"1\":{\"808\":1}}],[\"松弛方法\",{\"1\":{\"770\":1}}],[\"¹\",{\"1\":{\"807\":1}}],[\"似然函数为\",{\"1\":{\"826\":1}}],[\"似然函数定义为在参数\",{\"1\":{\"826\":1}}],[\"似然方程\",{\"1\":{\"826\":1}}],[\"似然\",{\"1\":{\"807\":1}}],[\"饱和度\",{\"1\":{\"802\":1}}],[\"饱和度变化\",{\"1\":{\"186\":1}}],[\"跳坑\",{\"1\":{\"841\":1}}],[\"跳出尝试循环\",{\"1\":{\"801\":1}}],[\"跳出循环\",{\"1\":{\"801\":1}}],[\"跳过训练过程\",{\"1\":{\"885\":1,\"886\":1}}],[\"跳过这对\",{\"1\":{\"578\":1}}],[\"跳过一行\",{\"1\":{\"425\":1}}],[\"布尔值\",{\"1\":{\"795\":1}}],[\"布尔张量\",{\"1\":{\"591\":1}}],[\"尖锐度\",{\"1\":{\"795\":1}}],[\"尖锐程度\",{\"1\":{\"248\":1}}],[\"软匹配\",{\"1\":{\"865\":1}}],[\"软\",{\"1\":{\"795\":1}}],[\"软采样\",{\"1\":{\"795\":2}}],[\"软标签分配\",{\"1\":{\"176\":1}}],[\"软标签\",{\"1\":{\"147\":1}}],[\"软标签计算\",{\"1\":{\"145\":1}}],[\"软标签通常用于边界模糊区域\",{\"1\":{\"64\":1}}],[\"掉了\",{\"1\":{\"803\":1}}],[\"掉\",{\"1\":{\"788\":1}}],[\"掉的\",{\"1\":{\"160\":1,\"788\":1,\"801\":1,\"802\":1}}],[\"掉的单词\",{\"1\":{\"155\":1}}],[\"拼图\",{\"1\":{\"786\":1}}],[\"拼接为\",{\"1\":{\"886\":1}}],[\"拼接到已有序列后\",{\"1\":{\"820\":1}}],[\"拼接到文本后面作为起始序列\",{\"1\":{\"817\":1}}],[\"拼接而成的序列\",{\"1\":{\"820\":1}}],[\"拼接新生成的\",{\"1\":{\"817\":1}}],[\"拼接起来\",{\"1\":{\"807\":1,\"813\":1}}],[\"拼接等操作\",{\"1\":{\"681\":1}}],[\"拼接前提文本\",{\"1\":{\"512\":1}}],[\"拼接平均池化的\",{\"1\":{\"212\":1}}],[\"拼接结果\",{\"1\":{\"186\":1}}],[\"拼接当前动量文本特征和文本队列\",{\"1\":{\"161\":1}}],[\"拼接当前动量图像特征和图像队列\",{\"1\":{\"161\":1}}],[\"拼接机制不够精细\",{\"1\":{\"112\":1}}],[\"拼接方式缺乏动态调整机制\",{\"1\":{\"112\":1}}],[\"拼接\",{\"1\":{\"59\":1,\"186\":1,\"272\":2,\"276\":2,\"333\":1,\"579\":1,\"804\":1,\"809\":1,\"815\":2}}],[\"拼接嵌入向量\",{\"1\":{\"43\":1}}],[\"拼接在一起\",{\"1\":{\"43\":1,\"312\":1,\"541\":1}}],[\"拼接多模态嵌入与语言嵌入\",{\"0\":{\"43\":1},\"1\":{\"40\":1}}],[\"拼接后的输入嵌入\",{\"1\":{\"43\":1}}],[\"拼接后\",{\"1\":{\"34\":1,\"35\":1,\"36\":1,\"272\":1}}],[\"拼接后送入解码器输出可供性预测\",{\"1\":{\"15\":1}}],[\"遮住当前像素及其右方\",{\"1\":{\"848\":1}}],[\"遮一片连续矩形区域\",{\"1\":{\"801\":1}}],[\"遮挡掩码\",{\"1\":{\"802\":2,\"803\":1}}],[\"遮挡块的最小宽高比\",{\"1\":{\"801\":1}}],[\"遮挡区域零碎\",{\"1\":{\"801\":1}}],[\"遮挡\",{\"1\":{\"801\":1,\"803\":1}}],[\"遮挡方式\",{\"1\":{\"801\":2}}],[\"遮挡位置记作集合\",{\"1\":{\"772\":1}}],[\"遮盖语言建模\",{\"1\":{\"268\":1}}],[\"异排列数\",{\"1\":{\"762\":2,\"763\":2}}],[\"异常值\",{\"1\":{\"797\":1}}],[\"异常值等问题\",{\"1\":{\"104\":1}}],[\"异常数据\",{\"1\":{\"717\":1}}],[\"异常检测\",{\"1\":{\"115\":1}}],[\"异常检测等特殊场景\",{\"1\":{\"115\":1}}],[\"异常点会影响分类和分割性能\",{\"1\":{\"112\":1}}],[\"听话\",{\"1\":{\"816\":1}}],[\"听者必须从说话者表达出的\",{\"1\":{\"759\":1}}],[\"听懂人话\",{\"1\":{\"239\":1}}],[\"置信度\",{\"1\":{\"758\":1}}],[\"贝叶斯公式本身非常简单\",{\"1\":{\"758\":1}}],[\"贝叶斯公式\",{\"1\":{\"758\":1,\"867\":1}}],[\"贝叶斯\",{\"1\":{\"758\":1}}],[\"贝叶斯法则写作\",{\"1\":{\"734\":1}}],[\"贝叶斯法则可以写为\",{\"1\":{\"733\":1}}],[\"贝叶斯法则\",{\"0\":{\"732\":1}}],[\"术语\",{\"1\":{\"758\":3}}],[\"密度\",{\"1\":{\"754\":1}}],[\"密度越小\",{\"1\":{\"754\":1}}],[\"壳层的厚度为\",{\"1\":{\"753\":1}}],[\"众数\",{\"1\":{\"753\":1}}],[\"众多基于视觉\",{\"1\":{\"297\":1}}],[\"球体的体积随半径\",{\"1\":{\"754\":1}}],[\"球形协方差矩阵\",{\"1\":{\"752\":1}}],[\"球查询\",{\"1\":{\"92\":2}}],[\"鉴于它的重要性\",{\"1\":{\"750\":1}}],[\"洛伦兹分布\",{\"1\":{\"749\":1}}],[\"柯西分布\",{\"0\":{\"749\":1},\"1\":{\"749\":1}}],[\"附近\",{\"1\":{\"746\":1,\"755\":2}}],[\"附录d\",{\"1\":{\"550\":1}}],[\"附录\",{\"0\":{\"478\":1},\"1\":{\"808\":1,\"871\":1}}],[\"附录内容\",{\"0\":{\"207\":1}}],[\"窄\",{\"1\":{\"746\":1}}],[\"事实证明\",{\"1\":{\"873\":1}}],[\"事实上\",{\"1\":{\"744\":1,\"750\":1}}],[\"事情会变得复杂\",{\"1\":{\"869\":1}}],[\"事件越罕见\",{\"1\":{\"828\":1}}],[\"事件集合体系\",{\"1\":{\"728\":1}}],[\"事件结果\",{\"1\":{\"727\":1}}],[\"事件\",{\"1\":{\"727\":2,\"728\":1,\"729\":1,\"730\":2,\"734\":1}}],[\"事件空间为\",{\"1\":{\"727\":1}}],[\"试验次数\",{\"1\":{\"741\":1}}],[\"红球\",{\"1\":{\"741\":1}}],[\"红色为剔除的文本\",{\"1\":{\"132\":1}}],[\"红色=功能区域\",{\"1\":{\"83\":1}}],[\"红色\",{\"1\":{\"83\":2}}],[\"红色区域为点云的可供性标注\",{\"1\":{\"17\":1}}],[\"失败次数\",{\"1\":{\"741\":1}}],[\"失败\",{\"1\":{\"741\":1}}],[\"容器\",{\"1\":{\"740\":1}}],[\"容易导致预训练过拟合\",{\"1\":{\"149\":1}}],[\"容易出错\",{\"1\":{\"112\":1}}],[\"盒子\",{\"1\":{\"740\":1}}],[\"服从概率密度\",{\"1\":{\"865\":1}}],[\"服从\",{\"1\":{\"741\":1}}],[\"服从二项分布\",{\"1\":{\"740\":1}}],[\"服从参数为\",{\"1\":{\"739\":1}}],[\"服务器训练\",{\"1\":{\"173\":1}}],[\"泊松分布是负二项分布的一个特例\",{\"1\":{\"744\":1}}],[\"泊松分布\",{\"0\":{\"739\":1}}],[\"读作\",{\"1\":{\"737\":1}}],[\"读取训练语料\",{\"1\":{\"476\":1}}],[\"读取图片并将其转换为合适的格式后\",{\"1\":{\"302\":1}}],[\"读取出所有点云文件路径\",{\"1\":{\"58\":1}}],[\"读取出所有图片路径\",{\"1\":{\"58\":1}}],[\"读取所有点云路径\",{\"1\":{\"29\":1}}],[\"读取所有图片路径\",{\"1\":{\"29\":1}}],[\"阳性概率应该很高\",{\"1\":{\"731\":1}}],[\"患病\",{\"1\":{\"731\":1}}],[\"赋一个非负权重\",{\"1\":{\"728\":1}}],[\"赋予局部特征提取的能力\",{\"1\":{\"326\":1}}],[\"半柯西分布\",{\"1\":{\"749\":1}}],[\"半正态分布\",{\"0\":{\"747\":1}}],[\"半开区间\",{\"1\":{\"728\":1}}],[\"半径太小可能无法有效捕获足够的局部详细\",{\"1\":{\"90\":1}}],[\"奇怪\",{\"1\":{\"728\":1}}],[\"度\",{\"1\":{\"728\":3}}],[\"度或\",{\"1\":{\"728\":1}}],[\"度之间\",{\"1\":{\"728\":1}}],[\"度量两个变量是否同步变化\",{\"1\":{\"455\":1}}],[\"秒\",{\"1\":{\"728\":2}}],[\"测量值是无理数\",{\"1\":{\"728\":1}}],[\"测量某事件持续时间\",{\"1\":{\"728\":1}}],[\"测试已学习的模型\",{\"0\":{\"869\":1}}],[\"测试的重要性\",{\"0\":{\"677\":1}}],[\"测试数据使用1k\",{\"1\":{\"593\":1}}],[\"测试和开发集\",{\"1\":{\"593\":1}}],[\"测试模型的长距离依赖能力\",{\"1\":{\"561\":1}}],[\"测试显示职业性别刻板印象明显\",{\"1\":{\"551\":1}}],[\"测试重叠率5\",{\"1\":{\"522\":1}}],[\"测试常识推理能力\",{\"1\":{\"522\":1}}],[\"测试图片分类正确率\",{\"1\":{\"302\":1,\"304\":1}}],[\"测试阶段\",{\"1\":{\"227\":1,\"273\":1}}],[\"测试阶段用中心裁剪来报告准确率\",{\"1\":{\"179\":1}}],[\"测试时\",{\"1\":{\"869\":1,\"874\":1}}],[\"测试时输入\",{\"1\":{\"588\":1}}],[\"测试时支持40区块\",{\"1\":{\"224\":1}}],[\"测试时可扩展至\",{\"1\":{\"222\":1}}],[\"测试划分\",{\"1\":{\"142\":1}}],[\"测试集上\",{\"1\":{\"202\":1}}],[\"测试集最终评估\",{\"1\":{\"82\":1}}],[\"测试集\",{\"1\":{\"68\":1,\"80\":1,\"716\":1}}],[\"测试集中\",{\"1\":{\"398\":1}}],[\"测试集中的可供性类别未在训练集中出现\",{\"1\":{\"20\":1}}],[\"测试集中包含训练集中未出现的物体类别\",{\"1\":{\"20\":1}}],[\"测试\",{\"0\":{\"674\":1},\"1\":{\"29\":1,\"66\":1,\"68\":1,\"715\":1,\"820\":1}}],[\"掷硬币\",{\"1\":{\"826\":1}}],[\"掷两次硬币的\",{\"1\":{\"727\":1}}],[\"掷两次公平硬币\",{\"1\":{\"727\":1}}],[\"掷一个三面骰子\",{\"1\":{\"727\":1}}],[\"探讨边界情况\",{\"1\":{\"717\":1}}],[\"探索\",{\"1\":{\"539\":1}}],[\"探索指令格式变化对模型泛化能力的影响\",{\"1\":{\"536\":1}}],[\"脏数据进行清洗\",{\"1\":{\"717\":1}}],[\"音视频等\",{\"1\":{\"717\":1}}],[\"音频和视频\",{\"1\":{\"704\":1}}],[\"绝大部分大模型应用都是采用的特定数据库\",{\"1\":{\"717\":1}}],[\"绝对位置编码\",{\"0\":{\"586\":1}}],[\"绝对位置编码参数\",{\"1\":{\"272\":1}}],[\"搭建数据库\",{\"1\":{\"717\":1}}],[\"搭建项目的整体架构\",{\"1\":{\"717\":1}}],[\"搭建整体架构\",{\"1\":{\"717\":1}}],[\"搭配70亿或130亿参数的llms\",{\"1\":{\"216\":1}}],[\"业务逻辑分解\",{\"1\":{\"716\":1}}],[\"业务逻辑分解等手段来充分发挥大模型能力\",{\"1\":{\"716\":1}}],[\"业界很早就发现了用户对于对话交互的特殊偏好\",{\"1\":{\"708\":1}}],[\"流程更为灵活和敏捷\",{\"1\":{\"716\":1}}],[\"流程四步走\",{\"1\":{\"100\":1}}],[\"流式处理\",{\"1\":{\"714\":1}}],[\"拥有近\",{\"1\":{\"714\":1}}],[\"拥有一个规模大且特征较为一致的字典\",{\"1\":{\"245\":1}}],[\"享受到更加安全稳定的开发体验\",{\"1\":{\"714\":1}}],[\"链路组合来实现业务逻辑\",{\"1\":{\"716\":1}}],[\"链式操作\",{\"1\":{\"714\":1}}],[\"链式法则\",{\"0\":{\"655\":1}}],[\"链\",{\"1\":{\"713\":1}}],[\"箭头表示数据流的方向\",{\"1\":{\"712\":1}}],[\"许多机构和个人相继推出了多个开源项目\",{\"1\":{\"712\":1}}],[\"许多研究人员开始训练越来越庞大的语言模型\",{\"1\":{\"703\":1}}],[\"黑盒子\",{\"1\":{\"711\":1}}],[\"黑点为采样点\",{\"1\":{\"387\":1}}],[\"微软\",{\"1\":{\"708\":1}}],[\"微调后准确率从63\",{\"1\":{\"550\":1}}],[\"微调也仅为\",{\"1\":{\"539\":1}}],[\"微调模型\",{\"1\":{\"537\":1}}],[\"微调预训练\",{\"1\":{\"537\":1}}],[\"微调预训练的gpt\",{\"1\":{\"535\":1}}],[\"微调小型数据集以嵌入价值观\",{\"1\":{\"536\":1}}],[\"微调范式\",{\"1\":{\"531\":1}}],[\"微调范式与任务适应能力的关系\",{\"1\":{\"531\":1}}],[\"微调任务和数据集如下\",{\"1\":{\"515\":1}}],[\"微调的对比可以参考下表\",{\"1\":{\"711\":1}}],[\"微调的细节\",{\"1\":{\"514\":1}}],[\"微调的场景中\",{\"1\":{\"495\":1}}],[\"微调的最终目的\",{\"1\":{\"483\":1}}],[\"微调流程\",{\"1\":{\"492\":1}}],[\"微调之后的模型\",{\"1\":{\"491\":1}}],[\"微调相对来说就是一个更优的方案\",{\"1\":{\"482\":1}}],[\"微调用于图像描述\",{\"1\":{\"269\":1}}],[\"微调成本高\",{\"1\":{\"239\":1}}],[\"微调整个模型参数\",{\"1\":{\"239\":1}}],[\"微调时保持视觉编码器参数不变\",{\"1\":{\"235\":1}}],[\"微调时提升为\",{\"1\":{\"131\":1}}],[\"微调过程\",{\"1\":{\"235\":1}}],[\"微调数据规模\",{\"1\":{\"550\":1}}],[\"微调数据\",{\"1\":{\"225\":1}}],[\"微调评估\",{\"1\":{\"179\":1}}],[\"微调阶段的数据组织方式如下\",{\"1\":{\"235\":1}}],[\"微调阶段使用的是作者自己构建的高质量多模态指令数据集\",{\"1\":{\"235\":1}}],[\"微调阶段\",{\"0\":{\"142\":1,\"145\":1},\"1\":{\"233\":1,\"509\":1}}],[\"微调\",{\"0\":{\"235\":1,\"492\":1},\"1\":{\"24\":1,\"206\":1,\"210\":1,\"528\":1,\"531\":1,\"536\":1,\"711\":4}}],[\"智能体\",{\"1\":{\"708\":1}}],[\"智慧化知识库系统\",{\"0\":{\"720\":1},\"1\":{\"702\":1,\"719\":1}}],[\"贾维斯\",{\"1\":{\"708\":1}}],[\"亚马逊\",{\"1\":{\"708\":1}}],[\"苹果\",{\"1\":{\"708\":1}}],[\"陆奇在微软期间\",{\"1\":{\"708\":1}}],[\"获得每个像素的概率分布\",{\"1\":{\"848\":1}}],[\"获得连续隐变量\",{\"1\":{\"794\":1}}],[\"获得的一系列离散\",{\"1\":{\"770\":1}}],[\"获得更好的应用效果\",{\"1\":{\"707\":1}}],[\"获得可以适用于大量下游任务的大模型\",{\"1\":{\"707\":1}}],[\"获取离散编码这一步有一点多余\",{\"1\":{\"880\":1}}],[\"获取卷积核尺寸\",{\"1\":{\"848\":1}}],[\"获取图文\",{\"1\":{\"822\":1}}],[\"获取图片\",{\"1\":{\"29\":1,\"58\":1}}],[\"获取维度信息\",{\"1\":{\"821\":1}}],[\"获取维度数\",{\"1\":{\"689\":1}}],[\"获取嵌入向量图\",{\"1\":{\"821\":1}}],[\"获取最后一维的大小\",{\"1\":{\"818\":1}}],[\"获取最后一层的自注意力权重\",{\"1\":{\"463\":1}}],[\"获取最后一层的自注意力权重矩阵\",{\"1\":{\"463\":2}}],[\"获取损失的标量值\",{\"1\":{\"803\":1}}],[\"获取元素总数\",{\"1\":{\"689\":1}}],[\"获取实际对象\",{\"1\":{\"687\":1}}],[\"获取选项个数\",{\"1\":{\"618\":1}}],[\"获取词嵌入层权重\",{\"1\":{\"580\":1}}],[\"获取所有单词并去重\",{\"1\":{\"578\":1}}],[\"获取所有单词和每个单词的出现次数词典\",{\"1\":{\"476\":1}}],[\"获取每个相邻字符对的出现次数\",{\"1\":{\"476\":3}}],[\"获取每个输入\",{\"1\":{\"186\":1}}],[\"获取子张量\",{\"1\":{\"425\":1}}],[\"获取第二列\",{\"1\":{\"425\":1}}],[\"获取第二行\",{\"1\":{\"425\":1}}],[\"获取输入张量x的形状\",{\"1\":{\"322\":1}}],[\"获取输入图像张量的形状\",{\"1\":{\"318\":1}}],[\"获取输入维度信息\",{\"1\":{\"40\":1}}],[\"获取对应图像的标签\",{\"1\":{\"316\":1}}],[\"获取对应的负文本嵌入\",{\"1\":{\"162\":1}}],[\"获取对应的负图像嵌入\",{\"1\":{\"162\":1}}],[\"获取该类别对应的索引\",{\"1\":{\"316\":1}}],[\"获取其对应的图像嵌入向量列表\",{\"1\":{\"302\":1}}],[\"获取候选分类名列表\",{\"1\":{\"302\":1,\"304\":1}}],[\"获取正负样本数量及\",{\"1\":{\"278\":1}}],[\"获取相对位置偏置\",{\"1\":{\"277\":1}}],[\"获取表示再融合\",{\"1\":{\"261\":1}}],[\"获取区域特征时可扩展性差\",{\"1\":{\"261\":1}}],[\"获取初始的\",{\"1\":{\"169\":1}}],[\"获取全局区域特征向量后\",{\"1\":{\"93\":1}}],[\"获取当前最高频的字符对\",{\"1\":{\"476\":3}}],[\"获取当前\",{\"1\":{\"107\":1}}],[\"获取当前功能类型对应的索引值\",{\"1\":{\"68\":1}}],[\"获取当前样本对应的问题文本\",{\"1\":{\"68\":1}}],[\"获取当前样本对应的功能区域掩码\",{\"1\":{\"68\":1}}],[\"获取当前样本对应的功能类型\",{\"1\":{\"68\":1}}],[\"获取当前样本对应的物体类别\",{\"1\":{\"68\":1}}],[\"获取当前样本对应的点云id\",{\"1\":{\"68\":1}}],[\"获取当前样本的物体类别和物体信息值\",{\"1\":{\"68\":1}}],[\"获取当前样本中多模态嵌入的维度信息\",{\"1\":{\"43\":1}}],[\"获取样本的代码实现\",{\"1\":{\"68\":1}}],[\"获取两个注意力加权结果\",{\"1\":{\"45\":1}}],[\"获取\",{\"1\":{\"43\":1,\"45\":1,\"163\":2,\"276\":1,\"293\":1,\"463\":1,\"580\":1,\"804\":2,\"815\":1,\"820\":1}}],[\"获取语言嵌入\",{\"1\":{\"40\":1}}],[\"获取设备信息\",{\"1\":{\"40\":1}}],[\"获取数据类型\",{\"1\":{\"689\":1}}],[\"获取数据形状\",{\"1\":{\"689\":1}}],[\"获取数据\",{\"1\":{\"29\":1,\"58\":1}}],[\"斯坦福大学等多所高校的研究人员提出了基座模型\",{\"1\":{\"707\":1}}],[\"斯坦福提出的\",{\"1\":{\"491\":1}}],[\"据推测\",{\"1\":{\"706\":1}}],[\"量变引起质变\",{\"1\":{\"706\":1}}],[\"量化连续隐变量\",{\"1\":{\"885\":1}}],[\"量化通过将这些高精度的浮点数转换为低精度的整数\",{\"1\":{\"495\":1}}],[\"量化是一种在深度学习领域用于减少模型内存占用和计算量的技术\",{\"1\":{\"495\":1}}],[\"量化的核心目标是降成本\",{\"1\":{\"488\":1}}],[\"量化\",{\"1\":{\"488\":2}}],[\"量化误差\",{\"1\":{\"386\":1}}],[\"量化损失\",{\"1\":{\"170\":2}}],[\"量化前做\",{\"1\":{\"170\":1}}],[\"量化后的特征图\",{\"1\":{\"170\":1}}],[\"量化后的\",{\"1\":{\"167\":1}}],[\"量化器在代码本\",{\"1\":{\"167\":1}}],[\"量化分析\",{\"1\":{\"23\":1}}],[\"集中在\",{\"1\":{\"746\":1}}],[\"集成\",{\"1\":{\"712\":1}}],[\"集群来实现\",{\"1\":{\"705\":1}}],[\"集合\",{\"1\":{\"336\":1,\"728\":1}}],[\"集合函数近似器\",{\"1\":{\"115\":1}}],[\"集合抽象\",{\"1\":{\"98\":1}}],[\"伦理隐私\",{\"1\":{\"711\":1}}],[\"伦理和风险问题\",{\"1\":{\"705\":1}}],[\"伦理响应\",{\"1\":{\"550\":1}}],[\"巨大的规模\",{\"1\":{\"705\":1}}],[\"媲美\",{\"1\":{\"704\":1}}],[\"团队开发的开源大语言模型系列\",{\"1\":{\"704\":1}}],[\"讯飞发布了推理思考模型\",{\"1\":{\"704\":1}}],[\"讯飞星火\",{\"1\":{\"704\":1}}],[\"讯飞星火发布模型\",{\"1\":{\"704\":1}}],[\"讯飞星火认知大模型是科大讯飞发布的语言大模型\",{\"1\":{\"704\":1}}],[\"星火语音同传模型\",{\"1\":{\"704\":1}}],[\"星火\",{\"1\":{\"704\":1}}],[\"星火大模型\",{\"1\":{\"704\":1}}],[\"免费版\",{\"1\":{\"704\":2}}],[\"版\",{\"1\":{\"704\":1}}],[\"版本只要输出一个概率分布的\",{\"1\":{\"843\":1}}],[\"版本的\",{\"1\":{\"843\":1}}],[\"版本的模型确实能快速计算第i个像素的概率分布了\",{\"1\":{\"843\":1}}],[\"版本的模型\",{\"1\":{\"843\":1}}],[\"版本迭代\",{\"0\":{\"714\":1}}],[\"版本进一步加入\",{\"1\":{\"537\":1}}],[\"版本\",{\"1\":{\"204\":1,\"302\":1,\"317\":1,\"431\":1,\"704\":4,\"717\":1,\"843\":1,\"858\":1}}],[\"版本代码\",{\"1\":{\"85\":2,\"102\":2}}],[\"费用最高\",{\"1\":{\"704\":1}}],[\"日\",{\"1\":{\"704\":6,\"714\":1}}],[\"日发布\",{\"1\":{\"704\":1}}],[\"日志记录工具\",{\"1\":{\"803\":1}}],[\"日志记录\",{\"1\":{\"353\":1}}],[\"于\",{\"1\":{\"704\":4}}],[\"于是有\",{\"1\":{\"867\":1}}],[\"于是代码中使用zip\",{\"1\":{\"682\":1}}],[\"于是你把这\",{\"1\":{\"387\":1}}],[\"于是\",{\"1\":{\"246\":1,\"882\":1}}],[\"离群点鲁棒性更强\",{\"1\":{\"797\":1}}],[\"离职人员创建的\",{\"1\":{\"704\":1}}],[\"离散化\",{\"1\":{\"885\":1}}],[\"离散化变分自编码器\",{\"0\":{\"821\":1},\"1\":{\"821\":1}}],[\"离散向量的另一个问题是它不好采样\",{\"1\":{\"878\":1}}],[\"离散表示空间的大小\",{\"1\":{\"821\":1}}],[\"离散表示学习\",{\"0\":{\"787\":1}}],[\"离散视觉词表大小\",{\"1\":{\"814\":1}}],[\"离散vae\",{\"1\":{\"803\":1}}],[\"离散vae的权重路径\",{\"1\":{\"803\":1}}],[\"离散的颜色值\",{\"1\":{\"847\":1}}],[\"离散的\",{\"1\":{\"773\":1}}],[\"离散变分自编码器\",{\"1\":{\"770\":1}}],[\"离散分布\",{\"0\":{\"736\":1},\"1\":{\"826\":1,\"829\":1,\"881\":1}}],[\"离散随机变量形式\",{\"0\":{\"733\":1}}],[\"离散随机变量\",{\"0\":{\"727\":1}}],[\"离散格子\",{\"1\":{\"389\":1}}],[\"离散\",{\"1\":{\"165\":1,\"772\":1,\"773\":1,\"796\":2}}],[\"专用代码生成模型\",{\"1\":{\"704\":1}}],[\"专业版\",{\"1\":{\"704\":2}}],[\"专注于\",{\"1\":{\"715\":1}}],[\"专注于第三方集成\",{\"1\":{\"715\":1}}],[\"专注于复杂问题求解和精确推理能力\",{\"1\":{\"704\":1}}],[\"专注于精确推理和复杂问题求解\",{\"1\":{\"704\":1}}],[\"专注于广泛知识覆盖和流畅对话体验\",{\"1\":{\"704\":1}}],[\"专门学好文本与图像\",{\"1\":{\"807\":1}}],[\"专门学好像素生成\",{\"1\":{\"807\":1}}],[\"专门对话\",{\"1\":{\"704\":1}}],[\"专门用于预测一个\",{\"1\":{\"107\":1}}],[\"慢\",{\"1\":{\"704\":1}}],[\"慢慢增加\",{\"1\":{\"159\":1}}],[\"速度越慢\",{\"1\":{\"709\":1}}],[\"速度最快\",{\"1\":{\"704\":1}}],[\"速度快\",{\"1\":{\"704\":1}}],[\"速度和显存优化\",{\"1\":{\"395\":1}}],[\"价格更加亲民\",{\"1\":{\"704\":1}}],[\"价值\",{\"1\":{\"539\":1}}],[\"快捷又有效\",{\"1\":{\"843\":1}}],[\"快约\",{\"1\":{\"704\":1}}],[\"快速流行\",{\"1\":{\"864\":1}}],[\"快速适应新任务\",{\"1\":{\"527\":1}}],[\"快速给出答案\",{\"1\":{\"500\":1}}],[\"快速找到合适的模型\",{\"1\":{\"314\":1}}],[\"截止\",{\"1\":{\"704\":1}}],[\"截断过长文本\",{\"1\":{\"40\":1}}],[\"月比较有影响力并且模型参数量超过\",{\"1\":{\"704\":1}}],[\"月\",{\"1\":{\"704\":50,\"714\":1}}],[\"月之前\",{\"1\":{\"703\":1}}],[\"月发布的\",{\"1\":{\"297\":1}}],[\"世界知识的语义\",{\"1\":{\"704\":1}}],[\"世界坐标系和局部坐标系\",{\"1\":{\"86\":1}}],[\"世纪\",{\"1\":{\"703\":1}}],[\"称之为\",{\"1\":{\"703\":1}}],[\"称为二项系数\",{\"1\":{\"737\":1}}],[\"称为后验概率\",{\"1\":{\"733\":1}}],[\"称为似然\",{\"1\":{\"733\":1}}],[\"称为先验概率\",{\"1\":{\"733\":1}}],[\"称为概率密度函数\",{\"1\":{\"728\":1}}],[\"称为概率质量函数\",{\"1\":{\"727\":1}}],[\"称为混淆矩阵\",{\"1\":{\"442\":1}}],[\"称为\",{\"1\":{\"179\":1,\"268\":2,\"727\":1}}],[\"称为随机输入丢弃\",{\"1\":{\"95\":1}}],[\"涌现能力可以与某些复杂任务有关\",{\"1\":{\"706\":1}}],[\"涌现能力就像是模型性能随着规模增大而迅速提升\",{\"1\":{\"706\":1}}],[\"涌现能力是一种令人惊讶的能力\",{\"1\":{\"706\":1}}],[\"涌现能力\",{\"1\":{\"703\":1,\"706\":1}}],[\"涌现能力研究\",{\"1\":{\"552\":1}}],[\"豆包\",{\"1\":{\"703\":1}}],[\"国内外有超过百种大模型相继发布\",{\"1\":{\"704\":1}}],[\"国内的有\",{\"1\":{\"703\":1}}],[\"国外的知名\",{\"1\":{\"703\":1}}],[\"拓展\",{\"1\":{\"700\":1}}],[\"拓扑复杂\",{\"1\":{\"114\":1}}],[\"🏗️\",{\"0\":{\"699\":1}}],[\"🌟\",{\"1\":{\"103\":1}}],[\"香蕉函数\",{\"1\":{\"697\":1}}],[\"山\",{\"1\":{\"697\":1}}],[\"寻找函数最优解\",{\"0\":{\"697\":1}}],[\"橙色圆形\",{\"1\":{\"696\":1}}],[\"牛顿法等经典函数逼近与优化示例\",{\"1\":{\"695\":1}}],[\"围绕计算图可视化\",{\"1\":{\"695\":1}}],[\"处对折\",{\"1\":{\"747\":1}}],[\"处标记最优点\",{\"1\":{\"697\":1}}],[\"处导数为\",{\"1\":{\"692\":1}}],[\"处理图像\",{\"1\":{\"815\":1,\"843\":1}}],[\"处理的是向量索引映射后的嵌入向量\",{\"1\":{\"885\":1}}],[\"处理的是点云数据\",{\"1\":{\"115\":1}}],[\"处理的\",{\"1\":{\"804\":1}}],[\"处理x1\",{\"1\":{\"690\":1}}],[\"处理x0\",{\"1\":{\"690\":1}}],[\"处理运算符的左右操作数差异\",{\"1\":{\"690\":1}}],[\"处理右操作数为自定义类型的情况\",{\"1\":{\"690\":1}}],[\"处理b\",{\"1\":{\"690\":2}}],[\"处理beam\",{\"1\":{\"313\":1}}],[\"处理a\",{\"1\":{\"690\":2}}],[\"处理vocab\",{\"1\":{\"578\":1}}],[\"处理两个csv文件\",{\"1\":{\"577\":1}}],[\"处理每行文本\",{\"1\":{\"577\":1}}],[\"处理csv文件\",{\"1\":{\"577\":1}}],[\"处理句法歧义\",{\"1\":{\"515\":1}}],[\"处理分布式训练下的负样本扩展\",{\"1\":{\"277\":1}}],[\"处理起来没啥问题\",{\"1\":{\"248\":1}}],[\"处理约\",{\"1\":{\"208\":1}}],[\"处理后\",{\"1\":{\"140\":1}}],[\"处理后的数据集包含比原始数据集更多的文本\",{\"1\":{\"136\":1}}],[\"处理后的\",{\"1\":{\"76\":1}}],[\"处理\",{\"1\":{\"114\":1,\"186\":1,\"272\":1,\"277\":1,\"372\":1,\"522\":1,\"538\":1,\"802\":1,\"804\":1}}],[\"处理点云数据\",{\"1\":{\"107\":1}}],[\"处理过程\",{\"1\":{\"72\":1,\"73\":1,\"74\":1}}],[\"处理流程\",{\"1\":{\"54\":1,\"186\":1}}],[\"演示tinypytorch的自动微分功能\",{\"1\":{\"692\":1}}],[\"幂运算y\",{\"1\":{\"690\":1}}],[\"幂运算\",{\"1\":{\"690\":1}}],[\"∂c\",{\"1\":{\"690\":1}}],[\"∂b\",{\"1\":{\"690\":1}}],[\"∂a\",{\"1\":{\"690\":1}}],[\"∂y\",{\"1\":{\"690\":3}}],[\"透明箱子\",{\"1\":{\"689\":1}}],[\"封装了\",{\"1\":{\"792\":1}}],[\"封装了多种损失函数\",{\"1\":{\"395\":1}}],[\"封装no\",{\"1\":{\"688\":1}}],[\"禁用梯度计算\",{\"1\":{\"821\":1}}],[\"禁用\",{\"1\":{\"820\":1}}],[\"禁用了\",{\"1\":{\"774\":1}}],[\"禁用模式下\",{\"1\":{\"688\":1}}],[\"禁用反向传播后\",{\"1\":{\"688\":1}}],[\"禁用反向传播\",{\"1\":{\"688\":2}}],[\"禁用反向传播的模式优化\",{\"1\":{\"688\":1}}],[\"禁用只是实现选择\",{\"1\":{\"277\":1}}],[\"终止训练\",{\"1\":{\"803\":1}}],[\"终端变量导数保留\",{\"1\":{\"688\":1}}],[\"终输出的\",{\"1\":{\"92\":1}}],[\"修改function\",{\"1\":{\"688\":1}}],[\"修改function类的\",{\"1\":{\"690\":1}}],[\"修改function类\",{\"1\":{\"687\":1,\"693\":1}}],[\"修改variable\",{\"1\":{\"688\":1}}],[\"修改variable类的backward方法\",{\"1\":{\"687\":1}}],[\"修正意图理解\",{\"1\":{\"32\":1}}],[\"弱引用不会增加对象的引用计数\",{\"1\":{\"687\":1}}],[\"弱引用作为主动优化\",{\"1\":{\"687\":1}}],[\"弱引用能确保计算图在使用完毕后自动释放内存\",{\"1\":{\"687\":1}}],[\"弱引用的优势\",{\"1\":{\"687\":1}}],[\"弱引用\",{\"1\":{\"687\":1}}],[\"弱化\",{\"1\":{\"32\":1}}],[\"频繁的gc操作会影响计算效率\",{\"1\":{\"687\":1}}],[\"频次表记录合并规则\",{\"1\":{\"476\":1}}],[\"辈分排序\",{\"1\":{\"686\":1}}],[\"辈分\",{\"0\":{\"686\":1},\"1\":{\"686\":2,\"693\":1}}],[\"叶节点\",{\"1\":{\"685\":1}}],[\"乘法运算是最基础的操作之一\",{\"1\":{\"690\":1}}],[\"乘法运算的实现与运算符重载\",{\"1\":{\"690\":1}}],[\"乘法\",{\"1\":{\"681\":1}}],[\"乘积\",{\"1\":{\"115\":1,\"781\":1}}],[\"弹出列表尾部元素\",{\"1\":{\"668\":1}}],[\"递归实现的反向传播在计算图较深时可能导致栈溢出\",{\"1\":{\"667\":1}}],[\"递归实现的问题\",{\"0\":{\"667\":1}}],[\"递归遍历目录获取所有图片路径\",{\"1\":{\"302\":1,\"304\":1}}],[\"导包\",{\"1\":{\"840\":1}}],[\"导数为400\",{\"1\":{\"697\":1}}],[\"导数公式\",{\"1\":{\"690\":1}}],[\"导数从输出端向输入端传播\",{\"1\":{\"657\":1}}],[\"导数是变化率的表示\",{\"1\":{\"650\":1}}],[\"导数的定义\",{\"0\":{\"650\":1}}],[\"导致从标准正态分布采样得到的\",{\"1\":{\"871\":1}}],[\"导致用户接收到的信息不准确\",{\"1\":{\"709\":1}}],[\"导致内存占用持续升高\",{\"1\":{\"687\":1}}],[\"导致引用计数无法归零\",{\"1\":{\"687\":1}}],[\"导致x变量梯度计算错误\",{\"1\":{\"685\":1}}],[\"导致最终构建得到的字典过大并且还有很多噪声\",{\"1\":{\"578\":1}}],[\"导致在融合时可能无法很好地相互补充\",{\"1\":{\"587\":1}}],[\"导致在分布外数据上表现不佳\",{\"1\":{\"527\":1}}],[\"导致在非常规宽高比或文档理解任务上表现受限\",{\"1\":{\"219\":1}}],[\"导致其泛化能力有限\",{\"1\":{\"520\":1}}],[\"导致\",{\"1\":{\"470\":1,\"493\":1}}],[\"导致整体距离变大\",{\"1\":{\"457\":1}}],[\"导致计算量依然很大\",{\"1\":{\"282\":1}}],[\"导致字典内编码特征不一致\",{\"1\":{\"250\":1}}],[\"导致模型性能不佳\",{\"1\":{\"864\":1}}],[\"导致模型过度关注图像而忽视文本\",{\"1\":{\"815\":1}}],[\"导致模型很难训练\",{\"1\":{\"249\":1}}],[\"导致模型学习没有轻重\",{\"1\":{\"248\":1}}],[\"导致模型泛化性不足\",{\"1\":{\"246\":1}}],[\"导致模型无法捕捉到更细粒度的几何细节\",{\"1\":{\"112\":1}}],[\"导致潜在信息损失\",{\"1\":{\"173\":1}}],[\"导致不公平\",{\"1\":{\"170\":1}}],[\"导致多模态编码器难以有效建模图文交互\",{\"1\":{\"149\":1}}],[\"导致性能下降\",{\"1\":{\"134\":1}}],[\"导致所有的特征\",{\"1\":{\"86\":1}}],[\"导致本论文复现流程暂时终止\",{\"1\":{\"37\":1}}],[\"导致各项指标大幅下降\",{\"1\":{\"24\":1}}],[\"辅助损失函数或额外信息\",{\"1\":{\"806\":1}}],[\"辅助模型生成过程\",{\"1\":{\"709\":1}}],[\"辅助函数\",{\"0\":{\"644\":1}}],[\"辅助训练目标\",{\"1\":{\"508\":1}}],[\"箱子\",{\"0\":{\"635\":1},\"1\":{\"636\":1}}],[\"帮助我们处理各种任务\",{\"1\":{\"712\":1}}],[\"帮助用户理解推理步骤\",{\"1\":{\"704\":1}}],[\"帮助开发者直观理解前向与反向传播路径\",{\"1\":{\"695\":1}}],[\"帮助读者从零搭建属于自己的深度学习引擎\",{\"1\":{\"680\":1}}],[\"帮助读者正确理解技术\",{\"1\":{\"634\":1}}],[\"帮助训练稳定收敛\",{\"1\":{\"107\":1}}],[\"揭示了自监督预训练中自注意力机制对语义理解的自动学习能力\",{\"1\":{\"766\":1}}],[\"揭示模型性能与规模的关系\",{\"1\":{\"552\":1}}],[\"揭开深度学习框架的神秘面纱\",{\"0\":{\"634\":1}}],[\"仓库链接\",{\"1\":{\"633\":1,\"679\":1,\"694\":1,\"699\":1}}],[\"托尔斯泰\",{\"1\":{\"618\":1}}],[\"莎士比亚\",{\"1\":{\"618\":1}}],[\"莎士比亚是英国文学史上最伟大的作家之一\",{\"1\":{\"614\":1}}],[\"歌德\",{\"1\":{\"618\":1}}],[\"雨果\",{\"1\":{\"618\":1}}],[\"麦克白\",{\"1\":{\"614\":1}}],[\"哈姆雷特\",{\"1\":{\"614\":2,\"618\":1}}],[\"态\",{\"1\":{\"594\":1}}],[\"破\",{\"1\":{\"594\":1}}],[\"票\",{\"1\":{\"594\":1}}],[\"股\",{\"1\":{\"594\":1}}],[\"股票中的突破形态\",{\"1\":{\"594\":2}}],[\"短\",{\"1\":{\"591\":1}}],[\"短距离\",{\"1\":{\"591\":2}}],[\"粗略表示\",{\"1\":{\"591\":1}}],[\"粗粒度\",{\"1\":{\"591\":1}}],[\"细粒度\",{\"1\":{\"591\":1}}],[\"细致地识别交互动作及其参与部位\",{\"1\":{\"28\":1}}],[\"怎么让梯度从解码器的输入\",{\"1\":{\"880\":1}}],[\"怎么理解\",{\"1\":{\"591\":1}}],[\"怎么办\",{\"1\":{\"575\":1}}],[\"桶矩阵\",{\"1\":{\"591\":1}}],[\"桶的总数量\",{\"1\":{\"591\":1}}],[\"桶的作用是什么\",{\"1\":{\"591\":1}}],[\"桶号是整数索引\",{\"1\":{\"591\":1}}],[\"桶号加\",{\"1\":{\"591\":1}}],[\"桶号查表\",{\"1\":{\"591\":1}}],[\"桶号最终用来查\",{\"1\":{\"591\":1}}],[\"桶映射\",{\"1\":{\"591\":2}}],[\"桶映射的目的\",{\"1\":{\"591\":1}}],[\"桶\",{\"1\":{\"591\":3}}],[\"爱因斯坦求和规则\",{\"1\":{\"590\":1}}],[\"爱因斯坦求和约定\",{\"1\":{\"367\":1}}],[\"⋅\",{\"1\":{\"590\":1}}],[\"𝑃\",{\"1\":{\"837\":1}}],[\"𝑖\",{\"1\":{\"588\":1}}],[\"𝐿\",{\"1\":{\"588\":1}}],[\"周枫\",{\"1\":{\"718\":1}}],[\"周期长\",{\"1\":{\"587\":1}}],[\"周期短\",{\"1\":{\"587\":1}}],[\"周围四个像素为\",{\"1\":{\"390\":1}}],[\"横着看是计算某个词与全局序列中其他词的相关度\",{\"1\":{\"584\":1}}],[\"出发\",{\"1\":{\"728\":2}}],[\"出来\",{\"1\":{\"616\":1}}],[\"出被掩码位置的表示\",{\"1\":{\"580\":1}}],[\"出于方便\",{\"1\":{\"578\":1}}],[\"出现了基于神经网络的生成模型框架\",{\"1\":{\"864\":1}}],[\"出现了一些基于自监督的方法\",{\"1\":{\"305\":1}}],[\"出现了一系列扩展方向\",{\"1\":{\"175\":1}}],[\"出现在输出\",{\"1\":{\"590\":1}}],[\"出现\",{\"1\":{\"473\":1,\"803\":1}}],[\"出现的小常数\",{\"1\":{\"473\":1}}],[\"出现这种差异的原因不难理解\",{\"1\":{\"305\":1}}],[\"出现均匀崩溃\",{\"1\":{\"183\":1}}],[\"出现单维崩溃\",{\"1\":{\"183\":1}}],[\"临时替换特殊标记\",{\"1\":{\"578\":1}}],[\"落在文章的第\",{\"1\":{\"575\":1}}],[\"落后于chinchilla\",{\"1\":{\"549\":1}}],[\"差不多\",{\"1\":{\"575\":1}}],[\"企鹅不擅长飞行\",{\"1\":{\"573\":2}}],[\"企业又有比较好的自有数据\",{\"1\":{\"482\":1}}],[\"纠错\",{\"1\":{\"572\":1}}],[\"炼成\",{\"1\":{\"571\":1}}],[\"源掩码\",{\"1\":{\"631\":1}}],[\"源注意力子层\",{\"1\":{\"630\":2}}],[\"源码链接\",{\"1\":{\"570\":1}}],[\"源自二战雷达检测\",{\"1\":{\"450\":1}}],[\"延长预训练时间\",{\"1\":{\"780\":1}}],[\"延长训练时间\",{\"1\":{\"569\":1}}],[\"延续了\",{\"1\":{\"521\":1}}],[\"领略强化学习之力\",{\"1\":{\"718\":1}}],[\"领先推理力\",{\"1\":{\"704\":1}}],[\"领先\",{\"1\":{\"566\":1}}],[\"领域专业知识能力欠缺\",{\"1\":{\"709\":1}}],[\"领域差异\",{\"1\":{\"550\":1}}],[\"领域逐渐转向预训练语言模型\",{\"1\":{\"527\":1}}],[\"领域的进展仍处于早期阶段\",{\"1\":{\"520\":1}}],[\"领域常用的文本transformer模型\",{\"1\":{\"299\":1}}],[\"领域中语言表示学习的演进\",{\"1\":{\"531\":1}}],[\"领域中的一些对比学习方法\",{\"1\":{\"298\":1}}],[\"领域中\",{\"1\":{\"280\":1}}],[\"领域\",{\"1\":{\"3\":1,\"577\":1}}],[\"水平翻转等\",{\"1\":{\"802\":1}}],[\"水平翻转和颜色抖动\",{\"1\":{\"774\":1}}],[\"水平\",{\"1\":{\"562\":1}}],[\"水壶的壶嘴\",{\"1\":{\"28\":1}}],[\"静态计算图\",{\"1\":{\"692\":1}}],[\"静态掩码\",{\"1\":{\"562\":1}}],[\"静态与动态掩码\",{\"1\":{\"562\":1}}],[\"静态方法\",{\"0\":{\"347\":1}}],[\"静态方法是类中的一种特殊方法\",{\"1\":{\"316\":1}}],[\"答案可以是任意文本\",{\"1\":{\"616\":1}}],[\"答案是\",{\"1\":{\"727\":1}}],[\"答案是原文中的一段\",{\"1\":{\"616\":1}}],[\"答案是否必须在原文中\",{\"1\":{\"616\":1}}],[\"答案是有的\",{\"1\":{\"491\":1}}],[\"答案应该在这段文字中的第\",{\"1\":{\"616\":1}}],[\"答案必须是原文中的一段文本\",{\"1\":{\"616\":1}}],[\"答案必须是原文中的连续片段\",{\"1\":{\"616\":1}}],[\"答案必存在于上下文中\",{\"1\":{\"561\":1}}],[\"答案就是\",{\"1\":{\"575\":1}}],[\"答案一定会出现在文章中\",{\"1\":{\"575\":1}}],[\"认知偏差等\",{\"1\":{\"705\":1}}],[\"认为\",{\"1\":{\"560\":1}}],[\"认真合理\",{\"1\":{\"538\":1}}],[\"甚至是diffusion模型\",{\"1\":{\"883\":1}}],[\"甚至直接是单位矩阵的倍数\",{\"1\":{\"866\":1}}],[\"甚至不如从零训练的\",{\"1\":{\"780\":1}}],[\"甚至指概率度量\",{\"1\":{\"728\":1}}],[\"甚至引发内存不足错误\",{\"1\":{\"687\":1}}],[\"甚至根据上下文进行\",{\"1\":{\"572\":1}}],[\"甚至可能损害模型表现\",{\"1\":{\"559\":1}}],[\"甚至超越了后续提出的模型\",{\"1\":{\"558\":1}}],[\"甚至在零样本和单样本设置下也能取得有竞争力的结果\",{\"1\":{\"526\":1}}],[\"社区治理框架\",{\"1\":{\"551\":1}}],[\"社会影响与部署考量\",{\"1\":{\"539\":1}}],[\"社会契约式\",{\"1\":{\"539\":1}}],[\"社会\",{\"1\":{\"539\":1}}],[\"社会偏见分析\",{\"1\":{\"551\":1}}],[\"社会偏见\",{\"1\":{\"536\":1}}],[\"凸显运算符重载的可读性优势\",{\"1\":{\"692\":1}}],[\"凸显公开数据训练的固有挑战\",{\"1\":{\"551\":1}}],[\"凸显领域微调的重要性\",{\"1\":{\"549\":1}}],[\"宗教类别偏见最显著\",{\"1\":{\"551\":1}}],[\"责任缺陷\",{\"1\":{\"549\":1}}],[\"灵感来自gpt\",{\"1\":{\"548\":1}}],[\"灵活适应问答系统\",{\"1\":{\"709\":1}}],[\"灵活控制\",{\"0\":{\"695\":1}}],[\"灵活的语言系统发展\",{\"1\":{\"527\":1}}],[\"灵活的组合方式\",{\"1\":{\"197\":1}}],[\"灵活性\",{\"1\":{\"229\":1}}],[\"灵活性与通用性\",{\"1\":{\"173\":1}}],[\"灵活分辨率\",{\"1\":{\"216\":1}}],[\"呼应ai伦理需求\",{\"1\":{\"547\":1}}],[\"呼应了t5等模型的\",{\"1\":{\"531\":1}}],[\"闭区间\",{\"1\":{\"728\":1}}],[\"闭卷问答\",{\"1\":{\"547\":1,\"549\":1}}],[\"闭包得到所有\",{\"1\":{\"728\":1}}],[\"闭包\",{\"1\":{\"341\":2,\"342\":1}}],[\"闭包是一个函数\",{\"1\":{\"340\":1}}],[\"闭包与高阶导数\",{\"0\":{\"338\":1}}],[\"历史缓存\",{\"1\":{\"544\":1}}],[\"历史最高频合并对的频率\",{\"1\":{\"476\":1}}],[\"堆叠而成\",{\"1\":{\"544\":1}}],[\"删除序列最后一个token\",{\"1\":{\"815\":1}}],[\"删除了大量无关代码\",{\"1\":{\"544\":1}}],[\"删除已创建的环境\",{\"0\":{\"435\":1}}],[\"部署服务\",{\"1\":{\"715\":1}}],[\"部署等任务\",{\"1\":{\"715\":1}}],[\"部署建议\",{\"1\":{\"539\":1}}],[\"部分图像\",{\"1\":{\"817\":1}}],[\"部分保证了生成的多样性与样本质量\",{\"1\":{\"816\":1}}],[\"部分结果如下\",{\"1\":{\"697\":1}}],[\"部分带来位置相关性\",{\"1\":{\"590\":1}}],[\"部分带来内容相关性\",{\"1\":{\"590\":1}}],[\"部分内容需分多段呈现以保留关键信息\",{\"1\":{\"536\":1}}],[\"部分任务甚至达到或超越微调模型的水平\",{\"1\":{\"532\":1}}],[\"部分任务甚至超越商业模型\",{\"1\":{\"215\":1}}],[\"部分任务性能接近或超越监督基线模型\",{\"1\":{\"520\":1}}],[\"部分能力甚至超越gpt\",{\"1\":{\"230\":1}}],[\"部分模型甚至可以在单个gpu上运行\",{\"1\":{\"546\":1}}],[\"部分模型\",{\"1\":{\"193\":1}}],[\"部分代码细节没有详细介绍\",{\"1\":{\"186\":1}}],[\"部分如图1所示\",{\"1\":{\"173\":1}}],[\"部分的翻译\",{\"1\":{\"134\":1}}],[\"部分翻译内容的总结\",{\"1\":{\"129\":1}}],[\"部分\",{\"1\":{\"43\":2,\"46\":1,\"142\":1,\"616\":1,\"718\":2,\"858\":1}}],[\"部分研究开始映射语义功能到3d结构\",{\"1\":{\"7\":1}}],[\"部分工作通过语言理解在2d数据中定位功能区域\",{\"1\":{\"7\":1}}],[\"拒绝模型\",{\"1\":{\"539\":1}}],[\"驯化\",{\"1\":{\"539\":1}}],[\"虚假宣传等敏感场景下\",{\"1\":{\"539\":1}}],[\"虚线之下是self\",{\"1\":{\"502\":1}}],[\"虚线之上是标准的cot的过程\",{\"1\":{\"502\":1}}],[\"虚线为\",{\"1\":{\"387\":1}}],[\"规范性\",{\"1\":{\"729\":1}}],[\"规范\",{\"1\":{\"539\":1}}],[\"规模相当的数据集\",{\"1\":{\"810\":1}}],[\"规模显著扩大\",{\"1\":{\"704\":1}}],[\"规模化研究\",{\"1\":{\"552\":1}}],[\"规模悖论\",{\"1\":{\"551\":1}}],[\"规模定律\",{\"1\":{\"522\":1}}],[\"规模与处理\",{\"1\":{\"521\":1}}],[\"规模一致性\",{\"1\":{\"90\":1}}],[\"规模\",{\"1\":{\"6\":1,\"815\":2}}],[\"尚待探索的问题\",{\"1\":{\"539\":1}}],[\"歧义加权\",{\"1\":{\"539\":1}}],[\"南瓜吸引炮弹\",{\"1\":{\"539\":1}}],[\"吃袜子\",{\"1\":{\"539\":1}}],[\"谁写了\",{\"1\":{\"614\":1,\"618\":1}}],[\"谁\",{\"1\":{\"539\":1}}],[\"谁离我越近\",{\"1\":{\"100\":1}}],[\"炸碎\",{\"1\":{\"538\":1}}],[\"炮弹打南瓜\",{\"1\":{\"538\":1}}],[\"胡编乱造\",{\"1\":{\"538\":1}}],[\"冥想后吃袜子有何用\",{\"1\":{\"538\":1}}],[\"荒谬\",{\"1\":{\"538\":1}}],[\"尊重\",{\"1\":{\"538\":1}}],[\"倾向于不作伪答\",{\"1\":{\"538\":1}}],[\"倾斜曲面\",{\"1\":{\"6\":1}}],[\"客户助手场景\",{\"1\":{\"538\":1}}],[\"±\",{\"1\":{\"538\":2}}],[\"毒性模式\",{\"1\":{\"551\":1}}],[\"毒性生成评估\",{\"1\":{\"551\":1}}],[\"毒性\",{\"1\":{\"537\":1}}],[\"公平硬币\",{\"1\":{\"829\":1}}],[\"公理\",{\"1\":{\"729\":1}}],[\"公司开发的闭源语言大模型\",{\"1\":{\"704\":1}}],[\"公司在\",{\"1\":{\"704\":1}}],[\"公开数据+严格过滤\",{\"1\":{\"548\":1}}],[\"公共对齐空间的维度\",{\"1\":{\"822\":1}}],[\"公共\",{\"1\":{\"537\":1}}],[\"公式2到5\",{\"1\":{\"874\":1}}],[\"公式相当于\",{\"1\":{\"815\":1}}],[\"公式推导过程\",{\"1\":{\"807\":1}}],[\"公式的含义\",{\"1\":{\"807\":1}}],[\"公式人话版本\",{\"1\":{\"758\":1}}],[\"公式表示如下\",{\"1\":{\"492\":1}}],[\"公式转化为tanimoto系数\",{\"1\":{\"471\":1}}],[\"公式是\",{\"1\":{\"457\":1,\"458\":1}}],[\"公式描述\",{\"1\":{\"389\":1}}],[\"公式\",{\"0\":{\"384\":1},\"1\":{\"186\":1,\"392\":1,\"393\":1,\"468\":2,\"828\":1,\"829\":1,\"830\":1,\"868\":2,\"869\":1,\"872\":1}}],[\"公式为\",{\"1\":{\"167\":1,\"651\":1}}],[\"公式中\",{\"1\":{\"157\":1}}],[\"公式来自论文\",{\"1\":{\"78\":1}}],[\"公式如下\",{\"1\":{\"13\":1,\"82\":1,\"391\":1,\"467\":1,\"510\":1}}],[\"幻觉\",{\"1\":{\"538\":1,\"709\":1}}],[\"幻觉率等多个维度的性能\",{\"1\":{\"537\":1}}],[\"幻觉控制\",{\"1\":{\"228\":1}}],[\"σ²\",{\"1\":{\"853\":5}}],[\"σ\",{\"1\":{\"537\":1,\"728\":12,\"853\":1}}],[\"−1\",{\"1\":{\"802\":1}}],[\"−0\",{\"1\":{\"774\":1}}],[\"−\",{\"1\":{\"537\":3}}],[\"θ\",{\"1\":{\"537\":3}}],[\"故事类文本\",{\"1\":{\"561\":1}}],[\"故事生成\",{\"1\":{\"536\":1}}],[\"故特别强调标注者的社会敏感性\",{\"1\":{\"537\":1}}],[\"雇佣了约\",{\"1\":{\"537\":1}}],[\"突\",{\"1\":{\"594\":1}}],[\"突出了真实用户需求的多样性\",{\"1\":{\"537\":1}}],[\"突破transformer缺少归纳偏置的限制\",{\"1\":{\"314\":1}}],[\"突破了传统视觉模型\",{\"1\":{\"196\":1}}],[\"明确展示了这三步流程之间的数据流和优化路径\",{\"1\":{\"537\":1}}],[\"节的定量结果中\",{\"1\":{\"810\":1}}],[\"节中的消融实验表明\",{\"1\":{\"772\":1}}],[\"节点连接\",{\"1\":{\"696\":1}}],[\"节点属性设置\",{\"1\":{\"696\":1}}],[\"节点间用换行分隔\",{\"1\":{\"696\":1}}],[\"节点和箭头展示计算流程\",{\"1\":{\"641\":1}}],[\"节\",{\"1\":{\"536\":2}}],[\"节省参数\",{\"1\":{\"591\":1}}],[\"节省gpu内存\",{\"1\":{\"548\":1}}],[\"节省内存\",{\"1\":{\"364\":2,\"562\":1,\"820\":1}}],[\"节省显存\",{\"1\":{\"147\":1,\"817\":1,\"821\":1}}],[\"风格等\",{\"1\":{\"866\":2}}],[\"风格归一化\",{\"1\":{\"802\":1}}],[\"风格的均值方差进行归一化\",{\"1\":{\"802\":1}}],[\"风格的\",{\"1\":{\"802\":2}}],[\"风格的视觉\",{\"1\":{\"790\":1}}],[\"风格的掩码建模在视觉领域的应用尚未充分研究\",{\"1\":{\"766\":1}}],[\"风格的对比学习\",{\"1\":{\"198\":1}}],[\"风格\",{\"1\":{\"681\":1,\"817\":1}}],[\"风格延续任务中的偏好学习\",{\"1\":{\"536\":1}}],[\"诚实\",{\"1\":{\"535\":1}}],[\"奖励模型\",{\"1\":{\"537\":1}}],[\"奖励模型训练\",{\"1\":{\"535\":1,\"537\":1}}],[\"奖励模型的目标是模拟人类的偏好判断\",{\"1\":{\"232\":1}}],[\"补洞\",{\"1\":{\"874\":1}}],[\"补集规则\",{\"1\":{\"729\":1}}],[\"补集操作\",{\"1\":{\"728\":1}}],[\"补全\",{\"1\":{\"537\":1}}],[\"补足了先前few\",{\"1\":{\"531\":1}}],[\"补充多样性\",{\"1\":{\"548\":1}}],[\"补充方式\",{\"1\":{\"468\":1}}],[\"补充\",{\"0\":{\"238\":1},\"1\":{\"236\":1}}],[\"补充了\",{\"1\":{\"175\":1}}],[\"补充说明\",{\"1\":{\"162\":1}}],[\"补充实验中还使用了\",{\"1\":{\"131\":1}}],[\"补充的交互方式\",{\"1\":{\"28\":1}}],[\"金融决策等\",{\"1\":{\"530\":1}}],[\"工作流程\",{\"0\":{\"710\":1}}],[\"工作中的一些问题\",{\"1\":{\"482\":1}}],[\"工具使用与智能体\",{\"1\":{\"714\":1}}],[\"工具和智能体\",{\"1\":{\"714\":1}}],[\"工具函数\",{\"1\":{\"691\":1}}],[\"工具包重新实现了\",{\"1\":{\"561\":1}}],[\"工程实践\",{\"1\":{\"688\":1}}],[\"工程等高精度领域的适用性\",{\"1\":{\"530\":1}}],[\"科研界给这些庞大的语言模型起了个名字\",{\"1\":{\"703\":1}}],[\"科研\",{\"1\":{\"530\":1}}],[\"科学问答\",{\"1\":{\"235\":1}}],[\"科学问答等实际应用任务\",{\"1\":{\"233\":1}}],[\"科学理解\",{\"1\":{\"228\":1}}],[\"程序员就少了一个需要调节的超参数\",{\"1\":{\"873\":1}}],[\"程序生成等\",{\"1\":{\"530\":1}}],[\"程序向\",{\"1\":{\"83\":1}}],[\"瓶颈\",{\"1\":{\"530\":1}}],[\"瓶颈式架构\",{\"1\":{\"71\":1}}],[\"逻辑\",{\"1\":{\"821\":1}}],[\"逻辑推理和结构化知识方面展现出卓越性能\",{\"1\":{\"704\":1}}],[\"逻辑缺陷\",{\"1\":{\"550\":1}}],[\"逻辑比较\",{\"1\":{\"530\":1}}],[\"逻辑转置中\",{\"1\":{\"426\":1}}],[\"逻辑转置\",{\"1\":{\"426\":1}}],[\"鼓励\",{\"1\":{\"885\":2}}],[\"鼓励后续研究继续探索更大规模语言模型的行为边界\",{\"1\":{\"524\":1}}],[\"鼓励变换矩阵接近正交矩阵\",{\"1\":{\"108\":1}}],[\"讨论\",{\"0\":{\"523\":1,\"539\":1}}],[\"证实模型并非简单记忆\",{\"1\":{\"522\":1}}],[\"证明运算符重载与自动微分机制的一致性\",{\"1\":{\"690\":1}}],[\"证明了其自动捕获高层视觉知识的能力\",{\"1\":{\"766\":1}}],[\"证明了bert原始设计的潜力尚未被充分挖掘\",{\"1\":{\"569\":1}}],[\"证明了可以将bert的方法和vison\",{\"1\":{\"280\":1}}],[\"证明指令适应的高效性\",{\"1\":{\"549\":1}}],[\"证明无监督预训练在多任务迁移中的巨大潜力\",{\"1\":{\"522\":1}}],[\"证明自然语言指令可激活任务特定行为\",{\"1\":{\"522\":1}}],[\"证明gpt\",{\"1\":{\"520\":1}}],[\"证明模型具有有效处理上下文长距离的信息的能力\",{\"1\":{\"515\":1}}],[\"证明其确实为下游任务获取到了有用的语言知识\",{\"1\":{\"507\":1}}],[\"证明\",{\"1\":{\"385\":1,\"559\":1}}],[\"独热编码\",{\"1\":{\"738\":1}}],[\"独立采样\",{\"1\":{\"874\":1}}],[\"独立同分布于\",{\"1\":{\"826\":1}}],[\"独立被遮或不遮\",{\"1\":{\"801\":1}}],[\"独立遮挡\",{\"1\":{\"801\":1}}],[\"独立学习\",{\"1\":{\"591\":1}}],[\"独立编码图像\",{\"1\":{\"196\":1}}],[\"独角兽新闻\",{\"1\":{\"522\":1}}],[\"英语词库数据\",{\"1\":{\"577\":1}}],[\"英罗等语言对的few\",{\"1\":{\"529\":1}}],[\"英德\",{\"1\":{\"529\":1}}],[\"英→法\",{\"1\":{\"522\":1}}],[\"英文全称\",{\"1\":{\"82\":1}}],[\"阅读理解任务\",{\"1\":{\"618\":1}}],[\"阅读理解与逻辑推理任务表现不一\",{\"1\":{\"529\":1}}],[\"阅读理解\",{\"1\":{\"522\":1}}],[\"命名实体识别\",{\"1\":{\"617\":1}}],[\"命名实体准确率89\",{\"1\":{\"522\":1}}],[\"命名实体\",{\"1\":{\"522\":1}}],[\"命令行工具\",{\"1\":{\"715\":1}}],[\"命令后加上\",{\"1\":{\"83\":1}}],[\"命令中\",{\"1\":{\"83\":1}}],[\"奠定了基础\",{\"1\":{\"521\":1}}],[\"触发摘要生成\",{\"1\":{\"521\":1}}],[\"≥3\",{\"1\":{\"521\":1}}],[\"间接学习任务\",{\"1\":{\"520\":1}}],[\"间存在功能冲突\",{\"1\":{\"134\":1}}],[\"狭窄的专家\",{\"1\":{\"520\":1}}],[\"翻译成大图像的方法\",{\"1\":{\"878\":1}}],[\"翻译成最终的生成图像\",{\"1\":{\"878\":1}}],[\"翻译成中文\",{\"1\":{\"232\":1}}],[\"翻译语言等\",{\"1\":{\"708\":1}}],[\"翻译等任务上的表现仍远未达到实用水平\",{\"1\":{\"523\":1}}],[\"翻译等任务表现仍远逊于专业系统\",{\"1\":{\"522\":1}}],[\"翻译任务\",{\"1\":{\"521\":1}}],[\"翻译示例\",{\"1\":{\"521\":1}}],[\"翻译的文本示例\",{\"1\":{\"520\":1}}],[\"翻译\",{\"1\":{\"519\":1,\"522\":1}}],[\"蕴含确定和文本分类\",{\"1\":{\"517\":1}}],[\"威诺格拉德模式\",{\"1\":{\"516\":1}}],[\"情感表达\",{\"1\":{\"704\":1}}],[\"情感分析\",{\"1\":{\"516\":1}}],[\"情况下\",{\"1\":{\"542\":1,\"543\":1,\"758\":1}}],[\"情况完全不一样\",{\"1\":{\"246\":1}}],[\"纽约大学发布的有关语法的数据集\",{\"1\":{\"515\":1}}],[\"评判两个文本语义信息的相似度\",{\"1\":{\"515\":1}}],[\"评估基准\",{\"1\":{\"561\":1}}],[\"评估方式\",{\"1\":{\"537\":1}}],[\"评估方法与设定\",{\"1\":{\"528\":1}}],[\"评估语言模型的风险与危害\",{\"1\":{\"536\":1}}],[\"评估工具\",{\"1\":{\"227\":1}}],[\"评估协议\",{\"1\":{\"179\":1}}],[\"评估阶段则是在验证集或测试集上评估模型的性能\",{\"1\":{\"82\":1}}],[\"评估\",{\"0\":{\"82\":1},\"1\":{\"79\":1}}],[\"评估集\",{\"1\":{\"68\":1}}],[\"评估时需要标准的单一样本对比\",{\"1\":{\"29\":1}}],[\"评估指标\",{\"1\":{\"22\":1}}],[\"美国知识问答网站\",{\"1\":{\"515\":1}}],[\"挑战\",{\"1\":{\"538\":1}}],[\"挑战了传统对\",{\"1\":{\"531\":1}}],[\"挑战在于识别语句是否是概念改写\",{\"1\":{\"515\":1}}],[\"挑战模型对可供性的泛化能力\",{\"1\":{\"19\":1}}],[\"矛盾或中立\",{\"1\":{\"515\":1}}],[\"涉及\",{\"1\":{\"537\":1}}],[\"涉及读取一对句子\",{\"1\":{\"515\":1}}],[\"涉及两个重要概念\",{\"1\":{\"421\":1}}],[\"残差块的数量\",{\"1\":{\"821\":1}}],[\"残差块实现如下\",{\"1\":{\"793\":1}}],[\"残差链接\",{\"1\":{\"606\":1}}],[\"残差层权重按\",{\"1\":{\"521\":1}}],[\"残差\",{\"1\":{\"514\":1}}],[\"残差连接与层归一化\",{\"1\":{\"622\":1}}],[\"残差连接\",{\"1\":{\"321\":2,\"626\":1}}],[\"困惑度仅从8\",{\"1\":{\"522\":1}}],[\"困惑度从99\",{\"1\":{\"522\":1}}],[\"困惑度\",{\"1\":{\"514\":1}}],[\"困难负样本挖掘\",{\"1\":{\"268\":1}}],[\"困难负样本挖掘策略\",{\"1\":{\"127\":1}}],[\"符来分隔两者\",{\"1\":{\"512\":1}}],[\"符合某个简单的数学分布\",{\"1\":{\"878\":1}}],[\"符合框架设计需求\",{\"1\":{\"687\":1}}],[\"符合我们直接观念所想的大模型微调流程为\",{\"1\":{\"490\":1}}],[\"符合认知的大模型微调流程\",{\"0\":{\"490\":1}}],[\"$\",{\"1\":{\"512\":1}}],[\"观察下图\",{\"1\":{\"685\":1}}],[\"观察倒水场景时\",{\"1\":{\"6\":1}}],[\"观测发现用辅助目标能提升性能\",{\"1\":{\"511\":1}}],[\"段落级别或者句子级别的\",{\"1\":{\"508\":1}}],[\"句子级别表示\",{\"1\":{\"614\":1}}],[\"句子嵌入\",{\"1\":{\"580\":2}}],[\"句子分隔列表\",{\"1\":{\"579\":1}}],[\"句子中20\",{\"1\":{\"579\":1}}],[\"句子\",{\"1\":{\"577\":1}}],[\"句法解析\",{\"1\":{\"507\":1}}],[\"句号等标点符号结合语义进行断句\",{\"1\":{\"476\":1}}],[\"迁移它来稍微适应一系列广泛的任务\",{\"1\":{\"507\":1}}],[\"迁移学习\",{\"1\":{\"395\":1}}],[\"问\",{\"1\":{\"731\":1}}],[\"问答系统中的候选答案选择\",{\"1\":{\"618\":1}}],[\"问答和文本生成等\",{\"1\":{\"526\":1}}],[\"问答和常识推理\",{\"1\":{\"512\":1,\"515\":1}}],[\"问答示例\",{\"1\":{\"523\":1}}],[\"问答任务\",{\"0\":{\"614\":1},\"1\":{\"521\":1,\"575\":2}}],[\"问答或文本蕴含\",{\"1\":{\"512\":1}}],[\"问答提升5\",{\"1\":{\"507\":1}}],[\"问答\",{\"1\":{\"506\":1,\"507\":1,\"516\":1,\"521\":1,\"522\":2,\"527\":1,\"537\":1}}],[\"问题在于\",{\"1\":{\"866\":1}}],[\"问题建模为一个自回归语言建模任务\",{\"1\":{\"813\":1}}],[\"问题分解能力\",{\"1\":{\"704\":1}}],[\"问题格式甚至换行方式都可能造成性能大幅波动\",{\"1\":{\"530\":1}}],[\"问题和答案\",{\"1\":{\"512\":1}}],[\"问题的损失函数改进方案\",{\"1\":{\"470\":1}}],[\"问题来了\",{\"1\":{\"305\":1}}],[\"问题\",{\"1\":{\"239\":1,\"387\":1,\"475\":1,\"522\":1,\"538\":1,\"562\":1,\"564\":1,\"591\":1,\"614\":3,\"616\":1,\"618\":2}}],[\"问题所在\",{\"1\":{\"112\":1}}],[\"问题嵌入\",{\"1\":{\"76\":1}}],[\"问题编码后的文本特征\",{\"1\":{\"72\":1}}],[\"问题条件化查询\",{\"1\":{\"70\":1}}],[\"问题文本不为空\",{\"1\":{\"68\":1}}],[\"问题文本\",{\"1\":{\"68\":1}}],[\"问题数\",{\"1\":{\"65\":1}}],[\"问题总数\",{\"1\":{\"65\":1,\"67\":1}}],[\"问题配对是固定的\",{\"1\":{\"66\":1}}],[\"问题配对\",{\"1\":{\"65\":1,\"67\":1,\"69\":1}}],[\"问题背景\",{\"1\":{\"29\":1,\"103\":1}}],[\"教程起源于加州大学伯克利分校和卡内基梅隆大学的读书分享\",{\"1\":{\"864\":1}}],[\"教育工具等\",{\"1\":{\"539\":1}}],[\"教llm把复杂问题\",{\"1\":{\"503\":1}}],[\"教师输出更新\",{\"1\":{\"186\":1}}],[\"教师输出\",{\"1\":{\"186\":1}}],[\"教师输出减去中心并进行温度锐化\",{\"1\":{\"186\":1}}],[\"教师输出和当前\",{\"1\":{\"186\":1}}],[\"教师模型输出\",{\"1\":{\"186\":1}}],[\"教师参数\",{\"1\":{\"186\":1}}],[\"教师参数是通过\",{\"1\":{\"176\":1}}],[\"教师梯度冻结\",{\"1\":{\"186\":1}}],[\"教师温度调度表\",{\"1\":{\"186\":1}}],[\"教师温度\",{\"1\":{\"179\":1}}],[\"教师的表现始终优于学生\",{\"1\":{\"178\":1}}],[\"教师网络只看\",{\"1\":{\"186\":1}}],[\"教师网络只处理全局视角\",{\"1\":{\"178\":1}}],[\"教师网络不更新梯度\",{\"1\":{\"186\":1}}],[\"教师网络不参与梯度更新\",{\"1\":{\"186\":1}}],[\"教师网络构建完成\",{\"1\":{\"186\":1}}],[\"教师网络初始参数与学生网络相同\",{\"1\":{\"186\":1}}],[\"教师网络\",{\"1\":{\"186\":1}}],[\"教师网络扮演关键角色\",{\"1\":{\"182\":1}}],[\"教师网络的选择\",{\"0\":{\"182\":1}}],[\"教师网络也有类似公式\",{\"1\":{\"178\":1}}],[\"教师也会从学生蒸馏\",{\"1\":{\"176\":1}}],[\"教师\",{\"1\":{\"123\":1,\"186\":1}}],[\"绿色标记出的部分是llm输出的推理过程\",{\"1\":{\"501\":1}}],[\"绿色为\",{\"1\":{\"132\":1}}],[\"背后的大致逻辑\",{\"1\":{\"500\":1}}],[\"背景与动机\",{\"1\":{\"527\":1}}],[\"背景类别极端不平衡的问题\",{\"1\":{\"470\":1}}],[\"背景知识扫盲\",{\"0\":{\"113\":1}}],[\"背景\",{\"0\":{\"86\":1,\"232\":1,\"307\":1,\"560\":1,\"621\":1},\"1\":{\"83\":1,\"470\":1}}],[\"背景点\",{\"1\":{\"78\":1}}],[\"背景特征\",{\"1\":{\"59\":1}}],[\"背景区域特征图\",{\"1\":{\"59\":1}}],[\"背景区域特征图经过roi\",{\"1\":{\"59\":1}}],[\"背景区域特征过程的实现细节如下\",{\"1\":{\"59\":1}}],[\"背景区域特征\",{\"1\":{\"59\":1}}],[\"他们再次使用了停止梯度的技术\",{\"1\":{\"882\":1}}],[\"他们希望利用\",{\"1\":{\"712\":1}}],[\"他们之间的关系是独立的\",{\"1\":{\"31\":1}}],[\"他写了包括\",{\"1\":{\"614\":1}}],[\"他利用自己已掌握的知识\",{\"1\":{\"500\":1}}],[\"思想\",{\"1\":{\"807\":1}}],[\"思想成功引入视觉领域\",{\"1\":{\"790\":1}}],[\"思忖未知之界\",{\"1\":{\"718\":1}}],[\"思维链\",{\"1\":{\"706\":1}}],[\"思维链展示\",{\"1\":{\"704\":2}}],[\"思维链技术\",{\"0\":{\"501\":1}}],[\"思考的时间更短\",{\"1\":{\"704\":1}}],[\"思考\",{\"0\":{\"847\":1},\"1\":{\"500\":1}}],[\"思考快与慢\",{\"1\":{\"500\":1}}],[\"思路\",{\"1\":{\"403\":1,\"788\":1}}],[\"秩的选择\",{\"0\":{\"494\":1},\"1\":{\"494\":1}}],[\"旁添加一条旁路\",{\"1\":{\"492\":1}}],[\"级别的参数量\",{\"1\":{\"490\":1}}],[\"级别的离散表示学习与教师特征对齐\",{\"1\":{\"167\":1}}],[\"感兴趣的朋友\",{\"1\":{\"488\":1}}],[\"限制\",{\"1\":{\"846\":1}}],[\"限制某像素只能看到图像中\",{\"1\":{\"846\":1}}],[\"限制卷积时只能看到左边和上方的像素\",{\"1\":{\"846\":1}}],[\"限制输入文本长度不超过最大\",{\"1\":{\"817\":1}}],[\"限制输入来自同一文档\",{\"1\":{\"562\":1}}],[\"限制哪些位置可以预测哪些\",{\"1\":{\"815\":1}}],[\"限制本次遮挡的patch数量不超过最大遮挡数\",{\"1\":{\"801\":1}}],[\"限制与盲点\",{\"1\":{\"539\":1}}],[\"限制了模型在多样化场景中的应用能力\",{\"1\":{\"520\":1}}],[\"限制了研究社区的应用和优化\",{\"1\":{\"218\":1}}],[\"限制了细节理解能力\",{\"1\":{\"216\":1}}],[\"限制了其在多模态任务中的表现\",{\"1\":{\"191\":1}}],[\"限制了llm的能力利用\",{\"1\":{\"189\":1}}],[\"限制了\",{\"1\":{\"173\":1}}],[\"限于篇幅原因\",{\"1\":{\"488\":1}}],[\"∆w\",{\"1\":{\"487\":3}}],[\"∆w为m\",{\"1\":{\"487\":1}}],[\"往输入序列x前面加特定的token\",{\"1\":{\"486\":1}}],[\"往往远多于正样本\",{\"1\":{\"470\":1}}],[\"跟prompt\",{\"1\":{\"486\":1}}],[\"尽量接近\",{\"1\":{\"869\":1}}],[\"尽可能相似\",{\"1\":{\"878\":1}}],[\"尽可能逼近标准正态分布\",{\"1\":{\"869\":1}}],[\"尽可能平均地使用每个\",{\"1\":{\"800\":1}}],[\"尽可能地提升大模型在特定领域的能力\",{\"1\":{\"483\":1}}],[\"尽管这个下界仍然包含一个关于\",{\"1\":{\"869\":1}}],[\"尽管这些大型语言模型与小型语言模型\",{\"1\":{\"703\":1}}],[\"尽管这些方法有所改进\",{\"1\":{\"219\":1}}],[\"尽管预训练时没有用任何人工标注\",{\"1\":{\"781\":1}}],[\"尽管每个样本的距离是随机的\",{\"1\":{\"755\":1}}],[\"尽管大型语言模型的调用相对简单\",{\"1\":{\"712\":1}}],[\"尽管用户不再访问这些对象\",{\"1\":{\"687\":1}}],[\"尽管有10种变体\",{\"1\":{\"562\":1}}],[\"尽管有时仍用英文回应\",{\"1\":{\"538\":1}}],[\"尽管\",{\"1\":{\"536\":1,\"560\":1,\"705\":1}}],[\"尽管仍有提升空间\",{\"1\":{\"534\":1}}],[\"尽管仍存在局限\",{\"1\":{\"532\":1}}],[\"尽管其非英语性能仍有限\",{\"1\":{\"531\":1}}],[\"尽管gpt\",{\"1\":{\"530\":2}}],[\"尽管训练数据中非英语文本仅占7\",{\"1\":{\"529\":1}}],[\"尽管当前零样本性能仍有限\",{\"1\":{\"524\":1}}],[\"尽管webtext几乎无平行语料\",{\"1\":{\"522\":1}}],[\"尽管数据集小\",{\"1\":{\"522\":1}}],[\"尽管零样本性能尚不完美\",{\"1\":{\"520\":1}}],[\"尽管该模型毫无用处\",{\"1\":{\"443\":1}}],[\"尽管谷歌基于jft\",{\"1\":{\"305\":1}}],[\"尽管clip是一个多模态模型\",{\"1\":{\"299\":1}}],[\"尽管如此\",{\"1\":{\"193\":1,\"806\":1}}],[\"尽管使用简单的过滤规则\",{\"1\":{\"122\":1}}],[\"漏字填空\",{\"1\":{\"571\":1}}],[\"漏检\",{\"1\":{\"471\":1}}],[\"漏报\",{\"1\":{\"471\":1}}],[\"漏掉的真正例\",{\"1\":{\"453\":1}}],[\"技巧\",{\"1\":{\"873\":1}}],[\"技巧性近似\",{\"1\":{\"470\":1}}],[\"技术从过滤后的\",{\"1\":{\"820\":1}}],[\"技术进行条件引导预测\",{\"1\":{\"817\":1}}],[\"技术领域的迅猛发展浪潮中\",{\"1\":{\"714\":1}}],[\"技术范式\",{\"1\":{\"707\":1}}],[\"技术细节必须伴随规范治理与透明流程\",{\"1\":{\"539\":1}}],[\"技术\",{\"1\":{\"248\":1,\"272\":1}}],[\"技术配置\",{\"1\":{\"227\":1}}],[\"求出最近的下标\",{\"1\":{\"880\":1}}],[\"求出了\",{\"1\":{\"847\":1}}],[\"求最近邻\",{\"1\":{\"880\":1}}],[\"求导\",{\"1\":{\"881\":1}}],[\"求导并令偏导数为零可知\",{\"1\":{\"826\":1}}],[\"求导后令导数为零\",{\"1\":{\"826\":1}}],[\"求\",{\"1\":{\"470\":1}}],[\"求和\",{\"1\":{\"76\":1,\"115\":1,\"367\":2}}],[\"^γ\",{\"1\":{\"470\":1}}],[\"^2\",{\"1\":{\"170\":1}}],[\"罕见疾病诊断等\",{\"1\":{\"470\":1}}],[\"任意有限\",{\"1\":{\"728\":1}}],[\"任何类别不平衡的分类任务\",{\"1\":{\"470\":1}}],[\"任务深受\",{\"1\":{\"772\":1}}],[\"任务上评估\",{\"1\":{\"780\":1}}],[\"任务上进行预训练\",{\"1\":{\"767\":1}}],[\"任务上表现更优\",{\"1\":{\"559\":1}}],[\"任务损失\",{\"1\":{\"581\":2}}],[\"任务会利用\",{\"1\":{\"580\":2}}],[\"任务通常需要不同的模型\",{\"1\":{\"571\":1}}],[\"任务通用性\",{\"1\":{\"522\":1}}],[\"任务复杂性上限未显现\",{\"1\":{\"538\":1}}],[\"任务类型\",{\"1\":{\"537\":1}}],[\"任务多样性与实用性\",{\"1\":{\"536\":1}}],[\"任务模式\",{\"1\":{\"529\":1}}],[\"任务不可知\",{\"1\":{\"528\":1}}],[\"任务提示的关键作用\",{\"1\":{\"521\":1}}],[\"任务执行的零样本机制\",{\"1\":{\"521\":1}}],[\"任务可以通过自然语言描述\",{\"1\":{\"521\":1}}],[\"任务涉及预测两个句子在语义上是否相等\",{\"1\":{\"515\":1}}],[\"任务需求\",{\"1\":{\"474\":1}}],[\"任务间接学习\",{\"1\":{\"277\":1}}],[\"任务也能进一步提升模型效果\",{\"1\":{\"268\":1}}],[\"任务结合起来\",{\"1\":{\"247\":1}}],[\"任务采样负样本索引\",{\"1\":{\"147\":1}}],[\"任务的本质\",{\"1\":{\"616\":1}}],[\"任务的通用架构该有多好\",{\"1\":{\"571\":1}}],[\"任务的核心步骤\",{\"1\":{\"562\":1}}],[\"任务的\",{\"1\":{\"537\":1}}],[\"任务的损失权重\",{\"1\":{\"276\":1}}],[\"任务的标签\",{\"1\":{\"276\":1}}],[\"任务的目标是最小化交叉熵损失\",{\"1\":{\"155\":1}}],[\"任务的二分类头\",{\"1\":{\"147\":1}}],[\"任务的评估体系\",{\"1\":{\"82\":1}}],[\"任务\",{\"1\":{\"82\":1,\"147\":1,\"274\":1,\"276\":1,\"277\":1,\"278\":1,\"529\":1,\"571\":1,\"580\":3,\"766\":1,\"772\":1}}],[\"任务中表现出色\",{\"1\":{\"705\":1}}],[\"任务中用于生成功能区域掩码的核心模块\",{\"1\":{\"76\":1}}],[\"任务中\",{\"1\":{\"71\":1,\"160\":1,\"173\":1,\"260\":1,\"618\":1}}],[\"任务设定\",{\"1\":{\"49\":1}}],[\"病灶区域像素远少于正常组织\",{\"1\":{\"470\":1}}],[\"医学图像分割\",{\"1\":{\"470\":1}}],[\"倍\",{\"1\":{\"470\":1,\"704\":2,\"807\":1,\"815\":1}}],[\"退火至\",{\"1\":{\"808\":1}}],[\"退火进行学习率衰减\",{\"1\":{\"774\":1}}],[\"退出with块后\",{\"1\":{\"688\":1}}],[\"退出当前环境\",{\"0\":{\"433\":1}}],[\"退化为ce\",{\"1\":{\"470\":1}}],[\"综述\",{\"1\":{\"718\":1}}],[\"综上\",{\"1\":{\"470\":1}}],[\"综合了\",{\"1\":{\"784\":1}}],[\"综合指标上\",{\"1\":{\"203\":1}}],[\"综合最近几个熟人的意见\",{\"1\":{\"100\":1}}],[\"抗类别不平衡能力强\",{\"1\":{\"468\":1}}],[\"ϵ\",{\"1\":{\"467\":1}}],[\"恢复为\",{\"1\":{\"885\":1}}],[\"恢复离散的类别\",{\"1\":{\"795\":1}}],[\"恢复被掩码的词\",{\"1\":{\"580\":1}}],[\"恢复原始顺序\",{\"1\":{\"463\":1}}],[\"恢复张量格式为\",{\"1\":{\"100\":1}}],[\"阈值化\",{\"1\":{\"463\":1}}],[\"投两次硬币\",{\"1\":{\"727\":1}}],[\"投注了更高的注意力\",{\"1\":{\"463\":1}}],[\"投影结果\",{\"1\":{\"272\":1}}],[\"投影层的丢弃率\",{\"1\":{\"322\":1}}],[\"投影层\",{\"1\":{\"234\":2,\"235\":2}}],[\"投影到统一词空间\",{\"1\":{\"815\":1}}],[\"投影到\",{\"1\":{\"186\":1,\"277\":1}}],[\"投影头\",{\"1\":{\"178\":1,\"186\":1}}],[\"投影\",{\"1\":{\"45\":5,\"147\":2,\"295\":1}}],[\"投影维度\",{\"1\":{\"45\":1}}],[\"压缩\",{\"1\":{\"885\":1}}],[\"压缩时间\",{\"1\":{\"46\":1}}],[\"压扁\",{\"1\":{\"459\":1}}],[\"偏移半个像素\",{\"1\":{\"866\":1}}],[\"偏离\",{\"1\":{\"830\":1}}],[\"偏好临近\",{\"1\":{\"591\":1}}],[\"偏好反馈机制\",{\"1\":{\"539\":1}}],[\"偏好条件化能力\",{\"1\":{\"539\":1}}],[\"偏见正相关\",{\"1\":{\"549\":1}}],[\"偏见与毒性分析\",{\"1\":{\"549\":1}}],[\"偏见或捏造内容\",{\"1\":{\"539\":1}}],[\"偏见水平相当\",{\"1\":{\"538\":1}}],[\"偏见\",{\"1\":{\"537\":1}}],[\"偏见评估数据集\",{\"1\":{\"536\":1}}],[\"偏见问题\",{\"1\":{\"527\":1}}],[\"偏差小但罕见的要严惩\",{\"1\":{\"459\":1}}],[\"偏差大但常见的就不判定为\",{\"1\":{\"459\":1}}],[\"偏置硬币\",{\"1\":{\"829\":1}}],[\"偏置加法公式\",{\"1\":{\"591\":1}}],[\"偏置表的定义\",{\"1\":{\"591\":1}}],[\"偏置表里的每个元素是一个标量\",{\"1\":{\"591\":1}}],[\"偏置表作用\",{\"1\":{\"591\":1}}],[\"偏置表\",{\"1\":{\"591\":3}}],[\"偏置\",{\"1\":{\"272\":5}}],[\"惩罚太远\",{\"1\":{\"591\":1}}],[\"惩罚项\",{\"1\":{\"537\":1}}],[\"惩罚更重\",{\"1\":{\"473\":2}}],[\"惩罚多\",{\"1\":{\"459\":1}}],[\"惩罚少\",{\"1\":{\"459\":1}}],[\"支配\",{\"1\":{\"459\":1}}],[\"支持的区域为0\",{\"1\":{\"835\":1}}],[\"支持的文件后缀类型\",{\"1\":{\"316\":1}}],[\"支持智能体工作负载\",{\"1\":{\"714\":1}}],[\"支持最大\",{\"1\":{\"704\":1}}],[\"支持思考模式和非思考模式之间无缝切换\",{\"1\":{\"704\":1}}],[\"支持更复杂的系统提示词控制\",{\"1\":{\"704\":1}}],[\"支持更广泛的下游任务\",{\"1\":{\"531\":1}}],[\"支持处理极长的文档和对话历史\",{\"1\":{\"704\":1}}],[\"支持标准模式与推理思考模式\",{\"1\":{\"704\":1}}],[\"支持自定义知识库和行为模式\",{\"1\":{\"704\":1}}],[\"支持手势识别和情感表达\",{\"1\":{\"704\":1}}],[\"支持保存为png\",{\"1\":{\"696\":1}}],[\"支持显示变量名\",{\"1\":{\"696\":1}}],[\"支持高阶导数的构建\",{\"1\":{\"695\":1}}],[\"支持高分辨率输入\",{\"1\":{\"222\":1}}],[\"支持variable与数值\",{\"1\":{\"693\":1}}],[\"支持用+\",{\"1\":{\"693\":1}}],[\"支持python原生控制流\",{\"1\":{\"692\":1}}],[\"支持将数学公式直接转译为python代码\",{\"1\":{\"692\":1}}],[\"支持x\",{\"1\":{\"690\":1}}],[\"支持x1\",{\"1\":{\"690\":2}}],[\"支持x0\",{\"1\":{\"690\":2}}],[\"支持y\",{\"1\":{\"690\":1}}],[\"支持3\",{\"1\":{\"690\":1}}],[\"支持与ndarray及数值类型的混合运算\",{\"1\":{\"690\":1}}],[\"支持为变量设置自定义名称\",{\"1\":{\"689\":1}}],[\"支持代码重构和扩展\",{\"1\":{\"677\":1}}],[\"支持数据的修改和读取\",{\"1\":{\"639\":1}}],[\"支持无答案问题\",{\"1\":{\"561\":1}}],[\"支持复杂对话\",{\"1\":{\"550\":1}}],[\"支持这一点\",{\"1\":{\"536\":1}}],[\"支持基于上下文的词表示\",{\"1\":{\"531\":1}}],[\"支持对任何文本\",{\"1\":{\"521\":1}}],[\"支持对比学习任务\",{\"1\":{\"197\":1}}],[\"支持加权和平均损失\",{\"1\":{\"467\":1}}],[\"支持常见的字典操作\",{\"1\":{\"401\":1}}],[\"支持混合精度训练\",{\"1\":{\"395\":1}}],[\"支持两种llm\",{\"1\":{\"313\":1}}],[\"支持两种配置\",{\"1\":{\"197\":1}}],[\"支持图文\",{\"1\":{\"274\":1}}],[\"支持同时处理文本和图像模态\",{\"1\":{\"272\":1}}],[\"支持生成任务\",{\"1\":{\"269\":1}}],[\"支持4k输入\",{\"1\":{\"230\":1}}],[\"支持4k分辨率\",{\"1\":{\"216\":1}}],[\"支持零样本扩展至\",{\"1\":{\"227\":1}}],[\"支持文本\",{\"1\":{\"218\":1}}],[\"支持文本和图像输入\",{\"1\":{\"218\":1}}],[\"支持多轮对话的同时\",{\"1\":{\"704\":1}}],[\"支持多轮视觉对话\",{\"1\":{\"235\":1}}],[\"支持多种自然语言处理任务\",{\"1\":{\"704\":1}}],[\"支持多种任务模式\",{\"1\":{\"197\":1}}],[\"支持多工具并行调用与精准指令解析\",{\"1\":{\"704\":1}}],[\"支持多个输入与输出\",{\"1\":{\"681\":1}}],[\"支持多维度同时交换\",{\"1\":{\"360\":1}}],[\"支持多模态问答\",{\"1\":{\"196\":1}}],[\"支持区域描述和问答\",{\"1\":{\"193\":1}}],[\"支持感知\",{\"1\":{\"189\":1}}],[\"支持温度调度\",{\"1\":{\"186\":1}}],[\"支持刚性变换标准化\",{\"1\":{\"112\":1}}],[\"支持原始点云\",{\"1\":{\"112\":1}}],[\"支持通过爱因斯坦求和约定\",{\"1\":{\"76\":1}}],[\"支持\",{\"1\":{\"49\":1,\"82\":2,\"163\":4,\"364\":1,\"467\":1,\"468\":1,\"580\":1,\"704\":1,\"885\":1}}],[\"尺度差异性\",{\"0\":{\"459\":1}}],[\"尺寸\",{\"1\":{\"272\":1,\"822\":1}}],[\"哪个参数值最合理\",{\"1\":{\"825\":1}}],[\"哪怕某个维度的数据本来波动很大\",{\"1\":{\"457\":1}}],[\"哪些\",{\"1\":{\"727\":1}}],[\"哪些位置有效\",{\"1\":{\"277\":1}}],[\"哪些图片是不相似的\",{\"1\":{\"242\":1}}],[\"身高\",{\"1\":{\"455\":1}}],[\"身高和体重的方差都为\",{\"1\":{\"455\":1}}],[\"身高和体重\",{\"1\":{\"455\":1}}],[\"身份证号\",{\"1\":{\"92\":1}}],[\"马氏距离适合不同维度尺度差别大\",{\"1\":{\"460\":1}}],[\"马氏距离通过协方差矩阵逆变换\",{\"1\":{\"459\":1}}],[\"马氏距离中对第一个维度的偏差乘上\",{\"1\":{\"459\":1}}],[\"马氏距离会自动把不同特征的偏差按标准差进行\",{\"1\":{\"459\":1}}],[\"马氏距离定义如下\",{\"1\":{\"459\":1}}],[\"马氏距离等\",{\"1\":{\"455\":1}}],[\"马氏距离\",{\"0\":{\"456\":1,\"458\":1},\"1\":{\"455\":1}}],[\"椭圆朝反对角线方向倾斜\",{\"1\":{\"455\":1}}],[\"圆形\",{\"1\":{\"455\":1}}],[\"协方差为\",{\"1\":{\"455\":1,\"865\":1}}],[\"协方差函数定义样本之间的相似性结构\",{\"1\":{\"455\":1}}],[\"协方差\",{\"1\":{\"455\":5}}],[\"协方差接近\",{\"1\":{\"455\":1}}],[\"协方差是负的\",{\"1\":{\"455\":1}}],[\"协方差是正的\",{\"1\":{\"455\":1}}],[\"协方差是两个变量\",{\"1\":{\"455\":1}}],[\"协方差矩阵形式为\",{\"1\":{\"752\":1}}],[\"协方差矩阵可以用来\",{\"1\":{\"455\":1}}],[\"协方差矩阵的结构\",{\"1\":{\"455\":1}}],[\"协方差矩阵\",{\"0\":{\"455\":1},\"1\":{\"455\":2}}],[\"协同蒸馏中\",{\"1\":{\"176\":1}}],[\"协同蒸馏\",{\"1\":{\"176\":1}}],[\"较低的阈值\",{\"1\":{\"453\":1}}],[\"较高\",{\"1\":{\"453\":1}}],[\"较慢\",{\"1\":{\"390\":1}}],[\"您选择优先考虑的指标取决于特定问题的成本\",{\"1\":{\"447\":1}}],[\"误差无法从解码器传递到编码器上\",{\"1\":{\"881\":1}}],[\"误差中\",{\"1\":{\"881\":1}}],[\"误差函数里应该只有原图像和目标图像的重建误差\",{\"1\":{\"881\":1}}],[\"误差较大时退化为\",{\"1\":{\"797\":1}}],[\"误检\",{\"1\":{\"471\":1}}],[\"误报为阳性概率是\",{\"1\":{\"731\":1}}],[\"误报\",{\"1\":{\"453\":1,\"471\":1}}],[\"误报很可怕\",{\"1\":{\"447\":1}}],[\"误报概率\",{\"0\":{\"445\":1}}],[\"误分类为\",{\"1\":{\"7\":1}}],[\"召回率曲线的创建方法是\",{\"1\":{\"452\":1}}],[\"召回率曲线\",{\"1\":{\"452\":1}}],[\"召回率会提高\",{\"1\":{\"446\":1}}],[\"召回率比准确率更有意义\",{\"1\":{\"444\":1}}],[\"召回率衡量的是被正确分类为垃圾邮件的垃圾邮件电子邮件的比例\",{\"1\":{\"444\":1}}],[\"召回率的定义为\",{\"1\":{\"444\":1}}],[\"召回率\",{\"0\":{\"444\":1},\"1\":{\"447\":1}}],[\"召回率等指标上的表现\",{\"1\":{\"474\":1}}],[\"召回率等\",{\"1\":{\"274\":1}}],[\"垃圾邮件被误分类为非垃圾邮件\",{\"1\":{\"442\":1}}],[\"垃圾邮件被正确分类为垃圾邮件\",{\"1\":{\"442\":1}}],[\"假嵌入\",{\"1\":{\"880\":1,\"883\":2}}],[\"假如我们是在生成\",{\"1\":{\"847\":1}}],[\"假数据\",{\"1\":{\"840\":1}}],[\"假定其独立同分布于参数为\",{\"1\":{\"826\":1}}],[\"假阴性\",{\"1\":{\"471\":2}}],[\"假阳性\",{\"1\":{\"471\":2}}],[\"假负例通常比假正例的后果更严重\",{\"1\":{\"444\":1}}],[\"假负例是指被误分类为负例的实际正例\",{\"1\":{\"444\":1}}],[\"假负例或假正例\",{\"1\":{\"443\":1}}],[\"假负例\",{\"1\":{\"442\":1}}],[\"假正例是被错误分类的实际负例\",{\"1\":{\"445\":1}}],[\"假正例率为\",{\"1\":{\"445\":1}}],[\"假正例率\",{\"0\":{\"445\":1},\"1\":{\"445\":1,\"447\":1}}],[\"假正例\",{\"1\":{\"442\":1}}],[\"假设不知道输入图像\",{\"1\":{\"881\":1}}],[\"假设嵌入空间已经训练完毕\",{\"1\":{\"880\":1}}],[\"假设潜变量\",{\"1\":{\"865\":1}}],[\"假设较弱\",{\"1\":{\"864\":1}}],[\"假设你想生成一张\",{\"1\":{\"846\":1}}],[\"假设你有一个问题\",{\"1\":{\"618\":1}}],[\"假设配置\",{\"1\":{\"814\":1}}],[\"假设图像有n个像素\",{\"1\":{\"843\":1}}],[\"假设图像是正方形的\",{\"1\":{\"821\":1}}],[\"假设图像\",{\"1\":{\"769\":1}}],[\"假设样本空间是实数集合的子集\",{\"1\":{\"728\":1}}],[\"假设原始上下文是\",{\"1\":{\"616\":1}}],[\"假设序列长度\",{\"1\":{\"590\":1}}],[\"假设\",{\"1\":{\"587\":1,\"591\":2,\"826\":1,\"838\":1,\"886\":1}}],[\"假设最终的输出\",{\"1\":{\"575\":1}}],[\"假设有标记数据集\",{\"1\":{\"511\":1}}],[\"假设有一个完美的模型\",{\"1\":{\"446\":1}}],[\"假设有一个\",{\"1\":{\"425\":1}}],[\"假设预训练的矩阵为\",{\"1\":{\"492\":1}}],[\"假设要在下游任务微调一个预训练语言模型\",{\"1\":{\"492\":1}}],[\"假设模型在任务适配过程中权重的改变量是低秩\",{\"1\":{\"491\":1}}],[\"假设两个正样本\",{\"1\":{\"470\":1}}],[\"假设我们不仅想生成新的数字\",{\"1\":{\"874\":1}}],[\"假设我们有一个\",{\"1\":{\"740\":1}}],[\"假设我们有一个检测疾病的筛查工具\",{\"1\":{\"731\":1}}],[\"假设我们有一个样本点\",{\"1\":{\"459\":1}}],[\"假设我们有预测概率图\",{\"1\":{\"473\":1}}],[\"假设我们有如下样本\",{\"1\":{\"455\":1}}],[\"假设我们在\",{\"1\":{\"415\":1}}],[\"假设的理想模型的\",{\"1\":{\"450\":1}}],[\"假设一个完美的模型不会出现假负例\",{\"1\":{\"444\":1}}],[\"假设为正方形\",{\"1\":{\"793\":1}}],[\"假设为\",{\"1\":{\"427\":1}}],[\"假设为常规行优先存储\",{\"1\":{\"427\":1}}],[\"假设输出坐标映射到输入坐标\",{\"1\":{\"390\":1}}],[\"假设输入图像\",{\"1\":{\"881\":1}}],[\"假设输入图像经过卷积得到一个特征图\",{\"1\":{\"386\":1}}],[\"假设输入的token序列为\",{\"1\":{\"584\":1}}],[\"假设输入特征图大小为\",{\"1\":{\"389\":1}}],[\"假设输入数据维度为\",{\"1\":{\"36\":1}}],[\"假设某个\",{\"1\":{\"386\":1}}],[\"假设空间中所有区域的尺度或特征分布具有一定的一致性\",{\"1\":{\"90\":1}}],[\"真相\",{\"1\":{\"758\":1}}],[\"真正随机的是实验结果\",{\"1\":{\"727\":1}}],[\"真正例率\",{\"0\":{\"444\":1},\"1\":{\"444\":1,\"447\":1}}],[\"真正例\",{\"1\":{\"442\":1}}],[\"真阳性\",{\"1\":{\"471\":2}}],[\"真负例\",{\"1\":{\"442\":1}}],[\"真实数据分布\",{\"1\":{\"840\":1}}],[\"真实token对应1\",{\"1\":{\"594\":1}}],[\"真实性缺陷\",{\"1\":{\"551\":1}}],[\"真实性\",{\"1\":{\"537\":1}}],[\"真实用户在\",{\"1\":{\"537\":1}}],[\"真实掩码\",{\"1\":{\"468\":1}}],[\"真实统计意义上的远近\",{\"1\":{\"459\":1}}],[\"真实的图像\",{\"1\":{\"864\":1}}],[\"真实的\",{\"1\":{\"82\":1}}],[\"真实标签对应的概率为\",{\"1\":{\"155\":1}}],[\"真实标签\",{\"1\":{\"40\":1,\"82\":1,\"157\":1,\"467\":1,\"468\":2,\"471\":1,\"473\":2}}],[\"混乱\",{\"1\":{\"829\":1}}],[\"混淆矩阵\",{\"0\":{\"442\":1}}],[\"混合专家模型\",{\"1\":{\"704\":1}}],[\"混合精度训练和分布式优化部分略过\",{\"1\":{\"811\":1}}],[\"混合精度训练\",{\"1\":{\"561\":1}}],[\"混合模型的常见结合方式\",{\"1\":{\"326\":1}}],[\"混合模型探索\",{\"0\":{\"326\":1}}],[\"混合模型改进\",{\"1\":{\"112\":1}}],[\"混合表征\",{\"1\":{\"277\":1}}],[\"混合多模态专家模型\",{\"1\":{\"272\":1}}],[\"混合特征方法\",{\"1\":{\"220\":1}}],[\"混合两种损失\",{\"1\":{\"163\":1}}],[\"混合比\",{\"1\":{\"163\":1}}],[\"混合编码器\",{\"1\":{\"142\":1}}],[\"混合\",{\"1\":{\"71\":1}}],[\"纯公开数据训练结果挑战了专有数据的必要性\",{\"1\":{\"549\":1}}],[\"纯\",{\"1\":{\"438\":1}}],[\"纯视觉模式\",{\"1\":{\"196\":1}}],[\"纯视觉模型\",{\"1\":{\"196\":1}}],[\"尝试只采样那些很可能生成\",{\"1\":{\"867\":1}}],[\"尝试生成一个遮挡块\",{\"1\":{\"801\":1}}],[\"尝试加载已保存的字典\",{\"1\":{\"578\":1}}],[\"尝试正确完成任务\",{\"1\":{\"538\":1}}],[\"尝试确保被标记为垃圾邮件的电子邮件实际上是垃圾邮件\",{\"1\":{\"447\":1}}],[\"尝试使用conda\",{\"1\":{\"438\":1}}],[\"尝试重建教师模型\",{\"1\":{\"167\":1}}],[\"安装和导入依赖\",{\"0\":{\"852\":1}}],[\"安装失败的包\",{\"1\":{\"438\":1}}],[\"安装所需要的依赖包\",{\"1\":{\"438\":1}}],[\"安全且有用地遵循用户指令\",{\"1\":{\"535\":1}}],[\"安全\",{\"1\":{\"133\":1,\"539\":1}}],[\"杂谈\",{\"0\":{\"429\":1}}],[\"满足了每个像素只能接受之前像素的信息这一约束\",{\"1\":{\"845\":1}}],[\"满足\",{\"1\":{\"772\":1}}],[\"满足下式\",{\"1\":{\"730\":1}}],[\"满足某些一致性要求\",{\"1\":{\"726\":1}}],[\"满足不同场景需求\",{\"1\":{\"704\":1}}],[\"满足以下两个条件之一即可\",{\"1\":{\"339\":1}}],[\"满三次后再打包成一个group\",{\"1\":{\"428\":1}}],[\"≤\",{\"1\":{\"427\":1,\"591\":1}}],[\"底层计算公式变为\",{\"1\":{\"799\":1}}],[\"底层内存中的数据并没有被重新排列\",{\"1\":{\"426\":1}}],[\"底层数据存储为\",{\"1\":{\"426\":1}}],[\"底层使用视觉和语言专家分别编码各自模态\",{\"1\":{\"264\":1}}],[\"物理数据未改变\",{\"1\":{\"427\":1}}],[\"物理转置\",{\"1\":{\"426\":1}}],[\"物体摆放不合逻辑\",{\"1\":{\"806\":1}}],[\"物体扭曲\",{\"1\":{\"806\":1}}],[\"物体在空间中移动时\",{\"1\":{\"116\":1}}],[\"物体分割和场景语义解析\",{\"1\":{\"103\":1}}],[\"物体名称匹配\",{\"1\":{\"68\":1}}],[\"物体组合\",{\"1\":{\"65\":1}}],[\"物体区域特征和点云特征的联合建模\",{\"1\":{\"59\":1}}],[\"物体区域特征图展平\",{\"1\":{\"59\":1}}],[\"物体几何结构文本\",{\"1\":{\"29\":2}}],[\"物体几何结构文本数据文件路径\",{\"1\":{\"29\":1}}],[\"物体几何知识特征\",{\"1\":{\"13\":1}}],[\"物体\",{\"1\":{\"26\":1,\"67\":1}}],[\"物体类别索引\",{\"1\":{\"68\":1}}],[\"物体类别数\",{\"1\":{\"65\":2}}],[\"物体类别\",{\"1\":{\"17\":1,\"67\":1,\"68\":1}}],[\"物体交互感知\",{\"1\":{\"11\":1}}],[\"物体可供性定位方法\",{\"1\":{\"26\":1}}],[\"物体可供性定位任务\",{\"1\":{\"16\":1}}],[\"物体可供性\",{\"1\":{\"8\":1}}],[\"轴上绘制所有阈值下的召回率\",{\"1\":{\"452\":1}}],[\"轴上绘制精确率\",{\"1\":{\"452\":1}}],[\"轴张量\",{\"1\":{\"428\":1}}],[\"轴\",{\"1\":{\"426\":1}}],[\"属于图像部分\",{\"1\":{\"817\":1}}],[\"属于哪一代\",{\"1\":{\"686\":1}}],[\"属于自蒸馏的一种形式\",{\"1\":{\"150\":1}}],[\"属性\",{\"1\":{\"425\":1,\"427\":1,\"690\":1}}],[\"切分成一个句子列表\",{\"1\":{\"577\":1}}],[\"切分后\",{\"1\":{\"31\":1}}],[\"切换也非常方便\",{\"1\":{\"487\":1}}],[\"切换\",{\"0\":{\"432\":1}}],[\"切片后可能是\",{\"1\":{\"425\":1}}],[\"切片索引语法\",{\"1\":{\"425\":1}}],[\"切片\",{\"0\":{\"425\":1},\"1\":{\"425\":2,\"681\":1}}],[\"❓q\",{\"0\":{\"417\":1,\"418\":1}}],[\"仍表现不佳\",{\"1\":{\"539\":1}}],[\"仍会生成有害\",{\"1\":{\"539\":1}}],[\"仍可生成有害内容\",{\"1\":{\"538\":1}}],[\"仍需谨慎评估其边界与适用性\",{\"1\":{\"530\":1}}],[\"仍暴露出其推理深度与语言理解的局限\",{\"1\":{\"529\":1}}],[\"仍是\",{\"1\":{\"408\":1}}],[\"仍然是连续空间中的解码\",{\"1\":{\"885\":1}}],[\"仍然是标准正态分布\",{\"1\":{\"874\":1}}],[\"仍然需要大量的定制开发工作\",{\"1\":{\"712\":1}}],[\"仍然\",{\"1\":{\"591\":1}}],[\"仍然能工作\",{\"1\":{\"175\":1}}],[\"仍然不如分块处理或多层级聚合模型高效\",{\"1\":{\"112\":1}}],[\"唯一标签数组\",{\"1\":{\"399\":1}}],[\"手写数字\",{\"1\":{\"700\":1}}],[\"手动传递导数\",{\"1\":{\"662\":1}}],[\"手动进行反向传播\",{\"0\":{\"658\":1}}],[\"手动实现线性层反向传播\",{\"1\":{\"548\":1}}],[\"手动指定某些类别的权重\",{\"1\":{\"399\":1}}],[\"手工特征\",{\"1\":{\"165\":1}}],[\"手工设计问题\",{\"1\":{\"63\":1}}],[\"经\",{\"1\":{\"871\":1}}],[\"经济\",{\"1\":{\"704\":1}}],[\"经ccnet流水线去重\",{\"1\":{\"548\":1}}],[\"经历n次迭代\",{\"1\":{\"476\":1}}],[\"经典模型\",{\"1\":{\"395\":1}}],[\"经过了第一个\",{\"1\":{\"845\":1}}],[\"经过一层全连接后的输出\",{\"1\":{\"614\":1}}],[\"经过一通计算\",{\"1\":{\"541\":1}}],[\"经过相同的非线性变换后\",{\"1\":{\"580\":1}}],[\"经过embedding层将输入token序列变为一个三维张量\",{\"1\":{\"541\":1}}],[\"经过encoder之后\",{\"1\":{\"319\":1}}],[\"经过过滤\",{\"1\":{\"528\":1}}],[\"经过sigmoid\",{\"1\":{\"470\":1}}],[\"经过处理后的图像块嵌入张量\",{\"1\":{\"318\":1}}],[\"经过卷积层变成\",{\"1\":{\"318\":1}}],[\"经过预处理的图像和对应的标签\",{\"1\":{\"316\":1}}],[\"经过pooler的特征\",{\"1\":{\"276\":1}}],[\"经过编码器2得到了正样本\",{\"1\":{\"248\":1}}],[\"经过编码器1得到了\",{\"1\":{\"248\":1}}],[\"经过全局池化后得到一个全局特征向量\",{\"1\":{\"107\":1}}],[\"经过几层\",{\"1\":{\"100\":1}}],[\"经过mlp进一步提取和融合特征\",{\"1\":{\"100\":1}}],[\"经过\",{\"1\":{\"43\":1,\"45\":2,\"76\":1,\"140\":1,\"473\":1,\"616\":1,\"795\":1,\"803\":1,\"822\":1}}],[\"库和\",{\"1\":{\"577\":1}}],[\"库来实现\",{\"1\":{\"495\":1}}],[\"库\",{\"0\":{\"395\":1,\"397\":1,\"400\":1},\"1\":{\"691\":1}}],[\"库的函数\",{\"1\":{\"370\":1}}],[\"长\",{\"1\":{\"591\":1}}],[\"长距离\",{\"1\":{\"591\":2}}],[\"长文本处理能力较弱\",{\"1\":{\"709\":1}}],[\"长文本对话模型\",{\"1\":{\"704\":1}}],[\"长文本理解和推理能力\",{\"1\":{\"704\":1}}],[\"长文本阅读理解任务\",{\"1\":{\"561\":1}}],[\"长文本能让生成模型学习到长依赖信息的条件概率\",{\"1\":{\"514\":1}}],[\"长度的一维序列\",{\"1\":{\"814\":1}}],[\"长度的序列\",{\"1\":{\"588\":1}}],[\"长度为n\",{\"1\":{\"541\":1}}],[\"长度等于样本数\",{\"1\":{\"403\":1}}],[\"长度与\",{\"1\":{\"399\":1}}],[\"长度必须相同\",{\"1\":{\"398\":1}}],[\"长度固定\",{\"1\":{\"393\":1}}],[\"长度\",{\"1\":{\"391\":1,\"590\":2}}],[\"长边按比例缩放\",{\"1\":{\"317\":1}}],[\"彩色图像来说\",{\"1\":{\"846\":1}}],[\"彩色图像非常友好\",{\"1\":{\"390\":1}}],[\"彩色图像通常为3\",{\"1\":{\"272\":1}}],[\"互怼的艺术\",{\"1\":{\"841\":1}}],[\"互不干扰\",{\"1\":{\"807\":1}}],[\"互为倒数\",{\"1\":{\"801\":1}}],[\"互动逻辑\",{\"1\":{\"712\":1}}],[\"互联提升效率\",{\"1\":{\"561\":1}}],[\"互斥事件\",{\"1\":{\"838\":1}}],[\"互斥\",{\"1\":{\"388\":1}}],[\"互优化机制\",{\"1\":{\"56\":1}}],[\"向最近整数取整\",{\"1\":{\"801\":1}}],[\"向容器对象\",{\"1\":{\"687\":1}}],[\"向函数传递参数\",{\"1\":{\"687\":1}}],[\"向下取整\",{\"1\":{\"387\":1}}],[\"向量靠近\",{\"1\":{\"885\":1}}],[\"向量进行归一化\",{\"1\":{\"822\":1}}],[\"向量或\",{\"1\":{\"821\":1}}],[\"向量加入回来\",{\"1\":{\"796\":1}}],[\"向量从计算图中分离出来\",{\"1\":{\"796\":1}}],[\"向量乘以\",{\"1\":{\"795\":1}}],[\"向量化构建出个性化数据库\",{\"1\":{\"717\":1}}],[\"向量数据库\",{\"1\":{\"713\":1}}],[\"向量映射成两个分数\",{\"1\":{\"614\":1}}],[\"向量维度\",{\"1\":{\"590\":1}}],[\"向量维度越高\",{\"1\":{\"587\":1}}],[\"向量长度\",{\"1\":{\"590\":1}}],[\"向量长度为\",{\"1\":{\"169\":1}}],[\"向量就越接近\",{\"1\":{\"587\":1}}],[\"向量中\",{\"1\":{\"575\":1}}],[\"向量的视角\",{\"1\":{\"590\":1}}],[\"向量的点积\",{\"1\":{\"391\":1}}],[\"向量的长度\",{\"1\":{\"324\":1}}],[\"向量的维度越高\",{\"1\":{\"587\":1}}],[\"向量的维度\",{\"1\":{\"170\":1}}],[\"向量合并成一个完整的\",{\"1\":{\"257\":1}}],[\"向量量化损失\",{\"1\":{\"885\":1}}],[\"向量量化器负责将连续的视觉特征映射到离散的视觉\",{\"1\":{\"170\":1}}],[\"向量量化器\",{\"0\":{\"170\":1},\"1\":{\"885\":1}}],[\"向量量化的\",{\"1\":{\"169\":1}}],[\"向量量化训练中常见问题是代码本塌陷\",{\"1\":{\"167\":1}}],[\"向量量化知识蒸馏算法用于d\",{\"0\":{\"167\":1}}],[\"向量量化知识蒸馏\",{\"1\":{\"165\":1}}],[\"向量\",{\"1\":{\"154\":1,\"156\":1,\"170\":1,\"199\":1,\"257\":1,\"277\":1,\"391\":2,\"392\":1,\"590\":1,\"738\":1,\"793\":1,\"794\":1,\"795\":1,\"796\":2,\"803\":1,\"804\":1,\"832\":1,\"857\":1,\"885\":2}}],[\"边界清晰\",{\"1\":{\"463\":1}}],[\"边界过渡自然\",{\"1\":{\"390\":1}}],[\"边界进行离散化\",{\"1\":{\"387\":1}}],[\"边界坐标的量化\",{\"1\":{\"387\":1}}],[\"边长为该整数\",{\"1\":{\"318\":2}}],[\"划分成固定数量的网格区域\",{\"1\":{\"386\":1}}],[\"划分后可以得到共个patch\",{\"1\":{\"318\":1}}],[\"电路理论类比\",{\"1\":{\"385\":1}}],[\"折叠\",{\"1\":{\"385\":1,\"749\":1}}],[\"锯齿波\",{\"1\":{\"385\":1}}],[\"拟合一个\",{\"1\":{\"385\":1}}],[\"拟合分段函数时\",{\"1\":{\"385\":1}}],[\"深入的业务逻辑理解往往也能带来更好的\",{\"1\":{\"717\":1}}],[\"深度置信网络\",{\"1\":{\"872\":1}}],[\"深度学习框架\",{\"1\":{\"700\":1}}],[\"深度学习框架的计算图范式\",{\"1\":{\"692\":1}}],[\"深度学习框架之所以强大\",{\"1\":{\"680\":1}}],[\"深度学习框架中蕴藏着惊人的技术和有趣的机制\",{\"1\":{\"634\":1}}],[\"深度学习等领域也得到了广泛应用\",{\"1\":{\"421\":1}}],[\"深度学习模型\",{\"1\":{\"112\":1}}],[\"深度分离定理\",{\"1\":{\"385\":1}}],[\"深度叠加导致表达能力爆炸式增长\",{\"1\":{\"385\":1}}],[\"深层cnn\",{\"1\":{\"385\":1}}],[\"深层网络的代价\",{\"1\":{\"385\":1}}],[\"深层网络类似布尔电路中的分层设计\",{\"1\":{\"385\":1}}],[\"深层网络通过共享参数\",{\"1\":{\"385\":1}}],[\"深层网络将复杂函数分解为多个简单步骤\",{\"1\":{\"385\":1}}],[\"深层网络依赖函数的嵌套深度\",{\"1\":{\"385\":1}}],[\"深层网络可以逐步构造出更复杂的函数\",{\"1\":{\"385\":1}}],[\"深层网络\",{\"1\":{\"385\":4}}],[\"深层神经网络通过函数复合\",{\"1\":{\"385\":1}}],[\"爆炸问题\",{\"1\":{\"385\":1}}],[\"爆炸式增长\",{\"1\":{\"385\":1}}],[\"爆炸\",{\"1\":{\"385\":1}}],[\"龙格现象\",{\"1\":{\"385\":1}}],[\"案例2\",{\"1\":{\"385\":1}}],[\"案例1\",{\"1\":{\"385\":1}}],[\"案例\",{\"1\":{\"385\":1}}],[\"神经语言模型的规模定律\",{\"1\":{\"531\":1}}],[\"神经元\",{\"1\":{\"385\":2}}],[\"神经元过多易过拟合\",{\"1\":{\"385\":1}}],[\"神经元实现相同精度\",{\"1\":{\"385\":1}}],[\"神经元数量\",{\"1\":{\"385\":1}}],[\"神经网络会默认1是一个处于0\",{\"1\":{\"878\":1}}],[\"神经网络会默认输入满足一个连续的分布\",{\"1\":{\"878\":1}}],[\"神经网络通过非线性激活函数生成的动态基函数组合\",{\"1\":{\"385\":1}}],[\"神经网络\",{\"1\":{\"385\":2}}],[\"神经网络的权重矩阵通常以高精度的浮点数\",{\"1\":{\"495\":1}}],[\"神经网络的独特优势\",{\"1\":{\"385\":1}}],[\"神经网络的输出在训练初期往往接近于零\",{\"1\":{\"107\":1}}],[\"神经网络逼近\",{\"1\":{\"385\":2}}],[\"神经网络与深度学习\",{\"1\":{\"385\":1}}],[\"神经网络模型只认识数字\",{\"1\":{\"68\":1}}],[\"逼近真实后验分布\",{\"1\":{\"867\":1}}],[\"逼近fine\",{\"1\":{\"529\":1}}],[\"逼近\",{\"1\":{\"385\":1}}],[\"逼近精度与代价的权衡\",{\"1\":{\"385\":1}}],[\"逼近区间\",{\"1\":{\"385\":1}}],[\"逼近原理\",{\"1\":{\"385\":1}}],[\"逼近方式\",{\"1\":{\"385\":1}}],[\"泰勒展开要求函数无限可微\",{\"1\":{\"385\":1}}],[\"泰勒展开\",{\"1\":{\"385\":1}}],[\"挤压\",{\"1\":{\"385\":2}}],[\"普通\",{\"1\":{\"858\":1}}],[\"普通注意力部分\",{\"1\":{\"590\":1}}],[\"普通自注意力打分公式\",{\"1\":{\"590\":1}}],[\"普通计数\",{\"1\":{\"377\":1}}],[\"普通方法\",{\"0\":{\"347\":1}}],[\"举个简单例子\",{\"0\":{\"838\":1}}],[\"举个例子\",{\"1\":{\"499\":1,\"616\":1,\"759\":1}}],[\"举个二维例子\",{\"1\":{\"374\":1}}],[\"举例来说\",{\"1\":{\"575\":1}}],[\"举例\",{\"1\":{\"145\":1,\"186\":1,\"403\":1}}],[\"举例说明\",{\"1\":{\"112\":1}}],[\"连续分布\",{\"1\":{\"796\":1,\"826\":1}}],[\"连续值\",{\"1\":{\"795\":1}}],[\"连续随机变量形式\",{\"0\":{\"734\":1}}],[\"连续随机变量\",{\"0\":{\"728\":1}}],[\"连续包月优惠价为\",{\"1\":{\"704\":1}}],[\"连续句子打包\",{\"1\":{\"562\":1,\"564\":1}}],[\"连续\",{\"1\":{\"514\":1,\"865\":1}}],[\"连续存储的方式\",{\"1\":{\"426\":1}}],[\"连续性\",{\"0\":{\"422\":1},\"1\":{\"421\":1,\"422\":1}}],[\"连续出现次数\",{\"1\":{\"372\":1}}],[\"连续不重复的元素\",{\"1\":{\"372\":1}}],[\"连接起来\",{\"1\":{\"313\":1}}],[\"连接图像特征和语言嵌入空间的线性层\",{\"1\":{\"235\":1}}],[\"连接视觉特征和语言嵌入空间\",{\"1\":{\"234\":1}}],[\"连接视觉编码器和llm\",{\"1\":{\"193\":1}}],[\"连接llm解码器\",{\"1\":{\"197\":1}}],[\"连接llm\",{\"1\":{\"196\":1}}],[\"连接\",{\"1\":{\"33\":1,\"198\":1,\"859\":2}}],[\"访问\",{\"1\":{\"366\":1}}],[\"报错\",{\"1\":{\"364\":1}}],[\"必要时用\",{\"1\":{\"362\":1}}],[\"必要时会复制数据\",{\"1\":{\"362\":1}}],[\"必须确保对数据集中的每个样本\",{\"1\":{\"865\":1}}],[\"必须新增遮挡patch数>0且不超过最大允许遮挡数\",{\"1\":{\"801\":1}}],[\"必须遵循概率公理\",{\"1\":{\"729\":1}}],[\"必须通过\",{\"1\":{\"690\":1}}],[\"必须落在上下文部分\",{\"1\":{\"616\":1}}],[\"必须为两个独立的词\",{\"1\":{\"476\":1}}],[\"必须\",{\"1\":{\"398\":1}}],[\"必须精确指定每维重复次数\",{\"1\":{\"364\":1}}],[\"必须用高阶函数\",{\"1\":{\"341\":1}}],[\"必须结合以下组件\",{\"1\":{\"173\":1}}],[\"必须自己学会对各种姿态都识别准确\",{\"1\":{\"107\":1}}],[\"常数\",{\"1\":{\"839\":1}}],[\"常省略下标\",{\"1\":{\"727\":1}}],[\"常识和写作能力\",{\"1\":{\"707\":1}}],[\"常识推理\",{\"1\":{\"549\":1}}],[\"常识推理与winograd类任务\",{\"1\":{\"529\":1}}],[\"常识推理等多样化任务\",{\"1\":{\"527\":1}}],[\"常识推理提升8\",{\"1\":{\"507\":1}}],[\"常规可测的集合\",{\"1\":{\"728\":1}}],[\"常规微调\",{\"1\":{\"490\":1}}],[\"常规的词汇表\",{\"1\":{\"476\":1}}],[\"常见事件\",{\"1\":{\"728\":1}}],[\"常见名词准确率93\",{\"1\":{\"522\":1}}],[\"常见错误\",{\"0\":{\"439\":1}}],[\"常见疑问解答\",{\"0\":{\"416\":1}}],[\"常见的llm\",{\"0\":{\"704\":1}}],[\"常见的应用场景包括\",{\"1\":{\"617\":1,\"618\":1}}],[\"常见的迁移学习方法是首先在大规模数据集\",{\"1\":{\"305\":1}}],[\"常见的对称函数\",{\"1\":{\"115\":1}}],[\"常用的\",{\"1\":{\"865\":1}}],[\"常用的peft方案\",{\"0\":{\"484\":1}}],[\"常用在分类任务中\",{\"1\":{\"832\":1}}],[\"常用评估指标\",{\"0\":{\"440\":1},\"1\":{\"440\":1}}],[\"常用方法\",{\"1\":{\"401\":1}}],[\"常用于图像回归与重建任务中\",{\"1\":{\"797\":1}}],[\"常用于类别不平衡的数据集\",{\"1\":{\"403\":1}}],[\"常用于机器学习的数据准备\",{\"1\":{\"398\":1}}],[\"常用于特征和概率分布处理\",{\"1\":{\"392\":1}}],[\"常用于随机打乱索引\",{\"1\":{\"375\":1}}],[\"常用于保存一些模型的状态信息\",{\"1\":{\"366\":1}}],[\"常用于临时缓存数据\",{\"1\":{\"366\":1}}],[\"常用于\",{\"1\":{\"359\":1,\"364\":1,\"399\":1}}],[\"常常比官方实现更高效\",{\"1\":{\"395\":1}}],[\"元\",{\"1\":{\"704\":2}}],[\"元素\",{\"1\":{\"591\":1}}],[\"元素为\",{\"1\":{\"591\":1}}],[\"元素是按\",{\"1\":{\"373\":1}}],[\"元学习和模型扩展趋势等多个重要研究方向的交汇点上\",{\"1\":{\"531\":1}}],[\"元学习\",{\"1\":{\"531\":1}}],[\"元学习与few\",{\"1\":{\"531\":1}}],[\"元学习与上下文学习的潜力\",{\"1\":{\"527\":1}}],[\"元组等\",{\"1\":{\"687\":1}}],[\"元组\",{\"1\":{\"358\":1}}],[\"元编程\",{\"1\":{\"346\":1}}],[\"运算中非常常见且强大的一种机制\",{\"1\":{\"427\":1}}],[\"运算符到pow函数\",{\"1\":{\"690\":1}}],[\"运算符到neg函数\",{\"1\":{\"690\":1}}],[\"运算符优先级与类型转换\",{\"1\":{\"690\":1}}],[\"运算符的调用顺序遵循以下规则\",{\"1\":{\"690\":1}}],[\"运算符上\",{\"1\":{\"690\":1}}],[\"运算符重载需要同时考虑左右运算符\",{\"1\":{\"690\":1}}],[\"运算符重载\",{\"0\":{\"690\":1}}],[\"运算符\",{\"1\":{\"354\":1}}],[\"运行和与\",{\"1\":{\"715\":1}}],[\"运行代码\",{\"1\":{\"697\":1}}],[\"运行结果为\",{\"1\":{\"697\":1}}],[\"运行\",{\"1\":{\"696\":1}}],[\"运行上述代码\",{\"1\":{\"303\":1}}],[\"运行可视化\",{\"1\":{\"83\":1}}],[\"典型代表包括\",{\"1\":{\"784\":1}}],[\"典型壳层\",{\"1\":{\"756\":1}}],[\"典型集合\",{\"1\":{\"753\":1}}],[\"典型的涌现能力\",{\"1\":{\"706\":1}}],[\"典型的输入是一个包含\",{\"1\":{\"614\":1}}],[\"典型值\",{\"1\":{\"470\":1}}],[\"典型步长\",{\"1\":{\"423\":2}}],[\"典型应用场景举例\",{\"0\":{\"353\":1}}],[\"典型例子是\",{\"1\":{\"175\":1}}],[\"装饰整个类\",{\"0\":{\"348\":1}}],[\"装饰类方法\",{\"0\":{\"347\":1}}],[\"装饰器的底层原理与执行过程\",{\"0\":{\"349\":1}}],[\"装饰器的实现用到了什么\",{\"0\":{\"341\":1}}],[\"装饰器会改变函数的元信息\",{\"1\":{\"346\":1}}],[\"装饰器工厂\",{\"0\":{\"345\":1},\"1\":{\"352\":1}}],[\"装饰器支持原函数有参数的情况\",{\"1\":{\"344\":1}}],[\"装饰器主要用于在\",{\"1\":{\"342\":1}}],[\"装饰器是\",{\"1\":{\"342\":1}}],[\"装饰器\",{\"0\":{\"342\":1,\"396\":1},\"1\":{\"341\":1,\"342\":1,\"346\":1,\"349\":1}}],[\"装饰器模式\",{\"1\":{\"186\":1}}],[\"持续推动着技术边界的拓展\",{\"1\":{\"714\":1}}],[\"持续下降\",{\"1\":{\"521\":1}}],[\"持续追踪日志最新输出\",{\"1\":{\"83\":1}}],[\"持有对\",{\"1\":{\"343\":1}}],[\"权限控制\",{\"1\":{\"353\":1}}],[\"权限校验等场景中非常常见\",{\"1\":{\"342\":1}}],[\"权重增加到\",{\"1\":{\"808\":1}}],[\"权重共享\",{\"1\":{\"580\":3,\"814\":1}}],[\"权重大\",{\"1\":{\"403\":1}}],[\"权重越高\",{\"1\":{\"403\":1}}],[\"权重越大\",{\"1\":{\"100\":1,\"403\":1}}],[\"权重最低\",{\"1\":{\"399\":1}}],[\"权重最高\",{\"1\":{\"399\":1}}],[\"权重较低\",{\"1\":{\"399\":1}}],[\"权重初始化\",{\"1\":{\"320\":1,\"323\":1,\"514\":1}}],[\"权重衰减系数为\",{\"1\":{\"774\":1}}],[\"权重衰减0\",{\"1\":{\"548\":1}}],[\"权重衰减\",{\"1\":{\"179\":1,\"186\":2,\"208\":1,\"209\":1}}],[\"权重衰减为\",{\"1\":{\"131\":1}}],[\"权重由\",{\"1\":{\"115\":1}}],[\"权重归一化\",{\"1\":{\"100\":1}}],[\"权重\",{\"1\":{\"100\":1,\"169\":2,\"199\":1,\"470\":1,\"727\":1,\"795\":1,\"814\":1}}],[\"权重项\",{\"1\":{\"78\":1}}],[\"绑定乘法运算符\",{\"1\":{\"690\":1}}],[\"绑定\",{\"1\":{\"340\":1,\"690\":2}}],[\"➡️\",{\"1\":{\"336\":1,\"796\":1}}],[\"外循环\",{\"1\":{\"531\":1}}],[\"外层函数的作用域\",{\"1\":{\"336\":1}}],[\"外部代理工具整合到一起\",{\"1\":{\"713\":1}}],[\"外部知识\",{\"1\":{\"713\":1}}],[\"外部作用域变量\",{\"1\":{\"340\":1}}],[\"外部直接传入图像mask\",{\"1\":{\"276\":1}}],[\"外部直接传入图像embedding\",{\"1\":{\"276\":1}}],[\"外部传入的\",{\"1\":{\"163\":1}}],[\"沿计算图反向推导各变量的导数\",{\"1\":{\"660\":1}}],[\"沿\",{\"1\":{\"590\":1}}],[\"沿对角线方向拉长的椭圆\",{\"1\":{\"455\":1}}],[\"沿哪个维度分块\",{\"1\":{\"374\":1}}],[\"沿着某个特定维度需要跨越多少个元素\",{\"1\":{\"423\":1}}],[\"沿着行方向\",{\"1\":{\"373\":1}}],[\"沿着哪个维度计算累积和\",{\"1\":{\"373\":1}}],[\"沿列拼接\",{\"1\":{\"333\":1}}],[\"沿行拼接\",{\"1\":{\"333\":1}}],[\"沿默认轴\",{\"1\":{\"333\":1}}],[\"架起了图像空间到文本空间的桥梁\",{\"1\":{\"328\":1}}],[\"架构来实现pixelcnn\",{\"1\":{\"845\":1}}],[\"架构改进\",{\"1\":{\"714\":1}}],[\"架构的神经网络模型开始崭露头角\",{\"1\":{\"703\":1}}],[\"架构微调\",{\"1\":{\"548\":1}}],[\"架构中\",{\"1\":{\"107\":1}}],[\"架构\",{\"1\":{\"93\":1,\"99\":1,\"167\":1,\"222\":1,\"302\":1,\"307\":1,\"514\":1,\"521\":2,\"537\":1,\"704\":3,\"806\":1,\"809\":1}}],[\"换个更好理解的说法\",{\"1\":{\"878\":1}}],[\"换一个角度看\",{\"1\":{\"878\":1}}],[\"换种方式理解这个问题\",{\"1\":{\"868\":1}}],[\"换言之\",{\"1\":{\"826\":1,\"868\":1}}],[\"换源到图像上\",{\"1\":{\"325\":1}}],[\"换句话说\",{\"1\":{\"100\":1,\"115\":1,\"242\":1,\"457\":1,\"590\":1,\"728\":1,\"872\":1,\"873\":1}}],[\"百万\",{\"1\":{\"324\":1}}],[\"右移\",{\"1\":{\"815\":1}}],[\"右乘\",{\"1\":{\"690\":1}}],[\"右操作数\",{\"1\":{\"690\":1}}],[\"右填充\",{\"1\":{\"594\":1}}],[\"右侧将这个编码过程拆分为两个步骤\",{\"1\":{\"872\":1}}],[\"右侧的损失函数值\",{\"1\":{\"873\":1}}],[\"右侧的表达式\",{\"1\":{\"870\":1}}],[\"右侧的ndarray或数值会被自动转换为variable\",{\"1\":{\"690\":1}}],[\"右侧是cot\",{\"1\":{\"501\":1}}],[\"右侧曲线的\",{\"1\":{\"453\":1}}],[\"右侧填充0个元素\",{\"1\":{\"369\":1}}],[\"右\",{\"1\":{\"428\":2,\"591\":1}}],[\"右图中\",{\"1\":{\"324\":1}}],[\"右边的意义\",{\"1\":{\"872\":1}}],[\"右边的第一项\",{\"1\":{\"868\":1}}],[\"右边的目标函数使用随机梯度下降进行优化呢\",{\"1\":{\"868\":1}}],[\"右边的结构也变得非常像一个自编码器\",{\"1\":{\"867\":1}}],[\"右边的编码是在线下执行\",{\"1\":{\"250\":1}}],[\"右边则是我们可以实际优化的目标\",{\"1\":{\"867\":1}}],[\"右边\",{\"1\":{\"590\":1,\"591\":2}}],[\"右边填充2个9\",{\"1\":{\"369\":1}}],[\"右边不填充\",{\"1\":{\"369\":1}}],[\"右边编码器会被之前的\",{\"1\":{\"246\":1}}],[\"键为元素\",{\"1\":{\"401\":1}}],[\"键\",{\"1\":{\"322\":2}}],[\"键向量\",{\"1\":{\"255\":1,\"410\":1}}],[\"左上角区域\",{\"1\":{\"817\":1}}],[\"左操作数3是int\",{\"1\":{\"690\":1}}],[\"左操作数x是variable\",{\"1\":{\"690\":1}}],[\"左操作数优先\",{\"1\":{\"690\":1}}],[\"左\",{\"1\":{\"591\":1}}],[\"左边的\",{\"1\":{\"867\":1}}],[\"左边是我们想要的目标\",{\"1\":{\"867\":1}}],[\"左边\",{\"1\":{\"590\":1,\"591\":3}}],[\"左边做一次梯度回传之后\",{\"1\":{\"250\":1}}],[\"左侧是常规的prompt\",{\"1\":{\"501\":1}}],[\"左侧为transformer原始的encoder结构\",{\"1\":{\"321\":1}}],[\"范式应用于其他视觉任务也非常直接\",{\"1\":{\"775\":1}}],[\"范式\",{\"1\":{\"531\":1}}],[\"范围在\",{\"1\":{\"801\":1}}],[\"范围内\",{\"1\":{\"371\":1}}],[\"范围\",{\"1\":{\"317\":2}}],[\"范围缩放到\",{\"1\":{\"317\":2}}],[\"范数进行归一化\",{\"1\":{\"255\":1}}],[\"范数\",{\"1\":{\"108\":2,\"392\":1,\"393\":1,\"873\":1}}],[\"组\",{\"1\":{\"846\":1}}],[\"组合模型\",{\"1\":{\"885\":1}}],[\"组合\",{\"0\":{\"763\":1}}],[\"组合分析\",{\"0\":{\"760\":1},\"1\":{\"760\":1}}],[\"组合数\",{\"1\":{\"741\":1}}],[\"组合损失\",{\"1\":{\"468\":1}}],[\"组合损失值\",{\"1\":{\"468\":1}}],[\"组合后的优势\",{\"1\":{\"468\":1}}],[\"组合后的图像张量和标签张量\",{\"1\":{\"316\":1}}],[\"组合方式\",{\"1\":{\"385\":1}}],[\"组成一个\",{\"1\":{\"455\":1}}],[\"组成新的训练集\",{\"1\":{\"128\":1}}],[\"组成\",{\"1\":{\"15\":1,\"560\":1,\"655\":1}}],[\"归纳偏置能够帮助学习算法缩小搜索范围\",{\"1\":{\"314\":1}}],[\"归纳偏置\",{\"1\":{\"314\":1}}],[\"归一化输入\",{\"1\":{\"848\":1}}],[\"归一化输入图像\",{\"1\":{\"821\":1}}],[\"归一化常数\",{\"1\":{\"748\":1,\"752\":1}}],[\"归一化最大距离\",{\"1\":{\"591\":1}}],[\"归一化处理\",{\"1\":{\"528\":1}}],[\"归一化层\",{\"1\":{\"318\":1}}],[\"归一化层类型\",{\"1\":{\"272\":1}}],[\"归一化有助于模型更快地收敛\",{\"1\":{\"317\":1}}],[\"归一化为权重\",{\"1\":{\"293\":1}}],[\"归一化特征\",{\"1\":{\"212\":1}}],[\"归一化得到\",{\"1\":{\"178\":1}}],[\"归一化并\",{\"1\":{\"170\":1}}],[\"归一化可以避免过大的梯度和数值爆炸\",{\"1\":{\"170\":1}}],[\"归一化后\",{\"1\":{\"170\":1}}],[\"归一化后的点云数据\",{\"1\":{\"83\":1}}],[\"归一化代码\",{\"1\":{\"167\":1}}],[\"归一化权重\",{\"1\":{\"100\":1}}],[\"归一化因子\",{\"1\":{\"100\":1}}],[\"归一化到单位球内\",{\"1\":{\"83\":1}}],[\"归一化\",{\"0\":{\"392\":1,\"393\":1},\"1\":{\"45\":1,\"83\":1,\"147\":2,\"161\":2,\"162\":2,\"167\":2,\"169\":1,\"170\":4,\"178\":1,\"276\":1,\"277\":4,\"295\":1,\"393\":2,\"463\":1,\"544\":2,\"704\":1,\"848\":1}}],[\"充当了soft\",{\"1\":{\"313\":1}}],[\"充分利用数据编排框架的优势\",{\"1\":{\"714\":1}}],[\"充分利用了大型语言模型的强大能力\",{\"1\":{\"712\":1}}],[\"充分利用大规模图像单模态和文本单模态数据\",{\"1\":{\"260\":1}}],[\"充分利用不同质量的数据\",{\"1\":{\"198\":1}}],[\"充分吸收了高级区域抽象特征和文本特征\",{\"1\":{\"70\":1}}],[\"错误还是不知道\",{\"1\":{\"575\":1}}],[\"错误分析显示\",{\"1\":{\"522\":1}}],[\"错误分类为\",{\"1\":{\"6\":1}}],[\"错位对齐\",{\"1\":{\"312\":1}}],[\"叠加的运算流程\",{\"1\":{\"312\":1}}],[\"缓冲区会被自动保存到模型的状态字典\",{\"1\":{\"366\":1}}],[\"缓冲区不会保存到\",{\"1\":{\"366\":1}}],[\"缓冲区的名称\",{\"1\":{\"366\":1}}],[\"缓存机制\",{\"1\":{\"817\":1}}],[\"缓存加速\",{\"1\":{\"817\":1}}],[\"缓存显著压缩为潜在向量来保证高效推理的同时不降低效果\",{\"1\":{\"704\":1}}],[\"缓存当前轮计算结果\",{\"1\":{\"544\":1}}],[\"缓存当前轮可重复利用的计算结果\",{\"1\":{\"541\":1}}],[\"缓存key\",{\"1\":{\"312\":1}}],[\"缓存key和value\",{\"1\":{\"312\":1}}],[\"缓存的key和value\",{\"1\":{\"312\":1}}],[\"缓存和复用\",{\"1\":{\"312\":1}}],[\"缓存\",{\"1\":{\"312\":1,\"544\":1}}],[\"缓解了对齐损失\",{\"1\":{\"538\":1}}],[\"缓解深层网络的梯度问题\",{\"1\":{\"521\":1}}],[\"缓解\",{\"1\":{\"469\":1}}],[\"缓解噪声影响\",{\"1\":{\"149\":1}}],[\"缓解类别极度不平衡问题\",{\"1\":{\"78\":1}}],[\"好消息是\",{\"1\":{\"871\":1}}],[\"好的\",{\"1\":{\"817\":1}}],[\"好\",{\"1\":{\"307\":3}}],[\"侧重于信息检索和融合外部知识\",{\"1\":{\"711\":1}}],[\"侧重于给这些点的特征分配更大的融合权重\",{\"1\":{\"72\":1}}],[\"侧重模态融合\",{\"1\":{\"307\":1}}],[\"早期方法如elmo\",{\"1\":{\"568\":1}}],[\"早期方法\",{\"1\":{\"531\":1}}],[\"早期的模型\",{\"1\":{\"527\":1}}],[\"早期的图文多模态\",{\"1\":{\"307\":1}}],[\"早期工作\",{\"1\":{\"51\":1}}],[\"曾有一段时期一直在追求更大的网络架构\",{\"1\":{\"307\":1}}],[\"庖丁解牛vit\",{\"0\":{\"314\":1}}],[\"庖丁解牛blip2\",{\"0\":{\"306\":1},\"1\":{\"306\":1}}],[\"庖丁解牛clip\",{\"0\":{\"296\":1}}],[\"谷歌提出的\",{\"1\":{\"491\":1}}],[\"谷歌利用强大的计算能力进行了预训练\",{\"1\":{\"305\":1}}],[\"谷歌采用的弱监督方法与以往方法的一个主要区别在于规模\",{\"1\":{\"305\":1}}],[\"搜索出来的图片\",{\"1\":{\"303\":1}}],[\"花卉图片分类\",{\"0\":{\"302\":1}}],[\"紧密相关\",{\"1\":{\"301\":1}}],[\"广泛的集成\",{\"1\":{\"714\":1}}],[\"广泛用于语言建模\",{\"1\":{\"577\":1}}],[\"广泛用于现代自然语言处理任务中\",{\"1\":{\"475\":1}}],[\"广泛应用于各类计算机视觉任务\",{\"1\":{\"297\":1}}],[\"广播相加\",{\"1\":{\"591\":1}}],[\"广播规则\",{\"1\":{\"590\":1}}],[\"广播通过\",{\"1\":{\"427\":1}}],[\"广播视图\",{\"1\":{\"362\":1}}],[\"广播\",{\"0\":{\"427\":1},\"1\":{\"112\":1,\"427\":2,\"591\":1,\"632\":1}}],[\"年开始\",{\"1\":{\"712\":1}}],[\"年推进过\",{\"1\":{\"708\":1}}],[\"年发布\",{\"1\":{\"704\":1}}],[\"年至\",{\"1\":{\"704\":1}}],[\"年左右\",{\"1\":{\"703\":1}}],[\"年深度学习先驱\",{\"1\":{\"703\":1}}],[\"年代\",{\"1\":{\"703\":1}}],[\"年代法国电影\",{\"1\":{\"539\":1}}],[\"年龄是0\",{\"1\":{\"878\":1}}],[\"年龄是偏老还是偏年轻\",{\"1\":{\"878\":1}}],[\"年龄\",{\"1\":{\"455\":1}}],[\"年\",{\"1\":{\"297\":1,\"703\":1,\"704\":49,\"707\":1,\"714\":1}}],[\"年可谓是视觉\",{\"1\":{\"297\":1}}],[\"年提出\",{\"1\":{\"73\":1}}],[\"┌────────▼───────────┐\",{\"1\":{\"294\":1}}],[\"┌────────┴───────────┐\",{\"1\":{\"294\":1}}],[\"│\",{\"1\":{\"294\":10}}],[\"拿到所有图片路径\",{\"1\":{\"303\":1}}],[\"拿到能够代表整段文本或者整个多模态表示的\",{\"1\":{\"289\":1}}],[\"拿到图片背景区域特征图\",{\"1\":{\"59\":1}}],[\"池化\",{\"1\":{\"387\":1}}],[\"池化输出实现\",{\"1\":{\"289\":1}}],[\"池化输出\",{\"1\":{\"289\":1}}],[\"池化后拼接\",{\"1\":{\"54\":1}}],[\"另\",{\"1\":{\"762\":1}}],[\"另外\",{\"1\":{\"482\":1,\"487\":1,\"499\":1,\"587\":2,\"847\":1}}],[\"另外vilt还使用了whole\",{\"1\":{\"285\":1}}],[\"另外vilt还设计了一个word\",{\"1\":{\"285\":1}}],[\"另一方面在许多实际问题中\",{\"1\":{\"750\":1}}],[\"另一条是第二个\",{\"1\":{\"684\":1}}],[\"另一相关研究方向是使用自然语言指令训练模型以实现跨任务泛化\",{\"1\":{\"536\":1}}],[\"另一种思路是在转换后\",{\"1\":{\"320\":1}}],[\"另一种是基于\",{\"1\":{\"299\":1}}],[\"另一种是dual\",{\"1\":{\"283\":1}}],[\"另一种是同时使用完整的\",{\"1\":{\"199\":1}}],[\"另一个特例是当\",{\"1\":{\"744\":1}}],[\"另一个是作为答案结束的可能性\",{\"1\":{\"614\":1}}],[\"另一个是masked\",{\"1\":{\"285\":1}}],[\"另一个技巧\",{\"1\":{\"500\":1}}],[\"另一个维度很小\",{\"1\":{\"459\":1}}],[\"另一个原因是nlp模型可以利用从互联网上收集的大量文本\",{\"1\":{\"305\":1}}],[\"另一个细节\",{\"1\":{\"249\":1}}],[\"另一流派\",{\"1\":{\"250\":1}}],[\"另一类则采用独立的图像与文本编码器\",{\"1\":{\"150\":1}}],[\"另一部分特征是通过在当前分辨率直接对所有原始点应用单个pointnet得到的\",{\"1\":{\"97\":1}}],[\"嵌入向量\",{\"1\":{\"886\":1}}],[\"嵌入向量生成过程图\",{\"1\":{\"597\":1}}],[\"嵌入空间误差为嵌入和其对应的编码器输出的均方误差\",{\"1\":{\"883\":1}}],[\"嵌入空间的向量应该和其对应编码器输出尽可能接近\",{\"1\":{\"882\":1}}],[\"嵌入空间的每一个向量应该能概括一类编码器输出的向量\",{\"1\":{\"882\":1}}],[\"嵌入空间的优化目标是什么呢\",{\"1\":{\"882\":1}}],[\"嵌入空间直接关联起来呢\",{\"1\":{\"880\":1}}],[\"嵌入空间\",{\"1\":{\"878\":1}}],[\"嵌入图像\",{\"1\":{\"822\":1}}],[\"嵌入和注意力层以\",{\"1\":{\"514\":1}}],[\"嵌入层维度\",{\"1\":{\"322\":1}}],[\"嵌入交互\",{\"1\":{\"319\":1}}],[\"嵌入的关系\",{\"1\":{\"319\":1}}],[\"嵌入序列的开头\",{\"1\":{\"319\":1}}],[\"嵌入中\",{\"1\":{\"319\":1,\"771\":1}}],[\"嵌入维度\",{\"1\":{\"318\":1,\"319\":1,\"793\":1,\"804\":1}}],[\"嵌入\",{\"1\":{\"280\":1,\"319\":1,\"771\":1}}],[\"摒弃了传统的目标检测和卷积视觉嵌入器\",{\"1\":{\"280\":1}}],[\"拷贝\",{\"1\":{\"278\":1,\"426\":1}}],[\"算力消耗较大\",{\"1\":{\"277\":1}}],[\"算法对\",{\"1\":{\"882\":1}}],[\"算法中经常用到的预训练模型\",{\"1\":{\"577\":1}}],[\"算法进行强化学习优化\",{\"1\":{\"537\":1}}],[\"算法预训练过程完整代码如下\",{\"1\":{\"476\":1}}],[\"算法预训练工作流程\",{\"1\":{\"476\":1}}],[\"算法\",{\"1\":{\"167\":1,\"872\":1}}],[\"资源开销\",{\"1\":{\"277\":1}}],[\"字或词\",{\"1\":{\"572\":1}}],[\"字母重排\",{\"1\":{\"529\":1}}],[\"字节级bpe\",{\"1\":{\"564\":1}}],[\"字节级\",{\"1\":{\"521\":1}}],[\"字节对编码\",{\"1\":{\"475\":1}}],[\"字节\",{\"1\":{\"427\":1}}],[\"字符串\",{\"1\":{\"366\":1,\"521\":1}}],[\"字段\",{\"1\":{\"277\":1}}],[\"字典的构建过程太过粗糙\",{\"1\":{\"578\":1}}],[\"字典的大\",{\"1\":{\"250\":1}}],[\"字典的大小就很重要\",{\"1\":{\"248\":1}}],[\"字典初始化\",{\"1\":{\"578\":1}}],[\"字典中包含文本\",{\"1\":{\"276\":1}}],[\"字典中保存了\",{\"1\":{\"274\":1}}],[\"字典大小\",{\"1\":{\"254\":1}}],[\"字典大小和字典特征一致性经常不能同时满足\",{\"1\":{\"249\":1}}],[\"字典大小是\",{\"1\":{\"249\":1}}],[\"字典\",{\"1\":{\"162\":1,\"336\":1}}],[\"里的那个\",{\"1\":{\"882\":1}}],[\"里的值不变\",{\"1\":{\"881\":1}}],[\"里的方法来生成图像\",{\"1\":{\"843\":1}}],[\"里的一个函数\",{\"1\":{\"840\":2}}],[\"里有两个角色\",{\"1\":{\"840\":1}}],[\"里查到对应的\",{\"1\":{\"590\":1}}],[\"里做了\",{\"1\":{\"395\":1}}],[\"里\",{\"1\":{\"366\":1,\"428\":2,\"591\":2,\"866\":1,\"881\":1,\"883\":1}}],[\"里面肯定含有整句话的完整信息\",{\"1\":{\"575\":1}}],[\"里面的变量外面也能用\",{\"1\":{\"336\":1}}],[\"里面包含了注意力机制\",{\"1\":{\"325\":1}}],[\"里面包含了非常丰富的成果\",{\"1\":{\"325\":1}}],[\"里面有n个图片\",{\"1\":{\"243\":1}}],[\"里取对应的相对位置向量\",{\"1\":{\"590\":1}}],[\"里取对应的查询向量\",{\"1\":{\"590\":1}}],[\"里取对应的\",{\"1\":{\"277\":1}}],[\"拆解成一系列的简单问题\",{\"1\":{\"503\":1}}],[\"拆回文本特征和图像特征\",{\"1\":{\"276\":1}}],[\"拆分输出序列\",{\"1\":{\"817\":1}}],[\"拆分作为共享矩阵\",{\"1\":{\"814\":1}}],[\"拆分为\",{\"1\":{\"804\":1}}],[\"拆分\",{\"1\":{\"272\":1}}],[\"累计新增遮挡数量\",{\"1\":{\"801\":1}}],[\"累积和\",{\"1\":{\"463\":1}}],[\"累积求和\",{\"1\":{\"186\":1}}],[\"累加后的值\",{\"1\":{\"373\":1}}],[\"累加求和\",{\"1\":{\"373\":1}}],[\"累加当前批次的样本数到总样本数中\",{\"1\":{\"323\":1}}],[\"累加所有学习任务结束后的损失\",{\"1\":{\"275\":1}}],[\"钩子方法\",{\"1\":{\"274\":1}}],[\"积攒起一批样本数据后\",{\"1\":{\"274\":1}}],[\"已加载预训练\",{\"1\":{\"886\":1}}],[\"已加载预训练模型\",{\"1\":{\"885\":1}}],[\"已有前置知识的同学\",{\"1\":{\"821\":1}}],[\"已有的技术涉及对模型架构进行特定任务的修改\",{\"1\":{\"507\":1}}],[\"已有的张量\",{\"1\":{\"371\":1}}],[\"已在文本\",{\"1\":{\"806\":1}}],[\"已知的条件下\",{\"1\":{\"730\":1}}],[\"已知rosenbrock函数的最小值在处\",{\"1\":{\"697\":1}}],[\"已实现自动微分系统与基础函数操作\",{\"1\":{\"700\":1}}],[\"已添加\",{\"1\":{\"580\":1}}],[\"已超越多项无监督nmt方法的表现\",{\"1\":{\"529\":1}}],[\"已初步验证了上下文学习的可行性\",{\"1\":{\"527\":1}}],[\"已弃用\",{\"1\":{\"468\":1,\"469\":1,\"470\":1}}],[\"已保存\",{\"1\":{\"463\":1}}],[\"已完成\",{\"1\":{\"274\":1}}],[\"已经训练完毕或已加载权重\",{\"1\":{\"886\":1}}],[\"已经和论文里的\",{\"1\":{\"843\":1}}],[\"已经\",{\"1\":{\"817\":1}}],[\"已经发生的前提下\",{\"1\":{\"730\":1}}],[\"已经发生的条件下的条件概率为\",{\"1\":{\"730\":1}}],[\"已经在许多领域产生了深远的影响\",{\"1\":{\"708\":1}}],[\"已经在多个领域展示了潜力\",{\"1\":{\"705\":1}}],[\"已经扩展到支持多模态数据\",{\"1\":{\"705\":1}}],[\"已经开源了\",{\"1\":{\"704\":1}}],[\"已经能够满足个人用户或小型企业的大部分需求\",{\"1\":{\"704\":1}}],[\"已经计算完之后\",{\"1\":{\"591\":1}}],[\"已经缓存的词序列长度\",{\"1\":{\"544\":1}}],[\"已经证明\",{\"1\":{\"521\":1}}],[\"已经证明无监督学习在nlp任务上是行得通的\",{\"1\":{\"246\":1}}],[\"已经经过\",{\"1\":{\"468\":1}}],[\"已经返回了\",{\"1\":{\"340\":1}}],[\"已经过预训练以提取语言信息视觉表示\",{\"1\":{\"313\":1}}],[\"已经接近其上限\",{\"1\":{\"236\":1}}],[\"子集\",{\"1\":{\"810\":1}}],[\"子层的输入进行了\",{\"1\":{\"704\":1}}],[\"子序列\",{\"1\":{\"616\":1}}],[\"子目录名的格式\",{\"1\":{\"302\":1}}],[\"子实现类为例\",{\"1\":{\"274\":1}}],[\"子类需要做的事情就非常简单了\",{\"1\":{\"274\":1}}],[\"子类\",{\"1\":{\"274\":1}}],[\"子类必须实现\",{\"1\":{\"274\":2}}],[\"子任务上\",{\"1\":{\"203\":1}}],[\"状态标志\",{\"1\":{\"274\":1}}],[\"生态圈\",{\"0\":{\"715\":1}}],[\"生物计算大模型\",{\"1\":{\"704\":1}}],[\"生命周期阶段\",{\"1\":{\"274\":11}}],[\"生成潜在变量\",{\"1\":{\"869\":1}}],[\"生成那些可以还原\",{\"1\":{\"867\":1}}],[\"生成更多类似但不完全相同的新样本\",{\"1\":{\"864\":1}}],[\"生成建模是机器学习中的一个重要领域\",{\"1\":{\"864\":1}}],[\"生成模型训练时\",{\"1\":{\"865\":1}}],[\"生成模型的任务就是捕捉这些像素间的依赖\",{\"1\":{\"864\":1}}],[\"生成模型学习\",{\"0\":{\"862\":1}}],[\"生成模型根据这些信息生成答案\",{\"1\":{\"710\":1}}],[\"生成新的图像\",{\"1\":{\"857\":1}}],[\"生成样本\",{\"1\":{\"857\":1,\"865\":1}}],[\"生成样本分析\",{\"1\":{\"522\":1}}],[\"生成参数\",{\"1\":{\"848\":1}}],[\"生成假样本\",{\"1\":{\"840\":2}}],[\"生成器代码实现\",{\"1\":{\"840\":1}}],[\"生成器想最小化判别器识别生成样本为假的概率\",{\"1\":{\"840\":1}}],[\"生成器将噪声\",{\"1\":{\"840\":1}}],[\"生成器力求生成更逼真的样本\",{\"1\":{\"840\":1}}],[\"生成器\",{\"1\":{\"840\":1}}],[\"生成器推导式里的循环变量\",{\"1\":{\"336\":1}}],[\"生成逼真的数据样本\",{\"1\":{\"840\":1}}],[\"生成对抗网络\",{\"0\":{\"823\":1},\"1\":{\"823\":1}}],[\"生成质量判别器\",{\"0\":{\"822\":1}}],[\"生成像素图像\",{\"1\":{\"807\":1}}],[\"生成视觉\",{\"1\":{\"803\":1}}],[\"生成两张不同视角图像\",{\"1\":{\"802\":1}}],[\"生成两个新的\",{\"1\":{\"274\":1}}],[\"生成图像的过程被建模为高斯分布\",{\"1\":{\"866\":1}}],[\"生成图像的合成描述\",{\"1\":{\"120\":1}}],[\"生成图像在\",{\"1\":{\"806\":1}}],[\"生成图像\",{\"1\":{\"802\":1,\"857\":1,\"869\":1}}],[\"生成图表和可视化报告\",{\"1\":{\"704\":1}}],[\"生成dot语言字符串\",{\"1\":{\"696\":1}}],[\"生成函数节点的dot描述\",{\"1\":{\"696\":1}}],[\"生成变量节点的dot描述\",{\"1\":{\"696\":1}}],[\"生成式预训练\",{\"0\":{\"785\":1}}],[\"生成式预训练语言模型\",{\"1\":{\"704\":1}}],[\"生成式\",{\"1\":{\"616\":2}}],[\"生成式generative模型的推理过程很有特点\",{\"1\":{\"541\":1}}],[\"生成一组可能生成\",{\"1\":{\"867\":1}}],[\"生成一组动态卷积核\",{\"1\":{\"76\":2}}],[\"生成一段文字\",{\"1\":{\"807\":1}}],[\"生成一个上下文相关的表示\",{\"1\":{\"616\":1}}],[\"生成注意力掩码\",{\"1\":{\"594\":1}}],[\"生成注意力热力图\",{\"1\":{\"463\":1}}],[\"生成padding部分的mask列表\",{\"1\":{\"594\":1}}],[\"生成相对位置差矩阵\",{\"1\":{\"590\":1}}],[\"生成能力\",{\"1\":{\"550\":1,\"820\":1}}],[\"生成位置编码\",{\"1\":{\"544\":1}}],[\"生成有害或无关文本\",{\"1\":{\"535\":1}}],[\"生成摘要\",{\"1\":{\"522\":1}}],[\"生成多种不同推理路径所得的结果的集合\",{\"1\":{\"502\":1}}],[\"生成形状为\",{\"1\":{\"378\":1}}],[\"生成类别名称以及对应的数字索引\",{\"1\":{\"316\":1}}],[\"生成文本的最小长度\",{\"1\":{\"313\":1}}],[\"生成文本的最大长度\",{\"1\":{\"313\":1}}],[\"生成文本嵌入\",{\"1\":{\"302\":1,\"304\":1}}],[\"生成学习\",{\"0\":{\"313\":1}}],[\"生成压缩的视觉表示\",{\"1\":{\"312\":1}}],[\"生成text\",{\"1\":{\"312\":1}}],[\"生成比标签\",{\"1\":{\"310\":1}}],[\"生成任务\",{\"1\":{\"197\":1}}],[\"生成和对话任务\",{\"1\":{\"189\":1}}],[\"生成掩码位置\",{\"1\":{\"163\":1}}],[\"生成伪标签\",{\"1\":{\"157\":1}}],[\"生成伪标签辅助训练\",{\"1\":{\"150\":1}}],[\"生成阶段\",{\"0\":{\"143\":1,\"886\":1},\"1\":{\"710\":1}}],[\"生成合成文本\",{\"1\":{\"132\":1}}],[\"生成固定长度的特征向量\",{\"1\":{\"96\":1}}],[\"生成点集的划分\",{\"1\":{\"86\":1}}],[\"生成\",{\"1\":{\"82\":1,\"122\":1,\"143\":3,\"186\":1,\"205\":1,\"206\":1,\"616\":1,\"802\":2,\"817\":1,\"846\":2,\"885\":1,\"886\":2}}],[\"生成融合特征\",{\"1\":{\"73\":1}}],[\"生成动态卷积核\",{\"1\":{\"70\":1}}],[\"生成的图像\",{\"1\":{\"871\":1}}],[\"生成的图像进行重新排序\",{\"1\":{\"811\":1}}],[\"生成的图像依然存在明显的瑕疵\",{\"1\":{\"806\":1}}],[\"生成的分布接近它\",{\"1\":{\"798\":1}}],[\"生成的最小\",{\"1\":{\"728\":1}}],[\"生成的耗时\",{\"1\":{\"711\":1}}],[\"生成的内容往往缺乏明确的信息来源\",{\"1\":{\"709\":1}}],[\"生成的值在\",{\"1\":{\"371\":1}}],[\"生成的样本数量\",{\"1\":{\"332\":1}}],[\"生成的文本特征相当于分类器的权重\",{\"1\":{\"300\":1}}],[\"生成的文本更具有\",{\"1\":{\"133\":1}}],[\"生成的教师特征来学习\",{\"1\":{\"175\":1}}],[\"生成的错误文本更难被\",{\"1\":{\"134\":1}}],[\"生成的多样化问题\",{\"1\":{\"69\":1}}],[\"生成的问题遵循以下三个关键原则\",{\"1\":{\"63\":1}}],[\"生成最终的\",{\"1\":{\"46\":1}}],[\"生成功能区域掩码\",{\"1\":{\"35\":1}}],[\"生成细粒度表示\",{\"1\":{\"12\":1}}],[\"汇总\",{\"1\":{\"273\":3}}],[\"└────────┬───────────┘\",{\"1\":{\"294\":2}}],[\"└─\",{\"1\":{\"273\":17}}],[\"├─\",{\"1\":{\"273\":32}}],[\"减法运算y\",{\"1\":{\"690\":1}}],[\"减法运算\",{\"1\":{\"690\":1}}],[\"减去的\",{\"1\":{\"867\":1}}],[\"减去一个误差项\",{\"1\":{\"867\":1}}],[\"减去余数\",{\"1\":{\"463\":1}}],[\"减去中心并进行温度锐化\",{\"1\":{\"186\":1}}],[\"减少亮度级别后\",{\"1\":{\"847\":1}}],[\"减少信息偏差\",{\"1\":{\"709\":1}}],[\"减少所需人力投入\",{\"1\":{\"707\":1}}],[\"减少了计算量\",{\"1\":{\"704\":2}}],[\"减少了训练前期的收敛难度\",{\"1\":{\"272\":1}}],[\"减少噪声和偏见\",{\"1\":{\"704\":1}}],[\"减少内存占用\",{\"1\":{\"688\":1}}],[\"减少gc触发频率\",{\"1\":{\"687\":1}}],[\"减少未登录词\",{\"1\":{\"564\":1}}],[\"减少未知词影响\",{\"1\":{\"559\":1}}],[\"减少存储开销并提升泛化能力\",{\"1\":{\"564\":1}}],[\"减少存储开销\",{\"1\":{\"562\":1}}],[\"减少重计算\",{\"1\":{\"548\":1}}],[\"减少幻觉与毒性\",{\"1\":{\"538\":1}}],[\"减少幻觉\",{\"1\":{\"538\":1}}],[\"减少有害内容生成等方面也有所改进\",{\"1\":{\"534\":1}}],[\"减少词汇碎片化\",{\"1\":{\"521\":1}}],[\"减少损失贡献\",{\"1\":{\"470\":1}}],[\"减少计数\",{\"1\":{\"401\":1}}],[\"允许看到当前像素\",{\"1\":{\"848\":1}}],[\"允许看自己\",{\"1\":{\"846\":1}}],[\"允许在训练时对离散随机变量进行\",{\"1\":{\"795\":1}}],[\"允许你用基本事件构造更复杂事件\",{\"1\":{\"728\":1}}],[\"允许用户无需编程创建专用的\",{\"1\":{\"704\":1}}],[\"允许开发者创建工具扩展\",{\"1\":{\"704\":1}}],[\"允许我们通过优化适应过程中密集层变化的秩分解矩阵\",{\"1\":{\"491\":1}}],[\"允许重复采样\",{\"1\":{\"403\":1}}],[\"允许跨模态交互\",{\"1\":{\"277\":1}}],[\"允许网络自己调节每一层的残差输出强度\",{\"1\":{\"272\":1}}],[\"允许数据增强后的一致性\",{\"1\":{\"175\":1}}],[\"列或卷积注意力掩码\",{\"1\":{\"809\":1}}],[\"列或其他任意模式访问数据\",{\"1\":{\"425\":1}}],[\"列方向\",{\"1\":{\"581\":2}}],[\"列维度步幅\",{\"1\":{\"427\":1}}],[\"列步长为\",{\"1\":{\"425\":1}}],[\"列时\",{\"1\":{\"423\":1}}],[\"列跳转到第\",{\"1\":{\"423\":1}}],[\"列优先\",{\"1\":{\"423\":2,\"426\":1}}],[\"列优先存储模式的步长\",{\"1\":{\"423\":1}}],[\"列\",{\"1\":{\"423\":5}}],[\"列的值就是\",{\"1\":{\"590\":1}}],[\"列的数据\",{\"1\":{\"423\":1}}],[\"列的所有元素\",{\"1\":{\"422\":2}}],[\"列的\",{\"1\":{\"386\":1}}],[\"列表最后一个记录了缓存的key和value\",{\"1\":{\"312\":2}}],[\"列表\",{\"1\":{\"272\":1,\"336\":1,\"403\":1,\"538\":1,\"578\":1,\"687\":1}}],[\"列举两个该物体常见的其他交互方式\",{\"1\":{\"12\":1}}],[\"针对第一个问题\",{\"1\":{\"866\":1}}],[\"针对输入\",{\"1\":{\"802\":1}}],[\"针对性优化\",{\"1\":{\"716\":1}}],[\"针对不同设置调整峰值学习率和预热步数\",{\"1\":{\"561\":1}}],[\"针对同一输入\",{\"1\":{\"537\":1}}],[\"针对每张图像\",{\"1\":{\"302\":1}}],[\"针对每个图像嵌入向量获取和其相似度最高的分类文本嵌入向量索引下标\",{\"1\":{\"302\":1}}],[\"针对每个图像嵌入向量取出和其相似度最高的那个文本嵌入向量的索引\",{\"1\":{\"302\":1}}],[\"针对文本和图像分别有独立的归一化层\",{\"1\":{\"272\":1}}],[\"针对\",{\"1\":{\"272\":1}}],[\"针对铰接物体\",{\"1\":{\"51\":1}}],[\"隐私问题\",{\"1\":{\"705\":1}}],[\"隐式元学习\",{\"1\":{\"531\":1}}],[\"隐式学习任务逻辑\",{\"1\":{\"521\":1,\"523\":1}}],[\"隐藏的\",{\"1\":{\"758\":1}}],[\"隐藏数据封装细节\",{\"1\":{\"689\":1}}],[\"隐藏层输出\",{\"1\":{\"612\":1}}],[\"隐藏层神经元的数量足够\",{\"1\":{\"385\":1}}],[\"隐藏层维度为\",{\"1\":{\"774\":1}}],[\"隐藏层维度设为\",{\"1\":{\"548\":1}}],[\"隐藏层维度和参数量不同\",{\"1\":{\"522\":1}}],[\"隐藏层维度\",{\"1\":{\"272\":1}}],[\"隐藏层维度与输入维度的比例\",{\"1\":{\"272\":1}}],[\"隐藏维度2048\",{\"1\":{\"178\":1}}],[\"隐层维度与\",{\"1\":{\"272\":1}}],[\"行业大模型\",{\"1\":{\"704\":1}}],[\"行第\",{\"1\":{\"590\":1}}],[\"行维度步幅\",{\"1\":{\"427\":1}}],[\"行步长为\",{\"1\":{\"425\":1}}],[\"行只需要在内存中前进一步\",{\"1\":{\"423\":1}}],[\"行移动到第\",{\"1\":{\"423\":2}}],[\"行优先布局\",{\"1\":{\"426\":1}}],[\"行优先\",{\"1\":{\"423\":1}}],[\"行优先存储模式的步长\",{\"1\":{\"423\":1}}],[\"行的所有元素\",{\"1\":{\"422\":2}}],[\"行\",{\"1\":{\"372\":1,\"386\":1,\"423\":7}}],[\"行列数\",{\"1\":{\"272\":1}}],[\"行为\",{\"1\":{\"186\":1,\"711\":1}}],[\"既能感知局部相对位置\",{\"1\":{\"587\":1}}],[\"既然是\",{\"1\":{\"272\":1}}],[\"既可用于预测文本\",{\"1\":{\"820\":1}}],[\"既可\",{\"1\":{\"49\":1}}],[\"扩大模型规模\",{\"1\":{\"269\":1}}],[\"扩展模型的推理能力\",{\"1\":{\"713\":2}}],[\"扩展语言模型的大小\",{\"1\":{\"704\":1}}],[\"扩展函数库并验证高阶导数\",{\"1\":{\"695\":1}}],[\"扩展dezero以处理多输入多输出函数\",{\"1\":{\"693\":1}}],[\"扩展function类\",{\"0\":{\"660\":1}}],[\"扩展variable类\",{\"0\":{\"659\":1}}],[\"扩展至更大规模数据\",{\"1\":{\"560\":1}}],[\"扩展配置\",{\"1\":{\"521\":1}}],[\"扩展后的\",{\"1\":{\"427\":1}}],[\"扩展后的逻辑形状\",{\"1\":{\"427\":1}}],[\"扩展后便于广播乘法\",{\"1\":{\"100\":1}}],[\"扩展到多个变量\",{\"1\":{\"455\":1}}],[\"扩展到\",{\"1\":{\"427\":1}}],[\"扩展到更多模态\",{\"1\":{\"269\":1}}],[\"扩展等操作\",{\"1\":{\"370\":1}}],[\"扩展分类标记以匹配输入批次大小\",{\"1\":{\"319\":1,\"320\":1,\"323\":1}}],[\"扩展可学习的query\",{\"1\":{\"313\":1}}],[\"扩展了负样本数量\",{\"1\":{\"277\":1}}],[\"扩展\",{\"1\":{\"272\":1,\"580\":1}}],[\"扩展gpt\",{\"1\":{\"218\":1}}],[\"扩展成\",{\"1\":{\"170\":1}}],[\"扩展性\",{\"1\":{\"112\":1}}],[\"扩展维度后相乘\",{\"1\":{\"100\":1}}],[\"扩展生成更多问题\",{\"1\":{\"63\":1}}],[\"扩展构建了piadv2\",{\"1\":{\"6\":1}}],[\"考察其中任一排列方式\",{\"1\":{\"762\":1}}],[\"考察所有可能的\",{\"1\":{\"82\":1}}],[\"考虑对数似然\",{\"1\":{\"773\":1}}],[\"考虑元素之间的顺序\",{\"0\":{\"762\":1}}],[\"考虑某个点\",{\"1\":{\"755\":1}}],[\"考虑两个事件\",{\"1\":{\"730\":1}}],[\"考虑\",{\"1\":{\"495\":1}}],[\"考虑使用其他指标\",{\"1\":{\"447\":1}}],[\"考虑篇幅原因\",{\"1\":{\"327\":1}}],[\"考虑到我们使用的图文对数量有限\",{\"1\":{\"268\":1}}],[\"顶层使用视觉\",{\"1\":{\"264\":1}}],[\"块状掩码策略的具体实现代码如下所示\",{\"1\":{\"801\":1}}],[\"块状遮挡通过遮盖图像中的连续\",{\"1\":{\"801\":1}}],[\"块状遮挡\",{\"0\":{\"801\":1},\"1\":{\"801\":1}}],[\"块状遮挡或\",{\"1\":{\"772\":1}}],[\"块\",{\"1\":{\"374\":1}}],[\"块级作用域\",{\"1\":{\"336\":1}}],[\"块通过切换不同模态专家捕捉模态特定信息\",{\"1\":{\"264\":1}}],[\"块对齐\",{\"1\":{\"261\":1}}],[\"块对齐以及掩码语言建模等方法来聚合和对齐视觉与语言信息\",{\"1\":{\"260\":1}}],[\"块内可编码图像\",{\"1\":{\"260\":1}}],[\"词性标注\",{\"1\":{\"617\":1}}],[\"词表的大小\",{\"1\":{\"772\":1}}],[\"词表大小设置为\",{\"1\":{\"770\":1}}],[\"词表大小\",{\"1\":{\"580\":1}}],[\"词表分布\",{\"1\":{\"155\":1}}],[\"词库中的词汇数量\",{\"1\":{\"577\":1}}],[\"词汇和句法歧义\",{\"1\":{\"515\":1}}],[\"词汇表大小为\",{\"1\":{\"809\":2}}],[\"词汇表增至50\",{\"1\":{\"521\":1}}],[\"词汇表灵活性\",{\"1\":{\"521\":1}}],[\"词汇表\",{\"1\":{\"514\":1}}],[\"词汇表与正则化\",{\"1\":{\"514\":1}}],[\"词频从高到低\",{\"1\":{\"476\":1}}],[\"词嵌入与位置嵌入相加\",{\"1\":{\"311\":1}}],[\"词嵌入\",{\"1\":{\"289\":1,\"508\":1,\"544\":2,\"580\":2}}],[\"词tokenized成3个部分\",{\"1\":{\"285\":1}}],[\"词\",{\"1\":{\"260\":1,\"261\":1}}],[\"肯定得更新样本特征\",{\"1\":{\"250\":1}}],[\"了新知识\",{\"1\":{\"530\":1}}],[\"了距离判断\",{\"1\":{\"459\":1}}],[\"了它定义时的\",{\"1\":{\"340\":1}}],[\"了\",{\"1\":{\"249\":1,\"869\":1}}],[\"伪代码里的\",{\"1\":{\"248\":1}}],[\"伪标签前五名\",{\"1\":{\"157\":1}}],[\"抽蓝球为\",{\"1\":{\"741\":1}}],[\"抽取式\",{\"1\":{\"616\":1}}],[\"抽取式问答\",{\"1\":{\"616\":1}}],[\"抽取等\",{\"1\":{\"537\":1}}],[\"抽取出一套通用的模版流程\",{\"1\":{\"273\":1}}],[\"抽样数量就是字典大小\",{\"1\":{\"248\":1}}],[\"抽象代数\",{\"1\":{\"530\":1}}],[\"抽象\",{\"1\":{\"107\":1,\"109\":1}}],[\"抽象点集或局部特征\",{\"1\":{\"86\":2}}],[\"很可惜\",{\"1\":{\"847\":1,\"878\":1}}],[\"很接近\",{\"1\":{\"837\":2}}],[\"很多简单的任务\",{\"1\":{\"497\":1}}],[\"很多模型在\",{\"1\":{\"395\":1}}],[\"很容易导致旧知识遗忘\",{\"1\":{\"491\":1}}],[\"很小\",{\"1\":{\"248\":1}}],[\"很大\",{\"1\":{\"248\":1,\"249\":1}}],[\"很难在这种情况下保持分类的一致性\",{\"1\":{\"112\":1}}],[\"几乎不可能采样到接近灰色的图像\",{\"1\":{\"756\":1}}],[\"几乎所有模型都能通过同样的方式调用\",{\"1\":{\"395\":1}}],[\"几十甚至上百层\",{\"1\":{\"272\":1}}],[\"几百万个类别就太难了\",{\"1\":{\"248\":1}}],[\"几何属性\",{\"1\":{\"32\":1}}],[\"几何属性提取+意图类比\",{\"1\":{\"7\":1}}],[\"几何结构映射方法\",{\"1\":{\"49\":1}}],[\"几何结构信息与交互信息的融合\",{\"0\":{\"33\":1}}],[\"几何结构文本信息与点云信息进行融合\",{\"1\":{\"30\":1}}],[\"几何结构知识\",{\"1\":{\"28\":1}}],[\"几何结构推理\",{\"1\":{\"11\":1}}],[\"几何信息无法有效注入点云\",{\"1\":{\"24\":1}}],[\"几何推理\",{\"0\":{\"11\":1}}],[\"几何与意图利用不足\",{\"1\":{\"6\":1}}],[\"像样\",{\"1\":{\"869\":1}}],[\"像解码器\",{\"1\":{\"867\":1}}],[\"像编码器\",{\"1\":{\"867\":1}}],[\"像素级逐步采样\",{\"1\":{\"848\":1}}],[\"像素级别任务如分割\",{\"1\":{\"387\":1}}],[\"像素标签\",{\"1\":{\"848\":1}}],[\"像素恢复任务通常难以训练\",{\"1\":{\"785\":1}}],[\"像素回归的局限性\",{\"1\":{\"766\":1}}],[\"像素进行插值\",{\"1\":{\"390\":1}}],[\"像素的图像块\",{\"1\":{\"327\":1}}],[\"像素的图块\",{\"1\":{\"215\":1}}],[\"像素\",{\"1\":{\"317\":2,\"327\":1,\"816\":1}}],[\"像moco和simclr有所不同\",{\"1\":{\"298\":1}}],[\"像\",{\"1\":{\"248\":1,\"277\":1}}],[\"什么都不发生\",{\"1\":{\"728\":1}}],[\"什么样的优化目标是最高效的迁移\",{\"1\":{\"507\":1}}],[\"什么是prompt\",{\"0\":{\"497\":1}}],[\"什么是大模型\",{\"0\":{\"481\":1}}],[\"什么是闭包\",{\"0\":{\"340\":1}}],[\"什么是高阶函数\",{\"0\":{\"339\":1}}],[\"什么是负样本呢\",{\"1\":{\"246\":1}}],[\"什么是负样本\",{\"1\":{\"243\":1}}],[\"什么意思呢\",{\"1\":{\"248\":1}}],[\"看作一个正则化项是很有意思的\",{\"1\":{\"873\":1}}],[\"看哪一个输出的值最大\",{\"1\":{\"575\":1}}],[\"看一下数据的形式\",{\"1\":{\"274\":1}}],[\"看看它内部包含哪些重要组件\",{\"1\":{\"272\":1}}],[\"看起来像自编码器\",{\"1\":{\"867\":1}}],[\"看起来像传统的自编码器\",{\"1\":{\"866\":1}}],[\"看起来很像原图\",{\"1\":{\"866\":1}}],[\"看起来不像\",{\"1\":{\"866\":1}}],[\"看起\",{\"1\":{\"248\":1}}],[\"看不出区别\",{\"1\":{\"248\":1}}],[\"看不清细节\",{\"1\":{\"112\":1}}],[\"看不懂下面两行代码的话\",{\"1\":{\"92\":1}}],[\"趋近贪心采样\",{\"1\":{\"819\":1}}],[\"趋近\",{\"1\":{\"819\":2}}],[\"趋近于均匀\",{\"1\":{\"798\":1}}],[\"趋近于零\",{\"1\":{\"244\":1}}],[\"趋近于\",{\"1\":{\"244\":1}}],[\"趋于较大值时\",{\"1\":{\"748\":1}}],[\"趋于平滑\",{\"1\":{\"248\":1}}],[\"越具体\",{\"1\":{\"499\":1}}],[\"越明确\",{\"1\":{\"499\":1}}],[\"越长的prompt\",{\"1\":{\"482\":1}}],[\"越接近\",{\"1\":{\"391\":3}}],[\"越接近黄色的位置代表越靠近位置编码的中心位置\",{\"1\":{\"320\":1}}],[\"越大时\",{\"1\":{\"755\":1}}],[\"越大\",{\"1\":{\"248\":1,\"471\":2,\"473\":1,\"839\":1}}],[\"越大越好\",{\"1\":{\"467\":1,\"469\":1}}],[\"越大越\",{\"1\":{\"161\":1}}],[\"越尖锐\",{\"1\":{\"248\":1}}],[\"越小\",{\"1\":{\"248\":1,\"469\":1,\"839\":1}}],[\"刚才说了\",{\"1\":{\"246\":1}}],[\"刚性运动\",{\"0\":{\"116\":1},\"1\":{\"116\":3}}],[\"走\",{\"1\":{\"277\":1,\"839\":2}}],[\"走一遍对比学习的流程\",{\"1\":{\"249\":1}}],[\"走了捷径\",{\"1\":{\"246\":1}}],[\"走的是e12这个编码器\",{\"1\":{\"246\":1}}],[\"锚点特征\",{\"1\":{\"248\":1}}],[\"锚点\",{\"1\":{\"246\":1,\"248\":1,\"249\":1}}],[\"检测为阳性\",{\"1\":{\"731\":2}}],[\"检测率为\",{\"1\":{\"444\":1}}],[\"检测等\",{\"1\":{\"245\":1}}],[\"检查遮挡块尺寸是否小于输入图像patch尺寸\",{\"1\":{\"801\":1}}],[\"检查\",{\"1\":{\"362\":1}}],[\"检查图像是否为\",{\"1\":{\"316\":1}}],[\"检查当前目录是否有预训练权重文件\",{\"1\":{\"302\":1,\"304\":1}}],[\"检查输入图像尺寸是否与初始化尺寸匹配\",{\"1\":{\"272\":1}}],[\"检索机制和索引管道等\",{\"1\":{\"714\":1}}],[\"检索能力\",{\"1\":{\"714\":1}}],[\"检索和使用外部数据可能引发伦理和隐私方面的问题\",{\"1\":{\"711\":1}}],[\"检索和分类任务的推理速度更快\",{\"1\":{\"261\":1}}],[\"检索阶段\",{\"1\":{\"710\":1}}],[\"检索增强生成\",{\"0\":{\"709\":1},\"1\":{\"709\":1}}],[\"检索任务需对所有图文对联合编码\",{\"1\":{\"260\":1}}],[\"检索任务高效\",{\"1\":{\"260\":1}}],[\"检索\",{\"1\":{\"189\":1,\"196\":1,\"710\":1}}],[\"检索等任务\",{\"1\":{\"112\":1}}],[\"巧妙构造出来\",{\"1\":{\"242\":1}}],[\"编号\",{\"1\":{\"793\":1}}],[\"编造\",{\"1\":{\"616\":1}}],[\"编程和逻辑推理等任务中表现卓越\",{\"1\":{\"704\":1}}],[\"编程\",{\"1\":{\"239\":1}}],[\"编码字典\",{\"1\":{\"885\":1}}],[\"编码输入图像\",{\"1\":{\"885\":1}}],[\"编码输入文本为\",{\"1\":{\"820\":1}}],[\"编码代价\",{\"1\":{\"872\":1}}],[\"编码结果\",{\"1\":{\"868\":1}}],[\"编码变长\",{\"1\":{\"830\":1}}],[\"编码是最优的\",{\"1\":{\"830\":1}}],[\"编码图文对\",{\"1\":{\"789\":1}}],[\"编码图像为\",{\"1\":{\"817\":1}}],[\"编码图像的\",{\"1\":{\"814\":1}}],[\"编码图像\",{\"1\":{\"59\":1}}],[\"编码能力异常强大\",{\"1\":{\"704\":1}}],[\"编码后可能是\",{\"1\":{\"616\":1}}],[\"编码后\",{\"1\":{\"614\":1,\"814\":2}}],[\"编码后得到输出的结果\",{\"1\":{\"311\":1}}],[\"编码在不同维度上具有不同的周期性\",{\"1\":{\"587\":1}}],[\"编码值的波动就越小\",{\"1\":{\"587\":1}}],[\"编码成\",{\"1\":{\"572\":1}}],[\"编码的文本\",{\"1\":{\"807\":1}}],[\"编码的维度设定为\",{\"1\":{\"587\":1}}],[\"编码的冗余扩展\",{\"1\":{\"521\":1}}],[\"编码的输入文本\",{\"1\":{\"147\":1}}],[\"编码为连续隐变量\",{\"1\":{\"885\":1}}],[\"编码为\",{\"1\":{\"770\":1}}],[\"编码为图像特征\",{\"1\":{\"312\":1}}],[\"编码为两个特征\",{\"1\":{\"13\":1}}],[\"编码阶段\",{\"1\":{\"289\":1}}],[\"编码影响\",{\"1\":{\"246\":1}}],[\"编码文本输入\",{\"1\":{\"142\":1}}],[\"编码过程\",{\"1\":{\"99\":1,\"885\":1}}],[\"编码器和嵌入向量的学习速度应该不一样快\",{\"1\":{\"882\":1}}],[\"编码器和解码器\",{\"1\":{\"792\":1}}],[\"编码器的目标是让\",{\"1\":{\"869\":1}}],[\"编码器的图像变换\",{\"1\":{\"802\":1}}],[\"编码器最终输出\",{\"1\":{\"821\":1}}],[\"编码器最终输出层\",{\"1\":{\"793\":1}}],[\"编码器末尾追加\",{\"1\":{\"821\":1}}],[\"编码器网络层列表\",{\"1\":{\"821\":1}}],[\"编码器输入\",{\"1\":{\"858\":1}}],[\"编码器输入通道从图像开始\",{\"1\":{\"821\":1}}],[\"编码器输出\",{\"1\":{\"821\":1}}],[\"编码器输出的\",{\"1\":{\"312\":1}}],[\"编码器下采样后\",{\"1\":{\"814\":1}}],[\"编码器把图像变成\",{\"1\":{\"807\":1}}],[\"编码器在给定\",{\"1\":{\"807\":1}}],[\"编码器提取上下文特征\",{\"1\":{\"804\":1}}],[\"编码器会被正则化为\",{\"1\":{\"800\":1}}],[\"编码器如果训练不当\",{\"1\":{\"800\":1}}],[\"编码器前向传播\",{\"1\":{\"794\":1}}],[\"编码器残差块\",{\"1\":{\"793\":1}}],[\"编码器初始输入通道\",{\"1\":{\"793\":1}}],[\"编码器中的卷积层个数\",{\"1\":{\"814\":1}}],[\"编码器中\",{\"1\":{\"772\":1}}],[\"编码器隐藏层输出\",{\"1\":{\"631\":1}}],[\"编码器层列表\",{\"1\":{\"793\":1}}],[\"编码器层\",{\"1\":{\"627\":1}}],[\"编码器层堆叠\",{\"1\":{\"580\":1}}],[\"编码器层数\",{\"1\":{\"580\":1}}],[\"编码器将图像转换为\",{\"1\":{\"167\":1}}],[\"编码器将输入图像转为离散\",{\"1\":{\"165\":1}}],[\"编码器建模图文交互\",{\"1\":{\"150\":1}}],[\"编码器模型适合理解类任务但难以生成文本\",{\"1\":{\"122\":1}}],[\"编码器模型不适合文本生成任务\",{\"1\":{\"120\":1}}],[\"编码器部分\",{\"1\":{\"101\":1}}],[\"编码器\",{\"0\":{\"134\":1,\"290\":1},\"1\":{\"98\":2,\"99\":1,\"101\":1,\"120\":1,\"122\":1,\"622\":1,\"777\":1,\"793\":2,\"803\":1,\"807\":1,\"809\":1,\"821\":3,\"853\":1,\"859\":1,\"869\":1,\"885\":1}}],[\"编码器不同层级的点云特征\",{\"1\":{\"46\":1}}],[\"编码\",{\"1\":{\"98\":1,\"145\":1,\"170\":1,\"246\":1,\"277\":2,\"559\":1,\"794\":1,\"795\":1,\"796\":1,\"809\":1,\"822\":2,\"873\":1}}],[\"编码得到的图像\",{\"1\":{\"807\":1}}],[\"编码得到\",{\"1\":{\"72\":1}}],[\"编码点云特征\",{\"1\":{\"70\":1}}],[\"编码推理结果\",{\"1\":{\"8\":1}}],[\"写入归一化像素值\",{\"1\":{\"848\":1}}],[\"写入json文件\",{\"1\":{\"577\":1}}],[\"写作风格或特定领域知识\",{\"1\":{\"711\":1}}],[\"写好prompt\",{\"1\":{\"502\":1}}],[\"写故事\",{\"1\":{\"239\":1}}],[\"写一个关于猫的故事\",{\"1\":{\"232\":1}}],[\"唤醒\",{\"1\":{\"239\":1}}],[\"辨析\",{\"0\":{\"239\":1}}],[\"刷新\",{\"1\":{\"236\":1}}],[\"刷新该数据集\",{\"1\":{\"235\":1}}],[\"助手需要生成推理过程\",{\"1\":{\"235\":1}}],[\"助手\",{\"1\":{\"235\":1,\"704\":1}}],[\"你差不多提前设计出了stable\",{\"1\":{\"883\":1}}],[\"你不仅能理解vq\",{\"1\":{\"877\":1}}],[\"你应该已经相信\",{\"1\":{\"870\":1}}],[\"你测量两个人到中间点的距离\",{\"1\":{\"837\":1}}],[\"你先测量\",{\"1\":{\"837\":1}}],[\"你会看到这个信息的可能性\",{\"1\":{\"758\":1}}],[\"你会得到\",{\"1\":{\"455\":1}}],[\"你在看到\",{\"1\":{\"758\":1}}],[\"你在没有观察任何信息前对\",{\"1\":{\"758\":1}}],[\"你在图片分类的时候很多照片是同一个类别\",{\"1\":{\"243\":1}}],[\"你观测到的信息\",{\"1\":{\"758\":1}}],[\"你总得允许\",{\"1\":{\"728\":1}}],[\"你有一个随机变量\",{\"1\":{\"727\":1}}],[\"你细品\",{\"1\":{\"665\":1}}],[\"你品\",{\"1\":{\"665\":1}}],[\"你将得到一个包含多个元素的\",{\"1\":{\"614\":1}}],[\"你关心离你近的人\",{\"1\":{\"590\":1}}],[\"你关心和你内容类似的人\",{\"1\":{\"590\":1}}],[\"你\",{\"1\":{\"590\":1}}],[\"你可能以为既然是围绕全灰图采样\",{\"1\":{\"756\":1}}],[\"你可能会觉得这里面有个问题\",{\"1\":{\"575\":1}}],[\"你可以为一个运算随意设计求梯度的方法\",{\"1\":{\"881\":1}}],[\"你可以在训练完成后加入如下代码来生成图像\",{\"1\":{\"857\":1}}],[\"你可以把它理解成\",{\"1\":{\"728\":1}}],[\"你可以把它们理解成\",{\"1\":{\"728\":1}}],[\"你可以把马氏距离想成是\",{\"1\":{\"459\":1}}],[\"你可以使用以下命令查看你所有的\",{\"1\":{\"434\":1}}],[\"你就可以把它们两两之间的协方差\",{\"1\":{\"455\":1}}],[\"你的环境名\",{\"1\":{\"438\":1}}],[\"你的终端提示符通常会显示当前环境的名字\",{\"1\":{\"432\":1}}],[\"你需要为每个选项分别构造一个完整的\",{\"1\":{\"618\":1}}],[\"你需要跳过\",{\"1\":{\"423\":1}}],[\"你需要在内存中跳过\",{\"1\":{\"423\":1}}],[\"你几乎可以把它当成\",{\"1\":{\"395\":1}}],[\"你要在\",{\"1\":{\"387\":1}}],[\"你希望衡量模型在真实匹配样本上的性能\",{\"1\":{\"274\":1}}],[\"你希望模型看到\",{\"1\":{\"274\":1}}],[\"你是一个视觉助手\",{\"1\":{\"235\":1}}],[\"你知道吗\",{\"1\":{\"111\":1}}],[\"理想中我们希望\",{\"1\":{\"798\":1}}],[\"理想情况\",{\"1\":{\"307\":1}}],[\"理解此处的数学推导意义不大\",{\"1\":{\"881\":1}}],[\"理解微妙提示方面表现更出色\",{\"1\":{\"704\":1}}],[\"理解反面\",{\"1\":{\"515\":1}}],[\"理解为\",{\"1\":{\"426\":1}}],[\"理解并回答科学类问题\",{\"1\":{\"235\":1}}],[\"理论\",{\"1\":{\"872\":1}}],[\"理论支持\",{\"1\":{\"385\":1}}],[\"理论结果\",{\"1\":{\"385\":1}}],[\"理论限制的相似性\",{\"1\":{\"385\":1}}],[\"理论上可在单机计算\",{\"1\":{\"277\":1}}],[\"理论上的限制\",{\"1\":{\"112\":1}}],[\"理论上证明\",{\"1\":{\"105\":1}}],[\"理论分析保证模型鲁棒性\",{\"1\":{\"105\":1}}],[\"期望平方距离为\",{\"1\":{\"755\":1}}],[\"期望模型能够学习到文本和图像之间的匹配关系\",{\"1\":{\"298\":1}}],[\"期望的回答\",{\"1\":{\"234\":1,\"235\":1}}],[\"期望输出\",{\"1\":{\"232\":1}}],[\"请把这部分原文告诉我\",{\"1\":{\"616\":1}}],[\"请看下面这张图\",{\"1\":{\"587\":1}}],[\"请保持尊重\",{\"1\":{\"538\":1}}],[\"请尊重\",{\"1\":{\"536\":1}}],[\"请取消下面这行注释\",{\"1\":{\"471\":1}}],[\"请考虑下图中的点\",{\"1\":{\"453\":1}}],[\"请使用此方法\",{\"1\":{\"447\":1}}],[\"请仅与其他指标搭配使用\",{\"1\":{\"447\":1}}],[\"请注意\",{\"1\":{\"442\":1,\"541\":1,\"770\":1,\"872\":1}}],[\"请阅读源码进行学习\",{\"1\":{\"288\":1}}],[\"请描述这张图片\",{\"1\":{\"234\":1}}],[\"请求\",{\"1\":{\"232\":1}}],[\"条件生成图像\",{\"0\":{\"861\":1}}],[\"条件化\",{\"1\":{\"858\":1}}],[\"条件变分自编码器\",{\"0\":{\"874\":1},\"1\":{\"850\":1,\"858\":1,\"874\":1}}],[\"条件输入\",{\"1\":{\"817\":1}}],[\"条件对输出的额外影响\",{\"1\":{\"816\":1}}],[\"条件概率衡量的是\",{\"1\":{\"730\":1}}],[\"条件概率\",{\"0\":{\"730\":1},\"1\":{\"510\":1}}],[\"条\",{\"1\":{\"235\":3}}],[\"条图文对\",{\"1\":{\"235\":1}}],[\"条高质量图文对\",{\"1\":{\"234\":1}}],[\"条描述\",{\"1\":{\"234\":1}}],[\"名标注者\",{\"1\":{\"537\":1}}],[\"名词等\",{\"1\":{\"522\":1}}],[\"名词\",{\"1\":{\"455\":1}}],[\"名词短语过滤\",{\"1\":{\"234\":1}}],[\"名称的长版本\",{\"1\":{\"450\":1}}],[\"名称\",{\"1\":{\"82\":1,\"235\":1}}],[\"复合运算的验证\",{\"1\":{\"690\":1}}],[\"复合函数的计算图展示了函数的组合过程\",{\"1\":{\"648\":1}}],[\"复合函数的计算\",{\"0\":{\"646\":1}}],[\"复用这个模型的\",{\"1\":{\"820\":1}}],[\"复用同一行数据\",{\"1\":{\"427\":1}}],[\"复用缓存的视觉信息\",{\"1\":{\"312\":1}}],[\"复制到\",{\"1\":{\"881\":1}}],[\"复制\",{\"1\":{\"346\":1}}],[\"复杂函数可视化示例\",{\"1\":{\"696\":1}}],[\"复杂函数的求导\",{\"0\":{\"692\":1}}],[\"复杂计算图处理\",{\"1\":{\"692\":1}}],[\"复杂指令处理能力不足\",{\"1\":{\"539\":1}}],[\"复杂\",{\"1\":{\"266\":1,\"728\":1}}],[\"复杂推理型\",{\"1\":{\"235\":1}}],[\"复杂推理能力\",{\"1\":{\"233\":1}}],[\"复现\",{\"0\":{\"83\":1}}],[\"回\",{\"1\":{\"885\":1}}],[\"回归模型的最佳结果往往是\",{\"1\":{\"874\":1}}],[\"回归损失函数\",{\"1\":{\"797\":1}}],[\"回忆一下\",{\"1\":{\"873\":1,\"878\":1}}],[\"回调\",{\"1\":{\"713\":1}}],[\"回调该钩子方法完成合适的批量数据格式组织\",{\"1\":{\"274\":1}}],[\"回收时机非即时性\",{\"1\":{\"687\":1}}],[\"回顾下之前的多模态网络设计\",{\"1\":{\"307\":1}}],[\"回顾\",{\"1\":{\"278\":1}}],[\"回答问题\",{\"1\":{\"708\":1}}],[\"回答\",{\"1\":{\"232\":1,\"239\":1,\"616\":1}}],[\"回原始输入形状\",{\"1\":{\"170\":1}}],[\"响应速度更快\",{\"1\":{\"704\":1}}],[\"响应速度比\",{\"1\":{\"704\":1}}],[\"响应\",{\"1\":{\"239\":2}}],[\"响应数据对模型进行微调\",{\"1\":{\"232\":1}}],[\"响应数据集\",{\"1\":{\"232\":1}}],[\"响应对\",{\"1\":{\"232\":1}}],[\"响应格式与\",{\"1\":{\"227\":1}}],[\"创新的动态高分辨率处理策略\",{\"1\":{\"230\":1}}],[\"创建的\",{\"1\":{\"714\":1,\"810\":1}}],[\"创建配置类config\",{\"1\":{\"688\":1}}],[\"创建变量的函数\",{\"0\":{\"640\":1}}],[\"创建用以区分special\",{\"1\":{\"594\":1}}],[\"创建句子辨识列表\",{\"1\":{\"594\":1}}],[\"创建反向映射\",{\"1\":{\"578\":1}}],[\"创建环境并安装一些常用包\",{\"1\":{\"431\":1}}],[\"创建环境时指定\",{\"1\":{\"431\":1}}],[\"创建新的线性层\",{\"1\":{\"580\":1}}],[\"创建新环境\",{\"0\":{\"431\":1}}],[\"创建新张量\",{\"1\":{\"364\":1}}],[\"创建了一个一维张量\",{\"1\":{\"423\":1}}],[\"创建预输出层\",{\"1\":{\"323\":1}}],[\"创建归一化层\",{\"1\":{\"323\":1}}],[\"创建encoder\",{\"1\":{\"323\":1}}],[\"创建丢弃层\",{\"1\":{\"320\":1,\"323\":1}}],[\"创建图像块嵌入层\",{\"1\":{\"319\":1,\"320\":1,\"323\":1}}],[\"创建图像注意力掩码\",{\"1\":{\"313\":1}}],[\"创建可学习的位置嵌入\",{\"1\":{\"320\":1,\"323\":1}}],[\"创建可学习的分类标记\",{\"1\":{\"319\":1,\"320\":1,\"323\":1}}],[\"创建可学习参数\",{\"1\":{\"272\":1}}],[\"创建可视化窗口\",{\"1\":{\"83\":1}}],[\"创建\",{\"1\":{\"186\":1,\"321\":1,\"793\":1}}],[\"创建损失函数\",{\"1\":{\"186\":1}}],[\"创建一个连续的转置副本\",{\"1\":{\"426\":1}}],[\"创建一个张量\",{\"1\":{\"425\":1,\"426\":2}}],[\"创建一个\",{\"1\":{\"423\":1}}],[\"创建一个空环境\",{\"1\":{\"431\":1}}],[\"创建一个空\",{\"1\":{\"186\":1}}],[\"创建一个全零点作为\",{\"1\":{\"92\":1}}],[\"创建文本编码器\",{\"1\":{\"147\":1}}],[\"创建主视觉编码器\",{\"1\":{\"147\":1}}],[\"创建动量编码器\",{\"1\":{\"145\":1}}],[\"聊天版语言模型\",{\"1\":{\"227\":1}}],[\"聊天版本\",{\"1\":{\"222\":1}}],[\"缩小方法\",{\"1\":{\"390\":1}}],[\"缩小了与商业模型的差距\",{\"1\":{\"225\":1}}],[\"缩放点积注意力\",{\"1\":{\"293\":1,\"405\":1}}],[\"缩放值\",{\"1\":{\"272\":1}}],[\"缩放\",{\"1\":{\"116\":1,\"117\":1,\"272\":1,\"521\":1}}],[\"缩放因子\",{\"1\":{\"45\":1,\"272\":2,\"277\":2,\"322\":1,\"388\":1}}],[\"额外的\",{\"1\":{\"591\":1}}],[\"额外的提升\",{\"1\":{\"516\":1}}],[\"额外构建\",{\"1\":{\"274\":1}}],[\"额外添加448×448缩略图以保留全局上下文\",{\"1\":{\"224\":1}}],[\"额外通道数\",{\"1\":{\"46\":1}}],[\"阿里云开源了\",{\"1\":{\"704\":1}}],[\"阿里\",{\"1\":{\"218\":1}}],[\"商业模型在规模和性能上领先\",{\"1\":{\"220\":1}}],[\"商业模型在多模态领域占据领先地位\",{\"1\":{\"218\":1}}],[\"商业模型通过多语言数据集训练\",{\"1\":{\"216\":1}}],[\"商业模型通常具有超过1000亿参数\",{\"1\":{\"216\":1}}],[\"商业模型支持动态分辨率以保留原始宽高比\",{\"1\":{\"216\":1}}],[\"系数范围是\",{\"1\":{\"467\":1}}],[\"系数衡量的是预测掩码与真实标签之间的相似性\",{\"1\":{\"467\":1}}],[\"系数\",{\"1\":{\"467\":2,\"471\":2}}],[\"系统2是慢思考系统\",{\"1\":{\"500\":1}}],[\"系统2\",{\"1\":{\"500\":1}}],[\"系统1是快思考系统\",{\"1\":{\"500\":1}}],[\"系统1\",{\"1\":{\"500\":1}}],[\"系统提示语\",{\"1\":{\"235\":1}}],[\"系统的进步\",{\"1\":{\"189\":1}}],[\"系列均采用\",{\"1\":{\"704\":1}}],[\"系列工作\",{\"1\":{\"704\":1}}],[\"系列基础模型\",{\"1\":{\"704\":1}}],[\"系列基本上是后续大模型的标杆\",{\"1\":{\"704\":1}}],[\"系列在开源社区的影响力和应用前景\",{\"1\":{\"704\":1}}],[\"系列相同\",{\"1\":{\"704\":1}}],[\"系列的三个版本\",{\"1\":{\"704\":1}}],[\"系列模型是\",{\"1\":{\"704\":1}}],[\"系列模型是由\",{\"1\":{\"704\":1}}],[\"系列模型\",{\"1\":{\"704\":2}}],[\"系列语言大模型由\",{\"1\":{\"704\":1}}],[\"系列已形成\",{\"1\":{\"704\":1}}],[\"系列\",{\"1\":{\"218\":1,\"219\":1,\"395\":1,\"531\":1,\"703\":1,\"704\":3}}],[\"系列等\",{\"1\":{\"215\":1}}],[\"项引入的误差分析\",{\"0\":{\"871\":1}}],[\"项前加权得到\",{\"1\":{\"807\":1}}],[\"项自然语言理解任务\",{\"1\":{\"561\":1}}],[\"项对训练稳定性影响较大\",{\"1\":{\"561\":1}}],[\"项目模块化结构\",{\"0\":{\"691\":1}}],[\"项目\",{\"1\":{\"294\":1,\"539\":1}}],[\"项目的数据组织中\",{\"1\":{\"29\":1}}],[\"项\",{\"1\":{\"248\":1,\"385\":1}}],[\"项达到领先水平\",{\"1\":{\"215\":1}}],[\"精通数学的人\",{\"1\":{\"847\":1}}],[\"精细的指令遵循\",{\"1\":{\"704\":1}}],[\"精准度高\",{\"1\":{\"704\":1}}],[\"精确表示\",{\"1\":{\"591\":1}}],[\"精确匹配准确率4\",{\"1\":{\"522\":1}}],[\"精确率与召回率曲线\",{\"0\":{\"452\":1},\"1\":{\"452\":1}}],[\"精确率和召回率通常呈现反向关系\",{\"1\":{\"446\":1}}],[\"精确率会提高\",{\"1\":{\"446\":1}}],[\"精确率作为指标的意义和实用性较低\",{\"1\":{\"446\":1}}],[\"精确率衡量的是被归类为垃圾邮件且实际上是垃圾邮件的电子邮件所占的比例\",{\"1\":{\"446\":1}}],[\"精确率是指模型所有正类别分类中实际为正类别的分类所占的比例\",{\"1\":{\"446\":1}}],[\"精确率\",{\"0\":{\"446\":1},\"1\":{\"447\":1,\"452\":1}}],[\"精度越高意味着分布越\",{\"1\":{\"746\":1}}],[\"精度丢失\",{\"1\":{\"653\":1}}],[\"精度高于最近邻\",{\"1\":{\"390\":1}}],[\"精度受限\",{\"1\":{\"114\":1}}],[\"精心构建了一个涵盖常见场景和文档图像的双语数据集\",{\"1\":{\"215\":1}}],[\"轮的部分计算\",{\"1\":{\"541\":1}}],[\"轮推理时必然包含了第\",{\"1\":{\"541\":1}}],[\"轮输入数据新增了一个\",{\"1\":{\"541\":1}}],[\"轮输入数据只比第\",{\"1\":{\"541\":1}}],[\"轮训练就足够了\",{\"1\":{\"514\":1}}],[\"轮热身\",{\"1\":{\"212\":1}}],[\"轮\",{\"1\":{\"210\":1,\"211\":1,\"212\":1,\"514\":1}}],[\"各组成部分的重要性\",{\"1\":{\"780\":1}}],[\"各种情形本身的概率\",{\"1\":{\"731\":1}}],[\"各需要一个\",{\"1\":{\"627\":1,\"630\":1}}],[\"各类别的权重\",{\"1\":{\"467\":1}}],[\"各训练\",{\"1\":{\"210\":1}}],[\"各方法差别不大\",{\"1\":{\"23\":1}}],[\"峰值学习率\",{\"1\":{\"209\":1,\"212\":1}}],[\"率\",{\"1\":{\"208\":1,\"211\":1}}],[\"β₂\",{\"1\":{\"774\":1}}],[\"β₁\",{\"1\":{\"774\":1}}],[\"β=0\",{\"1\":{\"471\":2}}],[\"β>α\",{\"1\":{\"471\":1}}],[\"β\",{\"1\":{\"471\":3,\"473\":3,\"537\":1,\"807\":2}}],[\"β2=0\",{\"1\":{\"208\":1,\"209\":1}}],[\"β1=0\",{\"1\":{\"208\":1,\"209\":1}}],[\"发生的概率\",{\"1\":{\"828\":1}}],[\"发生的可能性有多大\",{\"1\":{\"730\":1}}],[\"发生\",{\"1\":{\"729\":1}}],[\"发挥大模型为核心的大模型开发与传统的\",{\"1\":{\"716\":1}}],[\"发布并开源了\",{\"1\":{\"704\":2}}],[\"发布\",{\"1\":{\"704\":7}}],[\"发布的\",{\"1\":{\"704\":7}}],[\"发布模型\",{\"1\":{\"567\":1}}],[\"发布了全新升级的\",{\"1\":{\"704\":1}}],[\"发布了初始版本\",{\"1\":{\"704\":1}}],[\"发布了基于\",{\"1\":{\"704\":1}}],[\"发布了\",{\"1\":{\"138\":1,\"704\":10}}],[\"发现这对结果没有显著影响\",{\"1\":{\"810\":1}}],[\"发现潜在bug\",{\"1\":{\"677\":1}}],[\"发现\",{\"1\":{\"561\":1,\"780\":1}}],[\"发现无论是在训练损失还是实际任务中的表现\",{\"1\":{\"529\":1}}],[\"发现使用\",{\"1\":{\"204\":1}}],[\"兼容性与支持\",{\"1\":{\"714\":1}}],[\"兼容性\",{\"1\":{\"521\":1}}],[\"兼容大多数分类模型\",{\"1\":{\"470\":1}}],[\"兼具理解和生成能力\",{\"1\":{\"203\":1}}],[\"兼顾了对\",{\"1\":{\"714\":1}}],[\"兼顾了效率与泛化能力\",{\"1\":{\"150\":1}}],[\"兼顾像素级精度和区域重叠度\",{\"1\":{\"473\":1}}],[\"兼顾这两者\",{\"1\":{\"447\":1}}],[\"兼顾理解与生成能力\",{\"1\":{\"120\":1}}],[\"零\",{\"0\":{\"570\":1,\"576\":1},\"1\":{\"570\":1,\"576\":1}}],[\"零样本性能\",{\"1\":{\"549\":1}}],[\"零样本学习\",{\"1\":{\"528\":1}}],[\"零样本表现\",{\"1\":{\"516\":1}}],[\"零样本图像字幕生成\",{\"1\":{\"202\":1}}],[\"零样本图像\",{\"1\":{\"202\":1}}],[\"零样本图像分类\",{\"1\":{\"202\":1}}],[\"零拷贝\",{\"1\":{\"425\":1,\"426\":1}}],[\"零计算开销的\",{\"1\":{\"156\":1}}],[\"占比60\",{\"1\":{\"528\":1}}],[\"占据了特别大的内存资源和计算资源\",{\"1\":{\"490\":1}}],[\"占\",{\"1\":{\"199\":1}}],[\"亿对文本\",{\"1\":{\"810\":1}}],[\"亿图文对\",{\"1\":{\"806\":1}}],[\"亿图像\",{\"1\":{\"131\":1}}],[\"亿的自回归\",{\"1\":{\"806\":1}}],[\"亿的大语言模型\",{\"1\":{\"704\":1}}],[\"亿用户的增长\",{\"1\":{\"704\":1}}],[\"亿\",{\"1\":{\"703\":2}}],[\"亿个语句的数据合集\",{\"1\":{\"577\":1}}],[\"亿张图像\",{\"1\":{\"327\":1}}],[\"亿时\",{\"1\":{\"247\":1}}],[\"亿样本\",{\"1\":{\"208\":2}}],[\"亿参数模型的初步实验\",{\"1\":{\"810\":1}}],[\"亿参数的稀疏\",{\"1\":{\"809\":1}}],[\"亿参数的\",{\"1\":{\"703\":2}}],[\"亿参数规模\",{\"1\":{\"206\":1,\"810\":1}}],[\"亿参数\",{\"1\":{\"199\":1,\"704\":1}}],[\"此后\",{\"1\":{\"806\":1}}],[\"此例中\",{\"1\":{\"690\":1}}],[\"此指标可平衡精确率和召回率的重要性\",{\"1\":{\"448\":1}}],[\"此处将行维度从\",{\"1\":{\"427\":1}}],[\"此时公式简化为\",{\"1\":{\"866\":1}}],[\"此时认为\",{\"1\":{\"799\":1}}],[\"此时离目的地更近\",{\"1\":{\"697\":1}}],[\"此时需交换操作数顺序并调用sub类\",{\"1\":{\"690\":1}}],[\"此时a\",{\"1\":{\"687\":1}}],[\"此时我们可以通过辈分来确保函数b和c先于函数a取出\",{\"1\":{\"686\":1}}],[\"此时我们还要训练两个\",{\"1\":{\"575\":1}}],[\"此时的tinypytorch已经具备了自动微分的能力\",{\"1\":{\"678\":1}}],[\"此时影响因子r\",{\"1\":{\"656\":1}}],[\"此时r=\",{\"1\":{\"656\":1}}],[\"此时为空\",{\"1\":{\"544\":1}}],[\"此时马氏距离变为\",{\"1\":{\"459\":1}}],[\"此时必须先\",{\"1\":{\"361\":1}}],[\"此时先用text\",{\"1\":{\"312\":1}}],[\"此时\",{\"1\":{\"248\":1,\"252\":1,\"690\":1,\"727\":1,\"773\":1,\"799\":1,\"808\":1}}],[\"此前的研究\",{\"1\":{\"527\":1}}],[\"此前\",{\"1\":{\"232\":1}}],[\"此阶段有两种不同的配置方式\",{\"1\":{\"199\":1}}],[\"此阶段中\",{\"1\":{\"199\":1}}],[\"此外\",{\"1\":{\"5\":1,\"26\":1,\"48\":1,\"176\":1,\"191\":1,\"203\":1,\"223\":1,\"268\":2,\"280\":1,\"300\":1,\"301\":1,\"305\":1,\"362\":1,\"382\":1,\"495\":1,\"529\":1,\"531\":1,\"534\":1,\"535\":1,\"536\":1,\"559\":1,\"708\":1,\"766\":1,\"770\":1,\"772\":1,\"790\":1,\"806\":1,\"873\":1}}],[\"初步版本包含约800万篇文档\",{\"1\":{\"521\":1}}],[\"初步对齐视觉编码器\",{\"1\":{\"198\":1}}],[\"初期在\",{\"1\":{\"208\":1}}],[\"初始值复制自卷积核的权重\",{\"1\":{\"848\":1}}],[\"初始值为\",{\"1\":{\"818\":1}}],[\"初始输入\",{\"1\":{\"541\":1}}],[\"初始步幅\",{\"1\":{\"427\":1}}],[\"初始时没有任何语义信息\",{\"1\":{\"319\":1}}],[\"初始时随机选择一个点作为第一个中心点\",{\"1\":{\"92\":1}}],[\"初始文本token\",{\"1\":{\"313\":1}}],[\"初始为\",{\"1\":{\"313\":1}}],[\"初始阶段在较低分辨率\",{\"1\":{\"198\":1}}],[\"初始假设变换为恒等变换\",{\"1\":{\"107\":1}}],[\"初始设为一个极大值\",{\"1\":{\"92\":1}}],[\"初始化采样张量\",{\"1\":{\"848\":1}}],[\"初始化生成器和判别器网络参数\",{\"1\":{\"840\":1}}],[\"初始化输出\",{\"1\":{\"817\":1}}],[\"初始化一个全零的遮挡掩码\",{\"1\":{\"801\":1}}],[\"初始化一个简化版的\",{\"1\":{\"580\":1}}],[\"初始化运算符重载\",{\"1\":{\"691\":1}}],[\"初始化桶编号\",{\"1\":{\"591\":1}}],[\"初始化优化\",{\"1\":{\"521\":1}}],[\"初始化优化器\",{\"1\":{\"142\":1}}],[\"初始化为\",{\"1\":{\"493\":1,\"686\":1}}],[\"初始化两个低秩矩阵\",{\"1\":{\"490\":1}}],[\"初始化低秩矩阵\",{\"1\":{\"490\":1}}],[\"初始化自定义数据集类\",{\"1\":{\"316\":1}}],[\"初始化query\",{\"1\":{\"309\":1}}],[\"初始化各\",{\"1\":{\"278\":1}}],[\"初始化阶段\",{\"1\":{\"273\":1}}],[\"初始化所有权重\",{\"1\":{\"272\":1}}],[\"初始化视觉与文本\",{\"1\":{\"272\":1}}],[\"初始化视觉编码器\",{\"1\":{\"142\":1,\"145\":1,\"160\":1}}],[\"初始化值\",{\"1\":{\"272\":2}}],[\"初始化的语言中间件\",{\"1\":{\"206\":1}}],[\"初始化教师输出中心向量\",{\"1\":{\"186\":1}}],[\"初始化教师网络\",{\"1\":{\"186\":1}}],[\"初始化码本的路径\",{\"1\":{\"170\":1}}],[\"初始化码本\",{\"1\":{\"170\":2}}],[\"初始化新的簇中心\",{\"1\":{\"170\":1}}],[\"初始化簇中心\",{\"1\":{\"170\":1}}],[\"初始化权重\",{\"1\":{\"169\":1}}],[\"初始化队列特征为单位向量\",{\"1\":{\"160\":1}}],[\"初始化队列为单位向量\",{\"1\":{\"147\":1}}],[\"初始化负样本队列\",{\"1\":{\"160\":1}}],[\"初始化动量编码器参数\",{\"1\":{\"160\":1}}],[\"初始化时直接复制参数\",{\"1\":{\"147\":1}}],[\"初始化方法\",{\"1\":{\"147\":1}}],[\"初始化对比学习的负样本队列\",{\"1\":{\"145\":1}}],[\"初始化文本输入\",{\"1\":{\"313\":1}}],[\"初始化文本编码器和分词器\",{\"1\":{\"145\":1}}],[\"初始化文本解码器\",{\"1\":{\"142\":1}}],[\"初始化文本分词器\",{\"1\":{\"142\":1}}],[\"初始化函数\",{\"1\":{\"100\":1,\"467\":1,\"468\":1,\"469\":1,\"470\":1,\"471\":1,\"473\":1}}],[\"初始化pointrefer模型\",{\"1\":{\"83\":1}}],[\"初始化\",{\"0\":{\"793\":1},\"1\":{\"82\":1,\"101\":1,\"142\":1,\"160\":1,\"169\":2,\"170\":1,\"186\":1,\"277\":2,\"318\":1,\"319\":1,\"493\":5,\"544\":1,\"802\":1,\"803\":1,\"886\":1}}],[\"初始化损失函数\",{\"1\":{\"80\":1}}],[\"初始化模型和优化器\",{\"1\":{\"142\":1}}],[\"初始化模型\",{\"1\":{\"80\":1,\"885\":1}}],[\"初始化用于存储每个样本拼接后输入和\",{\"1\":{\"43\":1}}],[\"瑞士军刀\",{\"1\":{\"197\":1}}],[\"双视图表示\",{\"1\":{\"766\":1}}],[\"双线性\",{\"0\":{\"390\":1},\"1\":{\"390\":1}}],[\"双线性插值是一种常用的图像放大\",{\"1\":{\"390\":1}}],[\"双线性插值\",{\"1\":{\"387\":2}}],[\"双向对比损失\",{\"1\":{\"822\":1}}],[\"双向自注意力\",{\"1\":{\"311\":1}}],[\"双向注意力\",{\"1\":{\"134\":1}}],[\"双编码器\",{\"1\":{\"261\":1,\"269\":1}}],[\"双编码器架构\",{\"1\":{\"260\":1}}],[\"双编码器设计\",{\"1\":{\"220\":1}}],[\"双语数据集\",{\"1\":{\"225\":1}}],[\"双语数据集和持续学习的视觉编码器\",{\"1\":{\"220\":1}}],[\"双语描述\",{\"1\":{\"225\":1}}],[\"双语能力\",{\"1\":{\"216\":1}}],[\"双分支视觉编码器\",{\"1\":{\"219\":1}}],[\"双塔模型\",{\"1\":{\"196\":1}}],[\"新信息\",{\"1\":{\"828\":1}}],[\"新的文本\",{\"1\":{\"616\":1}}],[\"新的问题出现了\",{\"1\":{\"305\":1}}],[\"新闻数据\",{\"1\":{\"561\":1}}],[\"新词使用\",{\"1\":{\"529\":1}}],[\"新加入模块约为\",{\"1\":{\"199\":1}}],[\"新增名称属性\",{\"1\":{\"689\":1}}],[\"新增的可学习查询和交叉注意力层\",{\"1\":{\"209\":1}}],[\"新增模块\",{\"1\":{\"199\":1}}],[\"新增了96个可学习查询和交叉注意力层\",{\"1\":{\"197\":1}}],[\"新增96个可学习查询和交叉注意力层\",{\"1\":{\"196\":1}}],[\"新颖性与多样性\",{\"1\":{\"133\":1}}],[\"详解\",{\"0\":{\"540\":1}}],[\"详见算法\",{\"1\":{\"772\":1}}],[\"详见表\",{\"1\":{\"528\":1}}],[\"详见表1\",{\"1\":{\"196\":1,\"547\":1}}],[\"详见附录\",{\"1\":{\"268\":1,\"539\":1}}],[\"详细参数配置见表2\",{\"1\":{\"548\":1}}],[\"详细描述型\",{\"1\":{\"235\":1}}],[\"详细描述\",{\"1\":{\"234\":2}}],[\"详细描述交互\",{\"1\":{\"28\":1}}],[\"详细训练设置\",{\"0\":{\"207\":1}}],[\"详细解释\",{\"1\":{\"76\":1,\"616\":1}}],[\"详细交互行为\",{\"1\":{\"28\":1}}],[\"填补上vq\",{\"1\":{\"878\":1}}],[\"填补了这一领域的空白\",{\"1\":{\"194\":1}}],[\"填充\",{\"1\":{\"809\":1}}],[\"填充过程图\",{\"1\":{\"594\":1}}],[\"填充token对应0\",{\"1\":{\"594\":1}}],[\"填充符\",{\"1\":{\"313\":1}}],[\"填充至最长序列长度\",{\"1\":{\"40\":1}}],[\"远多于文本\",{\"1\":{\"815\":1}}],[\"远距离可能映射到不同桶\",{\"1\":{\"591\":1}}],[\"远距离用粗桶\",{\"1\":{\"591\":1}}],[\"远优于此前结果\",{\"1\":{\"529\":1}}],[\"远低于监督系统30\",{\"1\":{\"522\":1}}],[\"远低于解耦时的\",{\"1\":{\"134\":1}}],[\"远小于原始矩阵的维度\",{\"1\":{\"490\":1}}],[\"远\",{\"1\":{\"459\":1}}],[\"远落后于llms的规模\",{\"1\":{\"191\":1}}],[\"然而在某些情况下\",{\"1\":{\"709\":1}}],[\"然而大规模的未标注的文本语料是丰富\",{\"1\":{\"506\":1}}],[\"然而\",{\"1\":{\"191\":1,\"192\":1,\"216\":1,\"223\":1,\"299\":1,\"305\":3,\"520\":1,\"527\":2,\"703\":1,\"706\":1,\"730\":1,\"753\":1,\"772\":1,\"807\":1,\"864\":1,\"868\":1,\"870\":1,\"871\":1,\"873\":1}}],[\"然后用\",{\"1\":{\"866\":1}}],[\"然后用行归一化将多个正样本平均分配权重\",{\"1\":{\"145\":1}}],[\"然后送入\",{\"1\":{\"857\":1}}],[\"然后按比例混合\",{\"1\":{\"816\":1}}],[\"然后他们在\",{\"1\":{\"807\":1}}],[\"然后套入\",{\"1\":{\"807\":1}}],[\"然后加入位置编码并送入\",{\"1\":{\"804\":1}}],[\"然后随机选择一个遮挡块的宽高比\",{\"1\":{\"772\":1}}],[\"然后预测这些被遮挡位置对应的视觉\",{\"1\":{\"772\":1}}],[\"然后延展设计核心功能的上下游功能\",{\"1\":{\"717\":1}}],[\"然后从中选出最合适的那个\",{\"1\":{\"618\":1}}],[\"然后启动\",{\"1\":{\"593\":1}}],[\"然后换维度到\",{\"1\":{\"591\":1}}],[\"然后查表取出偏置\",{\"1\":{\"591\":1}}],[\"然后给出一个假设\",{\"1\":{\"575\":1}}],[\"然后让模型通过上下文预测那一个被遮盖或替换的部分\",{\"1\":{\"572\":1}}],[\"然后让模型去学习特征\",{\"1\":{\"246\":1}}],[\"然后切分成query\",{\"1\":{\"544\":1}}],[\"然后作为下一次推理的输入\",{\"1\":{\"541\":1}}],[\"然后能成功迁移学习解决判别式任务\",{\"1\":{\"517\":1}}],[\"然后累积计算每个误差对iou得分的影响\",{\"1\":{\"472\":1}}],[\"然后损失就是\",{\"1\":{\"471\":1}}],[\"然后打包成一个group\",{\"1\":{\"428\":1}}],[\"然后再将模型迁移到具体的下游任务上进行微调\",{\"1\":{\"778\":1}}],[\"然后再进行详细解析\",{\"1\":{\"590\":1}}],[\"然后再把新的问题让小孩子来解决\",{\"1\":{\"501\":1}}],[\"然后再经过一层\",{\"1\":{\"326\":1}}],[\"然后再拿到其它数据集上做迁移学习\",{\"1\":{\"324\":1}}],[\"然后输入到mlp\",{\"1\":{\"323\":1}}],[\"然后调整形状并重新排列维度\",{\"1\":{\"322\":1}}],[\"然后将每个\",{\"1\":{\"804\":1}}],[\"然后将全局表示送入\",{\"1\":{\"776\":1}}],[\"然后将其输入\",{\"1\":{\"772\":1}}],[\"然后将tf模型转为对应的pytorch版本即可\",{\"1\":{\"593\":1}}],[\"然后将该位置的\",{\"1\":{\"575\":1}}],[\"然后将所有的\",{\"1\":{\"574\":1}}],[\"然后将\",{\"1\":{\"326\":1,\"450\":1}}],[\"然后将特征图的最后两维展平为一维\",{\"1\":{\"318\":1}}],[\"然后将这个\",{\"1\":{\"869\":1}}],[\"然后将这个骨干网络参数冻结\",{\"1\":{\"245\":1}}],[\"然后将这些不同尺度的特征拼接在一起\",{\"1\":{\"96\":1}}],[\"然后图像的表征和\",{\"1\":{\"313\":1}}],[\"然后计算以下表达式的梯度\",{\"1\":{\"868\":1}}],[\"然后计算出和当前文本描述相似度最高的那副图片\",{\"1\":{\"303\":1}}],[\"然后计算每个分类文本对应的文本嵌入向量\",{\"1\":{\"302\":1}}],[\"然后利用模型获取文本特征\",{\"1\":{\"302\":1}}],[\"然后提取了相应的文本特征\",{\"1\":{\"300\":1}}],[\"然后文本输出接两层mlp预测mask掉的tokens\",{\"1\":{\"285\":1}}],[\"然后和postion\",{\"1\":{\"284\":1}}],[\"然后和position\",{\"1\":{\"284\":1}}],[\"然后还原维度为\",{\"1\":{\"272\":1}}],[\"然后对\",{\"1\":{\"826\":1}}],[\"然后对句子进行分词\",{\"1\":{\"578\":1}}],[\"然后对文本标志位对应输出使用一个线性的itm\",{\"1\":{\"285\":1}}],[\"然后对文本\",{\"1\":{\"266\":1}}],[\"然后对它们的特征做加权平均\",{\"1\":{\"100\":1}}],[\"然后在每项具体任务上判别性微调discriminative\",{\"1\":{\"506\":1}}],[\"然后在训练过程中\",{\"1\":{\"320\":1}}],[\"然后在具体的下游任务上进行微调\",{\"1\":{\"305\":1}}],[\"然后在文本语料上预训练语言专家\",{\"1\":{\"268\":1}}],[\"然后在下游任务如图文检索\",{\"1\":{\"260\":1}}],[\"然后在后续会进行如下处理\",{\"1\":{\"76\":1}}],[\"然后每次训练的时候\",{\"1\":{\"250\":1}}],[\"然后牺牲一些一致性\",{\"1\":{\"250\":1}}],[\"然后进行水平翻转\",{\"1\":{\"317\":1}}],[\"然后进来\",{\"1\":{\"249\":1}}],[\"然后进入pointnet++的特征传播阶段\",{\"1\":{\"30\":1}}],[\"然后经过e12这个编码器\",{\"1\":{\"246\":1}}],[\"然后我们读取要预测的图像\",{\"1\":{\"300\":1}}],[\"然后我们加一个\",{\"1\":{\"248\":1}}],[\"然后我们将图片x1经过数据增强t1得到图片x11\",{\"1\":{\"246\":1}}],[\"然后我们便可以直接用训练好的vit和bert来做图文匹配和图文相似度计算了\",{\"1\":{\"146\":1}}],[\"然后训练模型去恢复被遮挡的\",{\"1\":{\"167\":1}}],[\"然后定义\",{\"1\":{\"157\":1}}],[\"然后使用prepare\",{\"1\":{\"577\":1}}],[\"然后使用第一个cls\",{\"1\":{\"309\":1}}],[\"然后使用一个对比学习的函数去训练模型就可以了\",{\"1\":{\"243\":1}}],[\"然后使用\",{\"1\":{\"112\":1}}],[\"然后使用全局最大池化\",{\"1\":{\"112\":1}}],[\"然后取\",{\"1\":{\"108\":1}}],[\"然后取平均得到\",{\"1\":{\"82\":1}}],[\"然后通过微调\",{\"1\":{\"705\":1}}],[\"然后通过人类对多个模型输出的偏好进行排序\",{\"1\":{\"534\":1}}],[\"然后通过全连接层\",{\"1\":{\"110\":2}}],[\"然后通过\",{\"1\":{\"98\":1,\"575\":1}}],[\"然后通过对应的pointnets提取每个尺度上的特征来捕获多尺度模式\",{\"1\":{\"95\":1}}],[\"然后只保留前\",{\"1\":{\"92\":1}}],[\"然后复制这个索引数组到每个\",{\"1\":{\"92\":1}}],[\"然后把所有点映射到高维的特征通过最大池化最终表示全局特征\",{\"1\":{\"86\":1}}],[\"然后求和\",{\"1\":{\"82\":1}}],[\"然后\",{\"1\":{\"8\":1,\"300\":1,\"345\":1,\"423\":1,\"472\":1,\"716\":1,\"727\":1}}],[\"及\",{\"1\":{\"312\":1,\"843\":1}}],[\"及其右侧\",{\"1\":{\"848\":1}}],[\"及其对应的索引\",{\"1\":{\"818\":1}}],[\"及其迭代优化之后\",{\"1\":{\"717\":1}}],[\"及其多个变种\",{\"1\":{\"201\":1}}],[\"及其变体\",{\"1\":{\"191\":1}}],[\"及之后\",{\"1\":{\"159\":1}}],[\"渐进式图像\",{\"1\":{\"189\":1}}],[\"渐变\",{\"1\":{\"83\":1}}],[\"渐变颜色\",{\"1\":{\"83\":1}}],[\"轻松理解\",{\"1\":{\"887\":1}}],[\"轻松\",{\"1\":{\"716\":1}}],[\"轻量推理\",{\"1\":{\"704\":1}}],[\"轻量知识型\",{\"1\":{\"704\":1}}],[\"轻量级胶水层难以捕捉跨模态的复杂交互\",{\"1\":{\"189\":1}}],[\"轻\",{\"1\":{\"307\":7}}],[\"轻便\",{\"1\":{\"114\":1}}],[\"胶水层\",{\"1\":{\"189\":2,\"197\":1}}],[\"书生\",{\"0\":{\"187\":1,\"214\":1}}],[\"张量简介\",{\"1\":{\"428\":1}}],[\"张量变换操作\",{\"0\":{\"424\":1}}],[\"张量可以被视为一种广义的矩阵\",{\"1\":{\"421\":1}}],[\"张量会和调用它的原张量\",{\"1\":{\"378\":1}}],[\"张量创建方法\",{\"1\":{\"378\":1}}],[\"张量\",{\"1\":{\"359\":1,\"421\":1,\"423\":1,\"590\":1,\"795\":1}}],[\"张\",{\"1\":{\"208\":1,\"209\":1,\"774\":1}}],[\"张图片\",{\"1\":{\"186\":1}}],[\"张全局裁剪图像\",{\"1\":{\"186\":1}}],[\"丢弃它\",{\"1\":{\"803\":1}}],[\"丢弃最后不足\",{\"1\":{\"186\":1}}],[\"丢给\",{\"1\":{\"575\":1}}],[\"丢掉\",{\"1\":{\"295\":3}}],[\"丢失部分几何信息\",{\"1\":{\"114\":1}}],[\"打包成\",{\"1\":{\"821\":1}}],[\"打包返回结果\",{\"1\":{\"277\":2}}],[\"打分的模型\",{\"1\":{\"817\":1}}],[\"打分是\",{\"1\":{\"590\":1}}],[\"打下了基础\",{\"1\":{\"790\":1}}],[\"打破了\",{\"1\":{\"704\":1}}],[\"打破了这两个领域壁垒\",{\"1\":{\"314\":1}}],[\"打印时自动对齐多行数据\",{\"1\":{\"689\":1}}],[\"打印当前性能指标\",{\"1\":{\"82\":1}}],[\"打乱顺序\",{\"1\":{\"579\":1}}],[\"打乱数据顺序\",{\"1\":{\"186\":1}}],[\"打开指定索引的图像文件\",{\"1\":{\"316\":1}}],[\"送入模型中\",{\"1\":{\"575\":1}}],[\"送入llm时\",{\"1\":{\"313\":1}}],[\"送入\",{\"1\":{\"186\":1,\"575\":1,\"804\":1,\"815\":1,\"820\":1}}],[\"化方法\",{\"1\":{\"789\":1}}],[\"化的表示也非常常见\",{\"1\":{\"789\":1}}],[\"化为\",{\"1\":{\"770\":1}}],[\"化\",{\"1\":{\"186\":1}}],[\"遍历遮挡块区域\",{\"1\":{\"801\":1}}],[\"遍历所有相邻字符对的组合\",{\"1\":{\"477\":1}}],[\"遍历所有句子\",{\"1\":{\"477\":1}}],[\"遍历vocab中所有词\",{\"1\":{\"476\":2}}],[\"遍历句子列表\",{\"1\":{\"476\":1}}],[\"遍历数据加载器中的每个批次数据\",{\"1\":{\"323\":1}}],[\"遍历获取supported支持的所有文件路径\",{\"1\":{\"316\":1}}],[\"遍历文件夹\",{\"1\":{\"316\":1}}],[\"遍历data目录\",{\"1\":{\"303\":1}}],[\"遍历\",{\"1\":{\"277\":1,\"303\":1,\"304\":1}}],[\"遍历每个文件夹下的文件\",{\"1\":{\"316\":1}}],[\"遍历每个学生视图\",{\"1\":{\"186\":1}}],[\"遍历每个教师视图\",{\"1\":{\"186\":1}}],[\"遍历不同分辨率的分组\",{\"1\":{\"186\":1}}],[\"遍历标注数据列表\",{\"1\":{\"68\":1}}],[\"放回到\",{\"1\":{\"250\":1}}],[\"放到和输入相同的\",{\"1\":{\"186\":1}}],[\"放大这个差值就能让模型更\",{\"1\":{\"816\":1}}],[\"放大难分类样本的影响\",{\"1\":{\"470\":1}}],[\"放大难分类样本影响\",{\"1\":{\"78\":1}}],[\"放大两倍\",{\"1\":{\"389\":1}}],[\"放大\",{\"1\":{\"78\":1,\"470\":1,\"815\":1}}],[\"色调变化\",{\"1\":{\"186\":1}}],[\"亮度变化\",{\"1\":{\"186\":1}}],[\"耗时\",{\"1\":{\"353\":1}}],[\"耗时46小时\",{\"1\":{\"184\":1}}],[\"耗时严重\",{\"1\":{\"49\":1}}],[\"收益和风险\",{\"1\":{\"447\":1}}],[\"收录了数百种视觉模型\",{\"1\":{\"395\":1}}],[\"收敛情况的粗略指标\",{\"1\":{\"447\":1}}],[\"收敛\",{\"1\":{\"319\":1}}],[\"收敛为零并不是一件容易的事\",{\"1\":{\"871\":1}}],[\"收敛为\",{\"1\":{\"183\":1}}],[\"收敛为0\",{\"1\":{\"183\":1}}],[\"收集相邻句对\",{\"1\":{\"579\":1}}],[\"收集相同数量的相邻句对和非相邻句对\",{\"1\":{\"579\":1}}],[\"收集一组模型输出对\",{\"1\":{\"537\":1}}],[\"收集人类对模型多个输出的排序偏好\",{\"1\":{\"535\":1}}],[\"收集人类示范数据\",{\"1\":{\"535\":1}}],[\"收集人类偏好数据\",{\"1\":{\"232\":1}}],[\"收集成\",{\"1\":{\"337\":2}}],[\"收集了大量的人类编写的\",{\"1\":{\"232\":1}}],[\"收集指令\",{\"1\":{\"232\":1}}],[\"收集约\",{\"1\":{\"198\":1}}],[\"收集所有样本的预测结果\",{\"1\":{\"82\":1}}],[\"冻结预训练模型参数\",{\"1\":{\"490\":1}}],[\"冻结参数的image\",{\"1\":{\"309\":1}}],[\"冻结注意力模块和视觉专家\",{\"1\":{\"266\":1}}],[\"冻结主干网络\",{\"1\":{\"209\":1}}],[\"冻结\",{\"1\":{\"198\":1,\"814\":1}}],[\"冻结特征\",{\"1\":{\"179\":1}}],[\"冻结教师\",{\"1\":{\"178\":1}}],[\"光照变换\",{\"1\":{\"179\":1}}],[\"高概率地类似训练集中的数据\",{\"1\":{\"865\":1}}],[\"高度\",{\"1\":{\"846\":1}}],[\"高可用的托管解决方案\",{\"1\":{\"715\":1}}],[\"高计算资源需求\",{\"1\":{\"705\":1}}],[\"高次运算\",{\"1\":{\"692\":1}}],[\"高于ndarray的优先级\",{\"1\":{\"690\":1}}],[\"高于性别化代词\",{\"1\":{\"549\":1}}],[\"高维更多语义\",{\"1\":{\"587\":1}}],[\"高维对全局位置变化敏感\",{\"1\":{\"587\":1}}],[\"高维向量部分\",{\"1\":{\"587\":1}}],[\"高维分量\",{\"1\":{\"587\":1}}],[\"高维输入时\",{\"1\":{\"385\":1}}],[\"高纬度的编码值波动性较小\",{\"1\":{\"587\":1}}],[\"高赞网页内容\",{\"1\":{\"561\":1}}],[\"高质量完成\",{\"1\":{\"539\":1}}],[\"高质量数据被重复使用\",{\"1\":{\"528\":1}}],[\"高质量双语数据集\",{\"1\":{\"215\":1,\"216\":1}}],[\"高容量模型通过最大化文本序列的似然估计\",{\"1\":{\"524\":1}}],[\"高置信度\",{\"1\":{\"470\":1}}],[\"高斯肥皂泡现象\",{\"1\":{\"754\":1}}],[\"高斯壳\",{\"0\":{\"753\":1}}],[\"高斯联合分布\",{\"0\":{\"750\":1}}],[\"高斯分布是熵最大的分布\",{\"1\":{\"750\":1}}],[\"高斯分布作为近似是相当合理的\",{\"1\":{\"750\":1}}],[\"高斯分布的\",{\"1\":{\"753\":1}}],[\"高斯分布的一个问题在于它对离群点非常敏感\",{\"1\":{\"748\":1}}],[\"高斯分布的累积分布函数\",{\"1\":{\"746\":1}}],[\"高斯分布的概率密度函数\",{\"1\":{\"746\":1}}],[\"高斯分布\",{\"0\":{\"746\":1}}],[\"高斯过程\",{\"1\":{\"455\":2}}],[\"高斯混合模型\",{\"1\":{\"455\":1}}],[\"高斯模糊\",{\"1\":{\"179\":1,\"186\":3}}],[\"高效利用\",{\"1\":{\"800\":1}}],[\"高效\",{\"1\":{\"695\":1}}],[\"高效的模型微调\",{\"1\":{\"495\":1}}],[\"高效实现\",{\"1\":{\"395\":1}}],[\"高效广播\",{\"1\":{\"364\":1}}],[\"高阶导数构建\",{\"1\":{\"695\":1}}],[\"高阶导数\",{\"0\":{\"695\":1,\"698\":1}}],[\"高阶导数与深度学习优化进阶\",{\"1\":{\"694\":1}}],[\"高阶项导致数值不稳定\",{\"1\":{\"385\":1}}],[\"高阶函数\",{\"1\":{\"339\":1,\"341\":3,\"342\":1}}],[\"高分辨率\",{\"1\":{\"229\":1}}],[\"高分辨率优化方法\",{\"1\":{\"219\":1}}],[\"高分辨率用于文档分析\",{\"1\":{\"216\":1}}],[\"高\",{\"1\":{\"216\":1,\"307\":1,\"470\":1}}],[\"高出\",{\"1\":{\"23\":2}}],[\"余弦函数编码\",{\"1\":{\"588\":1}}],[\"余弦位置编码\",{\"0\":{\"587\":1}}],[\"余弦学习率调度\",{\"1\":{\"548\":1}}],[\"余弦退火\",{\"1\":{\"179\":1}}],[\"余弦相似度\",{\"0\":{\"391\":1},\"1\":{\"170\":1,\"391\":1}}],[\"序列和解码后的文本\",{\"1\":{\"820\":1}}],[\"序列解码为可读文本\",{\"1\":{\"820\":1}}],[\"序列中每个\",{\"1\":{\"814\":1}}],[\"序列中额外加入一个可学习的\",{\"1\":{\"179\":1}}],[\"序列前添加一个特殊的\",{\"1\":{\"771\":1}}],[\"序列很长时\",{\"1\":{\"591\":1}}],[\"序列输出\",{\"1\":{\"277\":1}}],[\"序列长度\",{\"1\":{\"272\":1,\"560\":1,\"561\":1,\"590\":1,\"591\":1,\"814\":1,\"815\":1}}],[\"序列\",{\"1\":{\"234\":1,\"277\":1,\"312\":1,\"512\":1,\"772\":1,\"804\":1,\"817\":7,\"820\":2,\"821\":1}}],[\"序列为文本\",{\"1\":{\"143\":1}}],[\"锐化操作则产生相反作用\",{\"1\":{\"183\":1}}],[\"锐化\",{\"1\":{\"178\":1}}],[\"坍塌问题\",{\"1\":{\"178\":1}}],[\"值更有帮助\",{\"1\":{\"807\":1}}],[\"值得大力推广\",{\"1\":{\"707\":1}}],[\"值得注意的是\",{\"1\":{\"178\":1,\"426\":1}}],[\"值的更新过程\",{\"1\":{\"697\":1}}],[\"值增加最快的方向是\",{\"1\":{\"697\":1}}],[\"值加1\",{\"1\":{\"686\":1}}],[\"值是在前向传播中算的\",{\"1\":{\"881\":1}}],[\"值是整数\",{\"1\":{\"591\":1}}],[\"值是\",{\"1\":{\"591\":1}}],[\"值域范围是\",{\"1\":{\"590\":1}}],[\"值变大并不能提升微调的效果\",{\"1\":{\"494\":1}}],[\"值越大\",{\"1\":{\"470\":1}}],[\"值越小表示匹配越好\",{\"1\":{\"467\":1}}],[\"值向量\",{\"1\":{\"410\":1}}],[\"值\",{\"1\":{\"387\":1,\"425\":1,\"469\":1,\"470\":1,\"660\":1,\"818\":1,\"820\":1,\"867\":2}}],[\"值固定为\",{\"1\":{\"277\":1}}],[\"值为0\",{\"1\":{\"815\":1}}],[\"值为出现次数\",{\"1\":{\"401\":1}}],[\"值为\",{\"1\":{\"163\":1,\"473\":1}}],[\"裁剪后再统一缩放到\",{\"1\":{\"186\":1}}],[\"裁剪\",{\"1\":{\"178\":1}}],[\"借用了\",{\"1\":{\"843\":1}}],[\"借鉴这种\",{\"1\":{\"789\":1}}],[\"借鉴\",{\"1\":{\"269\":1}}],[\"借鉴了\",{\"1\":{\"175\":1}}],[\"借助反向传播训练神经网络这一强大函数逼近器的突破\",{\"1\":{\"864\":1}}],[\"借助复杂的模型架构\",{\"1\":{\"806\":1}}],[\"借助于海量无标注数据的训练\",{\"1\":{\"707\":1}}],[\"借助\",{\"1\":{\"704\":1,\"714\":1,\"787\":1}}],[\"借助字典映射为word\",{\"1\":{\"594\":1}}],[\"借助对比学习机制\",{\"1\":{\"298\":1}}],[\"借助海量图文数据和多阶段训练策略\",{\"1\":{\"206\":1}}],[\"借助取反激活图片背景区域\",{\"1\":{\"59\":1}}],[\"白两种颜色来描述图像\",{\"1\":{\"847\":1}}],[\"白化\",{\"1\":{\"175\":1}}],[\"白色背景\",{\"1\":{\"83\":1}}],[\"超轻量推理\",{\"1\":{\"704\":1}}],[\"超强推理能力\",{\"1\":{\"704\":1}}],[\"超长截断\",{\"1\":{\"594\":1}}],[\"超参数调整\",{\"1\":{\"474\":1}}],[\"超参数设置说明\",{\"1\":{\"473\":1}}],[\"超参数为\",{\"1\":{\"208\":1,\"774\":1}}],[\"超级大的多分类问题\",{\"1\":{\"248\":1}}],[\"超越xlnet\",{\"1\":{\"565\":1,\"566\":1}}],[\"超越flan\",{\"1\":{\"549\":1,\"550\":1}}],[\"超越chinchilla\",{\"1\":{\"549\":1}}],[\"超越了基于监督学习或对比学习的主流方法\",{\"1\":{\"790\":1}}],[\"超越了一些基于检索系统的模型\",{\"1\":{\"529\":1}}],[\"超越了同规模cnn的自监督方法\",{\"1\":{\"184\":1}}],[\"超越了同规模\",{\"1\":{\"173\":1}}],[\"超越gpt\",{\"1\":{\"228\":1}}],[\"超越如\",{\"1\":{\"202\":1}}],[\"超过了随机水平\",{\"1\":{\"706\":1}}],[\"超过了如\",{\"1\":{\"201\":1}}],[\"超过按最大处理\",{\"1\":{\"591\":1}}],[\"超过部分无监督方法\",{\"1\":{\"522\":1}}],[\"超过此前需依赖上下文词约束的sota方法\",{\"1\":{\"522\":1}}],[\"超过起始层索引才启用\",{\"1\":{\"272\":1}}],[\"超过历史最佳\",{\"1\":{\"82\":1}}],[\"超大规模\",{\"1\":{\"530\":1}}],[\"超大规模语言模型可以显著减少对任务特定数据的需求\",{\"1\":{\"527\":1}}],[\"超大\",{\"1\":{\"175\":1}}],[\"天完成了\",{\"1\":{\"704\":1}}],[\"天注册人数突破\",{\"1\":{\"704\":1}}],[\"天\",{\"1\":{\"173\":1}}],[\"台\",{\"1\":{\"173\":1}}],[\"达到55\",{\"1\":{\"522\":1}}],[\"达到非常低的\",{\"1\":{\"514\":1}}],[\"达到四两拨千斤的效果\",{\"1\":{\"495\":1}}],[\"达到最先进性能\",{\"1\":{\"260\":1}}],[\"达到了\",{\"1\":{\"235\":1}}],[\"达到\",{\"1\":{\"173\":1,\"201\":1,\"203\":1,\"537\":1}}],[\"达成最新最优性能\",{\"1\":{\"23\":1}}],[\"居中操作抑制单维主导\",{\"1\":{\"183\":1}}],[\"居中操作等价于给教师输出加一个偏置项\",{\"1\":{\"178\":1}}],[\"居中与锐化效果互补\",{\"1\":{\"178\":1}}],[\"居中\",{\"1\":{\"173\":1,\"178\":1,\"183\":1}}],[\"准确来说\",{\"1\":{\"682\":1,\"843\":1}}],[\"准确性是指所有分类\",{\"1\":{\"443\":1}}],[\"准确率83\",{\"1\":{\"566\":1}}],[\"准确率低至72\",{\"1\":{\"551\":1}}],[\"准确率刷新sota\",{\"1\":{\"549\":1}}],[\"准确率达63\",{\"1\":{\"522\":1}}],[\"准确率达到\",{\"1\":{\"235\":1}}],[\"准确率进一步提升至63\",{\"1\":{\"522\":1}}],[\"准确率从19\",{\"1\":{\"522\":1}}],[\"准确率可以作为衡量模型质量的粗略指标\",{\"1\":{\"443\":1}}],[\"准确率衡量的是所有电子邮件正确分类所占的比例\",{\"1\":{\"443\":1}}],[\"准确率变化\",{\"1\":{\"237\":1}}],[\"准确率提升不大\",{\"1\":{\"236\":1}}],[\"准确率\",{\"0\":{\"443\":1},\"1\":{\"173\":1,\"184\":2,\"185\":1,\"235\":1,\"277\":1,\"447\":1,\"452\":1,\"474\":1,\"515\":1,\"522\":1}}],[\"准备调试\",{\"1\":{\"593\":1}}],[\"准备就绪\",{\"1\":{\"593\":1}}],[\"准备与下游任务相关的数据集\",{\"1\":{\"490\":1}}],[\"准备生成参数\",{\"1\":{\"313\":1}}],[\"准备阶段主要完成数据集加载\",{\"1\":{\"80\":1}}],[\"准备\",{\"0\":{\"80\":1},\"1\":{\"79\":1,\"312\":1,\"579\":1,\"804\":2}}],[\"带入上式中\",{\"1\":{\"867\":1}}],[\"带入公式得到\",{\"1\":{\"798\":1}}],[\"带示例的任务\",{\"1\":{\"537\":1}}],[\"带星号\",{\"1\":{\"434\":1}}],[\"带参数的装饰器\",{\"0\":{\"345\":1}}],[\"带参数的函数装饰器\",{\"0\":{\"344\":1}}],[\"带残差连接\",{\"1\":{\"272\":1}}],[\"带来的提升逐渐减弱\",{\"1\":{\"184\":1}}],[\"带来新的特性\",{\"1\":{\"173\":1}}],[\"带曲线\",{\"1\":{\"28\":1}}],[\"近两年\",{\"1\":{\"877\":1}}],[\"近似回传\",{\"1\":{\"885\":1}}],[\"近似真实后验\",{\"1\":{\"807\":1}}],[\"近似采样\",{\"1\":{\"793\":1}}],[\"近似值\",{\"1\":{\"692\":1}}],[\"近似于\",{\"1\":{\"469\":1}}],[\"近距离用细桶\",{\"1\":{\"591\":1}}],[\"近代自然语言处理技术发展的\",{\"1\":{\"488\":1}}],[\"近期\",{\"1\":{\"806\":1}}],[\"近期的方法如\",{\"1\":{\"784\":1}}],[\"近期研究考虑过各种各样的目标\",{\"1\":{\"507\":1}}],[\"近期研究通过将视觉模型与llms结合\",{\"1\":{\"193\":1}}],[\"近期研究发现\",{\"1\":{\"175\":1}}],[\"近期成为卷积神经网络\",{\"1\":{\"173\":1}}],[\"近年来\",{\"1\":{\"305\":1,\"520\":1,\"521\":1,\"527\":1,\"864\":1}}],[\"近年来的在线蒸馏则使用多个同时训练的模型进行知识迁移\",{\"1\":{\"150\":1}}],[\"近年来生成模型被用于文本任务的样本合成\",{\"1\":{\"124\":1}}],[\"稳定平衡\",{\"1\":{\"816\":1}}],[\"稳定训练\",{\"1\":{\"272\":1,\"796\":1}}],[\"稳定\",{\"1\":{\"170\":1}}],[\"稳定的\",{\"1\":{\"107\":1}}],[\"记为\",{\"1\":{\"771\":1}}],[\"记作\",{\"1\":{\"727\":2,\"731\":2,\"739\":1,\"772\":1,\"798\":1,\"866\":1}}],[\"记忆机制\",{\"1\":{\"714\":1}}],[\"记忆\",{\"1\":{\"713\":1}}],[\"记忆与泛化分析\",{\"1\":{\"522\":1}}],[\"记忆库\",{\"1\":{\"175\":1}}],[\"记住用户之前的交互习惯和偏好\",{\"1\":{\"704\":1}}],[\"记住了\",{\"1\":{\"340\":1,\"341\":1}}],[\"记住\",{\"1\":{\"232\":1,\"340\":1}}],[\"记得对中心做\",{\"1\":{\"170\":1}}],[\"记录本次新增遮挡的patch数量\",{\"1\":{\"801\":1}}],[\"记录宽高比范围的对数形式\",{\"1\":{\"801\":1}}],[\"记录创建该变量的函数\",{\"1\":{\"664\":1}}],[\"记录input后\",{\"1\":{\"660\":1}}],[\"记录输入长度\",{\"1\":{\"594\":1}}],[\"记录被掩码的原token\",{\"1\":{\"578\":1}}],[\"记录被掩码的位置\",{\"1\":{\"578\":1,\"580\":1}}],[\"记录当前词对应输入词序列中的索引\",{\"1\":{\"544\":1}}],[\"记录该子词对的全局频率\",{\"1\":{\"476\":1}}],[\"记录该类别的样本数量\",{\"1\":{\"316\":1}}],[\"记录历史合并的最高频子词对及其频率\",{\"1\":{\"476\":1}}],[\"记录损失和准确率到日志\",{\"1\":{\"276\":1}}],[\"记录一下本轮训练需要推进的学习任务有几个\",{\"1\":{\"275\":1}}],[\"记录\",{\"1\":{\"272\":2,\"277\":1,\"717\":1}}],[\"记录每个词的出现次数的词典\",{\"1\":{\"476\":1}}],[\"记录每个词的出现次数\",{\"1\":{\"476\":1}}],[\"记录每个物体对应的点云索引下标区间\",{\"1\":{\"29\":1}}],[\"记录每层输出\",{\"1\":{\"277\":1}}],[\"记录每类物体对应的点云文件下标索引区间\",{\"1\":{\"58\":1}}],[\"记录物体边界框\",{\"1\":{\"58\":1}}],[\"除此之外\",{\"1\":{\"845\":1}}],[\"除此之外的都是噪声样本\",{\"1\":{\"248\":1}}],[\"除此之外的特征都是使用之前的编码器得到的\",{\"1\":{\"246\":1}}],[\"除外\",{\"1\":{\"811\":1}}],[\"除boolq和winogrande\",{\"1\":{\"549\":1}}],[\"除以温度\",{\"1\":{\"819\":1}}],[\"除以后\",{\"1\":{\"815\":1}}],[\"除以\",{\"1\":{\"815\":1}}],[\"除以可以缓解这个问题\",{\"1\":{\"418\":1}}],[\"除以该簇的样本数\",{\"1\":{\"170\":1}}],[\"除非特别说明\",{\"1\":{\"811\":1}}],[\"除非指定\",{\"1\":{\"514\":1}}],[\"除非通过\",{\"1\":{\"378\":1}}],[\"除非增加额外的归一化\",{\"1\":{\"182\":1}}],[\"除head\",{\"1\":{\"327\":1}}],[\"除了能直接计算图像的概率外\",{\"1\":{\"847\":1}}],[\"除了最后一个\",{\"1\":{\"312\":1}}],[\"除了模型本身的应用\",{\"1\":{\"301\":1}}],[\"除了个体判别这个任务外\",{\"1\":{\"247\":1}}],[\"除法运算y\",{\"1\":{\"690\":1}}],[\"除法运算\",{\"1\":{\"690\":1}}],[\"除法\",{\"1\":{\"160\":1}}],[\"空事件\",{\"1\":{\"728\":1}}],[\"空\",{\"1\":{\"277\":3}}],[\"空簇\",{\"1\":{\"170\":1}}],[\"空间远小于先验分布\",{\"1\":{\"867\":1}}],[\"空间上的掩码仍然使用传统\",{\"1\":{\"846\":1}}],[\"空间掩码设计\",{\"1\":{\"848\":1}}],[\"空间掩码\",{\"0\":{\"845\":1},\"1\":{\"846\":2}}],[\"空间关系混乱\",{\"1\":{\"806\":1}}],[\"空间\",{\"1\":{\"277\":2,\"817\":1,\"822\":4}}],[\"空间中的位置\",{\"1\":{\"114\":1}}],[\"空间变换网络\",{\"1\":{\"103\":1,\"105\":1}}],[\"空间是均匀和各向同性的\",{\"1\":{\"90\":1}}],[\"空间均匀性\",{\"1\":{\"90\":1}}],[\"空间混合\",{\"1\":{\"73\":1}}],[\"空间先验对齐\",{\"1\":{\"52\":1}}],[\"空间维度\",{\"1\":{\"46\":1}}],[\"空间特征\",{\"1\":{\"45\":1}}],[\"μ\",{\"1\":{\"170\":1,\"853\":2}}],[\"循环多个epoch\",{\"1\":{\"803\":1}}],[\"循环直到遮挡的patch数量达到指定的遮挡总数\",{\"1\":{\"801\":1}}],[\"循环引用会导致python对象无法被正常回收\",{\"1\":{\"687\":1}}],[\"循环引用仍会导致对象无法释放\",{\"1\":{\"687\":1}}],[\"循环引用指对象之间相互引用\",{\"1\":{\"687\":1}}],[\"循环引用与内存释放\",{\"0\":{\"687\":1}}],[\"循环来设置每一对的导数\",{\"1\":{\"682\":1}}],[\"循环实现的优势\",{\"0\":{\"669\":1}}],[\"循环实现反向传播\",{\"0\":{\"668\":1}}],[\"循环变量在循环体外仍然可见\",{\"1\":{\"336\":1}}],[\"循环\",{\"1\":{\"170\":1,\"273\":5}}],[\"循环更新\",{\"1\":{\"147\":1}}],[\"迭代次数设为iters\",{\"1\":{\"697\":1}}],[\"迭代式对齐研究计划的一部分\",{\"1\":{\"539\":1}}],[\"迭代器\",{\"1\":{\"401\":1}}],[\"迭代\",{\"1\":{\"170\":1}}],[\"计数法则\",{\"0\":{\"761\":1}}],[\"计数为\",{\"1\":{\"401\":1}}],[\"计数\",{\"1\":{\"169\":1}}],[\"计算该函数的梯度并进行平均\",{\"1\":{\"868\":1}}],[\"计算生成器损失\",{\"1\":{\"840\":1}}],[\"计算判别器损失\",{\"1\":{\"840\":1}}],[\"计算所有样本之间的相似度矩阵\",{\"1\":{\"822\":1}}],[\"计算每对\",{\"1\":{\"822\":1}}],[\"计算每个可能的阈值\",{\"1\":{\"450\":1}}],[\"计算每个样本的权重\",{\"1\":{\"403\":1}}],[\"计算每个注意力头的维度\",{\"1\":{\"322\":1}}],[\"计算每个query\",{\"1\":{\"310\":1}}],[\"计算每个码本向量的累加特征\",{\"1\":{\"170\":1}}],[\"计算每个向量与码本中所有向量的欧氏距离平方\",{\"1\":{\"170\":1}}],[\"计算每个\",{\"1\":{\"163\":1}}],[\"计算每个原始点和下采样点之间的距离\",{\"1\":{\"100\":1}}],[\"计算每个查询点\",{\"1\":{\"92\":1}}],[\"计算可学习温度值\",{\"1\":{\"822\":1}}],[\"计算边长\",{\"1\":{\"821\":1}}],[\"计算文本部分的\",{\"1\":{\"815\":1}}],[\"计算文本token和视觉token预测结果与原label的交叉熵损失\",{\"1\":{\"815\":1}}],[\"计算总\",{\"1\":{\"804\":1}}],[\"计算遮挡块区域内已被遮挡的patch数\",{\"1\":{\"801\":1}}],[\"计算本轮最多还能遮挡的patch数\",{\"1\":{\"801\":1}}],[\"计算重建损失\",{\"1\":{\"794\":1,\"821\":1}}],[\"计算与图构建同时进行\",{\"1\":{\"692\":1}}],[\"计算y\",{\"1\":{\"690\":1}}],[\"计算两个输入变量的乘积\",{\"1\":{\"690\":1}}],[\"计算过程不保留计算图连接\",{\"1\":{\"688\":1}}],[\"计算完成后中间变量立即释放\",{\"1\":{\"688\":1}}],[\"计算掩码语言损失\",{\"1\":{\"612\":1}}],[\"计算需要填充的长度\",{\"1\":{\"594\":1}}],[\"计算需求\",{\"0\":{\"184\":1}}],[\"计算起来是比较容易的\",{\"1\":{\"587\":1}}],[\"计算资源\",{\"1\":{\"571\":1,\"711\":1}}],[\"计算资源消耗仍然较大\",{\"1\":{\"280\":1}}],[\"计算最优平衡理论\",{\"1\":{\"552\":1}}],[\"计算最大半径\",{\"1\":{\"83\":1}}],[\"计算律发现\",{\"1\":{\"552\":1}}],[\"计算并缓存其\",{\"1\":{\"544\":1}}],[\"计算并集\",{\"1\":{\"469\":1}}],[\"计算交集\",{\"1\":{\"467\":1,\"468\":1,\"469\":1}}],[\"计算交叉熵损失\",{\"1\":{\"161\":1,\"186\":1,\"295\":1,\"311\":1,\"615\":1,\"803\":1}}],[\"计算得到的编码值\",{\"1\":{\"587\":1}}],[\"计算得到的\",{\"1\":{\"467\":1,\"469\":1,\"470\":1,\"471\":1,\"473\":1}}],[\"计算特征图的尺寸\",{\"1\":{\"463\":1}}],[\"计算特征图中每个点和点云每个点特征的相似度\",{\"1\":{\"59\":1}}],[\"计算输出特征图的尺寸\",{\"1\":{\"463\":1}}],[\"计算机的内存\",{\"1\":{\"421\":1}}],[\"计算公式为\",{\"1\":{\"799\":1}}],[\"计算公式\",{\"1\":{\"399\":1}}],[\"计算公式如下\",{\"1\":{\"321\":1,\"405\":1}}],[\"计算梯度\",{\"1\":{\"323\":1}}],[\"计算预测输出与真实标签之间的\",{\"1\":{\"468\":1,\"469\":1,\"470\":1}}],[\"计算预测结果与真实标签之间的交叉熵损失\",{\"1\":{\"323\":1}}],[\"计算预测正确的样本数\",{\"1\":{\"323\":1}}],[\"计算网格大小\",{\"1\":{\"318\":1}}],[\"计算上下文表示\",{\"1\":{\"312\":1}}],[\"计算注意力分数\",{\"1\":{\"312\":1}}],[\"计算序列长度\",{\"1\":{\"311\":1}}],[\"计算一个\",{\"1\":{\"310\":1}}],[\"计算这批图像嵌入向量中每一个图像嵌入向量和我们所有分类文本嵌入向量的余弦相似度\",{\"1\":{\"302\":1}}],[\"计算余弦相似度\",{\"1\":{\"300\":1}}],[\"计算缩放的余弦相似度\",{\"1\":{\"299\":1}}],[\"计算跨模态\",{\"1\":{\"277\":1}}],[\"计算跨视图交叉熵损失\",{\"1\":{\"186\":1}}],[\"计算跨视图的交叉熵损失\",{\"1\":{\"186\":1}}],[\"计算单模态\",{\"1\":{\"277\":1}}],[\"计算相对位置矩阵\",{\"1\":{\"591\":1}}],[\"计算相对位置偏置\",{\"1\":{\"277\":1,\"804\":1}}],[\"计算相似度\",{\"1\":{\"161\":1}}],[\"计算相似度矩阵\",{\"1\":{\"59\":1}}],[\"计算量略高于ce\",{\"1\":{\"470\":1}}],[\"计算量太大了\",{\"1\":{\"248\":1}}],[\"计算量大\",{\"1\":{\"103\":1}}],[\"计算代价太高\",{\"1\":{\"248\":1}}],[\"计算效率\",{\"1\":{\"173\":1}}],[\"计算效率问题\",{\"1\":{\"90\":1}}],[\"计算开销线性增长\",{\"1\":{\"544\":1}}],[\"计算开销\",{\"1\":{\"385\":1}}],[\"计算开销更大\",{\"1\":{\"173\":1}}],[\"计算开销大\",{\"1\":{\"150\":1}}],[\"计算平方距离并取负号\",{\"1\":{\"170\":1}}],[\"计算平均\",{\"1\":{\"82\":1}}],[\"计算样本与中心的距离\",{\"1\":{\"170\":1}}],[\"计算标准\",{\"1\":{\"163\":1}}],[\"计算来源\",{\"1\":{\"162\":1}}],[\"计算图进阶与通用神经网络实现\",{\"0\":{\"699\":1}}],[\"计算图遍历逻辑\",{\"1\":{\"696\":1}}],[\"计算图遍历优化\",{\"1\":{\"680\":1}}],[\"计算图中的中间变量\",{\"1\":{\"687\":1}}],[\"计算图的反向传播\",{\"0\":{\"657\":1}}],[\"计算图的意义\",{\"0\":{\"648\":1}}],[\"计算图用圆框表示变量\",{\"1\":{\"641\":1}}],[\"计算图与自动微分\",{\"1\":{\"633\":1}}],[\"计算图与自动微分的起点\",{\"0\":{\"633\":1}}],[\"计算图像部分的\",{\"1\":{\"815\":1}}],[\"计算图像块的数量\",{\"1\":{\"319\":1,\"320\":1,\"323\":1}}],[\"计算图像块的总数\",{\"1\":{\"318\":1}}],[\"计算图像嵌入向量列表中每个图像对应的嵌入向量和传入的分类文本嵌入向量的余弦相似度\",{\"1\":{\"302\":1}}],[\"计算图像到文本\",{\"1\":{\"278\":1}}],[\"计算图像能切分成多少个\",{\"1\":{\"272\":1}}],[\"计算图像\",{\"1\":{\"265\":1}}],[\"计算图\",{\"1\":{\"147\":1}}],[\"计算动量编码器输出\",{\"1\":{\"147\":1}}],[\"计算itm损失\",{\"1\":{\"145\":1}}],[\"计算itc损失\",{\"1\":{\"145\":1}}],[\"计算提示词token长度\",{\"1\":{\"142\":1}}],[\"计算语言建模损失\",{\"1\":{\"142\":1}}],[\"计算时引入\",{\"1\":{\"127\":1}}],[\"计算点集的分布特性\",{\"1\":{\"115\":1}}],[\"计算点云质心\",{\"1\":{\"83\":1}}],[\"计算点云中每个点和特征图中每个点特征的相似度\",{\"1\":{\"59\":1}}],[\"计算复杂度高\",{\"1\":{\"114\":1}}],[\"计算变换矩阵与其转置相乘后与单位矩阵之间的距离\",{\"1\":{\"108\":1}}],[\"计算权重\",{\"1\":{\"100\":1}}],[\"计算原始点与下采样点之间的距离矩阵\",{\"1\":{\"100\":1}}],[\"计算当前批次中所有序列的实际最大长度\",{\"1\":{\"596\":1}}],[\"计算当前位置和其他位置的特征相似度\",{\"1\":{\"463\":1}}],[\"计算当前中心点与所有点之间的欧氏距离平方\",{\"1\":{\"92\":1}}],[\"计算当前语言输入中有多少个有效\",{\"1\":{\"43\":1}}],[\"计算成本高\",{\"1\":{\"653\":1}}],[\"计算成本相当\",{\"1\":{\"565\":1}}],[\"计算成本\",{\"1\":{\"89\":1}}],[\"计算曲线下面积\",{\"1\":{\"82\":1}}],[\"计算指标包括\",{\"1\":{\"82\":1}}],[\"计算损失函数\",{\"1\":{\"885\":1}}],[\"计算损失的时候\",{\"1\":{\"572\":1}}],[\"计算损失的时候使用多分类\",{\"1\":{\"249\":1}}],[\"计算损失\",{\"1\":{\"81\":1}}],[\"计算负类\",{\"1\":{\"78\":1}}],[\"计算正类\",{\"1\":{\"78\":1}}],[\"计算保持稳定\",{\"1\":{\"78\":1}}],[\"计算经过下采样得到的特征图相比于原始图片的缩小比例\",{\"1\":{\"59\":1}}],[\"计算密集跨模态相似性矩阵\",{\"1\":{\"54\":1}}],[\"计算\",{\"1\":{\"40\":1,\"45\":2,\"82\":4,\"147\":1,\"162\":2,\"163\":2,\"186\":1,\"274\":1,\"276\":2,\"277\":1,\"278\":1,\"293\":1,\"295\":1,\"310\":1,\"321\":1,\"467\":2,\"468\":2,\"469\":1,\"470\":2,\"471\":1,\"473\":1,\"646\":1,\"758\":1,\"803\":1,\"804\":1}}],[\"稍后再通过\",{\"1\":{\"169\":1}}],[\"管理类\",{\"1\":{\"169\":1}}],[\"码本权重\",{\"1\":{\"170\":1}}],[\"码本中向量的数量\",{\"1\":{\"170\":1}}],[\"码本的向量个数\",{\"1\":{\"169\":1}}],[\"码本\",{\"0\":{\"169\":1},\"1\":{\"169\":1,\"170\":1}}],[\"查找\",{\"1\":{\"794\":1}}],[\"查找最近邻时对代码本嵌入进行\",{\"1\":{\"167\":1}}],[\"查表\",{\"1\":{\"591\":1,\"821\":1}}],[\"查表获取偏置\",{\"1\":{\"591\":1}}],[\"查表获取偏置值\",{\"1\":{\"591\":1}}],[\"查表得到\",{\"1\":{\"591\":2}}],[\"查表得到偏置\",{\"1\":{\"591\":1}}],[\"查表得到相对位置向量\",{\"1\":{\"590\":1}}],[\"查表后\",{\"1\":{\"590\":1}}],[\"查看当前环境已安装的包\",{\"0\":{\"437\":1},\"1\":{\"437\":1}}],[\"查看当前conda激活的环境\",{\"1\":{\"436\":1}}],[\"查看当前激活的环境\",{\"0\":{\"436\":1}}],[\"查看所有已创建的环境\",{\"0\":{\"434\":1}}],[\"查询\",{\"1\":{\"590\":2}}],[\"查询位置\",{\"1\":{\"590\":4}}],[\"查询一个未出现的元素时\",{\"1\":{\"401\":1}}],[\"查询向量\",{\"1\":{\"255\":1,\"410\":1}}],[\"查询点的位置\",{\"1\":{\"92\":1}}],[\"查询点数量\",{\"1\":{\"92\":1}}],[\"查询相比\",{\"1\":{\"90\":1}}],[\"梯度清零\",{\"1\":{\"803\":1}}],[\"梯度流\",{\"1\":{\"796\":1}}],[\"梯度表示函数输出值最大的方向\",{\"1\":{\"697\":1}}],[\"梯度下降法解决问题\",{\"1\":{\"697\":1}}],[\"梯度下降等场景中非常常用\",{\"1\":{\"393\":1}}],[\"梯度展示了各点上函数输出值增加最快的方向\",{\"1\":{\"697\":1}}],[\"梯度分别乘以1和\",{\"1\":{\"690\":1}}],[\"梯度取反\",{\"1\":{\"690\":1}}],[\"梯度重复累加\",{\"1\":{\"685\":1}}],[\"梯度重复累加的问题\",{\"0\":{\"685\":1}}],[\"梯度累加\",{\"1\":{\"680\":1}}],[\"梯度检验\",{\"0\":{\"676\":1}}],[\"梯度裁剪1\",{\"1\":{\"548\":1}}],[\"梯度消失\",{\"1\":{\"385\":2,\"418\":1}}],[\"梯度消失或爆炸\",{\"1\":{\"41\":1}}],[\"梯度从\",{\"1\":{\"167\":1}}],[\"展开\",{\"1\":{\"867\":1}}],[\"展现出了非常流畅和自然的表现\",{\"1\":{\"703\":1}}],[\"展现了强大的视觉能力和与llms的无缝集成潜力\",{\"1\":{\"188\":1}}],[\"展平后是\",{\"1\":{\"814\":1}}],[\"展平掩码为\",{\"1\":{\"803\":1}}],[\"展平空间维度\",{\"1\":{\"794\":1,\"798\":1}}],[\"展平为分类标签\",{\"1\":{\"848\":1}}],[\"展平为分类输入\",{\"1\":{\"848\":1}}],[\"展平为\",{\"1\":{\"276\":2,\"821\":1}}],[\"展平\",{\"1\":{\"272\":1,\"804\":1}}],[\"展平并调整维度\",{\"1\":{\"272\":1}}],[\"展平并线性映射得到\",{\"1\":{\"167\":1}}],[\"展平特征图\",{\"1\":{\"170\":1}}],[\"展示出卓越的性能\",{\"1\":{\"790\":1}}],[\"展示\",{\"1\":{\"538\":1,\"814\":1}}],[\"展示强大的数学\",{\"1\":{\"228\":1}}],[\"展示同类物体的结构相似性可辅助对齐\",{\"1\":{\"49\":1}}],[\"展示了当我们从更多的样本数量\",{\"1\":{\"811\":1}}],[\"展示了不同\",{\"1\":{\"781\":1}}],[\"展示了不同变体的实验结果\",{\"1\":{\"780\":1}}],[\"展示了我们方法的整体流程\",{\"1\":{\"772\":1}}],[\"展示了一些从如下高斯分布中采样的灰度图像\",{\"1\":{\"756\":1}}],[\"展示了三种不同协方差矩阵下的二维多元高斯密度图\",{\"1\":{\"752\":1}}],[\"展示了其强大的泛化能力\",{\"1\":{\"706\":1}}],[\"展示了其轻量化设计在效率与性能上的优势\",{\"1\":{\"280\":1}}],[\"展示了如何仅使用公开可用的数据集来训练最先进的模型\",{\"1\":{\"704\":1}}],[\"展示了模型输出的多维质量元数据对比\",{\"1\":{\"538\":1}}],[\"展示了模型在是否遵循指令\",{\"1\":{\"537\":1}}],[\"展示了强大的in\",{\"1\":{\"532\":1}}],[\"展示了强大的少样本和零样本学习能力\",{\"1\":{\"192\":1}}],[\"展示了自然语言本身作为任务描述符的有效性\",{\"1\":{\"524\":1}}],[\"展示了大规模语言模型在无监督多任务学习中的潜力\",{\"1\":{\"519\":1}}],[\"展示了良好的语言泛化能力\",{\"1\":{\"202\":1}}],[\"展示了网页原始文本\",{\"1\":{\"132\":1}}],[\"展示了在大规模视觉\",{\"1\":{\"124\":1}}],[\"展示了对关键模块的消融实验结果\",{\"1\":{\"24\":1}}],[\"展示了各\",{\"1\":{\"19\":1}}],[\"展示了各类别的分布情况\",{\"1\":{\"17\":1}}],[\"继续改进\",{\"1\":{\"843\":1}}],[\"继续上述例子\",{\"1\":{\"727\":1}}],[\"继续训练的效果不如重新训练\",{\"1\":{\"137\":1}}],[\"继承第一阶段权重\",{\"1\":{\"209\":1}}],[\"继承了经过第一阶段对比训练后得到的\",{\"1\":{\"199\":1}}],[\"继承了第一阶段中学习到的权重\",{\"1\":{\"199\":1}}],[\"继承了\",{\"1\":{\"167\":1}}],[\"低成本的\",{\"1\":{\"716\":1}}],[\"低延迟\",{\"1\":{\"704\":1}}],[\"低纬向量部分数值波动幅度很大\",{\"1\":{\"587\":1}}],[\"低维更多位置\",{\"1\":{\"587\":1}}],[\"低维向量部分\",{\"1\":{\"587\":1}}],[\"低维分量\",{\"1\":{\"587\":1}}],[\"低维度的编码值波动性很大\",{\"1\":{\"587\":1}}],[\"低于词对齐基线\",{\"1\":{\"522\":1}}],[\"低秩分解\",{\"1\":{\"490\":1}}],[\"低置信度\",{\"1\":{\"470\":1}}],[\"低\",{\"1\":{\"216\":1}}],[\"低效连接\",{\"1\":{\"189\":1}}],[\"低层图像元素\",{\"1\":{\"165\":1}}],[\"低密度区域则过于稀缺\",{\"1\":{\"89\":1}}],[\"官方代码链接\",{\"1\":{\"544\":1}}],[\"官方代码实现进行\",{\"1\":{\"544\":1}}],[\"官方代码实现\",{\"0\":{\"544\":1}}],[\"官方代码库并没有非常清晰指明capfilt模块的实现代码位置\",{\"1\":{\"140\":1}}],[\"官方仓库\",{\"1\":{\"438\":1}}],[\"官方实现的default\",{\"1\":{\"316\":1}}],[\"官方文档中的行为规范\",{\"1\":{\"163\":1}}],[\"≠\",{\"1\":{\"163\":1,\"539\":1}}],[\"蒸馏还能用于将软伪标签传播到无标签数据\",{\"1\":{\"176\":1}}],[\"蒸馏损失\",{\"1\":{\"163\":2}}],[\"蒸馏损失的权重\",{\"1\":{\"163\":1}}],[\"蒸馏\",{\"1\":{\"163\":2}}],[\"剩余部分为图像\",{\"1\":{\"272\":1}}],[\"剩余的图片都不是同一个类别\",{\"1\":{\"243\":1}}],[\"剩余的语言\",{\"1\":{\"43\":1}}],[\"剩下的是失败\",{\"1\":{\"741\":1}}],[\"剩下的\",{\"1\":{\"163\":1}}],[\"被归类为了自回归生成模型\",{\"1\":{\"847\":1}}],[\"被拆分成\",{\"1\":{\"846\":2}}],[\"被\",{\"1\":{\"800\":1,\"803\":1}}],[\"被视为输入\",{\"1\":{\"772\":1}}],[\"被视为提升模型通用性的潜在途径\",{\"1\":{\"520\":1}}],[\"被称为贝叶斯推理\",{\"1\":{\"758\":1}}],[\"被称为自由度\",{\"1\":{\"748\":1}}],[\"被认为是\",{\"1\":{\"708\":1}}],[\"被证明在使用指令形式化描述的未见过的任务上表现良好\",{\"1\":{\"706\":1}}],[\"被设置为多个输入变量中最大的generation的值\",{\"1\":{\"686\":1}}],[\"被用作两次输入\",{\"1\":{\"684\":1}}],[\"被用作图像的全局特征\",{\"1\":{\"126\":1}}],[\"被关注\",{\"1\":{\"590\":1}}],[\"被关注位置\",{\"1\":{\"590\":4}}],[\"被掩码后的输入序列\",{\"1\":{\"579\":1}}],[\"被分开\",{\"1\":{\"521\":1}}],[\"被背景淹没\",{\"1\":{\"470\":1}}],[\"被抽到的概率越高\",{\"1\":{\"403\":1}}],[\"被改变\",{\"1\":{\"360\":1}}],[\"被引用\",{\"1\":{\"340\":1}}],[\"被添加到\",{\"1\":{\"319\":1}}],[\"被修改\",{\"1\":{\"278\":1}}],[\"被划分为\",{\"1\":{\"263\":1}}],[\"被广泛应用于对比学习中\",{\"1\":{\"248\":1}}],[\"被输入到标准的\",{\"1\":{\"179\":1}}],[\"被替换为随机\",{\"1\":{\"163\":1}}],[\"被替换为\",{\"1\":{\"163\":1}}],[\"~null\",{\"1\":{\"815\":1}}],[\"~31k\",{\"1\":{\"537\":1}}],[\"~33k\",{\"1\":{\"537\":1}}],[\"~13k\",{\"1\":{\"537\":1}}],[\"~$\",{\"1\":{\"432\":1}}],[\"~\",{\"1\":{\"375\":1,\"439\":1,\"470\":2,\"591\":2,\"665\":1,\"696\":1,\"821\":1,\"857\":2}}],[\"~mask\",{\"1\":{\"272\":1}}],[\"~masked\",{\"1\":{\"163\":1}}],[\"~indices\",{\"1\":{\"163\":1}}],[\"~pred\",{\"1\":{\"83\":1}}],[\"克隆一份\",{\"1\":{\"163\":1}}],[\"固定p\",{\"1\":{\"762\":1}}],[\"固定为\",{\"1\":{\"186\":1}}],[\"固定\",{\"1\":{\"176\":1,\"590\":1,\"807\":1,\"820\":1,\"871\":1}}],[\"固定作为\",{\"1\":{\"162\":1}}],[\"固定返回问题0\",{\"1\":{\"68\":1}}],[\"共用逻辑\",{\"1\":{\"690\":1}}],[\"共用\",{\"1\":{\"591\":1}}],[\"共分为\",{\"1\":{\"575\":1}}],[\"共273个样例\",{\"1\":{\"522\":1}}],[\"共同支撑了零样本泛化能力\",{\"1\":{\"521\":1}}],[\"共指\",{\"1\":{\"515\":1}}],[\"共个值\",{\"1\":{\"407\":1}}],[\"共5个类别\",{\"1\":{\"316\":1}}],[\"共\",{\"1\":{\"198\":1,\"560\":1}}],[\"共有\",{\"1\":{\"162\":1}}],[\"共享的图像增强\",{\"1\":{\"802\":1}}],[\"共享的自注意力模块也对模型有积极贡献\",{\"1\":{\"268\":1}}],[\"共享变量与梯度累加\",{\"0\":{\"684\":1}}],[\"共享同一桶\",{\"1\":{\"591\":1}}],[\"共享权重\",{\"1\":{\"580\":1}}],[\"共享内存\",{\"1\":{\"361\":1}}],[\"共享自注意力模块能够帮助\",{\"1\":{\"268\":1}}],[\"共享自注意力\",{\"1\":{\"268\":1}}],[\"共享自注意力机制的消融实验\",{\"1\":{\"268\":1}}],[\"共享嵌入空间\",{\"1\":{\"160\":2}}],[\"共享除了\",{\"1\":{\"126\":1}}],[\"按下面这个公式求梯度\",{\"1\":{\"881\":1}}],[\"按值为\",{\"1\":{\"881\":1}}],[\"按任意顺序进行排列\",{\"1\":{\"762\":1}}],[\"按导数公式计算梯度\",{\"1\":{\"690\":1}}],[\"按序取出元素\",{\"1\":{\"686\":1}}],[\"按序执行以下命令完成环境搭建\",{\"1\":{\"593\":1}}],[\"按反向顺序调用各函数的backward方法\",{\"1\":{\"662\":1}}],[\"按头\",{\"1\":{\"591\":1}}],[\"按评分排序答案\",{\"1\":{\"548\":1}}],[\"按用户\",{\"1\":{\"537\":1}}],[\"按需要在w前面拼接一些参数\",{\"1\":{\"486\":1}}],[\"按空格切分\",{\"1\":{\"476\":1}}],[\"按类别分配\",{\"1\":{\"470\":1}}],[\"按元素大小\",{\"1\":{\"427\":1}}],[\"按转置顺序\",{\"1\":{\"426\":1}}],[\"按权重采样样本\",{\"1\":{\"403\":1}}],[\"按权重从当前行采样一个负样本索引\",{\"1\":{\"162\":1}}],[\"按出现次数依次返回元素\",{\"1\":{\"401\":1}}],[\"按列索引累加元素\",{\"1\":{\"379\":1}}],[\"按行分成2块\",{\"1\":{\"374\":1}}],[\"按比例随机采样验证样本\",{\"1\":{\"316\":1}}],[\"按key进行聚合\",{\"1\":{\"274\":1}}],[\"按指令做事\",{\"1\":{\"239\":1}}],[\"按迭代次数调整\",{\"1\":{\"186\":1}}],[\"按\",{\"1\":{\"163\":1,\"277\":1,\"337\":1,\"754\":1}}],[\"按照权重加权融合\",{\"1\":{\"815\":1}}],[\"按照权重做加权平均\",{\"1\":{\"100\":1}}],[\"按照选定方差归一化\",{\"1\":{\"802\":1}}],[\"按照选定均值归一化\",{\"1\":{\"802\":1}}],[\"按照本批次序列中最大长度进行截断\",{\"1\":{\"596\":1}}],[\"按照16x16大小的patch进行划分\",{\"1\":{\"318\":1}}],[\"按照余弦相似度的数学公式来计算两者的相似度数值\",{\"1\":{\"302\":1}}],[\"按照最大相似度\",{\"1\":{\"300\":1}}],[\"按照\",{\"1\":{\"186\":1,\"476\":1}}],[\"按照给定概率进行\",{\"1\":{\"163\":1}}],[\"按照几个预定义的半径值来搜索周围的邻近点\",{\"1\":{\"95\":1}}],[\"按照不同的搜索半径或领域大小对点集进行分组\",{\"1\":{\"95\":1}}],[\"按照相似度完成信息融合\",{\"1\":{\"59\":1}}],[\"按照key的插入顺序返回的\",{\"1\":{\"29\":1}}],[\"屏蔽中心行上中心右边的列\",{\"1\":{\"848\":1}}],[\"屏蔽中心行上中心及其右侧的列\",{\"1\":{\"848\":1}}],[\"屏蔽中心行以下所有行\",{\"1\":{\"848\":2}}],[\"屏蔽中心像素\",{\"1\":{\"848\":1}}],[\"屏蔽非法的预测位置\",{\"1\":{\"820\":1}}],[\"屏蔽不合法预测\",{\"1\":{\"815\":1}}],[\"屏蔽不可\",{\"1\":{\"163\":1}}],[\"屏蔽\",{\"1\":{\"814\":2}}],[\"屏蔽填充部分的信息\",{\"1\":{\"622\":1}}],[\"屏蔽对角线\",{\"1\":{\"162\":1}}],[\"屏蔽掉\",{\"1\":{\"142\":1}}],[\"判别器代码实现\",{\"1\":{\"840\":1}}],[\"判别器想最大化识别真假的概率\",{\"1\":{\"840\":1}}],[\"判别器给输入\",{\"1\":{\"840\":1}}],[\"判别器力求识别真假样本\",{\"1\":{\"840\":1}}],[\"判别器\",{\"1\":{\"840\":3}}],[\"判别性和稳定性\",{\"1\":{\"161\":1}}],[\"判定其是否语法正确\",{\"1\":{\"515\":1}}],[\"判断\",{\"1\":{\"681\":1}}],[\"判断哪些是短距离\",{\"1\":{\"591\":1}}],[\"判断下一个句子是否是当前句子的后续句子\",{\"1\":{\"580\":1}}],[\"判断第\",{\"1\":{\"571\":1}}],[\"判断两个句子是否连续\",{\"1\":{\"564\":1}}],[\"判断两个片段是否连续\",{\"1\":{\"560\":1}}],[\"判断它们之间的关系\",{\"1\":{\"515\":1}}],[\"判断每个字符对是否存在于频次表中\",{\"1\":{\"477\":1}}],[\"判断预测是否正确\",{\"1\":{\"302\":1}}],[\"判断是否为交叉注意力\",{\"1\":{\"312\":1}}],[\"判断是否为\",{\"1\":{\"293\":1}}],[\"判断是否匹配\",{\"1\":{\"128\":1}}],[\"判断当前遮挡块的有效新增遮挡数量\",{\"1\":{\"801\":1}}],[\"判断当前是训练阶段还是验证阶段\",{\"1\":{\"276\":1}}],[\"判断当前图文对与队列中哪些样本是正对\",{\"1\":{\"145\":1}}],[\"判断者\",{\"1\":{\"236\":1}}],[\"判断图文是否匹配\",{\"1\":{\"127\":1,\"145\":1}}],[\"判断模型是否能正确区分前景和背景\",{\"1\":{\"82\":1}}],[\"线性混合强化\",{\"1\":{\"816\":1}}],[\"线性映射为\",{\"1\":{\"822\":1}}],[\"线性映射\",{\"1\":{\"591\":1}}],[\"线性映射得到\",{\"1\":{\"272\":1}}],[\"线性上升更新\",{\"1\":{\"514\":1}}],[\"线性增长\",{\"1\":{\"385\":1}}],[\"线性组合\",{\"1\":{\"385\":2}}],[\"线性加权和\",{\"1\":{\"385\":2}}],[\"线性层生成\",{\"1\":{\"272\":1}}],[\"线性复杂度\",{\"1\":{\"260\":1}}],[\"线性探测\",{\"1\":{\"201\":1,\"213\":1}}],[\"线性投影到与\",{\"1\":{\"313\":1}}],[\"线性投影\",{\"1\":{\"193\":1}}],[\"线性缩放\",{\"1\":{\"186\":1}}],[\"线性评估指的是\",{\"1\":{\"245\":1}}],[\"线性评估\",{\"1\":{\"179\":1,\"245\":1}}],[\"线性升到\",{\"1\":{\"179\":1}}],[\"线性基准上达到\",{\"1\":{\"173\":1}}],[\"线性分类头使用\",{\"1\":{\"212\":1}}],[\"线性分类基准上\",{\"1\":{\"173\":1}}],[\"线性分类器训练或数据增强的情况下\",{\"1\":{\"173\":1}}],[\"线性变换\",{\"1\":{\"161\":1}}],[\"线性从\",{\"1\":{\"159\":1}}],[\"配对\",{\"1\":{\"590\":1}}],[\"配对编码器用于同步参数\",{\"1\":{\"145\":1}}],[\"配以自然语言任务说明进行微调\",{\"1\":{\"536\":1}}],[\"配置控制等\",{\"1\":{\"680\":1}}],[\"配置字典\",{\"1\":{\"274\":2}}],[\"配置\",{\"1\":{\"160\":1,\"273\":1,\"274\":1}}],[\"恒定为最大值\",{\"1\":{\"159\":1}}],[\"步里被随机遮盖或替换的部分\",{\"1\":{\"572\":1}}],[\"步进\",{\"1\":{\"427\":1}}],[\"步长解决的是如何将多维张量中的\",{\"1\":{\"423\":1}}],[\"步长\",{\"0\":{\"423\":1},\"1\":{\"423\":1,\"425\":2}}],[\"步距为16\",{\"1\":{\"318\":1}}],[\"步热身\",{\"1\":{\"209\":1}}],[\"步骤9\",{\"0\":{\"670\":1}}],[\"步骤8\",{\"0\":{\"666\":1}}],[\"步骤7\",{\"0\":{\"663\":1}}],[\"步骤6\",{\"0\":{\"658\":1}}],[\"步骤5\",{\"0\":{\"654\":1}}],[\"步骤4\",{\"0\":{\"649\":1}}],[\"步骤如下\",{\"1\":{\"463\":1}}],[\"步骤包括\",{\"1\":{\"272\":1}}],[\"步骤3\",{\"0\":{\"645\":1},\"1\":{\"232\":1}}],[\"步骤27\",{\"0\":{\"698\":1}}],[\"步骤26\",{\"0\":{\"697\":1}}],[\"步骤25\",{\"0\":{\"696\":1}}],[\"步骤24\",{\"0\":{\"692\":1}}],[\"步骤23\",{\"0\":{\"691\":1}}],[\"步骤20\",{\"0\":{\"690\":1}}],[\"步骤2\",{\"0\":{\"640\":1},\"1\":{\"232\":1}}],[\"步骤19\",{\"0\":{\"689\":1}}],[\"步骤18\",{\"0\":{\"688\":1}}],[\"步骤17\",{\"0\":{\"687\":1}}],[\"步骤16\",{\"0\":{\"686\":1}}],[\"步骤15\",{\"0\":{\"685\":1}}],[\"步骤14\",{\"0\":{\"684\":1}}],[\"步骤13\",{\"0\":{\"683\":1}}],[\"步骤12\",{\"0\":{\"682\":1}}],[\"步骤11\",{\"0\":{\"681\":1}}],[\"步骤10\",{\"0\":{\"674\":1}}],[\"步骤1\",{\"0\":{\"635\":1},\"1\":{\"232\":1}}],[\"步骤\",{\"1\":{\"186\":1,\"885\":5}}],[\"步\",{\"1\":{\"159\":1,\"208\":1,\"209\":1,\"560\":2}}],[\"监督学习微调\",{\"1\":{\"535\":1}}],[\"监督式微调sft\",{\"1\":{\"483\":1}}],[\"监督式预训练\",{\"1\":{\"173\":1}}],[\"监督微调\",{\"0\":{\"515\":1},\"1\":{\"198\":1,\"537\":1}}],[\"监督\",{\"1\":{\"163\":2,\"173\":1}}],[\"监督为主\",{\"1\":{\"159\":1}}],[\"监督信号不理想\",{\"1\":{\"120\":1}}],[\"α=0\",{\"1\":{\"471\":2}}],[\"α>β\",{\"1\":{\"471\":1}}],[\"α\",{\"1\":{\"159\":1,\"470\":4,\"471\":3,\"473\":6}}],[\"捕捉不同子空间的信息\",{\"1\":{\"622\":1}}],[\"捕捉文本中位置相关的语义和结构信息\",{\"1\":{\"588\":1}}],[\"捕捉全局信息\",{\"1\":{\"326\":1}}],[\"捕捉与图像内容相关的多种可能性\",{\"1\":{\"157\":1}}],[\"捕获模态特定信息\",{\"1\":{\"260\":1}}],[\"捕获密集到稀疏采样区域内的多尺度信息\",{\"1\":{\"96\":1}}],[\"散度是常量\",{\"1\":{\"881\":1}}],[\"散度的\",{\"1\":{\"872\":1}}],[\"散度的单位就是比特\",{\"1\":{\"872\":1}}],[\"散度的期望中\",{\"1\":{\"867\":1}}],[\"散度的定义开始\",{\"1\":{\"867\":1}}],[\"散度时\",{\"1\":{\"853\":1}}],[\"散度就是交叉熵\",{\"1\":{\"831\":1}}],[\"散度部分\",{\"1\":{\"821\":1}}],[\"散度约束后\",{\"1\":{\"800\":1}}],[\"散度损失的权重\",{\"1\":{\"821\":1}}],[\"散度损失\",{\"1\":{\"794\":1,\"798\":1}}],[\"散度正则项的权重\",{\"1\":{\"793\":1}}],[\"散度为常数\",{\"1\":{\"773\":1}}],[\"散度项不用算入损失函数里\",{\"1\":{\"881\":1}}],[\"散度项会鼓励\",{\"1\":{\"867\":1}}],[\"散度项让\",{\"1\":{\"857\":1}}],[\"散度项的损失权重\",{\"1\":{\"793\":1}}],[\"散度项\",{\"1\":{\"773\":1,\"854\":1,\"873\":1}}],[\"散度\",{\"1\":{\"157\":1,\"163\":1,\"798\":1,\"831\":1,\"867\":3,\"868\":1,\"869\":2,\"871\":1}}],[\"老师模型\",{\"1\":{\"157\":1}}],[\"起主导作用\",{\"1\":{\"468\":1}}],[\"起始偏移量\",{\"1\":{\"425\":1}}],[\"起始值\",{\"1\":{\"332\":1}}],[\"起到了\",{\"1\":{\"458\":1}}],[\"起到\",{\"1\":{\"157\":1}}],[\"起来\",{\"1\":{\"33\":1}}],[\"硬币正面概率的\",{\"1\":{\"826\":1}}],[\"硬采样但梯度可导\",{\"1\":{\"793\":1}}],[\"硬标签分配\",{\"1\":{\"176\":1}}],[\"硬标签混合\",{\"1\":{\"147\":1}}],[\"硬负样本采样策略\",{\"1\":{\"156\":1}}],[\"令离散编码\",{\"1\":{\"881\":1}}],[\"令模型的输入为整幅图像和序号\",{\"1\":{\"843\":1}}],[\"令模型忽略输入的条件\",{\"1\":{\"816\":1}}],[\"令\",{\"1\":{\"154\":1,\"873\":3}}],[\"启发了\",{\"1\":{\"788\":1}}],[\"启发式过滤低质量网页\",{\"1\":{\"548\":1}}],[\"启发\",{\"1\":{\"154\":1}}],[\"启用反向传播\",{\"1\":{\"688\":1}}],[\"启用采样\",{\"1\":{\"143\":1}}],[\"启用\",{\"1\":{\"127\":3}}],[\"受到\",{\"1\":{\"264\":1}}],[\"受ureader启发\",{\"1\":{\"224\":1}}],[\"受\",{\"1\":{\"154\":1,\"790\":1}}],[\"受限于瓶颈维度\",{\"1\":{\"112\":1}}],[\"虽对部分任务性能略有影响\",{\"1\":{\"564\":1}}],[\"虽在图文检索中效果出色\",{\"1\":{\"150\":1}}],[\"虽然在实际中这样的小\",{\"1\":{\"871\":1}}],[\"虽然在阅读理解等任务上接近监督基线\",{\"1\":{\"523\":1}}],[\"虽然反向传播可以应对带噪输入\",{\"1\":{\"868\":1}}],[\"虽然可以尝试用更好的相似性度量代替欧氏距离\",{\"1\":{\"866\":1}}],[\"虽然我们现在能把编码器和解码器拼接到一起\",{\"1\":{\"880\":1}}],[\"虽然我们只能看到最终生成的字符\",{\"1\":{\"865\":1}}],[\"虽然我们通过使用大模型来简化了业务逻辑的拆解\",{\"1\":{\"717\":1}}],[\"虽然理论上有\",{\"1\":{\"800\":1}}],[\"虽然密度在下降\",{\"1\":{\"754\":1}}],[\"虽然密度函数以\",{\"1\":{\"754\":1}}],[\"虽然你可能觉得\",{\"1\":{\"731\":1}}],[\"虽然大模型是深度学习领域的集大成之作\",{\"1\":{\"716\":1}}],[\"虽然大模型训练更快达到目标性能\",{\"1\":{\"547\":1}}],[\"虽然之前的聊天机器人存在各种问题\",{\"1\":{\"708\":1}}],[\"虽然python的垃圾回收\",{\"1\":{\"687\":1}}],[\"虽然位置和语义在所有维度上混合\",{\"1\":{\"587\":1}}],[\"虽然正弦余弦位置编码能够隐含地表达一定的局部位置信息\",{\"1\":{\"587\":1}}],[\"虽然早期实验显示性能略有下降\",{\"1\":{\"562\":1}}],[\"虽然也不完全正确\",{\"1\":{\"538\":1}}],[\"虽然具备强大的自然语言处理能力\",{\"1\":{\"535\":1}}],[\"虽然gpt\",{\"1\":{\"530\":1}}],[\"虽然深度减少了神经元数量\",{\"1\":{\"385\":1}}],[\"虽然没变\",{\"1\":{\"364\":1}}],[\"虽然推理时间快\",{\"1\":{\"286\":1}}],[\"虽然还不能执行复杂的推理任务\",{\"1\":{\"234\":1}}],[\"虽然规模大\",{\"1\":{\"122\":1}}],[\"虽然\",{\"1\":{\"112\":3,\"179\":1,\"385\":1,\"469\":1,\"866\":1}}],[\"虽然这些方法提升了生成效果\",{\"1\":{\"806\":1}}],[\"虽然这种方式需要花费时间和内存来完成拷贝\",{\"1\":{\"426\":1}}],[\"虽然这个点没有实际意义\",{\"1\":{\"92\":1}}],[\"虽然这里用的是\",{\"1\":{\"78\":1}}],[\"促进硬负样本挖掘\",{\"1\":{\"149\":1}}],[\"匹配或超过3\",{\"1\":{\"522\":1}}],[\"匹配更复杂的表示\",{\"1\":{\"175\":1}}],[\"匹配\",{\"1\":{\"162\":1,\"521\":1}}],[\"匹配or不匹配\",{\"1\":{\"147\":1}}],[\"匹配和生成等任务目标进行联合训练\",{\"1\":{\"129\":1}}],[\"队列大小\",{\"1\":{\"254\":1}}],[\"队列里的样本不需要进行梯度回传\",{\"1\":{\"245\":1}}],[\"队列\",{\"1\":{\"147\":2,\"366\":1}}],[\"队列指针\",{\"1\":{\"147\":1,\"254\":1}}],[\"队列用于\",{\"1\":{\"147\":1}}],[\"滑动平均更新\",{\"1\":{\"147\":1}}],[\"便得到了模态对齐好的图像编码器vit\",{\"1\":{\"146\":1}}],[\"便于通过梯度下降逐渐调整参数\",{\"1\":{\"865\":1}}],[\"便于采样\",{\"1\":{\"801\":1}}],[\"便于\",{\"1\":{\"796\":1}}],[\"便于识别变量类型\",{\"1\":{\"689\":1}}],[\"便于在训练和推理阶段灵活切换\",{\"1\":{\"688\":1}}],[\"便于直接调用\",{\"1\":{\"671\":1}}],[\"便于从\",{\"1\":{\"580\":1}}],[\"便于跨数据集评估\",{\"1\":{\"521\":1}}],[\"便于之后相似度计算\",{\"1\":{\"160\":1}}],[\"便于计算归一化相似度\",{\"1\":{\"147\":1}}],[\"便于计算相似度\",{\"1\":{\"59\":1}}],[\"便于广播到整个\",{\"1\":{\"108\":1}}],[\"便于广播\",{\"1\":{\"92\":1}}],[\"便于后续处理\",{\"1\":{\"107\":1}}],[\"便于后续计算\",{\"1\":{\"100\":1,\"467\":1,\"468\":1,\"471\":1,\"473\":1}}],[\"便于后续统一评估\",{\"1\":{\"82\":1}}],[\"便于后续\",{\"1\":{\"45\":1}}],[\"环境搭建遵从如下步骤即可\",{\"1\":{\"620\":1}}],[\"环境搭建\",{\"0\":{\"593\":1}}],[\"环境中的\",{\"1\":{\"438\":1}}],[\"环境中使用\",{\"1\":{\"438\":1}}],[\"环境再使用\",{\"1\":{\"438\":1}}],[\"环境\",{\"0\":{\"432\":1,\"620\":1},\"1\":{\"145\":1,\"232\":1,\"278\":1,\"433\":1,\"434\":1}}],[\"环境配置\",{\"0\":{\"38\":1}}],[\"束搜索\",{\"1\":{\"143\":1}}],[\"核采样参数\",{\"1\":{\"313\":1}}],[\"核采样时不扩展beam\",{\"1\":{\"313\":1}}],[\"核采样的概率阈值\",{\"1\":{\"313\":1}}],[\"核采样\",{\"1\":{\"143\":1}}],[\"核心价值\",{\"1\":{\"717\":1}}],[\"核心组件\",{\"0\":{\"713\":1},\"1\":{\"715\":1}}],[\"核心组件为\",{\"1\":{\"260\":1}}],[\"核心函数实现原理\",{\"1\":{\"696\":1}}],[\"核心功能\",{\"1\":{\"691\":1}}],[\"核心理解\",{\"1\":{\"591\":1}}],[\"核心原因在于层次化的函数构造方式比单层网络的线性组合更高效\",{\"1\":{\"385\":1}}],[\"核心原则\",{\"1\":{\"364\":1}}],[\"核心要点\",{\"1\":{\"318\":1}}],[\"核心计算\",{\"0\":{\"293\":1}}],[\"核心思想是通过两个神经网络之间的\",{\"1\":{\"840\":1}}],[\"核心思想\",{\"1\":{\"239\":1,\"470\":1,\"473\":1}}],[\"核心问题\",{\"1\":{\"112\":1}}],[\"核心\",{\"0\":{\"103\":1}}],[\"核心操作包括\",{\"1\":{\"98\":1}}],[\"核心挑战\",{\"1\":{\"49\":1}}],[\"核心代码实现如下\",{\"1\":{\"28\":1,\"580\":1,\"802\":1}}],[\"份\",{\"1\":{\"143\":1}}],[\"索引分布\",{\"1\":{\"886\":1}}],[\"索引列表\",{\"1\":{\"886\":2}}],[\"索引矩阵\",{\"1\":{\"885\":1}}],[\"索引映射到内存中的地址\",{\"1\":{\"423\":1}}],[\"索引出错\",{\"1\":{\"276\":1}}],[\"索引\",{\"1\":{\"186\":1,\"578\":1,\"794\":1,\"796\":1,\"821\":3,\"886\":3}}],[\"索引编号\",{\"1\":{\"142\":1}}],[\"索引保存下来\",{\"1\":{\"92\":1}}],[\"清华大学和智谱\",{\"1\":{\"704\":1}}],[\"清晰了预训练模型的作用\",{\"1\":{\"707\":1}}],[\"清晰\",{\"1\":{\"695\":1}}],[\"清除中间变量的导数\",{\"1\":{\"688\":1}}],[\"清除旧梯度\",{\"1\":{\"142\":1}}],[\"清洗原始\",{\"1\":{\"514\":1}}],[\"清洗\",{\"1\":{\"6\":1}}],[\"剔除\",{\"1\":{\"134\":1}}],[\"剔除原始和生成的低质量描述\",{\"1\":{\"120\":1}}],[\"阶段二\",{\"0\":{\"809\":1},\"1\":{\"807\":1}}],[\"阶段一\",{\"0\":{\"808\":1},\"1\":{\"807\":1}}],[\"阶段只需\",{\"1\":{\"539\":1}}],[\"阶段式预训练能够缓解对大量图文对数据的依赖\",{\"1\":{\"268\":1}}],[\"阶段式预训练能够有效利用大规模图像语料与文本语料\",{\"1\":{\"268\":1}}],[\"阶段式预训练\",{\"1\":{\"268\":1}}],[\"阶段\",{\"1\":{\"134\":1,\"807\":2}}],[\"确实存在一个正则化参数\",{\"1\":{\"873\":1}}],[\"确实像openai的gpt4这样的llm已经非常强了\",{\"1\":{\"497\":1}}],[\"确立自回归范式\",{\"1\":{\"552\":1}}],[\"确信\",{\"1\":{\"538\":1}}],[\"确认你使用的是\",{\"1\":{\"438\":1}}],[\"确认偏差\",{\"1\":{\"134\":1}}],[\"确定事件\",{\"1\":{\"829\":1}}],[\"确定目标\",{\"1\":{\"717\":1}}],[\"确定缩放因子\",{\"1\":{\"322\":1}}],[\"确定是否使用\",{\"1\":{\"276\":1}}],[\"确定性搜索\",{\"1\":{\"133\":1}}],[\"确保方差\",{\"1\":{\"853\":1}}],[\"确保模型每个像素的输出\",{\"1\":{\"848\":1}}],[\"确保在生成文本的阶段\",{\"1\":{\"820\":1}}],[\"确保在单台机器上\",{\"1\":{\"577\":1}}],[\"确保至少选一个\",{\"1\":{\"818\":1}}],[\"确保一致性\",{\"1\":{\"817\":1}}],[\"确保图像尺寸正确\",{\"1\":{\"815\":1}}],[\"确保图像尺寸能被\",{\"1\":{\"463\":1}}],[\"确保遮挡块不会越界\",{\"1\":{\"801\":1}}],[\"确保遮挡块可放入图像范围内\",{\"1\":{\"801\":1}}],[\"确保它们在部署前达到预期的性能和稳定性标准\",{\"1\":{\"715\":1}}],[\"确保它们加起来是1\",{\"1\":{\"100\":1}}],[\"确保所有利用\",{\"1\":{\"714\":1}}],[\"确保开发者能够在升级过程中无缝过渡\",{\"1\":{\"714\":1}}],[\"确保信息的持续更新和准确性\",{\"1\":{\"709\":1}}],[\"确保输出内容的精确性和可信度\",{\"1\":{\"709\":1}}],[\"确保复杂计算图反向传播顺序正确\",{\"1\":{\"693\":1}}],[\"确保类型转换优先\",{\"1\":{\"690\":1}}],[\"确保运算正常进行\",{\"1\":{\"690\":1}}],[\"确保代码质量\",{\"1\":{\"678\":1}}],[\"确保代码功能正确性\",{\"1\":{\"677\":1}}],[\"确保variable只接受ndarray实例\",{\"1\":{\"673\":1}}],[\"确保映射是一一对应的\",{\"1\":{\"578\":1}}],[\"确保句子数为偶数\",{\"1\":{\"577\":1}}],[\"确保内容经过人工筛选\",{\"1\":{\"521\":1}}],[\"确保可以整除\",{\"1\":{\"463\":1}}],[\"确保卷积操作不会重叠\",{\"1\":{\"318\":1}}],[\"确保\",{\"1\":{\"274\":1,\"714\":1,\"871\":1}}],[\"确保右边编码器更新得非常缓慢\",{\"1\":{\"246\":1}}],[\"确保视觉编码器与llms的特征空间一致\",{\"1\":{\"189\":1}}],[\"确保每个\",{\"1\":{\"76\":1}}],[\"确保推理一致性\",{\"1\":{\"66\":1}}],[\"合适的\",{\"1\":{\"790\":1}}],[\"合理输出的空间是多模态的\",{\"1\":{\"874\":1}}],[\"合理的样本\",{\"1\":{\"869\":1}}],[\"合理的内存管理至关重要\",{\"1\":{\"687\":1}}],[\"合理事件空间\",{\"1\":{\"728\":1}}],[\"合计40\",{\"1\":{\"528\":1}}],[\"合成文本的多样性对性能的影响\",{\"0\":{\"133\":1}}],[\"合并后\",{\"1\":{\"815\":1}}],[\"合并头结果\",{\"1\":{\"605\":1}}],[\"合并并归一化\",{\"1\":{\"590\":1}}],[\"合并的\",{\"1\":{\"514\":1}}],[\"合并参数\",{\"1\":{\"490\":1}}],[\"合并该字符对\",{\"1\":{\"477\":1}}],[\"合并当前最高频的字符对\",{\"1\":{\"476\":3}}],[\"合并前n个最频繁的字符对\",{\"1\":{\"476\":1}}],[\"合并正负样本特征\",{\"1\":{\"278\":1}}],[\"合并正负样本对\",{\"1\":{\"147\":1}}],[\"合并收集的\",{\"1\":{\"278\":1}}],[\"合并各个子数据集\",{\"1\":{\"274\":1}}],[\"合并回一个序列\",{\"1\":{\"272\":1}}],[\"合并\",{\"1\":{\"78\":1,\"490\":1}}],[\"性价比最高\",{\"1\":{\"704\":1}}],[\"性价比高\",{\"1\":{\"704\":1}}],[\"性别化代词\",{\"1\":{\"551\":1}}],[\"性别偏见\",{\"1\":{\"536\":1}}],[\"性质的函数是指像sigmoid函数的有界函数\",{\"1\":{\"385\":1}}],[\"性质的激活函数的隐藏层组成的前馈神经网络\",{\"1\":{\"385\":1}}],[\"性能也有所下降\",{\"1\":{\"780\":1}}],[\"性能得到进一步提升\",{\"1\":{\"704\":1}}],[\"性能对标\",{\"1\":{\"704\":1}}],[\"性能强\",{\"1\":{\"704\":1}}],[\"性能强大\",{\"1\":{\"704\":1}}],[\"性能最强\",{\"1\":{\"704\":1}}],[\"性能最佳\",{\"1\":{\"528\":1}}],[\"性能有了进一步提升\",{\"1\":{\"704\":1}}],[\"性能开销较高\",{\"1\":{\"687\":1}}],[\"性能略优于full\",{\"1\":{\"562\":1}}],[\"性能优于原始bert\",{\"1\":{\"562\":1}}],[\"性能下降\",{\"1\":{\"562\":1}}],[\"性能仍优于gpt\",{\"1\":{\"549\":1}}],[\"性能好\",{\"1\":{\"539\":1}}],[\"性能提升非源于记忆\",{\"1\":{\"522\":1}}],[\"性能测试\",{\"1\":{\"342\":1,\"353\":1}}],[\"性能不够高\",{\"1\":{\"286\":1}}],[\"性能验证与社会责任\",{\"1\":{\"547\":1}}],[\"性能验证\",{\"1\":{\"216\":1}}],[\"性能逐步提升\",{\"1\":{\"181\":1}}],[\"性能表现\",{\"1\":{\"173\":1}}],[\"性能\",{\"1\":{\"138\":1,\"307\":1,\"522\":1,\"538\":2,\"549\":1}}],[\"性能反而下降\",{\"1\":{\"134\":1}}],[\"性能次优\",{\"1\":{\"134\":1}}],[\"性\",{\"1\":{\"132\":1}}],[\"移至每个子模块的输入\",{\"1\":{\"521\":1}}],[\"移除nsp任务\",{\"1\":{\"564\":1,\"569\":1}}],[\"移除\",{\"1\":{\"560\":1}}],[\"移除下一句预测\",{\"1\":{\"558\":1,\"559\":1}}],[\"移除宏定义和参考文献\",{\"1\":{\"548\":1}}],[\"移除了大量与本文无关的逻辑\",{\"1\":{\"544\":1}}],[\"移除提示后性能下降6\",{\"1\":{\"522\":1}}],[\"移除最后一个\",{\"1\":{\"143\":1}}],[\"移除无效数据的有效\",{\"1\":{\"132\":1}}],[\"移动\",{\"1\":{\"49\":1,\"116\":1}}],[\"且对应的\",{\"1\":{\"871\":1}}],[\"且对多功能的相似结构易产生混淆\",{\"1\":{\"49\":1}}],[\"且满足对称性\",{\"1\":{\"834\":1}}],[\"且当\",{\"1\":{\"831\":1}}],[\"且独立同分布\",{\"1\":{\"826\":1}}],[\"且非空\",{\"1\":{\"815\":1}}],[\"且文本词空间和图像离散视觉词空间也通过视觉词索引偏移的方式完成了统一\",{\"1\":{\"814\":1}}],[\"且通过自然语言实现控制\",{\"1\":{\"806\":1}}],[\"且容易聚焦低级细节而非语义结构\",{\"1\":{\"785\":1}}],[\"且能加速微调收敛\",{\"1\":{\"765\":1}}],[\"且第\",{\"1\":{\"741\":1}}],[\"且\",{\"1\":{\"728\":1,\"730\":1,\"732\":1,\"745\":1}}],[\"且必须按顺序处理内容\",{\"1\":{\"709\":1}}],[\"且效率较低\",{\"1\":{\"667\":1}}],[\"且更高效\",{\"1\":{\"562\":1}}],[\"且偏好有偏\",{\"1\":{\"539\":1}}],[\"且在公开nlp任务上的性能损失极小\",{\"1\":{\"534\":1}}],[\"且在更具挑战性的winogrande数据集上few\",{\"1\":{\"529\":1}}],[\"且在大多数实验中表现稳定\",{\"1\":{\"179\":1}}],[\"且每个任务都需新数据\",{\"1\":{\"528\":1}}],[\"且预留给\",{\"1\":{\"491\":1}}],[\"且真实也为正类的样本数\",{\"1\":{\"471\":1}}],[\"且训练难度增加\",{\"1\":{\"385\":1}}],[\"且高次项易导致震荡\",{\"1\":{\"385\":1}}],[\"且具备数据量和模型规模的可扩展性\",{\"1\":{\"132\":1}}],[\"人们更关心的是能否基于已有数据库\",{\"1\":{\"864\":1}}],[\"人是否患病\",{\"1\":{\"731\":1}}],[\"人群中\",{\"1\":{\"731\":1}}],[\"人力\",{\"1\":{\"571\":1}}],[\"人\",{\"1\":{\"455\":1}}],[\"人体关键点检测上都超越了有监督的预训练模型\",{\"1\":{\"241\":1}}],[\"人工标注\",{\"1\":{\"131\":1}}],[\"人类普遍价值\",{\"1\":{\"539\":1}}],[\"人类偏好引导型\",{\"1\":{\"539\":1}}],[\"人类代表\",{\"1\":{\"539\":1}}],[\"人类评估显示\",{\"1\":{\"806\":1}}],[\"人类评估\",{\"1\":{\"538\":1}}],[\"人类评估者显著偏好\",{\"1\":{\"538\":1}}],[\"人类评估输出的偏好\",{\"1\":{\"537\":1}}],[\"人类数据采集\",{\"1\":{\"537\":1}}],[\"人类价值对齐\",{\"1\":{\"539\":1}}],[\"人类价值\",{\"1\":{\"535\":1}}],[\"人类反馈微调是一种有效的模型对齐手段\",{\"1\":{\"534\":1}}],[\"人类反馈强化学习\",{\"1\":{\"232\":1}}],[\"人类可通过少量示例或自然语言指令快速适应新任务\",{\"1\":{\"527\":1}}],[\"人类仅需少量示例或简单指令即可完成新任务\",{\"1\":{\"527\":1}}],[\"人类通过同时分析物体的\",{\"1\":{\"32\":1}}],[\"人类通过多步推理和类比思维解决复杂任务\",{\"1\":{\"6\":1}}],[\"人类交互文本\",{\"1\":{\"29\":1}}],[\"人类交互文本数据文件路径\",{\"1\":{\"29\":1}}],[\"人类会\",{\"1\":{\"6\":1}}],[\"人类认知启发\",{\"1\":{\"6\":1}}],[\"遵循chung\",{\"1\":{\"550\":1}}],[\"遵循\",{\"1\":{\"263\":1}}],[\"遵循视觉\",{\"1\":{\"263\":1}}],[\"遵循常规做法\",{\"1\":{\"212\":1}}],[\"遵循您的格式规范\",{\"1\":{\"129\":1}}],[\"遵循一个\",{\"1\":{\"71\":1}}],[\"机器\",{\"1\":{\"872\":1}}],[\"机器上进行分布式训练\",{\"1\":{\"561\":1}}],[\"机器翻译实战\",{\"1\":{\"619\":1}}],[\"机器翻译\",{\"1\":{\"536\":1,\"568\":1}}],[\"机器人操作应用\",{\"1\":{\"51\":1}}],[\"机器人操作等任务中表现优异\",{\"1\":{\"7\":1}}],[\"机翻\",{\"1\":{\"507\":1}}],[\"机制的生成模型\",{\"1\":{\"887\":1}}],[\"机制可以处理循环引用对象\",{\"1\":{\"687\":1}}],[\"机制确保函数调用顺序的正确执行\",{\"1\":{\"686\":1}}],[\"机制\",{\"0\":{\"686\":1},\"1\":{\"531\":1,\"693\":1,\"787\":1}}],[\"机制生成新的视图\",{\"1\":{\"364\":1}}],[\"机制让每个\",{\"1\":{\"179\":1}}],[\"机制处理量化不可导问题\",{\"1\":{\"167\":1}}],[\"机制与重新初始化更契合\",{\"1\":{\"137\":1}}],[\"机制有效从网页图文对中挖掘高质量样本\",{\"1\":{\"129\":1}}],[\"统一词空间大小为9\",{\"1\":{\"814\":1}}],[\"统一转换为variable\",{\"1\":{\"690\":1}}],[\"统一处理逻辑\",{\"1\":{\"681\":1}}],[\"统一文本到文本框架\",{\"1\":{\"552\":1}}],[\"统一\",{\"1\":{\"395\":1}}],[\"统一接口\",{\"1\":{\"395\":1}}],[\"统一变为相同尺寸\",{\"1\":{\"386\":1}}],[\"统一多模态的可能性\",{\"1\":{\"328\":1}}],[\"统一形式的\",{\"1\":{\"272\":1}}],[\"统一训练框架的有效性\",{\"1\":{\"268\":1}}],[\"统一的预训练通过以下任务优化共享的\",{\"1\":{\"262\":1}}],[\"统一的多任务架构\",{\"1\":{\"129\":1}}],[\"统一预训练\",{\"1\":{\"261\":1}}],[\"统一视觉预训练框架\",{\"1\":{\"790\":1}}],[\"统一视觉\",{\"1\":{\"260\":1}}],[\"统一建模与数据增强的多模态预训练方法\",{\"1\":{\"129\":1}}],[\"统计冻结等\",{\"1\":{\"817\":1}}],[\"统计距离\",{\"1\":{\"460\":1}}],[\"统计函数运行时间\",{\"1\":{\"353\":1}}],[\"统计正确率\",{\"1\":{\"302\":1}}],[\"统计每个相邻字符对的出现次数\",{\"1\":{\"476\":1}}],[\"统计每个名词短语出现的频率\",{\"1\":{\"234\":1}}],[\"统计每个簇的样本数量\",{\"1\":{\"170\":2}}],[\"统计簇信息\",{\"1\":{\"170\":1}}],[\"统计量\",{\"1\":{\"115\":1}}],[\"统计分析\",{\"0\":{\"19\":1}}],[\"头部调优\",{\"1\":{\"213\":1}}],[\"头部处理\",{\"1\":{\"101\":1}}],[\"头维度和mlp比例\",{\"1\":{\"197\":1}}],[\"头数\",{\"1\":{\"196\":1,\"272\":1,\"814\":1,\"822\":2}}],[\"头\",{\"1\":{\"162\":1,\"186\":1}}],[\"头预测为不匹配\",{\"1\":{\"128\":1}}],[\"若对多个\",{\"1\":{\"868\":1}}],[\"若我们对该公式求梯度\",{\"1\":{\"868\":1}}],[\"若各观测独立\",{\"1\":{\"826\":1}}],[\"若10次抛硬币出现6次正面\",{\"1\":{\"825\":1}}],[\"若仅需要\",{\"1\":{\"821\":1}}],[\"若仅获取\",{\"1\":{\"794\":1}}],[\"若不除以\",{\"1\":{\"815\":1}}],[\"若不使用运算符\",{\"1\":{\"692\":1}}],[\"若直接使用像素作为图像\",{\"1\":{\"807\":1}}],[\"若是自定义\",{\"1\":{\"802\":1}}],[\"若集合\",{\"1\":{\"731\":1}}],[\"若在某个事件\",{\"1\":{\"730\":1}}],[\"若满足以下条件\",{\"1\":{\"730\":1}}],[\"若干业务\",{\"1\":{\"716\":1}}],[\"若干局部视角图像\",{\"1\":{\"186\":1}}],[\"若再增加迭代次数到\",{\"1\":{\"697\":1}}],[\"若从好的起点开始\",{\"1\":{\"697\":1}}],[\"若画出其\",{\"1\":{\"697\":1}}],[\"若显示版本信息\",{\"1\":{\"696\":1}}],[\"若左操作数a不支持\",{\"1\":{\"690\":1}}],[\"若a未实现\",{\"1\":{\"690\":1}}],[\"若y\",{\"1\":{\"690\":1}}],[\"若为false\",{\"1\":{\"688\":1}}],[\"若为none则使用默认值\",{\"1\":{\"322\":1}}],[\"若使用强引用\",{\"1\":{\"687\":1}}],[\"若存在循环引用\",{\"1\":{\"687\":1}}],[\"若由\",{\"1\":{\"655\":1}}],[\"若拒绝机制不足\",{\"1\":{\"539\":1}}],[\"若未经适当调节可能导致某些群体观点被系统性排除\",{\"1\":{\"539\":1}}],[\"若未指定掩码位置\",{\"1\":{\"163\":1}}],[\"若刻意要求生成毒性内容\",{\"1\":{\"538\":1}}],[\"若前景点稀疏\",{\"1\":{\"470\":1}}],[\"若需固定切分可用\",{\"1\":{\"398\":1}}],[\"若都为\",{\"1\":{\"398\":1}}],[\"若希望确保内存效率\",{\"1\":{\"362\":1}}],[\"若qk\",{\"1\":{\"322\":1}}],[\"若有query\",{\"1\":{\"311\":1}}],[\"若以文本单词数量来衡量\",{\"1\":{\"299\":1}}],[\"若想要得到比较好的效果\",{\"1\":{\"246\":1}}],[\"若某簇为空\",{\"1\":{\"170\":1}}],[\"若已初始化\",{\"1\":{\"169\":1}}],[\"若选择\",{\"1\":{\"169\":1}}],[\"若提供了\",{\"1\":{\"817\":1}}],[\"若提供\",{\"1\":{\"163\":1,\"169\":1}}],[\"若只需输出\",{\"1\":{\"163\":1}}],[\"若图文语义相近但细节不同\",{\"1\":{\"156\":1}}],[\"若\",{\"1\":{\"128\":1,\"183\":1,\"473\":2,\"728\":2,\"730\":1,\"739\":1,\"801\":1,\"826\":1,\"866\":1}}],[\"若缺失\",{\"1\":{\"24\":1}}],[\"噪声后取\",{\"1\":{\"819\":1}}],[\"噪声对比估计\",{\"1\":{\"175\":1}}],[\"噪声\",{\"1\":{\"163\":1,\"274\":1,\"795\":1,\"809\":1,\"819\":1}}],[\"噪声比例仅\",{\"1\":{\"134\":1}}],[\"噪声比例稍高\",{\"1\":{\"133\":1}}],[\"噪声比例较低\",{\"1\":{\"133\":1}}],[\"噪声严重\",{\"1\":{\"128\":1}}],[\"噪声仍广泛存在\",{\"1\":{\"122\":1}}],[\"本模型之所以具备可计算性\",{\"1\":{\"871\":1}}],[\"本研究训练了一个参数量为\",{\"1\":{\"806\":1}}],[\"本研究为\",{\"1\":{\"790\":1}}],[\"本研究指出\",{\"1\":{\"534\":1}}],[\"本地文件访问时内存管理升级\",{\"1\":{\"704\":1}}],[\"本地批次\",{\"1\":{\"145\":1}}],[\"本阶段的目标是打造一个\",{\"1\":{\"700\":1}}],[\"本步骤使用tinypytorch实现了梯度下降法\",{\"1\":{\"697\":1}}],[\"本步骤的目标是找到使rosenbrock函数输出值最小的和\",{\"1\":{\"697\":1}}],[\"本步骤将处理rosenbrock函数\",{\"1\":{\"697\":1}}],[\"本步骤选取3个经典测试函数\",{\"1\":{\"692\":1}}],[\"本系列文章试图揭开这些机制背后的本质\",{\"1\":{\"680\":1}}],[\"本系列将带领读者从零开始创建一个深度学习框架\",{\"1\":{\"634\":1}}],[\"本部分感兴趣的可以回顾高数中微分定义部分内容\",{\"1\":{\"651\":1}}],[\"本部分图片来源\",{\"1\":{\"428\":1}}],[\"本节开始为扩展阅读内容\",{\"1\":{\"821\":1}}],[\"本节最开始给出的前向传播流程图已经清晰展示了\",{\"1\":{\"815\":1}}],[\"本节讨论的是定义在\",{\"1\":{\"736\":1}}],[\"本节代码\",{\"1\":{\"633\":1,\"679\":1,\"694\":1,\"699\":1}}],[\"本节将详细讨论高斯分布\",{\"1\":{\"750\":1}}],[\"本节将会对bert模型实现的部分细节进行说明\",{\"1\":{\"583\":1}}],[\"本节将根据\",{\"1\":{\"544\":1}}],[\"本节我们会针对\",{\"1\":{\"793\":1}}],[\"本节我们将基于clip预训练模型实现zero\",{\"1\":{\"302\":1}}],[\"本节我们将对多模态bert的前向传播基本流程进行讲解\",{\"1\":{\"288\":1}}],[\"本节我们将一点点完成该类代码的拆解\",{\"1\":{\"272\":1}}],[\"本节我们先来详细解析一下它的实现逻辑\",{\"1\":{\"170\":1}}],[\"本类中不直接使用\",{\"1\":{\"471\":1}}],[\"本身\",{\"1\":{\"349\":1,\"728\":1}}],[\"本身接受参数\",{\"1\":{\"345\":1}}],[\"本次训练是基于预训练好的vit\",{\"1\":{\"327\":1}}],[\"本质上是一种\",{\"1\":{\"816\":1}}],[\"本质上是一个\",{\"1\":{\"704\":1}}],[\"本质上是一个线性\",{\"1\":{\"421\":1}}],[\"本质上就是\",{\"1\":{\"807\":1}}],[\"本质上\",{\"1\":{\"481\":1,\"497\":1}}],[\"本质\",{\"1\":{\"349\":1}}],[\"本质是一个\",{\"1\":{\"342\":1}}],[\"本质是一个二分类任务\",{\"1\":{\"127\":1}}],[\"本质就是一个交叉熵损失函数\",{\"1\":{\"248\":1}}],[\"本文转载至\",{\"1\":{\"887\":1}}],[\"本文将使用\",{\"1\":{\"850\":1}}],[\"本文将通过一个花卉分类的实战案例结合vit原论文\",{\"1\":{\"315\":1}}],[\"本文摘录至\",{\"1\":{\"849\":1}}],[\"本文只涉及原始\",{\"1\":{\"843\":1}}],[\"本文的transformer使用了self\",{\"1\":{\"621\":1}}],[\"本文的核心假设是\",{\"1\":{\"520\":1}}],[\"本文使用的是谷歌的中文预训练模型\",{\"1\":{\"593\":1}}],[\"本文使用的是训练了9个epoch后的模型权重进行的推理演示\",{\"1\":{\"83\":1}}],[\"本文所展示的bert预训练属于教学级别的\",{\"1\":{\"582\":1}}],[\"本文不再全部copy展示\",{\"1\":{\"580\":1}}],[\"本文中的\",{\"1\":{\"580\":1}}],[\"本文引入了一种有效的对齐方法\",{\"1\":{\"535\":1}}],[\"本文提出了一种对齐语言模型与用户意图的策略\",{\"1\":{\"535\":1}}],[\"本文提出的方法在效率上大大提升且表现出相似的性能\",{\"1\":{\"286\":1}}],[\"本文提出的\",{\"1\":{\"220\":1}}],[\"本文通过gpt\",{\"1\":{\"524\":1}}],[\"本文采用字节级\",{\"1\":{\"521\":1}}],[\"本文进一步假设\",{\"1\":{\"521\":1}}],[\"本文基于\",{\"1\":{\"463\":1,\"620\":1}}],[\"本文改编bert代码讲解基于blip项目展开\",{\"1\":{\"287\":1}}],[\"本文常用\",{\"1\":{\"179\":1}}],[\"本文创新\",{\"1\":{\"52\":1}}],[\"本文创新点\",{\"1\":{\"49\":1}}],[\"本文区别\",{\"1\":{\"51\":1}}],[\"本文构建了\",{\"1\":{\"16\":1}}],[\"采取的策略是\",{\"1\":{\"866\":1}}],[\"采用标准的\",{\"1\":{\"771\":1}}],[\"采用单任务微调\",{\"1\":{\"561\":1}}],[\"采用rmsnorm对子层输入归一化\",{\"1\":{\"548\":1}}],[\"采用kv\",{\"1\":{\"544\":1}}],[\"采用proximal\",{\"1\":{\"535\":1}}],[\"采用模型层间和矩阵级别的并行方式进行\",{\"1\":{\"528\":1}}],[\"采用了预训练和微调的学习方法\",{\"1\":{\"705\":1}}],[\"采用了\",{\"1\":{\"704\":1}}],[\"采用了更科学的数据配比\",{\"1\":{\"704\":1}}],[\"采用了一种更巧妙的解决思路\",{\"1\":{\"318\":1}}],[\"采用了阶段式预训练策略\",{\"1\":{\"269\":1}}],[\"采用无卷积的浅层线性投影直接将图像块\",{\"1\":{\"280\":1}}],[\"采用无检测器的图像编码器和文本编码器独立编码\",{\"1\":{\"149\":1}}],[\"采用共享的\",{\"1\":{\"261\":1}}],[\"采用掩码语言建模方法\",{\"1\":{\"260\":1}}],[\"采用三种联合预训练任务\",{\"1\":{\"260\":1}}],[\"采用经典的\",{\"1\":{\"222\":1}}],[\"采用线性增长\",{\"1\":{\"186\":1}}],[\"采用多视角图像输入\",{\"1\":{\"186\":1}}],[\"采用加权随机采样而非直接取相似度最大的负样本\",{\"1\":{\"162\":1}}],[\"采用动量更新方式对\",{\"1\":{\"256\":1}}],[\"采用动量慢更新策略\",{\"1\":{\"147\":1}}],[\"采用动量编码器来生成表示\",{\"1\":{\"127\":1}}],[\"采用itc\",{\"1\":{\"147\":1}}],[\"采用itc和itm目标执行完微调后\",{\"1\":{\"146\":1}}],[\"采用moco的动量慢更新策略进行学习\",{\"1\":{\"145\":1}}],[\"采用bert分词器实现论文中的文本预处理\",{\"1\":{\"142\":1}}],[\"采用\",{\"1\":{\"127\":1,\"142\":1,\"169\":1,\"179\":1,\"198\":1,\"208\":2,\"211\":1,\"222\":1,\"227\":1,\"260\":1,\"265\":1,\"560\":1,\"561\":1,\"704\":3}}],[\"采样相比\",{\"1\":{\"869\":1}}],[\"采样并输入解码器\",{\"1\":{\"868\":1}}],[\"采样效率低\",{\"1\":{\"866\":1}}],[\"采样后生成的样本\",{\"1\":{\"865\":1}}],[\"采样时\",{\"1\":{\"843\":1}}],[\"采样时的阈值\",{\"1\":{\"817\":1}}],[\"采样一次\",{\"1\":{\"868\":1}}],[\"采样一批噪声\",{\"1\":{\"840\":1}}],[\"采样一批真实样本\",{\"1\":{\"840\":1}}],[\"采样一些关键点\",{\"1\":{\"92\":1}}],[\"采样温度参数\",{\"1\":{\"821\":1}}],[\"采样直到达到目标长度\",{\"1\":{\"820\":1}}],[\"采样是一种常用的生成模型采样方法\",{\"1\":{\"818\":1}}],[\"采样生成\",{\"0\":{\"811\":1}}],[\"采样得到\",{\"1\":{\"809\":1}}],[\"采样得到的关键点坐标\",{\"1\":{\"92\":1}}],[\"采样过程详解\",{\"1\":{\"796\":1}}],[\"采样过程使用了一种称为\",{\"1\":{\"796\":1}}],[\"采样越接近\",{\"1\":{\"795\":1}}],[\"采样与训练\",{\"1\":{\"514\":1}}],[\"采样库\",{\"0\":{\"402\":1}}],[\"采样多个点\",{\"1\":{\"387\":1}}],[\"采样\",{\"0\":{\"818\":1},\"1\":{\"265\":1,\"817\":1,\"819\":2,\"821\":1,\"868\":1,\"874\":1}}],[\"采样策略\",{\"1\":{\"265\":1}}],[\"采样每个图像对应的负文本\",{\"1\":{\"162\":1}}],[\"采样每个文本对应的负图像\",{\"1\":{\"162\":1}}],[\"采样难负样本\",{\"1\":{\"145\":1}}],[\"采样的\",{\"1\":{\"886\":1}}],[\"采样的样本数\",{\"1\":{\"403\":1}}],[\"采样的阈值\",{\"1\":{\"143\":1,\"820\":1}}],[\"采样的关键点数量\",{\"1\":{\"92\":2}}],[\"采样点数量\",{\"1\":{\"92\":1}}],[\"采样半径\",{\"1\":{\"92\":1}}],[\"采样层\",{\"1\":{\"88\":1}}],[\"替换成\",{\"1\":{\"880\":1}}],[\"替换成以下内容\",{\"1\":{\"572\":1}}],[\"替换被遮挡的位置\",{\"1\":{\"804\":1}}],[\"替换被遮挡的部分\",{\"1\":{\"804\":1}}],[\"替换这些被遮挡的\",{\"1\":{\"772\":1}}],[\"替换的是哪一个词\",{\"1\":{\"572\":1}}],[\"替换relu为swiglu\",{\"1\":{\"548\":1}}],[\"替换标准\",{\"1\":{\"260\":1}}],[\"替换为唯一的\",{\"1\":{\"815\":1}}],[\"替换为伽马函数表达式\",{\"1\":{\"742\":1}}],[\"替换为随机单词\",{\"1\":{\"562\":1}}],[\"替换为随机\",{\"1\":{\"560\":1}}],[\"替换为\",{\"1\":{\"265\":1,\"312\":2,\"560\":1,\"562\":1,\"804\":1}}],[\"替换为特殊标记\",{\"1\":{\"155\":1}}],[\"替换为因果\",{\"1\":{\"126\":1}}],[\"替换\",{\"1\":{\"147\":2}}],[\"替代值\",{\"1\":{\"815\":1}}],[\"替代绝对位置编码\",{\"1\":{\"548\":1}}],[\"替代\",{\"1\":{\"73\":1}}],[\"位单通道图像\",{\"1\":{\"847\":1}}],[\"位标注者进行判断\",{\"1\":{\"539\":1}}],[\"位整数\",{\"1\":{\"495\":2}}],[\"位或\",{\"1\":{\"495\":2}}],[\"位浮点数\",{\"1\":{\"495\":1}}],[\"位于原点\",{\"1\":{\"753\":1}}],[\"位于序列的开头\",{\"1\":{\"319\":1}}],[\"位于\",{\"1\":{\"126\":1}}],[\"位置保留了唯一\",{\"1\":{\"814\":1}}],[\"位置处理方式并不完全确定\",{\"1\":{\"809\":1}}],[\"位置处设置为\",{\"1\":{\"311\":1}}],[\"位置偏好\",{\"1\":{\"590\":1}}],[\"位置的隐藏状态并池化\",{\"1\":{\"580\":1}}],[\"位置的\",{\"1\":{\"575\":1}}],[\"位置的标签设为\",{\"1\":{\"163\":1}}],[\"位置顺序\",{\"1\":{\"337\":1}}],[\"位置参数\",{\"1\":{\"337\":2}}],[\"位置参数与关键字参数\",{\"0\":{\"337\":1}}],[\"位置嵌入\",{\"1\":{\"514\":1,\"580\":2}}],[\"位置嵌入会被初始化为一组特定的值\",{\"1\":{\"320\":1}}],[\"位置嵌入和类型嵌入之和\",{\"1\":{\"263\":1}}],[\"位置编码设置\",{\"1\":{\"814\":1}}],[\"位置编码可以有效地捕捉输入序列中的相对位置信息\",{\"1\":{\"704\":1}}],[\"位置编码通常使用正弦和余弦函数生成\",{\"1\":{\"622\":1}}],[\"位置编码通过以下公式计算\",{\"1\":{\"587\":1}}],[\"位置编码为可学习的矩阵\",{\"1\":{\"597\":1}}],[\"位置编码的周期性可能导致不同位置之间的区分度逐渐降低\",{\"1\":{\"587\":1}}],[\"位置编码的作用是为了记忆输入的语序信息\",{\"1\":{\"320\":1}}],[\"位置编码向量是唯一的\",{\"1\":{\"587\":1}}],[\"位置编码计算\",{\"1\":{\"544\":1}}],[\"位置编码被添加到\",{\"1\":{\"319\":1}}],[\"位置编码\",{\"0\":{\"585\":1},\"1\":{\"289\":1,\"320\":2,\"544\":1,\"548\":1,\"585\":1,\"622\":1,\"704\":1,\"814\":1,\"815\":2}}],[\"位置一般是\",{\"1\":{\"276\":1}}],[\"位置\",{\"1\":{\"92\":1,\"587\":1}}],[\"单模型实现\",{\"1\":{\"816\":1}}],[\"单模态或者多模态\",{\"1\":{\"707\":1}}],[\"单模态自注意力\",{\"1\":{\"310\":1}}],[\"单模态对齐\",{\"1\":{\"277\":1}}],[\"单模态文本特征序列\",{\"1\":{\"277\":1}}],[\"单模态文本特征\",{\"1\":{\"277\":1}}],[\"单模态输出\",{\"1\":{\"277\":1}}],[\"单模态\",{\"1\":{\"277\":6}}],[\"单模态最终输出\",{\"1\":{\"277\":1}}],[\"单模态模式\",{\"1\":{\"277\":2}}],[\"单模态图像编码\",{\"1\":{\"277\":1}}],[\"单模态编码器\",{\"1\":{\"126\":1}}],[\"单个遮挡块的最小\",{\"1\":{\"801\":1}}],[\"单个python文件\",{\"1\":{\"691\":1}}],[\"单点集\",{\"1\":{\"728\":1}}],[\"单位\",{\"1\":{\"728\":1}}],[\"单元测试\",{\"0\":{\"675\":1}}],[\"单词\",{\"1\":{\"578\":1}}],[\"单词同样合理甚至更好的替代词\",{\"1\":{\"157\":1}}],[\"单任务微调\",{\"1\":{\"566\":1}}],[\"单文档内句子打包\",{\"1\":{\"564\":1}}],[\"单样本学习\",{\"1\":{\"528\":1}}],[\"单样本\",{\"1\":{\"527\":1}}],[\"单一嵌入向量\",{\"1\":{\"885\":1}}],[\"单一语言模型可处理翻译\",{\"1\":{\"522\":1}}],[\"单一的线性层只能进行线性变换\",{\"1\":{\"321\":1}}],[\"单纯\",{\"1\":{\"711\":1}}],[\"单纯依赖人工标注和设计任务目标难以满足多任务学习的规模化需求\",{\"1\":{\"520\":1}}],[\"单纯使用最近邻分类器\",{\"1\":{\"173\":1}}],[\"单领域的数据集训练模式\",{\"1\":{\"520\":1}}],[\"单层宽网络\",{\"1\":{\"385\":1}}],[\"单层网络依赖基函数的数量\",{\"1\":{\"385\":1}}],[\"单层网络\",{\"1\":{\"385\":4}}],[\"单隐藏层神经网络的输出形式为\",{\"1\":{\"385\":1}}],[\"单项式基\",{\"1\":{\"385\":1}}],[\"单机环境下显存\",{\"1\":{\"277\":1}}],[\"单机\",{\"1\":{\"277\":1}}],[\"单机模式\",{\"1\":{\"277\":1}}],[\"单机训练时\",{\"1\":{\"277\":1}}],[\"单靠有限规模的图文对数据进行预训练不足以获得最佳效果\",{\"1\":{\"269\":1}}],[\"单独学习\",{\"1\":{\"591\":1}}],[\"单独用来处理类别信息\",{\"1\":{\"319\":1}}],[\"单独编码图像和文本\",{\"1\":{\"262\":1}}],[\"单独使用\",{\"1\":{\"132\":1}}],[\"单维主导\",{\"1\":{\"183\":1}}],[\"单\",{\"1\":{\"170\":1}}],[\"单尺度分组\",{\"1\":{\"93\":1}}],[\"单尺度分组分类模型\",{\"0\":{\"93\":1}}],[\"框架进行开发\",{\"1\":{\"717\":1}}],[\"框架交互\",{\"1\":{\"715\":1}}],[\"框架的核心库\",{\"1\":{\"715\":1}}],[\"框架可以实现数据感知和环境互动\",{\"1\":{\"712\":1}}],[\"框架是一个开源工具\",{\"1\":{\"712\":1}}],[\"框架核心功能的日益完善\",{\"1\":{\"695\":1}}],[\"框架按照\",{\"1\":{\"308\":1}}],[\"框架图如下\",{\"1\":{\"246\":1}}],[\"框架\",{\"0\":{\"509\":1},\"1\":{\"120\":1,\"167\":1,\"531\":1,\"712\":2,\"870\":1}}],[\"框架在多项评估指标上具有显著优势\",{\"1\":{\"26\":1}}],[\"剪切\",{\"1\":{\"117\":1}}],[\"弯曲\",{\"1\":{\"116\":1}}],[\"才结束词汇表的构建\",{\"1\":{\"476\":2}}],[\"才会在分布意义上收敛于真实分布\",{\"1\":{\"871\":1}}],[\"才会有好的效果\",{\"1\":{\"324\":1}}],[\"才会将内容显示到屏幕上\",{\"1\":{\"83\":1}}],[\"才能使其可微\",{\"1\":{\"868\":1}}],[\"才能采到接近目标图像的样本\",{\"1\":{\"866\":1}}],[\"才能得到准确估计\",{\"1\":{\"866\":1}}],[\"才能继续计算其前向的梯度\",{\"1\":{\"685\":1}}],[\"才能计算导数\",{\"1\":{\"660\":1}}],[\"才能够满足业务的需求\",{\"1\":{\"482\":1}}],[\"才能通过\",{\"1\":{\"364\":1,\"396\":1}}],[\"才能起作用\",{\"1\":{\"250\":1}}],[\"才能更好处理复杂多模态任务\",{\"1\":{\"229\":1}}],[\"才能让表示真正学到\",{\"1\":{\"186\":1}}],[\"才能达到最佳效果\",{\"1\":{\"185\":1}}],[\"才能保证整个网络输出与输入点的顺序无关\",{\"1\":{\"115\":1}}],[\"网页收集\",{\"1\":{\"131\":1}}],[\"网格上每个空间位置的\",{\"1\":{\"808\":1}}],[\"网格的高和宽\",{\"1\":{\"801\":1}}],[\"网格大小\",{\"1\":{\"801\":1}}],[\"网格点\",{\"1\":{\"387\":1}}],[\"网格特征\",{\"1\":{\"280\":1}}],[\"网格\",{\"1\":{\"114\":1,\"387\":1,\"769\":1,\"770\":1,\"801\":1,\"807\":2}}],[\"网络会自动学习潜在结构\",{\"1\":{\"866\":1}}],[\"网络结构\",{\"1\":{\"848\":1}}],[\"网络结构特点\",{\"1\":{\"101\":1}}],[\"网络层封装\",{\"1\":{\"700\":1}}],[\"网络类型\",{\"1\":{\"385\":1}}],[\"网络启发\",{\"1\":{\"264\":1}}],[\"网络获得图像\",{\"1\":{\"262\":1}}],[\"网络采用\",{\"1\":{\"179\":1}}],[\"网络\",{\"1\":{\"163\":1,\"178\":1,\"179\":1,\"186\":1,\"793\":1}}],[\"网络图文数据噪声多\",{\"1\":{\"149\":1}}],[\"网络输出由一个有限子集\",{\"1\":{\"105\":1}}],[\"网络不是只捕获一个尺度上的局部特征\",{\"1\":{\"95\":1}}],[\"网络对于每个选定的形心点\",{\"1\":{\"95\":1}}],[\"网络对每一个点做低维到高维的映射\",{\"1\":{\"86\":1}}],[\"网络在训练时被呈现了不同稀疏度的点集\",{\"1\":{\"95\":1}}],[\"网络的学习目标是让重建出来的图像\",{\"1\":{\"878\":1}}],[\"网络的训练速度能快上很多\",{\"1\":{\"847\":1}}],[\"网络的所有卷积层要替换成带掩码的卷积层\",{\"1\":{\"847\":1}}],[\"网络的输出是一个经softmax的概率分布\",{\"1\":{\"847\":1}}],[\"网络的每一组set\",{\"1\":{\"87\":1}}],[\"网络的分割和分类模型\",{\"1\":{\"87\":1}}],[\"适配应用任务\",{\"1\":{\"716\":1}}],[\"适配分类\",{\"1\":{\"196\":1}}],[\"适应特定任务\",{\"1\":{\"705\":1}}],[\"适应性强的智能系统\",{\"1\":{\"539\":1}}],[\"适应任务必须微调\",{\"1\":{\"531\":1}}],[\"适应扩展到所有线性层\",{\"1\":{\"495\":1}}],[\"适应不同任务需求\",{\"1\":{\"473\":1}}],[\"适用场景\",{\"1\":{\"470\":1}}],[\"适用于生产环境\",{\"1\":{\"714\":1}}],[\"适用于更复杂的应用场景\",{\"1\":{\"704\":1}}],[\"适用于只需要前向推理且不需要更新模型参数的场景\",{\"1\":{\"365\":1}}],[\"适用于复杂推理任务但依赖目标检测器和高分辨率图像\",{\"1\":{\"150\":1}}],[\"适用于分类\",{\"1\":{\"103\":1}}],[\"适用于\",{\"1\":{\"82\":1}}],[\"适用于连续响应值\",{\"1\":{\"82\":1}}],[\"适当降低训练目标反而可能取得更好的效果\",{\"1\":{\"305\":1}}],[\"适合还原复杂细节\",{\"1\":{\"885\":1}}],[\"适合相对稳定的数据\",{\"1\":{\"711\":1}}],[\"适合动态变化的数据\",{\"1\":{\"711\":1}}],[\"适合日常对话和基础任务场景\",{\"1\":{\"704\":1}}],[\"适合大规模优化但灵活性较低\",{\"1\":{\"692\":1}}],[\"适合无需梯度的场景\",{\"1\":{\"688\":1}}],[\"适合机器学习中损失函数的优化\",{\"1\":{\"656\":1}}],[\"适合在推理阶段作为验证标准\",{\"1\":{\"469\":1}}],[\"适合连续值\",{\"1\":{\"390\":1}}],[\"适合图像缩放\",{\"1\":{\"390\":1}}],[\"适合用于构建对话助手\",{\"1\":{\"539\":1}}],[\"适合用于\",{\"1\":{\"389\":1}}],[\"适合渲染\",{\"1\":{\"114\":1}}],[\"适合\",{\"1\":{\"114\":1}}],[\"法律\",{\"1\":{\"530\":1}}],[\"法→英\",{\"1\":{\"522\":1}}],[\"法向量等属性\",{\"1\":{\"114\":1}}],[\"法向量\",{\"1\":{\"114\":1}}],[\"法线等\",{\"1\":{\"92\":1}}],[\"忽视局部邻域关系\",{\"1\":{\"112\":1}}],[\"忽略系数\",{\"1\":{\"752\":1}}],[\"忽略填充部分\",{\"1\":{\"580\":1}}],[\"忽略难分类样本\",{\"1\":{\"470\":1}}],[\"忽略标签为\",{\"1\":{\"163\":1}}],[\"忽略\",{\"1\":{\"163\":2,\"276\":1,\"822\":1}}],[\"忽略pad位loss\",{\"1\":{\"147\":1}}],[\"忽略局部结构\",{\"1\":{\"112\":1}}],[\"忽略局部结构信息\",{\"1\":{\"112\":1}}],[\"忽略了局部邻域之间的结构关系\",{\"1\":{\"112\":1}}],[\"易用\",{\"1\":{\"695\":1}}],[\"易混淆\",{\"0\":{\"616\":1}}],[\"易样本\",{\"1\":{\"470\":1}}],[\"易分类样本\",{\"1\":{\"470\":1}}],[\"易于扩展为检测\",{\"1\":{\"112\":1}}],[\"易受类别不平衡影响\",{\"1\":{\"468\":1}}],[\"易受\",{\"1\":{\"82\":1}}],[\"极端案例\",{\"1\":{\"522\":1}}],[\"极大地丰富了\",{\"1\":{\"715\":1}}],[\"极大地提升了开发效率和应用性能\",{\"1\":{\"714\":1}}],[\"极大地提升了模型在各种自然语言处理任务上的表现\",{\"1\":{\"703\":1}}],[\"极大地降低了在各种技术栈上构建\",{\"1\":{\"714\":1}}],[\"极大地降低成本\",{\"1\":{\"488\":1}}],[\"极大地简化了调试和问题排查的流程\",{\"1\":{\"714\":1}}],[\"极大\",{\"1\":{\"385\":1}}],[\"极其高效\",{\"1\":{\"112\":1}}],[\"极为重要\",{\"1\":{\"24\":1}}],[\"略逊于多视角\",{\"1\":{\"112\":1}}],[\"接上图像\",{\"1\":{\"815\":1}}],[\"接触到更多的文本信息\",{\"1\":{\"704\":1}}],[\"接一个逐位置的前馈层来生成目标字符的分布输出\",{\"1\":{\"510\":1}}],[\"接一个全连接层\",{\"1\":{\"156\":1}}],[\"接着\",{\"1\":{\"507\":1,\"772\":1,\"867\":1,\"870\":1}}],[\"接着是第\",{\"1\":{\"422\":2}}],[\"接着通过多头可供性链式思维\",{\"1\":{\"8\":1}}],[\"接下来使用\",{\"1\":{\"867\":1}}],[\"接下来的小节将更详细地介绍这两个阶段\",{\"1\":{\"807\":1}}],[\"接下来的阶段将进一步扩展tinypytorch\",{\"1\":{\"678\":1}}],[\"接下来就需要进行长期的用户体验跟踪\",{\"1\":{\"717\":1}}],[\"接下来就很简单了\",{\"1\":{\"243\":1}}],[\"接下来我们需要搭建前后端\",{\"1\":{\"717\":1}}],[\"接下来我们主要介绍几个国内外常见的大模型\",{\"1\":{\"704\":1}}],[\"接下来将使用tinypytorch验证是否能找到该最小值\",{\"1\":{\"697\":1}}],[\"接下来介绍几种比较流行的peft微调方案\",{\"1\":{\"484\":1}}],[\"接下来\",{\"1\":{\"300\":1,\"487\":1,\"706\":1}}],[\"接收信息\",{\"1\":{\"758\":1}}],[\"接收任意个数的位置参数\",{\"1\":{\"681\":1}}],[\"接收器操作特性\",{\"1\":{\"450\":1}}],[\"接收函数并返回函数\",{\"1\":{\"341\":1}}],[\"接收函数作为参数\",{\"1\":{\"339\":1}}],[\"接收\",{\"1\":{\"272\":1}}],[\"接收学生输出\",{\"1\":{\"186\":1}}],[\"接收的文本\",{\"1\":{\"132\":1}}],[\"接近于标准正态分布\",{\"1\":{\"857\":1}}],[\"接近palm\",{\"1\":{\"549\":1}}],[\"接近人类水平\",{\"1\":{\"529\":1}}],[\"接近或超越部分任务的微调模型性能\",{\"1\":{\"527\":1}}],[\"接近1\",{\"1\":{\"470\":1}}],[\"接近0\",{\"1\":{\"470\":1}}],[\"接近原图\",{\"1\":{\"186\":1}}],[\"接近\",{\"1\":{\"112\":1}}],[\"优质的\",{\"1\":{\"717\":1}}],[\"优缺点\",{\"1\":{\"470\":1}}],[\"优缺点对比\",{\"1\":{\"239\":1}}],[\"优先考虑精确性和推理步骤的正确性\",{\"1\":{\"704\":1}}],[\"优先于准确率\",{\"1\":{\"448\":1}}],[\"优先级低于\",{\"1\":{\"398\":1}}],[\"优点\",{\"1\":{\"239\":1,\"260\":2,\"261\":3,\"470\":1,\"591\":1}}],[\"优于opt\",{\"1\":{\"549\":1,\"551\":1}}],[\"优于minerva\",{\"1\":{\"549\":1}}],[\"优于简单\",{\"1\":{\"539\":1}}],[\"优于\",{\"1\":{\"203\":2}}],[\"优化嵌入空间\",{\"0\":{\"882\":1}}],[\"优化编码器和解码器\",{\"0\":{\"881\":1}}],[\"优化目标函数\",{\"0\":{\"868\":1}}],[\"优化目标是调整参数\",{\"1\":{\"865\":1}}],[\"优化将难以进行\",{\"1\":{\"865\":1}}],[\"优化该松弛的\",{\"1\":{\"808\":1}}],[\"优化\",{\"1\":{\"695\":1,\"809\":1}}],[\"优化打印等交互体验\",{\"1\":{\"693\":1}}],[\"优化正向传播实现\",{\"1\":{\"693\":1}}],[\"优化问题中常使用特定函数评估算法性能\",{\"1\":{\"692\":1}}],[\"优化效果总结\",{\"1\":{\"688\":1}}],[\"优化反向传播的内存消耗\",{\"1\":{\"688\":1}}],[\"优化内存消耗\",{\"0\":{\"688\":1}}],[\"优化后的内存管理确保框架在处理大规模计算时的稳定性和效率\",{\"1\":{\"687\":1}}],[\"优化后的roberta在多个基准测试\",{\"1\":{\"558\":1}}],[\"优化了反向传播的实现\",{\"1\":{\"678\":1}}],[\"优化策略\",{\"1\":{\"560\":1}}],[\"优化llama\",{\"1\":{\"550\":1}}],[\"优化人类偏好\",{\"1\":{\"535\":1}}],[\"优化难度\",{\"1\":{\"385\":1}}],[\"优化图文对比损失\",{\"1\":{\"267\":1}}],[\"优化不同分辨率输入\",{\"1\":{\"220\":1}}],[\"优化多模态对话能力\",{\"1\":{\"198\":1}}],[\"优化器准备\",{\"1\":{\"840\":1}}],[\"优化器采用\",{\"1\":{\"774\":1}}],[\"优化器与\",{\"1\":{\"700\":1}}],[\"优化器与学习率调度器\",{\"1\":{\"581\":1}}],[\"优化器改进\",{\"1\":{\"561\":1}}],[\"优化器方案\",{\"1\":{\"514\":1}}],[\"优化器及余弦调度器\",{\"1\":{\"186\":1}}],[\"优化器使用\",{\"1\":{\"131\":1,\"208\":1,\"209\":1}}],[\"优化器设置\",{\"1\":{\"80\":1}}],[\"优化器\",{\"1\":{\"22\":1,\"80\":1,\"179\":1,\"548\":1,\"560\":1,\"700\":1,\"803\":1}}],[\"优异的\",{\"1\":{\"173\":1}}],[\"优势\",{\"1\":{\"112\":1,\"467\":1,\"468\":1,\"473\":1,\"562\":1}}],[\"面向大语言模型的检索增强生成技术\",{\"1\":{\"718\":1}}],[\"面对复杂问题时\",{\"1\":{\"709\":1}}],[\"面对大量噪声点时效果较差\",{\"1\":{\"112\":1}}],[\"面临的主要问题有\",{\"1\":{\"709\":1}}],[\"面临\",{\"1\":{\"149\":1}}],[\"面部发生形变\",{\"1\":{\"112\":1}}],[\"尤其适用于生成模型中从\",{\"1\":{\"819\":1}}],[\"尤其适合研究和快速开发场景\",{\"1\":{\"692\":1}}],[\"尤其当处理大规模数据时\",{\"1\":{\"687\":1}}],[\"尤其对语义分割帮助很大\",{\"1\":{\"780\":1}}],[\"尤其对于多变量函数\",{\"1\":{\"653\":1}}],[\"尤其对\",{\"1\":{\"387\":1}}],[\"尤其是当我们用任意函数\",{\"1\":{\"871\":1}}],[\"尤其是二分类和多分类问题\",{\"1\":{\"832\":1}}],[\"尤其是自回归\",{\"1\":{\"806\":1}}],[\"尤其是情商方面异常优秀\",{\"1\":{\"704\":1}}],[\"尤其是few\",{\"1\":{\"528\":1}}],[\"尤其是目标检测\",{\"1\":{\"470\":1}}],[\"尤其是\",{\"1\":{\"274\":1,\"511\":1}}],[\"尤其是零样本\",{\"1\":{\"232\":1,\"239\":1}}],[\"尤其是在高容量模型下\",{\"1\":{\"864\":1}}],[\"尤其是在大规模预训练时\",{\"1\":{\"774\":1}}],[\"尤其是在长文本任务中\",{\"1\":{\"530\":1}}],[\"尤其是在\",{\"1\":{\"295\":1}}],[\"尤其是在低层次上对每个质心点运行局部pointnet时\",{\"1\":{\"97\":1}}],[\"尤其是在预测值接近极端值\",{\"1\":{\"78\":1}}],[\"尤其在解决复杂任务时表现出了惊人的潜力\",{\"1\":{\"703\":1}}],[\"尤其在神经网络训练中\",{\"1\":{\"687\":1}}],[\"尤其在军事\",{\"1\":{\"539\":1}}],[\"尤其在有\",{\"1\":{\"538\":1}}],[\"尤其在few\",{\"1\":{\"529\":1}}],[\"尤其在anli这种对抗性构建的数据集上\",{\"1\":{\"529\":1}}],[\"尤其在coqa中few\",{\"1\":{\"529\":1}}],[\"尤其在翻译为英语的方向上\",{\"1\":{\"529\":1}}],[\"尤其在triviaqa中\",{\"1\":{\"529\":1}}],[\"尤其在目标区域较小\",{\"1\":{\"467\":1}}],[\"尤其在ocr相关任务\",{\"1\":{\"216\":1,\"230\":1}}],[\"尤其在\",{\"1\":{\"215\":1}}],[\"尤其在图像分类与部分\",{\"1\":{\"123\":1}}],[\"尤其未训练时\",{\"1\":{\"112\":1}}],[\"十二亿\",{\"1\":{\"324\":1}}],[\"十亿\",{\"1\":{\"324\":1}}],[\"十一\",{\"1\":{\"112\":1}}],[\"十\",{\"1\":{\"112\":1}}],[\"又会带来两个新的问题\",{\"1\":{\"878\":1}}],[\"又会导致计算资源浪费\",{\"1\":{\"112\":1}}],[\"又能让\",{\"1\":{\"871\":1}}],[\"又能快速地求出图像概率的模型\",{\"1\":{\"847\":1}}],[\"又能计算概率的模型不好设计\",{\"1\":{\"847\":1}}],[\"又能拆解未知词的子词词汇表\",{\"1\":{\"475\":1}}],[\"又称\",{\"1\":{\"883\":1}}],[\"又称多元正态分布\",{\"1\":{\"751\":1}}],[\"又称为\",{\"1\":{\"467\":1}}],[\"又进一步发布了\",{\"1\":{\"704\":1}}],[\"又几乎不增加计算量\",{\"1\":{\"591\":1}}],[\"又是一个有实际意义的字或词\",{\"1\":{\"575\":1}}],[\"又怎么能够利用这些开源的大模型\",{\"1\":{\"491\":1}}],[\"又理解整体结构\",{\"1\":{\"105\":1}}],[\"九\",{\"0\":{\"439\":1},\"1\":{\"112\":1}}],[\"八百六十万\",{\"1\":{\"324\":1}}],[\"八\",{\"0\":{\"438\":1},\"1\":{\"112\":1}}],[\"七\",{\"0\":{\"419\":1,\"437\":1},\"1\":{\"112\":1}}],[\"六\",{\"0\":{\"416\":1,\"436\":1},\"1\":{\"112\":1}}],[\"拉回正态\",{\"1\":{\"459\":1}}],[\"拉伸等会导致形变的操作\",{\"1\":{\"117\":1}}],[\"拉伸等形变\",{\"1\":{\"112\":1}}],[\"拉伸\",{\"1\":{\"112\":1,\"116\":1}}],[\"拉平数据\",{\"1\":{\"459\":1}}],[\"拉平后线性投影获得\",{\"1\":{\"263\":1}}],[\"拉平\",{\"1\":{\"59\":1}}],[\"旋转预测\",{\"1\":{\"786\":1}}],[\"旋转位置编码\",{\"1\":{\"704\":1}}],[\"旋转\",{\"1\":{\"112\":1,\"116\":2,\"117\":2}}],[\"五\",{\"0\":{\"415\":1,\"435\":1},\"1\":{\"112\":1}}],[\"体型是0\",{\"1\":{\"878\":1}}],[\"体型是胖还是壮\",{\"1\":{\"878\":1}}],[\"体积\",{\"1\":{\"754\":1}}],[\"体验优化\",{\"1\":{\"717\":1}}],[\"体验bert的预训练过程是如何实现的\",{\"1\":{\"576\":1}}],[\"体会它们的有趣之处\",{\"1\":{\"634\":1}}],[\"体重\",{\"1\":{\"455\":2}}],[\"体现了自动微分的优势\",{\"1\":{\"692\":1}}],[\"体现了全词掩码在预训练时以及图像增强在微调时的重要性\",{\"1\":{\"280\":1}}],[\"体现出模型对语义的灵活解析能力\",{\"1\":{\"25\":1}}],[\"体现出数据集在样本分布上的全面性和均衡性\",{\"1\":{\"19\":1}}],[\"体素网格\",{\"1\":{\"114\":1}}],[\"体素\",{\"1\":{\"112\":1}}],[\"四种任务设定方法的比较\",{\"1\":{\"528\":1}}],[\"四阶张量的例子\",{\"1\":{\"428\":1}}],[\"四个残差块和一个输出层\",{\"1\":{\"382\":1}}],[\"四个指标协同工作\",{\"1\":{\"82\":1}}],[\"四个指标对比总结\",{\"1\":{\"82\":1}}],[\"四\",{\"0\":{\"411\":1,\"434\":1,\"699\":1},\"1\":{\"112\":1,\"536\":1}}],[\"🧮\",{\"0\":{\"679\":1}}],[\"🤔\",{\"1\":{\"665\":1}}],[\"🧪\",{\"1\":{\"112\":1,\"616\":1}}],[\"🧩\",{\"1\":{\"112\":2,\"616\":1}}],[\"🧱\",{\"1\":{\"112\":3}}],[\"🧠\",{\"0\":{\"694\":1},\"1\":{\"108\":1,\"112\":1,\"115\":1}}],[\"曲率等细节\",{\"1\":{\"112\":1}}],[\"曲率\",{\"1\":{\"112\":1}}],[\"曲线上最接近\",{\"1\":{\"453\":1}}],[\"曲线为从\",{\"1\":{\"451\":1}}],[\"曲线的方法是\",{\"1\":{\"450\":1}}],[\"曲线直观地显示了所有阈值下的模型性能\",{\"1\":{\"450\":1}}],[\"曲线和\",{\"0\":{\"449\":1}}],[\"曲线\",{\"1\":{\"82\":1}}],[\"曲线下的面积\",{\"1\":{\"82\":1}}],[\"曲线下面积较大的模型通常是更好的模型\",{\"1\":{\"453\":1}}],[\"曲线下面积\",{\"0\":{\"451\":1},\"1\":{\"82\":1,\"451\":1}}],[\"缺点\",{\"1\":{\"239\":1,\"260\":2,\"261\":2,\"286\":1,\"470\":1}}],[\"缺少锐化\",{\"1\":{\"183\":1}}],[\"缺少居中\",{\"1\":{\"183\":1}}],[\"缺乏预定义词汇\",{\"1\":{\"766\":1}}],[\"缺乏结构化监督利用能力\",{\"1\":{\"530\":1}}],[\"缺乏可控性与鲁棒性\",{\"1\":{\"530\":1}}],[\"缺乏鲁棒的系统性泛化能力\",{\"1\":{\"530\":1}}],[\"缺乏具体的上下文\",{\"1\":{\"301\":1}}],[\"缺乏语言对齐\",{\"1\":{\"196\":1}}],[\"缺乏与llms的直接特征兼容性\",{\"1\":{\"191\":1}}],[\"缺乏精细建模\",{\"1\":{\"112\":1}}],[\"缺乏层次化\",{\"1\":{\"112\":1}}],[\"缺乏层次化特征提取机制\",{\"1\":{\"112\":1}}],[\"缺乏动态上下文感知\",{\"1\":{\"112\":1}}],[\"缺陷对比\",{\"1\":{\"112\":1}}],[\"缺陷类型\",{\"1\":{\"112\":1}}],[\"缺陷\",{\"0\":{\"112\":1},\"1\":{\"112\":1,\"468\":1}}],[\"缺失\",{\"1\":{\"24\":1}}],[\"座位\",{\"1\":{\"111\":1}}],[\"控制了编码器的相对学习速度\",{\"1\":{\"882\":1}}],[\"控制了相似度计算的维度\",{\"1\":{\"413\":1}}],[\"控制维度\",{\"1\":{\"846\":1}}],[\"控制离散采样的平滑程度\",{\"1\":{\"821\":1}}],[\"控制保留多少\",{\"1\":{\"820\":1}}],[\"控制采样平滑程度\",{\"1\":{\"821\":1}}],[\"控制采样的随机程度\",{\"1\":{\"819\":1}}],[\"控制采样随机性\",{\"1\":{\"817\":1}}],[\"控制随机性\",{\"1\":{\"819\":1}}],[\"控制生成\",{\"1\":{\"817\":1}}],[\"控制这项的权重\",{\"1\":{\"807\":1}}],[\"控制反向传播是否启用\",{\"1\":{\"688\":1}}],[\"控制手段\",{\"1\":{\"538\":1}}],[\"控制交叉熵损失和\",{\"1\":{\"473\":1}}],[\"控制交叉熵中正负样本的权重\",{\"1\":{\"473\":1}}],[\"控制两个损失之间的权重比例\",{\"1\":{\"473\":1}}],[\"控制区域匹配误差的重要性\",{\"1\":{\"473\":1}}],[\"控制分布的平滑度\",{\"1\":{\"795\":1}}],[\"控制分布的平滑程度\",{\"1\":{\"178\":1}}],[\"控制分布的\",{\"1\":{\"795\":1}}],[\"控制分类误差的重要性\",{\"1\":{\"473\":1}}],[\"控制假阴性\",{\"1\":{\"471\":1}}],[\"控制假阳性\",{\"1\":{\"471\":1}}],[\"控制正类\",{\"1\":{\"470\":1}}],[\"控制正样本\",{\"1\":{\"470\":1}}],[\"控制难易样本权重\",{\"1\":{\"470\":1}}],[\"控制难易样本的权重衰减程度\",{\"1\":{\"470\":1}}],[\"控制残差贡献\",{\"1\":{\"272\":1}}],[\"控制输出格式\",{\"1\":{\"163\":1}}],[\"控制\",{\"1\":{\"163\":1,\"186\":1,\"246\":1,\"473\":1,\"538\":1,\"866\":1}}],[\"控制动量蒸馏信号的强度\",{\"1\":{\"157\":1}}],[\"控制是否对\",{\"1\":{\"467\":1}}],[\"控制是否启用\",{\"1\":{\"289\":1}}],[\"控制是否使用\",{\"1\":{\"109\":1}}],[\"控制是否输出全局特征\",{\"1\":{\"109\":1}}],[\"控制每个\",{\"1\":{\"29\":1}}],[\"添加shape\",{\"1\":{\"689\":1}}],[\"添加retain\",{\"1\":{\"688\":1}}],[\"添加元素\",{\"1\":{\"687\":1}}],[\"添加特殊token标记\",{\"1\":{\"594\":1}}],[\"添加batch维度\",{\"1\":{\"544\":1}}],[\"添加一个无监督训练目标是半监督学习的一种替代形式\",{\"1\":{\"508\":1}}],[\"添加一些特殊词\",{\"1\":{\"476\":1}}],[\"添加一维位置编码和二维位置编码并没有太大的差异\",{\"1\":{\"320\":1}}],[\"添加到\",{\"1\":{\"313\":1}}],[\"添加可学习偏置\",{\"1\":{\"272\":1}}],[\"添加位置编码\",{\"0\":{\"320\":1},\"1\":{\"272\":1,\"804\":1,\"820\":1}}],[\"添加\",{\"0\":{\"319\":1},\"1\":{\"108\":1,\"272\":3,\"276\":1,\"814\":1,\"821\":1}}],[\"添加更多上下文细节\",{\"1\":{\"63\":1}}],[\"❗而只有正交矩阵才能表示刚性变换\",{\"1\":{\"108\":1}}],[\"摆正\",{\"1\":{\"107\":1,\"109\":1}}],[\"摆脱几何标注和固定场景限制\",{\"1\":{\"51\":1}}],[\"变回图像\",{\"1\":{\"878\":1}}],[\"变分下界\",{\"1\":{\"854\":1}}],[\"变分自编码器是否也存在某种\",{\"1\":{\"873\":1}}],[\"变分自编码器\",{\"0\":{\"866\":1},\"1\":{\"854\":1,\"867\":1,\"873\":1}}],[\"变化越慢\",{\"1\":{\"839\":1}}],[\"变得对称且有界\",{\"1\":{\"835\":1}}],[\"变异系数\",{\"1\":{\"755\":1}}],[\"变大\",{\"1\":{\"364\":1}}],[\"变量和函数\",{\"1\":{\"696\":1}}],[\"变量和函数中会设置好\",{\"1\":{\"686\":1}}],[\"变量实例可直接访问ndarray的核心属性\",{\"1\":{\"689\":1}}],[\"变量名称可在计算图可视化等场景中显示\",{\"1\":{\"689\":1}}],[\"变量的作用是存储数据\",{\"1\":{\"636\":1}}],[\"变量的基本概念\",{\"0\":{\"636\":1}}],[\"变量是tinypytorch最重要的组成部分\",{\"1\":{\"636\":1}}],[\"变量\",{\"1\":{\"340\":1,\"758\":1,\"773\":1}}],[\"变量提升到所在函数\",{\"1\":{\"336\":1}}],[\"变为\",{\"1\":{\"310\":3,\"798\":1}}],[\"变形为\",{\"1\":{\"272\":1}}],[\"变形\",{\"1\":{\"116\":1}}],[\"变换后的输出维度\",{\"1\":{\"544\":1}}],[\"变换后再用欧几里得距离度量\",{\"1\":{\"459\":1}}],[\"变换不变性\",{\"1\":{\"112\":1}}],[\"变换矩阵会通过\",{\"1\":{\"107\":1}}],[\"变成了\",{\"1\":{\"814\":1}}],[\"变成像素级别的\",{\"1\":{\"807\":1}}],[\"变成行向量\",{\"1\":{\"590\":1}}],[\"变成列向量\",{\"1\":{\"590\":1}}],[\"变成1维度之后就成了50176\",{\"1\":{\"318\":1}}],[\"变成\",{\"1\":{\"92\":2,\"111\":1,\"370\":1,\"486\":1,\"618\":1,\"814\":2,\"815\":1}}],[\"变成特征向量\",{\"1\":{\"87\":1}}],[\"决定是否返回所有\",{\"1\":{\"804\":1}}],[\"决定哪些区域更重要\",{\"1\":{\"463\":1}}],[\"决定了输出的信息维度\",{\"1\":{\"413\":1}}],[\"决定\",{\"1\":{\"105\":1,\"385\":1}}],[\"小图像\",{\"1\":{\"878\":10,\"883\":1}}],[\"小型语言模型通常难以解决涉及多个推理步骤的复杂任务\",{\"1\":{\"706\":1}}],[\"小而全\",{\"1\":{\"700\":1}}],[\"小距离用独立桶\",{\"1\":{\"591\":1}}],[\"小模型\",{\"1\":{\"549\":1}}],[\"小模型+更多数据训练可能更优\",{\"1\":{\"547\":1}}],[\"小数据集没有\",{\"1\":{\"516\":1}}],[\"小批次样本\",{\"1\":{\"514\":1}}],[\"小批量训练\",{\"0\":{\"185\":1}}],[\"小孩子根据从示例中学习到的推理\",{\"1\":{\"501\":1}}],[\"小块\",{\"1\":{\"386\":1}}],[\"小batch训练可能需要重新调整超参数\",{\"1\":{\"185\":1}}],[\"小\",{\"1\":{\"173\":2,\"587\":1}}],[\"小结关系图\",{\"1\":{\"831\":1}}],[\"小结\",{\"0\":{\"129\":1,\"294\":1,\"305\":1}}],[\"小扰动不会改变函数输出\",{\"1\":{\"105\":1}}],[\"小红书\",{\"1\":{\"0\":1}}],[\"学完了\",{\"1\":{\"847\":1}}],[\"学\",{\"1\":{\"807\":3}}],[\"学多少\",{\"1\":{\"725\":1,\"757\":1}}],[\"学术数据不足限制mmlu表现\",{\"1\":{\"549\":1}}],[\"学会生成让\",{\"1\":{\"868\":1}}],[\"学会\",{\"1\":{\"530\":1}}],[\"学习的是\",{\"1\":{\"886\":1}}],[\"学习这些离散\",{\"1\":{\"886\":2}}],[\"学习将图像压缩为离散\",{\"1\":{\"886\":1}}],[\"学习一个分布\",{\"1\":{\"847\":1}}],[\"学习笔记\",{\"0\":{\"823\":1,\"888\":1},\"1\":{\"823\":1,\"888\":1}}],[\"学习先验\",{\"0\":{\"809\":1}}],[\"学习先验分布\",{\"1\":{\"773\":1}}],[\"学习视觉码本\",{\"0\":{\"808\":1}}],[\"学习成本高\",{\"1\":{\"788\":1}}],[\"学习通用的语言表示和知识\",{\"1\":{\"705\":1}}],[\"学习到输入数据的非线性特征\",{\"1\":{\"321\":1}}],[\"学习到的特征在下游任务上具有很好的迁移性\",{\"1\":{\"245\":1}}],[\"学习算法需要在所有可能的函数空间中搜索最优模型\",{\"1\":{\"314\":1}}],[\"学习目标\",{\"1\":{\"312\":1}}],[\"学习目标的计算\",{\"1\":{\"278\":1}}],[\"学习目标之前\",{\"1\":{\"278\":1}}],[\"学习目标实现过程\",{\"1\":{\"161\":1,\"162\":1,\"163\":1}}],[\"学习不同模态之间的对齐关系\",{\"1\":{\"268\":1}}],[\"学习上下文表示\",{\"1\":{\"261\":1}}],[\"学习\",{\"1\":{\"248\":1,\"695\":1,\"766\":1,\"886\":1}}],[\"学习温度系数\",{\"1\":{\"160\":1}}],[\"学习共同低维空间\",{\"1\":{\"149\":1}}],[\"学习大模型\",{\"1\":{\"123\":1}}],[\"学习率设为\",{\"1\":{\"774\":1}}],[\"学习率调整\",{\"1\":{\"561\":1}}],[\"学习率调度\",{\"1\":{\"179\":1}}],[\"学习率调度器\",{\"1\":{\"80\":1,\"395\":1}}],[\"学习率调度器初始化等\",{\"1\":{\"80\":1}}],[\"学习率采用线性预热\",{\"1\":{\"560\":1}}],[\"学习率采用线性缩放\",{\"1\":{\"185\":1}}],[\"学习率采用余弦退火策略\",{\"1\":{\"208\":1}}],[\"学习率按\",{\"1\":{\"186\":1}}],[\"学习率预热后分别达到\",{\"1\":{\"131\":1}}],[\"学习率\",{\"1\":{\"10\":1,\"22\":1,\"179\":1,\"186\":2}}],[\"学生模型输出\",{\"1\":{\"186\":1}}],[\"学生模型不能由教师模型直接初始化\",{\"1\":{\"137\":1}}],[\"学生输出按温度缩放\",{\"1\":{\"186\":1}}],[\"学生输出按温度缩放并拆分为每个裁剪的输出\",{\"1\":{\"186\":1}}],[\"学生输出\",{\"1\":{\"186\":1}}],[\"学生温度\",{\"1\":{\"179\":1}}],[\"学生网络看所有裁剪\",{\"1\":{\"186\":1}}],[\"学生网络训练模式\",{\"1\":{\"186\":1}}],[\"学生网络处理所有视角\",{\"1\":{\"178\":1}}],[\"学生网络通过交叉熵损失\",{\"1\":{\"173\":1}}],[\"学生通过最小化交叉熵损失来学习匹配教师的分布\",{\"1\":{\"178\":1}}],[\"学生参数的指数移动平均\",{\"1\":{\"176\":1}}],[\"学生与教师使用相同架构\",{\"1\":{\"176\":1}}],[\"学生和教师完全相同的架构\",{\"1\":{\"175\":1}}],[\"学生\",{\"0\":{\"748\":1},\"1\":{\"123\":1,\"186\":1,\"748\":1}}],[\"学到的是一个关键点集合\",{\"1\":{\"112\":1}}],[\"学到的是一个\",{\"1\":{\"105\":1}}],[\"矩阵维度\",{\"1\":{\"584\":1}}],[\"矩阵又不是\",{\"1\":{\"493\":1}}],[\"矩阵a和b为什么不能同时为零\",{\"0\":{\"493\":1}}],[\"矩阵初始化\",{\"1\":{\"492\":2,\"493\":1}}],[\"矩阵从\",{\"1\":{\"490\":1}}],[\"矩阵w就是通过机器学习\",{\"1\":{\"481\":1}}],[\"矩阵中的对角线元素\",{\"1\":{\"299\":1}}],[\"矩阵所有元素平方和开方\",{\"1\":{\"108\":1}}],[\"矩阵返回\",{\"1\":{\"107\":1}}],[\"矩阵\",{\"1\":{\"105\":2,\"409\":1,\"455\":1,\"492\":1,\"493\":2}}],[\"比直接逐像素生成效果更好\",{\"1\":{\"865\":1}}],[\"比特\",{\"1\":{\"831\":1}}],[\"比\",{\"1\":{\"536\":1,\"704\":1}}],[\"比原sota高出18\",{\"1\":{\"529\":1}}],[\"比原本少了一个多头自注意力\",{\"1\":{\"510\":1}}],[\"比此前最大的非稀疏语言模型大10倍\",{\"1\":{\"527\":1}}],[\"比许多情况下的ensemble模型要好\",{\"1\":{\"515\":1}}],[\"比single\",{\"1\":{\"515\":1}}],[\"比最近邻计算量大\",{\"1\":{\"390\":1}}],[\"比单层电路更高效\",{\"1\":{\"385\":1}}],[\"比较\",{\"1\":{\"885\":1}}],[\"比较它们在iou\",{\"1\":{\"474\":1}}],[\"比较两个分类名词是否相等\",{\"1\":{\"302\":1}}],[\"比较了两种文本生成方式\",{\"1\":{\"133\":1}}],[\"比基于网格特征的模型快至少四倍的推理速度\",{\"1\":{\"280\":1}}],[\"比使用在文本数据上预训练的\",{\"1\":{\"268\":1}}],[\"比例为\",{\"1\":{\"774\":1}}],[\"比例进行的掩码\",{\"1\":{\"581\":1}}],[\"比例等超参数组合上进行对比试验\",{\"1\":{\"204\":1}}],[\"比例\",{\"1\":{\"160\":1}}],[\"比排序\",{\"1\":{\"105\":1}}],[\"比如图像的类别\",{\"1\":{\"885\":1}}],[\"比如图中的\",{\"1\":{\"880\":2}}],[\"比如超分辨率\",{\"1\":{\"883\":1}}],[\"比如pixelcnn\",{\"1\":{\"878\":1}}],[\"比如对于图像\",{\"1\":{\"878\":1}}],[\"比如对于一个长度为\",{\"1\":{\"614\":1}}],[\"比如我们想让画家画一个人\",{\"1\":{\"878\":1}}],[\"比如我们可能想表示这些事件\",{\"1\":{\"728\":1}}],[\"比如最常见的标准正态分布\",{\"1\":{\"878\":1}}],[\"比如把\",{\"1\":{\"873\":1}}],[\"比如导致梯度尺度失衡\",{\"1\":{\"871\":1}}],[\"比如相邻像素颜色相似且共同构成物体\",{\"1\":{\"864\":1}}],[\"比如训练\",{\"1\":{\"821\":1}}],[\"比如从多分类分布中采样一个类别\",{\"1\":{\"795\":1}}],[\"比如只有两个互斥事件\",{\"1\":{\"729\":1}}],[\"比如你能谈\",{\"1\":{\"728\":1}}],[\"比如测量一个时间\",{\"1\":{\"728\":1}}],[\"比如后续我们会将搭建检索问答链来完成检索问答\",{\"1\":{\"713\":1}}],[\"比如取到了问题部分的内容\",{\"1\":{\"616\":1}}],[\"比如让模型偏向关注附近的\",{\"1\":{\"591\":1}}],[\"比如一个表示\",{\"1\":{\"882\":1}}],[\"比如一个头关注短距离\",{\"1\":{\"591\":1}}],[\"比如一张图像\",{\"1\":{\"869\":1}}],[\"比如一张224x224的图片\",{\"1\":{\"318\":1}}],[\"比如小距离\",{\"1\":{\"591\":1}}],[\"比如上面的例子中\",{\"1\":{\"572\":1}}],[\"比如它看到的\",{\"1\":{\"572\":1}}],[\"比如文本蕴涵\",{\"1\":{\"506\":1}}],[\"比如文本的\",{\"1\":{\"392\":1}}],[\"比如身高\",{\"1\":{\"455\":1}}],[\"比如在下图中\",{\"1\":{\"880\":1}}],[\"比如在计算\",{\"1\":{\"853\":1}}],[\"比如在\",{\"1\":{\"426\":1,\"858\":1}}],[\"比如在内存中从一个索引移动到另一个索引时\",{\"1\":{\"423\":1}}],[\"比如多头注意力中可以分别控制每个\",{\"1\":{\"413\":1}}],[\"比如relu\",{\"1\":{\"385\":1}}],[\"比如形状是\",{\"1\":{\"369\":1}}],[\"比如这个函数就是高阶函数\",{\"1\":{\"339\":1}}],[\"比如将\",{\"1\":{\"285\":1}}],[\"比如字典大小是\",{\"1\":{\"250\":1}}],[\"比如标注数据很少的任务\",{\"1\":{\"246\":1}}],[\"比如几万\",{\"1\":{\"246\":1}}],[\"比如bert最后进行的softmax操作\",{\"1\":{\"246\":1}}],[\"比如说在视频领域\",{\"1\":{\"243\":1}}],[\"比如说nceloss\",{\"1\":{\"243\":1}}],[\"比如边缘\",{\"1\":{\"112\":1}}],[\"比如椅子的腿\",{\"1\":{\"111\":1}}],[\"比如椅子朝向不同\",{\"1\":{\"107\":1}}],[\"比如法线\",{\"1\":{\"92\":1}}],[\"比如通过\",{\"1\":{\"92\":1}}],[\"比如颜色\",{\"1\":{\"92\":1}}],[\"比如\",{\"1\":{\"29\":1,\"203\":1,\"248\":1,\"366\":2,\"386\":1,\"387\":2,\"426\":2,\"463\":1,\"578\":1,\"728\":5,\"774\":1,\"800\":1,\"864\":1,\"869\":1,\"879\":1}}],[\"效率突破\",{\"1\":{\"549\":1}}],[\"效率优化\",{\"1\":{\"548\":1}}],[\"效率低的推断方法\",{\"1\":{\"864\":1}}],[\"效率低\",{\"1\":{\"544\":1}}],[\"效率比较低\",{\"1\":{\"483\":1}}],[\"效率\",{\"1\":{\"112\":1}}],[\"效率极低\",{\"1\":{\"76\":1}}],[\"效果是如何变化的\",{\"1\":{\"811\":1}}],[\"效果明显变差\",{\"1\":{\"780\":1}}],[\"效果可能不太理想\",{\"1\":{\"709\":1}}],[\"效果评估\",{\"1\":{\"581\":1}}],[\"效果会比不加这句话要好\",{\"1\":{\"500\":1}}],[\"效果相当惊人\",{\"1\":{\"488\":1}}],[\"效果已经非常好了\",{\"1\":{\"488\":1}}],[\"效果越显著\",{\"1\":{\"470\":1}}],[\"效果如下\",{\"1\":{\"463\":1}}],[\"效果对比\",{\"0\":{\"324\":1}}],[\"效果最佳\",{\"1\":{\"178\":1}}],[\"效果不错\",{\"1\":{\"178\":1}}],[\"效果验证\",{\"0\":{\"132\":1}}],[\"效果\",{\"0\":{\"582\":1},\"1\":{\"105\":3,\"198\":3,\"236\":2,\"717\":1,\"817\":1,\"840\":1}}],[\"整个序列的总长度\",{\"1\":{\"817\":1}}],[\"整个生成过程可以想成\",{\"1\":{\"807\":1}}],[\"整个\",{\"1\":{\"774\":1}}],[\"整个样本空间的概率为\",{\"1\":{\"729\":1}}],[\"整个样本空间\",{\"1\":{\"728\":1}}],[\"整个互联网一样\",{\"1\":{\"703\":1}}],[\"整个句子\",{\"1\":{\"621\":1}}],[\"整个过程中\",{\"1\":{\"575\":1}}],[\"整个注意力的\",{\"1\":{\"544\":1}}],[\"整个函数\",{\"1\":{\"105\":1}}],[\"整除\",{\"1\":{\"463\":1}}],[\"整数子集上的一些离散型概率分布\",{\"1\":{\"736\":1}}],[\"整数或\",{\"1\":{\"398\":1}}],[\"整数\",{\"1\":{\"318\":2}}],[\"整体仍在合理区间\",{\"1\":{\"815\":1}}],[\"整体效果\",{\"1\":{\"796\":1}}],[\"整体得分72\",{\"1\":{\"515\":1}}],[\"整体模型还是比较大的\",{\"1\":{\"327\":1}}],[\"整体结构图如下\",{\"1\":{\"327\":1}}],[\"整体流程可以被视作在最大化模型分布在图像\",{\"1\":{\"807\":1}}],[\"整体流程\",{\"1\":{\"591\":1}}],[\"整体流程总览\",{\"0\":{\"289\":1}}],[\"整体流程和albef模型实现一致\",{\"1\":{\"147\":1}}],[\"整体框架与近年来的自监督学习方法类似\",{\"1\":{\"178\":1}}],[\"整体而言\",{\"1\":{\"167\":1}}],[\"整体来看\",{\"1\":{\"129\":1}}],[\"整理\",{\"1\":{\"33\":1}}],[\"γ2\",{\"1\":{\"272\":2}}],[\"γ1\",{\"1\":{\"272\":2}}],[\"γ\",{\"1\":{\"105\":2,\"470\":3,\"537\":1}}],[\"≈\",{\"1\":{\"105\":1,\"159\":2,\"801\":2,\"815\":2,\"817\":1}}],[\"聚焦难分类样本\",{\"1\":{\"470\":1}}],[\"聚焦参数\",{\"1\":{\"78\":1,\"470\":2}}],[\"聚类式方法\",{\"1\":{\"175\":1}}],[\"聚类簇数\",{\"1\":{\"170\":1}}],[\"聚类的标准迭代流程\",{\"1\":{\"170\":1}}],[\"聚合了所有\",{\"1\":{\"410\":1}}],[\"聚合全局信息\",{\"1\":{\"165\":1}}],[\"聚合所有点的信息\",{\"1\":{\"105\":1,\"112\":1}}],[\"稀疏向量处理好\",{\"1\":{\"393\":1}}],[\"稀疏性强\",{\"1\":{\"114\":1}}],[\"稀疏点云等任务中表现受限\",{\"1\":{\"112\":1}}],[\"稀疏点云下性能差\",{\"1\":{\"112\":1}}],[\"稀疏\",{\"1\":{\"104\":1}}],[\"难于训练\",{\"1\":{\"491\":1}}],[\"难样本\",{\"1\":{\"470\":1}}],[\"难样本vs易样\",{\"1\":{\"470\":1}}],[\"难分类样本\",{\"1\":{\"470\":1}}],[\"难负样本\",{\"1\":{\"162\":1}}],[\"难负样本采样\",{\"1\":{\"145\":1}}],[\"难以还原原始数据\",{\"1\":{\"871\":1}}],[\"难以做到的\",{\"1\":{\"588\":1}}],[\"难以准确表示极长序列中各个位置的独特信息\",{\"1\":{\"587\":1}}],[\"难以覆盖广泛的语言任务\",{\"1\":{\"527\":1}}],[\"难以学习有效特征\",{\"1\":{\"470\":1}}],[\"难以局部修正\",{\"1\":{\"385\":1}}],[\"难以提升模型泛化能力\",{\"1\":{\"133\":1}}],[\"难以自动构建\",{\"1\":{\"114\":1}}],[\"难以用\",{\"1\":{\"114\":1}}],[\"难以建模更高维度的空间关系\",{\"1\":{\"112\":1}}],[\"难以捕捉非刚性变换下的不变性\",{\"1\":{\"112\":1}}],[\"难以区分语义相近但位置不同的区域\",{\"1\":{\"112\":1}}],[\"难以泛化到未见过的功能\",{\"1\":{\"6\":1}}],[\"难点\",{\"0\":{\"104\":1},\"1\":{\"105\":4}}],[\"避免再求\",{\"1\":{\"853\":1}}],[\"避免极端数值\",{\"1\":{\"820\":1}}],[\"避免直接用\",{\"1\":{\"819\":1}}],[\"避免直接引用导致循环\",{\"1\":{\"687\":1}}],[\"避免信息泄漏\",{\"1\":{\"801\":1}}],[\"避免\",{\"1\":{\"794\":1,\"798\":1,\"800\":1}}],[\"避免出现在预训练数据中\",{\"1\":{\"781\":1}}],[\"避免内存长期占用\",{\"1\":{\"688\":1}}],[\"避免内存泄漏\",{\"1\":{\"687\":1}}],[\"避免增加对象的引用计数\",{\"1\":{\"687\":1}}],[\"避免强引用导致的内存滞留\",{\"1\":{\"687\":1}}],[\"避免栈溢出\",{\"1\":{\"669\":1}}],[\"避免重复计算或存储额外数据\",{\"1\":{\"660\":1}}],[\"避免过拟合\",{\"1\":{\"562\":1}}],[\"避免过度拉伸\",{\"1\":{\"224\":1}}],[\"避免存储注意力权重\",{\"1\":{\"548\":1}}],[\"避免偏见与毒性\",{\"1\":{\"537\":1}}],[\"避免生成非结尾词\",{\"1\":{\"522\":1}}],[\"避免与webtext重叠\",{\"1\":{\"522\":1}}],[\"避免传统\",{\"1\":{\"521\":1}}],[\"避免复杂的编码需求\",{\"1\":{\"495\":1}}],[\"避免单一损失可能带来的训练不稳定性\",{\"1\":{\"473\":1}}],[\"避免训练震荡\",{\"1\":{\"468\":1}}],[\"避免使用不平衡的数据集\",{\"1\":{\"447\":1}}],[\"避免为每个像素单独建模\",{\"1\":{\"385\":1}}],[\"避免选中正样本作为负样本\",{\"1\":{\"278\":1}}],[\"避免选到自己\",{\"1\":{\"147\":1}}],[\"避免罕见组合\",{\"1\":{\"234\":1}}],[\"避免学生只学到平凡的输入匹配\",{\"1\":{\"186\":1}}],[\"避免塌缩\",{\"1\":{\"186\":1}}],[\"避免崩溃\",{\"0\":{\"183\":1}}],[\"避免了人为加\",{\"1\":{\"853\":1}}],[\"避免了手工设计基函数的局限性\",{\"1\":{\"385\":1}}],[\"避免了只通过单词上下文进行预测\",{\"1\":{\"285\":1}}],[\"避免了巨量类别的学习\",{\"1\":{\"175\":1}}],[\"避免了复杂的预处理\",{\"1\":{\"103\":1}}],[\"避免除零\",{\"1\":{\"170\":1}}],[\"避免除以零\",{\"1\":{\"100\":1}}],[\"避免数值尺度差异\",{\"1\":{\"170\":1}}],[\"避免数值错误的小常数\",{\"1\":{\"169\":1}}],[\"避免模型过拟合于极端负样本或伪负样本\",{\"1\":{\"162\":1}}],[\"避免采样到自己\",{\"1\":{\"162\":1}}],[\"避免因忘记重置配置导致的错误\",{\"1\":{\"688\":1}}],[\"避免因gc延迟导致的内存问题\",{\"1\":{\"687\":1}}],[\"避免因\",{\"1\":{\"157\":1}}],[\"只会用到式子的梯度\",{\"1\":{\"881\":1}}],[\"只会执行一次\",{\"1\":{\"170\":1}}],[\"只出现在公式右边的第二项中\",{\"1\":{\"873\":1}}],[\"只出现了几次\",{\"1\":{\"442\":1}}],[\"只允许卷积核看到左边和上方的像素\",{\"1\":{\"846\":1}}],[\"只算一个像素的概率分布还称不上高效\",{\"1\":{\"843\":1}}],[\"只关心最后一个\",{\"1\":{\"817\":1}}],[\"只关注如何把图像变成\",{\"1\":{\"773\":1}}],[\"只关注全局结构\",{\"1\":{\"112\":1}}],[\"只利用模型自身\",{\"1\":{\"816\":1}}],[\"只靠自身学到的\",{\"1\":{\"816\":1}}],[\"只展示第一个\",{\"1\":{\"814\":1}}],[\"只展示核心代码\",{\"1\":{\"544\":1}}],[\"只针对被\",{\"1\":{\"803\":1}}],[\"只返回重建图像\",{\"1\":{\"794\":1}}],[\"只开源了\",{\"1\":{\"704\":1}}],[\"只能保留全局信息\",{\"1\":{\"885\":1}}],[\"只能很好地完成图像压缩\",{\"1\":{\"878\":1}}],[\"只能起到把图像压缩的作用\",{\"1\":{\"878\":1}}],[\"只能学习如何根据某种隐变量\",{\"1\":{\"869\":1}}],[\"只能依赖于它左上方的像素\",{\"1\":{\"848\":1}}],[\"只能用\",{\"1\":{\"846\":1}}],[\"只能看\",{\"1\":{\"846\":2}}],[\"只能预测文本\",{\"1\":{\"820\":1}}],[\"只能最大化它的证据下界\",{\"1\":{\"807\":1}}],[\"只能实现一条竖线形状的计算图结构的反向传播\",{\"1\":{\"665\":1}}],[\"只能对输入文本中的\",{\"1\":{\"616\":1}}],[\"只能处理刚性变换\",{\"1\":{\"112\":1}}],[\"只做抽取式问答\",{\"1\":{\"616\":1}}],[\"只计算在第\",{\"1\":{\"572\":1}}],[\"只计算新\",{\"1\":{\"544\":1}}],[\"只为当前传入的词生成位置序列\",{\"1\":{\"544\":1}}],[\"只达到了56\",{\"1\":{\"515\":1}}],[\"只不过它是\",{\"1\":{\"817\":1}}],[\"只不过它们的具体实现上有一些差异\",{\"1\":{\"486\":1}}],[\"只不过是对每个字都要预测一个类别\",{\"1\":{\"575\":1}}],[\"只不过类别和所有样本相比\",{\"1\":{\"248\":1}}],[\"只包含\",{\"1\":{\"431\":1,\"616\":1}}],[\"只适用于连续内存的张量\",{\"1\":{\"361\":1}}],[\"只交换两个指定维度\",{\"1\":{\"359\":1}}],[\"只有空间掩码卷积\",{\"1\":{\"886\":1}}],[\"只有一个自由参数\",{\"1\":{\"752\":2}}],[\"只有一个\",{\"1\":{\"544\":1}}],[\"只有一个特殊标记\",{\"1\":{\"319\":1,\"320\":1,\"323\":1}}],[\"只有2490样本\",{\"1\":{\"515\":1}}],[\"只有\",{\"1\":{\"399\":1,\"492\":1,\"704\":2,\"752\":1}}],[\"只有原始维度\",{\"1\":{\"364\":1}}],[\"只有遇到换行符或者输出内容积累到一定大小时\",{\"1\":{\"83\":1}}],[\"只执行一次\",{\"1\":{\"274\":1}}],[\"只完成了借助卷积对图像进行前置处理的步骤\",{\"1\":{\"272\":1}}],[\"只需从标准正态分布中采样\",{\"1\":{\"869\":1}}],[\"只需优化训练策略即可达到sota\",{\"1\":{\"567\":1}}],[\"只需提供极少量的示例就能成功完成\",{\"1\":{\"529\":1}}],[\"只需将这些步长交换为\",{\"1\":{\"426\":1}}],[\"只需要去除cls\",{\"1\":{\"603\":1}}],[\"只需要计算当前轮新增\",{\"1\":{\"544\":1}}],[\"只需要计算\",{\"1\":{\"492\":1}}],[\"只需要微调\",{\"1\":{\"492\":1}}],[\"只需要48gb\",{\"1\":{\"488\":1}}],[\"只需要用一个一个linear即可\",{\"1\":{\"323\":1}}],[\"只需要将图像调整到合适的大小\",{\"1\":{\"317\":1}}],[\"只需要告知父类自己的数据集名和数据集类的具体实现即可\",{\"1\":{\"274\":1}}],[\"只需要\",{\"1\":{\"250\":1}}],[\"只需一次遍历下游数据集即可完成评估\",{\"1\":{\"179\":1}}],[\"只训练降维矩阵\",{\"1\":{\"492\":1}}],[\"只训练最后的全连接层\",{\"1\":{\"245\":1}}],[\"只训练少量\",{\"1\":{\"239\":1}}],[\"只要ae的编码空间比较规整\",{\"1\":{\"878\":1}}],[\"只要我们拥有足够高容量\",{\"1\":{\"871\":1}}],[\"只要这样的结构有助于拟合训练数据\",{\"1\":{\"866\":1}}],[\"只要知道\",{\"1\":{\"590\":1}}],[\"只要其隐藏层神经元的数量足够\",{\"1\":{\"385\":1}}],[\"只要相邻两行完全相同就会合并\",{\"1\":{\"372\":1}}],[\"只要你能够得到一个判断正样本和负样本的规律\",{\"1\":{\"243\":1}}],[\"只要关键点还在\",{\"1\":{\"105\":1}}],[\"只更新投影层\",{\"1\":{\"235\":1}}],[\"只保留最后一个\",{\"1\":{\"815\":1}}],[\"只保留最多\",{\"1\":{\"234\":1}}],[\"只保留\",{\"1\":{\"804\":2}}],[\"只保留一个\",{\"1\":{\"684\":1}}],[\"只保留一定百分比的注意力质量\",{\"1\":{\"463\":1}}],[\"只保留输出\",{\"1\":{\"463\":1}}],[\"只保留生成部分\",{\"1\":{\"143\":1}}],[\"只是用\",{\"1\":{\"845\":1}}],[\"只是直接加到注意力分数上\",{\"1\":{\"591\":1}}],[\"只是一个占位符而已\",{\"1\":{\"575\":1}}],[\"只是在推理的过程中\",{\"1\":{\"486\":1}}],[\"只是侧重点不一样\",{\"1\":{\"483\":1}}],[\"只是访问方式变了\",{\"1\":{\"426\":1}}],[\"只是结构上简化了多模态学习\",{\"1\":{\"286\":1}}],[\"只是建立中间模型的一种方式\",{\"1\":{\"246\":1}}],[\"只是参数经过调整以更好响应指令\",{\"1\":{\"232\":1}}],[\"只是温度为\",{\"1\":{\"178\":1}}],[\"只在这些\",{\"1\":{\"728\":1}}],[\"只在推导式内部有效\",{\"1\":{\"336\":1}}],[\"只在主进程调用一次\",{\"1\":{\"274\":1}}],[\"只在\",{\"1\":{\"163\":1,\"277\":1,\"398\":1,\"591\":1,\"804\":1}}],[\"只对低秩矩阵\",{\"1\":{\"490\":1}}],[\"只对被\",{\"1\":{\"163\":1}}],[\"只对应一个\",{\"1\":{\"145\":1}}],[\"只改变物体的方向\",{\"1\":{\"117\":1}}],[\"只改变位置和朝向\",{\"1\":{\"116\":1}}],[\"只学正交变换\",{\"1\":{\"112\":1}}],[\"只通过\",{\"1\":{\"112\":1}}],[\"只取绝对值\",{\"1\":{\"591\":1}}],[\"只取cls\",{\"1\":{\"145\":2}}],[\"只取\",{\"1\":{\"101\":1}}],[\"那我们就可以从这个分布里随机采样向量\",{\"1\":{\"878\":1}}],[\"那我们就认为\",{\"1\":{\"575\":1}}],[\"那只能靠\",{\"1\":{\"873\":1}}],[\"那它们的并集和交集也得能谈\",{\"1\":{\"728\":1}}],[\"那它的补集你也得能谈\",{\"1\":{\"728\":1}}],[\"那\",{\"1\":{\"728\":2}}],[\"那就需要使用生成式模型\",{\"1\":{\"616\":1}}],[\"那就一起用\",{\"1\":{\"100\":1}}],[\"那不就矛盾了吗\",{\"1\":{\"575\":1}}],[\"那很有可能就是我们最终的答案\",{\"1\":{\"502\":1}}],[\"那为什么还要有个qlora呢\",{\"1\":{\"488\":1}}],[\"那个图片的特征\",{\"1\":{\"248\":1}}],[\"那么恭喜你\",{\"1\":{\"883\":1}}],[\"那么我们用高斯近似的\",{\"1\":{\"871\":1}}],[\"那么我们该如何对公式\",{\"1\":{\"868\":1}}],[\"那么我当前图片经过数据增强之后\",{\"1\":{\"248\":1}}],[\"那么网络就只输出\",{\"1\":{\"847\":1}}],[\"那么采样出来的图像应该也接近灰色\",{\"1\":{\"756\":1}}],[\"那么一共有\",{\"1\":{\"762\":1}}],[\"那么一个事件的发生不会改变另一个事件的概率\",{\"1\":{\"730\":1}}],[\"那么一致性是如何做到的\",{\"1\":{\"246\":1}}],[\"那么值减少最快的方向是\",{\"1\":{\"697\":1}}],[\"那么f\",{\"1\":{\"682\":1}}],[\"那么function可能会放大或者缩小x对输出y大小变化的影响\",{\"1\":{\"656\":1}}],[\"那么此时影响因子r=\",{\"1\":{\"656\":1}}],[\"那么影响因子r恒为1\",{\"1\":{\"656\":1}}],[\"那么对于任意事件\",{\"1\":{\"731\":1}}],[\"那么对应的就是单词\",{\"1\":{\"616\":1}}],[\"那么对比学习的过程\",{\"1\":{\"246\":1}}],[\"那么可以组合这两个索引得到答案\",{\"1\":{\"614\":1}}],[\"那么它们都和\",{\"1\":{\"837\":1}}],[\"那么它们的相对位置信息也是相同的\",{\"1\":{\"589\":1}}],[\"那么它从\",{\"1\":{\"581\":2}}],[\"那么它就需要具有同时处理图像和文本的能力\",{\"1\":{\"272\":1}}],[\"那么这个误差项趋近于\",{\"1\":{\"867\":1}}],[\"那么这个\",{\"1\":{\"575\":1}}],[\"那么上面的梯度就变成了\",{\"1\":{\"493\":1}}],[\"那么矩阵\",{\"1\":{\"493\":1}}],[\"那么那些小公司或者个人\",{\"1\":{\"491\":1}}],[\"那么prompt\",{\"1\":{\"485\":1}}],[\"那么搭建自己的大模型就非常必要\",{\"1\":{\"482\":1}}],[\"那么协方差矩阵就是\",{\"1\":{\"459\":1}}],[\"那么前者的变化会主导整个距离\",{\"1\":{\"459\":1}}],[\"那么最终输出为\",{\"1\":{\"415\":1}}],[\"那么作者就想把注意力得到的结果\",{\"1\":{\"325\":1}}],[\"那么就存在很多种函数\",{\"1\":{\"871\":1}}],[\"那么就会导致模态混乱了\",{\"1\":{\"814\":1}}],[\"那么就会得到个文本特征\",{\"1\":{\"300\":1}}],[\"那么就得到了多项分布\",{\"1\":{\"738\":1}}],[\"那么就把该\",{\"1\":{\"386\":1}}],[\"那么就是一个\",{\"1\":{\"115\":1}}],[\"那么clip的训练目标就是最大个正样本的相似度\",{\"1\":{\"299\":1}}],[\"那么抽出三个来\",{\"1\":{\"250\":1}}],[\"那么除了我当前这个图片外\",{\"1\":{\"248\":1}}],[\"那么是什么意义呢\",{\"1\":{\"248\":1}}],[\"那么有一个问题\",{\"1\":{\"248\":1}}],[\"那么从中抽样的可能性组合就很多\",{\"1\":{\"246\":1}}],[\"那么字典最好需要满足两个条件\",{\"1\":{\"246\":1}}],[\"那么字典中的每个key就是一个类别\",{\"1\":{\"246\":1}}],[\"那么负样本走哪个编码器呢\",{\"1\":{\"246\":1}}],[\"那么\",{\"1\":{\"244\":1,\"248\":1,\"250\":1,\"300\":1,\"318\":1,\"473\":1,\"587\":1,\"684\":1,\"727\":1,\"758\":1,\"761\":1,\"838\":1,\"839\":1,\"871\":3,\"878\":1}}],[\"那样存整个向量矩阵\",{\"1\":{\"591\":1}}],[\"那样偏向背景点\",{\"1\":{\"469\":1}}],[\"那样对负样本过多敏感\",{\"1\":{\"467\":1}}],[\"那样的\",{\"1\":{\"336\":1}}],[\"那样我们总共有196个向量\",{\"1\":{\"318\":1}}],[\"那样\",{\"1\":{\"277\":1}}],[\"那样逐层提取多层次的抽象特征\",{\"1\":{\"112\":1}}],[\"那样依赖\",{\"1\":{\"82\":1}}],[\"给一个真实样本\",{\"1\":{\"869\":1}}],[\"给两个概率分布\",{\"1\":{\"836\":1}}],[\"给每个普通词分配索引\",{\"1\":{\"578\":1}}],[\"给每个实例样本加一个\",{\"1\":{\"516\":1}}],[\"给每个点\",{\"1\":{\"112\":1}}],[\"给出了直观的样本统计量作为参数估计\",{\"1\":{\"826\":1}}],[\"给出了完整的超参数描述\",{\"1\":{\"808\":1}}],[\"给出一定图像引导\",{\"1\":{\"817\":1}}],[\"给出的\",{\"1\":{\"798\":1}}],[\"给出问题和上下文\",{\"1\":{\"616\":1}}],[\"给出较为合理的解释\",{\"1\":{\"538\":1}}],[\"给出最大化的目标函数为\",{\"1\":{\"511\":1}}],[\"给出概率最大的结果\",{\"1\":{\"497\":1}}],[\"给llm更多的时间去思考\",{\"0\":{\"500\":1},\"1\":{\"500\":2}}],[\"给多个数组\",{\"1\":{\"398\":1}}],[\"给图像\",{\"1\":{\"277\":1}}],[\"给图像配上错误文本\",{\"1\":{\"274\":1}}],[\"给文本和图像\",{\"1\":{\"276\":1}}],[\"给文本配上错误图像\",{\"1\":{\"274\":1}}],[\"给\",{\"1\":{\"274\":1}}],[\"给这3个邻近点分配权重\",{\"1\":{\"100\":1}}],[\"给定输入\",{\"1\":{\"874\":1}}],[\"给定隐变量\",{\"1\":{\"854\":1}}],[\"给定下观测到该样本的联合概率或概率密度\",{\"1\":{\"826\":1}}],[\"给定一张用户已经去除了不需要物体的图像\",{\"1\":{\"874\":1}}],[\"给定一张输入图像\",{\"1\":{\"767\":1,\"772\":1}}],[\"给定一条文字描述和一张候选图像\",{\"1\":{\"811\":1}}],[\"给定一对文本\",{\"1\":{\"809\":1}}],[\"给定一个符号序列\",{\"1\":{\"521\":1}}],[\"给定一个无监督学习的语料tokens\",{\"1\":{\"510\":1}}],[\"给定一个图像\",{\"1\":{\"263\":1}}],[\"给定一个点云\",{\"1\":{\"98\":1}}],[\"给定一个\",{\"1\":{\"70\":1,\"265\":1}}],[\"给定某个输出值\",{\"1\":{\"727\":1}}],[\"给定某个状态\",{\"1\":{\"727\":1}}],[\"给定文档\",{\"1\":{\"512\":1}}],[\"给定图像\",{\"1\":{\"262\":1}}],[\"给定两个超参数\",{\"1\":{\"90\":1}}],[\"说白了\",{\"1\":{\"244\":1}}],[\"说明两个人相距越远\",{\"1\":{\"837\":1}}],[\"说明遮挡带来的表示学习能力是关键\",{\"1\":{\"780\":1}}],[\"说明偏好并非训练数据过拟合造成\",{\"1\":{\"538\":1}}],[\"说明标注者之间达成了较高的一致性\",{\"1\":{\"537\":1}}],[\"说明你更讨厌\",{\"1\":{\"471\":2}}],[\"说明它们强烈正相关\",{\"1\":{\"455\":1}}],[\"说明是原地修改\",{\"1\":{\"371\":1}}],[\"说明视觉语言专家有助于捕获更多的模态交互信息\",{\"1\":{\"268\":1}}],[\"说明\",{\"1\":{\"236\":1,\"294\":1,\"336\":1,\"343\":1,\"388\":1,\"390\":1,\"399\":1,\"425\":1,\"459\":1}}],[\"说明其任务执行能力更强\",{\"1\":{\"538\":1}}],[\"说明其确实有效增强了语言\",{\"1\":{\"75\":1}}],[\"说明其具备良好的泛化能力与鲁棒性\",{\"1\":{\"25\":1}}],[\"说话越有分量\",{\"1\":{\"100\":1}}],[\"维离散值\",{\"1\":{\"807\":1}}],[\"维的\",{\"1\":{\"848\":1}}],[\"维的向量\",{\"1\":{\"804\":1}}],[\"维的向量空间中\",{\"1\":{\"590\":1}}],[\"维的概率分布\",{\"1\":{\"178\":1}}],[\"维求和\",{\"1\":{\"590\":1}}],[\"维持\",{\"1\":{\"538\":1}}],[\"维内部隐藏层\",{\"1\":{\"514\":1}}],[\"维隐藏层\",{\"1\":{\"514\":1}}],[\"维是\",{\"1\":{\"364\":3}}],[\"维第\",{\"1\":{\"355\":1}}],[\"维和第\",{\"1\":{\"318\":1}}],[\"维护队列状态的代码实现如下所示\",{\"1\":{\"257\":1}}],[\"维护一个队列\",{\"1\":{\"246\":1}}],[\"维\",{\"1\":{\"255\":1,\"318\":1,\"590\":3,\"808\":1,\"848\":1}}],[\"维空间\",{\"1\":{\"186\":1}}],[\"维特征\",{\"1\":{\"100\":1}}],[\"维度通常为\",{\"1\":{\"885\":1}}],[\"维度间的复杂依赖会增加难度\",{\"1\":{\"865\":1}}],[\"维度是原始图像的通道数\",{\"1\":{\"821\":1}}],[\"维度是\",{\"1\":{\"821\":1}}],[\"维度从\",{\"1\":{\"815\":1}}],[\"维度可广播\",{\"1\":{\"591\":1}}],[\"维度的参数\",{\"1\":{\"588\":1}}],[\"维度的编码值的变化\",{\"1\":{\"587\":1}}],[\"维度的比例\",{\"1\":{\"272\":1}}],[\"维度统一\",{\"1\":{\"544\":1}}],[\"维度问题\",{\"0\":{\"428\":1}}],[\"维度相同\",{\"1\":{\"391\":1}}],[\"维度友好\",{\"1\":{\"385\":1}}],[\"维度灾难\",{\"1\":{\"385\":1}}],[\"维度诅咒的缓解\",{\"1\":{\"385\":1}}],[\"维度变换\",{\"1\":{\"370\":1}}],[\"维度变为\",{\"1\":{\"310\":1}}],[\"维度规则\",{\"1\":{\"367\":1}}],[\"维度必须兼容\",{\"1\":{\"364\":1}}],[\"维度为\",{\"1\":{\"252\":1,\"309\":2,\"310\":2,\"311\":9,\"316\":1}}],[\"维度求和\",{\"1\":{\"76\":1}}],[\"维度\",{\"1\":{\"46\":1,\"67\":1,\"76\":3,\"100\":1,\"105\":1,\"112\":2,\"186\":1,\"250\":1,\"272\":5,\"410\":2,\"423\":4,\"590\":2,\"591\":1,\"814\":1,\"820\":1,\"821\":1,\"886\":3}}],[\"维度扩展到64\",{\"1\":{\"36\":1}}],[\"维度同上\",{\"1\":{\"30\":1}}],[\"维度展平\",{\"1\":{\"30\":1}}],[\"找到最大概率的\",{\"1\":{\"796\":1}}],[\"找到最近的3个邻近点\",{\"1\":{\"100\":1}}],[\"找到\",{\"1\":{\"717\":1}}],[\"找到了rosenbrock函数最小值的位置\",{\"1\":{\"697\":1}}],[\"找到它在输入图像对应的浮点坐标\",{\"1\":{\"390\":1}}],[\"找到它在输入中的\",{\"1\":{\"389\":1}}],[\"找到它最近的\",{\"1\":{\"100\":1}}],[\"找到与文本最匹配的图片\",{\"1\":{\"303\":1,\"304\":1}}],[\"找到其特征的\",{\"1\":{\"179\":1}}],[\"找到每个样本最近的中心\",{\"1\":{\"170\":1}}],[\"找到邻居\",{\"1\":{\"100\":1}}],[\"找出它在嵌入空间里的最近邻\",{\"1\":{\"880\":1}}],[\"找出它周围距离小于\",{\"1\":{\"92\":1}}],[\"找出最可能是\",{\"1\":{\"614\":1}}],[\"找出最近的3个邻近点\",{\"1\":{\"100\":1}}],[\"找出该尺度下每个质心点周围的邻近点\",{\"1\":{\"96\":1}}],[\"找出每个点的局部邻近点\",{\"1\":{\"92\":1}}],[\"欧几里得距离适合所有维度的尺度和方差差不多时\",{\"1\":{\"460\":1}}],[\"欧几里得距离计算方式\",{\"1\":{\"459\":1}}],[\"欧几里得距离\",{\"0\":{\"457\":1}}],[\"欧氏距离计算\",{\"1\":{\"885\":1}}],[\"欧氏距离\",{\"1\":{\"170\":1}}],[\"欧氏距离平方\",{\"1\":{\"100\":1}}],[\"欧式距离的均匀性假设\",{\"1\":{\"90\":1}}],[\"格式化\",{\"1\":{\"715\":1}}],[\"格式为\",{\"1\":{\"143\":1}}],[\"格式\",{\"1\":{\"100\":1,\"804\":1}}],[\"格式输出\",{\"1\":{\"40\":1}}],[\"←\",{\"1\":{\"99\":3}}],[\"少量则通过\",{\"1\":{\"537\":1}}],[\"少量点无法覆盖关键结构\",{\"1\":{\"112\":1}}],[\"少量点的坐标\",{\"1\":{\"100\":1}}],[\"少样本学习\",{\"1\":{\"528\":1}}],[\"少样本任务迁移\",{\"1\":{\"239\":1}}],[\"少\",{\"1\":{\"98\":1}}],[\"墙壁等\",{\"1\":{\"98\":1}}],[\"椅子\",{\"1\":{\"98\":1,\"101\":1}}],[\"椅子对应的点云一共1000个\",{\"1\":{\"29\":1}}],[\"完善的工具使用\",{\"1\":{\"704\":1}}],[\"完善框架的模块结构\",{\"1\":{\"695\":1}}],[\"完全协方差矩阵\",{\"1\":{\"752\":1}}],[\"完全依赖语言模型对任务上下文的理解能力\",{\"1\":{\"521\":1}}],[\"完全随机猜测的\",{\"1\":{\"451\":1}}],[\"完全支持\",{\"1\":{\"112\":1}}],[\"完美的模型在某个阈值下的\",{\"1\":{\"450\":1}}],[\"完美的模型不会产生假正例\",{\"1\":{\"445\":1}}],[\"完美的模型没有假正例和假负例\",{\"1\":{\"443\":1}}],[\"完成预处理后\",{\"1\":{\"717\":1}}],[\"完成了自动微分的核心算法\",{\"1\":{\"678\":1}}],[\"完成特定任务\",{\"1\":{\"239\":1}}],[\"完成点云分割任务的过程是一个典型的\",{\"1\":{\"98\":1}}],[\"完成\",{\"1\":{\"97\":1,\"170\":1,\"274\":2,\"544\":1,\"717\":1}}],[\"完整架构见附录\",{\"1\":{\"809\":1}}],[\"完整的代码实现部分\",{\"1\":{\"580\":1}}],[\"完整的单尺度分组分类流程为\",{\"1\":{\"93\":1}}],[\"完整代码\",{\"0\":{\"304\":1}}],[\"完整代码实现如下\",{\"1\":{\"186\":1}}],[\"完整方法\",{\"1\":{\"82\":1}}],[\"要是可以把\",{\"1\":{\"881\":1}}],[\"要么在某处发生跳跃\",{\"1\":{\"868\":1}}],[\"要么忽略\",{\"1\":{\"868\":1}}],[\"要么对所有点做操作\",{\"1\":{\"86\":1}}],[\"要么对一个点做操作\",{\"1\":{\"86\":1}}],[\"要排除错误样本\",{\"1\":{\"866\":1}}],[\"要先输入空图像\",{\"1\":{\"847\":1}}],[\"要根据第\",{\"1\":{\"843\":1}}],[\"要接近先验分布\",{\"1\":{\"807\":1}}],[\"要求是\",{\"1\":{\"821\":1}}],[\"要求编码器的输出分布\",{\"1\":{\"807\":1}}],[\"要求\",{\"1\":{\"807\":1}}],[\"要求最小包含\",{\"1\":{\"772\":1}}],[\"要求目录结构为\",{\"1\":{\"186\":1}}],[\"要实现这一点\",{\"1\":{\"759\":1}}],[\"要知道\",{\"1\":{\"727\":1}}],[\"要知道像\",{\"1\":{\"491\":1}}],[\"要和分解的问题\",{\"1\":{\"503\":1}}],[\"要具体\",{\"0\":{\"499\":1}}],[\"要明确\",{\"0\":{\"499\":1}}],[\"要让llm给出的结果尽可能地合理\",{\"1\":{\"497\":1}}],[\"要想开发自己的大模型几乎不可能\",{\"1\":{\"491\":1}}],[\"要想在自己的服务中接入大模型的能力\",{\"1\":{\"482\":1}}],[\"要训练一个特定的模型\",{\"1\":{\"487\":1}}],[\"要适配特定的下游任务\",{\"1\":{\"487\":1}}],[\"要在个性化的服务中使用大模型的能力\",{\"1\":{\"482\":1}}],[\"要对大模型进行微调\",{\"1\":{\"482\":1}}],[\"要退出当前激活的环境\",{\"1\":{\"433\":1}}],[\"要跳到下一列只需要移动\",{\"1\":{\"423\":1}}],[\"要跳到下一行需要移动\",{\"1\":{\"423\":1}}],[\"要跳到下一个通道需要移动\",{\"1\":{\"423\":1}}],[\"要跳到下一个\",{\"1\":{\"423\":1}}],[\"要逼近复杂函数\",{\"1\":{\"385\":1}}],[\"要加到\",{\"1\":{\"379\":2}}],[\"要分成的块数\",{\"1\":{\"374\":1}}],[\"要注册的张量\",{\"1\":{\"366\":1}}],[\"要采样的质心点数量\",{\"1\":{\"96\":1}}],[\"之一\",{\"1\":{\"704\":1}}],[\"之前\",{\"1\":{\"591\":1}}],[\"之前的工作提出了在迁移表征顶部学习特定任务的架构\",{\"1\":{\"512\":1}}],[\"之前的工作中\",{\"1\":{\"249\":1}}],[\"之前已经有一些研究工作探讨了使用文本作为监督信号来训练视觉模型\",{\"1\":{\"305\":1}}],[\"之前也有很多优秀的无监督工作\",{\"1\":{\"246\":1}}],[\"之间切换\",{\"1\":{\"704\":1}}],[\"之间可能提供最佳平衡\",{\"1\":{\"453\":1}}],[\"之间生成\",{\"1\":{\"332\":1}}],[\"之间仍存在显著差距\",{\"1\":{\"216\":1}}],[\"之间的差异\",{\"1\":{\"867\":1}}],[\"之间的差距\",{\"1\":{\"808\":1}}],[\"之间的\",{\"1\":{\"798\":1,\"809\":1}}],[\"之间的距离\",{\"1\":{\"589\":1,\"784\":1,\"832\":1,\"854\":1}}],[\"之间的损失权重\",{\"1\":{\"470\":2}}],[\"之间的夹角\",{\"1\":{\"391\":1}}],[\"之间的关系\",{\"1\":{\"319\":1}}],[\"之间的性能差距\",{\"1\":{\"215\":1}}],[\"之间的平方欧氏距离\",{\"1\":{\"92\":1}}],[\"之间\",{\"1\":{\"126\":1,\"615\":1,\"801\":1,\"847\":2}}],[\"之后让每个子像素的颜色取值分布由之前所有的子像素决定\",{\"1\":{\"847\":1}}],[\"之后让模型预测和还原被遮盖掉或替换掉的部分\",{\"1\":{\"572\":1}}],[\"之后每一个卷积层都使用\",{\"1\":{\"845\":1}}],[\"之后的像素\",{\"1\":{\"843\":1}}],[\"之后我们要在这两个句子中加一些特殊的\",{\"1\":{\"573\":1}}],[\"之后做\",{\"1\":{\"572\":1}}],[\"之后可以用\",{\"1\":{\"366\":1}}],[\"之后\",{\"1\":{\"170\":1,\"297\":1,\"575\":1,\"686\":1,\"758\":1,\"814\":1,\"880\":2}}],[\"之后concat形成该区域提取的总特征\",{\"1\":{\"96\":1}}],[\"之后这些不同尺度上提取的特征被串联起来\",{\"1\":{\"95\":1}}],[\"zc\",{\"1\":{\"859\":2}}],[\"z|x\",{\"1\":{\"854\":1,\"857\":1}}],[\"ziegler\",{\"1\":{\"536\":1,\"537\":1}}],[\"zip\",{\"1\":{\"186\":1,\"254\":1,\"256\":1,\"316\":1,\"399\":1,\"581\":1,\"593\":2,\"596\":1,\"632\":1,\"682\":1,\"684\":1,\"686\":1,\"688\":1,\"821\":2}}],[\"zsh\",{\"1\":{\"439\":1}}],[\"zhihu\",{\"1\":{\"849\":1}}],[\"zhuanlan\",{\"1\":{\"849\":1}}],[\"zhandaohong\",{\"1\":{\"593\":1}}],[\"zhang\",{\"1\":{\"552\":1}}],[\"zhou\",{\"1\":{\"536\":1}}],[\"zh\",{\"1\":{\"202\":1,\"225\":1}}],[\"zoo\",{\"1\":{\"157\":1,\"735\":1}}],[\"z\",{\"1\":{\"93\":2,\"114\":2,\"170\":25,\"355\":1,\"361\":1,\"398\":1,\"459\":1,\"684\":1,\"692\":12,\"696\":7,\"697\":2,\"840\":4,\"853\":5,\"854\":2,\"857\":7,\"859\":5,\"861\":2,\"881\":3,\"885\":32,\"886\":2}}],[\"zero\",{\"1\":{\"81\":1,\"142\":1,\"145\":1,\"147\":1,\"159\":1,\"170\":7,\"186\":1,\"202\":2,\"232\":1,\"252\":1,\"273\":2,\"507\":1,\"519\":1,\"522\":1,\"527\":1,\"528\":1,\"584\":1,\"594\":2,\"704\":1,\"803\":1,\"805\":1,\"812\":1,\"840\":2,\"848\":1,\"856\":1,\"860\":1,\"885\":1,\"886\":1}}],[\"zeros\",{\"0\":{\"378\":1},\"1\":{\"59\":1,\"81\":2,\"82\":3,\"83\":3,\"92\":2,\"145\":2,\"147\":3,\"160\":1,\"161\":1,\"162\":1,\"169\":2,\"170\":3,\"186\":1,\"254\":1,\"255\":1,\"272\":5,\"276\":1,\"277\":1,\"278\":5,\"311\":1,\"319\":1,\"320\":2,\"323\":2,\"378\":2,\"591\":2,\"597\":1,\"610\":1,\"801\":1,\"815\":1,\"848\":1,\"886\":1}}],[\"质量很差\",{\"1\":{\"866\":1}}],[\"质量\",{\"1\":{\"537\":1}}],[\"质量高于\",{\"1\":{\"521\":1}}],[\"质量和多样性\",{\"1\":{\"223\":1}}],[\"质点数量\",{\"1\":{\"92\":1}}],[\"质心\",{\"1\":{\"92\":2}}],[\"我将先以易懂的逻辑带领大家一步一步领悟vq\",{\"1\":{\"877\":1}}],[\"我将两者的结构进行对比\",{\"1\":{\"321\":1}}],[\"我的调试文件是run\",{\"1\":{\"593\":1}}],[\"我的狗很可爱\",{\"1\":{\"573\":2}}],[\"我已经上传到了仓库中\",{\"1\":{\"593\":1}}],[\"我就不上传了\",{\"1\":{\"593\":1}}],[\"我现在要把你的数据重新整理成行优先\",{\"1\":{\"426\":1}}],[\"我不管你现在怎么解读这块内存\",{\"1\":{\"426\":1}}],[\"我不感兴趣\",{\"1\":{\"92\":1}}],[\"我认为为了保持正样本的定义\",{\"1\":{\"250\":1}}],[\"我自己理解\",{\"1\":{\"249\":1}}],[\"我这个点最近的3个熟人是谁\",{\"1\":{\"100\":1}}],[\"我们多加一个\",{\"1\":{\"882\":1}}],[\"我们虽然认识了vq\",{\"1\":{\"879\":1}}],[\"我们必须设定\",{\"1\":{\"873\":1}}],[\"我们必须推动\",{\"1\":{\"868\":1}}],[\"我们实际上并没有在精确地优化\",{\"1\":{\"870\":1}}],[\"我们实现了自动构建计算图与反向传播的基本机制\",{\"1\":{\"695\":1}}],[\"我们该如何优化\",{\"1\":{\"867\":1}}],[\"我们假设数据来自一个未知的真实分布\",{\"1\":{\"864\":1}}],[\"我们假设图像共有\",{\"1\":{\"854\":1}}],[\"我们假设图像每个像素的值是伯努利分布\",{\"1\":{\"854\":1}}],[\"我们学习的编码器\",{\"1\":{\"854\":1}}],[\"我们学习和利用了\",{\"1\":{\"681\":1}}],[\"我们完成了梯度的传递\",{\"1\":{\"881\":1}}],[\"我们完成了计算图与手动反向传播的雏形\",{\"1\":{\"680\":1}}],[\"我们完全可以用黑\",{\"1\":{\"847\":1}}],[\"我们设卷积核的形状是\",{\"1\":{\"846\":1}}],[\"我们设计了一个新颖的框架\",{\"1\":{\"26\":1}}],[\"我们能明白为什么只能先用一次\",{\"1\":{\"845\":1}}],[\"我们观察图像中心处的像素在每次卷积后的感受野\",{\"1\":{\"845\":1}}],[\"我们来讨论一下嵌入空间的训练方法\",{\"1\":{\"882\":1}}],[\"我们来详细探究这些细节\",{\"1\":{\"879\":1}}],[\"我们来探讨一下网络的实现细节\",{\"1\":{\"843\":1}}],[\"我们来一步步分析这个过程\",{\"1\":{\"404\":1}}],[\"我们根据序号\",{\"1\":{\"843\":1}}],[\"我们得到了一个\",{\"1\":{\"843\":1}}],[\"我们倾向于估计硬币出现正面的概率为0\",{\"1\":{\"825\":1}}],[\"我们很自然地认为这枚硬币不是公平的\",{\"1\":{\"825\":1}}],[\"我们保留了大约\",{\"1\":{\"809\":1}}],[\"我们固定\",{\"1\":{\"809\":1}}],[\"我们无法使用重参数化梯度来最大化它\",{\"1\":{\"808\":1}}],[\"我们没法直接优化\",{\"1\":{\"807\":1}}],[\"我们训练一个离散变分自编码器\",{\"1\":{\"807\":1}}],[\"我们训练一个学生网络\",{\"1\":{\"178\":1}}],[\"我们相信\",{\"1\":{\"790\":1}}],[\"我们相信该研究将为视觉可供性理解领域带来新的启发并推动其发展\",{\"1\":{\"26\":1}}],[\"我们提出了\",{\"1\":{\"790\":1}}],[\"我们提出了一种\",{\"1\":{\"156\":1,\"772\":1}}],[\"我们提出了一种开放词汇形式的\",{\"1\":{\"26\":1}}],[\"我们分析了\",{\"1\":{\"780\":1}}],[\"我们最大化关于\",{\"1\":{\"808\":1}}],[\"我们最多随机遮挡\",{\"1\":{\"774\":1}}],[\"我们最开始右边分支的编码器是由左边初始化而来\",{\"1\":{\"246\":1}}],[\"我们获得图像编码器作为离散变分自编码器\",{\"1\":{\"773\":1}}],[\"我们构造损坏图像的\",{\"1\":{\"772\":1}}],[\"我们构建了如下关键功能\",{\"1\":{\"693\":1}}],[\"我们构建了变量\",{\"1\":{\"680\":1}}],[\"我们随机遮挡大约\",{\"1\":{\"772\":1}}],[\"我们随机选择一个图片\",{\"1\":{\"243\":1}}],[\"我们遵循\",{\"1\":{\"771\":1}}],[\"我们直觉上会认为\",{\"1\":{\"753\":1}}],[\"我们直接使用一个简单的线性分类器作为任务层\",{\"1\":{\"776\":1}}],[\"我们直接使用训练好的图像\",{\"1\":{\"774\":1}}],[\"我们直接用自然语言丢给他就去执行就好了\",{\"1\":{\"497\":1}}],[\"我们直接梯度回传就可以了\",{\"1\":{\"250\":1}}],[\"我们应该修改模型\",{\"1\":{\"843\":1}}],[\"我们应该预期这些样本大多会落在空间的哪里\",{\"1\":{\"753\":1}}],[\"我们应该进行实际业务测试\",{\"1\":{\"717\":1}}],[\"我们简称为student\",{\"1\":{\"748\":1}}],[\"我们简写为\",{\"1\":{\"746\":1}}],[\"我们简要介绍三个\",{\"1\":{\"706\":1}}],[\"我们讨论一些定义在实数集合\",{\"1\":{\"745\":1}}],[\"我们继续抽球\",{\"1\":{\"741\":1}}],[\"我们进行有放回抽样\",{\"1\":{\"740\":1}}],[\"我们进一步分析了\",{\"1\":{\"268\":1}}],[\"我们为每个\",{\"1\":{\"728\":1}}],[\"我们为variable类添加\",{\"1\":{\"690\":1}}],[\"我们定义概率\",{\"1\":{\"728\":1}}],[\"我们不希望人为规定\",{\"1\":{\"866\":1}}],[\"我们不妨来做一个实验\",{\"1\":{\"845\":1}}],[\"我们不能对\",{\"1\":{\"728\":1}}],[\"我们不需要知道第一张和第二张图片是人\",{\"1\":{\"242\":1}}],[\"我们称\",{\"1\":{\"727\":1}}],[\"我们称之为transformation\",{\"1\":{\"243\":1}}],[\"我们这么定义\",{\"1\":{\"727\":1}}],[\"我们关心的是\",{\"1\":{\"727\":1}}],[\"我们用它来衡量\",{\"1\":{\"867\":1}}],[\"我们用一个预训练的对比模型\",{\"1\":{\"811\":1}}],[\"我们用一个可学习的嵌入向量\",{\"1\":{\"772\":1}}],[\"我们用3面而不是6面\",{\"1\":{\"727\":1}}],[\"我们用蓝色的向量和所有黄色向量进行\",{\"1\":{\"575\":1}}],[\"我们就可以用pixelcnn生成离散编码\",{\"1\":{\"878\":1}}],[\"我们就可以扔掉编码器\",{\"1\":{\"878\":1}}],[\"我们就会使用上述的高斯分布\",{\"1\":{\"873\":1}}],[\"我们就不需要真实的\",{\"1\":{\"869\":1}}],[\"我们就真正最大化了\",{\"1\":{\"867\":1}}],[\"我们就等于是在并行地训练n个样本\",{\"1\":{\"843\":1}}],[\"我们就得到了后验分布\",{\"1\":{\"758\":1}}],[\"我们就完成了应用的核心功能\",{\"1\":{\"717\":1}}],[\"我们就用该查询点最近的那个点\",{\"1\":{\"92\":1}}],[\"我们推荐基于\",{\"1\":{\"717\":1}}],[\"我们一般可以将大模型开发分解为以下几个流程\",{\"1\":{\"717\":1}}],[\"我们一般不会去大幅度改动模型\",{\"1\":{\"716\":1}}],[\"我们后续会用到的处理文档\",{\"1\":{\"715\":1}}],[\"我们开始迈入更深入也更贴近真实深度学习框架设计的阶段\",{\"1\":{\"695\":1}}],[\"我们引入一个新的分布函数\",{\"1\":{\"867\":1}}],[\"我们引入释放中间变量导数的机制\",{\"1\":{\"688\":1}}],[\"我们引入了目前最大规模的\",{\"1\":{\"26\":1}}],[\"我们便可以根据常规的卷积模型搭建策略来实现\",{\"1\":{\"848\":1}}],[\"我们便可以通过\",{\"1\":{\"686\":1}}],[\"我们便可以采样dino模型代码中采用的注意力掩码矩阵技巧\",{\"1\":{\"463\":1}}],[\"我们采用了类似的两阶段训练流程\",{\"1\":{\"807\":1}}],[\"我们采用与\",{\"1\":{\"773\":1}}],[\"我们采用\",{\"1\":{\"770\":1,\"777\":1}}],[\"我们采用更加暴力的\",{\"1\":{\"686\":1}}],[\"我们采用动态高分辨率训练策略\",{\"1\":{\"224\":1}}],[\"我们要算的事件是\",{\"1\":{\"731\":1}}],[\"我们要问\",{\"1\":{\"731\":1}}],[\"我们要先计算出其梯度后\",{\"1\":{\"685\":1}}],[\"我们要计算输入序列第\",{\"1\":{\"587\":1}}],[\"我们从\",{\"1\":{\"867\":1}}],[\"我们从互联网收集了\",{\"1\":{\"810\":1}}],[\"我们从零开始构建了tinypytorch框架的基础功能\",{\"1\":{\"678\":1}}],[\"我们从原始输入的\",{\"1\":{\"616\":1}}],[\"我们从flower\",{\"1\":{\"302\":1}}],[\"我们主要使用它来预测答案的起始和结束位置\",{\"1\":{\"614\":1}}],[\"我们已经学完了vq\",{\"1\":{\"878\":1}}],[\"我们已经在对从数据集\",{\"1\":{\"868\":1}}],[\"我们已经有了\",{\"1\":{\"591\":1}}],[\"我们已经探讨了clip模型的运作机制\",{\"1\":{\"300\":1}}],[\"我们想得到一个由3个整数构成的离散编码\",{\"1\":{\"880\":1}}],[\"我们想得到一个结果\",{\"1\":{\"242\":1}}],[\"我们想要从\",{\"1\":{\"853\":1}}],[\"我们想算\",{\"1\":{\"590\":1}}],[\"我们打印了位置\",{\"1\":{\"587\":1}}],[\"我们只需知道vae可以把图片编码成符合标准正态分布的向量即可\",{\"1\":{\"878\":1}}],[\"我们只需从\",{\"1\":{\"874\":1}}],[\"我们只需要找到一种函数\",{\"1\":{\"871\":1}}],[\"我们只需要如下修改variable变量的backward方法即可完成按照辈分获取函数的逻辑\",{\"1\":{\"686\":1}}],[\"我们只需要确保对于某个词的上下文融合不被pad词参与即可\",{\"1\":{\"584\":1}}],[\"我们只需要在计算出相似度得分矩阵后\",{\"1\":{\"303\":1}}],[\"我们只需要经过模型\",{\"1\":{\"243\":1}}],[\"我们只对哪些集合定义概率\",{\"1\":{\"728\":1}}],[\"我们只会计算被随机遮盖或替换的部分\",{\"1\":{\"581\":1}}],[\"我们给上句的\",{\"1\":{\"573\":1}}],[\"我们给一个输入文本\",{\"1\":{\"541\":1}}],[\"我们传入的是\",{\"1\":{\"544\":1}}],[\"我们到底在\",{\"1\":{\"539\":1}}],[\"我们先来制订一下\",{\"1\":{\"881\":1}}],[\"我们先从变分贝叶斯方法的基础出发\",{\"1\":{\"867\":1}}],[\"我们先用\",{\"1\":{\"845\":1}}],[\"我们先只考虑单通道图像\",{\"1\":{\"843\":1}}],[\"我们先给小孩子分析讲解一些示例\",{\"1\":{\"501\":1}}],[\"我们先对大模型做一个直观的抽象\",{\"1\":{\"481\":1}}],[\"我们教小孩做应用题\",{\"1\":{\"501\":1}}],[\"我们让llm对一段文字进行总结\",{\"1\":{\"499\":1}}],[\"我们发现这种做法虽然验证集损失更高\",{\"1\":{\"809\":1}}],[\"我们发现这些值呈现周期性的变化\",{\"1\":{\"587\":1}}],[\"我们发现\",{\"1\":{\"781\":1,\"808\":1}}],[\"我们发现恰当的初始化对于\",{\"1\":{\"774\":1}}],[\"我们发现倒数第四层的特征在多模态任务中表现最佳\",{\"1\":{\"223\":1}}],[\"我们发给llm的批令\",{\"1\":{\"499\":1}}],[\"我们看一下矩阵\",{\"1\":{\"493\":1}}],[\"我们看重无监督学习的优点\",{\"1\":{\"245\":1}}],[\"我们微调大模型的流程就变为了\",{\"1\":{\"490\":1}}],[\"我们所说的\",{\"1\":{\"481\":1}}],[\"我们取其补集\",{\"1\":{\"469\":1}}],[\"我们通常只对\",{\"1\":{\"868\":1}}],[\"我们通常假设协方差矩阵是对角的\",{\"1\":{\"866\":1}}],[\"我们通常令先验为\",{\"1\":{\"773\":1}}],[\"我们通常取其补集\",{\"1\":{\"467\":1}}],[\"我们通过引入潜变量\",{\"1\":{\"874\":1}}],[\"我们通过已观测到的样本情况去\",{\"1\":{\"825\":1}}],[\"我们通过最大化带标签数据的似然函数\",{\"1\":{\"776\":1}}],[\"我们通过变量梯度非空则进行累加的改动\",{\"1\":{\"685\":1}}],[\"我们通过把复杂问题拆解成一个个的简单问题\",{\"1\":{\"503\":1}}],[\"我们通过线性变换得到\",{\"1\":{\"415\":1}}],[\"我们通过自定义一个patchembed类完成上述工作\",{\"1\":{\"318\":1}}],[\"我们通过利用clip模型的多模态能力\",{\"1\":{\"300\":1}}],[\"我们通过一次\",{\"1\":{\"250\":1}}],[\"我们通过在线对比难样本挖掘来改进图文匹配\",{\"1\":{\"153\":1}}],[\"我们选择的阈值取决于哪个指标对特定用例而言最重要\",{\"1\":{\"453\":1}}],[\"我们知道了\",{\"1\":{\"880\":1}}],[\"我们知道\",{\"1\":{\"421\":1,\"731\":1}}],[\"我们生成一个3\",{\"1\":{\"421\":1}}],[\"我们会说这个是男是女\",{\"1\":{\"878\":1}}],[\"我们会使用\",{\"1\":{\"873\":1}}],[\"我们会使用pad\",{\"1\":{\"584\":1}}],[\"我们会调查\",{\"1\":{\"870\":1}}],[\"我们会从信息论\",{\"1\":{\"870\":1}}],[\"我们会从一张图片中生成多个候选区域\",{\"1\":{\"386\":1}}],[\"我们会探讨\",{\"1\":{\"870\":1}}],[\"我们会在后续进一步探索这种\",{\"1\":{\"867\":1}}],[\"我们会在预训练好的\",{\"1\":{\"767\":1}}],[\"我们会给\",{\"1\":{\"807\":1}}],[\"我们会用到多种概率分布\",{\"1\":{\"735\":1}}],[\"我们会用自然语言描述一系列的推理过程\",{\"1\":{\"501\":1}}],[\"我们会为该任务设计一个最合适的神经网络架构并做训练\",{\"1\":{\"571\":1}}],[\"我们会拼接多个这样的头\",{\"1\":{\"415\":1}}],[\"我们希望建立一个模型\",{\"1\":{\"874\":1}}],[\"我们希望估计其\",{\"1\":{\"866\":1}}],[\"我们希望从一个高斯分布中采样隐变量\",{\"1\":{\"853\":1}}],[\"我们希望得到\",{\"1\":{\"807\":1}}],[\"我们希望\",{\"1\":{\"796\":1}}],[\"我们希望使用定义在非负实数上的分布\",{\"1\":{\"747\":1}}],[\"我们希望每次计算都能得到正确的导数\",{\"1\":{\"683\":1}}],[\"我们希望输出一个\",{\"1\":{\"386\":1}}],[\"我们希望在特征空间里\",{\"1\":{\"242\":1}}],[\"我们常常需要衡量文本嵌入和图片嵌入之间的相似度\",{\"1\":{\"302\":1}}],[\"我们使用一个包含\",{\"1\":{\"774\":1}}],[\"我们使用\",{\"1\":{\"772\":1,\"773\":1,\"774\":1,\"781\":1,\"808\":1,\"846\":1}}],[\"我们使用了一个示例来说明这一概念\",{\"1\":{\"427\":1}}],[\"我们使用了\",{\"1\":{\"301\":1}}],[\"我们使用多模态编码器输出的\",{\"1\":{\"156\":1}}],[\"我们也展示了通过联合\",{\"1\":{\"790\":1}}],[\"我们也可以将自然语言理解看作是一个病态问题\",{\"1\":{\"759\":1}}],[\"我们也可以考虑结果为连续值的实验\",{\"1\":{\"728\":1}}],[\"我们也可以发现\",{\"1\":{\"587\":1}}],[\"我们也可以对得到的余弦相似度计算softmax\",{\"1\":{\"300\":1}}],[\"我们也尝试过随机初始化直接进行视觉语言预训练\",{\"1\":{\"268\":1}}],[\"我们首先将所有参数在一个较小范围内随机初始化\",{\"1\":{\"774\":1}}],[\"我们首先应该明确\",{\"1\":{\"717\":1}}],[\"我们首先需要确定开发的目标\",{\"1\":{\"717\":1}}],[\"我们首先拿到属于上下文的一对句子\",{\"1\":{\"573\":1}}],[\"我们首先获取图片库中所有图片\",{\"1\":{\"303\":1}}],[\"我们首先创建了各类别的文本描述\",{\"1\":{\"300\":1}}],[\"我们首先用一幅图理清楚\",{\"1\":{\"273\":1}}],[\"我们首先进行了阶段式预训练的消融实验\",{\"1\":{\"268\":1}}],[\"我们的讨论都是建立在嵌入空间已经训练完毕的前提上的\",{\"1\":{\"882\":1}}],[\"我们的目标是训练一个\",{\"1\":{\"807\":1}}],[\"我们的工作首次提出以\",{\"1\":{\"790\":1}}],[\"我们的方法中将图像表示为两种形式\",{\"1\":{\"768\":1}}],[\"我们的方法则从所有\",{\"1\":{\"268\":1}}],[\"我们的实验从图像预训练开始\",{\"1\":{\"268\":1}}],[\"我们还可以从标准正态分布中采样一个向量\",{\"1\":{\"857\":1}}],[\"我们还需要处理一个更复杂的问题\",{\"1\":{\"846\":1}}],[\"我们还发现\",{\"1\":{\"808\":1}}],[\"我们还用了\",{\"1\":{\"499\":1}}],[\"我们还有其他的选择\",{\"1\":{\"301\":1}}],[\"我们还进行了\",{\"1\":{\"268\":1}}],[\"我们还提升了预训练数据集的规模\",{\"1\":{\"223\":1}}],[\"我们比较了两种初始化方式\",{\"1\":{\"268\":1}}],[\"我们是放到字典中去的\",{\"1\":{\"249\":1}}],[\"我们其实可以把key集合看成字典\",{\"1\":{\"246\":1}}],[\"我们把两类掩码卷积分别称为\",{\"1\":{\"845\":1}}],[\"我们把\",{\"1\":{\"731\":1}}],[\"我们把某个位置的向量大概划分为两部分\",{\"1\":{\"587\":1}}],[\"我们把它加到第二个\",{\"1\":{\"587\":1}}],[\"我们把字典中的\",{\"1\":{\"250\":1}}],[\"我们把f11叫做\",{\"1\":{\"246\":1}}],[\"我们把x11这个图片叫做\",{\"1\":{\"246\":1}}],[\"我们接着来看图\",{\"1\":{\"246\":1}}],[\"我们可以设计一个把梯度从\",{\"1\":{\"881\":1}}],[\"我们可以借鉴nlp中对于离散单词的处理方法\",{\"1\":{\"878\":1}}],[\"我们可以借助预训练好的clip模型\",{\"1\":{\"822\":1}}],[\"我们可以明确地\",{\"1\":{\"873\":1}}],[\"我们可以人为\",{\"1\":{\"873\":1}}],[\"我们可以思考一个问题\",{\"1\":{\"873\":1}}],[\"我们可以从信息论的角度\",{\"1\":{\"872\":1}}],[\"我们可以从以下角度理解\",{\"1\":{\"411\":1}}],[\"我们可以\",{\"1\":{\"869\":1}}],[\"我们可以对多个样本的\",{\"1\":{\"868\":1}}],[\"我们可以对ltm\",{\"1\":{\"503\":1}}],[\"我们可以将之前的公式\",{\"1\":{\"874\":1}}],[\"我们可以将标准正态的\",{\"1\":{\"866\":1}}],[\"我们可以将每个样本空间中的结果映射为一个实数\",{\"1\":{\"727\":1}}],[\"我们可以说\",{\"1\":{\"847\":1}}],[\"我们可以用任意一种\",{\"1\":{\"845\":1}}],[\"我们可以用一句话来总结贝叶斯公式\",{\"1\":{\"758\":1}}],[\"我们可以在一次前向传播后得到图像每一处的概率分布\",{\"1\":{\"843\":1}}],[\"我们可以在一个数据量更丰富的中间数据集\",{\"1\":{\"778\":1}}],[\"我们可以让模型输入一幅图像\",{\"1\":{\"843\":1}}],[\"我们可以提出这样一个问题\",{\"1\":{\"753\":1}}],[\"我们可以使用采样来估计这个期望\",{\"1\":{\"868\":1}}],[\"我们可以使用贝叶斯公式来计算后验概率\",{\"1\":{\"759\":1}}],[\"我们可以使用分类分布\",{\"1\":{\"738\":1}}],[\"我们可以使用一些代理任务\",{\"1\":{\"242\":1}}],[\"我们可以得到\",{\"1\":{\"728\":1}}],[\"我们可以基于\",{\"1\":{\"717\":1}}],[\"我们可以根据自身需求灵活地进行组合\",{\"1\":{\"713\":1}}],[\"我们可以根据这个类别去学习模型\",{\"1\":{\"246\":1}}],[\"我们可以轻松地构建如下所示的\",{\"1\":{\"712\":1}}],[\"我们可以验证框架是否支持复杂表达式的自动微分\",{\"1\":{\"690\":1}}],[\"我们可以通过以下重参数方式\",{\"1\":{\"873\":1}}],[\"我们可以通过一些简单处理过滤掉第\",{\"1\":{\"843\":1}}],[\"我们可以通过除以\",{\"1\":{\"758\":1}}],[\"我们可以通过变量的辈分来设置其创建者函数的辈分\",{\"1\":{\"686\":1}}],[\"我们可以通改变对内存中数据缓冲区的解读方式来实现逻辑上的转置\",{\"1\":{\"426\":1}}],[\"我们可以获取到哪个函数生成了哪个变量\",{\"1\":{\"686\":1}}],[\"我们可以采用拓扑排序\",{\"1\":{\"686\":1}}],[\"我们可以发现\",{\"1\":{\"587\":1}}],[\"我们可以利用矩阵分解技术\",{\"1\":{\"490\":1}}],[\"我们可以把它换成transformer\",{\"1\":{\"883\":1}}],[\"我们可以把pixelcnn生成图像的方法搬过来\",{\"1\":{\"878\":1}}],[\"我们可以把类似的嵌入层加到vq\",{\"1\":{\"878\":1}}],[\"我们可以把这看作是对\",{\"1\":{\"759\":1}}],[\"我们可以把\",{\"1\":{\"426\":1}}],[\"我们可以直接使用类别标签作为文本描述\",{\"1\":{\"301\":1}}],[\"我们并不是简单地随机选择\",{\"1\":{\"772\":1}}],[\"我们并不需要深研大模型内部原理\",{\"1\":{\"716\":1}}],[\"我们并不需要大量标注好的数据\",{\"1\":{\"241\":1}}],[\"我们并没有用到标签信息\",{\"1\":{\"242\":1}}],[\"我们需要的是一种算法\",{\"1\":{\"874\":1}}],[\"我们需要更具体地定义\",{\"1\":{\"868\":1}}],[\"我们需要通过\",{\"1\":{\"814\":1}}],[\"我们需要通过prompt\",{\"1\":{\"500\":1}}],[\"我们需要重点关注应用于图像之上的transform操作\",{\"1\":{\"802\":1}}],[\"我们需要借助borel\",{\"1\":{\"728\":1}}],[\"我们需要逐步迭代构建优质的\",{\"1\":{\"717\":1}}],[\"我们需要收集数据并进行预处理\",{\"1\":{\"717\":1}}],[\"我们需要针对我们所设计的功能\",{\"1\":{\"717\":1}}],[\"我们需要让variable实例能与numpy数组\",{\"1\":{\"690\":1}}],[\"我们需要让这三个表征在特征空间中\",{\"1\":{\"242\":1}}],[\"我们需要实现mul类来处理正向传播和反向传播\",{\"1\":{\"690\":1}}],[\"我们需要在每次计算之前将导数重置为0\",{\"1\":{\"683\":1}}],[\"我们需要在其对应的crossentropyloss中指定ignore\",{\"1\":{\"581\":1}}],[\"我们需要读取并构建batch数据\",{\"1\":{\"579\":1}}],[\"我们需要先将\",{\"1\":{\"386\":1}}],[\"我们需要根据上面给出的花卉数据集下载链接\",{\"1\":{\"302\":1}}],[\"我们需要知道的是\",{\"1\":{\"242\":1}}],[\"我们现在看到的这些大语言模型\",{\"1\":{\"487\":1}}],[\"我们现在把这三张图片输入一个模型\",{\"1\":{\"242\":1}}],[\"我们现在有三张图\",{\"1\":{\"242\":1}}],[\"我们将基于minist数据集进行训练演示\",{\"1\":{\"885\":1}}],[\"我们将讨论三个关键主题\",{\"1\":{\"870\":1}}],[\"我们将采样从网络内部移动到输入层\",{\"1\":{\"868\":1}}],[\"我们将等式两边都取负号\",{\"1\":{\"867\":1}}],[\"我们将所有输入和输出通道都分成\",{\"1\":{\"846\":1}}],[\"我们将快速过一下\",{\"1\":{\"821\":1}}],[\"我们将文本与图像\",{\"1\":{\"809\":1}}],[\"我们将文本标题的最大长度限制为\",{\"1\":{\"809\":1}}],[\"我们将小写化的标题用\",{\"1\":{\"809\":1}}],[\"我们将初始先验\",{\"1\":{\"808\":1}}],[\"我们将最多\",{\"1\":{\"807\":1}}],[\"我们将自注意力模块和前馈网络中子层最后的线性投影矩阵的输出按\",{\"1\":{\"774\":1}}],[\"我们将\",{\"1\":{\"773\":1,\"808\":1}}],[\"我们将图像\",{\"1\":{\"770\":1}}],[\"我们将图像表示为由\",{\"1\":{\"770\":1}}],[\"我们将每张图像\",{\"1\":{\"770\":1}}],[\"我们将每张\",{\"1\":{\"769\":1}}],[\"我们将其划分为\",{\"1\":{\"769\":1,\"772\":1}}],[\"我们将其编码为图像\",{\"1\":{\"263\":1}}],[\"我们将详细介绍多元高斯分布\",{\"1\":{\"751\":1}}],[\"我们将组合数\",{\"1\":{\"742\":1}}],[\"我们将随机变量可能的取值集合称为其状态空间\",{\"1\":{\"727\":1}}],[\"我们将概率空间定义为三元组\",{\"1\":{\"726\":1}}],[\"我们将开发以大语言模型为功能核心\",{\"1\":{\"716\":1}}],[\"我们将实现\",{\"1\":{\"700\":1}}],[\"我们将真正迈入\",{\"1\":{\"700\":1}}],[\"我们将看到\",{\"1\":{\"695\":1}}],[\"我们将add类绑定到+运算符\",{\"1\":{\"690\":1}}],[\"我们将mul类封装为python函数mul\",{\"1\":{\"690\":1}}],[\"我们将继续揭开深度学习框架的核心机制\",{\"1\":{\"680\":1}}],[\"我们将从第25步继续出发\",{\"1\":{\"695\":1}}],[\"我们将从\",{\"1\":{\"576\":1}}],[\"我们将进入\",{\"1\":{\"275\":1}}],[\"我们将分辨率从224提升至448\",{\"1\":{\"223\":1}}],[\"我们将原始数据集中的网页文本复制\",{\"1\":{\"136\":1}}],[\"我们在下一小节里来详细探究一下怎么优化\",{\"1\":{\"880\":1}}],[\"我们在闲暇之余来谈一谈\",{\"1\":{\"847\":1}}],[\"我们在生成当前像素的\",{\"1\":{\"846\":1}}],[\"我们在本文中以图像分类和语义分割为例\",{\"1\":{\"775\":1}}],[\"我们在自监督学习中不使用图像标签\",{\"1\":{\"774\":1}}],[\"我们在\",{\"1\":{\"771\":1,\"775\":1,\"778\":1,\"810\":1}}],[\"我们在variable类和function类中增加实例变量generation\",{\"1\":{\"686\":1}}],[\"我们在接下来的部分\",{\"1\":{\"500\":1}}],[\"我们在给llm发指令的时候\",{\"1\":{\"499\":1}}],[\"我们在做对比学习的时候\",{\"1\":{\"246\":1}}],[\"我们在训练中同时激活视觉编码器和mlp投影层\",{\"1\":{\"223\":1}}],[\"我们在internvl\",{\"1\":{\"223\":1}}],[\"我们在该阶段冻结\",{\"1\":{\"199\":1}}],[\"我们以\",{\"1\":{\"155\":1}}],[\"我们计算的是编码器输出分布\",{\"1\":{\"798\":1}}],[\"我们计算归一化的图像到文本和文本到图像的\",{\"1\":{\"154\":1}}],[\"我们计划构建专用于推理的数据集\",{\"1\":{\"26\":1}}],[\"我们维护两个队列来存储动量单模态编码器最近的\",{\"1\":{\"154\":1}}],[\"我们切分为多个步骤进行解析\",{\"1\":{\"145\":1}}],[\"我们对此进行了控制\",{\"1\":{\"810\":1}}],[\"我们对该分布建模的因式分解为\",{\"1\":{\"807\":1}}],[\"我们对可能出现的结果\",{\"1\":{\"758\":1}}],[\"我们对prompt进行优化\",{\"1\":{\"497\":1}}],[\"我们对不同预训练任务的贡献进行了消融实验\",{\"1\":{\"268\":1}}],[\"我们对比了两种方式\",{\"1\":{\"137\":1}}],[\"我们对\",{\"1\":{\"10\":1,\"153\":1,\"867\":1}}],[\"代替它\",{\"1\":{\"867\":1}}],[\"代入\",{\"1\":{\"807\":1}}],[\"代入调整后的步幅\",{\"1\":{\"427\":1}}],[\"代数就是一种封闭的事件系统\",{\"1\":{\"728\":1}}],[\"代数是一种你可以安全地讨论概率的\",{\"1\":{\"728\":1}}],[\"代数是一个集合的集合\",{\"1\":{\"728\":1}}],[\"代数是由所有形如\",{\"1\":{\"728\":1}}],[\"代数是由半开区间\",{\"1\":{\"728\":1}}],[\"代数是专门为实数空间\",{\"1\":{\"728\":1}}],[\"代数\",{\"1\":{\"728\":7}}],[\"代理服务以及回调处理等关键组件\",{\"1\":{\"714\":1}}],[\"代理\",{\"1\":{\"713\":1}}],[\"代理任务通常是辅助进行表征学习\",{\"1\":{\"305\":1}}],[\"代价是非常高的\",{\"1\":{\"492\":1}}],[\"代表我们因为编码器不完美而付出的额外\",{\"1\":{\"872\":1}}],[\"代表隐空间的离散编码\",{\"1\":{\"795\":1}}],[\"代表的是模型的基础\",{\"1\":{\"317\":1}}],[\"代表\",{\"1\":{\"252\":2,\"324\":2,\"327\":1,\"704\":1}}],[\"代表性工作包括\",{\"1\":{\"219\":1}}],[\"代表每个\",{\"1\":{\"92\":1}}],[\"代表原始点云中每个点的\",{\"1\":{\"92\":1}}],[\"代码执行\",{\"1\":{\"704\":1}}],[\"代码中\",{\"1\":{\"697\":1}}],[\"代码中用\",{\"1\":{\"544\":1}}],[\"代码将变量y的计算图转换为dot语言字符串\",{\"1\":{\"696\":1}}],[\"代码示例\",{\"0\":{\"647\":1}}],[\"代码及新数据集cc\",{\"1\":{\"567\":1}}],[\"代码与学术数据\",{\"1\":{\"548\":1}}],[\"代码生成与数学推理\",{\"1\":{\"549\":1}}],[\"代码生成\",{\"1\":{\"547\":1,\"549\":1,\"550\":1}}],[\"代码描述如下\",{\"1\":{\"541\":1}}],[\"代码任务\",{\"1\":{\"539\":1}}],[\"代码片段\",{\"1\":{\"538\":1}}],[\"代码块类型\",{\"1\":{\"336\":1}}],[\"代码块与作用域对照表\",{\"1\":{\"336\":1}}],[\"代码如下\",{\"1\":{\"186\":1}}],[\"代码解析\",{\"0\":{\"186\":1},\"1\":{\"470\":1}}],[\"代码本嵌入使用指数移动平均\",{\"1\":{\"167\":1}}],[\"代码整体流程比较长\",{\"1\":{\"145\":1}}],[\"代码链接\",{\"1\":{\"119\":1,\"148\":1,\"164\":1,\"171\":1,\"172\":1,\"187\":1,\"231\":1,\"240\":1,\"259\":1,\"270\":1,\"279\":1,\"287\":1,\"764\":1}}],[\"代码实现逻辑\",{\"1\":{\"277\":1}}],[\"代码实现的同学\",{\"1\":{\"271\":1}}],[\"代码实现如下所示\",{\"1\":{\"272\":1}}],[\"代码实现如下\",{\"1\":{\"93\":1,\"591\":1}}],[\"代码实现\",{\"0\":{\"68\":1,\"92\":1,\"99\":1,\"168\":1,\"615\":1,\"637\":1,\"643\":1,\"652\":1,\"813\":1,\"884\":1},\"1\":{\"107\":1,\"467\":1,\"468\":1,\"469\":1,\"470\":1,\"473\":1,\"692\":3,\"840\":1}}],[\"代码体现\",{\"1\":{\"29\":1}}],[\"代码\",{\"0\":{\"27\":1,\"57\":1,\"106\":1},\"1\":{\"4\":1,\"37\":1,\"47\":1,\"60\":1,\"306\":1}}],[\"到这里\",{\"1\":{\"878\":1}}],[\"到这个内部函数上\",{\"1\":{\"340\":1}}],[\"到目前为止\",{\"1\":{\"870\":1,\"882\":1}}],[\"到向量的映射\",{\"1\":{\"821\":1}}],[\"到向量存储\",{\"1\":{\"714\":1}}],[\"到对应的位置\",{\"1\":{\"818\":1}}],[\"到序列最前面\",{\"1\":{\"804\":1}}],[\"到原点的平方距离\",{\"1\":{\"755\":1}}],[\"到第\",{\"1\":{\"616\":1}}],[\"到三维\",{\"1\":{\"580\":1}}],[\"到神经网络\",{\"1\":{\"552\":1}}],[\"到上下文感知的循环神经网络\",{\"1\":{\"520\":1}}],[\"到特征图空间\",{\"1\":{\"386\":1}}],[\"到的特征不太好泛化\",{\"1\":{\"248\":1}}],[\"到近年来的vision\",{\"1\":{\"191\":1}}],[\"到一个标准姿态\",{\"1\":{\"107\":1}}],[\"到\",{\"0\":{\"878\":1},\"1\":{\"92\":1,\"186\":1,\"215\":1,\"272\":1,\"332\":1,\"346\":1,\"423\":1,\"451\":1,\"684\":2,\"704\":1,\"726\":1,\"728\":1,\"814\":1,\"846\":2,\"847\":2,\"880\":1,\"881\":1}}],[\"到红色\",{\"1\":{\"83\":1}}],[\"<i\",{\"1\":{\"848\":1}}],[\"<bos>\",{\"1\":{\"814\":1,\"815\":3}}],[\"<==\",{\"1\":{\"885\":1}}],[\"<=\",{\"1\":{\"579\":3,\"590\":1,\"614\":1,\"801\":1}}],[\"<unk>\",{\"1\":{\"476\":1,\"478\":2,\"578\":1}}],[\"<pad>\",{\"1\":{\"476\":1,\"478\":2}}],[\"<line\",{\"1\":{\"476\":1,\"477\":1,\"478\":2}}],[\"<环境名>\",{\"1\":{\"431\":1,\"432\":1}}],[\"<4\",{\"1\":{\"427\":1}}],[\"<<\",{\"1\":{\"385\":1}}],[\"<stop>\",{\"1\":{\"235\":6}}],[\"<eos>\",{\"1\":{\"126\":1}}],[\"<\",{\"1\":{\"92\":1,\"294\":3,\"455\":1,\"473\":1,\"476\":6,\"477\":2,\"478\":7,\"578\":1,\"581\":1,\"591\":5,\"801\":4,\"814\":4,\"815\":1,\"817\":1}}],[\"次正面\",{\"1\":{\"826\":1}}],[\"次抛掷中出现\",{\"1\":{\"826\":1}}],[\"次试验的结果\",{\"1\":{\"741\":1}}],[\"次试验中选出\",{\"1\":{\"741\":1}}],[\"次试验中出现的次数\",{\"1\":{\"738\":1}}],[\"次成功的位置\",{\"1\":{\"741\":1}}],[\"次数\",{\"1\":{\"741\":1}}],[\"次失败必须是第\",{\"1\":{\"741\":1}}],[\"次失败\",{\"1\":{\"741\":1}}],[\"次从\",{\"1\":{\"514\":1}}],[\"次并与每个点的局部特征拼接\",{\"1\":{\"112\":1}}],[\"次并与每个点的局部特征\",{\"1\":{\"109\":1}}],[\"次\",{\"1\":{\"92\":1,\"111\":1,\"364\":1,\"845\":1}}],[\"重参数化的关键思想\",{\"1\":{\"853\":1}}],[\"重参数化技巧仅适用于连续变量的分布\",{\"1\":{\"868\":1}}],[\"重参数化技巧\",{\"1\":{\"853\":1,\"868\":1}}],[\"重构损失项可以写作\",{\"1\":{\"873\":1}}],[\"重构损失\",{\"0\":{\"854\":1}}],[\"重构损失中的量化损失系数\",{\"1\":{\"170\":1}}],[\"重构项\",{\"1\":{\"807\":1}}],[\"重建误差\",{\"1\":{\"885\":1}}],[\"重建误差为输入图片和重建图片的均方误差\",{\"1\":{\"883\":1}}],[\"重建误差和嵌入空间误差\",{\"1\":{\"883\":1}}],[\"重建\",{\"1\":{\"872\":1}}],[\"重建项\",{\"1\":{\"854\":1}}],[\"重建样本\",{\"1\":{\"854\":1}}],[\"重建对数似然\",{\"1\":{\"854\":1}}],[\"重建损失\",{\"1\":{\"821\":1,\"869\":1}}],[\"重建损失函数\",{\"1\":{\"793\":1}}],[\"重建原始图像\",{\"1\":{\"770\":1}}],[\"重载运算符\",{\"1\":{\"693\":1}}],[\"重置导数\",{\"0\":{\"683\":1}}],[\"重新定义了\",{\"1\":{\"874\":1}}],[\"重新排列\",{\"1\":{\"821\":1,\"867\":1}}],[\"重新计算\",{\"1\":{\"544\":1}}],[\"重新输入全部历史\",{\"1\":{\"544\":1}}],[\"重新拉直空间\",{\"1\":{\"459\":1}}],[\"重写\",{\"1\":{\"537\":1}}],[\"重要的是\",{\"1\":{\"528\":1}}],[\"重要说明\",{\"1\":{\"438\":1}}],[\"重叠计算与gpu通信\",{\"1\":{\"548\":1}}],[\"重叠\",{\"1\":{\"522\":1}}],[\"重塑为\",{\"1\":{\"463\":1}}],[\"重塑注意力权重为\",{\"1\":{\"463\":1}}],[\"重\",{\"1\":{\"307\":8}}],[\"重点注意各个参数的含义\",{\"1\":{\"801\":1}}],[\"重点是保持参数尺寸最小化\",{\"1\":{\"495\":1}}],[\"重点是如何理解这里的分组\",{\"1\":{\"72\":1}}],[\"重点在于\",{\"1\":{\"427\":1}}],[\"重点训练图像和文本特征提取\",{\"1\":{\"307\":1}}],[\"重型胶水层\",{\"1\":{\"196\":1}}],[\"重组视觉特征\",{\"1\":{\"189\":1}}],[\"重复上述步骤直到遮挡的\",{\"1\":{\"772\":1}}],[\"重复向梯度方向移动一定距离\",{\"1\":{\"697\":1}}],[\"重复惩罚系数\",{\"1\":{\"313\":1}}],[\"重复惩罚项\",{\"1\":{\"143\":1}}],[\"重复迭代更新聚类中心\",{\"1\":{\"170\":1}}],[\"重复步骤2和3\",{\"1\":{\"840\":1}}],[\"重复步骤\",{\"1\":{\"170\":1}}],[\"重复\",{\"1\":{\"92\":1}}],[\"批处理\",{\"1\":{\"700\":1}}],[\"批次大小\",{\"1\":{\"560\":1,\"821\":1}}],[\"批次索引\",{\"1\":{\"92\":1,\"463\":1}}],[\"批量\",{\"1\":{\"212\":1}}],[\"批量大小增至\",{\"1\":{\"210\":1}}],[\"批量大小\",{\"1\":{\"179\":1,\"211\":1}}],[\"批量大小为\",{\"1\":{\"131\":1}}],[\"批大小提升至512\",{\"1\":{\"521\":1}}],[\"批大小为\",{\"1\":{\"514\":1}}],[\"批大小\",{\"1\":{\"22\":1}}],[\"距离本身越来越集中在\",{\"1\":{\"755\":1}}],[\"距离或温度\",{\"1\":{\"728\":1}}],[\"距离归一化并取对数\",{\"1\":{\"591\":1}}],[\"距离分组\",{\"1\":{\"591\":1}}],[\"距离较大的\",{\"1\":{\"591\":1}}],[\"距离\",{\"1\":{\"459\":1}}],[\"距离越近\",{\"1\":{\"100\":1}}],[\"距离直观性\",{\"1\":{\"90\":1}}],[\"距离的度量不受空间中位置的影响\",{\"1\":{\"90\":1}}],[\"文章生成和情境理解方面表现出色\",{\"1\":{\"705\":1}}],[\"文章中提炼出来\",{\"1\":{\"577\":1}}],[\"文心大模型包括\",{\"1\":{\"704\":1}}],[\"文心一言网页版分为\",{\"1\":{\"704\":1}}],[\"文心一言的中文能力相对来说非常不错\",{\"1\":{\"704\":1}}],[\"文心一言的基础模型文心大模型于\",{\"1\":{\"704\":1}}],[\"文心一言是基于百度文心大模型的知识增强语言大模型\",{\"1\":{\"704\":1}}],[\"文心一言\",{\"1\":{\"703\":1,\"704\":1}}],[\"文献中也探索了多种控制模型输出的策略\",{\"1\":{\"536\":1}}],[\"文档\",{\"1\":{\"512\":1}}],[\"文档生成\",{\"1\":{\"346\":1}}],[\"文档理解\",{\"1\":{\"228\":1}}],[\"文件转换命令\",{\"1\":{\"696\":1}}],[\"文件中的\",{\"1\":{\"620\":1}}],[\"文件进行调试即可\",{\"1\":{\"593\":1}}],[\"文件顶层的名字都在模块作用域内\",{\"1\":{\"336\":1}}],[\"文件\",{\"1\":{\"336\":1}}],[\"文字搜索图像\",{\"0\":{\"303\":1}}],[\"文字搜索图像实战演练\",{\"1\":{\"296\":1}}],[\"文中将省略函数\",{\"1\":{\"865\":1}}],[\"文中所有用于展示效果和评测的样本\",{\"1\":{\"811\":1}}],[\"文中提到了一些少量使用in\",{\"1\":{\"531\":1}}],[\"文中引用了kaplan等人提出的\",{\"1\":{\"531\":1}}],[\"文中的𝐶所表示的其他信息\",{\"1\":{\"91\":1}}],[\"文中作者通过ball\",{\"1\":{\"90\":1}}],[\"文本掩码\",{\"1\":{\"822\":1}}],[\"文本嵌入维度\",{\"1\":{\"822\":1}}],[\"文本部分的平均交叉熵损失\",{\"1\":{\"815\":1}}],[\"文本部分\",{\"1\":{\"815\":1}}],[\"文本去掉\",{\"1\":{\"815\":1}}],[\"文本序列开头加上\",{\"1\":{\"815\":1}}],[\"文本序列最大长度\",{\"1\":{\"814\":1,\"822\":1}}],[\"文本位置\",{\"1\":{\"822\":1}}],[\"文本位置编码\",{\"1\":{\"814\":1}}],[\"文本位置单独学习一个特殊的填充\",{\"1\":{\"809\":1}}],[\"文本词表大小\",{\"1\":{\"814\":2,\"822\":1}}],[\"文本标题\",{\"1\":{\"807\":1}}],[\"文本标签\",{\"1\":{\"276\":2,\"277\":2}}],[\"文本摘要中的奖励建模与\",{\"1\":{\"536\":1}}],[\"文本到文本部分使用标准的因果掩码\",{\"1\":{\"809\":1}}],[\"文本到文本\",{\"1\":{\"531\":1}}],[\"文本到图像的相似度权重\",{\"1\":{\"162\":1,\"278\":1}}],[\"文本蕴含\",{\"1\":{\"512\":1}}],[\"文本蕴含提升5\",{\"1\":{\"507\":1}}],[\"文本蕴含提升1\",{\"1\":{\"506\":1}}],[\"文本分词\",{\"1\":{\"594\":1}}],[\"文本分类任务\",{\"1\":{\"594\":1}}],[\"文本分类\",{\"1\":{\"512\":1,\"575\":2}}],[\"文本分离\",{\"1\":{\"506\":1}}],[\"文本分支\",{\"1\":{\"307\":2}}],[\"文本生成图像\",{\"1\":{\"817\":1}}],[\"文本生成图像的研究多基于较小数据集\",{\"1\":{\"806\":1}}],[\"文本生成图像任务传统上是在固定的数据集上\",{\"1\":{\"806\":1}}],[\"文本生成\",{\"1\":{\"507\":1,\"537\":1}}],[\"文本生成阶段\",{\"1\":{\"312\":1}}],[\"文本生成任务\",{\"1\":{\"147\":1}}],[\"文本描述的生成也是一个关键环节\",{\"1\":{\"301\":1}}],[\"文本描述生成\",{\"0\":{\"301\":1}}],[\"文本问图\",{\"1\":{\"294\":1}}],[\"文本推理\",{\"1\":{\"277\":1}}],[\"文本id\",{\"1\":{\"276\":1}}],[\"文本类型\",{\"1\":{\"276\":1}}],[\"文本模态的\",{\"1\":{\"272\":1}}],[\"文本token\",{\"1\":{\"272\":1}}],[\"文本语料\",{\"1\":{\"269\":1}}],[\"文本预训练进一步提升了视觉语言模型的性能\",{\"1\":{\"268\":1}}],[\"文本预训练\",{\"1\":{\"268\":1}}],[\"文本的更轻\",{\"1\":{\"282\":1}}],[\"文本的序列特征\",{\"1\":{\"276\":1}}],[\"文本的上下文表示\",{\"1\":{\"264\":1}}],[\"文本的注意力掩码\",{\"1\":{\"162\":1}}],[\"文本输入\",{\"1\":{\"277\":1}}],[\"文本输入表示\",{\"1\":{\"263\":2}}],[\"文本输入格式处理\",{\"1\":{\"83\":1}}],[\"文本表示\",{\"1\":{\"263\":2}}],[\"文本向量表示\",{\"1\":{\"263\":1}}],[\"文本和图像\",{\"1\":{\"263\":1,\"807\":1}}],[\"文本以及图像\",{\"1\":{\"262\":1}}],[\"文本及图文对\",{\"1\":{\"260\":1}}],[\"文本匹配损失\",{\"1\":{\"198\":1}}],[\"文本数据集\",{\"1\":{\"274\":1}}],[\"文本数据\",{\"1\":{\"198\":1}}],[\"文本数据进行渐进式对齐训练\",{\"1\":{\"188\":1}}],[\"文本检索\",{\"1\":{\"202\":1,\"205\":1}}],[\"文本检索等对比任务上表现优异\",{\"1\":{\"198\":1}}],[\"文本检索以及多模态对话系统等\",{\"1\":{\"188\":1}}],[\"文本对应的标签\",{\"1\":{\"594\":1}}],[\"文本对更容易收集数据\",{\"1\":{\"266\":1}}],[\"文本对时\",{\"1\":{\"264\":1}}],[\"文本对表示进行图文匹配\",{\"1\":{\"262\":1}}],[\"文本对的表示\",{\"1\":{\"262\":1}}],[\"文本对的对称交叉熵损失\",{\"1\":{\"198\":1}}],[\"文本对上训练\",{\"1\":{\"223\":1}}],[\"文本对比损失\",{\"1\":{\"198\":1}}],[\"文本对\",{\"1\":{\"198\":1,\"262\":1,\"263\":1,\"265\":1,\"309\":1}}],[\"文本对齐策略\",{\"1\":{\"189\":1}}],[\"文本相似度\",{\"1\":{\"161\":1,\"265\":1}}],[\"文本全局语义\",{\"1\":{\"161\":1}}],[\"文本可能实际上与图像语义一致\",{\"1\":{\"157\":1}}],[\"文本中可能包含与图像无关的信息\",{\"1\":{\"157\":1}}],[\"文本经过编码后生成的嵌入序列\",{\"1\":{\"152\":1}}],[\"文本动量编码器\",{\"1\":{\"147\":1}}],[\"文本解码器\",{\"1\":{\"147\":1}}],[\"文本队列\",{\"1\":{\"147\":1}}],[\"文本跨模态编码器\",{\"1\":{\"142\":1}}],[\"文本\",{\"1\":{\"133\":1,\"147\":4,\"163\":1,\"196\":1,\"235\":1,\"264\":1,\"276\":4,\"277\":3,\"312\":2,\"561\":1,\"813\":1,\"814\":1,\"815\":3,\"817\":2,\"820\":1,\"822\":5}}],[\"文本末尾添加一个\",{\"1\":{\"126\":1}}],[\"文本特征输入部分\",{\"1\":{\"284\":1}}],[\"文本特征为空\",{\"1\":{\"277\":1}}],[\"文本特征队列\",{\"1\":{\"160\":1}}],[\"文本特征提取和投影\",{\"1\":{\"145\":1}}],[\"文本特征\",{\"1\":{\"75\":2,\"160\":1,\"277\":1}}],[\"文本引导的点特征分组\",{\"0\":{\"72\":1}}],[\"文本编码器的作用是提取文本的特征\",{\"1\":{\"299\":1}}],[\"文本编码器\",{\"1\":{\"161\":1,\"208\":2,\"299\":1,\"300\":1,\"822\":1}}],[\"文本编码器和多模态编码器均为\",{\"1\":{\"152\":1}}],[\"文本编码器和多模态编码器\",{\"1\":{\"152\":1}}],[\"文本编码器配置\",{\"1\":{\"147\":1}}],[\"文本编码器bert\",{\"1\":{\"146\":1}}],[\"文本编码器则基于\",{\"1\":{\"131\":1}}],[\"文本编码器使用的是基于\",{\"1\":{\"302\":1}}],[\"文本编码器使用\",{\"1\":{\"126\":1}}],[\"文本编码\",{\"0\":{\"31\":1},\"1\":{\"147\":1,\"260\":1,\"562\":1,\"822\":1}}],[\"样本取平均\",{\"1\":{\"868\":1}}],[\"样本方差\",{\"1\":{\"826\":1}}],[\"样本空间为\",{\"1\":{\"727\":2}}],[\"样本的得分是用生成模型分配的tokens的平均对数概率\",{\"1\":{\"516\":1}}],[\"样本为文本对\",{\"1\":{\"515\":1}}],[\"样本级别\",{\"1\":{\"470\":1}}],[\"样本标签\",{\"1\":{\"399\":1}}],[\"样本总数\",{\"1\":{\"399\":1}}],[\"样本\",{\"1\":{\"198\":1,\"727\":1}}],[\"样本分配\",{\"1\":{\"170\":1}}],[\"样本分布偏差\",{\"1\":{\"89\":1}}],[\"样本数\",{\"1\":{\"65\":1,\"398\":1}}],[\"选取最相近的向量索引\",{\"1\":{\"885\":1}}],[\"选取使得观测到的数据出现的概率\",{\"1\":{\"825\":1}}],[\"选取物体\",{\"1\":{\"63\":1}}],[\"选\",{\"1\":{\"737\":1}}],[\"选项内容\",{\"1\":{\"618\":1}}],[\"选择不改变相似性度量\",{\"1\":{\"866\":1}}],[\"选择桶编号\",{\"1\":{\"591\":1}}],[\"选择性优势\",{\"1\":{\"530\":1}}],[\"选择性能最佳的损失函数\",{\"1\":{\"474\":1}}],[\"选择合适的预训练好的大模型\",{\"1\":{\"490\":1}}],[\"选择适合的损失函数\",{\"1\":{\"474\":1}}],[\"选择最大值作为这个图文对的相似度\",{\"1\":{\"310\":1}}],[\"选择与图像特征相似度最高的文本所对应的类别\",{\"1\":{\"300\":1}}],[\"选择了一个包含6300万参数的transformer模型\",{\"1\":{\"299\":1}}],[\"选择图像键名\",{\"1\":{\"276\":1}}],[\"选择𝑁个点\",{\"1\":{\"89\":1}}],[\"选出投票最多的结果\",{\"1\":{\"502\":1}}],[\"选出他们认为最好的答案\",{\"1\":{\"232\":1}}],[\"选出\",{\"1\":{\"96\":1}}],[\"选关键点\",{\"1\":{\"92\":1}}],[\"邻近点\",{\"1\":{\"88\":1}}],[\"三部分参数更新\",{\"1\":{\"885\":1}}],[\"三部分组成\",{\"1\":{\"88\":1}}],[\"三类子数据集\",{\"1\":{\"537\":1}}],[\"三类模态专家\",{\"1\":{\"260\":1}}],[\"三步训练框架\",{\"1\":{\"537\":1}}],[\"三大原则来评估模型对齐效果\",{\"1\":{\"535\":1}}],[\"三元组\",{\"1\":{\"512\":1}}],[\"三是接下来要解答的子问题\",{\"1\":{\"503\":1}}],[\"三种损失函数\",{\"1\":{\"198\":1}}],[\"三种设置下的对比表明\",{\"1\":{\"132\":1}}],[\"三\",{\"0\":{\"410\":1,\"433\":1,\"694\":1},\"1\":{\"112\":1,\"536\":1}}],[\"三次sample\",{\"1\":{\"93\":1}}],[\"三层分层特征学习结构\",{\"1\":{\"93\":1}}],[\"三个通道之间的信息流动\",{\"1\":{\"846\":1}}],[\"三个规模的模型\",{\"1\":{\"704\":1}}],[\"三个标记的点\",{\"1\":{\"453\":1}}],[\"三个模块\",{\"1\":{\"307\":1}}],[\"三个流程\",{\"1\":{\"79\":1}}],[\"三个关键步骤的实现\",{\"1\":{\"75\":1}}],[\"局限性与挑战\",{\"1\":{\"550\":1}}],[\"局限性与未来工作\",{\"1\":{\"26\":1}}],[\"局限性\",{\"0\":{\"530\":1},\"1\":{\"522\":1,\"539\":1}}],[\"局部性\",{\"1\":{\"385\":1}}],[\"局部逼近\",{\"1\":{\"385\":1}}],[\"局部变量会在函数执行完后被释放\",{\"1\":{\"340\":1}}],[\"局部作用域\",{\"1\":{\"336\":1}}],[\"局部困难负样本挖掘\",{\"1\":{\"268\":1}}],[\"局部裁剪数量\",{\"1\":{\"186\":1}}],[\"局部裁剪\",{\"1\":{\"186\":1}}],[\"局部分辨率为\",{\"1\":{\"178\":1}}],[\"局部\",{\"1\":{\"178\":1}}],[\"局部视角2\",{\"1\":{\"186\":1}}],[\"局部视角1\",{\"1\":{\"186\":1}}],[\"局部视角\",{\"1\":{\"178\":1}}],[\"局部建模能力弱\",{\"1\":{\"112\":1}}],[\"局部特征实现上下文感知\",{\"1\":{\"112\":1}}],[\"局部特征编码\",{\"1\":{\"92\":1}}],[\"局部特征学习器\",{\"1\":{\"86\":1}}],[\"局部区域\",{\"1\":{\"92\":1}}],[\"局部区域中的每个点将相对于形心所在位置进行调整\",{\"1\":{\"91\":1}}],[\"局部区域中的点转换成相对于形心的局部坐标系\",{\"1\":{\"91\":1}}],[\"局部坐标系转换\",{\"1\":{\"91\":1}}],[\"再把采样出来的离散向量对应的嵌入输入进解码器\",{\"1\":{\"883\":1}}],[\"再对距离数组取一个\",{\"1\":{\"880\":1}}],[\"再对每个选项做分类打分\",{\"1\":{\"618\":1}}],[\"再利用vq\",{\"1\":{\"878\":1}}],[\"再让解码器根据这个向量来完成随机图片生成了\",{\"1\":{\"878\":1}}],[\"再被解码回另一幅长得差不多的图像\",{\"1\":{\"878\":1}}],[\"再介绍vq\",{\"1\":{\"877\":1}}],[\"再进一步映射为图像\",{\"1\":{\"866\":1}}],[\"再进行归一化和标准化处理\",{\"1\":{\"317\":2}}],[\"再进行视觉\",{\"1\":{\"269\":1}}],[\"再进行集成\",{\"1\":{\"138\":1}}],[\"再生成对应像素\",{\"1\":{\"865\":1}}],[\"再生成若干张局部\",{\"1\":{\"186\":1}}],[\"再设法优化这个下界\",{\"1\":{\"847\":1}}],[\"再每次使用\",{\"1\":{\"845\":1}}],[\"再采样一批噪声\",{\"1\":{\"840\":1}}],[\"再测量\",{\"1\":{\"837\":1}}],[\"再重建图像\",{\"1\":{\"773\":1}}],[\"再如\",{\"1\":{\"727\":1}}],[\"再针对性进行优化即可\",{\"1\":{\"717\":1}}],[\"再向量化存储到数据库中\",{\"1\":{\"717\":1}}],[\"再求梯度\",{\"1\":{\"697\":1}}],[\"再例如\",{\"1\":{\"660\":1}}],[\"再加偏置\",{\"1\":{\"591\":1}}],[\"再广播到\",{\"1\":{\"591\":1}}],[\"再经过softmax与采样\",{\"1\":{\"880\":1}}],[\"再经过两次\",{\"1\":{\"845\":1}}],[\"再经过非线性变换后\",{\"1\":{\"580\":1}}],[\"再经过e11这个编码器\",{\"1\":{\"246\":1}}],[\"再按照80\",{\"1\":{\"579\":1}}],[\"再到基于自注意力机制的transformer架构\",{\"1\":{\"520\":1}}],[\"再使用\",{\"1\":{\"514\":2}}],[\"再在具体任务数据上进行监督微调\",{\"1\":{\"531\":1}}],[\"再在其中添加一个分隔符得到\",{\"1\":{\"512\":1}}],[\"再在高质量数据上生成学习\",{\"1\":{\"189\":1}}],[\"再没有额外的成本\",{\"1\":{\"487\":1}}],[\"再不行尝试源码编译安装\",{\"1\":{\"438\":1}}],[\"再将整个group按照\",{\"1\":{\"428\":1}}],[\"再将融合信息返回点空间\",{\"1\":{\"75\":1}}],[\"再来看一个多维张量的例子\",{\"1\":{\"423\":1}}],[\"再来回顾我们的卷积层计算公式\",{\"1\":{\"318\":1}}],[\"再\",{\"1\":{\"361\":1,\"885\":1}}],[\"再和真实标签做交叉熵损失\",{\"1\":{\"323\":1}}],[\"再和缓存的key\",{\"1\":{\"312\":1}}],[\"再乘以缩放因子scale\",{\"1\":{\"322\":1}}],[\"再映射为\",{\"1\":{\"318\":1}}],[\"再从中心位置裁剪成224x224\",{\"1\":{\"317\":1}}],[\"再计算协方差矩阵\",{\"1\":{\"455\":1}}],[\"再计算\",{\"1\":{\"278\":1,\"868\":1}}],[\"再次扫描训练集\",{\"1\":{\"886\":1}}],[\"再次提取被掩码位置的表示\",{\"1\":{\"580\":1}}],[\"再次应用\",{\"1\":{\"321\":1}}],[\"再次遍历后半部分\",{\"1\":{\"277\":1}}],[\"再次用原始的条件\",{\"1\":{\"816\":1}}],[\"再次用\",{\"1\":{\"236\":1}}],[\"再查看在不同数据集上的表现结果\",{\"1\":{\"245\":1}}],[\"再微调\",{\"1\":{\"210\":1}}],[\"再通过跨模态注意力实现深度融合\",{\"1\":{\"150\":1}}],[\"再通过\",{\"1\":{\"140\":1,\"156\":1,\"312\":1,\"470\":1}}],[\"再通过第一个卷积层提取初始特征\",{\"1\":{\"109\":1}}],[\"再由外层\",{\"1\":{\"350\":1}}],[\"再由\",{\"1\":{\"132\":1}}],[\"再与每个点的局部特征拼接\",{\"1\":{\"111\":1}}],[\"再用vq\",{\"1\":{\"878\":1}}],[\"再用若干次\",{\"1\":{\"845\":2}}],[\"再用多模态编码器融合\",{\"1\":{\"149\":1}}],[\"再用跨模态注意力融合\",{\"1\":{\"149\":1}}],[\"再用mlp提提神\",{\"1\":{\"100\":1}}],[\"再用\",{\"1\":{\"92\":1,\"210\":1,\"807\":1}}],[\"再决定要使用什么文本查询\",{\"1\":{\"83\":1}}],[\"示例输出\",{\"1\":{\"696\":2}}],[\"示例验证\",{\"1\":{\"689\":1}}],[\"示例显示\",{\"1\":{\"538\":1}}],[\"示例或文本上下文隐式表达\",{\"1\":{\"537\":1}}],[\"示例从开发集提取\",{\"1\":{\"528\":1}}],[\"示例后\",{\"1\":{\"521\":1}}],[\"示例中设置为了1\",{\"1\":{\"476\":1}}],[\"示例4\",{\"1\":{\"372\":1}}],[\"示例3\",{\"1\":{\"372\":1,\"431\":1}}],[\"示例2\",{\"1\":{\"372\":1,\"373\":1,\"431\":1}}],[\"示例1\",{\"1\":{\"372\":1,\"373\":1,\"431\":1}}],[\"示例\",{\"1\":{\"336\":1,\"355\":1,\"376\":1,\"385\":2,\"399\":1,\"432\":1,\"616\":1,\"689\":1}}],[\"示例场景\",{\"1\":{\"239\":1}}],[\"示例文本查询\",{\"1\":{\"83\":1}}],[\"示例数据\",{\"1\":{\"83\":1}}],[\"示例为\",{\"1\":{\"11\":2,\"12\":2}}],[\"蓝色标记出的部分是提供给llm的示例\",{\"1\":{\"501\":1}}],[\"蓝色\",{\"1\":{\"83\":1}}],[\"蓝色=背景\",{\"1\":{\"83\":1}}],[\"二进制比特\",{\"1\":{\"828\":1}}],[\"二项分布关注试验次数固定\",{\"1\":{\"741\":1}}],[\"二项分布\",{\"1\":{\"737\":1}}],[\"二是已解决的子问题及其答案列表\",{\"1\":{\"503\":1}}],[\"二值化或软标签\",{\"1\":{\"467\":1}}],[\"二值化显示\",{\"1\":{\"83\":1}}],[\"二元分类器的每个输出有四种可能的结果\",{\"1\":{\"442\":1}}],[\"二元分类场景\",{\"0\":{\"441\":1}}],[\"二维嵌入索引矩阵\",{\"1\":{\"885\":1}}],[\"二维的\",{\"1\":{\"885\":1}}],[\"二维协方差矩阵\",{\"1\":{\"455\":1}}],[\"二维布局\",{\"1\":{\"423\":2}}],[\"二维张量\",{\"1\":{\"373\":1}}],[\"二维图像\",{\"1\":{\"263\":1}}],[\"二者都是对卷积操作的卷积核做了掩码处理\",{\"1\":{\"845\":1}}],[\"二者都要在同一个\",{\"1\":{\"590\":1}}],[\"二者都加同样的辅助lm\",{\"1\":{\"516\":1}}],[\"二者参数分别为\",{\"1\":{\"178\":1}}],[\"二者分别从不同实例中采样\",{\"1\":{\"19\":1}}],[\"二分类交叉熵\",{\"1\":{\"832\":1}}],[\"二分类task\",{\"0\":{\"311\":1}}],[\"二分类问题\",{\"1\":{\"248\":1}}],[\"二分类\",{\"1\":{\"162\":1}}],[\"二\",{\"0\":{\"406\":1,\"432\":1,\"679\":1},\"1\":{\"112\":1,\"536\":1}}],[\"二次sample\",{\"1\":{\"93\":1}}],[\"颜色橙色并填充\",{\"1\":{\"696\":1}}],[\"颜色抖动\",{\"1\":{\"179\":1,\"186\":1}}],[\"颜色\",{\"1\":{\"92\":1,\"114\":1,\"817\":1}}],[\"颜色等\",{\"1\":{\"92\":1}}],[\"颜色等信息\",{\"1\":{\"46\":1}}],[\"颜色映射\",{\"1\":{\"83\":1}}],[\"增大批次和训练数据\",{\"1\":{\"569\":1}}],[\"增大批次和数据规模\",{\"1\":{\"560\":1}}],[\"增大批次规模\",{\"1\":{\"559\":1}}],[\"增加数据的生成概率\",{\"1\":{\"865\":1}}],[\"增加网络的表达能力和非线性\",{\"1\":{\"704\":1}}],[\"增加模型大小或使用更多数据\",{\"1\":{\"703\":1}}],[\"增加模型鲁棒性\",{\"1\":{\"272\":1}}],[\"增加迭代次数设为\",{\"1\":{\"697\":1}}],[\"增加多样性\",{\"1\":{\"562\":1}}],[\"增加旁路矩阵来模拟全参数微调\",{\"1\":{\"495\":1}}],[\"增加\",{\"1\":{\"494\":1}}],[\"增加了检索步骤的耗时\",{\"1\":{\"711\":1}}],[\"增加了二分类器判断可答性\",{\"1\":{\"561\":1}}],[\"增加了模型层数\",{\"1\":{\"491\":1}}],[\"增加了图像的多样性\",{\"1\":{\"317\":1}}],[\"增加一些特定长度的特殊token\",{\"1\":{\"485\":1}}],[\"增加一个维度\",{\"1\":{\"370\":1}}],[\"增加批次维度\",{\"1\":{\"463\":1}}],[\"增加神经元数量\",{\"1\":{\"385\":2}}],[\"增加阶数\",{\"1\":{\"385\":1}}],[\"增加阶数提高精度\",{\"1\":{\"385\":1}}],[\"增加到\",{\"1\":{\"178\":1,\"179\":1}}],[\"增加到设定的最大值\",{\"1\":{\"159\":1}}],[\"增加特征维度\",{\"1\":{\"98\":1}}],[\"增加batch维度\",{\"1\":{\"83\":1}}],[\"增强它区分真假样本的能力\",{\"1\":{\"840\":1}}],[\"增强采样精度\",{\"1\":{\"821\":1}}],[\"增强特征提取\",{\"1\":{\"793\":1}}],[\"增强策略包括随机缩放裁剪\",{\"1\":{\"774\":1}}],[\"增强阶段\",{\"1\":{\"710\":1}}],[\"增强和生成四个阶段\",{\"1\":{\"710\":1}}],[\"增强了模型的推理和理解能力\",{\"1\":{\"709\":1}}],[\"增强了内容的可追溯性\",{\"1\":{\"709\":1}}],[\"增强了\",{\"1\":{\"704\":1}}],[\"增强整体模型的能力\",{\"1\":{\"495\":1}}],[\"增强区域匹配\",{\"1\":{\"468\":1}}],[\"增强鲁棒性\",{\"1\":{\"274\":1}}],[\"增强模型对上下文的理解能力\",{\"1\":{\"801\":1}}],[\"增强模型文字识别能力\",{\"1\":{\"225\":1}}],[\"增强模型生成能力\",{\"1\":{\"198\":1}}],[\"增强视觉理解能力并适配不同llms\",{\"1\":{\"216\":1}}],[\"增强训练稳定性\",{\"1\":{\"186\":1}}],[\"增强分布尖锐性\",{\"1\":{\"178\":1}}],[\"增强样本多样性\",{\"1\":{\"147\":1}}],[\"增强后的点特征进行卷积\",{\"1\":{\"76\":1}}],[\"增强的点特征图\",{\"1\":{\"74\":1}}],[\"增强点特征的语义判别能力\",{\"1\":{\"70\":1}}],[\"增强现实等领域\",{\"1\":{\"48\":1}}],[\"增强稳定性\",{\"1\":{\"45\":1}}],[\"增强\",{\"1\":{\"45\":2,\"138\":1}}],[\"增强空间特征表达\",{\"1\":{\"45\":1}}],[\"增强类比能力\",{\"1\":{\"12\":1}}],[\"预备知识\",{\"0\":{\"865\":1}}],[\"预归一化\",{\"1\":{\"548\":1}}],[\"预热衰减方案\",{\"1\":{\"514\":1}}],[\"预编译的二进制包\",{\"1\":{\"438\":1}}],[\"预处理阶段固定掩码模式\",{\"1\":{\"564\":1}}],[\"预处理的影响\",{\"1\":{\"522\":1}}],[\"预处理这个步骤在论文里并没有详细说明\",{\"1\":{\"317\":1}}],[\"预处理层\",{\"1\":{\"107\":1}}],[\"预计算好的图像\",{\"1\":{\"277\":2}}],[\"预留的这套模版流程是怎么设计的\",{\"1\":{\"273\":1}}],[\"预训练用的数据集加载器\",{\"1\":{\"802\":1}}],[\"预训练步数为\",{\"1\":{\"780\":1}}],[\"预训练再微调\",{\"1\":{\"775\":1}}],[\"预训练共进行约\",{\"1\":{\"774\":1}}],[\"预训练设置\",{\"0\":{\"774\":1}}],[\"预训练和微调\",{\"1\":{\"705\":1}}],[\"预训练与微调\",{\"1\":{\"608\":1}}],[\"预训练与迁移学习的趋势\",{\"1\":{\"520\":1}}],[\"预训练方法的复制研究\",{\"1\":{\"559\":1}}],[\"预训练梯度\",{\"1\":{\"536\":1}}],[\"预训练结合监督微调的方法在nlp任务中表现突出\",{\"1\":{\"520\":1}}],[\"预训练对于获取不同级别信息的需要\",{\"1\":{\"508\":1}}],[\"预训练+微调\",{\"1\":{\"507\":1}}],[\"预训练过程中的一个\",{\"1\":{\"803\":1}}],[\"预训练过程\",{\"0\":{\"476\":1}}],[\"预训练权重\",{\"1\":{\"395\":1}}],[\"预训练权重大小为393mb\",{\"1\":{\"327\":1}}],[\"预训练模型\",{\"1\":{\"803\":1}}],[\"预训练模型下载下来之后\",{\"1\":{\"593\":1}}],[\"预训练模型很容易直接zero\",{\"1\":{\"305\":1}}],[\"预训练模型中\",{\"1\":{\"302\":1}}],[\"预训练模型名称\",{\"1\":{\"302\":1}}],[\"预训练模型路径\",{\"1\":{\"83\":1}}],[\"预训练参数初始化\",{\"1\":{\"266\":1}}],[\"预训练任务\",{\"0\":{\"265\":1},\"1\":{\"268\":1,\"577\":1,\"773\":1}}],[\"预训练任务与策略\",{\"1\":{\"260\":1}}],[\"预训练旨在从大规模图文对中学习通用的跨模态表示\",{\"1\":{\"260\":1}}],[\"预训练好的\",{\"1\":{\"234\":1}}],[\"预训练是\",{\"1\":{\"234\":1}}],[\"预训练阶段实际上是将上述两个任务结合起来\",{\"1\":{\"574\":1}}],[\"预训练阶段有三个\",{\"1\":{\"275\":1}}],[\"预训练阶段非常关键\",{\"1\":{\"237\":1}}],[\"预训练阶段\",{\"1\":{\"233\":1}}],[\"预训练阶段一\",{\"0\":{\"167\":1}}],[\"预训练视觉编码器+mlp投影器\",{\"1\":{\"227\":1}}],[\"预训练数据集\",{\"1\":{\"803\":1}}],[\"预训练数据与处理\",{\"1\":{\"548\":1}}],[\"预训练数据\",{\"1\":{\"225\":1}}],[\"预训练均值\",{\"1\":{\"186\":1}}],[\"预训练在\",{\"1\":{\"179\":1}}],[\"预训练教师模型\",{\"1\":{\"176\":1}}],[\"预训练总目标函数\",{\"1\":{\"156\":1}}],[\"预训练代码实现部分参考moco论文实现\",{\"1\":{\"147\":1}}],[\"预训练\",{\"0\":{\"147\":1,\"234\":1,\"608\":1,\"792\":1},\"1\":{\"165\":1,\"531\":1,\"703\":1}}],[\"预训练环境为两个16\",{\"1\":{\"131\":1}}],[\"预训练细节\",{\"0\":{\"131\":1}}],[\"预训练目标变成恢复原始像素\",{\"1\":{\"780\":1}}],[\"预训练目标是最大化在损坏图像条件下\",{\"1\":{\"772\":1}}],[\"预训练目标\",{\"0\":{\"127\":1},\"1\":{\"125\":1,\"773\":1}}],[\"预测越接近0损失越小\",{\"1\":{\"832\":1}}],[\"预测越接近1损失越小\",{\"1\":{\"832\":1}}],[\"预测分布\",{\"1\":{\"821\":1}}],[\"预测下一个\",{\"1\":{\"820\":1}}],[\"预测下一个词\",{\"1\":{\"535\":1}}],[\"预测被遮挡位置的视觉\",{\"1\":{\"804\":1}}],[\"预测被掩码的词\",{\"1\":{\"580\":1}}],[\"预测任务\",{\"1\":{\"789\":1}}],[\"预测所有\",{\"1\":{\"780\":1}}],[\"预测正确视觉\",{\"1\":{\"772\":1}}],[\"预测正确的句对数量\",{\"1\":{\"582\":1}}],[\"预测正确的掩码词数量\",{\"1\":{\"582\":1}}],[\"预测某个结果\",{\"1\":{\"759\":1}}],[\"预测出该字的标签\",{\"1\":{\"575\":1}}],[\"预测出一个变换矩阵\",{\"1\":{\"109\":1}}],[\"预测概率分布是\",{\"1\":{\"832\":1}}],[\"预测概率\",{\"1\":{\"468\":1,\"832\":1}}],[\"预测和真实中所有正类区域之和\",{\"1\":{\"467\":1}}],[\"预测为负但实际为正的像素数量\",{\"1\":{\"471\":1}}],[\"预测为负类\",{\"1\":{\"471\":1}}],[\"预测为负例\",{\"1\":{\"442\":1}}],[\"预测为正但实际为负的像素数量\",{\"1\":{\"471\":1}}],[\"预测为正且实际也为正的像素数量\",{\"1\":{\"471\":1}}],[\"预测为正类\",{\"1\":{\"471\":2}}],[\"预测为正类且实际也为正类的部分\",{\"1\":{\"467\":1}}],[\"预测为正例\",{\"1\":{\"442\":1}}],[\"预测图像对应的文本的词袋模型\",{\"1\":{\"305\":1}}],[\"预测图像与文本是否匹配\",{\"1\":{\"265\":1}}],[\"预测目标\",{\"1\":{\"277\":1}}],[\"预测值和真实值都为\",{\"1\":{\"468\":1}}],[\"预测值\",{\"1\":{\"276\":1}}],[\"预测准确率\",{\"1\":{\"276\":1}}],[\"预测阶段\",{\"1\":{\"273\":1}}],[\"预测头\",{\"1\":{\"98\":1,\"276\":1}}],[\"预测掩码\",{\"1\":{\"83\":1}}],[\"预测结果可视化\",{\"1\":{\"83\":1}}],[\"预测结果\",{\"1\":{\"83\":1,\"580\":1}}],[\"预测点云的功能区域掩码\",{\"1\":{\"83\":1}}],[\"预测的\",{\"1\":{\"82\":1}}],[\"预测与\",{\"1\":{\"78\":1,\"467\":1}}],[\"预测\",{\"1\":{\"46\":1,\"786\":1,\"815\":1}}],[\"预测倾向训练集中已有的\",{\"1\":{\"24\":1}}],[\"杀死训练进程\",{\"1\":{\"83\":1}}],[\"脚本时非常有用\",{\"1\":{\"83\":1}}],[\"会把图像生成问题看成学习一个图像的分布\",{\"1\":{\"847\":1}}],[\"会把图像切成\",{\"1\":{\"277\":1}}],[\"会丧失多样性\",{\"1\":{\"816\":1}}],[\"会\",{\"1\":{\"815\":1}}],[\"会促使模型更关注短程依赖和高频细节\",{\"1\":{\"772\":1}}],[\"会产生环形分布\",{\"1\":{\"866\":1}}],[\"会产生\",{\"1\":{\"762\":1}}],[\"会发现线的形状类似香蕉\",{\"1\":{\"697\":1}}],[\"会将其编码为上下文相关的向量表示\",{\"1\":{\"767\":1}}],[\"会将这些输入展平\",{\"1\":{\"618\":1}}],[\"会将输入图像分割成大小为\",{\"1\":{\"327\":1}}],[\"会去分步骤思考\",{\"1\":{\"500\":1}}],[\"会去定义一些规则\",{\"1\":{\"242\":1}}],[\"会有多个用于不同目的的权重参数矩阵\",{\"1\":{\"481\":1}}],[\"会降低也是如此\",{\"1\":{\"453\":1}}],[\"会额外返回每个唯一值的\",{\"1\":{\"372\":1}}],[\"会额外返回一个张量\",{\"1\":{\"372\":1}}],[\"会改变张量的\",{\"1\":{\"361\":1}}],[\"会自动把这些变量\",{\"1\":{\"340\":1}}],[\"会泄漏\",{\"1\":{\"336\":1}}],[\"会在训练初期使用较短序列\",{\"1\":{\"561\":1}}],[\"会在get\",{\"1\":{\"312\":1}}],[\"会在coco数据集每个样本原有caption的基础上添加一个prompt\",{\"1\":{\"142\":1}}],[\"会从缓存中取出对应层先前缓存的key\",{\"1\":{\"312\":1}}],[\"会使用\",{\"1\":{\"312\":1,\"802\":1}}],[\"会进行相应的错误提示并返回\",{\"1\":{\"302\":1}}],[\"会进行推理能力结果更新\",{\"1\":{\"83\":1}}],[\"会被替换成嵌入空间里最近的真嵌入\",{\"1\":{\"883\":1}}],[\"会被编码成一个较短的向量\",{\"1\":{\"878\":1}}],[\"会被展平为向量并线性投影\",{\"1\":{\"769\":1}}],[\"会被正常回收\",{\"1\":{\"687\":1}}],[\"会被立即回收\",{\"1\":{\"687\":1}}],[\"会被交叉熵忽略\",{\"1\":{\"276\":1}}],[\"会被当作\",{\"1\":{\"274\":1}}],[\"会被划分为\",{\"1\":{\"167\":1}}],[\"会让模型只关注那个困难的负样本\",{\"1\":{\"248\":1}}],[\"会根据输入模态选择不同专家\",{\"1\":{\"264\":1}}],[\"会根据子文件夹名自动生成\",{\"1\":{\"186\":1}}],[\"会根据不同功能分支前向三次\",{\"1\":{\"127\":1}}],[\"会返回连续相同值的唯一值及计数\",{\"1\":{\"186\":1}}],[\"会得到\",{\"1\":{\"186\":1}}],[\"会出现\",{\"1\":{\"178\":1}}],[\"会导致概率的定义出现矛盾或不收敛\",{\"1\":{\"728\":1}}],[\"会导致\",{\"1\":{\"727\":2,\"835\":1}}],[\"会导致模型很难收敛\",{\"1\":{\"248\":1}}],[\"会导致距离计算不稳定\",{\"1\":{\"170\":1}}],[\"会导致非正交\",{\"1\":{\"107\":1}}],[\"会标记为\",{\"1\":{\"170\":1}}],[\"会作为\",{\"1\":{\"162\":1}}],[\"会与图像嵌入一起送入多模态编码器进行融合\",{\"1\":{\"152\":1}}],[\"会影响特征提取的一致性\",{\"1\":{\"107\":1}}],[\"会强制标准输出也像标准错误一样\",{\"1\":{\"83\":1}}],[\"会按照\",{\"1\":{\"31\":1}}],[\"当且仅当\",{\"1\":{\"728\":1}}],[\"当时的研究主要集中在采用统计学习方法来预测词汇\",{\"1\":{\"703\":1}}],[\"当表达式为3\",{\"1\":{\"690\":1}}],[\"当表达式中的左右操作数类型不同时\",{\"1\":{\"690\":1}}],[\"当操作数类型不同时\",{\"1\":{\"690\":1}}],[\"当执行x\",{\"1\":{\"690\":1}}],[\"当执行表达式a\",{\"1\":{\"690\":1}}],[\"当执行完插值得到原始图像尺寸大小时\",{\"1\":{\"463\":1}}],[\"当variable实例不再被其他对象引用时\",{\"1\":{\"687\":1}}],[\"当用户执行完一次前向传播和反向传播后\",{\"1\":{\"687\":1}}],[\"当用户不再引用variable时\",{\"1\":{\"687\":1}}],[\"当tinypytorch处理大量神经网络计算时\",{\"1\":{\"687\":1}}],[\"当对象的引用计数为0时\",{\"1\":{\"687\":1}}],[\"当某个变量被多次用作输入时\",{\"1\":{\"684\":1}}],[\"当我们希望评估某个测试样本\",{\"1\":{\"869\":1}}],[\"当我们希望从训练好的模型中生成新样本时\",{\"1\":{\"869\":1}}],[\"当我们尝试通过采样计算公式\",{\"1\":{\"867\":1}}],[\"当我们将其评估于实际观测结果\",{\"1\":{\"758\":1}}],[\"当我们讨论连续型随机变量\",{\"1\":{\"728\":1}}],[\"当我们谈论大模型时\",{\"1\":{\"718\":1}}],[\"当我们使用同一个变量分别进行多次计算时\",{\"1\":{\"683\":1}}],[\"当我们在其他任务中使用预训练好的模型时\",{\"1\":{\"317\":1}}],[\"当模型计算注意力分数时\",{\"1\":{\"591\":1}}],[\"当模型在足够大且多样化的文本数据\",{\"1\":{\"524\":1}}],[\"当训练或测试时\",{\"1\":{\"588\":1}}],[\"当训练步数远超过bert的1m步时\",{\"1\":{\"562\":1}}],[\"当然可以\",{\"1\":{\"752\":1}}],[\"当然\",{\"1\":{\"587\":1}}],[\"当然你也可以将所有词的\",{\"1\":{\"575\":1}}],[\"当中包括\",{\"1\":{\"577\":1}}],[\"当任务违反道德或逻辑前提时\",{\"1\":{\"539\":1}}],[\"当语言模型在足够多样化的文本数据上训练时\",{\"1\":{\"523\":1}}],[\"当两个变量\",{\"1\":{\"455\":3}}],[\"当精确率和召回率相差很大时\",{\"1\":{\"448\":1}}],[\"当精确率和召回率的值接近时\",{\"1\":{\"448\":1}}],[\"当精确率和召回率均为\",{\"1\":{\"448\":1}}],[\"当正例预测的准确性非常重要时\",{\"1\":{\"447\":1}}],[\"当假正例的代价高于假负例时使用\",{\"1\":{\"447\":1}}],[\"当假负例的代价高于假正例时使用\",{\"1\":{\"447\":1}}],[\"当进行转置时\",{\"1\":{\"426\":1}}],[\"当较大时\",{\"1\":{\"418\":1}}],[\"当提到模型参数量时\",{\"1\":{\"324\":1}}],[\"当使用\",{\"1\":{\"316\":1}}],[\"当使用软标签时\",{\"1\":{\"176\":1}}],[\"当cnn具有以上两种归纳偏置\",{\"1\":{\"314\":1}}],[\"当拥有足够多的数据进行预训练的时候\",{\"1\":{\"314\":1}}],[\"当is\",{\"1\":{\"312\":1}}],[\"当文本和query\",{\"1\":{\"311\":1}}],[\"当子实现类比较多的时候\",{\"1\":{\"274\":1}}],[\"当移除顶层\",{\"1\":{\"268\":1}}],[\"当数据集不均衡时\",{\"1\":{\"452\":1}}],[\"当数据集规模从\",{\"1\":{\"247\":1}}],[\"当数据量小于30m时\",{\"1\":{\"324\":1}}],[\"当数据规模增大时\",{\"1\":{\"175\":1}}],[\"当与\",{\"1\":{\"235\":1}}],[\"当filter模块在coco数据集上\",{\"1\":{\"146\":1}}],[\"当\",{\"1\":{\"143\":1,\"236\":2,\"246\":1,\"274\":1,\"321\":1,\"368\":2,\"471\":3,\"492\":1,\"686\":1,\"729\":1,\"749\":1,\"795\":1,\"796\":1,\"815\":1,\"839\":1,\"873\":1}}],[\"当输入点云非常稀疏时\",{\"1\":{\"112\":1}}],[\"当局部区域的密度较高时\",{\"1\":{\"97\":1}}],[\"当局部区域的密度较低时\",{\"1\":{\"97\":1}}],[\"当在\",{\"1\":{\"83\":1}}],[\"当前序列长度\",{\"1\":{\"820\":1}}],[\"当前epoch对应的权重衰减表\",{\"1\":{\"803\":1}}],[\"当前epoch对应的学习率表\",{\"1\":{\"803\":1}}],[\"当前epoch已训练的步数\",{\"1\":{\"803\":1}}],[\"当前epoch数\",{\"1\":{\"803\":1}}],[\"当前已经遮挡的patch数量\",{\"1\":{\"801\":1}}],[\"当前已经有的词数\",{\"1\":{\"578\":1}}],[\"当前tinypytorch已能将复杂式子转化为代码\",{\"1\":{\"696\":1}}],[\"当前tinypytorch框架中\",{\"1\":{\"687\":1}}],[\"当前token之前的text\",{\"1\":{\"312\":1}}],[\"当前输入词的query\",{\"1\":{\"544\":1}}],[\"当前输入通道数初始化为in\",{\"1\":{\"100\":1}}],[\"当前新\",{\"1\":{\"544\":1}}],[\"当前轮输出token与输入tokens拼接\",{\"1\":{\"541\":1}}],[\"当前对齐对象\",{\"1\":{\"539\":1}}],[\"当前对齐并非通用意义上的\",{\"1\":{\"539\":1}}],[\"当前偏好群体有限\",{\"1\":{\"539\":1}}],[\"当前基于微调的方法存在三个主要问题\",{\"1\":{\"527\":1}}],[\"当前的机器学习系统虽然在特定任务上表现出色\",{\"1\":{\"520\":1}}],[\"当前机器学习系统的局限性\",{\"1\":{\"520\":1}}],[\"当前实现未使用\",{\"1\":{\"470\":1}}],[\"当前模态\",{\"1\":{\"277\":1}}],[\"当前代码未使用\",{\"1\":{\"276\":1}}],[\"当前研究重点包括\",{\"1\":{\"220\":1}}],[\"当前广泛使用的视觉模型参数量仍停留在约10亿级别\",{\"1\":{\"191\":1}}],[\"当前训练轮数\",{\"1\":{\"186\":1}}],[\"当前迭代\",{\"1\":{\"186\":1}}],[\"当前主分支计算相似度\",{\"1\":{\"161\":1}}],[\"当前入队位置指针\",{\"1\":{\"160\":1}}],[\"当前论文提出了一个基于对比损失的\",{\"1\":{\"149\":1}}],[\"当前batch\",{\"1\":{\"147\":2}}],[\"当前视觉\",{\"1\":{\"120\":1,\"150\":1}}],[\"当前物体待预测的功能区域\",{\"1\":{\"83\":1}}],[\"当前物体类型\",{\"1\":{\"83\":1}}],[\"当前\",{\"1\":{\"82\":1,\"145\":1,\"186\":1,\"544\":2,\"815\":1,\"817\":1}}],[\"当前点云待预测的交互行为\",{\"1\":{\"29\":1}}],[\"当前是训练\",{\"1\":{\"29\":1}}],[\"当前交互\",{\"1\":{\"28\":1}}],[\"当前交互行为\",{\"1\":{\"28\":1}}],[\"就这样\",{\"1\":{\"880\":1}}],[\"就应该让编码器输出3组logit\",{\"1\":{\"880\":1}}],[\"就应运而生了\",{\"1\":{\"248\":1}}],[\"就被转换成了一个等价的随机生成一个较小的\",{\"1\":{\"878\":1}}],[\"就数字生成而言\",{\"1\":{\"874\":1}}],[\"就消失了\",{\"1\":{\"873\":1}}],[\"就无法使用该技巧\",{\"1\":{\"868\":1}}],[\"就需要多次对\",{\"1\":{\"868\":1}}],[\"就必须让\",{\"1\":{\"866\":1}}],[\"就必须先调用\",{\"1\":{\"360\":1}}],[\"就不能反向传播到\",{\"1\":{\"853\":1}}],[\"就没有什么特别的地方了\",{\"1\":{\"845\":1}}],[\"就没什么意义\",{\"1\":{\"248\":1}}],[\"就用默认的\",{\"1\":{\"821\":1}}],[\"就返回\",{\"1\":{\"814\":1}}],[\"就于\",{\"1\":{\"708\":1}}],[\"就像\",{\"1\":{\"817\":1}}],[\"就像让计算机阅读\",{\"1\":{\"703\":1}}],[\"就像你在地图上两个村庄中间估算温度时\",{\"1\":{\"387\":1}}],[\"就点击这里直接下载\",{\"1\":{\"593\":1}}],[\"就相当于给其注入了顺序信息\",{\"1\":{\"587\":1}}],[\"就要重新计算所有之前\",{\"1\":{\"542\":1}}],[\"就足够了\",{\"1\":{\"494\":1}}],[\"就说明这些区域对当前学习任务特别重要\",{\"1\":{\"463\":1}}],[\"就能从一个\",{\"1\":{\"590\":1}}],[\"就能反映\",{\"1\":{\"459\":1}}],[\"就能在\",{\"1\":{\"173\":1}}],[\"就得到了函数\",{\"1\":{\"758\":1}}],[\"就得到了这个格子的特征\",{\"1\":{\"387\":1}}],[\"就得到了\",{\"1\":{\"387\":1}}],[\"就看不到真实文档了\",{\"1\":{\"346\":1}}],[\"就表示模型大约有\",{\"1\":{\"324\":1}}],[\"就意味着模型大约有\",{\"1\":{\"324\":1}}],[\"就完成了从图片到token之间的转换\",{\"1\":{\"318\":1}}],[\"就有了很多先验信息\",{\"1\":{\"314\":1}}],[\"就从\",{\"1\":{\"277\":1}}],[\"就可以引入一个类似\",{\"1\":{\"873\":1}}],[\"就可以直接处理图像数据\",{\"1\":{\"769\":1}}],[\"就可以\",{\"1\":{\"426\":1}}],[\"就可以拿到所有样本的特征\",{\"1\":{\"250\":1}}],[\"就可以认为其无限被\",{\"1\":{\"246\":1}}],[\"就会推动模型向这一特定参数化方式靠拢\",{\"1\":{\"871\":1}}],[\"就会得到文中那种\",{\"1\":{\"807\":1}}],[\"就会抵达\",{\"1\":{\"697\":1}}],[\"就会进行数据复制以创建新的张量\",{\"1\":{\"362\":1}}],[\"就会导致只有最后一条路径上的梯度被保留\",{\"1\":{\"684\":1}}],[\"就会导致不利用图像信息\",{\"1\":{\"285\":1}}],[\"就会导致特征\",{\"1\":{\"249\":1}}],[\"就会立即在屏幕上显示一个字符\",{\"1\":{\"83\":1}}],[\"就是拿解码器输入\",{\"1\":{\"881\":1}}],[\"就是vq\",{\"1\":{\"878\":1}}],[\"就是为了能在图像生成时把编码器扔掉\",{\"1\":{\"878\":1}}],[\"就是在图像分布里随机采样一张图\",{\"1\":{\"847\":1}}],[\"就是告诉你\",{\"1\":{\"834\":1}}],[\"就是取使\",{\"1\":{\"825\":1}}],[\"就是最大似然估计的直观思想\",{\"1\":{\"825\":1}}],[\"就是从分布中采样一个\",{\"1\":{\"819\":1}}],[\"就是重构项\",{\"1\":{\"807\":1}}],[\"就是计算这些\",{\"1\":{\"727\":1}}],[\"就是没有答案\",{\"1\":{\"575\":1}}],[\"就是正常的词向量\",{\"1\":{\"573\":1}}],[\"就是正样本\",{\"1\":{\"248\":1}}],[\"就是随机遮盖或替换一句话里面的任意字或词\",{\"1\":{\"572\":1}}],[\"就是其中一个将此概念付诸实践的例子\",{\"1\":{\"571\":1}}],[\"就是大数据集有效\",{\"1\":{\"516\":1}}],[\"就是猜测被分配到高的概率值的token作为预测值\",{\"1\":{\"516\":1}}],[\"就是识别文本蕴含\",{\"1\":{\"515\":1}}],[\"就是需要更新的参数\",{\"1\":{\"492\":1}}],[\"就是将结构化输入转换为有序序列以便作者预训练能处理\",{\"1\":{\"512\":1}}],[\"就是将y=wx中的w\",{\"1\":{\"486\":1}}],[\"就是将变成\",{\"1\":{\"485\":1}}],[\"就是将传统cnn和transformer进行结合\",{\"1\":{\"326\":1}}],[\"就是fft存在的上述两个问题\",{\"1\":{\"483\":1}}],[\"就是用特定的数据\",{\"1\":{\"483\":1}}],[\"就是用了\",{\"1\":{\"250\":1}}],[\"就是根据问题找到相关内容并返回\",{\"1\":{\"414\":1}}],[\"就是一个包含\",{\"1\":{\"758\":1}}],[\"就是一个不错的方案\",{\"1\":{\"482\":1}}],[\"就是一个序列数据转换的问题\",{\"1\":{\"481\":1}}],[\"就是一个采样点\",{\"1\":{\"387\":1}}],[\"就是一种很好的解决方式\",{\"1\":{\"248\":1}}],[\"就是两个人的位置\",{\"1\":{\"837\":1}}],[\"就是两个线性层+gelu激活函数+dropout的结构\",{\"1\":{\"321\":1}}],[\"就是两个编码器都可以通过梯度回传进行更新\",{\"1\":{\"250\":1}}],[\"就是利用量化技术的一个变体\",{\"1\":{\"495\":1}}],[\"就是利用一个卷积核大小为16x16\",{\"1\":{\"318\":1}}],[\"就是利用这个动量的特性\",{\"1\":{\"244\":1}}],[\"就是把整个数据集的特征\",{\"1\":{\"250\":1}}],[\"就是把所有的负样本一视同仁\",{\"1\":{\"248\":1}}],[\"就是这个端到端的框架\",{\"1\":{\"250\":1}}],[\"就是这个图\",{\"1\":{\"246\":1}}],[\"就是\",{\"1\":{\"248\":1,\"249\":1,\"250\":2,\"387\":1,\"854\":1,\"881\":1}}],[\"就是我们要把给llm做的任务尽可能细化\",{\"1\":{\"499\":1}}],[\"就是我们的负样本数量\",{\"1\":{\"248\":1}}],[\"就是我们的\",{\"1\":{\"248\":1}}],[\"就是我们的模型在大量无标注的数据集上进行训练之后\",{\"1\":{\"246\":1}}],[\"就是我们不需要知道前两张图片是人这个类别\",{\"1\":{\"242\":1}}],[\"就是想得到一个模型\",{\"1\":{\"246\":1}}],[\"就是数据集中剩余的所有图片都是负样本\",{\"1\":{\"246\":1}}],[\"就是它可以从大量未标注的数据上学习到特征\",{\"1\":{\"245\":1}}],[\"就是不想让当前时刻的输出只是依赖于当前时刻的输入\",{\"1\":{\"244\":1}}],[\"就是代理任务是多样性的\",{\"1\":{\"243\":1}}],[\"就是第一张图片和第二张图片是同一个类别\",{\"1\":{\"242\":1}}],[\"就是经过\",{\"1\":{\"74\":1}}],[\"就拼接起来\",{\"1\":{\"100\":1}}],[\"就更新它\",{\"1\":{\"92\":1}}],[\"存一个标量\",{\"1\":{\"591\":1}}],[\"存在一个重要问题\",{\"1\":{\"868\":1}}],[\"存在一个或多个潜变量设置\",{\"1\":{\"865\":1}}],[\"存在一定的噪声\",{\"1\":{\"305\":1}}],[\"存在的问题\",{\"1\":{\"717\":1}}],[\"存在某些函数\",{\"1\":{\"385\":1}}],[\"存在以下不足\",{\"1\":{\"173\":1}}],[\"存在缓存机制\",{\"1\":{\"83\":1}}],[\"存储验证集图片对应索引信息\",{\"1\":{\"316\":1}}],[\"存储验证集的所有图片路径\",{\"1\":{\"316\":1}}],[\"存储训练集图片对应索引信息\",{\"1\":{\"316\":1}}],[\"存储训练集的所有图片路径\",{\"1\":{\"316\":1}}],[\"存储每个类别的样本总数\",{\"1\":{\"316\":1}}],[\"存储每层\",{\"1\":{\"277\":1}}],[\"存储每次选出的\",{\"1\":{\"92\":1}}],[\"存储是为了快速矩阵乘\",{\"1\":{\"257\":1}}],[\"存储图像描述引导提示词\",{\"1\":{\"142\":1}}],[\"存储数组\",{\"1\":{\"82\":1}}],[\"存储了物体边界框文件路径\",{\"1\":{\"58\":1}}],[\"均和vae实现部分保持一致\",{\"1\":{\"858\":1}}],[\"均能支持流式处理\",{\"1\":{\"714\":1}}],[\"均能正确构建反向传播路径\",{\"1\":{\"692\":1}}],[\"均是混合推理模型\",{\"1\":{\"704\":1}}],[\"均经过严格去重\",{\"1\":{\"548\":1}}],[\"均值和方差\",{\"1\":{\"743\":1}}],[\"均值是\",{\"1\":{\"459\":1}}],[\"均值\",{\"1\":{\"366\":1,\"869\":1}}],[\"均值作为最终评估指标\",{\"1\":{\"82\":1}}],[\"均冻结\",{\"1\":{\"307\":1}}],[\"均匀采样\",{\"1\":{\"801\":1}}],[\"均匀输出\",{\"1\":{\"183\":1}}],[\"均匀分布意味着我们希望所有\",{\"1\":{\"800\":1}}],[\"均匀分布随机数填充\",{\"1\":{\"371\":1}}],[\"均匀分布\",{\"1\":{\"175\":1,\"829\":1}}],[\"均匀性假设\",{\"1\":{\"90\":1}}],[\"均有性能提升\",{\"1\":{\"132\":1}}],[\"均保持不变\",{\"1\":{\"30\":1}}],[\"取负号\",{\"1\":{\"854\":1}}],[\"取平均\",{\"1\":{\"837\":2}}],[\"取平均或\",{\"1\":{\"822\":1}}],[\"取对数得到\",{\"1\":{\"854\":1}}],[\"取对数得\",{\"1\":{\"826\":1}}],[\"取对应的索引\",{\"1\":{\"100\":1}}],[\"取决于\",{\"1\":{\"821\":1}}],[\"取决于是否能容纳在2048\",{\"1\":{\"528\":1}}],[\"取当前时间步\",{\"1\":{\"817\":1}}],[\"取最大概率的\",{\"1\":{\"821\":1}}],[\"取最后一层\",{\"1\":{\"781\":1}}],[\"取最小值\",{\"1\":{\"115\":1}}],[\"取最小的三个距离\",{\"1\":{\"100\":1}}],[\"取反\",{\"1\":{\"591\":1}}],[\"取得了显著进展\",{\"1\":{\"568\":1}}],[\"取得了领先的零样本分类准确率\",{\"1\":{\"201\":1}}],[\"取值范围\",{\"1\":{\"391\":1}}],[\"取\",{\"1\":{\"277\":1,\"311\":1,\"368\":2,\"882\":1}}],[\"取第1行到第3行\",{\"1\":{\"425\":1}}],[\"取第一个cls\",{\"1\":{\"309\":1}}],[\"取第\",{\"1\":{\"277\":1,\"355\":1}}],[\"取图像\",{\"1\":{\"277\":1}}],[\"取每个位置的平均作为最终的匹配得分\",{\"1\":{\"311\":1}}],[\"取每个\",{\"1\":{\"186\":1}}],[\"取双向平均\",{\"1\":{\"161\":1}}],[\"取出出现次数最多的字符对\",{\"1\":{\"477\":2}}],[\"取出该区域内的最大值\",{\"1\":{\"386\":1}}],[\"取出该行中得分最大的那一列\",{\"1\":{\"303\":1}}],[\"取出经过\",{\"1\":{\"277\":1}}],[\"取出文本相关的张量\",{\"1\":{\"276\":1}}],[\"取出批大小\",{\"1\":{\"272\":1}}],[\"取出\",{\"1\":{\"161\":2,\"276\":1,\"277\":1}}],[\"取出图像和文本的\",{\"1\":{\"277\":1}}],[\"取出图像并做视觉编码\",{\"1\":{\"276\":1}}],[\"取出图像\",{\"1\":{\"142\":1}}],[\"取出当前批次的图像列表\",{\"1\":{\"302\":1}}],[\"取出当前最远点的坐标\",{\"1\":{\"92\":1}}],[\"取出当前样本对应的点云数据\",{\"1\":{\"68\":1}}],[\"取所有点的平均值\",{\"1\":{\"115\":1}}],[\"取所有点的最大值\",{\"1\":{\"115\":1}}],[\"取均值或求和\",{\"1\":{\"467\":1}}],[\"取均值\",{\"1\":{\"82\":1}}],[\"|n|\",{\"1\":{\"591\":1}}],[\"||i\",{\"1\":{\"105\":1}}],[\"|\",{\"1\":{\"82\":4,\"294\":4,\"387\":8,\"390\":4,\"582\":2,\"594\":2,\"814\":2,\"848\":1}}],[\"直通梯度\",{\"1\":{\"795\":1}}],[\"直到生成器能够生成看起来很真实的数据\",{\"1\":{\"840\":1}}],[\"直到观察到\",{\"1\":{\"741\":1}}],[\"直到抽出\",{\"1\":{\"740\":1}}],[\"直到达到一个较为稳定\",{\"1\":{\"717\":1}}],[\"直到达到预定迭代次数或收敛条件\",{\"1\":{\"170\":1}}],[\"直到无法合并为止\",{\"1\":{\"477\":3}}],[\"直线距离\",{\"1\":{\"457\":1}}],[\"直观地说\",{\"1\":{\"825\":1}}],[\"直观解释如下\",{\"0\":{\"754\":1}}],[\"直观上\",{\"1\":{\"455\":1}}],[\"直观理解js散度\",{\"0\":{\"837\":1}}],[\"直观理解\",{\"1\":{\"385\":1,\"390\":1,\"457\":1,\"458\":1}}],[\"直观的重排\",{\"1\":{\"370\":1}}],[\"直方图交集\",{\"1\":{\"82\":1}}],[\"直接从\",{\"1\":{\"869\":1}}],[\"直接从标准正态分布采样\",{\"1\":{\"869\":1}}],[\"直接从预测的概率分布里采样出第\",{\"1\":{\"843\":1}}],[\"直接假设\",{\"1\":{\"866\":1}}],[\"直接拿一个神经网络来评价生成的图像好不好\",{\"1\":{\"847\":1}}],[\"直接平均所有\",{\"1\":{\"822\":1}}],[\"直接加载\",{\"1\":{\"792\":1}}],[\"直接预测图像\",{\"1\":{\"788\":1}}],[\"直接预测掩码块的原始像素会导致模型过度关注短程依赖和高频细节\",{\"1\":{\"766\":1}}],[\"直接预测教师网络\",{\"1\":{\"173\":1}}],[\"直接更新检索知识库\",{\"1\":{\"711\":1}}],[\"直接处理和分析上传的数据文件\",{\"1\":{\"704\":1}}],[\"直接处理的原始点特征\",{\"1\":{\"97\":1}}],[\"直接进行运算\",{\"1\":{\"690\":1}}],[\"直接保留\",{\"1\":{\"590\":1}}],[\"直接计算概率\",{\"1\":{\"521\":1}}],[\"直接计算相似度\",{\"1\":{\"277\":1}}],[\"直接在大规模强化学习\",{\"1\":{\"704\":1}}],[\"直接在监督学习任务上训练\",{\"1\":{\"516\":1}}],[\"直接在原张量上进行操作\",{\"1\":{\"371\":1}}],[\"直接微调模型\",{\"1\":{\"512\":1}}],[\"直接影响着大模型给出答案的正确与否\",{\"1\":{\"497\":1}}],[\"直接丢给它个指令\",{\"1\":{\"497\":1}}],[\"直接优化\",{\"1\":{\"467\":1}}],[\"直接把这个像素的值赋给输出像素\",{\"1\":{\"389\":1}}],[\"直接建模图像与文本的交互\",{\"1\":{\"269\":1}}],[\"直接建模跨模态特征相似性\",{\"1\":{\"52\":1}}],[\"直接套到对比学习中去\",{\"1\":{\"248\":1}}],[\"直接照搬\",{\"1\":{\"247\":1}}],[\"直接拷贝学生参数\",{\"1\":{\"178\":1}}],[\"直接使用标准高斯采样值\",{\"1\":{\"869\":1}}],[\"直接使用的就是交叉熵损失函数代码\",{\"1\":{\"248\":1}}],[\"直接使用原始任务描述\",{\"1\":{\"239\":1}}],[\"直接使用internvit\",{\"1\":{\"197\":1}}],[\"直接使用\",{\"1\":{\"170\":1,\"268\":1,\"544\":1}}],[\"直接点积即可\",{\"1\":{\"170\":1}}],[\"直接返回解码图像\",{\"1\":{\"821\":1}}],[\"直接返回\",{\"1\":{\"163\":1,\"815\":1,\"821\":1}}],[\"直接用编码后的\",{\"1\":{\"807\":1}}],[\"直接用prompt\",{\"1\":{\"482\":1}}],[\"直接用\",{\"1\":{\"159\":1}}],[\"直接以点集作为输入\",{\"1\":{\"103\":1}}],[\"直接复制其特征到所有原始点\",{\"1\":{\"100\":1}}],[\"直接提取的特征\",{\"1\":{\"97\":1}}],[\"直接对\",{\"1\":{\"847\":1}}],[\"直接对图像进行分类\",{\"1\":{\"300\":2}}],[\"直接对所有点进行特征提取\",{\"1\":{\"92\":1}}],[\"直接对整句进行编码\",{\"1\":{\"31\":1}}],[\"直接输入冻结参数的\",{\"1\":{\"313\":1}}],[\"直接输入\",{\"1\":{\"82\":1}}],[\"直接评价分割精度\",{\"1\":{\"82\":1}}],[\"直接添加\",{\"1\":{\"68\":1}}],[\"直接关联结构与功能\",{\"1\":{\"51\":1}}],[\"直接拼接图像与点云特征作为输入\",{\"1\":{\"22\":1}}],[\"`j+1`\",{\"1\":{\"423\":1}}],[\"`j`\",{\"1\":{\"423\":1}}],[\"`2`\",{\"1\":{\"423\":2}}],[\"`1`\",{\"1\":{\"423\":2}}],[\"`i+1`\",{\"1\":{\"423\":2}}],[\"`i`\",{\"1\":{\"423\":2}}],[\"`3`\",{\"1\":{\"423\":2}}],[\"`\",{\"1\":{\"82\":1,\"423\":8}}],[\"角度\",{\"1\":{\"82\":1}}],[\"排列\",{\"0\":{\"762\":1}}],[\"排列不变性\",{\"1\":{\"112\":1}}],[\"排行榜提交\",{\"1\":{\"566\":1}}],[\"排除\",{\"1\":{\"463\":2,\"804\":1,\"866\":1}}],[\"排除当前\",{\"1\":{\"278\":1}}],[\"排除与几何矛盾的意图\",{\"1\":{\"32\":1}}],[\"排序为\",{\"1\":{\"305\":1}}],[\"排序\",{\"1\":{\"82\":1,\"316\":1}}],[\"∞\",{\"1\":{\"82\":1,\"469\":2,\"819\":1}}],[\"否\",{\"1\":{\"82\":8,\"239\":3,\"364\":2,\"469\":3}}],[\"否则就永远不能完全编码一个实数向量\",{\"1\":{\"873\":1}}],[\"否则会直接把\",{\"1\":{\"815\":1}}],[\"否则无法计算图像\",{\"1\":{\"815\":1}}],[\"否则返回损失\",{\"1\":{\"821\":1}}],[\"否则返回\",{\"1\":{\"794\":1}}],[\"否则返回视图\",{\"1\":{\"362\":1}}],[\"否则用\",{\"1\":{\"793\":1}}],[\"否则取\",{\"1\":{\"738\":1}}],[\"否则答案可能不合理\",{\"1\":{\"616\":1}}],[\"否则保存这两个句子的\",{\"1\":{\"578\":1}}],[\"否则对齐仅为形式上的\",{\"1\":{\"539\":1}}],[\"否则应注释掉这行\",{\"1\":{\"467\":1}}],[\"否则可能报错\",{\"1\":{\"361\":1}}],[\"否则为恒等映射\",{\"1\":{\"323\":1}}],[\"否则存入训练集\",{\"1\":{\"316\":1}}],[\"否则更新为新的中心\",{\"1\":{\"170\":1}}],[\"否则\",{\"1\":{\"112\":1}}],[\"否则只有\",{\"1\":{\"93\":1}}],[\"否则使用恒等映射\",{\"1\":{\"321\":1}}],[\"否则使用\",{\"1\":{\"92\":1,\"318\":2,\"821\":1}}],[\"否则使用给定的\",{\"1\":{\"43\":1}}],[\"否则固定返回问题0\",{\"1\":{\"68\":1}}],[\"❌\",{\"1\":{\"82\":8,\"103\":1,\"116\":1,\"336\":4,\"364\":5,\"469\":3,\"473\":6,\"616\":2}}],[\"✅\",{\"0\":{\"412\":1,\"413\":1,\"414\":1},\"1\":{\"82\":8,\"105\":5,\"107\":3,\"109\":2,\"111\":2,\"112\":12,\"115\":7,\"116\":1,\"336\":4,\"341\":2,\"346\":3,\"364\":4,\"469\":8,\"473\":14,\"614\":2,\"616\":4,\"618\":1,\"801\":1,\"831\":1,\"885\":1,\"886\":1}}],[\"成立的样本点集合\",{\"1\":{\"727\":1}}],[\"成为研究和应用的热门工具\",{\"1\":{\"864\":1}}],[\"成为了当今计算机科学和人工智能领域的重要研究和应用方向\",{\"1\":{\"705\":1}}],[\"成为了现象级爆火应用\",{\"1\":{\"704\":1}}],[\"成为史上增长最快的\",{\"1\":{\"704\":1}}],[\"成为当时史上用户增长最快的消费级应用程序\",{\"1\":{\"704\":1}}],[\"成为首个在零样本设置下接近监督模型性能的大规模语言模型\",{\"1\":{\"521\":1}}],[\"成多头格式\",{\"1\":{\"605\":1}}],[\"成本效益\",{\"1\":{\"704\":1}}],[\"成本低\",{\"1\":{\"539\":1}}],[\"成本较高\",{\"1\":{\"453\":1}}],[\"成员存入类的属性字典\",{\"1\":{\"336\":1}}],[\"成功加载预训练的\",{\"1\":{\"885\":1,\"886\":1}}],[\"成功次数随机\",{\"1\":{\"741\":1}}],[\"成功\",{\"1\":{\"741\":2}}],[\"成功为蓝球\",{\"0\":{\"741\":1}}],[\"成功生成json文件\",{\"1\":{\"577\":2}}],[\"成功弥合了视觉模型与大型语言模型之间的能力与表示鸿沟\",{\"1\":{\"206\":1}}],[\"成功实现了视觉与语言模型在参数规模和特征表示上的协调\",{\"1\":{\"188\":1}}],[\"成原来的特征图形状\",{\"1\":{\"170\":1}}],[\"成一个大的局部区域\",{\"1\":{\"92\":1}}],[\"成\",{\"1\":{\"82\":1,\"107\":1,\"618\":1}}],[\"影响内容的可信度\",{\"1\":{\"709\":1}}],[\"影响泛化能力\",{\"1\":{\"562\":1}}],[\"影响模型的运行效率\",{\"1\":{\"587\":1}}],[\"影响模型性能\",{\"1\":{\"491\":1}}],[\"影响模型容量和梯度稳定性\",{\"1\":{\"413\":1}}],[\"影响比较大的问题\",{\"1\":{\"483\":1}}],[\"影响显著\",{\"1\":{\"387\":1}}],[\"影响\",{\"1\":{\"82\":1}}],[\"敏感度有限\",{\"1\":{\"82\":1}}],[\"绘制等高线图\",{\"1\":{\"697\":1}}],[\"绘制到图表中\",{\"1\":{\"450\":1}}],[\"绘制每种类别个数柱状图\",{\"1\":{\"316\":1}}],[\"绘制\",{\"1\":{\"82\":1,\"450\":1}}],[\"还不如直接理解成\",{\"1\":{\"881\":1}}],[\"还不如直接预测词袋模型\",{\"1\":{\"305\":1}}],[\"还认识其他来自标准正态分布的向量\",{\"1\":{\"878\":1}}],[\"还原所需的最小比特数\",{\"1\":{\"872\":1}}],[\"还原出\",{\"1\":{\"872\":1}}],[\"还原为重建图像\",{\"1\":{\"885\":1}}],[\"还原为\",{\"1\":{\"867\":1,\"886\":1}}],[\"还优化了\",{\"1\":{\"870\":1}}],[\"还依赖于编码器\",{\"1\":{\"868\":1}}],[\"还要包含书写角度\",{\"1\":{\"866\":1}}],[\"还屏蔽掉卷积中心\",{\"1\":{\"846\":1}}],[\"还需要额外将\",{\"1\":{\"821\":1}}],[\"还需要对每个像素进行分类\",{\"1\":{\"465\":1}}],[\"还希望它能\",{\"1\":{\"815\":1}}],[\"还希望和之前时刻的输出有关系\",{\"1\":{\"244\":1}}],[\"还可以传入初始图像条件\",{\"1\":{\"817\":1}}],[\"还可以推导出全概率公式\",{\"1\":{\"731\":1}}],[\"还可以定义累积分布函数\",{\"1\":{\"728\":1}}],[\"还可能占用大量的内存空间\",{\"1\":{\"587\":1}}],[\"还具备网页浏览\",{\"1\":{\"704\":1}}],[\"还确保了复杂表达式的自动微分正确性\",{\"1\":{\"690\":1}}],[\"还取决于\",{\"1\":{\"589\":1}}],[\"还将一个工具方法整合到了分词器的实现之中\",{\"1\":{\"578\":1}}],[\"还未进行初始化\",{\"1\":{\"544\":1}}],[\"还评估模型在\",{\"1\":{\"537\":1}}],[\"还借鉴了对语言模型潜在风险的研究\",{\"1\":{\"536\":1}}],[\"还有一个大特点\",{\"1\":{\"847\":1}}],[\"还有很多种\",{\"1\":{\"488\":1}}],[\"还有另一个方向\",{\"1\":{\"305\":1}}],[\"还考虑数据在各个维度上的方差大小和维度间的相关性\",{\"1\":{\"458\":1}}],[\"还考虑了从更低分辨率\",{\"1\":{\"97\":1}}],[\"还是只是记住了相似的训练样本\",{\"1\":{\"530\":1}}],[\"还是\",{\"1\":{\"426\":1}}],[\"还扩展了计数相关方法\",{\"1\":{\"401\":1}}],[\"还在336的分辨率下额外进行了一个周期的微调\",{\"1\":{\"299\":1}}],[\"还在多项视觉\",{\"1\":{\"280\":1}}],[\"还好\",{\"1\":{\"250\":1}}],[\"还小\",{\"1\":{\"92\":1}}],[\"还能够处理更复杂的自动微分任务\",{\"1\":{\"695\":1}}],[\"还能提高其泛化能力\",{\"1\":{\"539\":1}}],[\"还能提供更灵活的语义参考\",{\"1\":{\"157\":1}}],[\"还能计算任意条件概率\",{\"1\":{\"521\":1}}],[\"还能生成与\",{\"1\":{\"82\":1}}],[\"还能感知其他\",{\"1\":{\"76\":1}}],[\"还看响应强度分布\",{\"1\":{\"82\":1}}],[\"⚠️\",{\"1\":{\"82\":4,\"112\":1,\"115\":1,\"346\":2,\"386\":1,\"467\":1,\"469\":1,\"616\":1,\"799\":1,\"885\":1,\"886\":1}}],[\"衡量的是\",{\"1\":{\"854\":1}}],[\"衡量\",{\"1\":{\"794\":1,\"798\":1}}],[\"衡量点与均值之间的距离\",{\"1\":{\"455\":1}}],[\"衡量模型预测分布与动量模型生成的软标签之间的差异\",{\"1\":{\"157\":1}}],[\"衡量模型对二分类问题的判别能力\",{\"1\":{\"82\":1}}],[\"衡量空间重合度\",{\"1\":{\"82\":1}}],[\"衡量分类器整体判别能力\",{\"1\":{\"82\":1}}],[\"衡量分类器排序能力\",{\"1\":{\"82\":1}}],[\"衡量分布相似性\",{\"1\":{\"82\":2}}],[\"衡量逐点误差\",{\"1\":{\"82\":2}}],[\"衡量预测区域与真实标签之间的空间重合度\",{\"1\":{\"82\":1}}],[\"衡量预测掩码与\",{\"1\":{\"78\":1}}],[\"衡量整体分布一致性\",{\"1\":{\"82\":1}}],[\"✔️\",{\"1\":{\"82\":11,\"468\":4,\"469\":3,\"473\":4}}],[\"特殊像素映射操作\",{\"1\":{\"802\":1}}],[\"特殊情况说明\",{\"0\":{\"742\":1}}],[\"特殊\",{\"1\":{\"616\":1}}],[\"特殊操作后的中间结果\",{\"1\":{\"362\":1}}],[\"特定任务输入转换\",{\"0\":{\"512\":1}}],[\"特点\",{\"1\":{\"390\":1,\"392\":1,\"393\":1,\"395\":1,\"468\":2,\"704\":4,\"801\":1}}],[\"特点与作用\",{\"1\":{\"82\":4}}],[\"特别强化了对客观事实的准确性\",{\"1\":{\"704\":1}}],[\"特别值得注意的是\",{\"1\":{\"523\":1}}],[\"特别适用于图像分割任务\",{\"1\":{\"473\":1}}],[\"特别常用于文本向量\",{\"1\":{\"391\":1}}],[\"特别是分析等式\",{\"1\":{\"870\":1}}],[\"特别是语言建模\",{\"1\":{\"577\":1}}],[\"特别是降后期的推理成本\",{\"1\":{\"488\":1}}],[\"特别是在小样本数据集上\",{\"1\":{\"781\":1}}],[\"特别是在小数据集\",{\"1\":{\"522\":1}}],[\"特别是在像\",{\"1\":{\"475\":1}}],[\"特别是在遮挡严重的情况下\",{\"1\":{\"112\":1}}],[\"特别是\",{\"1\":{\"269\":1,\"404\":1,\"872\":1}}],[\"特别注意初始化方法中传入的\",{\"1\":{\"186\":1}}],[\"特性\",{\"1\":{\"82\":4,\"364\":1,\"438\":1,\"469\":1,\"689\":1}}],[\"特征比较\",{\"1\":{\"711\":2}}],[\"特征值分解\",{\"1\":{\"455\":1}}],[\"特征图的边长\",{\"1\":{\"814\":1}}],[\"特征图\",{\"1\":{\"386\":1,\"463\":2}}],[\"特征较特殊\",{\"1\":{\"277\":1}}],[\"特征向量可提前计算存储\",{\"1\":{\"260\":1}}],[\"特征回归\",{\"1\":{\"260\":1}}],[\"特征质量\",{\"1\":{\"173\":1}}],[\"特征中会自然出现场景布局与物体边界\",{\"1\":{\"173\":1}}],[\"特征的影响\",{\"1\":{\"173\":1}}],[\"特征队列初始化\",{\"1\":{\"147\":1}}],[\"特征映射到共享空间\",{\"1\":{\"147\":1}}],[\"特征投影层\",{\"1\":{\"145\":1}}],[\"特征融合\",{\"1\":{\"115\":1}}],[\"特征融合准备\",{\"1\":{\"59\":1}}],[\"特征空间一致\",{\"1\":{\"198\":1}}],[\"特征空间变换矩阵\",{\"1\":{\"109\":1}}],[\"特征空间对齐\",{\"1\":{\"52\":1}}],[\"特征变换开关\",{\"1\":{\"109\":1}}],[\"特征插值方式\",{\"1\":{\"98\":1}}],[\"特征传播层\",{\"0\":{\"100\":1}}],[\"特征传播\",{\"1\":{\"98\":1,\"100\":1}}],[\"特征传播阶段结束\",{\"1\":{\"70\":1}}],[\"特征传播阶段\",{\"1\":{\"70\":1}}],[\"特征编码\",{\"1\":{\"91\":1}}],[\"特征通道维度\",{\"1\":{\"76\":1}}],[\"特征增强\",{\"1\":{\"59\":1,\"115\":1}}],[\"特征分布对齐损失\",{\"1\":{\"55\":1}}],[\"特征提取网络相对轻量\",{\"1\":{\"307\":1}}],[\"特征提取网络\",{\"1\":{\"186\":1}}],[\"特征提取\",{\"0\":{\"109\":1},\"1\":{\"54\":1}}],[\"特征维度\",{\"1\":{\"46\":1,\"272\":1}}],[\"特征从原始嵌入维度\",{\"1\":{\"42\":1}}],[\"特征\",{\"1\":{\"40\":2,\"100\":1,\"160\":1,\"165\":1,\"277\":11,\"591\":1}}],[\"标题\",{\"1\":{\"807\":1}}],[\"标记进行下一句预测\",{\"1\":{\"580\":1}}],[\"标记\",{\"1\":{\"274\":1,\"312\":1}}],[\"标记哪些簇没有分配到样本\",{\"1\":{\"170\":1}}],[\"标记是否完成初始化\",{\"1\":{\"169\":1}}],[\"标记序列开始\",{\"1\":{\"126\":1}}],[\"标记为已初始化\",{\"1\":{\"170\":1}}],[\"标记为\",{\"1\":{\"82\":1}}],[\"标准的回归模型在这种情况下会失败\",{\"1\":{\"874\":1}}],[\"标准正态分布\",{\"1\":{\"869\":1}}],[\"标准正态空间\",{\"1\":{\"869\":1}}],[\"标准正态\",{\"1\":{\"853\":1}}],[\"标准与示例\",{\"1\":{\"539\":1}}],[\"标准提供训练信号\",{\"1\":{\"537\":1}}],[\"标准交叉熵损失\",{\"1\":{\"470\":1}}],[\"标准\",{\"1\":{\"163\":1,\"186\":1,\"470\":2,\"802\":1}}],[\"标准差单位距离\",{\"1\":{\"459\":1}}],[\"标准差\",{\"1\":{\"115\":1}}],[\"标准化\",{\"1\":{\"186\":1,\"458\":1,\"459\":1,\"463\":1}}],[\"标准化输出\",{\"1\":{\"163\":1}}],[\"标准化输入点云和特征空间\",{\"1\":{\"103\":1}}],[\"标准化的意义\",{\"1\":{\"107\":1}}],[\"标准错误\",{\"1\":{\"83\":1}}],[\"标准输出\",{\"1\":{\"83\":1}}],[\"标签生成等\",{\"1\":{\"803\":1}}],[\"标签为x\",{\"1\":{\"696\":1}}],[\"标签平滑\",{\"1\":{\"581\":1}}],[\"标签图\",{\"1\":{\"389\":1}}],[\"标签中非\",{\"1\":{\"276\":1}}],[\"标签等信息\",{\"1\":{\"276\":1}}],[\"标签过度惩罚合理预测\",{\"1\":{\"157\":1}}],[\"标签约束\",{\"1\":{\"157\":1}}],[\"标签的监督会一律惩罚这些\",{\"1\":{\"157\":1}}],[\"标签二值化\",{\"1\":{\"82\":1}}],[\"标签\",{\"1\":{\"82\":1,\"154\":1,\"162\":1,\"163\":2,\"248\":1,\"276\":1,\"277\":2,\"278\":1,\"295\":1,\"802\":1,\"859\":2}}],[\"标注者\",{\"1\":{\"539\":1}}],[\"标注者人数有限\",{\"1\":{\"539\":1}}],[\"标注者受其引导\",{\"1\":{\"539\":1}}],[\"标注者的偏好\",{\"1\":{\"539\":1}}],[\"标注者之间都保持一致\",{\"1\":{\"538\":1}}],[\"标注者实验\",{\"1\":{\"537\":1}}],[\"标注者在判断指令时需考虑信息准确性\",{\"1\":{\"537\":1}}],[\"标注者创作的\",{\"1\":{\"537\":1}}],[\"标注数据昂贵又耗时\",{\"1\":{\"507\":1}}],[\"标注数据组织形式\",{\"1\":{\"68\":1}}],[\"标注图像中的物体及其位置\",{\"1\":{\"234\":1}}],[\"标注\",{\"0\":{\"64\":1}}],[\"标注策略\",{\"0\":{\"18\":1}}],[\"平等地使用\",{\"1\":{\"800\":1}}],[\"平方\",{\"1\":{\"752\":1}}],[\"平滑采样\",{\"1\":{\"819\":1}}],[\"平滑程度\",{\"1\":{\"819\":1}}],[\"平滑控制长宽比例分布\",{\"1\":{\"801\":1}}],[\"平滑系数\",{\"1\":{\"471\":1,\"473\":1}}],[\"平滑项\",{\"1\":{\"467\":1,\"468\":2,\"469\":1,\"470\":1}}],[\"平滑\",{\"1\":{\"390\":1}}],[\"平滑过的对比目标\",{\"1\":{\"161\":1}}],[\"平滑处理\",{\"1\":{\"115\":1}}],[\"平衡文本和图像两部分的训练目标\",{\"1\":{\"815\":1}}],[\"平衡正负样本数量\",{\"1\":{\"470\":1}}],[\"平衡类别数量\",{\"1\":{\"470\":1}}],[\"平衡效率与精度\",{\"1\":{\"229\":1}}],[\"平衡其指导作用\",{\"1\":{\"157\":1}}],[\"平衡因子\",{\"1\":{\"78\":1,\"470\":1}}],[\"平移到正索引区间\",{\"1\":{\"590\":1}}],[\"平移等变换具有鲁棒性\",{\"1\":{\"105\":1}}],[\"平移\",{\"1\":{\"104\":1,\"107\":1,\"116\":1}}],[\"平移中心到以关键点为原点的局部坐标系上\",{\"1\":{\"92\":1}}],[\"平均图像\",{\"1\":{\"874\":1}}],[\"平均近似\",{\"1\":{\"866\":1}}],[\"平均是指求期望\",{\"1\":{\"831\":1}}],[\"平均\",{\"1\":{\"831\":2}}],[\"平均每个样本要多花多少信息量\",{\"1\":{\"831\":1}}],[\"平均两个方向的\",{\"1\":{\"822\":1}}],[\"平均分布\",{\"1\":{\"821\":1}}],[\"平均分成\",{\"1\":{\"374\":1}}],[\"平均偏见得分66\",{\"1\":{\"551\":1}}],[\"平均重叠率3\",{\"1\":{\"522\":1}}],[\"平均估计\",{\"1\":{\"387\":2}}],[\"平均对称\",{\"1\":{\"387\":1}}],[\"平均可达\",{\"1\":{\"202\":1}}],[\"平均精度达到\",{\"1\":{\"201\":1}}],[\"平均池化\",{\"1\":{\"115\":1,\"776\":1}}],[\"平均值作为损失项\",{\"1\":{\"108\":1}}],[\"平均交并比\",{\"1\":{\"82\":1}}],[\"平均绝对误差\",{\"1\":{\"82\":1}}],[\"反卷积上采样\",{\"1\":{\"793\":1}}],[\"反卷积层\",{\"1\":{\"777\":1}}],[\"反而有所提升\",{\"1\":{\"562\":1}}],[\"反而更\",{\"1\":{\"538\":1}}],[\"反复多次\",{\"1\":{\"541\":1}}],[\"反毒性\",{\"1\":{\"539\":1}}],[\"反应很快\",{\"1\":{\"500\":1}}],[\"反推出来的\",{\"1\":{\"470\":1}}],[\"反之\",{\"1\":{\"453\":1,\"814\":1}}],[\"反之亦然\",{\"1\":{\"94\":1}}],[\"反过来计算text\",{\"1\":{\"310\":1}}],[\"反转亮部\",{\"1\":{\"186\":1}}],[\"反射中都非常重要\",{\"1\":{\"346\":1}}],[\"反射\",{\"1\":{\"108\":1,\"112\":1,\"117\":1}}],[\"反距离加权插值\",{\"1\":{\"98\":1}}],[\"反映出互联网用户对于聊天和对话这种交互模式的偏好\",{\"1\":{\"708\":1}}],[\"反映社会偏见\",{\"1\":{\"549\":1}}],[\"反映的是模型对正确样本的能力\",{\"1\":{\"274\":1}}],[\"反映模型是否准确学习语言引导下的响应强度\",{\"1\":{\"82\":1}}],[\"反映点与功能核心区域的距离远近\",{\"1\":{\"64\":1}}],[\"反向传播与参数更新\",{\"1\":{\"885\":1}}],[\"反向传播用到的\",{\"1\":{\"881\":1}}],[\"反向传播用于计算输入x对输出y大小变化的影响\",{\"1\":{\"656\":1}}],[\"反向传播其实不会用到式子的值\",{\"1\":{\"881\":1}}],[\"反向传播并更新参数\",{\"1\":{\"803\":1}}],[\"反向传播正确计算了每个变量的梯度\",{\"1\":{\"690\":1}}],[\"反向传播时取\",{\"1\":{\"881\":1}}],[\"反向传播时\",{\"1\":{\"881\":1}}],[\"反向传播时仍保持连续可导\",{\"1\":{\"796\":1}}],[\"反向传播时需按此计算梯度\",{\"1\":{\"690\":2}}],[\"反向传播时需要将上游传来的梯度gy分别乘以x1和x0\",{\"1\":{\"690\":1}}],[\"反向传播时将上游梯度取反\",{\"1\":{\"690\":1}}],[\"反向传播时可直接获取这些值\",{\"1\":{\"660\":1}}],[\"反向传播过程中它的梯度应累加\",{\"1\":{\"684\":1}}],[\"反向传播过程中\",{\"1\":{\"657\":1}}],[\"反向传播按从输出到输入的顺序计算导数\",{\"1\":{\"656\":1}}],[\"反向传播的自动化\",{\"0\":{\"663\":1}}],[\"反向传播的执行\",{\"0\":{\"662\":1}}],[\"反向传播的核心是依据链式法则\",{\"1\":{\"660\":1}}],[\"反向传播的方向\",{\"0\":{\"656\":1}}],[\"反向传播的理论基础是链式法则\",{\"1\":{\"655\":1}}],[\"反向传播的理论知识\",{\"0\":{\"654\":1}}],[\"反向传播更新模型参数过程\",{\"1\":{\"490\":1}}],[\"反向传播\",{\"1\":{\"81\":2,\"142\":1,\"161\":1,\"186\":1,\"678\":1,\"690\":1,\"803\":1,\"885\":1}}],[\"损失就是\",{\"1\":{\"832\":2}}],[\"损失之间的权重分配\",{\"1\":{\"473\":1}}],[\"损失权重仅降低\",{\"1\":{\"470\":1}}],[\"损失权重降低\",{\"1\":{\"470\":1}}],[\"损失几乎不受影响\",{\"1\":{\"470\":1}}],[\"损失被大幅降低\",{\"1\":{\"470\":1}}],[\"损失越小表示预测越接近真实标签\",{\"1\":{\"469\":1}}],[\"损失结合在一起的一种损失函数\",{\"1\":{\"468\":1}}],[\"损失值逐渐降低\",{\"1\":{\"319\":1}}],[\"损失记录到\",{\"1\":{\"276\":1}}],[\"损失乘以权重\",{\"1\":{\"276\":1}}],[\"损失也会很大\",{\"1\":{\"249\":1}}],[\"损失\",{\"1\":{\"149\":1,\"163\":1,\"186\":1,\"276\":1,\"277\":1,\"295\":1,\"821\":1,\"885\":1}}],[\"损失计算与反向传播\",{\"1\":{\"319\":1}}],[\"损失计算的是整个字典做多分类\",{\"1\":{\"249\":1}}],[\"损失计算\",{\"1\":{\"81\":1}}],[\"损失函数与优化器\",{\"1\":{\"848\":1}}],[\"损失函数直接作用于\",{\"1\":{\"319\":1}}],[\"损失函数类\",{\"1\":{\"186\":1}}],[\"损失函数定义\",{\"1\":{\"80\":1}}],[\"损失函数\",{\"0\":{\"77\":1,\"466\":1},\"1\":{\"186\":1,\"248\":2,\"469\":1,\"473\":1,\"581\":1}}],[\"损失函数由\",{\"1\":{\"15\":1}}],[\"更准确地说是\",{\"1\":{\"872\":1}}],[\"更重要的是\",{\"1\":{\"867\":1}}],[\"更重视精确率\",{\"1\":{\"471\":1}}],[\"更重视召回率\",{\"1\":{\"471\":1}}],[\"更宽松\",{\"1\":{\"846\":1}}],[\"更早\",{\"1\":{\"846\":1}}],[\"更陡\",{\"1\":{\"839\":1}}],[\"更加随机\",{\"1\":{\"819\":1}}],[\"更加符合人类的一些期望\",{\"1\":{\"483\":1}}],[\"更符合图像结构\",{\"1\":{\"801\":1}}],[\"更符合用户指令\",{\"1\":{\"539\":1}}],[\"更真实地模拟自然场景中的遮挡\",{\"1\":{\"801\":1}}],[\"更形式化地说\",{\"1\":{\"730\":1,\"825\":1}}],[\"更长的上下文长度\",{\"1\":{\"704\":1}}],[\"更长训练步数\",{\"1\":{\"565\":1}}],[\"更进一步划分\",{\"1\":{\"704\":1}}],[\"更接近真实框架的自动微分系统\",{\"1\":{\"680\":1}}],[\"更因为其背后复杂而精妙的自动微分系统\",{\"1\":{\"680\":1}}],[\"更大批次\",{\"1\":{\"567\":1}}],[\"更大批次训练\",{\"1\":{\"559\":1}}],[\"更大规模数据\",{\"1\":{\"565\":1}}],[\"更大的词表\",{\"1\":{\"704\":1}}],[\"更大的批次规模\",{\"1\":{\"558\":1}}],[\"更大的模型在几乎所有任务上都显著优于小模型\",{\"1\":{\"522\":1}}],[\"更大的模型在多个基准测试中达到了最先进水平\",{\"1\":{\"519\":1}}],[\"更严格的数据清洗\",{\"1\":{\"551\":1}}],[\"更不代表所有受语言模型影响的人群\",{\"1\":{\"539\":1}}],[\"更受欢迎\",{\"1\":{\"539\":1}}],[\"更受偏好\",{\"1\":{\"538\":1}}],[\"更常\",{\"1\":{\"538\":1}}],[\"更少毒性\",{\"1\":{\"539\":1}}],[\"更少生成有毒文本\",{\"1\":{\"538\":1}}],[\"更少生成有害内容\",{\"1\":{\"536\":1}}],[\"更少编造\",{\"1\":{\"538\":1}}],[\"更少\",{\"1\":{\"538\":1}}],[\"更具可控性\",{\"1\":{\"539\":1}}],[\"更具\",{\"1\":{\"536\":1}}],[\"更具体地说\",{\"1\":{\"451\":1}}],[\"更好的提升大模型在特定领域的能力\",{\"1\":{\"482\":1}}],[\"更好地遵循指令\",{\"1\":{\"538\":1}}],[\"更好地理解和执行用户给出的自然语言指令\",{\"1\":{\"232\":1}}],[\"更好地应对\",{\"1\":{\"78\":1}}],[\"更稳定的估计收敛\",{\"1\":{\"869\":1}}],[\"更稳定的训练过程\",{\"1\":{\"473\":1}}],[\"更稳定地收敛\",{\"1\":{\"468\":1}}],[\"更贴近最终评估指标\",{\"1\":{\"469\":1}}],[\"更贴近真实用户交互\",{\"1\":{\"239\":1}}],[\"更能知道如何将vq\",{\"1\":{\"877\":1}}],[\"更能遵守\",{\"1\":{\"538\":1}}],[\"更能反映真实的\",{\"1\":{\"460\":1}}],[\"更能增强模型将视觉信息转化为自然语言的能力\",{\"1\":{\"127\":1}}],[\"更广泛地说\",{\"1\":{\"448\":1}}],[\"更容易在训练中收敛\",{\"1\":{\"797\":1}}],[\"更容易处理复杂计算图\",{\"1\":{\"669\":1}}],[\"更容易被采到\",{\"1\":{\"403\":1}}],[\"更容易训练\",{\"1\":{\"107\":1}}],[\"更适合拟合离散分布\",{\"1\":{\"878\":1}}],[\"更适合长训练周期\",{\"1\":{\"562\":1}}],[\"更适合用于\",{\"1\":{\"538\":1}}],[\"更适合作为用户助手\",{\"1\":{\"538\":1}}],[\"更适合前景极少的小区域识别\",{\"1\":{\"468\":1}}],[\"更适合评估边界模糊区域\",{\"1\":{\"469\":1}}],[\"更适合评估\",{\"1\":{\"82\":1}}],[\"更适应局部特征\",{\"1\":{\"385\":1}}],[\"更灵活适应目标函数\",{\"1\":{\"385\":1}}],[\"更关注召回率\",{\"1\":{\"473\":1}}],[\"更关注精确率\",{\"1\":{\"473\":1}}],[\"更关注整体区域匹配\",{\"1\":{\"467\":1}}],[\"更关注\",{\"1\":{\"250\":1,\"467\":1}}],[\"更强的任务泛化能力\",{\"1\":{\"239\":1}}],[\"更强的视觉主干\",{\"1\":{\"132\":1}}],[\"更多内容可参考文献\",{\"1\":{\"872\":1}}],[\"更多分布使用到的时候再进行补充\",{\"1\":{\"749\":1}}],[\"更多的训练数据量\",{\"1\":{\"704\":1}}],[\"更多的数据\",{\"1\":{\"558\":1}}],[\"更多数据是关键\",{\"1\":{\"567\":1}}],[\"更多消融实验见附录\",{\"1\":{\"268\":1}}],[\"更多图块\",{\"1\":{\"229\":1}}],[\"更多视角数\",{\"1\":{\"184\":1}}],[\"更丰富的表征\",{\"1\":{\"186\":1}}],[\"更聚焦\",{\"1\":{\"186\":1}}],[\"更小的patch能带来准确率提升\",{\"1\":{\"181\":1}}],[\"更小的patch尺寸能显著提升vit\",{\"1\":{\"181\":1}}],[\"更倾向于生成数据集中常见的\",{\"1\":{\"133\":1}}],[\"更复杂的对称函数建模\",{\"1\":{\"115\":1}}],[\"更有效\",{\"1\":{\"105\":1}}],[\"更新嵌入向量\",{\"1\":{\"885\":1}}],[\"更新总长度\",{\"1\":{\"815\":1}}],[\"更新已遮挡patch数量\",{\"1\":{\"801\":1}}],[\"更新判断\",{\"1\":{\"758\":1}}],[\"更新成本高\",{\"1\":{\"711\":1}}],[\"更新至\",{\"1\":{\"704\":1}}],[\"更新项\",{\"1\":{\"537\":1}}],[\"更新计数\",{\"1\":{\"401\":1}}],[\"更新特征数量为表示层的维度\",{\"1\":{\"323\":1}}],[\"更新会非常缓慢\",{\"1\":{\"246\":1}}],[\"更新教师输出中心\",{\"1\":{\"186\":1}}],[\"更新教师网络参数\",{\"1\":{\"186\":1}}],[\"更新学生网络参数\",{\"1\":{\"186\":1}}],[\"更新参数\",{\"1\":{\"186\":1}}],[\"更新下一个起始位置\",{\"1\":{\"186\":1}}],[\"更新下一层的输入通道数\",{\"1\":{\"100\":1}}],[\"更新方式为\",{\"1\":{\"178\":1}}],[\"更新规则为\",{\"1\":{\"178\":1}}],[\"更新和量化逻辑\",{\"1\":{\"170\":1}}],[\"更新衰减系数\",{\"1\":{\"170\":1}}],[\"更新后的中心需要做\",{\"1\":{\"170\":1}}],[\"更新簇中心\",{\"1\":{\"170\":2}}],[\"更新超参\",{\"1\":{\"170\":1}}],[\"更新的衰减系数\",{\"1\":{\"170\":1}}],[\"更新权重和\",{\"1\":{\"169\":1}}],[\"更新动量编码器参数\",{\"1\":{\"161\":1}}],[\"更新动量队列\",{\"1\":{\"145\":1}}],[\"更新负样本队列\",{\"1\":{\"147\":1}}],[\"更新\",{\"1\":{\"147\":1,\"160\":1,\"167\":1,\"169\":3,\"170\":6,\"178\":1,\"815\":1,\"885\":3}}],[\"更新队列\",{\"1\":{\"145\":1,\"161\":1}}],[\"更新模型参数\",{\"1\":{\"142\":1}}],[\"更新索引\",{\"1\":{\"82\":1}}],[\"更高效\",{\"1\":{\"680\":1}}],[\"更高效的字节级\",{\"1\":{\"559\":1}}],[\"更高效的性能\",{\"1\":{\"26\":1}}],[\"更高毒性\",{\"1\":{\"538\":1}}],[\"更高分辨率\",{\"1\":{\"97\":1}}],[\"更易于管理的子集\",{\"1\":{\"86\":1}}],[\"抑制简单样本的梯度主导\",{\"1\":{\"470\":1}}],[\"抑制简单样本\",{\"1\":{\"470\":1}}],[\"抑制均匀输出\",{\"1\":{\"183\":1}}],[\"抑制\",{\"1\":{\"78\":1,\"470\":1}}],[\"正是变分自编码器的核心思想\",{\"1\":{\"867\":1}}],[\"正是对这一缺陷的改进\",{\"1\":{\"112\":1}}],[\"正好可以直接来自模型输出\",{\"1\":{\"853\":1}}],[\"正好捕捉了\",{\"1\":{\"816\":1}}],[\"正好为resnet18最后生成的特征图的分辨率\",{\"1\":{\"59\":1}}],[\"正比于\",{\"1\":{\"758\":1}}],[\"正态程度\",{\"1\":{\"748\":1}}],[\"正态分布\",{\"0\":{\"746\":1},\"1\":{\"826\":1}}],[\"正面\",{\"1\":{\"829\":1}}],[\"正面出现次数\",{\"1\":{\"727\":1}}],[\"正面影响\",{\"1\":{\"539\":1}}],[\"正在改变着我们与技术互动的方式\",{\"1\":{\"708\":1}}],[\"正式开源\",{\"1\":{\"704\":1}}],[\"正式开源了\",{\"1\":{\"704\":1}}],[\"正式发布了其稳定版本\",{\"1\":{\"714\":1}}],[\"正式发布\",{\"1\":{\"704\":1}}],[\"正向传播\",{\"1\":{\"690\":1}}],[\"正向图文对的前向传播\",{\"1\":{\"162\":1}}],[\"正负方向可能分桶\",{\"1\":{\"591\":1}}],[\"正数\",{\"1\":{\"591\":1}}],[\"正余弦位置编码通过在不同维度上引入不同波长的正余弦信号\",{\"1\":{\"587\":1}}],[\"正弦和余弦\",{\"1\":{\"587\":1}}],[\"正弦余弦位置编码通常是高维向量\",{\"1\":{\"587\":1}}],[\"正弦余弦位置编码是一种基于三角函数的固定编码方式\",{\"1\":{\"587\":1}}],[\"正弦余弦位置编码\",{\"1\":{\"587\":1,\"588\":1}}],[\"正弦\",{\"0\":{\"587\":1}}],[\"正则项\",{\"1\":{\"807\":1}}],[\"正则\",{\"1\":{\"514\":1}}],[\"正则匹配含有\",{\"1\":{\"476\":1}}],[\"正则化参数\",{\"1\":{\"870\":1,\"873\":3}}],[\"正则化\",{\"1\":{\"170\":1,\"704\":1}}],[\"正则化损失\",{\"0\":{\"108\":1}}],[\"正相关\",{\"1\":{\"455\":1}}],[\"正确的累加方式\",{\"1\":{\"684\":1,\"686\":1}}],[\"正确\",{\"1\":{\"497\":1,\"575\":1}}],[\"正确识别阳性病例至关重要\",{\"1\":{\"444\":1}}],[\"正确分类的比例\",{\"1\":{\"443\":1}}],[\"正常工作\",{\"1\":{\"868\":1}}],[\"正常\",{\"1\":{\"728\":1}}],[\"正常情况下\",{\"1\":{\"340\":1}}],[\"正常推理时为\",{\"1\":{\"277\":1}}],[\"正图负文\",{\"1\":{\"162\":2}}],[\"正图像\",{\"1\":{\"162\":1}}],[\"正文负图\",{\"1\":{\"162\":2}}],[\"正文本\",{\"1\":{\"162\":1}}],[\"正样本在对角线\",{\"1\":{\"822\":1}}],[\"正样本较少时增加权重\",{\"1\":{\"470\":1}}],[\"正样本batch=1\",{\"1\":{\"311\":1}}],[\"正样本batch\",{\"1\":{\"311\":3}}],[\"正样本推理\",{\"1\":{\"278\":1}}],[\"正样本为\",{\"1\":{\"278\":1}}],[\"正样本图文对往往关联性较弱\",{\"1\":{\"157\":1}}],[\"正样本概率为\",{\"1\":{\"154\":1}}],[\"正样本对\",{\"1\":{\"147\":1}}],[\"正样本\",{\"1\":{\"145\":2,\"162\":2}}],[\"正样本编码\",{\"1\":{\"145\":2}}],[\"正交变换包括\",{\"1\":{\"117\":1}}],[\"正交变换的本质是\",{\"1\":{\"117\":1}}],[\"正交变换\",{\"0\":{\"117\":1}}],[\"正类\",{\"1\":{\"78\":1}}],[\"负无穷\",{\"1\":{\"818\":1}}],[\"负二项分布变为几何分布\",{\"1\":{\"744\":1}}],[\"负二项分布的意义与优势\",{\"0\":{\"744\":1}}],[\"负二项分布的两个矩\",{\"1\":{\"743\":1}}],[\"负二项分布关注成功次数固定\",{\"1\":{\"741\":1}}],[\"负二项分布\",{\"0\":{\"740\":1},\"1\":{\"741\":1}}],[\"负数运算y\",{\"1\":{\"690\":1}}],[\"负数运算\",{\"1\":{\"690\":1}}],[\"负数\",{\"1\":{\"591\":1}}],[\"负号\",{\"1\":{\"470\":1}}],[\"负相关\",{\"1\":{\"455\":1}}],[\"负图像\",{\"1\":{\"162\":1}}],[\"负文本\",{\"1\":{\"162\":1}}],[\"负样本batch2=0\",{\"1\":{\"311\":1}}],[\"负样本batch2\",{\"1\":{\"311\":3}}],[\"负样本batch1=0\",{\"1\":{\"311\":1}}],[\"负样本batch1\",{\"1\":{\"311\":3}}],[\"负样本为\",{\"1\":{\"278\":1}}],[\"负样本数量\",{\"1\":{\"254\":1,\"277\":1}}],[\"负样本x2\",{\"1\":{\"246\":1}}],[\"负样本概率为\",{\"1\":{\"154\":1}}],[\"负样本\",{\"1\":{\"145\":2,\"157\":1,\"162\":1,\"470\":1}}],[\"负类\",{\"1\":{\"78\":1}}],[\"负责判断输入是真实数据还是生成器造出来的假数据\",{\"1\":{\"840\":1}}],[\"负责从随机噪声生成\",{\"1\":{\"840\":1}}],[\"负责组织多个\",{\"1\":{\"312\":1}}],[\"负责组织自注意力和交叉注意力的运算流程\",{\"1\":{\"312\":1}}],[\"负责组内信息混合\",{\"1\":{\"73\":2}}],[\"负责管理多个子数据集\",{\"1\":{\"274\":1}}],[\"负责完成出队入队的信息记录\",{\"1\":{\"254\":1}}],[\"负责通道间信息混合\",{\"1\":{\"73\":2}}],[\"掩码类型\",{\"1\":{\"846\":1}}],[\"掩码卷积\",{\"0\":{\"844\":1}}],[\"掩码策略也在\",{\"1\":{\"772\":1}}],[\"掩码机制\",{\"1\":{\"622\":1}}],[\"掩码符号\",{\"1\":{\"578\":1}}],[\"掩码候选位置\",{\"1\":{\"578\":1}}],[\"掩码语言模型\",{\"1\":{\"560\":1}}],[\"掩码语言建模\",{\"1\":{\"260\":1,\"261\":1,\"265\":1,\"568\":1,\"580\":1,\"772\":1}}],[\"掩码语言建模中的动量蒸馏\",{\"1\":{\"157\":1}}],[\"掩码等\",{\"1\":{\"366\":1}}],[\"掩码区域分类和特征回归\",{\"1\":{\"261\":1}}],[\"掩码区域分类\",{\"1\":{\"260\":1}}],[\"掩码图像建模\",{\"0\":{\"772\":1},\"1\":{\"165\":1,\"766\":1,\"772\":1,\"773\":1}}],[\"掩码高度匹配的功能区域\",{\"1\":{\"82\":1}}],[\"掩码之间的逐点偏差\",{\"1\":{\"82\":1}}],[\"掩码\",{\"1\":{\"78\":1,\"198\":1,\"208\":1,\"276\":1,\"389\":1,\"467\":1,\"469\":2,\"470\":1,\"562\":1}}],[\"或普通梯度更新\",{\"1\":{\"885\":1}}],[\"或不确定\",{\"1\":{\"829\":1}}],[\"或不参与优化\",{\"1\":{\"773\":1}}],[\"或密度\",{\"1\":{\"826\":1}}],[\"或很小\",{\"1\":{\"821\":1}}],[\"或仅返回被\",{\"1\":{\"804\":1}}],[\"或假设\",{\"1\":{\"758\":1}}],[\"或后验推理\",{\"1\":{\"758\":1}}],[\"或隐藏\",{\"1\":{\"758\":1}}],[\"或称\",{\"1\":{\"740\":1}}],[\"或太\",{\"1\":{\"728\":1}}],[\"或开源模型来实现核心的理解与生成\",{\"1\":{\"716\":1}}],[\"或记忆\",{\"1\":{\"704\":1}}],[\"或更多\",{\"1\":{\"703\":1}}],[\"或x\",{\"1\":{\"690\":1}}],[\"或返回notimplemented\",{\"1\":{\"690\":3}}],[\"或实现\",{\"1\":{\"689\":1}}],[\"或变量\",{\"1\":{\"686\":1}}],[\"或两个句子\",{\"1\":{\"616\":1}}],[\"或doc\",{\"1\":{\"564\":1}}],[\"或微调的前提下\",{\"1\":{\"529\":1}}],[\"或释义发现\",{\"1\":{\"515\":1}}],[\"或准确率\",{\"1\":{\"447\":1}}],[\"或模型的误报率\",{\"1\":{\"445\":1}}],[\"或源码\",{\"1\":{\"438\":1}}],[\"或数组\",{\"1\":{\"427\":1}}],[\"或矩阵\",{\"1\":{\"425\":1}}],[\"或加权和\",{\"1\":{\"377\":1}}],[\"或可以通过在前面添加维度来自动广播\",{\"1\":{\"364\":1}}],[\"或新形状无法与原内存布局兼容时\",{\"1\":{\"362\":1}}],[\"或某些要求内存连续的操作\",{\"1\":{\"360\":1}}],[\"或类\",{\"1\":{\"342\":1}}],[\"或类似模型\",{\"1\":{\"170\":1}}],[\"或恒等映射\",{\"1\":{\"272\":1}}],[\"或其他传入的额外参数\",{\"1\":{\"272\":1}}],[\"或文本\",{\"1\":{\"264\":1}}],[\"或者说\",{\"1\":{\"883\":1}}],[\"或者说在于计算能力和数据集的规模\",{\"1\":{\"305\":1}}],[\"或者非要从\",{\"1\":{\"881\":1}}],[\"或者换个角度说\",{\"1\":{\"878\":1}}],[\"或者私有化模型\",{\"1\":{\"712\":1}}],[\"或者直接命令行运行\",{\"1\":{\"593\":1}}],[\"或者更广义地\",{\"1\":{\"473\":1}}],[\"或者更细一点\",{\"1\":{\"246\":1}}],[\"或者你不在意尺度差异\",{\"1\":{\"460\":1}}],[\"或者在达到某个最低准确性水平的情况下\",{\"1\":{\"447\":1}}],[\"或者一种错误\",{\"1\":{\"443\":1}}],[\"或者使用\",{\"1\":{\"426\":1}}],[\"或者使用其他方法\",{\"1\":{\"170\":1}}],[\"或者跨设备\",{\"1\":{\"362\":1}}],[\"或者这个任务需要更多的视觉信息\",{\"1\":{\"286\":1}}],[\"或者\",{\"1\":{\"248\":1,\"312\":1,\"434\":1,\"476\":1,\"738\":1}}],[\"或者其他的数据增广操作\",{\"1\":{\"243\":1}}],[\"或前缀\",{\"1\":{\"239\":1}}],[\"或视觉语言模型性能的技术\",{\"1\":{\"239\":1}}],[\"或多任务场景下的表现\",{\"1\":{\"232\":1}}],[\"或全局池化特征\",{\"1\":{\"196\":1}}],[\"或与bert系列模型对齐\",{\"1\":{\"191\":1}}],[\"或未初始化分布式训练时\",{\"1\":{\"170\":1}}],[\"或相似度最大的中心\",{\"1\":{\"170\":1}}],[\"或相似度最高的簇\",{\"1\":{\"170\":1}}],[\"或相似度\",{\"1\":{\"170\":1}}],[\"或图结构增强局部建模能力\",{\"1\":{\"112\":1}}],[\"或图像视图\",{\"1\":{\"103\":1}}],[\"或转置卷积\",{\"1\":{\"100\":1}}],[\"或每组邻域大小\",{\"1\":{\"95\":1}}],[\"或局部区域\",{\"1\":{\"86\":1}}],[\"或\",{\"1\":{\"78\":1,\"82\":1,\"83\":1,\"86\":1,\"98\":1,\"132\":1,\"163\":1,\"167\":1,\"175\":1,\"178\":1,\"179\":1,\"234\":1,\"255\":1,\"272\":1,\"274\":3,\"276\":1,\"277\":1,\"289\":1,\"355\":1,\"359\":1,\"366\":1,\"387\":1,\"388\":1,\"389\":1,\"398\":2,\"403\":1,\"423\":1,\"425\":1,\"431\":1,\"438\":1,\"467\":1,\"468\":2,\"471\":1,\"473\":2,\"591\":2,\"705\":1,\"727\":2,\"729\":1,\"730\":1,\"749\":1,\"750\":1,\"793\":1,\"795\":1,\"796\":1,\"800\":1,\"801\":1,\"802\":1,\"803\":2,\"821\":2,\"828\":1,\"848\":1,\"853\":1,\"868\":1,\"885\":1}}],[\"或经过\",{\"1\":{\"78\":1,\"469\":1,\"470\":1}}],[\"或平均池化\",{\"1\":{\"76\":1}}],[\"强推理能力\",{\"1\":{\"704\":1}}],[\"强记忆型的语言预测器\",{\"1\":{\"530\":1}}],[\"强视觉编码器\",{\"1\":{\"225\":1}}],[\"强视觉表征\",{\"1\":{\"216\":1}}],[\"强大的神经网络模型\",{\"1\":{\"703\":1}}],[\"强大的视觉编码器\",{\"1\":{\"215\":1,\"216\":1}}],[\"强大性能\",{\"1\":{\"189\":1}}],[\"强制屏蔽掉不允许看的区域\",{\"1\":{\"848\":1}}],[\"强制学生跨视图对齐\",{\"1\":{\"186\":1}}],[\"强制学习正交变换矩阵\",{\"1\":{\"112\":1}}],[\"强制将每个样本开头的\",{\"1\":{\"143\":1}}],[\"强度\",{\"1\":{\"114\":1}}],[\"强调责任约束\",{\"1\":{\"550\":1}}],[\"强调未来开发和部署语言模型时需格外关注其社会影响及安全性\",{\"1\":{\"535\":1}}],[\"强调它们在无需微调的情况下就能取得良好效果\",{\"1\":{\"528\":1}}],[\"强调预测与\",{\"1\":{\"468\":1,\"469\":1}}],[\"强调分布匹配\",{\"1\":{\"82\":1}}],[\"强调正类\",{\"1\":{\"78\":1}}],[\"强化系数\",{\"1\":{\"817\":1}}],[\"强化复杂任务处理能力\",{\"1\":{\"704\":1}}],[\"强化学习\",{\"0\":{\"723\":1},\"1\":{\"537\":1}}],[\"强化学习来自人类反馈\",{\"1\":{\"536\":1}}],[\"强化学习微调\",{\"1\":{\"535\":1}}],[\"强化学习方法\",{\"1\":{\"49\":1,\"51\":1}}],[\"强化了模型对长上下文的理解和生成\",{\"1\":{\"709\":1}}],[\"强化了模型的代码能力\",{\"1\":{\"704\":1}}],[\"强化了\",{\"1\":{\"531\":1}}],[\"强化多义性和类间相似度学习\",{\"1\":{\"159\":1}}],[\"强化人类意图在物体语义推理中的引导作用\",{\"1\":{\"32\":1}}],[\"强化\",{\"1\":{\"32\":1}}],[\"参与的是可导的加法和乘法\",{\"1\":{\"853\":1}}],[\"参与点积计算\",{\"1\":{\"591\":1}}],[\"参与配对但保留在输出里\",{\"1\":{\"590\":1}}],[\"参与数据标注\",{\"1\":{\"537\":1}}],[\"参数准备\",{\"1\":{\"840\":1}}],[\"参数和文本词空间的构成需要简单说明一下\",{\"1\":{\"814\":1}}],[\"参数便在部分达到了\",{\"1\":{\"704\":1}}],[\"参数模型是首个公开的千亿级开源模型\",{\"1\":{\"704\":1}}],[\"参数的\",{\"1\":{\"703\":2}}],[\"参数的语言模型\",{\"1\":{\"703\":1}}],[\"参数的变化趋势\",{\"1\":{\"159\":1}}],[\"参数管理与清理机制\",{\"1\":{\"700\":1}}],[\"参数调优\",{\"1\":{\"531\":1}}],[\"参数调整正类和负类的权重\",{\"1\":{\"473\":1}}],[\"参数从117m到1\",{\"1\":{\"521\":1}}],[\"参数足够多\",{\"1\":{\"501\":1}}],[\"参数选择\",{\"1\":{\"470\":1}}],[\"参数用于平衡正负类别的权重\",{\"1\":{\"470\":1}}],[\"参数用于抑制容易分类的样本\",{\"1\":{\"470\":1}}],[\"参数复用与模块化\",{\"1\":{\"385\":1}}],[\"参数个数必须和\",{\"1\":{\"363\":1,\"364\":1}}],[\"参数说明\",{\"1\":{\"332\":1,\"374\":1,\"848\":1}}],[\"参数与训练集的归一化参数相同\",{\"1\":{\"317\":1}}],[\"参数初始化\",{\"1\":{\"272\":1}}],[\"参数效率高\",{\"1\":{\"239\":1}}],[\"参数规模庞大\",{\"1\":{\"705\":1}}],[\"参数规模从7b到65b不等\",{\"1\":{\"546\":1}}],[\"参数规模\",{\"1\":{\"216\":1}}],[\"参数规模不匹配\",{\"1\":{\"189\":1}}],[\"参数量会很大\",{\"1\":{\"591\":1}}],[\"参数量会非常大\",{\"1\":{\"591\":1}}],[\"参数量远超\",{\"1\":{\"521\":1}}],[\"参数量降低到\",{\"1\":{\"490\":1}}],[\"参数量更少\",{\"1\":{\"385\":1}}],[\"参数量极大\",{\"1\":{\"385\":1}}],[\"参数量\",{\"1\":{\"199\":1}}],[\"参数量是qformer的42倍\",{\"1\":{\"197\":1}}],[\"参数量达到60亿\",{\"1\":{\"197\":1}}],[\"参数平衡的视觉与语言组件\",{\"1\":{\"189\":1}}],[\"参数形式\",{\"1\":{\"186\":1}}],[\"参数更新\",{\"1\":{\"160\":1,\"803\":1}}],[\"参数更新等\",{\"1\":{\"81\":1}}],[\"参数共享\",{\"1\":{\"112\":1}}],[\"参数依赖\",{\"1\":{\"89\":1}}],[\"参数\",{\"0\":{\"799\":1},\"1\":{\"78\":1,\"83\":1,\"92\":1,\"100\":2,\"101\":1,\"169\":1,\"170\":3,\"186\":1,\"239\":1,\"272\":2,\"274\":1,\"353\":1,\"377\":1,\"388\":1,\"467\":2,\"468\":2,\"469\":2,\"470\":3,\"471\":2,\"473\":3,\"580\":1,\"591\":1,\"704\":1,\"746\":2}}],[\"参考decoderlayer\",{\"1\":{\"626\":1}}],[\"参考上文\",{\"1\":{\"550\":1}}],[\"参考上文的\",{\"1\":{\"68\":1}}],[\"参考rabe\",{\"1\":{\"548\":1}}],[\"参考群体\",{\"1\":{\"539\":1}}],[\"参考点解码器\",{\"0\":{\"76\":1},\"1\":{\"70\":1}}],[\"参考\",{\"0\":{\"718\":1},\"1\":{\"22\":1,\"131\":1,\"561\":3}}],[\"让正向传播和反向传播按照不同的方式计算\",{\"1\":{\"883\":1}}],[\"让正样本的key和query距离近\",{\"1\":{\"246\":1}}],[\"让它学习怎么生成\",{\"1\":{\"878\":1}}],[\"让它比较\",{\"1\":{\"839\":1}}],[\"让pixelcnn学习生成\",{\"1\":{\"878\":1}}],[\"让随机采样出的向量也能通过解码器变成图片\",{\"1\":{\"878\":1}}],[\"让向量符合标准正态分布的原因是方便随机采样\",{\"1\":{\"878\":1}}],[\"让看起来真实的图像具有较高概率\",{\"1\":{\"864\":1}}],[\"让图像\",{\"1\":{\"815\":1}}],[\"让开发者可以专注于应用程序的开发\",{\"1\":{\"715\":1}}],[\"让开发者能够通过简单的命令来管理整个应用程序的生命周期\",{\"1\":{\"715\":1}}],[\"让我们来总结一下\",{\"1\":{\"878\":1}}],[\"让我们来整理一下vq\",{\"1\":{\"878\":1}}],[\"让我们从最早的自编码器\",{\"1\":{\"878\":1}}],[\"让我们回到之前生成手写数字的例子\",{\"1\":{\"874\":1}}],[\"让我们的应用能够上线成为产品\",{\"1\":{\"717\":1}}],[\"让我们更轻松地找到所需的信息\",{\"1\":{\"708\":1}}],[\"让我们逐步构建起tinypytorch的基础功能\",{\"1\":{\"634\":1}}],[\"让大语言模型真正火爆的契机\",{\"1\":{\"708\":1}}],[\"让大模型生成的结果\",{\"1\":{\"483\":1}}],[\"让用户可根据具体需求选择最适合的模型类型\",{\"1\":{\"704\":1}}],[\"让返回值始终封装为元组\",{\"1\":{\"681\":1}}],[\"让函数更易用\",{\"0\":{\"670\":1}}],[\"让其\",{\"1\":{\"575\":1}}],[\"让llm照着例子进行推理\",{\"1\":{\"500\":1}}],[\"让他去执行就好了\",{\"1\":{\"497\":1}}],[\"让难分类样本获得更大的\",{\"1\":{\"470\":1}}],[\"让你显式指定维度之间怎么相乘\",{\"1\":{\"367\":1}}],[\"让被装饰函数看起来仍然像原来的函数\",{\"1\":{\"346\":1}}],[\"让q\",{\"1\":{\"312\":1}}],[\"让query在字典中与自己匹配的正样本更近\",{\"1\":{\"246\":1}}],[\"让文本动态关注图像区域\",{\"1\":{\"294\":1}}],[\"让文本\",{\"1\":{\"291\":1}}],[\"让固定模型适应新任务\",{\"1\":{\"239\":1}}],[\"让视觉编码器提取的图像特征与语言模型的词嵌入空间对齐\",{\"1\":{\"233\":1}}],[\"让人类标注者对这些回答进行排序\",{\"1\":{\"232\":1}}],[\"让\",{\"1\":{\"165\":1,\"246\":1,\"867\":1,\"869\":1}}],[\"让变换矩阵从一个恒等变换开始学习\",{\"1\":{\"107\":1}}],[\"让网络从一个小扰动开始学习\",{\"1\":{\"107\":1}}],[\"让模型知道\",{\"1\":{\"817\":1}}],[\"让模型也能学到\",{\"1\":{\"815\":1}}],[\"让模型可以更好地捕捉和理解语言中的复杂关系\",{\"1\":{\"703\":1}}],[\"让模型自己学会区分不同的句子\",{\"1\":{\"597\":1}}],[\"让模型得以判断上下句的起止位置\",{\"1\":{\"573\":1}}],[\"让模型理解图像和文本之间的语义关系\",{\"1\":{\"233\":1}}],[\"让模型生成多个不同的回答\",{\"1\":{\"232\":1}}],[\"让模型学习更细粒度\",{\"1\":{\"186\":1}}],[\"让模型更容易训练和泛化\",{\"1\":{\"107\":1}}],[\"让模型既关注局部细节\",{\"1\":{\"105\":1}}],[\"让模型同时关注逐点分类精度和整体区域匹配\",{\"1\":{\"78\":1}}],[\"让每个离散编码值对应一个嵌入\",{\"1\":{\"883\":1}}],[\"让每个像素都忽略后续像素的信息的方法就不是那么显然了\",{\"1\":{\"843\":1}}],[\"让每个类别在训练过程中被抽到的机会接近均衡\",{\"1\":{\"403\":1}}],[\"让每个点都能看到上下文信息\",{\"1\":{\"109\":1,\"111\":1}}],[\"让每个\",{\"1\":{\"76\":1}}],[\"让每个语言\",{\"1\":{\"72\":1}}],[\"得益于前人的一些关于内在维度\",{\"1\":{\"491\":1}}],[\"得益于这种建模灵活性\",{\"1\":{\"262\":1}}],[\"得出带有一定置信度的一般性结论的行为\",{\"1\":{\"758\":1}}],[\"得出的用来将x序列\",{\"1\":{\"481\":1}}],[\"得出\",{\"1\":{\"115\":1}}],[\"得分也会接近它们的值\",{\"1\":{\"448\":1}}],[\"得分也会为\",{\"1\":{\"448\":1}}],[\"得分是精确率和召回率的调和平均数\",{\"1\":{\"448\":1}}],[\"得分从\",{\"1\":{\"204\":1}}],[\"得分达\",{\"1\":{\"203\":1}}],[\"得分达到\",{\"1\":{\"202\":1}}],[\"得分\",{\"0\":{\"448\":1},\"1\":{\"76\":1}}],[\"得到真正的嵌入\",{\"1\":{\"880\":1}}],[\"得到3个整数\",{\"1\":{\"880\":1}}],[\"得到第二个像素\",{\"1\":{\"847\":1}}],[\"得到第一个像素\",{\"1\":{\"847\":1}}],[\"得到形状\",{\"1\":{\"821\":1}}],[\"得到形状为\",{\"1\":{\"318\":3}}],[\"得到连续的隐向量表示\",{\"1\":{\"795\":1}}],[\"得到概率\",{\"1\":{\"614\":1}}],[\"得到模型预测的这些掩码token对应的真实词\",{\"1\":{\"580\":1}}],[\"得到对应的json格式文件\",{\"1\":{\"577\":1}}],[\"得到上图中黄色的输出\",{\"1\":{\"575\":1}}],[\"得到llama\",{\"1\":{\"550\":1}}],[\"得到初始策略模型\",{\"1\":{\"537\":1}}],[\"得到一组f\",{\"1\":{\"471\":1}}],[\"得到一个离散的\",{\"1\":{\"796\":1}}],[\"得到一个\",{\"1\":{\"795\":1,\"817\":1}}],[\"得到一个新的形状为\",{\"1\":{\"426\":1}}],[\"得到一个融合了上下文信息的向量\",{\"1\":{\"412\":1}}],[\"得到一个logit\",{\"1\":{\"311\":1}}],[\"得到一个全局语义向量\",{\"1\":{\"46\":1}}],[\"得到归一化的注意力权重\",{\"1\":{\"408\":1}}],[\"得到归一化因子\",{\"1\":{\"100\":1}}],[\"得到结果如下图所示\",{\"1\":{\"325\":1}}],[\"得到图像和对应的标签\",{\"1\":{\"323\":1}}],[\"得到图像的表征\",{\"1\":{\"313\":1}}],[\"得到图片表征f11\",{\"1\":{\"246\":1}}],[\"得到相似度矩阵\",{\"1\":{\"310\":2}}],[\"得到相同维度的特征\",{\"1\":{\"299\":1}}],[\"得到注意力权重矩阵\",{\"1\":{\"322\":1}}],[\"得到注意力权重\",{\"1\":{\"272\":1}}],[\"得到注意力分数矩阵\",{\"1\":{\"272\":1,\"322\":1}}],[\"得到两个样本\",{\"1\":{\"252\":1}}],[\"得到表征f12\",{\"1\":{\"246\":1}}],[\"得到三个表征\",{\"1\":{\"242\":1}}],[\"得到最终适用于下游任务的模型参数\",{\"1\":{\"490\":1}}],[\"得到最终表示\",{\"1\":{\"186\":1}}],[\"得到最终的掩码\",{\"1\":{\"76\":1}}],[\"得到每组\",{\"1\":{\"186\":1}}],[\"得到每个位置对应的\",{\"1\":{\"821\":1}}],[\"得到每个位置上的分类\",{\"1\":{\"815\":1}}],[\"得到每个像素位置的\",{\"1\":{\"794\":1}}],[\"得到每个注意力头的输出\",{\"1\":{\"322\":1}}],[\"得到每个预测类别的概率值\",{\"1\":{\"300\":1}}],[\"得到每个原始点的插值特征\",{\"1\":{\"100\":1}}],[\"得到每个\",{\"1\":{\"76\":1,\"163\":1,\"591\":1}}],[\"得到以下核心结论\",{\"1\":{\"173\":1}}],[\"得到新的簇中心\",{\"1\":{\"170\":1}}],[\"得到新的中心\",{\"1\":{\"170\":1}}],[\"得到离散编码后\",{\"1\":{\"880\":1}}],[\"得到离散\",{\"1\":{\"167\":1}}],[\"得到预测结果\",{\"1\":{\"323\":1}}],[\"得到预测概率\",{\"1\":{\"156\":1}}],[\"得到预测的\",{\"1\":{\"82\":1,\"276\":1}}],[\"得到该区域的特征\",{\"1\":{\"98\":1}}],[\"得到该区域的固定长度特征表示\",{\"1\":{\"92\":1}}],[\"得到\",{\"1\":{\"93\":3,\"111\":1,\"313\":1,\"591\":1,\"793\":1,\"794\":1,\"816\":1}}],[\"得到的导数为\",{\"1\":{\"697\":1}}],[\"得到的就是答案\",{\"1\":{\"616\":1}}],[\"得到的三个答案中\",{\"1\":{\"502\":1}}],[\"得到的预测概率如下所示\",{\"1\":{\"300\":1}}],[\"得到的特征可以很好地迁移到下游任务中\",{\"1\":{\"246\":1}}],[\"得到的特征可能无法覆盖整个物体\",{\"1\":{\"112\":1}}],[\"得到的特征拼接后再送入\",{\"1\":{\"186\":1}}],[\"得到的聚类中心赋值给\",{\"1\":{\"170\":1}}],[\"得到的\",{\"1\":{\"145\":1,\"758\":1,\"868\":1}}],[\"得到的质心\",{\"1\":{\"92\":1}}],[\"得到的几何属性描述与\",{\"1\":{\"13\":1}}],[\"得到分割掩码\",{\"1\":{\"76\":1}}],[\"得到目标物体区域掩码\",{\"1\":{\"59\":1}}],[\"得到目标物体区域特征\",{\"1\":{\"59\":2}}],[\"得到融合特征\",{\"1\":{\"8\":1}}],[\"去定义\",{\"1\":{\"871\":1}}],[\"去编码真实来自\",{\"1\":{\"830\":1}}],[\"去预测\",{\"1\":{\"816\":1}}],[\"去预测下一个\",{\"1\":{\"816\":1}}],[\"去预测被掩码的\",{\"1\":{\"276\":1}}],[\"去推测其真正的意图\",{\"1\":{\"759\":1}}],[\"去推断世界的状态\",{\"1\":{\"759\":1}}],[\"去做任务适配\",{\"1\":{\"491\":1}}],[\"去重并移除了\",{\"1\":{\"521\":1}}],[\"去重\",{\"1\":{\"372\":1}}],[\"去缓慢地更新编码器\",{\"1\":{\"244\":1}}],[\"去匹配一个教师网络\",{\"1\":{\"178\":1}}],[\"去掉字符和空格\",{\"1\":{\"514\":1}}],[\"去掉目标检测器\",{\"1\":{\"261\":1}}],[\"去掉\",{\"1\":{\"143\":1,\"186\":1,\"804\":1}}],[\"去除视觉\",{\"1\":{\"780\":1}}],[\"去除\",{\"1\":{\"780\":1}}],[\"去除含有低频词的句对\",{\"1\":{\"578\":1}}],[\"去除前后空格\",{\"1\":{\"577\":1}}],[\"去除后性能反而提升\",{\"1\":{\"567\":1}}],[\"去除nsp损失不仅未降低性能\",{\"1\":{\"562\":1}}],[\"去除nsp损失\",{\"1\":{\"562\":1}}],[\"去除多视角图像选择逻辑\",{\"1\":{\"276\":1}}],[\"去除这个温度超参数\",{\"1\":{\"248\":1}}],[\"去除频率小于\",{\"1\":{\"234\":1}}],[\"去除低质量描述\",{\"1\":{\"198\":1}}],[\"去除噪声文本\",{\"1\":{\"132\":1}}],[\"去除batch维度\",{\"1\":{\"83\":1}}],[\"去填充这些空缺\",{\"1\":{\"92\":1}}],[\"去卷积点云特征\",{\"1\":{\"76\":1}}],[\"去关注点云中最相关的区域\",{\"1\":{\"72\":1}}],[\"区块\",{\"1\":{\"772\":1}}],[\"区别于\",{\"1\":{\"591\":1}}],[\"区分大语言模型\",{\"1\":{\"706\":1}}],[\"区分句子\",{\"1\":{\"580\":1}}],[\"区分\",{\"1\":{\"277\":1}}],[\"区分模态\",{\"1\":{\"276\":1,\"277\":1}}],[\"区间事件\",{\"1\":{\"728\":2}}],[\"区间数值的映射\",{\"1\":{\"726\":1}}],[\"区间内\",{\"1\":{\"473\":1}}],[\"区间内随机生成整数的张量\",{\"1\":{\"376\":1}}],[\"区间对应\",{\"1\":{\"186\":1}}],[\"区间\",{\"1\":{\"76\":1,\"467\":1,\"469\":1,\"728\":2}}],[\"区域使用\",{\"1\":{\"804\":1}}],[\"区域匹配度\",{\"1\":{\"473\":1}}],[\"区域匹配误差\",{\"1\":{\"78\":1}}],[\"区域重叠误差\",{\"1\":{\"473\":1}}],[\"区域重合度\",{\"1\":{\"82\":1}}],[\"区域划分为\",{\"1\":{\"386\":1}}],[\"区域中提取固定大小的特征\",{\"1\":{\"386\":1}}],[\"区域特征\",{\"1\":{\"280\":1}}],[\"区域定位\",{\"1\":{\"54\":1}}],[\"区域\",{\"1\":{\"6\":1,\"7\":1,\"25\":2,\"178\":1,\"260\":1,\"261\":1,\"801\":2}}],[\"扫描角度不同等\",{\"1\":{\"107\":1}}],[\"扫描\",{\"1\":{\"76\":1}}],[\"动态图控制与框架灵活性展开一系列扩展与优化\",{\"1\":{\"695\":1}}],[\"动态图可视化与高阶导数构建\",{\"0\":{\"694\":1}}],[\"动态计算图\",{\"1\":{\"692\":1}}],[\"动态掩码与大批量训练\",{\"1\":{\"567\":1}}],[\"动态掩码在squad\",{\"1\":{\"564\":1}}],[\"动态掩码能持续提供新的掩码模式\",{\"1\":{\"562\":1}}],[\"动态掩码性能略优于静态掩码\",{\"1\":{\"562\":1}}],[\"动态掩码\",{\"1\":{\"559\":1,\"562\":1,\"564\":1}}],[\"动态调整样本权重\",{\"1\":{\"470\":1}}],[\"动态增加其功能\",{\"1\":{\"342\":1}}],[\"动态高分辨率策略\",{\"1\":{\"227\":1}}],[\"动态高分辨率处理\",{\"1\":{\"215\":1,\"216\":1}}],[\"动态宽高比匹配\",{\"1\":{\"224\":1}}],[\"动态分辨率的作用\",{\"1\":{\"229\":1}}],[\"动态分辨率策略\",{\"1\":{\"222\":1,\"225\":1}}],[\"动态分辨率支持和多语言优化\",{\"1\":{\"218\":1}}],[\"动态更新的\",{\"1\":{\"176\":1}}],[\"动态卷积核\",{\"1\":{\"76\":1}}],[\"动态卷积\",{\"1\":{\"76\":2}}],[\"动量更新参数\",{\"1\":{\"254\":1}}],[\"动量更新系数\",{\"1\":{\"160\":1}}],[\"动量设置为了\",{\"1\":{\"249\":1}}],[\"动量这个超参数是\",{\"1\":{\"244\":1}}],[\"动量是一种加权移动平均\",{\"1\":{\"244\":1}}],[\"动量\",{\"1\":{\"186\":1}}],[\"动量教师在整个训练过程中始终优于学生模型\",{\"1\":{\"182\":1}}],[\"动量教师\",{\"1\":{\"182\":1}}],[\"动量视觉特征\",{\"1\":{\"163\":1}}],[\"动量视觉编码器\",{\"1\":{\"147\":1}}],[\"动量图像编码器输出特征\",{\"1\":{\"161\":1}}],[\"动量分支的\",{\"1\":{\"159\":1}}],[\"动量蒸馏的总体损失是对原始监督信号与伪监督信号的加权组合\",{\"1\":{\"157\":1}}],[\"动量模型生成的伪标签往往比真实标签更具多样性和语义丰富性\",{\"1\":{\"157\":1}}],[\"动量模型是对主模型参数的滑动平均版本\",{\"1\":{\"157\":1}}],[\"动量模型\",{\"1\":{\"157\":1}}],[\"动量文本编码器输出特征\",{\"1\":{\"161\":1}}],[\"动量文本编码器\",{\"1\":{\"147\":1}}],[\"动量编码器生成的归一化特征分别记为\",{\"1\":{\"154\":1}}],[\"动量编码器\",{\"1\":{\"147\":1,\"173\":1,\"175\":1}}],[\"动量编码器的更新参数\",{\"1\":{\"147\":1}}],[\"动量慢更新\",{\"1\":{\"145\":1}}],[\"动作可能性\",{\"1\":{\"6\":1,\"7\":1}}],[\"猜测\",{\"1\":{\"825\":1}}],[\"猜出我的特征\",{\"1\":{\"100\":1}}],[\"猜\",{\"1\":{\"76\":1}}],[\"显然\",{\"1\":{\"300\":1,\"845\":1}}],[\"显存\",{\"1\":{\"774\":1}}],[\"显存并训练模型\",{\"1\":{\"495\":1}}],[\"显存15\",{\"1\":{\"184\":1}}],[\"显存9\",{\"1\":{\"184\":1}}],[\"显式地学习分类器无法很好扩展\",{\"1\":{\"175\":1}}],[\"显式的语义分割信息\",{\"1\":{\"173\":1}}],[\"显示原图和重建图像\",{\"1\":{\"857\":1}}],[\"显示它关注哪些其他\",{\"1\":{\"781\":1}}],[\"显示增大批次规模可提升模型困惑度和下游任务准确率\",{\"1\":{\"559\":1}}],[\"显示动态掩码在\",{\"1\":{\"559\":1}}],[\"显示模型在强化学习过程中存在轻微性能损失\",{\"1\":{\"537\":1}}],[\"显示了\",{\"1\":{\"537\":1}}],[\"显示了在极小显存条件下训练大模型的潜力\",{\"1\":{\"185\":1}}],[\"显示出这种人类反馈驱动的微调策略极具潜力\",{\"1\":{\"535\":1}}],[\"显示出数据集对交互多样性和类别多样性的全面覆盖\",{\"1\":{\"17\":1}}],[\"显示其对\",{\"1\":{\"529\":1}}],[\"显示gpt\",{\"1\":{\"529\":1}}],[\"显示在一些语义比较任务上仍存在明显短板\",{\"1\":{\"529\":1}}],[\"显示无监督学习的当前边界\",{\"1\":{\"522\":1}}],[\"显示\",{\"1\":{\"134\":1,\"137\":1,\"268\":1,\"537\":1,\"538\":4}}],[\"显著高于bert\",{\"1\":{\"566\":1}}],[\"显著高于palm\",{\"1\":{\"549\":1}}],[\"显著比\",{\"1\":{\"538\":1}}],[\"显著减少数据需求\",{\"1\":{\"528\":1}}],[\"显著抑制简单样本\",{\"1\":{\"470\":1}}],[\"显著超越现有方法\",{\"1\":{\"202\":1}}],[\"显著超越之前的自监督方法\",{\"1\":{\"173\":1}}],[\"显著优于\",{\"1\":{\"201\":1}}],[\"显著优于上述方法\",{\"1\":{\"182\":1}}],[\"显著提升下游任务性能\",{\"1\":{\"780\":1}}],[\"显著提升难样本的分类性能\",{\"1\":{\"470\":1}}],[\"显著提升表现\",{\"1\":{\"236\":1}}],[\"显著提升性能\",{\"1\":{\"229\":1}}],[\"显著提升ocr和中文任务性能\",{\"1\":{\"216\":1}}],[\"显著提升模型性能\",{\"1\":{\"132\":1,\"260\":1}}],[\"显著提升了性能\",{\"1\":{\"563\":1}}],[\"显著提升了\",{\"1\":{\"560\":1}}],[\"显著提升了模型性能\",{\"1\":{\"268\":1,\"562\":1}}],[\"显著提升了模型在\",{\"1\":{\"215\":1}}],[\"显著提升了零样本和少样本泛化能力\",{\"1\":{\"232\":1}}],[\"显著提升了开源模型在ocr\",{\"1\":{\"225\":1}}],[\"显著提升了视觉\",{\"1\":{\"205\":1}}],[\"显著提升了视觉任务的性能\",{\"1\":{\"191\":1}}],[\"显著提升了分割性能\",{\"1\":{\"105\":1}}],[\"显著提升了所有指标\",{\"1\":{\"75\":1}}],[\"显著扩展了训练数据的规模和质量\",{\"1\":{\"129\":1}}],[\"后几层则将这些属性解码为图像\",{\"1\":{\"866\":1}}],[\"后5维为离散视觉词空间索引\",{\"1\":{\"814\":1}}],[\"后2个位置为图像token\",{\"1\":{\"814\":1}}],[\"后验分布\",{\"1\":{\"871\":1}}],[\"后验\",{\"1\":{\"758\":1}}],[\"后对\",{\"1\":{\"758\":1}}],[\"后更名为\",{\"1\":{\"704\":1}}],[\"后训练和在线推理阶段也各自拥有了\",{\"1\":{\"703\":1}}],[\"后训练和在线推理\",{\"1\":{\"703\":1}}],[\"后一半桶表示右方向\",{\"1\":{\"591\":1}}],[\"后得到的注意力得分矩阵维度相同\",{\"1\":{\"584\":1}}],[\"后处理技术\",{\"1\":{\"551\":1}}],[\"后处理步骤\",{\"1\":{\"176\":1}}],[\"后来被应用于语言任务\",{\"1\":{\"536\":1}}],[\"后面的用b类掩码\",{\"1\":{\"847\":1}}],[\"后面的mlp是个单独的结构\",{\"1\":{\"321\":1}}],[\"后面再赋值\",{\"1\":{\"366\":1}}],[\"后面所有维度都选中\",{\"1\":{\"355\":1}}],[\"后将投影后的\",{\"1\":{\"313\":1}}],[\"后三种模型是按照efficientnet的缩放规则对resnet分别放大4倍\",{\"1\":{\"299\":1}}],[\"后应用一个\",{\"1\":{\"292\":1}}],[\"后半部分是图像\",{\"1\":{\"276\":1}}],[\"后的结果\",{\"1\":{\"747\":1}}],[\"后的形式\",{\"1\":{\"614\":1}}],[\"后的改进\",{\"1\":{\"544\":1}}],[\"后的概率值\",{\"1\":{\"467\":1}}],[\"后的\",{\"1\":{\"274\":1}}],[\"后可选\",{\"1\":{\"273\":1}}],[\"后缀\",{\"1\":{\"239\":1,\"276\":1}}],[\"后分割为448×448区块\",{\"1\":{\"224\":1}}],[\"后者是其110倍\",{\"1\":{\"577\":1}}],[\"后者是加模型\",{\"1\":{\"396\":1}}],[\"后者效果略优但计算复杂\",{\"1\":{\"564\":1}}],[\"后者在前\",{\"1\":{\"268\":1}}],[\"后者只从单个\",{\"1\":{\"268\":1}}],[\"后者作为强大的\",{\"1\":{\"189\":1}}],[\"后者为因果\",{\"1\":{\"126\":1}}],[\"后期切换至\",{\"1\":{\"198\":1,\"208\":1}}],[\"后期\",{\"1\":{\"159\":1}}],[\"后续公式中将省略\",{\"1\":{\"868\":1}}],[\"后续为了简洁\",{\"1\":{\"865\":1}}],[\"后续几层\",{\"1\":{\"848\":1}}],[\"后续计算逻辑\",{\"1\":{\"690\":1}}],[\"后续需要利用该相关度完成当前词的全局上下文信息融合\",{\"1\":{\"584\":1}}],[\"后续实验均采用动态掩码\",{\"1\":{\"562\":1}}],[\"后续每次生成新\",{\"1\":{\"544\":1}}],[\"后续推理\",{\"1\":{\"544\":1}}],[\"后续方法\",{\"1\":{\"531\":1}}],[\"后续再进行裁剪操作\",{\"1\":{\"317\":1}}],[\"后续更新时对右边这个编码器的参数进行动量更新\",{\"1\":{\"246\":1}}],[\"后续\",{\"1\":{\"147\":1,\"186\":1}}],[\"后续的损失函数之类的训练就很常规了\",{\"1\":{\"243\":1}}],[\"后续的\",{\"1\":{\"112\":1}}],[\"后续的特征提取更稳定\",{\"1\":{\"107\":1}}],[\"后续发展\",{\"1\":{\"112\":1}}],[\"后续改进方向\",{\"1\":{\"112\":1}}],[\"后续改进\",{\"1\":{\"112\":1}}],[\"后续训练完50个epoch后\",{\"1\":{\"83\":1}}],[\"后台运行\",{\"1\":{\"83\":1}}],[\"后\",{\"1\":{\"75\":1,\"107\":1,\"162\":1,\"274\":1,\"360\":1,\"455\":1,\"590\":1,\"817\":1}}],[\"↓\",{\"1\":{\"75\":4,\"98\":5,\"99\":8,\"419\":9}}],[\"──┐\",{\"1\":{\"75\":1}}],[\"两阶段如何对应这个公式\",{\"1\":{\"807\":1}}],[\"两阶段训练\",{\"1\":{\"227\":1}}],[\"两条互补产品线\",{\"1\":{\"704\":1}}],[\"两大技术分支\",{\"1\":{\"704\":1}}],[\"两两配对遍历\",{\"1\":{\"578\":1}}],[\"两点注意\",{\"1\":{\"316\":1}}],[\"两点的距离反映了这两点的实际相似度或关联度\",{\"1\":{\"90\":1}}],[\"两张全局视角图像\",{\"1\":{\"186\":1}}],[\"两种变分自编码器\",{\"1\":{\"792\":1}}],[\"两种规模的\",{\"1\":{\"704\":1}}],[\"两种模态是否相互作用\",{\"1\":{\"282\":1}}],[\"两种模态是否保持平衡\",{\"1\":{\"282\":1}}],[\"两种模式\",{\"1\":{\"65\":1,\"816\":1}}],[\"两种配置\",{\"1\":{\"198\":1}}],[\"两种崩溃被平衡并避免\",{\"1\":{\"183\":1}}],[\"两组负样本编码\",{\"1\":{\"145\":1}}],[\"两者之间会出现一种\",{\"1\":{\"754\":1}}],[\"两者中相同字母代表要\",{\"1\":{\"590\":1}}],[\"两者毒性差异减小\",{\"1\":{\"538\":1}}],[\"两者协同提升模型性能\",{\"1\":{\"470\":1}}],[\"两者解决的是不同维度的问题\",{\"1\":{\"470\":1}}],[\"两者解耦可以让模型更灵活地分配资源\",{\"1\":{\"417\":1}}],[\"两者互补\",{\"1\":{\"468\":1}}],[\"两者都通过增加基函数的数量\",{\"1\":{\"385\":1}}],[\"两者都会输出一个\",{\"1\":{\"178\":1}}],[\"两者的训练效率相差3倍\",{\"1\":{\"305\":1}}],[\"两者平均再乘权重\",{\"1\":{\"277\":1}}],[\"两者联合使用时效果最佳\",{\"1\":{\"132\":1}}],[\"两者结合可以\",{\"1\":{\"78\":1}}],[\"两个损失项的单位是一致的\",{\"1\":{\"873\":1}}],[\"两个完全不同的分布\",{\"1\":{\"838\":1}}],[\"两个分布相差多远\",{\"1\":{\"834\":1}}],[\"两个参数都是\",{\"1\":{\"799\":1}}],[\"两个月后月活用户破亿\",{\"1\":{\"704\":1}}],[\"两个句子是否为上下句关系\",{\"1\":{\"611\":1}}],[\"两个任务\",{\"1\":{\"580\":1}}],[\"两个开源数据集\",{\"1\":{\"577\":1}}],[\"两个不同分类任务的评估结果\",{\"1\":{\"515\":1}}],[\"两个比较的句子没有内在顺序\",{\"1\":{\"512\":1}}],[\"两个假设模型的\",{\"1\":{\"453\":1}}],[\"两个向量\",{\"1\":{\"391\":1}}],[\"两个贡献\",{\"1\":{\"249\":1}}],[\"两个编码器\",{\"1\":{\"246\":1}}],[\"两个点之间的直线距离被认为是相似度或连接强度的直观表示\",{\"1\":{\"90\":1}}],[\"两个问题是相关联的\",{\"1\":{\"86\":1}}],[\"两个\",{\"1\":{\"73\":1,\"589\":1}}],[\"相较于真实分布累积分布函数\",{\"1\":{\"871\":1}}],[\"相较于传统的语言模型具有更强大的能力\",{\"1\":{\"709\":1}}],[\"相乘\",{\"1\":{\"758\":1}}],[\"相互抵消的平衡点\",{\"1\":{\"754\":1}}],[\"相信未来会涌现出很多类似的以对话形态让助手完成各种具体工作的项目\",{\"1\":{\"708\":1}}],[\"相应的位置信息\",{\"1\":{\"588\":1}}],[\"相加过程总结\",{\"1\":{\"591\":1}}],[\"相加\",{\"1\":{\"574\":1}}],[\"相对或绝对\",{\"1\":{\"820\":1}}],[\"相对标准差\",{\"1\":{\"755\":1}}],[\"相对于均值\",{\"1\":{\"752\":1}}],[\"相对距离\",{\"1\":{\"591\":1}}],[\"相对位置可能范围很大\",{\"1\":{\"591\":1}}],[\"相对位置矩阵\",{\"1\":{\"591\":1}}],[\"相对位置矩阵relative\",{\"1\":{\"591\":1}}],[\"相对位置桶映射\",{\"1\":{\"591\":1}}],[\"相对位置桶数\",{\"1\":{\"591\":1}}],[\"相对位置桶\",{\"1\":{\"591\":1}}],[\"相对位置信息\",{\"1\":{\"591\":1}}],[\"相对位置的分组数量\",{\"1\":{\"591\":1}}],[\"相对位置像\",{\"1\":{\"591\":2}}],[\"相对位置偏置\",{\"0\":{\"591\":1},\"1\":{\"591\":1}}],[\"相对位置索引矩阵\",{\"1\":{\"590\":1}}],[\"相对位置部分\",{\"1\":{\"590\":1}}],[\"相对位置向量表\",{\"1\":{\"590\":1}}],[\"相对位置编码中的相对位置矩阵的详解\",{\"1\":{\"590\":1}}],[\"相对位置编码改成\",{\"1\":{\"590\":1}}],[\"相对位置编码直接对\",{\"1\":{\"589\":1}}],[\"相对位置编码\",{\"0\":{\"589\":1},\"1\":{\"272\":1,\"814\":1}}],[\"相对位置编码偏置\",{\"1\":{\"272\":1}}],[\"相对来说成本会比较高\",{\"1\":{\"483\":1}}],[\"相结合\",{\"1\":{\"473\":1}}],[\"相邻重复值\",{\"1\":{\"372\":1}}],[\"相媲美的效果\",{\"1\":{\"328\":1}}],[\"相同形状的\",{\"1\":{\"818\":1}}],[\"相同字母且不出现在输出\",{\"1\":{\"590\":1}}],[\"相同的维度字母表示要做\",{\"1\":{\"367\":1}}],[\"相同\",{\"1\":{\"232\":1,\"364\":1,\"399\":1,\"471\":1,\"473\":1,\"591\":1}}],[\"相当\",{\"1\":{\"215\":1,\"521\":1}}],[\"相当于输出了一个\",{\"1\":{\"881\":1}}],[\"相当于人为扩大重构误差项的权重\",{\"1\":{\"873\":1}}],[\"相当于限制了函数的最大\",{\"1\":{\"839\":1}}],[\"相当于为计算机提供了强大的\",{\"1\":{\"703\":1}}],[\"相当于一个\",{\"1\":{\"459\":1}}],[\"相当于对输入空间进行一次\",{\"1\":{\"385\":1}}],[\"相当于\",{\"1\":{\"343\":1,\"794\":1,\"802\":1}}],[\"相当于直接输入一篇五万字的文章\",{\"1\":{\"318\":1}}],[\"相当于数据量不够\",{\"1\":{\"246\":1}}],[\"相当于在训练中持续进行模型集成\",{\"1\":{\"182\":1}}],[\"相当于告诉模型\",{\"1\":{\"111\":1}}],[\"相当于加了一个\",{\"1\":{\"107\":1}}],[\"相当于跨空间位置的信息交换\",{\"1\":{\"73\":1}}],[\"相关证明可见附录\",{\"1\":{\"871\":1}}],[\"相关计算\",{\"1\":{\"814\":1}}],[\"相关的标量偏置\",{\"1\":{\"591\":1}}],[\"相关核心代码实现如下\",{\"1\":{\"577\":1}}],[\"相关代码\",{\"1\":{\"569\":1}}],[\"相关模型和代码已公开供进一步研究\",{\"1\":{\"558\":1}}],[\"相关阅读资料\",{\"1\":{\"488\":1}}],[\"相关任务中表现突出\",{\"1\":{\"215\":1}}],[\"相关工作\",{\"0\":{\"7\":1,\"50\":1,\"174\":1,\"190\":1,\"217\":1,\"508\":1,\"531\":1,\"536\":1,\"552\":1,\"568\":1,\"782\":1}}],[\"相似的结果\",{\"1\":{\"865\":1}}],[\"相似度指标\",{\"1\":{\"471\":1}}],[\"相似度高\",{\"1\":{\"391\":1}}],[\"相似度如下所示\",{\"1\":{\"300\":1}}],[\"相似度生成的\",{\"1\":{\"162\":1}}],[\"相似度\",{\"1\":{\"147\":1,\"154\":1,\"170\":1,\"248\":1,\"512\":1}}],[\"相似性得分\",{\"1\":{\"82\":1}}],[\"相等\",{\"1\":{\"145\":1,\"364\":1}}],[\"相比与其他生成模型\",{\"1\":{\"847\":1}}],[\"相比普通的\",{\"1\":{\"843\":1}}],[\"相比原始\",{\"1\":{\"561\":1}}],[\"相比前代模型大幅提升\",{\"1\":{\"530\":1}}],[\"相比更低\",{\"1\":{\"522\":1}}],[\"相比其他替代方案如rnn\",{\"1\":{\"507\":1}}],[\"相比w\",{\"1\":{\"483\":1}}],[\"相比单独图像预训练\",{\"1\":{\"268\":1}}],[\"相比传统轻量级\",{\"1\":{\"197\":1}}],[\"相比qformer等轻量适配器\",{\"1\":{\"196\":1}}],[\"相比\",{\"1\":{\"173\":1,\"362\":1,\"367\":1,\"538\":1,\"704\":2,\"797\":1}}],[\"相比于普通的vae\",{\"1\":{\"877\":1}}],[\"相比于逐\",{\"1\":{\"801\":1}}],[\"相比于每次开发单个模型的方式\",{\"1\":{\"707\":1}}],[\"相比于著名的\",{\"1\":{\"577\":1}}],[\"相比于grid\",{\"1\":{\"286\":1}}],[\"相比于region\",{\"1\":{\"286\":1}}],[\"相比于传统的\",{\"1\":{\"127\":1}}],[\"相比于随机采样\",{\"1\":{\"89\":1}}],[\"相比使用预训练目标检测器\",{\"1\":{\"126\":1}}],[\"相比之下\",{\"1\":{\"112\":1,\"173\":3,\"305\":1,\"527\":1,\"806\":1,\"873\":1}}],[\"相反\",{\"1\":{\"90\":1,\"97\":1,\"425\":1,\"512\":1}}],[\"操作将视觉token数量减少至1\",{\"1\":{\"222\":1}}],[\"操作\",{\"1\":{\"73\":1,\"76\":2,\"98\":1,\"163\":1,\"385\":1,\"387\":1,\"427\":1,\"885\":1}}],[\"因批次更大\",{\"1\":{\"565\":1}}],[\"因文章复用段落\",{\"1\":{\"522\":1}}],[\"因基函数\",{\"1\":{\"385\":1}}],[\"因数据量扩大\",{\"1\":{\"210\":1}}],[\"因果注意力\",{\"1\":{\"134\":1}}],[\"因其在编码\",{\"1\":{\"134\":1}}],[\"因此本节旨在更深入地理解这个目标函数究竟在做什么\",{\"1\":{\"870\":1}}],[\"因此对\",{\"1\":{\"867\":1}}],[\"因此对于存在多分支的复杂计算图而言\",{\"1\":{\"685\":1}}],[\"因此才有了transformer可以一次性预测出每个位置对应的next\",{\"1\":{\"814\":1}}],[\"因此通常遵循\",{\"1\":{\"802\":1}}],[\"因此比像素级别遮挡更有效和实用\",{\"1\":{\"801\":1}}],[\"因此图像会被划分为\",{\"1\":{\"774\":1}}],[\"因此采用\",{\"1\":{\"770\":1}}],[\"因此rosenbrock函数也被称为\",{\"1\":{\"697\":1}}],[\"因此反向传播时需将上游梯度gy分别乘以1和\",{\"1\":{\"690\":1}}],[\"因此需调用x\",{\"1\":{\"690\":1}}],[\"因此需要大家自行完成运行时缺失依赖包的安装\",{\"1\":{\"593\":1}}],[\"因此需要探索更高效的学习范式\",{\"1\":{\"520\":1}}],[\"因此需要使用像素级别的损失函数\",{\"1\":{\"465\":1}}],[\"因此需要更多得视觉部分\",{\"1\":{\"286\":1}}],[\"因此需要\",{\"1\":{\"175\":1}}],[\"因此func列表同一时刻最多只存在一个func\",{\"1\":{\"668\":1}}],[\"因此出现了extended\",{\"1\":{\"621\":1}}],[\"因此只需要二维标量表\",{\"1\":{\"591\":1}}],[\"因此不能只用一个全局向量\",{\"1\":{\"885\":1}}],[\"因此不会影响最终的损失值计算\",{\"1\":{\"581\":1}}],[\"因此不论张量是多少维的\",{\"1\":{\"421\":1}}],[\"因此为了确保masked\",{\"1\":{\"581\":1}}],[\"因此模型返回的logits\",{\"1\":{\"581\":1}}],[\"因此此时的预测搞不好是对的\",{\"1\":{\"575\":1}}],[\"因此首轮推理过程需要完成\",{\"1\":{\"544\":1}}],[\"因此第\",{\"1\":{\"541\":1}}],[\"因此无法像微调方法那样从结构化监督中持续优化\",{\"1\":{\"530\":1}}],[\"因此论文探索如何让语言模型具备类似的少样本学习能力\",{\"1\":{\"527\":1}}],[\"因此sst属于单个句子的文本分类任务\",{\"1\":{\"515\":1}}],[\"因此cola属于单个句子的文本二分类任务\",{\"1\":{\"515\":1}}],[\"因此后面\",{\"1\":{\"493\":1}}],[\"因此语义分割可以提供更详细和准确的图像分析结果\",{\"1\":{\"465\":1}}],[\"因此我们可以安全地将梯度符号移入期望中而不会影响等式成立\",{\"1\":{\"868\":1}}],[\"因此我们可以往队列里放入很多负样本\",{\"1\":{\"245\":1}}],[\"因此我们的训练数据中包含了一部分\",{\"1\":{\"810\":1}}],[\"因此我们扩展\",{\"1\":{\"681\":1}}],[\"因此我们只需要根据is\",{\"1\":{\"581\":1}}],[\"因此我们重点关注每个头对应的注意力权重矩阵上\",{\"1\":{\"463\":1}}],[\"因此精确率为\",{\"1\":{\"446\":1}}],[\"因此其假正例率为\",{\"1\":{\"445\":1}}],[\"因此其召回率\",{\"1\":{\"444\":1}}],[\"因此会出现在分母中\",{\"1\":{\"444\":1,\"445\":1}}],[\"因此准确率为\",{\"1\":{\"443\":1}}],[\"因此步长为\",{\"1\":{\"426\":1}}],[\"因此叫\",{\"1\":{\"390\":1}}],[\"因此使用四邻域双线性插值从特征图中获取精确的\",{\"1\":{\"387\":1}}],[\"因此是自注意力\",{\"1\":{\"322\":1}}],[\"因此可以移出期望符号\",{\"1\":{\"867\":1}}],[\"因此可以充分利用计算资源\",{\"1\":{\"621\":1}}],[\"因此可以堆叠多个block\",{\"1\":{\"321\":1}}],[\"因此可能比第二个向量更不可靠\",{\"1\":{\"97\":1}}],[\"因此它有效地充当信息瓶颈\",{\"1\":{\"313\":1}}],[\"因此成本较高\",{\"1\":{\"305\":1}}],[\"因此这个公式可以简化为\",{\"1\":{\"868\":1}}],[\"因此这里就不再给出数据集下载链接了\",{\"1\":{\"302\":1}}],[\"因此这里构造\",{\"1\":{\"145\":1}}],[\"因此这是一个非常庞大的数据集\",{\"1\":{\"299\":1}}],[\"因此如果研究过\",{\"1\":{\"271\":1}}],[\"因此直接移除了最后三层的权重\",{\"1\":{\"223\":1}}],[\"因此在\",{\"1\":{\"869\":1}}],[\"因此在建模局部依赖关系时能力相对不足\",{\"1\":{\"587\":1}}],[\"因此在类别数量相近且平衡的数据集的情况下\",{\"1\":{\"443\":1}}],[\"因此在新的数据集上需要定义新的分类器来重新训练\",{\"1\":{\"305\":1}}],[\"因此在效果上可能不如使用\",{\"1\":{\"301\":1}}],[\"因此在处理高分辨率图像或非互联网来源图像\",{\"1\":{\"223\":1}}],[\"因此在相同的\",{\"1\":{\"136\":1}}],[\"因此大大简化了特征评估的流程\",{\"1\":{\"179\":1}}],[\"因此整个系统bn\",{\"1\":{\"178\":1}}],[\"因此学生和教师网络架构完全相同\",{\"1\":{\"178\":1}}],[\"因此存在较大的噪声\",{\"1\":{\"157\":1}}],[\"因此正负样本是\",{\"1\":{\"145\":1}}],[\"因此每个质心将根据这些不同的半径值与其周围点形成多个点集群\",{\"1\":{\"95\":1}}],[\"因此\",{\"1\":{\"94\":1,\"159\":1,\"173\":1,\"175\":1,\"179\":1,\"181\":1,\"246\":1,\"268\":1,\"269\":1,\"273\":1,\"274\":2,\"305\":2,\"317\":1,\"362\":1,\"446\":1,\"493\":1,\"501\":1,\"503\":1,\"544\":1,\"562\":2,\"575\":1,\"684\":1,\"690\":1,\"703\":1,\"705\":1,\"707\":1,\"716\":2,\"728\":1,\"749\":1,\"771\":1,\"807\":1,\"843\":2,\"847\":1,\"857\":1,\"866\":1,\"868\":2,\"869\":2,\"871\":1,\"872\":1,\"873\":1,\"878\":1,\"881\":1,\"882\":1}}],[\"因此加权融合的时候\",{\"1\":{\"72\":1}}],[\"因为训练目标通常会惩罚预测结果与真实结果之间的距离\",{\"1\":{\"874\":1}}],[\"因为训练数据集中的文本\",{\"1\":{\"305\":1}}],[\"因为真实的\",{\"1\":{\"869\":1}}],[\"因为在这种情况下\",{\"1\":{\"868\":1}}],[\"因为在代码中有个冻结权重的操作\",{\"1\":{\"327\":1}}],[\"因为任意复杂分布都可以通过把简单分布输入到一个足够复杂的函数中得到\",{\"1\":{\"866\":1}}],[\"因为知道某个图像不太可能出现\",{\"1\":{\"864\":1}}],[\"因为随机采样不可微\",{\"1\":{\"853\":1}}],[\"因为这个假设使得产生\",{\"1\":{\"825\":1}}],[\"因为这里是自监督学习\",{\"1\":{\"186\":1}}],[\"因为其距离并不小\",{\"1\":{\"866\":1}}],[\"因为其不参与next\",{\"1\":{\"815\":1}}],[\"因为其概率密度随着与中心的平方距离增大而指数级衰减\",{\"1\":{\"748\":1}}],[\"因为为每个\",{\"1\":{\"814\":1}}],[\"因为梯度变化更平滑\",{\"1\":{\"797\":1}}],[\"因为概率质量\",{\"1\":{\"754\":1}}],[\"因为当\",{\"1\":{\"748\":1}}],[\"因为大多数人根本没病\",{\"1\":{\"731\":1}}],[\"因为大模型的参数量非常大\",{\"1\":{\"482\":1}}],[\"因为某些集合太\",{\"1\":{\"728\":1}}],[\"因为cuda不支持macos\",{\"1\":{\"620\":1}}],[\"因为我们的模型假设在测试时\",{\"1\":{\"874\":1}}],[\"因为我们要预测下一个\",{\"1\":{\"312\":1}}],[\"因为我只是为了了解内部代码情况\",{\"1\":{\"593\":1}}],[\"因为正弦和余弦函数都是周期函数\",{\"1\":{\"587\":1}}],[\"因为正样本和负样本都是相对于锚点来说的\",{\"1\":{\"246\":1}}],[\"因为低频词出现次数极少\",{\"1\":{\"578\":1}}],[\"因为更大容量的模型能吸收更多任务相关的模式\",{\"1\":{\"527\":1}}],[\"因为存在各种变化现象\",{\"1\":{\"515\":1}}],[\"因为作者的预训练模型是用连续的文本序列训练的\",{\"1\":{\"512\":1}}],[\"因为llm的prompt长度通常都是有长度限制的\",{\"1\":{\"501\":1}}],[\"因为收集人类反馈\",{\"1\":{\"483\":1}}],[\"因为微调的参数量跟预训练的是一样的多的\",{\"1\":{\"483\":1}}],[\"因为推理成本是跟prompt长度的平方正向相关的\",{\"1\":{\"482\":1}}],[\"因为通常大模型的实现原理\",{\"1\":{\"482\":1}}],[\"因为要最小化损失\",{\"1\":{\"473\":1}}],[\"因为每个头只能根据分配给自己的这部分特征\",{\"1\":{\"463\":1}}],[\"因为不同位置的编码由不同的正弦和余弦值组成\",{\"1\":{\"587\":1}}],[\"因为不会引入新的中间值\",{\"1\":{\"389\":1}}],[\"因为不需要保存中间变量用于反向传播\",{\"1\":{\"365\":1}}],[\"因为第\",{\"1\":{\"364\":1}}],[\"因为transformer和cnn相比缺少归纳偏置\",{\"1\":{\"314\":1}}],[\"因为都是有效\",{\"1\":{\"312\":1}}],[\"因为数据集的bias\",{\"1\":{\"286\":1}}],[\"因为dual\",{\"1\":{\"283\":1}}],[\"因为你这个更新操作\",{\"1\":{\"250\":1}}],[\"因为到后来第一个分支和第二个分支编码器差距越来越大\",{\"1\":{\"249\":1}}],[\"因为如果这样做了\",{\"1\":{\"249\":1}}],[\"因为如果不这样做\",{\"1\":{\"246\":1}}],[\"因为先进先出\",{\"1\":{\"249\":1}}],[\"因为有\",{\"1\":{\"248\":1}}],[\"因为直接在超大类别空间上做\",{\"1\":{\"248\":1}}],[\"因为后面要用\",{\"1\":{\"170\":1}}],[\"因为向量一般做过\",{\"1\":{\"170\":1}}],[\"因为它可以根据向量来生成图片\",{\"1\":{\"878\":1}}],[\"因为它可以明确地定义如何计算公式右边的两项\",{\"1\":{\"868\":1}}],[\"因为它可以单独控制均值与方差\",{\"1\":{\"744\":1}}],[\"因为它只是一个与\",{\"1\":{\"758\":1}}],[\"因为它是通过对未知量\",{\"1\":{\"758\":1}}],[\"因为它的和不一定为\",{\"1\":{\"758\":1}}],[\"因为它们对模型的适应性至关重要\",{\"1\":{\"495\":1}}],[\"因为它们的作用不同\",{\"1\":{\"417\":1}}],[\"因为它衡量的是模型正确识别所有正例实例的能力\",{\"1\":{\"444\":1}}],[\"因为它集合了大量常见与前沿的图像模型\",{\"1\":{\"395\":1}}],[\"因为它和前面的\",{\"1\":{\"372\":1}}],[\"因为它访问了其外部作用域的变量\",{\"1\":{\"341\":1}}],[\"因为它接收\",{\"1\":{\"341\":1}}],[\"因为它引用了\",{\"1\":{\"340\":1}}],[\"因为它认为每个图片自成一个类别\",{\"1\":{\"243\":1}}],[\"因为它能够在更低层次上递归地检视更高分辨率\",{\"1\":{\"97\":1}}],[\"因为它提供了高质量的点云和功能标注\",{\"1\":{\"62\":1}}],[\"因为前面有\",{\"1\":{\"92\":1}}],[\"因为学习到的特征和权重可以在多个局部区域中复用\",{\"1\":{\"86\":1}}],[\"因为\",{\"1\":{\"86\":1,\"244\":1,\"250\":1,\"272\":1,\"455\":1,\"470\":1,\"616\":1,\"690\":2,\"758\":1,\"807\":1,\"817\":1,\"867\":1,\"869\":1,\"873\":1}}],[\"因为背景区域大小等于特征图大小\",{\"1\":{\"59\":1}}],[\"知识更新\",{\"1\":{\"711\":1}}],[\"知识更新滞后性\",{\"1\":{\"709\":1}}],[\"知识截止日期\",{\"1\":{\"704\":2}}],[\"知识型模型\",{\"1\":{\"704\":1}}],[\"知识型与推理型双模式\",{\"1\":{\"704\":1}}],[\"知识型\",{\"1\":{\"704\":3}}],[\"知识扫盲\",{\"0\":{\"480\":1,\"496\":1},\"1\":{\"480\":1,\"496\":1}}],[\"知识蒸馏不再是自监督预训练之后的\",{\"1\":{\"176\":1}}],[\"知识蒸馏让小模型\",{\"1\":{\"123\":1}}],[\"知识蒸馏\",{\"0\":{\"123\":1},\"1\":{\"176\":1,\"178\":1}}],[\"知识星球\",{\"1\":{\"0\":1}}],[\"知道了哪些点跟自身的相关度更大\",{\"1\":{\"72\":1}}],[\"某个未知\",{\"1\":{\"758\":1}}],[\"某一维如果是\",{\"1\":{\"364\":1}}],[\"某一层次𝐿𝑖的区域特征是通过将来自下一级𝐿𝑖−1的子区域特征总结后的向量与直接处理该局部区域所有原始点的单个pointnet得到的特征向量进行concat得到的\",{\"1\":{\"97\":1}}],[\"某一层解码器输出的点特征\",{\"1\":{\"72\":1}}],[\"某些操作\",{\"1\":{\"361\":1}}],[\"某些功能类型在特定物体类别下会从训练集中省略\",{\"1\":{\"65\":1}}],[\"传到\",{\"1\":{\"880\":1}}],[\"传染性事件\",{\"1\":{\"744\":1}}],[\"传递给下游变量\",{\"1\":{\"690\":1}}],[\"传给\",{\"1\":{\"349\":1,\"869\":1}}],[\"传参保留\",{\"1\":{\"277\":1}}],[\"传统gan训练的完整流程\",{\"1\":{\"840\":1}}],[\"传统\",{\"1\":{\"716\":1,\"885\":1}}],[\"传统的离散变量采样\",{\"1\":{\"795\":1}}],[\"传统的\",{\"1\":{\"716\":1}}],[\"传统的视觉特征提取主要有两种典型实现方案\",{\"1\":{\"280\":1}}],[\"传统语言模型通常依赖单词或字符级输入\",{\"1\":{\"521\":1}}],[\"传统监督学习通常建模\",{\"1\":{\"521\":1}}],[\"传统bpe算法没有这一步\",{\"1\":{\"476\":8}}],[\"传统知识蒸馏通过教师模型指导学生模型提升性能\",{\"1\":{\"150\":1}}],[\"传统vlp方法依赖目标检测器提取区域特征\",{\"1\":{\"149\":1}}],[\"传统方法的缺陷\",{\"1\":{\"103\":1}}],[\"传统方法难以适应不同情况\",{\"1\":{\"71\":1}}],[\"传统卷积神经网络难以直接处理\",{\"1\":{\"103\":1}}],[\"传入函数的参数\",{\"1\":{\"337\":1}}],[\"传入图像\",{\"1\":{\"312\":1}}],[\"传入图像编码信息\",{\"1\":{\"143\":1}}],[\"传入\",{\"1\":{\"272\":1}}],[\"传入了\",{\"1\":{\"162\":1}}],[\"传入的点集特征集合经过转置处理后的维度为\",{\"1\":{\"70\":1}}],[\"传入question文本\",{\"1\":{\"70\":1}}],[\"传入数据维度\",{\"1\":{\"35\":1}}],[\"过大\",{\"1\":{\"816\":1}}],[\"过长截断策略\",{\"1\":{\"594\":1}}],[\"过度顺从错误指令\",{\"1\":{\"539\":1}}],[\"过度关注局部块重建而忽略全局表示的问题\",{\"1\":{\"165\":1}}],[\"过于中性\",{\"1\":{\"538\":1}}],[\"过拟合风险\",{\"1\":{\"385\":1}}],[\"过滤无效行\",{\"1\":{\"577\":1}}],[\"过滤掉\",{\"1\":{\"843\":1}}],[\"过滤掉概率低的\",{\"1\":{\"817\":1}}],[\"过滤掉句子数少于2的行\",{\"1\":{\"577\":1}}],[\"过滤掉vocab中的低频词\",{\"1\":{\"476\":1}}],[\"过滤掉与图像不匹配的原始和合成文本\",{\"1\":{\"140\":1}}],[\"过滤阶段\",{\"0\":{\"146\":1}}],[\"过滤对象既包括网页原始文本\",{\"1\":{\"128\":1}}],[\"过滤\",{\"1\":{\"122\":1,\"537\":1,\"820\":1}}],[\"过滤器\",{\"1\":{\"120\":1}}],[\"过滤噪声\",{\"1\":{\"59\":1}}],[\"过程非常简单\",{\"1\":{\"869\":1}}],[\"过程中混入预训练目标\",{\"1\":{\"538\":1}}],[\"过程\",{\"1\":{\"70\":1}}],[\"前几层将\",{\"1\":{\"866\":1}}],[\"前几个块会比后面的多一个元素\",{\"1\":{\"374\":1}}],[\"前4个位置为文本token\",{\"1\":{\"814\":1}}],[\"前中后都加\",{\"1\":{\"814\":1}}],[\"前乘了一个经验选择的系数\",{\"1\":{\"807\":1}}],[\"前景与背景融合不自然\",{\"1\":{\"806\":1}}],[\"前景点少\",{\"1\":{\"470\":1}}],[\"前景点\",{\"1\":{\"78\":1}}],[\"前后端搭建\",{\"1\":{\"717\":1}}],[\"前三阶段的\",{\"1\":{\"700\":1}}],[\"前缀\",{\"1\":{\"689\":1}}],[\"前缀让\",{\"1\":{\"239\":1}}],[\"前馈网络的中间层维度为\",{\"1\":{\"774\":1}}],[\"前馈网络子层\",{\"1\":{\"272\":1}}],[\"前馈层\",{\"1\":{\"627\":2,\"630\":2}}],[\"前馈神经网络\",{\"1\":{\"622\":1}}],[\"前一半桶\",{\"1\":{\"591\":1}}],[\"前一个epoch的学生网络\",{\"1\":{\"182\":1}}],[\"前面是特殊token\",{\"1\":{\"578\":1}}],[\"前提是标准差\",{\"1\":{\"871\":1}}],[\"前提是这两个事件是互斥的\",{\"1\":{\"729\":1}}],[\"前提是数据集大致平衡\",{\"1\":{\"453\":1}}],[\"前提条件是行优先存储\",{\"1\":{\"426\":1}}],[\"前者是其2倍\",{\"1\":{\"577\":1}}],[\"前者是用模型\",{\"1\":{\"396\":1}}],[\"前者为双向\",{\"1\":{\"126\":1}}],[\"前使用\",{\"1\":{\"362\":1}}],[\"前半部分是文本\",{\"1\":{\"276\":1}}],[\"前置知识\",{\"0\":{\"271\":1,\"702\":1,\"824\":1}}],[\"前两步不变\",{\"1\":{\"490\":1}}],[\"前两列\",{\"1\":{\"425\":1}}],[\"前两行\",{\"1\":{\"425\":1}}],[\"前两张图片的表征距离比较近\",{\"1\":{\"242\":1}}],[\"前两种与\",{\"1\":{\"20\":1}}],[\"前向主函数\",{\"1\":{\"804\":1}}],[\"前向特征提取\",{\"1\":{\"804\":1}}],[\"前向模型\",{\"1\":{\"759\":1}}],[\"前向计算\",{\"1\":{\"186\":1}}],[\"前向传播时\",{\"1\":{\"881\":2}}],[\"前向传播时是one\",{\"1\":{\"796\":1}}],[\"前向传播和反向传播的计算可以不对应\",{\"1\":{\"881\":1}}],[\"前向传播逻辑\",{\"1\":{\"580\":1}}],[\"前向传播计算\",{\"1\":{\"473\":1}}],[\"前向传播计算损失值\",{\"1\":{\"471\":1}}],[\"前向传播流程\",{\"0\":{\"288\":1,\"815\":1}}],[\"前向传播代码实现\",{\"1\":{\"163\":1}}],[\"前向传播函数\",{\"1\":{\"100\":1,\"101\":1,\"170\":1,\"318\":1,\"467\":1,\"468\":1,\"469\":1,\"470\":1,\"848\":1}}],[\"前向传播\",{\"0\":{\"794\":1},\"1\":{\"82\":1,\"142\":1,\"163\":1,\"319\":1,\"803\":1,\"848\":2}}],[\"前向传播过程主要是为了计算两个训练目标的损失\",{\"1\":{\"145\":1}}],[\"前向传播过程\",{\"1\":{\"81\":1}}],[\"前向传播过程如下\",{\"1\":{\"70\":1}}],[\"前将低维嵌入映射回高维空间\",{\"1\":{\"167\":1}}],[\"前\",{\"1\":{\"159\":1,\"162\":1,\"179\":1,\"186\":1,\"272\":1,\"774\":1,\"815\":1}}],[\"前期\",{\"1\":{\"159\":1}}],[\"前的某一层\",{\"1\":{\"98\":1}}],[\"骨干网络\",{\"1\":{\"70\":1}}],[\"也正是\",{\"1\":{\"880\":1}}],[\"也提供了把\",{\"1\":{\"878\":1}}],[\"也提示了未来改进方向\",{\"1\":{\"527\":1}}],[\"也能把\",{\"1\":{\"878\":1}}],[\"也能感知全局位置信息\",{\"1\":{\"587\":1}}],[\"也难以训练\",{\"1\":{\"866\":1}}],[\"也类似于\",{\"1\":{\"811\":1}}],[\"也一起看作潜变量的一部分\",{\"1\":{\"807\":1}}],[\"也一并加入\",{\"1\":{\"92\":1,\"96\":1}}],[\"也一并提取\",{\"1\":{\"92\":1}}],[\"也分离出来\",{\"1\":{\"796\":1}}],[\"也分析了在四种不同设置下预训练模型的零次\",{\"1\":{\"507\":1}}],[\"也为未来探索更强大的视觉理解与生成模型提供了方向\",{\"1\":{\"790\":1}}],[\"也借鉴了\",{\"1\":{\"788\":1}}],[\"也叫\",{\"1\":{\"795\":1}}],[\"也叫正态分布\",{\"1\":{\"746\":1}}],[\"也叫作边缘似然\",{\"1\":{\"733\":1}}],[\"也得允许\",{\"1\":{\"728\":1}}],[\"也属于\",{\"1\":{\"728\":1}}],[\"也称大型语言模型\",{\"1\":{\"703\":1}}],[\"也称为各向同性协方差矩阵\",{\"1\":{\"752\":1}}],[\"也称为贝叶斯定理\",{\"1\":{\"732\":1}}],[\"也称为\",{\"1\":{\"469\":1}}],[\"也称为intersection\",{\"1\":{\"469\":1}}],[\"也称为误报概率\",{\"1\":{\"445\":1}}],[\"也称为召回率\",{\"1\":{\"444\":1}}],[\"也在上表4中\",{\"1\":{\"515\":1}}],[\"也用\",{\"1\":{\"493\":2}}],[\"也几乎未引入额外的\",{\"1\":{\"492\":1}}],[\"也还有一些其它参数\",{\"1\":{\"481\":1}}],[\"也通常是句子长度\",{\"1\":{\"405\":1}}],[\"也都是适用的\",{\"1\":{\"385\":1}}],[\"也会被加载\",{\"1\":{\"366\":1}}],[\"也需要保持输入图像尺寸与预训练时一致\",{\"1\":{\"317\":1}}],[\"也是该分布的众数\",{\"1\":{\"746\":1}}],[\"也是在\",{\"1\":{\"590\":1}}],[\"也是其一大亮点\",{\"1\":{\"300\":1}}],[\"也是如此\",{\"1\":{\"199\":1}}],[\"也被\",{\"1\":{\"866\":1}}],[\"也被称为\",{\"1\":{\"797\":1}}],[\"也被直接监督\",{\"1\":{\"277\":1}}],[\"也被近年来的工作所采纳\",{\"1\":{\"126\":1}}],[\"也不训练\",{\"1\":{\"773\":1}}],[\"也不及\",{\"1\":{\"538\":1}}],[\"也不局限于某一个方案\",{\"1\":{\"483\":1}}],[\"也不对\",{\"1\":{\"387\":1}}],[\"也不会进行变换\",{\"1\":{\"869\":1}}],[\"也不会参与梯度计算或优化\",{\"1\":{\"366\":1}}],[\"也不会计算梯度\",{\"1\":{\"365\":1}}],[\"也不例外\",{\"1\":{\"274\":1}}],[\"也不需要高分辨率图像\",{\"1\":{\"149\":1}}],[\"也就意味着我们只需要实现空间掩码即可\",{\"1\":{\"848\":1}}],[\"也就为非线性激活函数提供了更多可以学习的特征组合\",{\"1\":{\"321\":1}}],[\"也就几万个类别\",{\"1\":{\"248\":1}}],[\"也就是向量的每一维都是浮点数\",{\"1\":{\"878\":1}}],[\"也就是公式5的右边\",{\"1\":{\"873\":1}}],[\"也就是把文本损失和图像损失当作\",{\"1\":{\"815\":1}}],[\"也就是在某个距离范围内\",{\"1\":{\"754\":1}}],[\"也就是在句子开头加一个\",{\"1\":{\"573\":1}}],[\"也就是所谓的\",{\"1\":{\"706\":1,\"754\":1}}],[\"也就是我们常说的\",{\"1\":{\"706\":1}}],[\"也就是我的\",{\"1\":{\"248\":1}}],[\"也就是改变x对于y的影响因子\",{\"1\":{\"656\":1}}],[\"也就是两个句子\",{\"1\":{\"573\":1}}],[\"也就是有哪些子词以及这些子词的出现次数\",{\"1\":{\"476\":1}}],[\"也就是每个变量自己的方差\",{\"1\":{\"455\":1}}],[\"也就是和输入的\",{\"1\":{\"409\":1}}],[\"也就是形成闭包\",{\"1\":{\"340\":1}}],[\"也就是q\",{\"1\":{\"325\":1}}],[\"也就是经过卷积后拼接得到的特征图\",{\"1\":{\"318\":1}}],[\"也就是卷积核的数量\",{\"1\":{\"318\":1}}],[\"也就是一张图像搭配与之对应的文本描述\",{\"1\":{\"298\":1}}],[\"也就是未pooler的\",{\"1\":{\"276\":1}}],[\"也就是\",{\"1\":{\"248\":1,\"490\":1,\"773\":1,\"798\":1,\"799\":1,\"882\":1}}],[\"也就是字典的大小就是分母下方的类别数量\",{\"1\":{\"248\":1}}],[\"也就是现在只有两个类别\",{\"1\":{\"248\":1}}],[\"也就是会得到这样一个向量\",{\"1\":{\"248\":1}}],[\"也就是类似\",{\"1\":{\"247\":1}}],[\"也就是原始的信号空间是由单词组成\",{\"1\":{\"246\":1}}],[\"也就是同一个类别的图片\",{\"1\":{\"243\":1}}],[\"也就是imagenet上的预训练模型\",{\"1\":{\"241\":1}}],[\"也就是说这个张量可以看作是一个\",{\"1\":{\"423\":1}}],[\"也就是说当我们用一个很小的\",{\"1\":{\"246\":1}}],[\"也就是说\",{\"1\":{\"76\":1,\"186\":1,\"233\":1,\"336\":1,\"444\":1,\"445\":1,\"618\":1,\"712\":1,\"728\":1,\"741\":1,\"749\":1,\"826\":1,\"846\":2,\"847\":1,\"869\":1,\"870\":1,\"878\":1,\"881\":2}}],[\"也就是取出上面随机选择的问题文本\",{\"1\":{\"68\":1}}],[\"也没有浓缩得那么简洁\",{\"1\":{\"246\":1}}],[\"也与\",{\"1\":{\"176\":1}}],[\"也包括合成描述\",{\"1\":{\"128\":1}}],[\"也应该以一种方式被处理\",{\"1\":{\"86\":1}}],[\"也可用于预测图像\",{\"1\":{\"820\":1}}],[\"也可用于\",{\"1\":{\"784\":1}}],[\"也可用参数化函数表示\",{\"1\":{\"727\":1}}],[\"也可联合编码图文对用于分类任务\",{\"1\":{\"261\":1}}],[\"也可作为融合编码器处理图文对分类任务\",{\"1\":{\"260\":1}}],[\"也可能产生多个输出\",{\"1\":{\"681\":1}}],[\"也可能触发复制\",{\"1\":{\"362\":1}}],[\"也可能存在多个与被\",{\"1\":{\"157\":1}}],[\"也可能导致错误分类\",{\"1\":{\"112\":1}}],[\"也可以写成\",{\"1\":{\"831\":1}}],[\"也可以理解为是一种\",{\"1\":{\"817\":1}}],[\"也可以简称为概率推理\",{\"1\":{\"758\":1}}],[\"也可以将\",{\"1\":{\"738\":1}}],[\"也可以指\",{\"1\":{\"728\":1}}],[\"也可以基于大模型的推理\",{\"1\":{\"707\":1}}],[\"也可以看到\",{\"1\":{\"587\":1}}],[\"也可以用以下方式表示\",{\"1\":{\"450\":1}}],[\"也可以传\",{\"1\":{\"366\":1}}],[\"也可以进行随机裁剪\",{\"1\":{\"317\":1}}],[\"也可以采用视觉transformer模型\",{\"1\":{\"299\":1}}],[\"也可以作为融合编码器\",{\"1\":{\"262\":1}}],[\"也可以很好地训练模型\",{\"1\":{\"246\":1}}],[\"也可以是特定任务\",{\"1\":{\"232\":1}}],[\"也可以是软标签\",{\"1\":{\"64\":1}}],[\"也可以归一化为\",{\"1\":{\"82\":1}}],[\"也可\",{\"1\":{\"49\":1}}],[\"点数\",{\"1\":{\"470\":1}}],[\"点\",{\"1\":{\"453\":2}}],[\"点表示\",{\"1\":{\"450\":1}}],[\"点上取值\",{\"1\":{\"387\":1}}],[\"点积才能得到一个有意义的相似度分数\",{\"1\":{\"590\":1}}],[\"点积\",{\"1\":{\"367\":1,\"590\":1,\"822\":1}}],[\"点积的缩放因子\",{\"1\":{\"272\":1}}],[\"点的数量\",{\"1\":{\"111\":1}}],[\"点的特征数据\",{\"1\":{\"92\":1}}],[\"点之间的相互作用\",{\"1\":{\"105\":1}}],[\"点之间存在相互作用\",{\"1\":{\"104\":1}}],[\"点与点之间有空间关系\",{\"1\":{\"104\":1}}],[\"点额外特征\",{\"1\":{\"92\":1}}],[\"点坐标\",{\"1\":{\"92\":1}}],[\"点大小\",{\"1\":{\"83\":1}}],[\"点集抽象层\",{\"1\":{\"92\":1}}],[\"点集的划分必须产生跨分区的共同结构\",{\"1\":{\"86\":1}}],[\"点集划分是指如何将一个大的点云分割成更小的\",{\"1\":{\"86\":1}}],[\"点集特征集合\",{\"1\":{\"75\":1}}],[\"点集集合中每个点的特征和文本特征信息进行融合\",{\"1\":{\"70\":1}}],[\"点特征作为键\",{\"1\":{\"72\":1}}],[\"点级别标注\",{\"1\":{\"68\":1}}],[\"点云模型\",{\"1\":{\"112\":1}}],[\"点云是点的集合\",{\"1\":{\"104\":1}}],[\"点云是三维几何数据的一种重要表示形式\",{\"1\":{\"103\":1}}],[\"点云语义分割模型\",{\"0\":{\"101\":1}}],[\"点云语义分割\",{\"0\":{\"98\":1}}],[\"点云的姿态可能各不相同\",{\"1\":{\"107\":1}}],[\"点云的无序性\",{\"1\":{\"104\":1,\"105\":1}}],[\"点云的额外特征\",{\"1\":{\"92\":1}}],[\"点云的跨模态点云形状补全方法\",{\"1\":{\"22\":1}}],[\"点云坐标数据\",{\"1\":{\"92\":2}}],[\"点云坐标\",{\"1\":{\"83\":1}}],[\"点云预处理\",{\"1\":{\"83\":1}}],[\"点云分割中最常用的指标之一\",{\"1\":{\"82\":1}}],[\"点云分支\",{\"1\":{\"54\":1}}],[\"点云维度\",{\"1\":{\"76\":1}}],[\"点云对象和一个自然语言问题\",{\"1\":{\"70\":1}}],[\"点云对象组成\",{\"1\":{\"16\":1}}],[\"点云id\",{\"1\":{\"68\":2}}],[\"点云来源\",{\"1\":{\"67\":1}}],[\"点云中点的顺序不影响整体形状\",{\"1\":{\"115\":1}}],[\"点云中点的数量\",{\"1\":{\"82\":1}}],[\"点云中的每个点被标注为支持一个或多个功能类型\",{\"1\":{\"62\":1}}],[\"点云中相关点\",{\"1\":{\"41\":1}}],[\"点云无序特征\",{\"1\":{\"59\":1}}],[\"点云功能区域索引列表\",{\"1\":{\"58\":1}}],[\"点云功能区域掩码列表\",{\"1\":{\"58\":1}}],[\"点云列表\",{\"1\":{\"58\":1}}],[\"点云配对数据的数据集piad\",{\"1\":{\"48\":1}}],[\"点云等\",{\"1\":{\"43\":1}}],[\"点云编码器\",{\"1\":{\"40\":1}}],[\"点云特征图\",{\"1\":{\"76\":1}}],[\"点云特征与几何结构特征的融合\",{\"0\":{\"36\":1}}],[\"点云特征和几何结构特征做特征融合\",{\"1\":{\"35\":1}}],[\"点云特征\",{\"1\":{\"30\":1}}],[\"点云样本列表\",{\"1\":{\"29\":1}}],[\"点云索引下标区间\",{\"1\":{\"29\":1}}],[\"点云索引文件路径\",{\"1\":{\"29\":1}}],[\"点云\",{\"0\":{\"114\":1},\"1\":{\"29\":2,\"67\":1,\"114\":2}}],[\"点云数据归一化处理\",{\"1\":{\"83\":1}}],[\"点云数据组织形式\",{\"1\":{\"68\":1}}],[\"点云数据\",{\"1\":{\"40\":1,\"68\":1,\"83\":1,\"101\":1}}],[\"点云数量是前者的五倍\",{\"1\":{\"17\":1}}],[\"点云数\",{\"1\":{\"17\":1}}],[\"点云部分主要来自以下开源数据源\",{\"1\":{\"17\":1}}],[\"点云关联\",{\"1\":{\"7\":1}}],[\"种\",{\"1\":{\"843\":1}}],[\"种重复排列\",{\"1\":{\"762\":1}}],[\"种不同的排列方式\",{\"1\":{\"762\":1}}],[\"种可能的值\",{\"1\":{\"807\":1}}],[\"种可能的图像\",{\"1\":{\"800\":1}}],[\"种可能的顺序\",{\"1\":{\"512\":1}}],[\"种可能结果\",{\"1\":{\"761\":4}}],[\"种语言和方言\",{\"1\":{\"704\":1}}],[\"种模型大小\",{\"1\":{\"704\":1}}],[\"种唯一组合\",{\"1\":{\"67\":1}}],[\"种物体\",{\"1\":{\"63\":1}}],[\"内循环\",{\"1\":{\"531\":1}}],[\"内取平均\",{\"1\":{\"470\":1}}],[\"内样本取平均\",{\"1\":{\"468\":1,\"469\":1,\"470\":1}}],[\"内\",{\"1\":{\"467\":1,\"473\":1,\"541\":1}}],[\"内置库\",{\"1\":{\"401\":1}}],[\"内置\",{\"0\":{\"400\":1,\"402\":1}}],[\"内置命名空间\",{\"1\":{\"336\":1}}],[\"内存释放机制\",{\"1\":{\"688\":1}}],[\"内存使用量大幅降低\",{\"1\":{\"688\":1}}],[\"内存占用低\",{\"1\":{\"688\":1}}],[\"内存占用高\",{\"1\":{\"688\":1}}],[\"内存\",{\"1\":{\"548\":1}}],[\"内存管理\",{\"1\":{\"548\":1}}],[\"内存地址不变\",{\"1\":{\"427\":1}}],[\"内存空间得以连续布局\",{\"1\":{\"426\":1}}],[\"内存先存储第\",{\"1\":{\"422\":2}}],[\"内存步长\",{\"1\":{\"361\":1}}],[\"内存布局\",{\"1\":{\"360\":1}}],[\"内负样本有限\",{\"1\":{\"277\":1}}],[\"内从\",{\"1\":{\"179\":1}}],[\"内线性升至基础值\",{\"1\":{\"179\":1}}],[\"内容不可追溯\",{\"1\":{\"709\":1}}],[\"内容相似度\",{\"1\":{\"590\":1}}],[\"内容结构遵循原文小节安排\",{\"1\":{\"536\":1}}],[\"内容\",{\"1\":{\"67\":1}}],[\"内部又是\",{\"1\":{\"575\":1}}],[\"内部是\",{\"1\":{\"575\":1}}],[\"内部验证调用\",{\"1\":{\"274\":2}}],[\"内部调用\",{\"1\":{\"274\":5}}],[\"内部标注人员手动构造的示例\",{\"1\":{\"232\":1}}],[\"内部会实现\",{\"1\":{\"170\":1}}],[\"内部\",{\"1\":{\"33\":1,\"73\":2,\"273\":4}}],[\"内部或\",{\"1\":{\"33\":1}}],[\"抓取所有垃圾邮件\",{\"1\":{\"447\":1}}],[\"抓取耳机\",{\"1\":{\"65\":1}}],[\"抓握中部\",{\"1\":{\"28\":1}}],[\"目前为止\",{\"1\":{\"871\":1}}],[\"目前采用的主要改进如下\",{\"1\":{\"704\":1}}],[\"目前\",{\"1\":{\"703\":1,\"704\":2,\"709\":1,\"717\":1,\"766\":1}}],[\"目前实现的版本无法实现上图中计算图多分支的结构\",{\"1\":{\"665\":1}}],[\"目前尚无有效方式解释它为何会给出某一答案\",{\"1\":{\"530\":1}}],[\"目前尚不清楚模型在推理任务中是否\",{\"1\":{\"530\":1}}],[\"目前还没有达成共识\",{\"1\":{\"507\":1}}],[\"目前主流的方法包括2019年\",{\"1\":{\"491\":1}}],[\"目前参数量最小的多模态transformer方法\",{\"1\":{\"281\":1}}],[\"目的\",{\"1\":{\"310\":1,\"311\":1,\"312\":1,\"403\":1,\"591\":1}}],[\"目的是为了让llm的推理能力能够更进一步提升\",{\"1\":{\"502\":1}}],[\"目的是\",{\"1\":{\"470\":1,\"840\":1}}],[\"目的是让点云\",{\"1\":{\"107\":1}}],[\"目的是从一个大的数据集中选出一组代表性强的点\",{\"1\":{\"89\":1}}],[\"目的是测试模型对新组合的泛化能力\",{\"1\":{\"65\":1}}],[\"目的是评估模型在熟悉场景下的表现\",{\"1\":{\"65\":1}}],[\"目录获取所有图片路径\",{\"1\":{\"303\":1,\"304\":1}}],[\"目标不同\",{\"1\":{\"885\":1}}],[\"目标图像\",{\"1\":{\"866\":1}}],[\"目标倾向于优先建模像素之间的短程依赖\",{\"1\":{\"807\":1}}],[\"目标值\",{\"1\":{\"797\":1}}],[\"目标预训练\",{\"0\":{\"786\":1}}],[\"目标人群\",{\"1\":{\"717\":1}}],[\"目标掩码\",{\"1\":{\"631\":1}}],[\"目标任务\",{\"1\":{\"507\":1}}],[\"目标点\",{\"1\":{\"470\":1}}],[\"目标检测\",{\"1\":{\"470\":1}}],[\"目标检测器开销高\",{\"1\":{\"149\":1}}],[\"目标大小\",{\"1\":{\"390\":1}}],[\"目标函数是\",{\"1\":{\"840\":1}}],[\"目标函数使用\",{\"1\":{\"809\":1}}],[\"目标函数如下\",{\"1\":{\"537\":1}}],[\"目标函数\",{\"1\":{\"385\":2}}],[\"目标仍是\",{\"1\":{\"364\":1}}],[\"目标让视觉编码器输出的图像特征与语言模型的词向量空间对齐\",{\"1\":{\"234\":1}}],[\"目标锐化\",{\"1\":{\"183\":1}}],[\"目标进行微调\",{\"1\":{\"128\":1}}],[\"目标在\",{\"1\":{\"128\":1}}],[\"目标是用看起来合理的像素填补这个空洞\",{\"1\":{\"874\":1}}],[\"目标是学习一个生成模型\",{\"1\":{\"864\":1}}],[\"目标是学习一个全局表示\",{\"1\":{\"507\":1}}],[\"目标是建立对数据点\",{\"1\":{\"864\":1}}],[\"目标是使现有模型更符合人类意图\",{\"1\":{\"539\":1}}],[\"目标是使正样本的图文对在特征空间中接近\",{\"1\":{\"127\":1}}],[\"目标是训练好\",{\"1\":{\"309\":1}}],[\"目标是从\",{\"1\":{\"265\":1}}],[\"目标是为了让真正标签的输出尽可能的大\",{\"1\":{\"248\":1}}],[\"目标是让模型在预训练的基础上进一步掌握多模态指令理解与复杂推理能力\",{\"1\":{\"235\":1}}],[\"目标是优化模型\",{\"1\":{\"8\":1}}],[\"目标\",{\"1\":{\"98\":1,\"198\":3,\"232\":1,\"470\":2,\"511\":1,\"558\":1,\"559\":1,\"766\":1}}],[\"目标功能区域\",{\"1\":{\"78\":1}}],[\"目标物体框\",{\"1\":{\"58\":2}}],[\"🔸\",{\"1\":{\"820\":2}}],[\"🔗\",{\"1\":{\"735\":1}}],[\"🚀\",{\"0\":{\"633\":1}}],[\"📚\",{\"1\":{\"616\":1}}],[\"👉\",{\"1\":{\"407\":1,\"409\":1,\"459\":1}}],[\"📌\",{\"1\":{\"112\":1}}],[\"📐\",{\"1\":{\"112\":1}}],[\"📊\",{\"1\":{\"112\":1}}],[\"📈\",{\"1\":{\"112\":2}}],[\"📉\",{\"1\":{\"112\":2}}],[\"🔍\",{\"1\":{\"112\":6,\"616\":1}}],[\"📦\",{\"1\":{\"100\":1,\"115\":1}}],[\"🔹\",{\"1\":{\"65\":2}}],[\"🔹目标\",{\"1\":{\"28\":4}}],[\"💡\",{\"1\":{\"64\":1,\"112\":1,\"248\":1,\"616\":1}}],[\"构成解码器\",{\"1\":{\"777\":1}}],[\"构成样本空间\",{\"1\":{\"731\":1}}],[\"构成一个位置序列矩阵\",{\"1\":{\"597\":1}}],[\"构成了一个\",{\"1\":{\"471\":1}}],[\"构造编码器与解码器的通道列表\",{\"1\":{\"821\":1}}],[\"构造预测标签\",{\"1\":{\"815\":1}}],[\"构造遮挡掩码\",{\"1\":{\"804\":1}}],[\"构造相对位置矩阵\",{\"1\":{\"591\":1}}],[\"构造训练目标\",{\"1\":{\"312\":1}}],[\"构造函数\",{\"1\":{\"272\":1}}],[\"构造目标标签\",{\"1\":{\"163\":1}}],[\"构造新的图文对\",{\"1\":{\"162\":1}}],[\"构造一对一的匹配目标\",{\"1\":{\"161\":1}}],[\"构造一个新的张量\",{\"1\":{\"581\":1}}],[\"构造一个与\",{\"1\":{\"163\":1,\"818\":1}}],[\"构造一个单位矩阵\",{\"1\":{\"108\":1}}],[\"构造一个从\",{\"1\":{\"92\":1}}],[\"构造软标签\",{\"1\":{\"157\":1}}],[\"构造两组负样本\",{\"1\":{\"145\":1}}],[\"构造图文匹配矩阵\",{\"1\":{\"145\":3}}],[\"构造图像的\",{\"1\":{\"161\":1}}],[\"构造图像\",{\"1\":{\"143\":1}}],[\"构造输入的\",{\"1\":{\"143\":1}}],[\"构造\",{\"1\":{\"143\":1,\"147\":1,\"161\":1,\"162\":1,\"277\":1,\"580\":1,\"814\":4,\"815\":1}}],[\"构造对应的数据加载器\",{\"1\":{\"142\":1}}],[\"构造出你所需要的所有\",{\"1\":{\"728\":1}}],[\"构造出\",{\"1\":{\"69\":1}}],[\"构造出对应的二值掩码\",{\"1\":{\"64\":1}}],[\"构建目标函数\",{\"0\":{\"867\":1}}],[\"构建标签\",{\"1\":{\"822\":1}}],[\"构建编码器和解码器的每一层\",{\"1\":{\"821\":1}}],[\"构建多层编码器和解码器\",{\"1\":{\"793\":1}}],[\"构建多视图增强\",{\"1\":{\"186\":1}}],[\"构建出一个来源于实际业务的小型验证集\",{\"1\":{\"717\":1}}],[\"构建出性能更强的教师来指导学生学习\",{\"1\":{\"182\":1}}],[\"构建器平台\",{\"1\":{\"704\":1}}],[\"构建泰勒展开\",{\"1\":{\"695\":1}}],[\"构建样本\",{\"1\":{\"579\":1}}],[\"构建词汇表\",{\"1\":{\"476\":1}}],[\"构建加权随机采样器\",{\"1\":{\"403\":1}}],[\"构建一个基于\",{\"1\":{\"469\":1,\"470\":1}}],[\"构建一个组合损失函数\",{\"1\":{\"468\":1}}],[\"构建一个下三角矩阵作为因果掩码矩阵\",{\"1\":{\"312\":1}}],[\"构建一个多样化的指令\",{\"1\":{\"232\":1}}],[\"构建匹配标签\",{\"1\":{\"311\":1}}],[\"构建输入图像列表\",{\"1\":{\"311\":1}}],[\"构建输入文本列表\",{\"1\":{\"311\":1}}],[\"构建query和text的padding\",{\"1\":{\"311\":1}}],[\"构建query\",{\"1\":{\"311\":1}}],[\"构建padding\",{\"1\":{\"309\":1}}],[\"构建描述文本并提取特征\",{\"1\":{\"300\":1}}],[\"构建的\",{\"1\":{\"295\":1}}],[\"构建返回字典\",{\"1\":{\"278\":1}}],[\"构建负样本\",{\"1\":{\"278\":1}}],[\"构建测试\",{\"1\":{\"274\":1}}],[\"构建测试数据集\",{\"1\":{\"274\":1}}],[\"构建验证\",{\"1\":{\"274\":1}}],[\"构建验证数据集\",{\"1\":{\"274\":1}}],[\"构建训练数据加载器\",{\"1\":{\"803\":1}}],[\"构建训练数据集\",{\"1\":{\"274\":1}}],[\"构建训练\",{\"1\":{\"274\":1}}],[\"构建无干扰的测试集\",{\"1\":{\"274\":1}}],[\"构建无干扰的验证集\",{\"1\":{\"274\":1}}],[\"构建无干扰测试数据集\",{\"1\":{\"274\":1}}],[\"构建无干扰验证数据集\",{\"1\":{\"274\":1}}],[\"构建了语言模型\",{\"1\":{\"572\":1}}],[\"构建了一个与\",{\"1\":{\"810\":1}}],[\"构建了一个动态的字典\",{\"1\":{\"245\":1}}],[\"构建了一个强大且通用的视觉\",{\"1\":{\"206\":1}}],[\"构建了多模态对话系统\",{\"1\":{\"193\":1}}],[\"构建优化器\",{\"1\":{\"186\":1}}],[\"构建教师网络\",{\"1\":{\"186\":1}}],[\"构建学生网络\",{\"1\":{\"186\":1}}],[\"构建学生和教师\",{\"1\":{\"186\":1}}],[\"构建学生\",{\"1\":{\"186\":2}}],[\"构建动量编码器\",{\"1\":{\"160\":1}}],[\"构建文本所有对比特征\",{\"1\":{\"147\":1}}],[\"构建图像所有对比特征\",{\"1\":{\"147\":1}}],[\"构建语言建模标签\",{\"1\":{\"142\":1}}],[\"构建预训练语料\",{\"1\":{\"138\":1}}],[\"构建全局特征向量\",{\"1\":{\"115\":1}}],[\"构建点云的层次化表示\",{\"1\":{\"112\":1}}],[\"构建点之间的邻接图\",{\"1\":{\"112\":1}}],[\"构建mlp层\",{\"1\":{\"100\":1}}],[\"构建用于特征传播\",{\"1\":{\"100\":1}}],[\"构建它们的局部邻域区域\",{\"1\":{\"92\":1}}],[\"构建局部邻域的半径\",{\"1\":{\"92\":2}}],[\"构建问题\",{\"0\":{\"63\":1}}],[\"构建\",{\"1\":{\"43\":2,\"78\":2,\"186\":2,\"227\":1,\"272\":2,\"274\":1,\"278\":1,\"312\":1,\"470\":1,\"802\":1,\"803\":1,\"820\":1}}],[\"陈述句等\",{\"1\":{\"63\":1}}],[\"疑问句\",{\"1\":{\"63\":1}}],[\"改写为条件形式\",{\"1\":{\"874\":1}}],[\"改写\",{\"1\":{\"792\":1}}],[\"改善了对长文本的理解和生成能力\",{\"1\":{\"704\":1}}],[\"改善单模态编码语义理解\",{\"1\":{\"149\":1}}],[\"改用50k词汇表的字节级bpe编码\",{\"1\":{\"564\":1}}],[\"改用动态掩码\",{\"1\":{\"560\":1}}],[\"改变维度顺序\",{\"1\":{\"361\":1}}],[\"改变\",{\"1\":{\"116\":1}}],[\"改进之后\",{\"1\":{\"843\":1}}],[\"改进了推理能力和指令遵循能力\",{\"1\":{\"704\":1}}],[\"改进的\",{\"1\":{\"821\":1}}],[\"改进的合并策略\",{\"1\":{\"521\":1}}],[\"改进的字节对编码\",{\"1\":{\"521\":1}}],[\"改进版本\",{\"1\":{\"843\":1}}],[\"改进版\",{\"1\":{\"514\":1}}],[\"改进版的\",{\"1\":{\"514\":1}}],[\"改进而来\",{\"1\":{\"470\":1}}],[\"改进方法\",{\"1\":{\"261\":1}}],[\"改进\",{\"1\":{\"112\":6}}],[\"改为像素重建\",{\"1\":{\"780\":1}}],[\"改为\",{\"1\":{\"63\":1,\"620\":1,\"857\":1,\"873\":1}}],[\"改良的交叉注意力\",{\"0\":{\"32\":1}}],[\"例外情况\",{\"1\":{\"522\":1}}],[\"例子说明\",{\"0\":{\"415\":1}}],[\"例子如下\",{\"1\":{\"358\":1,\"685\":1}}],[\"例子\",{\"1\":{\"352\":1,\"378\":1,\"401\":1,\"828\":1,\"829\":1}}],[\"例\",{\"1\":{\"63\":1,\"762\":1}}],[\"例如书写快导致角度大\",{\"1\":{\"866\":1}}],[\"例如二值数据可用伯努利分布\",{\"1\":{\"865\":1}}],[\"例如对于黑白手写数字数据集\",{\"1\":{\"847\":1}}],[\"例如更准确地按照提示文本生成图像\",{\"1\":{\"816\":1}}],[\"例如用于\",{\"1\":{\"794\":1}}],[\"例如灰度图像\",{\"0\":{\"756\":1}}],[\"例如某些事件之间是正相关的\",{\"1\":{\"744\":1}}],[\"例如某些包在arm64系统上没有预先编译好的版本\",{\"1\":{\"438\":1}}],[\"例如原始数据或预处理后的数据\",{\"1\":{\"712\":1}}],[\"例如数字类别\",{\"1\":{\"866\":1}}],[\"例如数据收集模块或预处理模块\",{\"1\":{\"712\":1}}],[\"例如数学问题\",{\"1\":{\"706\":1}}],[\"例如拥有\",{\"1\":{\"703\":1}}],[\"例如加法\",{\"1\":{\"681\":1}}],[\"例如长度\",{\"1\":{\"591\":1}}],[\"例如上图中\",{\"1\":{\"575\":1}}],[\"例如65b模型维度为8192\",{\"1\":{\"548\":1}}],[\"例如1\",{\"1\":{\"534\":1}}],[\"例如预测缺失的单词或句子\",{\"1\":{\"521\":1}}],[\"例如背景像素可能占据了大部分\",{\"1\":{\"465\":1}}],[\"例如总共\",{\"1\":{\"445\":1,\"446\":1}}],[\"例如卷云\",{\"1\":{\"442\":1}}],[\"例如将\",{\"1\":{\"387\":1,\"816\":1}}],[\"例如我们希望将每个\",{\"1\":{\"386\":1}}],[\"例如从\",{\"1\":{\"386\":1}}],[\"例如经过了\",{\"1\":{\"362\":1}}],[\"例如参数量为\",{\"1\":{\"324\":1}}],[\"例如clip\",{\"1\":{\"307\":1}}],[\"例如谷歌的bit和vit基于jft\",{\"1\":{\"305\":1}}],[\"例如2017年的那篇工作只在imagenet上实现了11\",{\"1\":{\"305\":1}}],[\"例如virtex基于transformer的语言模型\",{\"1\":{\"305\":1}}],[\"例如openai的gpt\",{\"1\":{\"305\":1}}],[\"例如语音\",{\"1\":{\"269\":1}}],[\"例如在原图上坐标为\",{\"1\":{\"386\":1}}],[\"例如在多头自注意力机制或前馈网络中引入卷积层\",{\"1\":{\"326\":1}}],[\"例如在\",{\"1\":{\"202\":1}}],[\"例如学习率不同会导致准确率差异较大\",{\"1\":{\"179\":1}}],[\"例如法向量\",{\"1\":{\"46\":1}}],[\"例如不同形状的椅子\",{\"1\":{\"29\":1}}],[\"例如\",{\"1\":{\"6\":1,\"7\":3,\"45\":1,\"62\":1,\"65\":1,\"70\":1,\"83\":1,\"98\":1,\"100\":1,\"157\":2,\"159\":1,\"163\":2,\"181\":1,\"201\":1,\"204\":1,\"272\":1,\"300\":1,\"301\":1,\"305\":1,\"314\":1,\"326\":2,\"340\":1,\"346\":1,\"375\":1,\"377\":1,\"385\":1,\"386\":2,\"387\":3,\"425\":1,\"426\":1,\"432\":1,\"443\":1,\"453\":1,\"471\":1,\"474\":1,\"521\":1,\"538\":2,\"539\":1,\"547\":1,\"549\":1,\"562\":1,\"572\":3,\"573\":1,\"588\":2,\"589\":1,\"591\":3,\"614\":1,\"646\":1,\"660\":1,\"684\":2,\"687\":3,\"690\":3,\"703\":1,\"717\":1,\"727\":5,\"728\":1,\"738\":1,\"801\":2,\"804\":3,\"814\":1,\"815\":1,\"818\":1,\"825\":1,\"848\":1,\"866\":1,\"868\":1}}],[\"上就好了\",{\"1\":{\"881\":1}}],[\"上分布\",{\"1\":{\"864\":1}}],[\"上进一步训练\",{\"1\":{\"778\":1}}],[\"上进行训练\",{\"1\":{\"704\":1}}],[\"上进行预训练\",{\"1\":{\"305\":1,\"317\":1}}],[\"上进行语义分割测试\",{\"1\":{\"201\":1}}],[\"上进行线性探测评估\",{\"1\":{\"201\":1}}],[\"上进行\",{\"1\":{\"179\":1}}],[\"上验证了其有效性\",{\"1\":{\"766\":1}}],[\"上时\",{\"1\":{\"758\":1}}],[\"上式等价于\",{\"1\":{\"730\":1}}],[\"上做\",{\"1\":{\"728\":1}}],[\"上做最大池化\",{\"1\":{\"92\":1}}],[\"上线后用户增长迅速\",{\"1\":{\"704\":1}}],[\"上超越未微调的palm\",{\"1\":{\"549\":1}}],[\"上超越了之前的有监督预训练模型\",{\"1\":{\"245\":1}}],[\"上超越了多个\",{\"1\":{\"203\":1}}],[\"上更真实\",{\"1\":{\"538\":1}}],[\"上收集\",{\"1\":{\"537\":1}}],[\"上达到了最先进的性能\",{\"1\":{\"558\":1}}],[\"上达到\",{\"1\":{\"522\":1}}],[\"上表现较差\",{\"1\":{\"522\":1}}],[\"上提升显著\",{\"1\":{\"522\":1}}],[\"上提升8\",{\"1\":{\"506\":1}}],[\"上仍表现欠拟合\",{\"1\":{\"521\":1}}],[\"上爬取高赞\",{\"1\":{\"521\":1}}],[\"上使用多头自注意力操作\",{\"1\":{\"510\":1}}],[\"上使用偏置\",{\"1\":{\"272\":1}}],[\"上述公式简化为\",{\"1\":{\"729\":1}}],[\"上述定义也可推广到多维空间\",{\"1\":{\"728\":1}}],[\"上述例子是\",{\"1\":{\"697\":1}}],[\"上述的全量微调流程问题在于大模型的参数量往往特别大\",{\"1\":{\"490\":1}}],[\"上述即为pointnet++设计中的两个核心挑战\",{\"1\":{\"86\":1}}],[\"上创建\",{\"1\":{\"378\":1}}],[\"上面优化方向很多\",{\"1\":{\"578\":1}}],[\"上面所举例子并没有使用kv\",{\"1\":{\"541\":1}}],[\"上面代码实现中使用的是加权交叉熵损失\",{\"1\":{\"473\":1}}],[\"上面代码实现中使用的是可学习位置嵌入\",{\"1\":{\"320\":1}}],[\"上面的问题本质是因为函数调用顺序错误导致的\",{\"1\":{\"685\":1}}],[\"上面的完美模型包含边长为\",{\"1\":{\"451\":1}}],[\"上面的花卉分类案例相当于使用图像去匹配最合适的文本描述\",{\"1\":{\"303\":1}}],[\"上面已经给出了数据集加载以及vit模型核心代码实现了\",{\"1\":{\"327\":1}}],[\"上图\",{\"1\":{\"587\":1}}],[\"上图中的两句话明显是连续的\",{\"1\":{\"573\":1}}],[\"上图中是每一个patch中各位置的位置编码相似性度量\",{\"1\":{\"320\":1}}],[\"上图是4种不同类型的vlp模型示意图\",{\"1\":{\"282\":1}}],[\"上的联合似然的证据下界\",{\"1\":{\"807\":1}}],[\"上的一元连续分布\",{\"1\":{\"745\":1}}],[\"上的研究大致可以分为以下几个阶段\",{\"1\":{\"704\":1}}],[\"上的生成能力\",{\"1\":{\"522\":1}}],[\"上的问题答案数据集\",{\"1\":{\"515\":1}}],[\"上的\",{\"1\":{\"257\":1,\"278\":1,\"385\":1}}],[\"上的表现较差\",{\"1\":{\"220\":1}}],[\"上下文感知\",{\"1\":{\"705\":1}}],[\"上下文长度\",{\"1\":{\"704\":6}}],[\"上下文长度扩展至\",{\"1\":{\"704\":2}}],[\"上下文长度4096\",{\"1\":{\"227\":1}}],[\"上下文\",{\"1\":{\"614\":3,\"704\":1}}],[\"上下文学习能力是由\",{\"1\":{\"706\":1}}],[\"上下文学习\",{\"1\":{\"532\":1,\"706\":1}}],[\"上下文建模\",{\"1\":{\"531\":1}}],[\"上下文窗口限制性能提升\",{\"1\":{\"530\":1}}],[\"上下文窗口从512扩展到1024\",{\"1\":{\"521\":1}}],[\"上下文编码投影到词空间\",{\"1\":{\"276\":1}}],[\"上下文预测等\",{\"1\":{\"248\":1}}],[\"上下文丰富化\",{\"1\":{\"63\":1}}],[\"上微调\",{\"1\":{\"211\":1}}],[\"上训练速度达380\",{\"1\":{\"548\":1}}],[\"上训练时\",{\"1\":{\"524\":1}}],[\"上训练好的权重\",{\"1\":{\"395\":1}}],[\"上训练\",{\"1\":{\"208\":1,\"209\":1,\"257\":1}}],[\"上均有显著提升\",{\"1\":{\"204\":1}}],[\"上均取得\",{\"1\":{\"202\":1}}],[\"上一句话\",{\"1\":{\"573\":1}}],[\"上一部分介绍了一系列模型指标\",{\"1\":{\"449\":1}}],[\"上一轮迭代的学生网络\",{\"1\":{\"182\":1}}],[\"上一层点集中的点特征重建过程中\",{\"1\":{\"70\":1}}],[\"上取得\",{\"1\":{\"559\":1}}],[\"上取得良好性能\",{\"1\":{\"173\":1}}],[\"上取得最先进性能\",{\"1\":{\"120\":1}}],[\"上可达到\",{\"1\":{\"173\":1}}],[\"上运行\",{\"1\":{\"170\":1,\"774\":1}}],[\"上升\",{\"1\":{\"159\":1}}],[\"上预测得到的概率分布为\",{\"1\":{\"157\":1}}],[\"上预训练的\",{\"1\":{\"131\":1}}],[\"上所有样本索引的集合\",{\"1\":{\"145\":1}}],[\"上轻量微调\",{\"1\":{\"128\":1}}],[\"上略低于\",{\"1\":{\"112\":1}}],[\"上\",{\"1\":{\"112\":1,\"145\":1,\"173\":1,\"179\":1,\"186\":1,\"202\":1,\"538\":1,\"591\":1,\"756\":1,\"821\":1}}],[\"上也具有泛化能力\",{\"1\":{\"82\":1}}],[\"上采样层数\",{\"1\":{\"793\":1}}],[\"上采样\",{\"0\":{\"388\":1},\"1\":{\"100\":2}}],[\"上采样后的点云特征\",{\"1\":{\"76\":1}}],[\"上采样过程中\",{\"1\":{\"70\":1}}],[\"上采样过程\",{\"1\":{\"46\":1}}],[\"上采样至原始点数后记为\",{\"1\":{\"14\":1}}],[\"原因如下\",{\"1\":{\"873\":1}}],[\"原因分析\",{\"1\":{\"112\":2}}],[\"原图边长\",{\"1\":{\"814\":1}}],[\"原图面积之间\",{\"1\":{\"186\":1}}],[\"原像\",{\"1\":{\"727\":1}}],[\"原有代码\",{\"1\":{\"687\":2}}],[\"原序列添加特殊token标记图\",{\"1\":{\"594\":1}}],[\"原文\",{\"1\":{\"537\":1}}],[\"原sota\",{\"1\":{\"522\":2}}],[\"原模型虽大\",{\"1\":{\"495\":1}}],[\"原张量是\",{\"1\":{\"425\":1}}],[\"原张量在\",{\"1\":{\"378\":1}}],[\"原来的标签\",{\"1\":{\"276\":1}}],[\"原本是正样本的\",{\"1\":{\"249\":1}}],[\"原理大致跟rlhf类似\",{\"1\":{\"483\":1}}],[\"原理\",{\"0\":{\"315\":1}}],[\"原理回顾\",{\"1\":{\"112\":1}}],[\"原理说明\",{\"1\":{\"105\":1}}],[\"原则\",{\"1\":{\"63\":1,\"336\":1}}],[\"原始的变分自编码器\",{\"1\":{\"869\":1}}],[\"原始的步长可能是\",{\"1\":{\"426\":1}}],[\"原始论文链接\",{\"1\":{\"843\":1}}],[\"原始论文layernorm在最后\",{\"1\":{\"626\":1}}],[\"原始注意力分数\",{\"1\":{\"591\":1}}],[\"原始bert使用30k的字符级bpe词汇表\",{\"1\":{\"562\":1}}],[\"原始bert使用256的批次大小训练1m步\",{\"1\":{\"562\":1}}],[\"原始bert使用\",{\"1\":{\"562\":1}}],[\"原始bert使用静态掩码\",{\"1\":{\"562\":1,\"564\":1}}],[\"原始bert的做法\",{\"1\":{\"562\":1}}],[\"原始空间中\",{\"1\":{\"459\":1}}],[\"原始形状为\",{\"1\":{\"427\":1}}],[\"原始transformer的norm层在多头注意力和前馈网络之后\",{\"1\":{\"321\":1}}],[\"原始实现\",{\"1\":{\"293\":1}}],[\"原始\",{\"0\":{\"840\":1},\"1\":{\"277\":2,\"538\":1,\"539\":1,\"560\":2,\"561\":1,\"807\":1,\"821\":1}}],[\"原始图像张量\",{\"1\":{\"276\":1}}],[\"原始特征向量\",{\"1\":{\"170\":1}}],[\"原始文本\",{\"1\":{\"157\":1,\"276\":1}}],[\"原始点集合\",{\"1\":{\"114\":1}}],[\"原始点数量\",{\"1\":{\"100\":1}}],[\"原始点对应的特征数据\",{\"1\":{\"100\":1}}],[\"原始点坐标数据\",{\"1\":{\"100\":1}}],[\"原始点坐标\",{\"1\":{\"98\":1}}],[\"原始点云数据\",{\"1\":{\"93\":1}}],[\"原始点云数量\",{\"1\":{\"46\":2}}],[\"原始点特征\",{\"1\":{\"74\":1,\"98\":1}}],[\"原始交互文本\",{\"1\":{\"31\":1}}],[\"具备基本能力的\",{\"1\":{\"717\":1}}],[\"具备对文本\",{\"1\":{\"704\":1}}],[\"具备跨模态交互能力\",{\"1\":{\"235\":1}}],[\"具备极强的感知能力\",{\"1\":{\"205\":1}}],[\"具体代码实现过程如下\",{\"1\":{\"816\":1}}],[\"具体代码实现如下所示\",{\"1\":{\"276\":1}}],[\"具体代码实现如下\",{\"1\":{\"272\":1,\"303\":1,\"817\":1}}],[\"具体如下\",{\"1\":{\"729\":1,\"772\":1}}],[\"具体函数实现\",{\"1\":{\"691\":1}}],[\"具体函数的反向传播\",{\"0\":{\"661\":1}}],[\"具体函数继承该类并实现forward方法\",{\"1\":{\"642\":1}}],[\"具体位置在\",{\"1\":{\"593\":1}}],[\"具体核心代码实现如下\",{\"1\":{\"581\":1}}],[\"具体过程如下图所示\",{\"1\":{\"580\":2}}],[\"具体步骤为\",{\"1\":{\"579\":1}}],[\"具体流程我们可以看下面这幅图\",{\"1\":{\"575\":1}}],[\"具体体现在\",{\"1\":{\"544\":1}}],[\"具体方法是\",{\"1\":{\"781\":1}}],[\"具体方法包括\",{\"1\":{\"534\":1}}],[\"具体方式可以是直接缩放\",{\"1\":{\"317\":1}}],[\"具体任务表现分析\",{\"1\":{\"522\":1}}],[\"具体要考虑解决的问题类型\",{\"1\":{\"501\":1}}],[\"具体来看\",{\"1\":{\"492\":1}}],[\"具体来说就是这个队列可以很大\",{\"1\":{\"246\":1}}],[\"具体来说\",{\"1\":{\"95\":1,\"320\":1,\"485\":1,\"486\":1,\"712\":1,\"770\":1,\"814\":1,\"845\":1}}],[\"具体示例如下所示\",{\"1\":{\"426\":1}}],[\"具体的流程如下图所示\",{\"1\":{\"813\":1}}],[\"具体的\",{\"1\":{\"425\":1}}],[\"具体的实验结果可以参考clip公开的notebook\",{\"1\":{\"301\":1}}],[\"具体可以从以下几个方面理解\",{\"1\":{\"385\":1}}],[\"具体可参考\",{\"1\":{\"247\":1}}],[\"具体为vit\",{\"1\":{\"327\":1}}],[\"具体解释如下\",{\"1\":{\"320\":1}}],[\"具体使用的是\",{\"1\":{\"302\":1}}],[\"具体形式如下\",{\"1\":{\"274\":1}}],[\"具体实现\",{\"1\":{\"274\":1}}],[\"具体包括\",{\"1\":{\"235\":1}}],[\"具体分为三步\",{\"1\":{\"232\":1}}],[\"具体而言\",{\"1\":{\"97\":1,\"765\":1,\"776\":1}}],[\"具体做法是\",{\"1\":{\"868\":1}}],[\"具体做法如下\",{\"1\":{\"815\":1}}],[\"具体做法\",{\"1\":{\"90\":1}}],[\"具体选择多少个中心点以及邻域内的数量由超参数确定\",{\"1\":{\"89\":1}}],[\"具体地如下图所示\",{\"1\":{\"573\":1}}],[\"具体地描述出来\",{\"1\":{\"499\":1}}],[\"具体地\",{\"1\":{\"14\":1,\"773\":1,\"777\":1,\"825\":1,\"872\":1}}],[\"具有任意高的表达能力\",{\"1\":{\"871\":1}}],[\"具有如下优点\",{\"1\":{\"864\":1}}],[\"具有出色的能力\",{\"1\":{\"705\":1}}],[\"具有较强的泛化能力\",{\"1\":{\"327\":1}}],[\"具有较强的实用性与拓展性\",{\"1\":{\"129\":1}}],[\"具有很强的zero\",{\"1\":{\"307\":1}}],[\"具有高度多样性和挑战性\",{\"1\":{\"235\":1}}],[\"具有以下优势\",{\"1\":{\"78\":1}}],[\"具有语义意义\",{\"1\":{\"62\":1}}],[\"等其他方法联系起来\",{\"1\":{\"870\":1}}],[\"等复杂的采样技术\",{\"1\":{\"866\":1}}],[\"等式右边的两项是\",{\"1\":{\"854\":1}}],[\"等不稳定做法\",{\"1\":{\"853\":1}}],[\"等不使用\",{\"1\":{\"186\":1}}],[\"等训练行为\",{\"1\":{\"820\":1}}],[\"等条件生成场景\",{\"1\":{\"816\":1}}],[\"等通过共享\",{\"1\":{\"789\":1}}],[\"等通用数据集\",{\"1\":{\"225\":1}}],[\"等自动编码器结构\",{\"1\":{\"786\":1}}],[\"等概率地可能出现\",{\"1\":{\"773\":1}}],[\"等等\",{\"1\":{\"761\":1,\"843\":1}}],[\"等架构的实现\",{\"1\":{\"717\":1}}],[\"等多个技术领域\",{\"1\":{\"714\":1}}],[\"等多模态架构中的文本生成部分\",{\"1\":{\"295\":1}}],[\"等多模态生成模型\",{\"1\":{\"202\":1}}],[\"等多模态对话基准上达到\",{\"1\":{\"198\":1}}],[\"等项目已经出现并受到关注\",{\"1\":{\"708\":1}}],[\"等基于语音对话的产品也非常受欢迎\",{\"1\":{\"708\":1}}],[\"等基于图像的方法\",{\"1\":{\"112\":1}}],[\"等全面对标\",{\"1\":{\"704\":1}}],[\"等功能\",{\"1\":{\"704\":1}}],[\"等合作研发的语言大模型\",{\"1\":{\"704\":1}}],[\"等技术\",{\"1\":{\"704\":1}}],[\"等先进技术\",{\"1\":{\"704\":1}}],[\"等商业闭源模型\",{\"1\":{\"704\":1}}],[\"等函数节点\",{\"1\":{\"695\":1}}],[\"等运算符自然表达计算\",{\"1\":{\"693\":1}}],[\"等会被\",{\"1\":{\"616\":1}}],[\"等著名悲剧\",{\"1\":{\"614\":1}}],[\"等模型趋势一致\",{\"1\":{\"551\":1}}],[\"等模型将预训练语言模型推向主流\",{\"1\":{\"531\":1}}],[\"等机制\",{\"1\":{\"536\":1}}],[\"等原始网络数据\",{\"1\":{\"521\":1}}],[\"等于上述两个步骤的总和\",{\"1\":{\"872\":1}}],[\"等于正面次数占总次数的比例\",{\"1\":{\"826\":1}}],[\"等于\",{\"1\":{\"492\":1}}],[\"等特性\",{\"1\":{\"395\":1}}],[\"等价操作\",{\"1\":{\"367\":1}}],[\"等价于把解码器的梯度全部传给\",{\"1\":{\"881\":1}}],[\"等价于\",{\"1\":{\"349\":1,\"350\":1,\"355\":1,\"469\":1,\"471\":1,\"690\":1,\"796\":1}}],[\"等价于n个类别的cross\",{\"1\":{\"299\":1}}],[\"等价于基于余弦相似度查找最近代码\",{\"1\":{\"167\":1}}],[\"等操作\",{\"1\":{\"362\":1}}],[\"等元信息\",{\"1\":{\"346\":1}}],[\"等属性丢失\",{\"1\":{\"346\":1}}],[\"等信息\",{\"1\":{\"274\":1}}],[\"等生成类任务\",{\"1\":{\"269\":1}}],[\"等强化学习算法\",{\"1\":{\"232\":1}}],[\"等任务上超越chinchilla\",{\"1\":{\"547\":1}}],[\"等任务上表现退化\",{\"1\":{\"538\":1}}],[\"等任务上的零样本表现\",{\"1\":{\"537\":1}}],[\"等任务上的局限性\",{\"1\":{\"527\":1}}],[\"等任务中也得到了广泛实践\",{\"1\":{\"536\":1}}],[\"等任务\",{\"1\":{\"277\":1}}],[\"等任务表现优异\",{\"1\":{\"228\":1}}],[\"等任务专用数据\",{\"1\":{\"225\":1}}],[\"等大规模ocr数据\",{\"1\":{\"225\":1}}],[\"等新兴模型进一步推动多模态技术的发展\",{\"1\":{\"218\":1}}],[\"等方法一样\",{\"1\":{\"802\":1}}],[\"等方法\",{\"1\":{\"203\":1}}],[\"等主流模型\",{\"1\":{\"201\":1}}],[\"等人在\",{\"1\":{\"868\":1}}],[\"等人在2014年提出的一种生成模型\",{\"1\":{\"840\":1}}],[\"等人用生成对抗网络提升了图像质量和泛化能力\",{\"1\":{\"806\":1}}],[\"等人用变分自编码器\",{\"1\":{\"806\":1}}],[\"等人提出的\",{\"1\":{\"491\":1}}],[\"等人\",{\"1\":{\"176\":1,\"811\":1}}],[\"等指标更关注重合度\",{\"1\":{\"82\":1}}],[\"等\",{\"1\":{\"62\":1,\"63\":1,\"67\":2,\"78\":1,\"120\":1,\"163\":1,\"198\":1,\"201\":1,\"219\":1,\"232\":1,\"239\":1,\"274\":1,\"326\":1,\"364\":1,\"395\":5,\"539\":1,\"547\":1,\"560\":1,\"561\":1,\"580\":1,\"700\":2,\"703\":2,\"704\":1}}],[\"基准上\",{\"1\":{\"538\":1}}],[\"基准任务转换为指令格式\",{\"1\":{\"536\":1}}],[\"基本流程\",{\"0\":{\"717\":1}}],[\"基本语法\",{\"1\":{\"431\":1}}],[\"基本用法如下\",{\"1\":{\"374\":1}}],[\"基本用法\",{\"1\":{\"332\":1}}],[\"基函数叠加\",{\"1\":{\"385\":1}}],[\"基函数\",{\"1\":{\"385\":1}}],[\"基类\",{\"1\":{\"274\":1}}],[\"基座是\",{\"1\":{\"199\":1}}],[\"基础上添加任务层\",{\"1\":{\"767\":1}}],[\"基础模型\",{\"1\":{\"704\":1}}],[\"基础词汇仅需256个字节\",{\"1\":{\"521\":1}}],[\"基础\",{\"1\":{\"274\":1}}],[\"基础增强\",{\"1\":{\"186\":1}}],[\"基础值遵循线性缩放规则\",{\"1\":{\"179\":1}}],[\"基础点云可视化\",{\"1\":{\"83\":1}}],[\"基础数据来源\",{\"0\":{\"62\":1}}],[\"基线\",{\"1\":{\"75\":1}}],[\"基于离散\",{\"1\":{\"886\":1}}],[\"基于已经训练好的vq\",{\"1\":{\"886\":1}}],[\"基于这种运算\",{\"1\":{\"881\":1}}],[\"基于这一技术\",{\"1\":{\"881\":1}}],[\"基于能量模型的方法和优化预训练跨模态模型输入的方式也出现\",{\"1\":{\"806\":1}}],[\"基于变分自编码器视角\",{\"1\":{\"766\":1}}],[\"基于小型验证集设计满足基本要求\",{\"1\":{\"717\":1}}],[\"基于静态的数据集训练\",{\"1\":{\"709\":1}}],[\"基于上下文编码\",{\"1\":{\"616\":1}}],[\"基于上述背景\",{\"1\":{\"491\":1}}],[\"基于可学习的嵌入\",{\"0\":{\"588\":1}}],[\"基于可学习码本\",{\"1\":{\"165\":1}}],[\"基于正弦和余弦函数得到的位置编码可以保证唯一性\",{\"1\":{\"587\":1}}],[\"基于transformer的优化设计\",{\"1\":{\"548\":1}}],[\"基于wikipedia引用分类\",{\"1\":{\"548\":1}}],[\"基于人类反馈的模型对齐\",{\"1\":{\"536\":1}}],[\"基于人类反馈的强化学习微调rlhf\",{\"1\":{\"483\":1}}],[\"基于人类反馈的强化学习\",{\"1\":{\"232\":1}}],[\"基于大模型的内在低秩特性\",{\"1\":{\"495\":1}}],[\"基于prompt\",{\"1\":{\"486\":1}}],[\"基于ai反馈的强化学习微调rlaif\",{\"1\":{\"483\":1}}],[\"基于标准交叉熵损失\",{\"1\":{\"470\":1}}],[\"基于标准vit架构的60亿参数视觉编码器\",{\"1\":{\"196\":1}}],[\"基于交叉熵损失进行扩展\",{\"1\":{\"470\":1}}],[\"基于步长的逻辑转置\",{\"1\":{\"426\":1}}],[\"基于自回归或语言掩码的预训练方法已经相对成熟\",{\"1\":{\"305\":1}}],[\"基于internvit\",{\"1\":{\"216\":1}}],[\"基于图像的文本生成损失\",{\"1\":{\"198\":1}}],[\"基于图卷积或注意力机制的模型更能捕捉这种非刚性变化\",{\"1\":{\"112\":1}}],[\"基于多语言llama\",{\"1\":{\"196\":1,\"197\":1}}],[\"基于知识蒸馏的自监督学习\",{\"0\":{\"178\":1}}],[\"基于以上发现\",{\"1\":{\"173\":1}}],[\"基于以下前提\",{\"1\":{\"90\":1}}],[\"基于\",{\"1\":{\"73\":1,\"142\":1,\"161\":1,\"170\":1,\"222\":1,\"227\":1,\"234\":1,\"235\":1,\"307\":1,\"521\":1,\"560\":1,\"561\":1,\"788\":1,\"792\":1}}],[\"基于相机参数\",{\"1\":{\"52\":1}}],[\"基于几何映射的方法\",{\"1\":{\"51\":1}}],[\"基于语言引导的3d可供性分割\",{\"1\":{\"22\":1}}],[\"基于微调的mllm\",{\"1\":{\"6\":1}}],[\"简化了模型的实现细节\",{\"1\":{\"848\":1}}],[\"简化为单点分布\",{\"1\":{\"773\":1}}],[\"简化部署流程\",{\"1\":{\"715\":1}}],[\"简化\",{\"1\":{\"591\":1}}],[\"简化和优化bert的训练过程\",{\"1\":{\"568\":1}}],[\"简化版\",{\"1\":{\"468\":1,\"691\":1}}],[\"简化多维索引\",{\"1\":{\"355\":1}}],[\"简化跨模态融合\",{\"1\":{\"149\":1}}],[\"简而言之\",{\"1\":{\"342\":1}}],[\"简单说\",{\"1\":{\"834\":1}}],[\"简单节点定义\",{\"1\":{\"696\":1}}],[\"简单总结下\",{\"1\":{\"587\":1}}],[\"简单微调后\",{\"1\":{\"549\":1}}],[\"简单样本抑制越强\",{\"1\":{\"470\":1}}],[\"简单样本主导梯度\",{\"1\":{\"470\":1}}],[\"简单样本的梯度贡献淹没难样本的梯度\",{\"1\":{\"470\":1}}],[\"简单例子\",{\"1\":{\"398\":1}}],[\"简单来说\",{\"1\":{\"301\":1,\"421\":1,\"572\":1}}],[\"简单理解\",{\"1\":{\"272\":1,\"728\":1}}],[\"简洁\",{\"1\":{\"114\":1}}],[\"简洁表达\",{\"1\":{\"63\":1}}],[\"简析pointnet网络模型及其背后原理\",{\"1\":{\"102\":1}}],[\"简析pointnet\",{\"0\":{\"102\":1}}],[\"简析pointnet++\",{\"0\":{\"85\":1},\"1\":{\"85\":1}}],[\"简称\",{\"1\":{\"60\":1,\"492\":1,\"495\":1,\"750\":1,\"870\":1}}],[\"简介\",{\"0\":{\"6\":1,\"49\":1,\"189\":1,\"216\":1,\"507\":1,\"520\":1,\"527\":1,\"535\":1,\"547\":1,\"766\":1}}],[\"自回归生成\",{\"1\":{\"820\":1}}],[\"自回归建模\",{\"1\":{\"820\":1}}],[\"自回归模型\",{\"1\":{\"814\":1,\"816\":1,\"847\":1}}],[\"自回归语言建模任务\",{\"1\":{\"312\":1}}],[\"自回归语言建模\",{\"0\":{\"295\":1},\"1\":{\"295\":1}}],[\"自研的\",{\"1\":{\"792\":1}}],[\"自纠错机制\",{\"1\":{\"704\":1}}],[\"自发布以来就引发了人工智能社区的兴奋\",{\"1\":{\"704\":1}}],[\"自己写答案\",{\"1\":{\"616\":1}}],[\"自己和自己的值其实是占大头的\",{\"1\":{\"575\":1}}],[\"自己的部分\",{\"1\":{\"278\":1}}],[\"自一致性技术\",{\"0\":{\"502\":1}}],[\"自适应基函数\",{\"1\":{\"385\":1}}],[\"自适应生成的非线性函数空间\",{\"1\":{\"385\":1}}],[\"自适应融合模块\",{\"0\":{\"71\":1,\"75\":1},\"1\":{\"70\":1}}],[\"自定义工具调用\",{\"1\":{\"704\":1}}],[\"自定义指令与记忆功能\",{\"1\":{\"704\":1}}],[\"自定义打印格式\",{\"1\":{\"689\":1}}],[\"自定义的批量数据处理函数\",{\"1\":{\"316\":1}}],[\"自定义数据集\",{\"1\":{\"316\":1}}],[\"自定义一个mydataset类来封装我们加载得到的数据集\",{\"1\":{\"316\":1}}],[\"自定义模型的行为\",{\"1\":{\"273\":1}}],[\"自谷歌提出\",{\"1\":{\"297\":1}}],[\"自身就能学到基本的跨模态检索能力\",{\"1\":{\"277\":1}}],[\"自然对数\",{\"1\":{\"828\":1}}],[\"自然代码表达\",{\"1\":{\"692\":1}}],[\"自然演示的机会\",{\"1\":{\"521\":1}}],[\"自然语言建模的场景\",{\"1\":{\"577\":1}}],[\"自然语言推理\",{\"1\":{\"575\":1}}],[\"自然语言推断nli\",{\"1\":{\"507\":1}}],[\"自然语言处理\",{\"1\":{\"527\":1}}],[\"自然语言理解包含了广泛的多样性任务\",{\"1\":{\"506\":1}}],[\"自然语言指令可作为隐式任务描述\",{\"1\":{\"521\":1}}],[\"自然语言指令\",{\"1\":{\"40\":1}}],[\"自然指数\",{\"1\":{\"470\":1}}],[\"自然会存在一些重复性操作\",{\"1\":{\"274\":1}}],[\"自家的数据集上同样效果良好\",{\"1\":{\"247\":1}}],[\"自动去掉\",{\"1\":{\"820\":1}}],[\"自动执行\",{\"1\":{\"799\":1}}],[\"自动执行dot文件转换并显示图像\",{\"1\":{\"696\":1}}],[\"自动执行反向传播\",{\"1\":{\"665\":1}}],[\"自动反向传播与框架基础能力提升\",{\"1\":{\"679\":1}}],[\"自动反向传播与计算图进阶\",{\"0\":{\"679\":1}}],[\"自动反向传播的实现\",{\"0\":{\"665\":1}}],[\"自动设置梯度\",{\"0\":{\"672\":1}}],[\"自动跳过\",{\"1\":{\"616\":1}}],[\"自动广播到\",{\"1\":{\"591\":1}}],[\"自动打分\",{\"1\":{\"538\":1}}],[\"自动安装\",{\"1\":{\"438\":1}}],[\"自动计算权重\",{\"1\":{\"399\":1}}],[\"自动按维度扩展\",{\"1\":{\"364\":1}}],[\"自动生成ai使用指南\",{\"1\":{\"550\":1}}],[\"自动生成\",{\"1\":{\"235\":1}}],[\"自动将实例分组\",{\"1\":{\"175\":1}}],[\"自训练与知识蒸馏本质上是相关的\",{\"1\":{\"176\":1}}],[\"自训练\",{\"1\":{\"176\":1}}],[\"自训练方法\",{\"1\":{\"149\":1}}],[\"自蒸馏\",{\"1\":{\"175\":1}}],[\"自蒸馏也取得了不错效果\",{\"1\":{\"123\":1}}],[\"自监督视觉预训练方法可以大致分为三类\",{\"1\":{\"783\":1}}],[\"自监督视觉预训练\",{\"0\":{\"783\":1}}],[\"自监督预训练成为利用大规模无标注图像数据的关键方法\",{\"1\":{\"766\":1}}],[\"自监督方法的优势在于不再需要标注数据\",{\"1\":{\"305\":1}}],[\"自监督的方式进行学习\",{\"1\":{\"247\":1}}],[\"自监督目标函数\",{\"1\":{\"176\":1}}],[\"自监督\",{\"1\":{\"173\":2}}],[\"自监督学习其实是一种特殊形式的无监督学习\",{\"1\":{\"248\":1}}],[\"自监督学习的方法可以从两个方面来进行优化或创新\",{\"1\":{\"248\":1}}],[\"自监督学习的常见评估方式有两类\",{\"1\":{\"179\":1}}],[\"自监督学习主要经历了以下几类方法\",{\"1\":{\"175\":1}}],[\"自监督学习是否能为\",{\"1\":{\"173\":1}}],[\"自监督学习\",{\"1\":{\"173\":1}}],[\"自信看源码进行学习\",{\"1\":{\"145\":1}}],[\"自注意力图的分析\",{\"0\":{\"781\":1}}],[\"自注意力子层\",{\"1\":{\"627\":2,\"630\":2}}],[\"自注意力运算\",{\"1\":{\"312\":1,\"544\":1}}],[\"自注意力和交叉注意力流程统一化\",{\"1\":{\"312\":1}}],[\"自注意力掩码策略\",{\"1\":{\"310\":1,\"311\":1,\"312\":1}}],[\"自注意力捕捉文本内部的依赖\",{\"1\":{\"291\":1}}],[\"自注意力层通过\",{\"1\":{\"179\":1}}],[\"自注意力机制是\",{\"1\":{\"622\":1}}],[\"自注意力机制能够捕捉图像中任意两个\",{\"1\":{\"319\":1}}],[\"自注意力机制\",{\"1\":{\"76\":1,\"404\":1}}],[\"自注意力\",{\"1\":{\"59\":1,\"291\":1,\"312\":2}}],[\"自注意力完成内部信息建模\",{\"1\":{\"59\":1}}],[\"消失了\",{\"1\":{\"868\":1}}],[\"消融研究\",{\"1\":{\"516\":1}}],[\"消融实验\",{\"0\":{\"180\":1,\"237\":1,\"780\":1}}],[\"消融项分析\",{\"1\":{\"24\":1}}],[\"消除量化误差\",{\"1\":{\"387\":1}}],[\"消除尺度差异\",{\"1\":{\"68\":1}}],[\"消除模态差异\",{\"1\":{\"59\":1}}],[\"保存模型\",{\"1\":{\"885\":1,\"886\":1}}],[\"保存生成图像\",{\"1\":{\"848\":1}}],[\"保存配置参数\",{\"1\":{\"814\":1}}],[\"保存超参数\",{\"1\":{\"793\":1}}],[\"保存指数\",{\"1\":{\"690\":1}}],[\"保存最优模型\",{\"1\":{\"581\":1}}],[\"保存字典到文件\",{\"1\":{\"578\":1}}],[\"保存每个注意力头的热力图\",{\"1\":{\"463\":1}}],[\"保存注意力头的数量\",{\"1\":{\"322\":1}}],[\"保存嵌入维度\",{\"1\":{\"319\":1,\"320\":1,\"323\":1}}],[\"保存分类任务的类别数\",{\"1\":{\"319\":1,\"320\":1,\"323\":1}}],[\"保存该层输出\",{\"1\":{\"277\":1}}],[\"保存数据集\",{\"1\":{\"274\":1}}],[\"保存是否使用绝对位置编码和相对位置编码的标志\",{\"1\":{\"272\":1}}],[\"保存\",{\"1\":{\"272\":1,\"274\":1,\"804\":1,\"814\":1}}],[\"保存码本的维度和\",{\"1\":{\"170\":1}}],[\"保障了模型的通用性与灵活性\",{\"1\":{\"205\":1}}],[\"保证整个\",{\"1\":{\"752\":1}}],[\"保证运算按预期执行\",{\"1\":{\"690\":1}}],[\"保证数量一致\",{\"1\":{\"579\":1}}],[\"保证训练的开始此旁路矩阵依然是\",{\"1\":{\"492\":1}}],[\"保证训练集和验证集的数据处理方式一致\",{\"1\":{\"317\":1}}],[\"保证切分后各类比例与原始数据一致\",{\"1\":{\"398\":1}}],[\"保证长度\",{\"1\":{\"393\":1}}],[\"保证绝对值之和\",{\"1\":{\"393\":1}}],[\"保证顺序一致\",{\"1\":{\"316\":1}}],[\"保证随机结果可复现\",{\"1\":{\"316\":1}}],[\"保证\",{\"1\":{\"277\":1}}],[\"保证验证指标真实可靠\",{\"1\":{\"274\":1}}],[\"保证输入是\",{\"1\":{\"186\":1}}],[\"保证每个\",{\"1\":{\"169\":1}}],[\"保证变换是刚性的\",{\"1\":{\"107\":1}}],[\"保留中心像素\",{\"1\":{\"848\":1}}],[\"保留中间结果\",{\"1\":{\"688\":1}}],[\"保留卷积中心\",{\"1\":{\"846\":1}}],[\"保留的是原始像素数据\",{\"1\":{\"769\":1}}],[\"保留反向传播所需的计算图连接\",{\"1\":{\"688\":1}}],[\"保留英文\",{\"1\":{\"548\":1}}],[\"保留接口以备后续扩展\",{\"1\":{\"469\":1}}],[\"保留接口以备扩展\",{\"1\":{\"468\":1,\"470\":1}}],[\"保留向量方向\",{\"1\":{\"393\":1}}],[\"保留向量的方向信息\",{\"1\":{\"392\":1}}],[\"保留浮点型的\",{\"1\":{\"387\":1}}],[\"保留\",{\"1\":{\"367\":1}}],[\"保留维度\",{\"1\":{\"364\":1}}],[\"保留剩余维度\",{\"1\":{\"355\":1}}],[\"保留原函数元信息\",{\"0\":{\"346\":1}}],[\"保留原始几何信息\",{\"1\":{\"114\":1}}],[\"保留和text\",{\"1\":{\"310\":2}}],[\"保留梯度\",{\"1\":{\"170\":1}}],[\"保留旧的中心\",{\"1\":{\"170\":1}}],[\"保留为原始\",{\"1\":{\"163\":1}}],[\"保留下来\",{\"1\":{\"76\":2}}],[\"保留跨模态共享的显著特征\",{\"1\":{\"59\":1}}],[\"保持自回归结构\",{\"1\":{\"848\":1}}],[\"保持总损失的数值\",{\"1\":{\"815\":1}}],[\"保持对称性\",{\"1\":{\"801\":1}}],[\"保持可导\",{\"1\":{\"796\":1}}],[\"保持原意清晰\",{\"1\":{\"752\":1}}],[\"保持原样不动的形式进行处理\",{\"1\":{\"579\":1}}],[\"保持原样\",{\"1\":{\"163\":1}}],[\"保持内容的时效性\",{\"1\":{\"709\":1}}],[\"保持模型关注短距离精细信息\",{\"1\":{\"591\":1}}],[\"保持偏置和层归一化可训练\",{\"1\":{\"495\":1}}],[\"保持预训练模型的原始参数\",{\"1\":{\"490\":1}}],[\"保持高损失权重\",{\"1\":{\"470\":1}}],[\"保持冻结\",{\"1\":{\"235\":1}}],[\"保持视觉编码器和语言模型参数冻结\",{\"1\":{\"234\":1}}],[\"保持\",{\"1\":{\"143\":1,\"820\":1}}],[\"保持不变\",{\"1\":{\"76\":1,\"560\":1,\"562\":1,\"590\":1}}],[\"保持评估完整性\",{\"1\":{\"66\":1}}],[\"保持一致性是因为我们需要字典中的特征尽可能使用同一个或者相近的编码器进行表征\",{\"1\":{\"246\":1}}],[\"保持一致\",{\"1\":{\"20\":1,\"161\":1,\"272\":1}}],[\"筛选测试\",{\"1\":{\"537\":1}}],[\"筛选高质量图像\",{\"1\":{\"198\":1}}],[\"筛选出的图文对与人工标注数据结合\",{\"1\":{\"128\":1}}],[\"筛选关键信息\",{\"1\":{\"59\":1}}],[\"筛选相关的几何特征\",{\"1\":{\"32\":1}}],[\"映射成潜在属性\",{\"1\":{\"866\":1}}],[\"映射至\",{\"1\":{\"820\":1}}],[\"映射回原图像通道数\",{\"1\":{\"793\":1}}],[\"映射关系的反向求解\",{\"1\":{\"759\":1}}],[\"映射为模型所需的潜在因子空间\",{\"1\":{\"866\":1}}],[\"映射为一个\",{\"1\":{\"804\":2}}],[\"映射为离散\",{\"1\":{\"770\":1}}],[\"映射为实数\",{\"1\":{\"727\":1}}],[\"映射为\",{\"1\":{\"727\":1}}],[\"映射为4\",{\"1\":{\"59\":2}}],[\"映射\",{\"1\":{\"386\":1}}],[\"映射到图像\",{\"1\":{\"871\":1}}],[\"映射到公共\",{\"1\":{\"822\":3}}],[\"映射到实数\",{\"1\":{\"727\":1}}],[\"映射到长距离桶区间\",{\"1\":{\"591\":1}}],[\"映射到桶索引\",{\"1\":{\"591\":1}}],[\"映射到桶\",{\"1\":{\"591\":2}}],[\"映射到特征图上之后是一个大小为\",{\"1\":{\"386\":1}}],[\"映射到特征图上\",{\"1\":{\"386\":1}}],[\"映射到分类空间中去\",{\"1\":{\"323\":1}}],[\"映射到\",{\"1\":{\"42\":1,\"277\":1,\"467\":1,\"591\":1,\"802\":2,\"821\":1,\"867\":1}}],[\"根据阈值计算\",{\"1\":{\"818\":1}}],[\"根据文本生成图像\",{\"1\":{\"815\":1}}],[\"根据文本和图像\",{\"1\":{\"807\":1}}],[\"根据文字搜索图片\",{\"1\":{\"303\":1,\"304\":1}}],[\"根据面积和长宽比计算遮挡块的高度和宽度\",{\"1\":{\"801\":1}}],[\"根据遮挡图像恢复视觉令牌\",{\"1\":{\"773\":1}}],[\"根据输入的视觉令牌重建原始图像\",{\"1\":{\"773\":1}}],[\"根据输入图像的长宽比和分辨率\",{\"1\":{\"215\":1}}],[\"根据视觉\",{\"1\":{\"770\":1}}],[\"根据视觉词汇表将图像像素\",{\"1\":{\"770\":1}}],[\"根据观测数据对某一感兴趣的未知量的分布进行更新的过程\",{\"1\":{\"758\":1}}],[\"根据观察数据更新置信度的方法\",{\"1\":{\"758\":1}}],[\"根据条件概率的定义\",{\"1\":{\"731\":1,\"732\":1}}],[\"根据这个定义\",{\"1\":{\"730\":1}}],[\"根据导数公式\",{\"1\":{\"690\":1,\"692\":1}}],[\"根据decoder的隐状态输出一个词\",{\"1\":{\"624\":1}}],[\"根据编码器的输出生成目标序列\",{\"1\":{\"622\":1}}],[\"根据你的理解\",{\"1\":{\"616\":1}}],[\"根据索引矩阵\",{\"1\":{\"581\":1}}],[\"根据索引获取数据集中的图像和对应的标签\",{\"1\":{\"316\":1}}],[\"根据上下文\",{\"1\":{\"572\":1}}],[\"根据上述计算得到的和其相似度最高的分类文本索引\",{\"1\":{\"302\":1}}],[\"根据所在gptblock层级\",{\"1\":{\"544\":1}}],[\"根据频次表构建最终的词汇表\",{\"1\":{\"476\":1}}],[\"根据n轮迭代合并后的vocab来构建最终的频次表\",{\"1\":{\"476\":1}}],[\"根据特定的分割任务的需求和特点\",{\"1\":{\"474\":1}}],[\"根据预测的\",{\"1\":{\"616\":1}}],[\"根据预测误差对预测结果进行排序\",{\"1\":{\"472\":1}}],[\"根据预测值从灰色\",{\"1\":{\"83\":1}}],[\"根据正负样本比例调整\",{\"1\":{\"470\":1}}],[\"根据公式\",{\"1\":{\"427\":1}}],[\"根据相关性\",{\"1\":{\"412\":1}}],[\"根据通用近似定理\",{\"1\":{\"385\":1}}],[\"根据图像特征\",{\"1\":{\"312\":1}}],[\"根据imagenet数据集上的zero\",{\"1\":{\"305\":1}}],[\"根据任务的分类需求\",{\"1\":{\"300\":1}}],[\"根据训练\",{\"1\":{\"278\":1}}],[\"根据模态类型选择不同\",{\"1\":{\"272\":1}}],[\"根据\",{\"1\":{\"163\":1,\"438\":1,\"473\":1,\"869\":1}}],[\"根据注意力机制加权求和\",{\"1\":{\"115\":1}}],[\"根据距离类别\",{\"1\":{\"591\":1}}],[\"根据距离反比加权\",{\"1\":{\"100\":1}}],[\"根据距离分配权重\",{\"1\":{\"100\":1}}],[\"根据样本索引取出样本数据\",{\"1\":{\"68\":1}}],[\"根据自然语言问题找出与之相关的功能区域\",{\"1\":{\"62\":1}}],[\"根据交互主体框\",{\"1\":{\"59\":1}}],[\"根据目标物体框\",{\"1\":{\"59\":1}}],[\"一直以来\",{\"1\":{\"847\":1}}],[\"一样引导生成内容\",{\"1\":{\"817\":1}}],[\"一样的人工智能\",{\"1\":{\"708\":1}}],[\"一边是完整图像\",{\"1\":{\"802\":1}}],[\"一边喂模型的是带遮挡的图像\",{\"1\":{\"802\":1}}],[\"一张输入图像最终被编码为一个\",{\"1\":{\"885\":1}}],[\"一张用于传给视觉\",{\"1\":{\"802\":1}}],[\"一张用于喂给\",{\"1\":{\"802\":1}}],[\"一张图对应一条生成的\",{\"1\":{\"128\":1}}],[\"一张图片对应多张同物体但形状不同的点云图片\",{\"1\":{\"58\":1}}],[\"一共有\",{\"1\":{\"761\":1}}],[\"一共合并merges个高频字符对后\",{\"1\":{\"476\":2}}],[\"一定距离的\",{\"1\":{\"756\":1}}],[\"一定会发生\",{\"1\":{\"728\":1}}],[\"一方面是因为其数学处理非常方便\",{\"1\":{\"750\":1}}],[\"一词既可以指\",{\"1\":{\"728\":1}}],[\"一文详尽之scaling\",{\"1\":{\"718\":1}}],[\"一文的建议\",{\"1\":{\"528\":1}}],[\"一系列推理加速技术\",{\"1\":{\"704\":1}}],[\"一些常用变量的引用\",{\"1\":{\"817\":1}}],[\"一些常见的概率分布\",{\"0\":{\"735\":1}}],[\"一些\",{\"1\":{\"705\":1}}],[\"一些任务\",{\"1\":{\"529\":1}}],[\"一些损失函数具有额外的超参数\",{\"1\":{\"474\":1}}],[\"一步步引导llm得出复杂问题的结果\",{\"1\":{\"503\":1}}],[\"一步步重建回原始点数量\",{\"1\":{\"70\":1}}],[\"一是完整的ltm的例子\",{\"1\":{\"503\":1}}],[\"一次性\",{\"1\":{\"562\":1}}],[\"一次性计算\",{\"1\":{\"272\":1}}],[\"一次训练的成本就在上千亿美元\",{\"1\":{\"491\":1}}],[\"一条是第一个\",{\"1\":{\"684\":1}}],[\"一条是只对部分的参数进行训练\",{\"1\":{\"483\":1}}],[\"一条是对全量的参数\",{\"1\":{\"483\":1}}],[\"一起训练\",{\"1\":{\"807\":1}}],[\"一起变大或一起变小\",{\"1\":{\"455\":1}}],[\"一起送入\",{\"1\":{\"186\":1,\"313\":1}}],[\"一起送入mini\",{\"1\":{\"91\":1}}],[\"一幅图像\",{\"1\":{\"390\":1}}],[\"一维卷积进行线性变换和升维\",{\"1\":{\"544\":1}}],[\"一维的存储空间\",{\"1\":{\"421\":1}}],[\"一维数组\",{\"1\":{\"399\":1,\"403\":1}}],[\"一维\",{\"1\":{\"377\":1}}],[\"一维张量\",{\"1\":{\"373\":1,\"377\":1}}],[\"一般指通过不断发现\",{\"1\":{\"717\":1}}],[\"一般使用诸如\",{\"1\":{\"717\":1}}],[\"一般应先设定最小化目标\",{\"1\":{\"717\":1}}],[\"一般从2开始调优\",{\"1\":{\"470\":1}}],[\"一般\",{\"1\":{\"307\":2}}],[\"一般是\",{\"1\":{\"276\":1,\"814\":1}}],[\"一般模型训练都会加载多个来源不同的开源或私有数据集\",{\"1\":{\"274\":1}}],[\"一般来说\",{\"1\":{\"248\":1,\"717\":1}}],[\"一会详细讲\",{\"1\":{\"244\":1}}],[\"一句话说\",{\"1\":{\"242\":1}}],[\"一句话总结\",{\"1\":{\"112\":1,\"591\":1}}],[\"一种用于离散变量的采样技术\",{\"1\":{\"821\":1}}],[\"一种方法是在自注意力运算中将这些\",{\"1\":{\"809\":1}}],[\"一种基于图像\",{\"1\":{\"790\":1}}],[\"一种更具鲁棒性的分布是\",{\"1\":{\"748\":1}}],[\"一种构造这类分布的方法是设定\",{\"1\":{\"747\":1}}],[\"一种假设是\",{\"1\":{\"516\":1}}],[\"一种平均值\",{\"1\":{\"448\":1}}],[\"一种思路是在转换之前\",{\"1\":{\"320\":1}}],[\"一种朴素的想法就是把一个个像素点拉平\",{\"1\":{\"318\":1}}],[\"一种比较好理解的方式\",{\"1\":{\"309\":1}}],[\"一种是平移不变形\",{\"1\":{\"314\":1}}],[\"一种是局部性\",{\"1\":{\"314\":1}}],[\"一种是常用的cnn架构resnet\",{\"1\":{\"299\":1}}],[\"一种是single\",{\"1\":{\"283\":1}}],[\"一种是单独使用\",{\"1\":{\"199\":1}}],[\"一种无标签的\",{\"1\":{\"175\":1}}],[\"一阶统计量\",{\"1\":{\"178\":1}}],[\"一类使用多模态\",{\"1\":{\"150\":1}}],[\"一\",{\"0\":{\"405\":1,\"431\":1,\"633\":1},\"1\":{\"112\":1,\"536\":1,\"841\":1}}],[\"一致的表示空间\",{\"1\":{\"590\":1}}],[\"一致的表征对齐\",{\"1\":{\"189\":1}}],[\"一致性\",{\"1\":{\"249\":1}}],[\"一致\",{\"1\":{\"98\":1,\"227\":1}}],[\"一组新的关键点位置\",{\"1\":{\"96\":1}}],[\"一组点云被处理和抽象\",{\"1\":{\"88\":1}}],[\"一个嵌入向量\",{\"1\":{\"885\":1}}],[\"一个随机生成大图像的问题\",{\"1\":{\"878\":1}}],[\"一个比较合适的输出分布是\",{\"1\":{\"873\":1}}],[\"一个看起来像正则化参数的东西\",{\"1\":{\"873\":1}}],[\"一个直接的近似方法是采样多个\",{\"1\":{\"866\":1}}],[\"一个合理的\",{\"1\":{\"866\":1}}],[\"一个图像被不断地进模型\",{\"1\":{\"847\":1}}],[\"一个又方便采样\",{\"1\":{\"847\":1}}],[\"一个函数\",{\"1\":{\"839\":1}}],[\"一个事件的发生给我们带来多少\",{\"1\":{\"828\":1}}],[\"一个事件总体概率\",{\"1\":{\"731\":1}}],[\"一个人检测阳性的总体概率是多少\",{\"1\":{\"731\":1}}],[\"一个人检测为阳性的总体概率是多少\",{\"1\":{\"731\":1}}],[\"一个把\",{\"1\":{\"727\":1}}],[\"一个相对距离桶的偏置\",{\"1\":{\"591\":1}}],[\"一个头的所有偏置\",{\"1\":{\"591\":1}}],[\"一个头关注长距离\",{\"1\":{\"591\":1}}],[\"一个周期能够包含更多的位置信息\",{\"1\":{\"587\":1}}],[\"一个具有1750亿参数的自回归语言模型\",{\"1\":{\"526\":1}}],[\"一个问题\",{\"1\":{\"512\":1}}],[\"一个问题可以作用于多个物体类别\",{\"1\":{\"65\":1}}],[\"一个例子帮助理解\",{\"1\":{\"455\":1}}],[\"一个或多个数组\",{\"1\":{\"398\":1}}],[\"一个简单的技巧是在你的prompt后面\",{\"1\":{\"500\":1}}],[\"一个简单的例子如下所示\",{\"1\":{\"389\":1}}],[\"一个简单的线性层\",{\"1\":{\"234\":1}}],[\"一个布尔型张量\",{\"1\":{\"368\":1}}],[\"一个可迭代对象\",{\"1\":{\"358\":1}}],[\"一个装饰器\",{\"1\":{\"349\":1}}],[\"一个装饰器的实现\",{\"1\":{\"341\":1}}],[\"一个block之后维度依然和输入相同\",{\"1\":{\"321\":1}}],[\"一个改进的想法就是把一张图片分成nxn个patch\",{\"1\":{\"318\":1}}],[\"一个批次的数据\",{\"1\":{\"316\":1}}],[\"一个批次图像经过增强后\",{\"1\":{\"186\":1}}],[\"一个文件夹对应一个类别\",{\"1\":{\"316\":1}}],[\"一个的轻量q\",{\"1\":{\"307\":1}}],[\"一个视觉模型和一个文本模型\",{\"1\":{\"300\":1}}],[\"一个\",{\"1\":{\"260\":1,\"336\":1,\"374\":1,\"575\":1}}],[\"一个one\",{\"1\":{\"248\":1}}],[\"一个很大的优势在于\",{\"1\":{\"245\":1}}],[\"一个是该\",{\"1\":{\"614\":1}}],[\"一个是叫灾难性遗忘\",{\"1\":{\"483\":1}}],[\"一个是训练的成本会比较高\",{\"1\":{\"483\":1}}],[\"一个是image\",{\"1\":{\"285\":1}}],[\"一个是保证字典内特征一致性\",{\"1\":{\"249\":1}}],[\"一个是构建很大的字典\",{\"1\":{\"249\":1}}],[\"一个是正常样本\",{\"1\":{\"248\":1}}],[\"一个是e12\",{\"1\":{\"246\":1}}],[\"一个是e11\",{\"1\":{\"246\":1}}],[\"一个是\",{\"1\":{\"243\":2}}],[\"一个最经典的代理任务就是\",{\"1\":{\"243\":1}}],[\"一个封装类\",{\"1\":{\"186\":1}}],[\"一个列表\",{\"1\":{\"100\":1}}],[\"一个非法索引\",{\"1\":{\"92\":1}}],[\"一个元组\",{\"1\":{\"92\":1,\"107\":1,\"109\":1}}],[\"一旦点云被划分成小的子集\",{\"1\":{\"86\":1}}],[\"一名普通但十分热爱探索技术的coder\",{\"1\":{\"2\":1}}],[\"联合优化\",{\"1\":{\"776\":1}}],[\"联合关系\",{\"1\":{\"455\":1}}],[\"联合使用\",{\"1\":{\"236\":1}}],[\"联合\",{\"0\":{\"236\":1}}],[\"联合推理时\",{\"1\":{\"235\":1}}],[\"联合qllama二次编码视觉特征\",{\"1\":{\"196\":1}}],[\"联合训练三种任务\",{\"1\":{\"120\":1}}],[\"联合建模\",{\"1\":{\"59\":1}}],[\"联合注意力生成对齐特征\",{\"1\":{\"54\":1}}],[\"联合区域对齐\",{\"1\":{\"54\":1}}],[\"意思是\",{\"1\":{\"807\":1}}],[\"意味着gpt\",{\"1\":{\"530\":1}}],[\"意味着从第\",{\"1\":{\"423\":2}}],[\"意味着相邻列的元素在内存中也是相邻的\",{\"1\":{\"423\":1}}],[\"意味着如果你从第\",{\"1\":{\"423\":1}}],[\"意味着在处理图像时\",{\"1\":{\"327\":1}}],[\"意味着动量分布和\",{\"1\":{\"159\":1}}],[\"意义\",{\"1\":{\"49\":1}}],[\"意图协同推理\",{\"1\":{\"7\":1}}],[\"场景文本\",{\"1\":{\"228\":1}}],[\"场景\",{\"1\":{\"56\":1,\"78\":1,\"337\":1,\"455\":1}}],[\"场景特征\",{\"1\":{\"54\":1}}],[\"场景的评估\",{\"1\":{\"49\":1}}],[\"场景交互以揭示功能\",{\"1\":{\"49\":1}}],[\"主干网络\",{\"0\":{\"771\":1}}],[\"主干部分全部冻结\",{\"1\":{\"327\":1}}],[\"主因是书籍数据量不足\",{\"1\":{\"549\":1}}],[\"主是为了解决cot这种从易到难的迁移能力不足而诞生的\",{\"1\":{\"503\":1}}],[\"主对角线\",{\"1\":{\"459\":1}}],[\"主成分分析\",{\"1\":{\"455\":1}}],[\"主特征\",{\"1\":{\"186\":1}}],[\"主要偏重计算机视觉领域\",{\"1\":{\"864\":1}}],[\"主要由以下\",{\"1\":{\"713\":1}}],[\"主要特点包括\",{\"1\":{\"704\":1}}],[\"主要原因如下\",{\"1\":{\"687\":1}}],[\"主要输出项解释\",{\"1\":{\"614\":1}}],[\"主要捕捉局部位置关系\",{\"1\":{\"587\":1}}],[\"主要来源包括\",{\"1\":{\"548\":1}}],[\"主要来自美国和东南亚\",{\"1\":{\"539\":1}}],[\"主要用于测试小型数据集的语言模型训练效果\",{\"1\":{\"577\":1}}],[\"主要用于冷启动训练\",{\"1\":{\"537\":1}}],[\"主要用于解决目标检测任务中前景\",{\"1\":{\"470\":1}}],[\"主要针对电影评论来做情感分类\",{\"1\":{\"515\":1}}],[\"主要有以下两个\",{\"1\":{\"483\":1}}],[\"主要有几个原因\",{\"1\":{\"170\":1}}],[\"主要变化方向\",{\"1\":{\"455\":1}}],[\"主要包括行优先和列优先两类\",{\"1\":{\"422\":1}}],[\"主要包含encoder和decoder结构\",{\"1\":{\"314\":1}}],[\"主要包含以下组件\",{\"1\":{\"222\":1}}],[\"主要的区别就是去掉了paddding\",{\"1\":{\"322\":1}}],[\"主要区别在于norm层的顺序\",{\"1\":{\"321\":1}}],[\"主要是因为这些方法难以实现较高的性能\",{\"1\":{\"305\":1}}],[\"主要动机\",{\"1\":{\"277\":1}}],[\"主要贡献\",{\"1\":{\"260\":1}}],[\"主要步骤如下\",{\"1\":{\"224\":1}}],[\"主要采用固定分辨率\",{\"1\":{\"219\":1}}],[\"主要代表包括\",{\"1\":{\"218\":1}}],[\"主要体现在三个方面\",{\"1\":{\"216\":1}}],[\"主要思想\",{\"1\":{\"186\":1}}],[\"主要作用是\",{\"1\":{\"100\":1}}],[\"主视觉特征\",{\"1\":{\"163\":1}}],[\"主网络进行\",{\"1\":{\"163\":1}}],[\"主模型代码实现\",{\"0\":{\"804\":1}}],[\"主模型\",{\"1\":{\"273\":1}}],[\"主模型参数\",{\"1\":{\"160\":1}}],[\"主模型的预测为\",{\"1\":{\"157\":1}}],[\"主模型被训练去匹配动量模型的预测\",{\"1\":{\"157\":1}}],[\"主流知识型模型对比\",{\"1\":{\"704\":1}}],[\"主流程\",{\"1\":{\"142\":1}}],[\"主流\",{\"1\":{\"122\":1}}],[\"主体\",{\"1\":{\"49\":1,\"54\":1,\"56\":1,\"773\":1,\"814\":1,\"815\":1}}],[\"主页\",{\"0\":{\"0\":1}}],[\"盛放\",{\"1\":{\"49\":1}}],[\"握持\",{\"1\":{\"49\":1}}],[\"握柄倒水\",{\"1\":{\"6\":1}}],[\"杯子\",{\"1\":{\"49\":1}}],[\"需大量\",{\"1\":{\"866\":1}}],[\"需为奇数\",{\"1\":{\"848\":1}}],[\"需使用\",{\"1\":{\"802\":1}}],[\"需使用领域特定语言\",{\"1\":{\"692\":1}}],[\"需在多样化的应用场景中保持高效和准确\",{\"1\":{\"709\":1}}],[\"需编写繁琐的函数调用\",{\"1\":{\"692\":1}}],[\"需包含\",{\"1\":{\"691\":1}}],[\"需处理左右操作数的除法运算\",{\"1\":{\"690\":1}}],[\"需分别实现\",{\"1\":{\"690\":1}}],[\"需通过弱引用解决\",{\"1\":{\"687\":1}}],[\"需通过交互上下文建模解决\",{\"1\":{\"49\":1}}],[\"需依赖垃圾回收机制处理\",{\"1\":{\"687\":1}}],[\"需从\",{\"1\":{\"561\":1}}],[\"需后处理\",{\"1\":{\"550\":1}}],[\"需后续治理\",{\"1\":{\"549\":1}}],[\"需约\",{\"1\":{\"539\":1}}],[\"需调参\",{\"1\":{\"470\":1}}],[\"需二值化\",{\"1\":{\"469\":1}}],[\"需正则化\",{\"1\":{\"385\":1}}],[\"需直接建模像素到类别的复杂映射\",{\"1\":{\"385\":1}}],[\"需数百个神经元拟合嵌套正弦波\",{\"1\":{\"385\":1}}],[\"需高阶泰勒展开\",{\"1\":{\"385\":1}}],[\"需训练整个模型\",{\"1\":{\"239\":1}}],[\"需搭配大规模视觉编码器\",{\"1\":{\"229\":1}}],[\"需先\",{\"1\":{\"82\":2}}],[\"需结合\",{\"1\":{\"82\":1,\"551\":1}}],[\"需严格的空间对应\",{\"1\":{\"52\":1}}],[\"需跨源对齐区域\",{\"1\":{\"49\":1}}],[\"需要强调的是\",{\"1\":{\"878\":1}}],[\"需要指出的一点是\",{\"1\":{\"868\":1}}],[\"需要指定概率度量\",{\"1\":{\"727\":1}}],[\"需要非常多的样本\",{\"1\":{\"866\":1}}],[\"需要解决两个核心问题\",{\"1\":{\"866\":1}}],[\"需要可计算且关于参数\",{\"1\":{\"865\":1}}],[\"需要减去偏移\",{\"1\":{\"817\":1}}],[\"需要\",{\"1\":{\"802\":1,\"853\":1,\"866\":1}}],[\"需要被\",{\"1\":{\"801\":1}}],[\"需要被掩码的词之上\",{\"1\":{\"579\":1}}],[\"需要给出\",{\"1\":{\"759\":1}}],[\"需要进行切片\",{\"1\":{\"717\":1}}],[\"需要设计本应用所要提供的功能\",{\"1\":{\"717\":1}}],[\"需要首先构造训练集\",{\"1\":{\"716\":1}}],[\"需要额外的资源来支持检索机制和数据库的维护\",{\"1\":{\"711\":1}}],[\"需要额外存储和计算\",{\"1\":{\"277\":1}}],[\"需要谨慎\",{\"1\":{\"705\":1}}],[\"需要分别处理左右操作数\",{\"1\":{\"690\":1}}],[\"需要知道正向传播时的\",{\"1\":{\"660\":1}}],[\"需要存储\",{\"1\":{\"588\":1}}],[\"需要对vq\",{\"1\":{\"883\":1}}],[\"需要对数据结构做强假设\",{\"1\":{\"864\":1}}],[\"需要对掩码数量不足max\",{\"1\":{\"581\":1}}],[\"需要对哪个物体做归一化呢\",{\"1\":{\"86\":1}}],[\"需要准备好每一层\",{\"1\":{\"544\":1}}],[\"需要至少50个token的上下文理解\",{\"1\":{\"522\":1}}],[\"需要做些修改以便用在这些任务上\",{\"1\":{\"512\":1}}],[\"需要更多的训练数据\",{\"1\":{\"766\":1}}],[\"需要更多训练数据\",{\"1\":{\"173\":1}}],[\"需要更长的反应时间\",{\"1\":{\"500\":1}}],[\"需要特别说明\",{\"1\":{\"481\":1}}],[\"需要跨越多少个内存元素\",{\"1\":{\"425\":1}}],[\"需要移动\",{\"1\":{\"423\":1}}],[\"需要计算权重和加权平均\",{\"1\":{\"390\":1}}],[\"需要管理员权限\",{\"1\":{\"353\":1}}],[\"需要再将第一个添加的class\",{\"1\":{\"323\":1}}],[\"需要单独将这个token再提取出来\",{\"1\":{\"319\":1}}],[\"需要相对少的数据就可以学习一个比较好的模型\",{\"1\":{\"314\":1}}],[\"需要复制图像特征以匹配beam数量\",{\"1\":{\"313\":1}}],[\"需要数百个gpu训练数十天\",{\"1\":{\"307\":1}}],[\"需要先完成\",{\"1\":{\"278\":1}}],[\"需要先将\",{\"1\":{\"82\":1}}],[\"需要不同的缩放系数\",{\"1\":{\"272\":1}}],[\"需要注意的是\",{\"1\":{\"758\":1,\"807\":1}}],[\"需要注意的一点是\",{\"1\":{\"593\":1}}],[\"需要注意的一点\",{\"1\":{\"249\":1}}],[\"需要注意在对交互文本进行编码时\",{\"1\":{\"31\":1}}],[\"需要大量的计算资源进行训练和推理\",{\"1\":{\"705\":1}}],[\"需要大量的数据标注\",{\"1\":{\"305\":1}}],[\"需要大量神经元构造多个\",{\"1\":{\"385\":1}}],[\"需要大量高质量指令数据\",{\"1\":{\"239\":1}}],[\"需要大量人工或机器生成的\",{\"1\":{\"239\":1}}],[\"需要维护的参数\",{\"1\":{\"169\":1}}],[\"需要捕捉局部结构\",{\"1\":{\"104\":1}}],[\"需要确保这些划分具有一定的一致性或共同结构\",{\"1\":{\"86\":1}}],[\"需要将输入图像调整为这个固定的尺寸\",{\"1\":{\"327\":1}}],[\"需要将\",{\"1\":{\"29\":1,\"620\":1}}],[\"首个提出\",{\"1\":{\"887\":1}}],[\"首个版本于\",{\"1\":{\"704\":1}}],[\"首轮推理\",{\"1\":{\"544\":1}}],[\"首轮统计展示\",{\"1\":{\"476\":1}}],[\"首先给出添加了空间掩码的卷积层实现\",{\"1\":{\"848\":1}}],[\"首先给出的是掩码生成器的初始化方法\",{\"1\":{\"801\":1}}],[\"首先是\",{\"1\":{\"793\":1}}],[\"首先是其初始化方法中需要完成\",{\"1\":{\"578\":1}}],[\"首先是其实现的钩子方法\",{\"1\":{\"275\":1}}],[\"首先要确定应用的核心功能\",{\"1\":{\"717\":1}}],[\"首先需要将非常复杂的业务逻辑依次拆解\",{\"1\":{\"716\":1}}],[\"首先需要对输入图片进行尺寸变化\",{\"1\":{\"317\":1}}],[\"首先在大规模文本数据上进行预训练\",{\"1\":{\"705\":1}}],[\"首先在输入句子的开头加一个代表分类的符号\",{\"1\":{\"575\":1}}],[\"首先求rosenbrock函数在处的导数和\",{\"1\":{\"697\":1}}],[\"首先调用a\",{\"1\":{\"690\":1}}],[\"首先来看一下\",{\"1\":{\"590\":1,\"821\":1}}],[\"首先模型会根据传入的tokens列表生成一个pad\",{\"1\":{\"584\":1}}],[\"首先加入特殊标记\",{\"1\":{\"578\":1}}],[\"首先我们需要准备一个小型语料库\",{\"1\":{\"577\":1}}],[\"首先我们用data目录充当我们的图片库来源\",{\"1\":{\"303\":1}}],[\"首先将\",{\"1\":{\"579\":1}}],[\"首先将橙色和所有的黄色向量进行\",{\"1\":{\"575\":1}}],[\"首先将问题和文章通过\",{\"1\":{\"575\":1}}],[\"首先利用人工演示数据对gpt\",{\"1\":{\"534\":1}}],[\"首先说明\",{\"1\":{\"327\":1}}],[\"首先说对比学习想要做到什么呢\",{\"1\":{\"242\":1}}],[\"首先输入图片\",{\"1\":{\"313\":1}}],[\"首先对图像\",{\"1\":{\"266\":1}}],[\"首先从\",{\"1\":{\"248\":1}}],[\"首先通过一个线性映射层转换为\",{\"1\":{\"771\":1}}],[\"首先通过\",{\"1\":{\"140\":1}}],[\"首先\",{\"1\":{\"97\":1,\"223\":1,\"246\":1,\"250\":1,\"272\":1,\"300\":1,\"302\":1,\"487\":1,\"507\":1,\"516\":1,\"524\":1,\"868\":1,\"870\":1}}],[\"首先使用卷积层对输入图像进行处理\",{\"1\":{\"318\":1}}],[\"首先使用\",{\"1\":{\"8\":1}}],[\"首次引入的\",{\"1\":{\"706\":1}}],[\"首次发布\",{\"1\":{\"704\":1}}],[\"首次将深度学习的思想融入到语言模型中\",{\"1\":{\"703\":1}}],[\"首次实现了视觉与语言模型在参数和特征空间的深度协同\",{\"1\":{\"194\":1}}],[\"首次sample\",{\"1\":{\"93\":1}}],[\"首次通过非配对的2d\",{\"1\":{\"51\":1}}],[\"首次提出通过2d交互图像预测3d物体功能区域\",{\"1\":{\"49\":1}}],[\"坐标值\",{\"1\":{\"387\":1}}],[\"坐标时进行了两次量化\",{\"1\":{\"387\":1}}],[\"坐标信息\",{\"1\":{\"114\":1}}],[\"坐标\",{\"1\":{\"101\":1,\"114\":1,\"386\":1}}],[\"坐标与热力图形式的可供性值\",{\"1\":{\"18\":1}}],[\"坐\",{\"1\":{\"49\":1}}],[\"概念\",{\"1\":{\"49\":1}}],[\"概率越小\",{\"1\":{\"828\":1}}],[\"概率模型已定\",{\"1\":{\"825\":1}}],[\"概率论的核心是\",{\"1\":{\"759\":1}}],[\"概率论基础模型\",{\"0\":{\"757\":1},\"1\":{\"757\":1}}],[\"概率论基础概念\",{\"0\":{\"725\":1},\"1\":{\"725\":1}}],[\"概率论基础知识\",{\"0\":{\"724\":1}}],[\"概率公理\",{\"0\":{\"729\":1}}],[\"概率由积分给出\",{\"1\":{\"728\":1}}],[\"概率空间\",{\"0\":{\"726\":1}}],[\"概率保持不变\",{\"1\":{\"578\":2}}],[\"概率替换为随机词\",{\"1\":{\"578\":2}}],[\"概率替换为\",{\"1\":{\"578\":2}}],[\"概率线性增长\",{\"1\":{\"272\":1}}],[\"概率进行太阳化增强\",{\"1\":{\"186\":1}}],[\"概率转为灰度图\",{\"1\":{\"186\":1}}],[\"概率执行颜色抖动\",{\"1\":{\"186\":1}}],[\"概率水平翻转\",{\"1\":{\"186\":1}}],[\"概率\",{\"1\":{\"163\":1,\"186\":3,\"265\":1,\"272\":8,\"799\":2,\"814\":2,\"848\":1}}],[\"概率值\",{\"1\":{\"46\":1}}],[\"概率分布\",{\"1\":{\"40\":1,\"111\":1,\"728\":1,\"794\":1,\"798\":1}}],[\"验证迭代在大模型开发中是极其重要的一步\",{\"1\":{\"717\":1}}],[\"验证迭代\",{\"1\":{\"717\":1}}],[\"验证迭代优化\",{\"1\":{\"716\":1}}],[\"验证dezero对复杂表达式的计算图构建能力\",{\"1\":{\"696\":1}}],[\"验证安装\",{\"1\":{\"696\":1}}],[\"验证案例\",{\"1\":{\"688\":1}}],[\"验证函数的正向传播和反向传播\",{\"1\":{\"675\":1}}],[\"验证反向传播的正确性\",{\"1\":{\"653\":1,\"676\":1}}],[\"验证小模型+长训练的有效性\",{\"1\":{\"549\":1}}],[\"验证过程中的日志记录\",{\"1\":{\"277\":1}}],[\"验证数据集类\",{\"1\":{\"274\":1}}],[\"验证阶段计算并记录\",{\"1\":{\"278\":1}}],[\"验证阶段\",{\"1\":{\"273\":1}}],[\"验证了更多数据能显著提升模型性能\",{\"1\":{\"561\":1}}],[\"验证了该技术在生产环境下的可行性和价值\",{\"1\":{\"539\":1}}],[\"验证了\",{\"1\":{\"132\":1,\"136\":1,\"268\":1}}],[\"验证了任务设定的可行性和方法的有效性\",{\"1\":{\"48\":1}}],[\"验证集图像\",{\"1\":{\"810\":1}}],[\"验证集上准确率达到了98\",{\"1\":{\"327\":1}}],[\"验证集上进行评估的核心代码实现如下\",{\"1\":{\"82\":1}}],[\"验证集不需要进行数据增强\",{\"1\":{\"317\":1}}],[\"验证集的预处理转换操作\",{\"1\":{\"317\":1}}],[\"验证集\",{\"1\":{\"80\":1,\"716\":1}}],[\"验证\",{\"1\":{\"66\":1,\"68\":1,\"142\":1}}],[\"验证环境\",{\"1\":{\"29\":1}}],[\"建议伴随伦理审查\",{\"1\":{\"539\":1}}],[\"建议设为较高值\",{\"1\":{\"470\":1}}],[\"建议总是先激活\",{\"1\":{\"438\":1}}],[\"建议在\",{\"1\":{\"362\":1}}],[\"建议用linux或者windows系统进行测试\",{\"1\":{\"38\":1}}],[\"建立了测试机制\",{\"1\":{\"678\":1}}],[\"建立变量与函数的连接\",{\"0\":{\"664\":1}}],[\"建立更强的拒绝机制以识别恶意请求\",{\"1\":{\"539\":1}}],[\"建立\",{\"1\":{\"294\":1}}],[\"建立物体类型和功能类型的索引映射关系\",{\"1\":{\"68\":1}}],[\"建模了把一个来自正态分布的向量变形成\",{\"1\":{\"847\":1}}],[\"建模的文本和图像\",{\"1\":{\"807\":1}}],[\"建模\",{\"1\":{\"589\":1,\"847\":1}}],[\"建模图像和文本的交互\",{\"1\":{\"267\":1}}],[\"建模图像与文本的深层交互\",{\"1\":{\"262\":1}}],[\"建模交互上下文以明确功能区域\",{\"1\":{\"48\":1}}],[\"旨在帮助开发者提高应用程序的质量\",{\"1\":{\"715\":1}}],[\"旨在帮助开发者们快速构建基于大型语言模型的端到端应用程序或工作流程\",{\"1\":{\"712\":1}}],[\"旨在满足不同用户和应用场景的需求\",{\"1\":{\"704\":1}}],[\"旨在提升任务泛化能力\",{\"1\":{\"550\":1}}],[\"旨在将模型输出行为与人类意图对齐\",{\"1\":{\"536\":1}}],[\"旨在将图像中的每个像素分类为不同的语义类别\",{\"1\":{\"465\":1}}],[\"旨在缩小开源模型与商业多模态模型\",{\"1\":{\"215\":1}}],[\"旨在与大型语言模型\",{\"1\":{\"197\":1}}],[\"旨在解决当前视觉与视觉\",{\"1\":{\"188\":1}}],[\"旨在实现语言引导下的\",{\"1\":{\"69\":1}}],[\"旨在推动\",{\"1\":{\"60\":1}}],[\"旨在为具身智能体建立感知与操作之间的联系\",{\"1\":{\"48\":1}}],[\"旨在通过系统性的实验评估不同超参数和数据规模对模型性能的影响\",{\"1\":{\"559\":1}}],[\"旨在通过任意指令定位物体上支持特定交互的\",{\"1\":{\"6\":1}}],[\"旨在通过挖掘物体的不变几何属性和潜在交互意图\",{\"1\":{\"5\":1}}],[\"yc+1\",{\"1\":{\"886\":1}}],[\"yc\",{\"1\":{\"886\":3}}],[\"y|x\",{\"1\":{\"821\":1}}],[\"yfcc100m\",{\"1\":{\"810\":2}}],[\"yellow\",{\"1\":{\"697\":1}}],[\"ys\",{\"1\":{\"681\":5,\"686\":5,\"688\":5}}],[\"yn\",{\"1\":{\"481\":1}}],[\"y2\",{\"1\":{\"481\":1}}],[\"y=y\",{\"1\":{\"399\":1}}],[\"y=v\",{\"1\":{\"316\":1}}],[\"y1\",{\"1\":{\"390\":2,\"481\":1,\"652\":2}}],[\"y0\",{\"1\":{\"390\":2,\"652\":2}}],[\"ylabel\",{\"1\":{\"316\":1,\"697\":1}}],[\"yl3800\",{\"1\":{\"60\":1}}],[\"yield\",{\"1\":{\"688\":1}}],[\"yi\",{\"1\":{\"223\":2}}],[\"y\",{\"1\":{\"93\":2,\"114\":2,\"355\":2,\"359\":1,\"360\":1,\"361\":2,\"364\":1,\"368\":2,\"370\":3,\"373\":4,\"378\":2,\"389\":1,\"390\":2,\"395\":1,\"398\":10,\"399\":4,\"452\":1,\"455\":1,\"470\":1,\"481\":1,\"537\":2,\"616\":1,\"643\":2,\"647\":2,\"660\":2,\"662\":2,\"668\":2,\"675\":4,\"676\":2,\"681\":2,\"684\":3,\"685\":2,\"686\":2,\"688\":10,\"689\":6,\"690\":5,\"692\":26,\"696\":24,\"697\":15,\"758\":1,\"794\":1,\"796\":14,\"798\":1,\"821\":1,\"860\":2}}],[\"yanx27\",{\"1\":{\"85\":1}}],[\"yaml\",{\"1\":{\"83\":3}}],[\"yawen\",{\"1\":{\"4\":1}}],[\"you\",{\"1\":{\"70\":1}}],[\"yyvhang\",{\"1\":{\"47\":1}}],[\"做的就是这个定位任务\",{\"1\":{\"616\":1}}],[\"做点积\",{\"1\":{\"590\":3}}],[\"做减法\",{\"1\":{\"590\":1}}],[\"做分类\",{\"1\":{\"575\":1,\"616\":1}}],[\"做为最终的答案\",{\"1\":{\"502\":1}}],[\"做简单的矩阵加法即可\",{\"1\":{\"487\":1}}],[\"做了大量的简化\",{\"1\":{\"481\":1}}],[\"做了个近似\",{\"1\":{\"248\":1}}],[\"做attention\",{\"1\":{\"311\":1}}],[\"做\",{\"1\":{\"310\":1,\"814\":1}}],[\"做线性变换\",{\"1\":{\"276\":1}}],[\"做到一个近似的全部数据集的多分类\",{\"1\":{\"250\":1}}],[\"做判断\",{\"1\":{\"236\":1}}],[\"做掩码操作\",{\"1\":{\"76\":1}}],[\"做全局池化\",{\"1\":{\"46\":1}}],[\"做回答\",{\"1\":{\"28\":1}}],[\"执行随机梯度下降\",{\"1\":{\"868\":1}}],[\"执行模型的一个训练周期\",{\"1\":{\"803\":1}}],[\"执行块状遮挡策略的核心代码实现如下\",{\"1\":{\"801\":1}}],[\"执行项目初始化\",{\"1\":{\"715\":1}}],[\"执行具体行动计划至关重要\",{\"1\":{\"714\":1}}],[\"执行掩码的词的原token列表\",{\"1\":{\"579\":2}}],[\"执行掩码的词的位置列表\",{\"1\":{\"579\":2}}],[\"执行bert的掩码策略\",{\"1\":{\"578\":1}}],[\"执行以下任务\",{\"1\":{\"537\":1}}],[\"执行微调训练\",{\"1\":{\"490\":1}}],[\"执行顺序\",{\"1\":{\"345\":1}}],[\"执行复杂的视觉推理任务\",{\"1\":{\"235\":1}}],[\"执行语言建模训练\",{\"1\":{\"142\":1}}],[\"执行一次训练\",{\"1\":{\"142\":1}}],[\"执行一个\",{\"1\":{\"142\":1}}],[\"执行多轮训练\",{\"1\":{\"142\":1}}],[\"执行预测和可视化\",{\"1\":{\"83\":1}}],[\"执行\",{\"1\":{\"46\":1,\"76\":1,\"360\":1,\"423\":1,\"538\":1,\"696\":1}}],[\"执行交叉注意力机制\",{\"1\":{\"45\":1}}],[\"全零\",{\"1\":{\"848\":1}}],[\"全灰\",{\"1\":{\"756\":1}}],[\"全概率公式\",{\"0\":{\"731\":1},\"1\":{\"731\":1}}],[\"全新的范式\",{\"1\":{\"707\":1}}],[\"全能\",{\"1\":{\"704\":1}}],[\"全面扩展\",{\"1\":{\"680\":1}}],[\"全连接再加上一个softmax\",{\"1\":{\"624\":1}}],[\"全连接层预测变换矩阵\",{\"1\":{\"107\":1}}],[\"全部从维基百科的\",{\"1\":{\"577\":1}}],[\"全部为\",{\"1\":{\"170\":1}}],[\"全部为1\",{\"1\":{\"161\":1}}],[\"全\",{\"1\":{\"573\":2}}],[\"全称为\",{\"1\":{\"571\":1}}],[\"全1\",{\"1\":{\"313\":1}}],[\"全是\",{\"1\":{\"277\":1}}],[\"全0\",{\"1\":{\"272\":1}}],[\"全模型微调\",{\"1\":{\"227\":1}}],[\"全参数调优\",{\"1\":{\"213\":1}}],[\"全量微调\",{\"1\":{\"201\":1}}],[\"全局性\",{\"1\":{\"385\":1}}],[\"全局逼近\",{\"1\":{\"385\":1}}],[\"全局作用域\",{\"1\":{\"336\":1}}],[\"全局困难负样本挖掘带来了显著的性能提升\",{\"1\":{\"268\":1}}],[\"全局困难负样本挖掘\",{\"1\":{\"268\":2}}],[\"全局迭代索引\",{\"1\":{\"186\":1}}],[\"全局裁剪\",{\"1\":{\"186\":2}}],[\"全局对齐\",{\"1\":{\"178\":1}}],[\"全局视角2\",{\"1\":{\"186\":1}}],[\"全局视角1\",{\"1\":{\"186\":1}}],[\"全局视角分辨率为\",{\"1\":{\"178\":1}}],[\"全局视角\",{\"1\":{\"178\":1}}],[\"全局信息\",{\"1\":{\"111\":1}}],[\"全局信息融合机制\",{\"1\":{\"105\":1}}],[\"全局特征表示\",{\"1\":{\"319\":1}}],[\"全局特征不能很好地反映每个点的上下文\",{\"1\":{\"112\":1}}],[\"全局特征不能直接用于分割\",{\"1\":{\"111\":1}}],[\"全局特征只有一份\",{\"1\":{\"111\":1}}],[\"全局特征\",{\"1\":{\"109\":1}}],[\"全局特征开关\",{\"1\":{\"109\":1}}],[\"全局特征都不一样了\",{\"1\":{\"86\":1}}],[\"全局最大池化\",{\"1\":{\"107\":1}}],[\"全局质心点\",{\"1\":{\"92\":1}}],[\"全局平均池化层\",{\"1\":{\"46\":1}}],[\"全为\",{\"1\":{\"43\":1,\"143\":1,\"312\":1}}],[\"数清楚\",{\"1\":{\"873\":1}}],[\"数不能超过图像\",{\"1\":{\"817\":1}}],[\"数\",{\"1\":{\"798\":1,\"801\":3,\"802\":2,\"822\":1}}],[\"数值稳定性更高\",{\"1\":{\"853\":1}}],[\"数值不连续\",{\"1\":{\"853\":1}}],[\"数值\",{\"1\":{\"727\":1}}],[\"数值微分的问题\",{\"0\":{\"653\":1}}],[\"数值微分的实现\",{\"0\":{\"651\":1}}],[\"数值微分\",{\"0\":{\"649\":1}}],[\"数值可以是\",{\"1\":{\"64\":1}}],[\"数字拆分为独立字符\",{\"1\":{\"548\":1}}],[\"数理一致性等方面\",{\"1\":{\"530\":1}}],[\"数学上\",{\"1\":{\"865\":1}}],[\"数学推导\",{\"0\":{\"826\":1}}],[\"数学推理\",{\"1\":{\"228\":1}}],[\"数学表达式\",{\"1\":{\"795\":1}}],[\"数学解释\",{\"0\":{\"755\":1}}],[\"数学期望与方差\",{\"0\":{\"743\":1}}],[\"数学\",{\"1\":{\"550\":1}}],[\"数学等专业任务中\",{\"1\":{\"549\":1}}],[\"数学能力\",{\"1\":{\"549\":1}}],[\"数学知识点\",{\"0\":{\"454\":1},\"1\":{\"454\":1}}],[\"数学本质对比\",{\"1\":{\"385\":1}}],[\"数学定义\",{\"1\":{\"115\":1,\"455\":1,\"473\":1}}],[\"数下\",{\"1\":{\"136\":1}}],[\"数组混合运算\",{\"1\":{\"693\":1}}],[\"数组转换为\",{\"1\":{\"317\":2}}],[\"数组后\",{\"1\":{\"302\":1}}],[\"数组格式返回\",{\"1\":{\"302\":1}}],[\"数组\",{\"1\":{\"83\":1,\"423\":1,\"427\":2}}],[\"数量达到总数的\",{\"1\":{\"772\":1}}],[\"数量一致\",{\"1\":{\"409\":1}}],[\"数量和\",{\"1\":{\"272\":1}}],[\"数量有限\",{\"1\":{\"128\":1}}],[\"数量\",{\"1\":{\"46\":2,\"143\":1,\"170\":2,\"272\":1,\"318\":1,\"801\":1,\"802\":1,\"804\":1,\"817\":1,\"821\":1}}],[\"数据流\",{\"1\":{\"796\":1}}],[\"数据工程\",{\"1\":{\"716\":2}}],[\"数据连接\",{\"1\":{\"713\":1,\"714\":1}}],[\"数据存储等等\",{\"1\":{\"712\":1}}],[\"数据存储在data属性中\",{\"1\":{\"639\":1}}],[\"数据处理\",{\"1\":{\"711\":1}}],[\"数据处理阶段\",{\"1\":{\"710\":1}}],[\"数据处理参数\",{\"1\":{\"274\":1}}],[\"数据分析与可视化\",{\"1\":{\"704\":1}}],[\"数据分析和第三方服务调用\",{\"1\":{\"704\":1}}],[\"数据类型检查\",{\"0\":{\"673\":1}}],[\"数据类型和设备\",{\"1\":{\"170\":1}}],[\"数据预加载\",{\"1\":{\"578\":1}}],[\"数据预处理一般包括从多种格式向纯文本的转化\",{\"1\":{\"717\":1}}],[\"数据预处理\",{\"0\":{\"594\":1},\"1\":{\"83\":1,\"476\":1,\"848\":1}}],[\"数据清洗\",{\"0\":{\"577\":1}}],[\"数据清洗与分词\",{\"1\":{\"514\":1}}],[\"数据量增加后\",{\"1\":{\"565\":1}}],[\"数据量和计算量按幂律缩放\",{\"1\":{\"531\":1}}],[\"数据规模和模型设置\",{\"1\":{\"563\":1}}],[\"数据复制增加了存储和计算开销\",{\"1\":{\"562\":1}}],[\"数据复制\",{\"1\":{\"562\":1}}],[\"数据配置\",{\"1\":{\"561\":1}}],[\"数据根源\",{\"1\":{\"551\":1}}],[\"数据不透明\",{\"1\":{\"550\":1}}],[\"数据策略与开源兼容性\",{\"1\":{\"547\":1}}],[\"数据在训练中并非按体量采样\",{\"1\":{\"528\":1}}],[\"数据在底层存储为\",{\"1\":{\"426\":1}}],[\"数据质量\",{\"1\":{\"522\":1}}],[\"数据质量差\",{\"1\":{\"120\":1}}],[\"数据重叠检测\",{\"1\":{\"522\":1}}],[\"数据与架构创新\",{\"1\":{\"521\":1}}],[\"数据以避免测试集污染\",{\"1\":{\"521\":1}}],[\"数据来源\",{\"1\":{\"521\":1}}],[\"数据来源包括\",{\"1\":{\"232\":1}}],[\"数据安全的问题\",{\"1\":{\"482\":1}}],[\"数据可能沿某个方向拉长\",{\"1\":{\"459\":1}}],[\"数据内容\",{\"1\":{\"427\":1}}],[\"数据指针偏移\",{\"1\":{\"425\":1}}],[\"数据还是指向内存中已有的数据\",{\"1\":{\"425\":1}}],[\"数据元素在内存空间的排列顺序\",{\"1\":{\"422\":1}}],[\"数据的分布更加稀疏\",{\"1\":{\"321\":1}}],[\"数据下载\",{\"0\":{\"316\":1}}],[\"数据按\",{\"1\":{\"274\":1}}],[\"数据目录\",{\"1\":{\"274\":1}}],[\"数据模块\",{\"0\":{\"274\":1}}],[\"数据加载\",{\"0\":{\"855\":1}}],[\"数据加载器与数据集支持\",{\"1\":{\"700\":1}}],[\"数据加载阶段\",{\"1\":{\"273\":1}}],[\"数据加载完成\",{\"1\":{\"186\":1}}],[\"数据通常较长\",{\"1\":{\"266\":1}}],[\"数据进行语言预训练\",{\"1\":{\"266\":1}}],[\"数据进行视觉预训练\",{\"1\":{\"266\":1}}],[\"数据提升模型能力\",{\"1\":{\"266\":1}}],[\"数据会出去\",{\"1\":{\"249\":1}}],[\"数据依赖性强\",{\"1\":{\"239\":1}}],[\"数据需求高\",{\"1\":{\"527\":1}}],[\"数据需求\",{\"1\":{\"239\":1}}],[\"数据均匀采样\",{\"1\":{\"235\":1}}],[\"数据构建方式\",{\"1\":{\"234\":1}}],[\"数据准备阶段\",{\"1\":{\"273\":1,\"274\":1}}],[\"数据准备\",{\"1\":{\"186\":1}}],[\"数据从头训练一个新模型\",{\"1\":{\"137\":1}}],[\"数据训练\",{\"1\":{\"137\":1,\"210\":1}}],[\"数据\",{\"1\":{\"131\":1,\"198\":3,\"276\":1,\"278\":1,\"560\":1,\"561\":1,\"840\":1}}],[\"数据增强和更强的视觉编码器\",{\"1\":{\"220\":1}}],[\"数据增强包括随机裁剪和翻转\",{\"1\":{\"212\":1}}],[\"数据增强类\",{\"1\":{\"186\":1}}],[\"数据增强\",{\"0\":{\"124\":1},\"1\":{\"179\":1,\"274\":1}}],[\"数据增强与配对策略\",{\"0\":{\"66\":1}}],[\"数据自举方法\",{\"1\":{\"120\":1}}],[\"数据路径设置\",{\"1\":{\"83\":1}}],[\"数据组织形式\",{\"1\":{\"68\":1}}],[\"数据总量\",{\"1\":{\"65\":1}}],[\"数据划分方式\",{\"1\":{\"65\":1}}],[\"数据划分\",{\"0\":{\"20\":1}}],[\"数据收集问题\",{\"1\":{\"539\":1}}],[\"数据收集\",{\"0\":{\"17\":1,\"810\":1},\"1\":{\"539\":1}}],[\"数据集加载\",{\"0\":{\"802\":1}}],[\"数据集加载代码\",{\"1\":{\"316\":1}}],[\"数据集预处理完后\",{\"1\":{\"594\":1}}],[\"数据集预训练模型\",{\"1\":{\"514\":1}}],[\"数据集评估\",{\"1\":{\"537\":1}}],[\"数据集构成与过滤策略\",{\"1\":{\"528\":1}}],[\"数据集构建\",{\"1\":{\"537\":1}}],[\"数据集构建钩子\",{\"1\":{\"274\":1}}],[\"数据集构建阶段\",{\"1\":{\"274\":1}}],[\"数据集级别\",{\"1\":{\"470\":1}}],[\"数据集下载\",{\"1\":{\"316\":1}}],[\"数据集训练的检测模型\",{\"1\":{\"280\":1}}],[\"数据集进行训练\",{\"1\":{\"235\":1}}],[\"数据集进行微调\",{\"1\":{\"142\":1,\"145\":1}}],[\"数据集处理方面\",{\"1\":{\"145\":1}}],[\"数据集上的实战测试\",{\"0\":{\"848\":1}}],[\"数据集上的实验结果\",{\"1\":{\"538\":1}}],[\"数据集上的性能下降\",{\"1\":{\"539\":1}}],[\"数据集上取得了很好的结果\",{\"1\":{\"247\":1}}],[\"数据集上\",{\"1\":{\"245\":1,\"538\":1}}],[\"数据集上进行训练与评估\",{\"1\":{\"850\":1}}],[\"数据集上进行训练后\",{\"1\":{\"143\":1}}],[\"数据集上进行了最高至\",{\"1\":{\"810\":1}}],[\"数据集上进行预训练的\",{\"1\":{\"327\":1}}],[\"数据集上进行迁移学习\",{\"1\":{\"235\":1}}],[\"数据集上开展了系统性的实验评估\",{\"1\":{\"21\":1}}],[\"数据集的零样本测试中表现优异\",{\"1\":{\"806\":1}}],[\"数据集的加载\",{\"1\":{\"802\":1}}],[\"数据集的\",{\"1\":{\"236\":1}}],[\"数据集的训练\",{\"1\":{\"142\":1}}],[\"数据集的初始化\",{\"1\":{\"29\":1}}],[\"数据集应当用于重新训练一个新模型\",{\"1\":{\"137\":1}}],[\"数据集重新训练模型\",{\"0\":{\"137\":1}}],[\"数据集一致\",{\"1\":{\"136\":1}}],[\"数据集中的图像都是单通道图像\",{\"1\":{\"848\":1}}],[\"数据集中每一个样本最终都会解析得到一个inputfeatures\",{\"1\":{\"594\":1}}],[\"数据集中图像的数量\",{\"1\":{\"316\":1}}],[\"数据集中\",{\"1\":{\"78\":1}}],[\"数据集类型\",{\"1\":{\"68\":1}}],[\"数据集存放目录\",{\"1\":{\"68\":1}}],[\"数据集统计信息\",{\"0\":{\"67\":1}}],[\"数据集设置\",{\"1\":{\"65\":1}}],[\"数据集组织方式\",{\"0\":{\"65\":1}}],[\"数据集基于\",{\"1\":{\"62\":1,\"69\":1}}],[\"数据集初始化的核心代码实现如下\",{\"1\":{\"68\":1}}],[\"数据集初始化\",{\"1\":{\"58\":1}}],[\"数据集目录下的组织方式\",{\"1\":{\"58\":1}}],[\"数据集贡献\",{\"1\":{\"6\":1}}],[\"数据集\",{\"0\":{\"16\":1,\"29\":1,\"58\":1,\"61\":1},\"1\":{\"4\":1,\"47\":1,\"138\":1,\"186\":1,\"210\":1,\"235\":1,\"274\":1,\"307\":1,\"536\":1,\"537\":3,\"538\":1}}],[\"热图回归损失\",{\"1\":{\"55\":1}}],[\"热图\",{\"1\":{\"46\":1}}],[\"它之前的名字叫logit\",{\"1\":{\"880\":1}}],[\"它提供了把大图像翻译成\",{\"1\":{\"878\":1}}],[\"它提供了一种根据观测数据\",{\"1\":{\"734\":1}}],[\"它和ae一样\",{\"1\":{\"878\":1}}],[\"它控制着两个损失项之间的权重\",{\"1\":{\"873\":1}}],[\"它度量了\",{\"1\":{\"872\":1}}],[\"它既能最大化\",{\"1\":{\"871\":1}}],[\"它衡量两个概率分布之间的距离\",{\"1\":{\"867\":1}}],[\"它最大的优势在于可以直接从中采样\",{\"1\":{\"866\":1}}],[\"它引入了条件变量\",{\"1\":{\"858\":1}}],[\"它引入了局部区域搜索\",{\"1\":{\"112\":1}}],[\"它有一个闭式解\",{\"1\":{\"854\":1}}],[\"它大概率指的就是\",{\"1\":{\"847\":1}}],[\"它能描述的颜色是有限而确定的\",{\"1\":{\"847\":1}}],[\"它能够根据输入\",{\"1\":{\"867\":1}}],[\"它能够让语言模型与其他数据来源连接\",{\"1\":{\"712\":1}}],[\"它能够成功的两个关键点\",{\"1\":{\"704\":1}}],[\"它能够从每个子集中提取有用的信息或特征\",{\"1\":{\"86\":1}}],[\"它把\",{\"1\":{\"847\":1}}],[\"它前面的像素\",{\"1\":{\"846\":1}}],[\"它用于约束编码器的输出\",{\"1\":{\"882\":1}}],[\"它用于优化嵌入空间\",{\"1\":{\"882\":1}}],[\"它用于聚合全局信息\",{\"1\":{\"179\":1}}],[\"它用一些巧妙的方法约束了编码向量\",{\"1\":{\"878\":1}}],[\"它用来衡量模型预测的概率分布\",{\"1\":{\"832\":1}}],[\"它总是\",{\"1\":{\"831\":1}}],[\"它假设数据生成过程已知\",{\"1\":{\"825\":1}}],[\"它使得\",{\"1\":{\"796\":1}}],[\"它使用双线性插值来避免量化误差\",{\"1\":{\"386\":1}}],[\"它使用\",{\"1\":{\"110\":2,\"175\":1}}],[\"它描述了在观测到\",{\"1\":{\"759\":1}}],[\"它从一些基本的\",{\"1\":{\"728\":1}}],[\"它必须满足以下三条规则\",{\"1\":{\"728\":1}}],[\"它必须要在超大数据集上进行预训练\",{\"1\":{\"324\":1}}],[\"它本身不\",{\"1\":{\"727\":1}}],[\"它本身不随机\",{\"1\":{\"727\":1}}],[\"它让计算机更好地理解和使用语言\",{\"1\":{\"708\":1}}],[\"它也总是会沿着某个分支进行dfs直到\",{\"1\":{\"685\":1}}],[\"它也倾向于过度规避风险\",{\"1\":{\"538\":1}}],[\"它允许模型在处理每个词时关注输入序列中的所有词\",{\"1\":{\"622\":1}}],[\"它允许不同形状的张量进行逐元素\",{\"1\":{\"427\":1}}],[\"它较难学习到长距离的依赖关系\",{\"1\":{\"621\":1}}],[\"它对应某个相对位置桶\",{\"1\":{\"591\":1}}],[\"它对每个维度的偏差一视同仁\",{\"1\":{\"457\":1}}],[\"它面临的问题包括任务适应不均\",{\"1\":{\"530\":1}}],[\"它验证了单一模型架构通过规模扩展即可实现多任务处理的可能性\",{\"1\":{\"524\":1}}],[\"它被证明在许多任务上有很强的表现\",{\"1\":{\"507\":1}}],[\"它得到的结果是错的\",{\"1\":{\"502\":1}}],[\"它并不是一个通用智能系统\",{\"1\":{\"530\":1}}],[\"它并不保证结果的合理性和正确性\",{\"1\":{\"497\":1}}],[\"它并不像单词那样有很强的语义信息\",{\"1\":{\"246\":1}}],[\"它只是在给定的信息的前提下\",{\"1\":{\"497\":1}}],[\"它来源于\",{\"1\":{\"467\":1}}],[\"它包含了每个特征的方差\",{\"1\":{\"459\":1}}],[\"它包含了这个区域内所有点的信息\",{\"1\":{\"92\":1}}],[\"它直接对每个维度的偏差做平方加总\",{\"1\":{\"459\":1}}],[\"它在小型模型中不明显\",{\"1\":{\"706\":1}}],[\"它在编码每一词的时候都能够注意\",{\"1\":{\"621\":1}}],[\"它在\",{\"1\":{\"591\":1}}],[\"它在技术上并非从零出发\",{\"1\":{\"531\":1}}],[\"它在某种程度上也具备一定的多语言能力\",{\"1\":{\"531\":1}}],[\"它在这个维度上的偏差也会被直接算入距离\",{\"1\":{\"457\":1}}],[\"它在科研与工业界都很受欢迎\",{\"1\":{\"395\":1}}],[\"它就是我们平时量两个点之间\",{\"1\":{\"457\":1}}],[\"它表示我们在看到数据\",{\"1\":{\"758\":1}}],[\"它表示\",{\"1\":{\"455\":1,\"831\":1}}],[\"它可能由两部分组成\",{\"1\":{\"590\":1}}],[\"它可按下式计算\",{\"1\":{\"448\":1}}],[\"它可以把每个输入单词都映射到一个独一无二的连续向量上\",{\"1\":{\"878\":1}}],[\"它可以改进搜索引擎\",{\"1\":{\"708\":1}}],[\"它可以帮助计算机更好地理解和生成文本\",{\"1\":{\"708\":1}}],[\"它可以当成函数调用\",{\"1\":{\"626\":1}}],[\"它可以在指定维度上\",{\"1\":{\"581\":1}}],[\"它可以拥有任意数量的维度\",{\"1\":{\"421\":1}}],[\"它可以以任意的精度来近似任何一个定义在实数空间中的有界闭集函数\",{\"1\":{\"385\":1}}],[\"它可以被理解为一种\",{\"1\":{\"173\":1}}],[\"它离\",{\"1\":{\"387\":4}}],[\"它根据已有张量的属性创建一个全零张量\",{\"1\":{\"378\":1}}],[\"它会根据\",{\"1\":{\"591\":1}}],[\"它会把一个张量\",{\"1\":{\"366\":1}}],[\"它会复制数据\",{\"1\":{\"363\":1}}],[\"它会将多个样本收集起来形成一个批次\",{\"1\":{\"316\":1}}],[\"它会将图像切分为\",{\"1\":{\"126\":1}}],[\"它接收一个函数或类作为参数\",{\"1\":{\"342\":1}}],[\"它接收来自编码器和解码器的特征\",{\"1\":{\"46\":1}}],[\"它\",{\"1\":{\"340\":1}}],[\"它位于最终分类头之前\",{\"1\":{\"323\":1}}],[\"它与类的实例和类本身都没有直接关联\",{\"1\":{\"316\":1}}],[\"它首次将nlp领域火热的transformer模型架构移植到了cv领域\",{\"1\":{\"314\":1}}],[\"它将权重矩阵量化为\",{\"1\":{\"495\":1}}],[\"它将\",{\"1\":{\"473\":1,\"686\":1}}],[\"它将每个\",{\"1\":{\"312\":1}}],[\"它将输入的向量转换为\",{\"1\":{\"302\":1}}],[\"它由一些基本区间\",{\"1\":{\"728\":1}}],[\"它由18层组成\",{\"1\":{\"382\":1}}],[\"它由两个部分组成\",{\"1\":{\"300\":1}}],[\"它由大量带有位置信息的点组成\",{\"1\":{\"114\":1}}],[\"它比谷歌的jft\",{\"1\":{\"299\":1}}],[\"它代表着一种基于对比文本\",{\"1\":{\"298\":1}}],[\"它通常用于像\",{\"1\":{\"295\":1}}],[\"它通过简单地对整个生成过程加上条件限制来修改上一节中的数学模型\",{\"1\":{\"874\":1}}],[\"它通过位置编码将序列中词的位置信息注入到输入中\",{\"1\":{\"622\":1}}],[\"它通过固定的周期性函数\",{\"1\":{\"587\":1}}],[\"它通过一组非线性基函数\",{\"1\":{\"385\":1}}],[\"它通过广播\",{\"1\":{\"364\":1}}],[\"它通过处理器对输入文本进行处理\",{\"1\":{\"302\":1}}],[\"它通过让学生特征去匹配由\",{\"1\":{\"175\":1}}],[\"它通过学习一个相似度函数\",{\"1\":{\"154\":1}}],[\"它基于jaccard指数\",{\"1\":{\"469\":1}}],[\"它基于\",{\"1\":{\"269\":1}}],[\"它基于前面的特征提取模块\",{\"1\":{\"110\":1,\"111\":1}}],[\"它非常灵活\",{\"1\":{\"246\":1}}],[\"它们都可以生成我们希望逼近的输出分布\",{\"1\":{\"871\":1}}],[\"它们都是在数万亿个字符上训练的\",{\"1\":{\"704\":1}}],[\"它们都是按照其序列长度的20\",{\"1\":{\"581\":1}}],[\"它们都是被过度参数化的\",{\"1\":{\"487\":1}}],[\"它们仍可能无法提供准确的答案\",{\"1\":{\"709\":1}}],[\"它们为自然语言理解和生成任务提供了强大的工具\",{\"1\":{\"705\":1}}],[\"它们的平方距离越来越集中在\",{\"1\":{\"755\":1}}],[\"它们的出现会导致比独立情形更大的方差\",{\"1\":{\"744\":1}}],[\"它们的多语言能力使得跨文化和跨语言的应用变得更加容易\",{\"1\":{\"705\":1}}],[\"它们的能力依次递增\",{\"1\":{\"704\":1}}],[\"它们在海量的文本数据上进行训练\",{\"1\":{\"703\":1}}],[\"它们在\",{\"1\":{\"577\":1}}],[\"它们有更小的内在维度\",{\"1\":{\"491\":1}}],[\"它们分布在\",{\"1\":{\"387\":1}}],[\"它们是离散的信号\",{\"1\":{\"246\":1}}],[\"它们共同帮助我们判断模型是否真正理解语言引导下的功能区域语义\",{\"1\":{\"82\":1}}],[\"它负责从输入点云中提取出可用于分类或分割的特征\",{\"1\":{\"109\":1}}],[\"它具有以下特点\",{\"1\":{\"107\":1}}],[\"它是在注意力分数计算完之后加上去的\",{\"1\":{\"591\":1}}],[\"它是在lora的基础上\",{\"1\":{\"488\":1}}],[\"它是用于执行bert\",{\"1\":{\"578\":1}}],[\"它是一种静态的位置信息表示\",{\"1\":{\"587\":1}}],[\"它是一种用于度量集合之间相似性的指标\",{\"1\":{\"471\":1}}],[\"它是一个常用于离散分布中采样的技巧\",{\"1\":{\"819\":1}}],[\"它是一个用于计算在给定观测数据\",{\"1\":{\"758\":1}}],[\"它是一个函数\",{\"1\":{\"727\":1}}],[\"它是一个指向内存中某个元素的指针偏移量\",{\"1\":{\"425\":1}}],[\"它是一个非常强大且灵活的张量操作函数\",{\"1\":{\"76\":1}}],[\"它是\",{\"1\":{\"324\":1,\"703\":1,\"834\":1}}],[\"它是无序点云数据特征提取的高效算法\",{\"1\":{\"86\":1}}],[\"它常用于图像检索\",{\"1\":{\"82\":1}}],[\"它结合了均方误差\",{\"1\":{\"797\":1}}],[\"它结合了两种\",{\"1\":{\"468\":1}}],[\"它结合了\",{\"1\":{\"78\":1}}],[\"它的值在前向传播时取\",{\"1\":{\"881\":1}}],[\"它的目的是把图像压缩成离散向量\",{\"1\":{\"878\":1}}],[\"它的目标是在生成图像时\",{\"1\":{\"846\":1}}],[\"它的目标是在一个由一个正样本和多个负样本构成的集合中\",{\"1\":{\"248\":1}}],[\"它的目标是为各种大型语言模型应用提供通用接口\",{\"1\":{\"712\":1}}],[\"它的目标是\",{\"1\":{\"107\":1}}],[\"它的输入是\",{\"1\":{\"820\":1}}],[\"它的核心思想可以分为三个步骤\",{\"1\":{\"816\":1}}],[\"它的核心思想是通过不断合并最常见的字符对来构建一个高效的词汇表\",{\"1\":{\"475\":1}}],[\"它的核心思想是\",{\"1\":{\"92\":1,\"390\":1}}],[\"它的\",{\"1\":{\"773\":1}}],[\"它的尾部非常厚重\",{\"1\":{\"749\":1}}],[\"它的概率密度函数全部集中在正实数轴上\",{\"1\":{\"749\":1}}],[\"它的概率密度函数\",{\"1\":{\"748\":1,\"749\":1}}],[\"它的定义是\",{\"1\":{\"728\":1}}],[\"它的样本空间是连续的\",{\"1\":{\"728\":1}}],[\"它的语法是\",{\"1\":{\"615\":1}}],[\"它的波动幅度很小\",{\"1\":{\"587\":1}}],[\"它的应用自不必提\",{\"1\":{\"495\":1}}],[\"它的更新可表示为\",{\"1\":{\"492\":1}}],[\"它的结构包括一个输入层\",{\"1\":{\"382\":1}}],[\"它的名字和文档字符串也被覆盖了\",{\"1\":{\"346\":1}}],[\"它的作用是给定一个完整的句子\",{\"1\":{\"616\":1}}],[\"它的作用是对一个样本进行两次增强\",{\"1\":{\"252\":1}}],[\"它的作用是负责从输入的点云数据中采样关键点\",{\"1\":{\"92\":1}}],[\"它的基本思想是把一个\",{\"1\":{\"248\":1}}],[\"它的本质是\",{\"1\":{\"76\":1}}],[\"它的主要目标是\",{\"1\":{\"76\":1}}],[\"它不仅是\",{\"1\":{\"695\":1}}],[\"它不仅考虑两个点之间的差异\",{\"1\":{\"458\":1}}],[\"它不具有生成能力\",{\"1\":{\"616\":1}}],[\"它不会\",{\"1\":{\"616\":1}}],[\"它不会参与点积运算\",{\"1\":{\"591\":1}}],[\"它不依赖任何手工设计的公式\",{\"1\":{\"588\":1}}],[\"它不是理想的后验\",{\"1\":{\"872\":1}}],[\"它不是单纯地\",{\"1\":{\"232\":1}}],[\"它不是直接包含原始图像\",{\"1\":{\"41\":1}}],[\"它不使用任何注意力机制\",{\"1\":{\"73\":1}}],[\"→68\",{\"1\":{\"550\":1}}],[\"→\",{\"0\":{\"410\":1},\"1\":{\"45\":3,\"46\":4,\"82\":1,\"98\":1,\"99\":9,\"101\":4,\"105\":4,\"107\":4,\"147\":8,\"159\":3,\"160\":5,\"170\":2,\"181\":2,\"183\":3,\"224\":1,\"272\":1,\"274\":2,\"336\":3,\"364\":4,\"386\":1,\"390\":1,\"393\":2,\"399\":3,\"403\":2,\"419\":4,\"455\":3,\"470\":4,\"471\":4,\"578\":1,\"590\":2,\"591\":10,\"728\":4,\"758\":1,\"793\":1,\"801\":1,\"814\":2,\"815\":2,\"819\":3,\"828\":2,\"831\":1,\"886\":1}}],[\"指导大型语言模型生成更为精准的答案\",{\"1\":{\"709\":1}}],[\"指导抓取和运动规划\",{\"1\":{\"51\":1}}],[\"指代准确率81\",{\"1\":{\"551\":1}}],[\"指的就是上述公式中的矩阵w\",{\"1\":{\"481\":1}}],[\"指的是输入图像的尺寸为\",{\"1\":{\"327\":1}}],[\"指南\",{\"1\":{\"447\":1}}],[\"指向\",{\"1\":{\"425\":1}}],[\"指明在每个维度上移动一个索引单位时\",{\"1\":{\"425\":1}}],[\"指明哪些位置是有效的\",{\"1\":{\"312\":1}}],[\"指从一个大的数据结构中提取出一部分连续的数据子集\",{\"1\":{\"425\":1}}],[\"指定标签\",{\"0\":{\"861\":1}}],[\"指定模型只预测被遮挡的位置\",{\"1\":{\"803\":1}}],[\"指定待处理图像路径后\",{\"1\":{\"463\":1}}],[\"指定沿哪一维累加\",{\"1\":{\"379\":1}}],[\"指定最小长度\",{\"1\":{\"377\":1}}],[\"指定\",{\"1\":{\"376\":1,\"378\":1}}],[\"指定输出数据类型\",{\"1\":{\"373\":1}}],[\"指定维度\",{\"1\":{\"372\":1}}],[\"指定操作的维度\",{\"1\":{\"372\":1}}],[\"指定填充的方式\",{\"1\":{\"369\":1}}],[\"指定的列\",{\"1\":{\"68\":1}}],[\"指令遵循与文本生成提供了复杂业务逻辑的简单平替方案\",{\"1\":{\"716\":1}}],[\"指令遵循\",{\"1\":{\"706\":1}}],[\"指令跟随能力\",{\"1\":{\"539\":1}}],[\"指令的顺从\",{\"1\":{\"538\":1}}],[\"指令中的显式约束\",{\"1\":{\"538\":1}}],[\"指令\",{\"1\":{\"232\":2,\"234\":2,\"239\":2}}],[\"指令调优\",{\"1\":{\"232\":1,\"239\":2}}],[\"指令微调\",{\"0\":{\"550\":1},\"1\":{\"205\":1,\"549\":1,\"706\":1}}],[\"指令理解特征\",{\"1\":{\"45\":1}}],[\"指数中的表达式\",{\"1\":{\"752\":1}}],[\"指数级表达能力\",{\"1\":{\"385\":1}}],[\"指数增长\",{\"1\":{\"385\":2}}],[\"指数衰减的polyak\",{\"1\":{\"182\":1}}],[\"指数滑动平均\",{\"1\":{\"169\":1,\"178\":1}}],[\"指标的选择和权衡\",{\"0\":{\"447\":1}}],[\"指标\",{\"1\":{\"82\":2,\"447\":1,\"469\":1}}],[\"指出图像中物体与人交互的部分\",{\"1\":{\"11\":1}}],[\"作用是\",{\"1\":{\"346\":1}}],[\"作用域\",{\"0\":{\"336\":1}}],[\"作用于\",{\"1\":{\"272\":1}}],[\"作用于注意力分支\",{\"1\":{\"272\":1}}],[\"作用于注意力之前\",{\"1\":{\"272\":1}}],[\"作用于点云特征图\",{\"1\":{\"76\":1}}],[\"作用\",{\"1\":{\"186\":1,\"272\":1,\"294\":1,\"372\":1,\"373\":1,\"374\":1,\"378\":1,\"470\":1,\"802\":3,\"846\":1}}],[\"作为解码器的输入\",{\"1\":{\"880\":2}}],[\"作为近似指标\",{\"1\":{\"869\":1}}],[\"作为对\",{\"1\":{\"868\":1}}],[\"作为对称函数\",{\"1\":{\"105\":1}}],[\"作为图文匹配的判别器\",{\"1\":{\"822\":1}}],[\"作为图像的分类预测结果\",{\"1\":{\"300\":1}}],[\"作为图像编码器\",{\"1\":{\"126\":1}}],[\"作为下一个\",{\"1\":{\"818\":1}}],[\"作为送入\",{\"1\":{\"815\":1}}],[\"作为自回归预测的开始标志\",{\"1\":{\"815\":1}}],[\"作为统一的序列输入transformer进行编码\",{\"1\":{\"814\":1}}],[\"作为离散符号\",{\"1\":{\"807\":1}}],[\"作为单一的数据流进行建模\",{\"1\":{\"807\":1}}],[\"作为训练标签\",{\"1\":{\"803\":1}}],[\"作为标签\",{\"1\":{\"803\":1}}],[\"作为重建损失\",{\"1\":{\"793\":1}}],[\"作为主干网络\",{\"1\":{\"771\":1}}],[\"作为划分事件\",{\"1\":{\"731\":1}}],[\"作为大模型开发的初学者\",{\"1\":{\"716\":1}}],[\"作为一个统一的序列进行训练\",{\"1\":{\"813\":1}}],[\"作为一个不断进化的创新平台\",{\"1\":{\"714\":1}}],[\"作为一个大语言模型开发框架\",{\"1\":{\"713\":1}}],[\"作为一个指标就没有那么有意义和实用\",{\"1\":{\"445\":1}}],[\"作为节点唯一id\",{\"1\":{\"696\":1}}],[\"作为答案开始的可能性\",{\"1\":{\"614\":1}}],[\"作为整个输入序列的全局信息聚合表示\",{\"1\":{\"580\":1}}],[\"作为整个点云的\",{\"1\":{\"107\":1,\"109\":1}}],[\"作为最终的\",{\"1\":{\"575\":1}}],[\"作为奖励函数\",{\"1\":{\"537\":1}}],[\"作为激活函数\",{\"1\":{\"514\":1}}],[\"作为分隔符\",{\"1\":{\"499\":1}}],[\"作为分词时的合并规则和优先选择权\",{\"1\":{\"476\":1}}],[\"作为平衡数据集的模型训练进度\",{\"1\":{\"447\":1}}],[\"作为特征提取器\",{\"1\":{\"326\":1}}],[\"作为特征提取器的方式差不多\",{\"1\":{\"245\":1}}],[\"作为文本解码器的初始状态\",{\"1\":{\"312\":1}}],[\"作为输入\",{\"1\":{\"277\":1}}],[\"作为模型的缓冲区注册\",{\"1\":{\"366\":1}}],[\"作为模型初始化\",{\"1\":{\"268\":1}}],[\"作为模型输入\",{\"1\":{\"186\":1}}],[\"作为初始化\",{\"1\":{\"268\":1}}],[\"作为初始输入\",{\"1\":{\"76\":1}}],[\"作为融合编码器使用\",{\"1\":{\"267\":1}}],[\"作为融合编码器的\",{\"1\":{\"260\":1}}],[\"作为双编码器比融合编码器更快\",{\"1\":{\"260\":1}}],[\"作为编码器\",{\"1\":{\"255\":1,\"326\":1}}],[\"作为视觉与llms之间的\",{\"1\":{\"196\":1}}],[\"作为教师\",{\"1\":{\"182\":2}}],[\"作为监督信号进行\",{\"1\":{\"165\":1}}],[\"作为结束标记\",{\"1\":{\"143\":1}}],[\"作为第二个\",{\"1\":{\"45\":1}}],[\"作为第一个\",{\"1\":{\"45\":1}}],[\"作为\",{\"0\":{\"635\":1},\"1\":{\"45\":1,\"143\":2,\"162\":1,\"163\":2,\"204\":2,\"250\":1,\"269\":2,\"309\":1,\"777\":1,\"802\":1}}],[\"作者再次使用了停止梯度算子\",{\"1\":{\"883\":1}}],[\"作者分别讨论了上面公式里的两个误差\",{\"1\":{\"882\":1}}],[\"作者发现\",{\"1\":{\"882\":1}}],[\"作者并不清楚是否已经有任何人从一般意义上证明了这一点\",{\"1\":{\"871\":1}}],[\"作者引入了\",{\"1\":{\"814\":1}}],[\"作者强调\",{\"1\":{\"539\":1,\"568\":1}}],[\"作者列出多个值得进一步研究的问题\",{\"1\":{\"539\":1}}],[\"作者建议未来采用更多元标注\",{\"1\":{\"539\":1}}],[\"作者清晰指出当前模型对齐行为的\",{\"1\":{\"539\":1}}],[\"作者采用了\",{\"1\":{\"535\":1}}],[\"作者称这些过程使得模型输出更符合人类偏好\",{\"1\":{\"535\":1}}],[\"作者借鉴了\",{\"1\":{\"531\":1}}],[\"作者首先展示了8个不同规模的模型在训练过程中的表现\",{\"1\":{\"529\":1}}],[\"作者首先定义了语言模型执行任务的四种方式\",{\"1\":{\"528\":1}}],[\"作者对common\",{\"1\":{\"528\":1}}],[\"作者对比了不同的\",{\"1\":{\"184\":1}}],[\"作者训练了从125m到175b参数的8个模型\",{\"1\":{\"528\":1}}],[\"作者训练流程有两个阶段\",{\"1\":{\"509\":1}}],[\"作者开放了模型代码和小型预训练模型\",{\"1\":{\"524\":1}}],[\"作者同时指出gpt\",{\"1\":{\"523\":1}}],[\"作者归因于该数据集的句子级打乱破坏了长程依赖\",{\"1\":{\"522\":1}}],[\"作者特别指出\",{\"1\":{\"522\":1}}],[\"作者指出\",{\"1\":{\"520\":1,\"521\":1,\"522\":1,\"530\":1,\"532\":1,\"535\":1,\"871\":1}}],[\"作者的工作表明\",{\"1\":{\"517\":1}}],[\"作者模型获得了重要的世界知识和处理长距离依赖的能力\",{\"1\":{\"517\":1}}],[\"作者介绍了一种框架\",{\"1\":{\"517\":1}}],[\"作者观察标准结果\",{\"1\":{\"516\":1}}],[\"作者修改输入序列来包含\",{\"1\":{\"512\":1}}],[\"作者额外要微调的参数只有\",{\"1\":{\"511\":1}}],[\"作者通过实验验证这一假设\",{\"1\":{\"520\":1}}],[\"作者通过fps来抽样点集中较为重要的点\",{\"1\":{\"89\":1}}],[\"作者通用的任务未知task\",{\"1\":{\"507\":1}}],[\"作者利用源于遍历式\",{\"1\":{\"507\":1}}],[\"作者假设采用一个大型无标记文本语料库和几个人工标记训练样本的数据集\",{\"1\":{\"507\":1}}],[\"作者用以下优化\",{\"1\":{\"511\":1}}],[\"作者用无监督的预训练和监督的微调组合来探索关于语言理解任务半监督方法\",{\"1\":{\"507\":1}}],[\"作者用交叉熵公式来解释\",{\"1\":{\"183\":1}}],[\"作者证明通过在丰富的无标签文本语料库生成预训练generative\",{\"1\":{\"506\":1}}],[\"作者又探索了一种混合模型\",{\"1\":{\"326\":1}}],[\"作者先是在imagenet21k上进行预训练\",{\"1\":{\"323\":1}}],[\"作者随后也对一维位置编码的结果进行了可视化\",{\"1\":{\"320\":1}}],[\"作者最终选择了对比学习方法来进行训练\",{\"1\":{\"305\":1}}],[\"作者提出一种通过人类反馈对模型进行微调的方法\",{\"1\":{\"534\":1}}],[\"作者提出\",{\"1\":{\"520\":1}}],[\"作者提出的vilt可以认为是目前最简单的多模态transformer方法\",{\"1\":{\"284\":1}}],[\"作者提出的vilt属于\",{\"1\":{\"282\":1}}],[\"作者提出这4种类型的主要依据有两点\",{\"1\":{\"282\":1}}],[\"作者提出了\",{\"1\":{\"173\":1}}],[\"作者提出了一个新的数据处理流程\",{\"1\":{\"128\":1}}],[\"作者提出了一个多任务模型架构\",{\"1\":{\"126\":1}}],[\"作者提出了一个统一的视觉语言预训练框架\",{\"1\":{\"125\":1}}],[\"作者说到\",{\"1\":{\"250\":1}}],[\"作者认为\",{\"1\":{\"520\":1,\"530\":1,\"871\":1}}],[\"作者认为大规模数据没有被充分利用\",{\"1\":{\"247\":1}}],[\"作者认为这是因为cv领域和nlp领域的原始信号空间不同\",{\"1\":{\"246\":1}}],[\"作者认为编码和解码之间的主要差异体现在\",{\"1\":{\"126\":1}}],[\"作者还发现加入语言模型作为辅助目标来微调有助于学习\",{\"1\":{\"511\":1}}],[\"作者还提出了一种创新方法\",{\"1\":{\"236\":1}}],[\"作者还构建了一个包含图像\",{\"1\":{\"48\":1}}],[\"作者使用遍历式方法\",{\"1\":{\"512\":1}}],[\"作者使用了一种巧妙的停止梯度算子\",{\"1\":{\"883\":1}}],[\"作者使用了谷歌制作的jft\",{\"1\":{\"324\":1}}],[\"作者使用了四个核心评估指标来衡量模型对语言引导下功能区域的识别能力\",{\"1\":{\"82\":1}}],[\"作者使用的是大规模图文对数据集\",{\"1\":{\"234\":1}}],[\"作者确定了在性能和效率之间取得平衡的最佳配置\",{\"1\":{\"197\":1}}],[\"作者将vit和之前图像分类领域比较强的resnet模型进行了对比测试\",{\"1\":{\"324\":1}}],[\"作者将模型训练分为两个阶段\",{\"1\":{\"233\":1}}],[\"作者将动量教师解释为一种\",{\"1\":{\"182\":1}}],[\"作者将通过\",{\"1\":{\"128\":1}}],[\"作者推测英语语言模型的强大概率补偿了翻译知识的不足\",{\"1\":{\"522\":1}}],[\"作者推测\",{\"1\":{\"133\":1}}],[\"作者在微调时用辅助的lm目标来检查作者模型的性能\",{\"1\":{\"516\":1}}],[\"作者在微调阶段使用任务感知的输入转换来实现有效的迁移\",{\"1\":{\"506\":1}}],[\"作者在下面部分和可视化插图\",{\"1\":{\"512\":1}}],[\"作者在监督学习目标任务上调整参数\",{\"1\":{\"511\":1}}],[\"作者在四种类型的语言理解任务评估作者的方法\",{\"1\":{\"507\":1}}],[\"作者在常识推理\",{\"1\":{\"506\":1}}],[\"作者在不同模型深度\",{\"1\":{\"204\":1}}],[\"作者在模型中采用了\",{\"1\":{\"126\":1}}],[\"作者在提出的\",{\"1\":{\"21\":1}}],[\"作者设计了\",{\"1\":{\"71\":1}}],[\"作者设计了一个名为iag\",{\"1\":{\"48\":1}}],[\"作者设计了多个分析实验\",{\"1\":{\"25\":1}}],[\"定价为\",{\"1\":{\"704\":1}}],[\"定价降低约\",{\"1\":{\"704\":1}}],[\"定性分析与模型行为观察\",{\"1\":{\"538\":1}}],[\"定理\",{\"0\":{\"384\":1}}],[\"定理表明\",{\"1\":{\"105\":1}}],[\"定义损失函数\",{\"0\":{\"854\":1}}],[\"定义它们的平均分布\",{\"1\":{\"836\":1}}],[\"定义似然函数\",{\"1\":{\"825\":1}}],[\"定义如下\",{\"1\":{\"752\":1}}],[\"定义在实数上的连续分布\",{\"0\":{\"745\":1}}],[\"定义失败为红球\",{\"0\":{\"741\":1}}],[\"定义随机变量\",{\"1\":{\"727\":1}}],[\"定义事件空间后\",{\"1\":{\"727\":1}}],[\"定义节点id为1\",{\"1\":{\"696\":1}}],[\"定义包含节点x和y的有向图\",{\"1\":{\"696\":1}}],[\"定义短距离线性映射的阈值\",{\"1\":{\"591\":1}}],[\"定义相对位置为\",{\"1\":{\"591\":1}}],[\"定义相似度函数为\",{\"1\":{\"154\":1}}],[\"定义字典保存路径\",{\"1\":{\"578\":1}}],[\"定义为每个子像素出现概率的乘积\",{\"1\":{\"847\":1}}],[\"定义为\",{\"1\":{\"473\":1,\"737\":1,\"738\":1,\"746\":2,\"748\":2,\"749\":1,\"752\":1,\"795\":1}}],[\"定义时\",{\"1\":{\"337\":1}}],[\"定义注意力矩阵的丢弃层\",{\"1\":{\"322\":1}}],[\"定义一个线性层\",{\"1\":{\"322\":1}}],[\"定义一个二维卷积层\",{\"1\":{\"318\":1}}],[\"定义一个字典\",{\"1\":{\"317\":1}}],[\"定义当前目录\",{\"1\":{\"302\":1,\"304\":1}}],[\"定义卷积层\",{\"1\":{\"272\":1}}],[\"定义\",{\"0\":{\"752\":1,\"853\":1,\"859\":1},\"1\":{\"239\":1,\"392\":1,\"393\":1,\"470\":1,\"727\":1}}],[\"定义与核心思想\",{\"1\":{\"239\":1}}],[\"定义的一个结构体\",{\"1\":{\"163\":1}}],[\"定义局部区域的形心\",{\"1\":{\"88\":1}}],[\"定义投影层的丢弃层\",{\"1\":{\"322\":1}}],[\"定义投影层\",{\"1\":{\"45\":1,\"322\":1}}],[\"定位答案\",{\"1\":{\"616\":1}}],[\"定位交互部位\",{\"1\":{\"28\":1}}],[\"定位交互部件并分析几何结构\",{\"1\":{\"6\":1}}],[\"定位交互发生的对象区域\",{\"1\":{\"28\":1}}],[\"定位精度显著更高\",{\"1\":{\"23\":1}}],[\"定位\",{\"1\":{\"7\":1}}],[\"调节随机性\",{\"1\":{\"820\":1}}],[\"调节因子\",{\"1\":{\"470\":1}}],[\"调试和测试\",{\"1\":{\"715\":1}}],[\"调试便捷\",{\"1\":{\"692\":1}}],[\"调度器\",{\"1\":{\"186\":1}}],[\"调整的过程\",{\"1\":{\"497\":1}}],[\"调整为适合下游任务的\",{\"1\":{\"490\":1}}],[\"调整大小\",{\"1\":{\"463\":1}}],[\"调整后的\",{\"1\":{\"427\":1}}],[\"调整以下三个要素来创建一个新的视图\",{\"1\":{\"425\":1}}],[\"调整某一系数会影响整个函数\",{\"1\":{\"385\":1}}],[\"调整某一系数会影响全局拟合\",{\"1\":{\"385\":1}}],[\"调整位置编码以适配不同尺度\",{\"1\":{\"179\":1}}],[\"调整维度以便加到注意力分数\",{\"1\":{\"591\":1}}],[\"调整维度\",{\"1\":{\"101\":1,\"272\":1,\"591\":1}}],[\"调整输出格式为\",{\"1\":{\"45\":1}}],[\"调整\",{\"1\":{\"45\":1,\"561\":1}}],[\"调用父类\",{\"1\":{\"848\":1}}],[\"调用函数或工具\",{\"1\":{\"714\":1}}],[\"调用x\",{\"1\":{\"690\":1}}],[\"调用方法\",{\"1\":{\"347\":1}}],[\"调用后\",{\"1\":{\"339\":1,\"343\":2,\"351\":1}}],[\"调用前\",{\"1\":{\"339\":1,\"343\":2,\"351\":1}}],[\"调用时\",{\"1\":{\"337\":1}}],[\"调用q\",{\"1\":{\"313\":1}}],[\"调用bertmodel\",{\"1\":{\"295\":1}}],[\"调用子数据模块的\",{\"1\":{\"274\":1}}],[\"调用每个子数据模块的\",{\"1\":{\"274\":1}}],[\"调用所有\",{\"1\":{\"273\":1}}],[\"调用跨模态解码器\",{\"1\":{\"142\":1}}],[\"调用\",{\"1\":{\"40\":1,\"111\":1,\"163\":1,\"169\":1,\"274\":4,\"275\":1,\"276\":1,\"312\":2,\"353\":1,\"396\":1}}],[\"来算梯度\",{\"1\":{\"881\":1}}],[\"来控制建模精度\",{\"1\":{\"873\":1}}],[\"来控制是否只用图像作为输入\",{\"1\":{\"274\":1}}],[\"来理解公式\",{\"1\":{\"872\":1}}],[\"来理解语言\",{\"1\":{\"703\":1}}],[\"来重建训练数据\",{\"1\":{\"869\":1}}],[\"来估计\",{\"1\":{\"867\":1}}],[\"来保证输出尺寸与输入一致\",{\"1\":{\"848\":1}}],[\"来近似\",{\"1\":{\"831\":1}}],[\"来进行条件\",{\"1\":{\"817\":1}}],[\"来熟悉模型中使用到的一些参数及其含义\",{\"1\":{\"814\":1}}],[\"来对从\",{\"1\":{\"811\":1}}],[\"来对齐视觉和语言模型的特征\",{\"1\":{\"189\":1}}],[\"来学习会引入误差\",{\"1\":{\"871\":1}}],[\"来学习文本与图像\",{\"1\":{\"809\":1}}],[\"来学习优化的策略\",{\"1\":{\"95\":1}}],[\"来建模文本和图像\",{\"1\":{\"807\":1}}],[\"来汇聚所有\",{\"1\":{\"776\":1}}],[\"来作为掩码位置\",{\"1\":{\"772\":1}}],[\"来优化模型参数\",{\"1\":{\"770\":1}}],[\"来定义模型\",{\"1\":{\"874\":1}}],[\"来定义事件空间\",{\"1\":{\"728\":1}}],[\"来定位图像中的物体区域\",{\"1\":{\"280\":1}}],[\"来提升系统效果\",{\"1\":{\"717\":1}}],[\"来提升应用性能\",{\"1\":{\"717\":1}}],[\"来提升模型在特定任务上的表现\",{\"1\":{\"711\":1}}],[\"来满足验证集效果\",{\"1\":{\"716\":1}}],[\"来解决任务\",{\"1\":{\"716\":1}}],[\"来替代子模型的训练调优\",{\"1\":{\"716\":1}}],[\"来开发基于大型语言模型的应用程序\",{\"1\":{\"712\":1}}],[\"来为序列的不同位置提供唯一的编码\",{\"1\":{\"587\":1}}],[\"来完成\",{\"1\":{\"544\":1}}],[\"来完成点云物体分割任务\",{\"1\":{\"111\":1}}],[\"来完成点云分类任务\",{\"1\":{\"110\":1}}],[\"来挑选具有敏感内容识别能力的标注者\",{\"1\":{\"537\":1}}],[\"来隐式学习任务\",{\"1\":{\"521\":1}}],[\"来指定\",{\"1\":{\"521\":1}}],[\"来限制语言模型的输出分布只有\",{\"1\":{\"516\":1}}],[\"来正则化\",{\"1\":{\"514\":1}}],[\"来正常获取一个批次的数据了\",{\"1\":{\"274\":1}}],[\"来最终得到复杂问题的结果\",{\"1\":{\"503\":1}}],[\"来引导llm展现出更好的推理能力\",{\"1\":{\"501\":1}}],[\"来间接训练神经网络中的一些密集层\",{\"1\":{\"491\":1}}],[\"来减少模型对于计算资源的需求的方法\",{\"1\":{\"488\":1}}],[\"来命名环境\",{\"1\":{\"431\":1}}],[\"来读取数据\",{\"1\":{\"426\":1}}],[\"来增加表达能力\",{\"1\":{\"385\":1}}],[\"来扩大逼近空间的容量\",{\"1\":{\"385\":1}}],[\"来接收和返回函数\",{\"1\":{\"341\":1}}],[\"来帮助大家梳理清楚vision\",{\"1\":{\"315\":1}}],[\"来预测mask的\",{\"1\":{\"285\":1}}],[\"来计算textual\",{\"1\":{\"285\":1}}],[\"来说\",{\"1\":{\"250\":1,\"492\":1}}],[\"来训练模型\",{\"1\":{\"248\":1}}],[\"来适配不同类别\",{\"1\":{\"239\":1}}],[\"来生成图文结合的指令响应对\",{\"1\":{\"232\":1}}],[\"来实现大语言模型的控制\",{\"1\":{\"716\":1}}],[\"来实现数据的压缩\",{\"1\":{\"495\":1}}],[\"来实现\",{\"1\":{\"232\":1}}],[\"来实现全局信息建模\",{\"1\":{\"73\":1}}],[\"来稳定训练\",{\"1\":{\"186\":1}}],[\"来避免这两类崩溃\",{\"1\":{\"183\":1}}],[\"来简化特征质量评估\",{\"1\":{\"179\":1}}],[\"来更新我们对未知变量\",{\"1\":{\"734\":1}}],[\"来更新的\",{\"1\":{\"176\":1}}],[\"来更新分组特征\",{\"1\":{\"73\":1}}],[\"来约束特征学习\",{\"1\":{\"175\":1}}],[\"来找最近中心\",{\"1\":{\"170\":1}}],[\"来表示整句话的语义\",{\"1\":{\"126\":1}}],[\"来表达各种线性代数运算\",{\"1\":{\"76\":1}}],[\"来模拟不同的采样密度\",{\"1\":{\"96\":1}}],[\"来构建局部区域点集\",{\"1\":{\"88\":1}}],[\"来自后验近似\",{\"1\":{\"872\":1}}],[\"来自先验分布\",{\"1\":{\"872\":1}}],[\"来自一个简单的分布\",{\"1\":{\"866\":1}}],[\"来自真实图像\",{\"1\":{\"817\":1}}],[\"来自图像\",{\"1\":{\"294\":1}}],[\"来自文本\",{\"1\":{\"294\":1}}],[\"来自视觉模型\",{\"1\":{\"290\":1}}],[\"来自动量编码器\",{\"1\":{\"163\":1}}],[\"来自下一级的特征\",{\"1\":{\"97\":1}}],[\"来自论文的理论分析\",{\"1\":{\"112\":1}}],[\"来自论文\",{\"1\":{\"82\":1}}],[\"来自论文图3\",{\"0\":{\"67\":1}}],[\"来自\",{\"1\":{\"46\":2,\"67\":1,\"98\":1,\"163\":1,\"234\":1,\"293\":1,\"398\":1,\"590\":2,\"773\":1,\"821\":1}}],[\"来源于真实\",{\"1\":{\"539\":1}}],[\"来源之二\",{\"1\":{\"45\":1}}],[\"来源之一\",{\"1\":{\"45\":1}}],[\"来源\",{\"1\":{\"45\":1}}],[\"来标记哪些多模态\",{\"1\":{\"43\":1}}],[\"来推断交互可能性\",{\"1\":{\"32\":1}}],[\"都差不多\",{\"1\":{\"882\":1}}],[\"都由神经网络实现\",{\"1\":{\"868\":1}}],[\"都成立\",{\"1\":{\"839\":1}}],[\"都很敏感\",{\"1\":{\"802\":1}}],[\"都可以提供对应的解决方案\",{\"1\":{\"712\":1}}],[\"都可以归纳为一种字典查询的工作\",{\"1\":{\"246\":1}}],[\"都使用了残差连接和层归一化\",{\"1\":{\"622\":1}}],[\"都单独构造一个\",{\"1\":{\"618\":1}}],[\"都等于max\",{\"1\":{\"594\":1}}],[\"都对应一个可学习的向量\",{\"1\":{\"588\":1}}],[\"都无所谓\",{\"1\":{\"572\":1}}],[\"都要\",{\"1\":{\"544\":1}}],[\"都随着模型参数的增长而呈现平滑的幂律提升趋势\",{\"1\":{\"529\":1}}],[\"都预测为负类别\",{\"1\":{\"443\":1}}],[\"都需要进行有监督微调\",{\"1\":{\"305\":1}}],[\"都处理文本+图像的联合序列\",{\"1\":{\"276\":1}}],[\"都存到了一起\",{\"1\":{\"250\":1}}],[\"都是比特\",{\"1\":{\"873\":1}}],[\"都是高斯分布\",{\"1\":{\"871\":1}}],[\"都是高阶函数\",{\"1\":{\"339\":1}}],[\"都是在没有调整温度\",{\"1\":{\"811\":1}}],[\"都是在寻找最相关的\",{\"1\":{\"412\":1}}],[\"都是有足够资源的来开发大模型\",{\"1\":{\"491\":1}}],[\"都是有效的\",{\"1\":{\"43\":1}}],[\"都是一个非线性变换\",{\"1\":{\"385\":1}}],[\"都是197\",{\"1\":{\"321\":1}}],[\"都是从同一个\",{\"1\":{\"250\":1}}],[\"都展现出更强的像素级感知能力\",{\"1\":{\"201\":1}}],[\"都能接收相同的图像信息\",{\"1\":{\"143\":1}}],[\"都有一个对应的\",{\"1\":{\"614\":1}}],[\"都有一个\",{\"1\":{\"544\":1}}],[\"都有一个低维的本质模型\",{\"1\":{\"487\":1}}],[\"都有一个唯一的地址\",{\"1\":{\"421\":1}}],[\"都有机会执行\",{\"1\":{\"290\":1}}],[\"都有\",{\"1\":{\"115\":1}}],[\"都有效\",{\"1\":{\"43\":1,\"272\":1}}],[\"都尝试引入更复杂的结构来提升建模能力\",{\"1\":{\"112\":1}}],[\"都会非常接近于\",{\"1\":{\"867\":1}}],[\"都会乘以相同的输入\",{\"1\":{\"492\":1}}],[\"都会对输入序列的长度有限制\",{\"1\":{\"482\":1}}],[\"都会处理一部分\",{\"1\":{\"257\":1}}],[\"都会被压缩为一个固定长度的特征向量\",{\"1\":{\"92\":1}}],[\"都会基于其语言语义\",{\"1\":{\"76\":1}}],[\"都与所有点\",{\"1\":{\"76\":1}}],[\"都带有原始语言上下文\",{\"1\":{\"76\":1}}],[\"则先验分布\",{\"1\":{\"881\":1}}],[\"则先用全零矩阵占位\",{\"1\":{\"169\":1}}],[\"则分布中仅有\",{\"1\":{\"881\":1}}],[\"则输出的是像素取某个颜色的概率分布\",{\"1\":{\"847\":1}}],[\"则输出为常量\",{\"1\":{\"183\":1}}],[\"则正面挑战了建立概率模型这一任务\",{\"1\":{\"847\":1}}],[\"则似然函数为\",{\"1\":{\"826\":1}}],[\"则归一化输出\",{\"1\":{\"820\":1}}],[\"则裁剪掉最后一个\",{\"1\":{\"815\":1}}],[\"则整条\",{\"1\":{\"815\":1}}],[\"则设为总遮挡目标数\",{\"1\":{\"801\":1}}],[\"则构造成正方形大小的\",{\"1\":{\"801\":1}}],[\"则直接返回\",{\"1\":{\"794\":1}}],[\"则直接加载预训练的\",{\"1\":{\"169\":1}}],[\"则用来指代那些使用概率理论来表示\",{\"1\":{\"758\":1}}],[\"则二项分布退化为伯努利分布\",{\"1\":{\"737\":1}}],[\"则称\",{\"1\":{\"730\":2}}],[\"则定义事件\",{\"1\":{\"730\":1}}],[\"则复合事件的概率可通过求和得到\",{\"1\":{\"727\":1}}],[\"则安装成功\",{\"1\":{\"696\":1}}],[\"则调用b\",{\"1\":{\"690\":1}}],[\"则尝试调用右操作数b的\",{\"1\":{\"690\":1}}],[\"则反向传播后清除中间变量的导数\",{\"1\":{\"688\":1}}],[\"则将其概率分布中的文本词索引空间对应的概率分布设置为0\",{\"1\":{\"814\":1}}],[\"则将其概率分布中的离散视觉词索引空间对应的概率分布设置为0\",{\"1\":{\"814\":1}}],[\"则将其设置为\",{\"1\":{\"615\":2}}],[\"则将其转换为\",{\"1\":{\"318\":1}}],[\"则生成的pad\",{\"1\":{\"584\":1}}],[\"则写出听起来\",{\"1\":{\"538\":1}}],[\"则容易自信地给出错误答案\",{\"1\":{\"538\":1}}],[\"则\",{\"1\":{\"492\":1,\"493\":1,\"587\":1,\"655\":1,\"690\":1,\"727\":1,\"728\":1,\"826\":1,\"866\":1}}],[\"则它的参数量\",{\"1\":{\"492\":1}}],[\"则在这里激活\",{\"1\":{\"469\":1,\"470\":1}}],[\"则应注释掉这一行\",{\"1\":{\"468\":1,\"469\":1}}],[\"则点\",{\"1\":{\"453\":1}}],[\"则可能有必要选择\",{\"1\":{\"453\":1}}],[\"则可以用\",{\"1\":{\"450\":1}}],[\"则其概率质量函数\",{\"1\":{\"739\":1}}],[\"则其补集\",{\"1\":{\"728\":1}}],[\"则其\",{\"1\":{\"451\":1}}],[\"则其假正例数为零\",{\"1\":{\"446\":1}}],[\"则其准确性得分为\",{\"1\":{\"443\":1}}],[\"则最好改为针对其他指标进行优化\",{\"1\":{\"443\":1}}],[\"则表示数据集不平衡\",{\"1\":{\"442\":1}}],[\"则表示图像块是正方形\",{\"1\":{\"318\":1}}],[\"则表示图像是正方形\",{\"1\":{\"318\":1}}],[\"则会调用右操作数b的\",{\"1\":{\"690\":1}}],[\"则会得到以下表格\",{\"1\":{\"442\":1}}],[\"则会因\",{\"1\":{\"134\":1}}],[\"则需要更新预训练模型参数\",{\"1\":{\"492\":1}}],[\"则需要在这里激活\",{\"1\":{\"467\":1}}],[\"则需要使用不同的工具\",{\"1\":{\"449\":1}}],[\"则需要再多一层函数嵌套\",{\"1\":{\"345\":1}}],[\"则需要将图像特征复制\",{\"1\":{\"143\":1}}],[\"则创建线性分类头\",{\"1\":{\"323\":1}}],[\"则默认为\",{\"1\":{\"321\":2}}],[\"则默认多模态\",{\"1\":{\"43\":1}}],[\"则对图像进行处理\",{\"1\":{\"316\":1}}],[\"则对整个点云做全局特征提取\",{\"1\":{\"92\":1}}],[\"则计算当前层bertlayer时\",{\"1\":{\"312\":1}}],[\"则q来自query\",{\"1\":{\"312\":1}}],[\"则自动生成\",{\"1\":{\"311\":1}}],[\"则采用了两种不同的架构\",{\"1\":{\"299\":1}}],[\"则是以文本作为监督信号\",{\"1\":{\"297\":1}}],[\"则单独为\",{\"1\":{\"272\":1}}],[\"则覆盖\",{\"1\":{\"272\":1}}],[\"则加上\",{\"1\":{\"272\":2}}],[\"则加载多语言\",{\"1\":{\"208\":1}}],[\"则使用其打分\",{\"1\":{\"817\":1}}],[\"则使用unk替换\",{\"1\":{\"578\":1}}],[\"则使用beam\",{\"1\":{\"528\":1}}],[\"则使用默认的\",{\"1\":{\"323\":1}}],[\"则使用默认的缩放因子\",{\"1\":{\"322\":1}}],[\"则使用该层进行归一化\",{\"1\":{\"318\":2}}],[\"则使用来自文献\",{\"1\":{\"199\":1}}],[\"则使用\",{\"1\":{\"170\":1,\"323\":1}}],[\"则保留原中心不变\",{\"1\":{\"170\":1}}],[\"则保存\",{\"1\":{\"82\":1}}],[\"则跳过\",{\"1\":{\"169\":1}}],[\"则从最后一层开始使用\",{\"1\":{\"272\":1}}],[\"则从已有\",{\"1\":{\"169\":1}}],[\"则从问题1～15中随机选择一个问题\",{\"1\":{\"68\":1}}],[\"则按给定的概率矩阵进行伯努利采样\",{\"1\":{\"163\":1}}],[\"则做\",{\"1\":{\"162\":1}}],[\"则为\",{\"1\":{\"161\":1}}],[\"则视为\",{\"1\":{\"156\":1}}],[\"则基于高质量人工标注的数据集如\",{\"1\":{\"140\":1}}],[\"则模型体积大\",{\"1\":{\"134\":1}}],[\"则认为是噪声文本\",{\"1\":{\"128\":1}}],[\"则返回所有样本损失的平均值\",{\"1\":{\"471\":1,\"473\":1}}],[\"则返回\",{\"1\":{\"109\":2}}],[\"则返回该问题文本\",{\"1\":{\"68\":1}}],[\"则拼接起来\",{\"1\":{\"100\":1}}],[\"则进行额外处理\",{\"1\":{\"40\":1}}],[\"插件系统\",{\"1\":{\"704\":1}}],[\"插值到原始图像尺寸\",{\"1\":{\"463\":2}}],[\"插值公式\",{\"1\":{\"390\":1}}],[\"插值\",{\"0\":{\"389\":1,\"390\":1}}],[\"插值方式\",{\"1\":{\"388\":1}}],[\"插值并融合后的特征\",{\"1\":{\"100\":1}}],[\"插值得到的密集特征\",{\"1\":{\"98\":1}}],[\"插值阶段\",{\"1\":{\"30\":1}}],[\"插入对应层的list缓存中去\",{\"1\":{\"544\":1}}],[\"插入缓存中\",{\"1\":{\"544\":1}}],[\"插入新维度的位置\",{\"1\":{\"358\":1}}],[\"插入到了\",{\"1\":{\"199\":1}}],[\"插入异常点\",{\"1\":{\"112\":1}}],[\"插入批次索引\",{\"1\":{\"59\":1}}],[\"插入的多模态嵌入\",{\"1\":{\"43\":1}}],[\"非负\",{\"1\":{\"736\":1}}],[\"非负性\",{\"1\":{\"729\":1}}],[\"非负整数\",{\"1\":{\"590\":1}}],[\"非负整数张量\",{\"1\":{\"377\":1}}],[\"非负整数张量input\",{\"1\":{\"377\":1}}],[\"非多任务学习\",{\"1\":{\"561\":1}}],[\"非英语泛化能力未系统评估\",{\"1\":{\"539\":1}}],[\"非英语指令等非监督数据上表现较好\",{\"1\":{\"538\":1}}],[\"非英语指令\",{\"1\":{\"538\":1}}],[\"非功能区域\",{\"1\":{\"470\":1}}],[\"非目标点\",{\"1\":{\"470\":1}}],[\"非目标区域匹配度\",{\"1\":{\"78\":1}}],[\"非对角元素\",{\"1\":{\"459\":1}}],[\"非对角线元素为\",{\"1\":{\"752\":1}}],[\"非对角线\",{\"1\":{\"455\":1}}],[\"非对角线上的元素\",{\"1\":{\"455\":1}}],[\"非垃圾邮件被正确分类为非垃圾邮件\",{\"1\":{\"442\":1}}],[\"非垃圾邮件被误分类为垃圾邮件\",{\"1\":{\"442\":1}}],[\"非连续\",{\"1\":{\"361\":1}}],[\"非常值得深入理解\",{\"1\":{\"867\":1}}],[\"非常小\",{\"1\":{\"866\":1}}],[\"非常接近了\",{\"1\":{\"843\":1}}],[\"非常适合比较模型\",{\"1\":{\"452\":1}}],[\"非常高\",{\"1\":{\"307\":2}}],[\"非常有效\",{\"1\":{\"272\":1}}],[\"非训练模式下统计码本使用情况\",{\"1\":{\"170\":1}}],[\"非梯度更新\",{\"1\":{\"170\":1}}],[\"非动量\",{\"1\":{\"163\":1}}],[\"非标答案\",{\"1\":{\"157\":1}}],[\"非均匀\",{\"1\":{\"116\":1}}],[\"非均匀密度下稳定的特征学习\",{\"0\":{\"94\":1}}],[\"非刚性运动\",{\"1\":{\"116\":1}}],[\"非刚性变形\",{\"1\":{\"112\":1}}],[\"非结构化\",{\"1\":{\"114\":1}}],[\"非线性替换为\",{\"1\":{\"704\":1}}],[\"非线性激活后的基\",{\"1\":{\"385\":1}}],[\"非线性变换\",{\"1\":{\"59\":1,\"289\":1,\"295\":1}}],[\"非线性增强和空间对齐\",{\"1\":{\"41\":2}}],[\"非\",{\"1\":{\"43\":1,\"163\":1,\"312\":1,\"438\":1,\"818\":1,\"821\":1}}],[\"供离散\",{\"1\":{\"803\":1}}],[\"供后续\",{\"1\":{\"277\":2}}],[\"供\",{\"1\":{\"43\":1,\"803\":1,\"814\":1}}],[\"默认从\",{\"1\":{\"820\":1}}],[\"默认采样前\",{\"1\":{\"817\":1}}],[\"默认采用gelu激活函数\",{\"1\":{\"295\":1}}],[\"默认行为\",{\"1\":{\"804\":1}}],[\"默认与\",{\"1\":{\"801\":1}}],[\"默认取\",{\"1\":{\"801\":1}}],[\"默认等于\",{\"1\":{\"801\":1}}],[\"默认优先级为100\",{\"1\":{\"690\":1}}],[\"默认模式\",{\"1\":{\"688\":1}}],[\"默认接受并执行\",{\"1\":{\"538\":1}}],[\"默认情况下\",{\"1\":{\"500\":1}}],[\"默认要求\",{\"1\":{\"468\":1}}],[\"默认仓库\",{\"1\":{\"438\":1}}],[\"默认会展平为\",{\"1\":{\"372\":1}}],[\"默认会忽略标签为\",{\"1\":{\"163\":1}}],[\"默认是\",{\"1\":{\"358\":1,\"371\":1}}],[\"默认使用行优先方式\",{\"1\":{\"422\":1}}],[\"默认使用\",{\"1\":{\"321\":1}}],[\"默认忽略的标签值\",{\"1\":{\"312\":1}}],[\"默认不计算\",{\"1\":{\"277\":1}}],[\"默认归一化层\",{\"1\":{\"272\":1}}],[\"默认16x16\",{\"1\":{\"272\":1}}],[\"默认224x224\",{\"1\":{\"272\":1}}],[\"默认用欧氏距离\",{\"1\":{\"170\":1}}],[\"默认\",{\"1\":{\"147\":1,\"160\":2,\"185\":1,\"332\":2,\"366\":1,\"374\":1,\"388\":2,\"398\":2,\"688\":1,\"793\":1,\"814\":1}}],[\"默认为0\",{\"1\":{\"322\":2}}],[\"默认为false\",{\"1\":{\"322\":1}}],[\"默认为8\",{\"1\":{\"322\":1}}],[\"默认为\",{\"1\":{\"142\":1,\"272\":1,\"316\":1,\"318\":5,\"467\":1,\"468\":1,\"469\":1,\"470\":1}}],[\"默认为全\",{\"1\":{\"43\":1}}],[\"默认有\",{\"1\":{\"93\":1}}],[\"默认图像注意力掩码为空\",{\"1\":{\"40\":1}}],[\"形如\",{\"1\":{\"821\":1}}],[\"形\",{\"1\":{\"594\":1}}],[\"形式传进去\",{\"1\":{\"799\":1}}],[\"形式化地\",{\"1\":{\"769\":1}}],[\"形式和内容高度敏感\",{\"1\":{\"530\":1}}],[\"形式存储和计算\",{\"1\":{\"495\":1}}],[\"形式\",{\"1\":{\"476\":1,\"618\":1,\"807\":1}}],[\"形式的监督信号\",{\"1\":{\"159\":1}}],[\"形式为\",{\"1\":{\"78\":1,\"579\":1}}],[\"形心点的坐标来实现\",{\"1\":{\"91\":1}}],[\"形成量化后的表示\",{\"1\":{\"885\":1}}],[\"形成离散化的语义表示\",{\"1\":{\"766\":1}}],[\"形成了一个具备如下特征的微型深度学习框架\",{\"1\":{\"700\":1}}],[\"形成复合函数\",{\"1\":{\"646\":1}}],[\"形成集合\",{\"1\":{\"178\":1}}],[\"形成簇成员集合\",{\"1\":{\"170\":1}}],[\"形成多尺度特征表示\",{\"1\":{\"98\":1}}],[\"形成最终的局部特征表示\",{\"1\":{\"96\":1}}],[\"形成最终的局部区域表示\",{\"1\":{\"92\":1}}],[\"形成\",{\"1\":{\"92\":1,\"145\":1}}],[\"形成一个连续的一维空间\",{\"1\":{\"421\":1}}],[\"形成一个特征向量\",{\"1\":{\"97\":1}}],[\"形成一个综合的多尺度特征表示\",{\"1\":{\"95\":1}}],[\"形成一个新的子集\",{\"1\":{\"92\":1}}],[\"形成一个类似于\",{\"1\":{\"73\":1}}],[\"形成更稳定的联合表示\",{\"1\":{\"41\":1}}],[\"形状不自然\",{\"1\":{\"806\":1}}],[\"形状和数据类型\",{\"1\":{\"696\":1}}],[\"形状如\",{\"1\":{\"471\":1,\"473\":1}}],[\"形状由\",{\"1\":{\"376\":1}}],[\"形状相同的张量\",{\"1\":{\"373\":1}}],[\"形状是\",{\"1\":{\"310\":1}}],[\"形状通常为\",{\"1\":{\"276\":1}}],[\"形状与\",{\"1\":{\"98\":1,\"471\":1,\"473\":1,\"591\":1}}],[\"形状也为\",{\"1\":{\"78\":1}}],[\"形状\",{\"1\":{\"76\":4,\"100\":5,\"101\":2,\"160\":1,\"170\":1,\"313\":1,\"388\":1,\"423\":2,\"425\":2,\"428\":1,\"455\":1,\"591\":3,\"614\":2,\"821\":3}}],[\"形状多样\",{\"1\":{\"71\":1}}],[\"形状的一维数组\",{\"1\":{\"64\":1}}],[\"形状为\",{\"1\":{\"43\":1,\"78\":1,\"83\":1,\"318\":2,\"426\":1,\"427\":1,\"467\":2,\"468\":2,\"469\":2,\"470\":2,\"821\":2}}],[\"层控制像素生成顺序\",{\"1\":{\"848\":1}}],[\"层自注意力层中的任一层都可以访问所有文本\",{\"1\":{\"809\":1}}],[\"层面借用\",{\"1\":{\"788\":1}}],[\"层共享权重\",{\"1\":{\"580\":1}}],[\"层与\",{\"1\":{\"580\":1}}],[\"层有自注意力头\",{\"1\":{\"514\":1}}],[\"层relu网络可生成\",{\"1\":{\"385\":1}}],[\"层网络的输出是多次复合的结果\",{\"1\":{\"385\":1}}],[\"层交错堆叠\",{\"1\":{\"326\":1}}],[\"层和\",{\"1\":{\"326\":1}}],[\"层和后\",{\"1\":{\"152\":1}}],[\"层处理后的输出\",{\"1\":{\"321\":1}}],[\"层的作用\",{\"1\":{\"614\":1}}],[\"层的\",{\"1\":{\"277\":1,\"774\":1}}],[\"层的输出作为起点\",{\"1\":{\"277\":1}}],[\"层类型\",{\"1\":{\"272\":1}}],[\"层数的迁移学习影响\",{\"1\":{\"516\":1}}],[\"层数\",{\"1\":{\"272\":1,\"385\":1,\"814\":1,\"822\":2}}],[\"层中\",{\"1\":{\"268\":1}}],[\"层中的视觉语言专家时\",{\"1\":{\"268\":1}}],[\"层或\",{\"1\":{\"204\":1}}],[\"层明显优于传统\",{\"1\":{\"204\":1}}],[\"层也能取得良好效果\",{\"1\":{\"198\":1}}],[\"层连接\",{\"1\":{\"198\":1}}],[\"层视觉\",{\"1\":{\"152\":1}}],[\"层不共享参数\",{\"1\":{\"134\":1}}],[\"层则可以共享\",{\"1\":{\"126\":1}}],[\"层以外的所有参数\",{\"1\":{\"126\":1}}],[\"层维度\",{\"1\":{\"112\":1}}],[\"层进一步融合局部\",{\"1\":{\"111\":1}}],[\"层后面都加了\",{\"1\":{\"107\":1}}],[\"层后的结果\",{\"1\":{\"43\":1}}],[\"层层插值并融合特征\",{\"1\":{\"101\":1}}],[\"层层下采样并提取特征\",{\"1\":{\"101\":1}}],[\"层\",{\"0\":{\"291\":1},\"1\":{\"99\":2,\"101\":4,\"109\":1,\"126\":1,\"134\":1,\"152\":2,\"199\":1,\"204\":1,\"210\":2,\"272\":1,\"321\":3,\"385\":1,\"467\":1,\"468\":1,\"469\":1,\"470\":1,\"580\":1,\"771\":1,\"772\":1,\"774\":1,\"814\":4}}],[\"层堆叠\",{\"1\":{\"98\":2}}],[\"层构成了一个\",{\"1\":{\"93\":1}}],[\"层提取特征\",{\"1\":{\"92\":1}}],[\"层次化结构由多个set\",{\"1\":{\"88\":1}}],[\"层次化点集特征学习\",{\"0\":{\"88\":1}}],[\"层归一化调整\",{\"1\":{\"521\":1}}],[\"层归一化来生成所有可能答案的分布\",{\"1\":{\"512\":1}}],[\"层归一化\",{\"1\":{\"45\":1,\"277\":2,\"514\":1,\"606\":1,\"631\":1}}],[\"层将计算结果映射至词表空间\",{\"1\":{\"541\":1}}],[\"层将\",{\"1\":{\"40\":1,\"313\":1}}],[\"应运而生\",{\"1\":{\"874\":1}}],[\"应对边界情况\",{\"1\":{\"717\":1}}],[\"应被及时回收\",{\"1\":{\"687\":1}}],[\"应为\",{\"1\":{\"426\":1}}],[\"应使用\",{\"0\":{\"137\":1}}],[\"应用贝叶斯公式\",{\"1\":{\"867\":1}}],[\"应用就可以上线体验了\",{\"1\":{\"717\":1}}],[\"应用程序的开发\",{\"1\":{\"715\":1}}],[\"应用程序的开发提供了坚实的基础\",{\"1\":{\"715\":1}}],[\"应用程序部署到云端\",{\"1\":{\"715\":1}}],[\"应用的复杂度\",{\"1\":{\"714\":1}}],[\"应用的开发和部署提供了坚实的基础\",{\"1\":{\"714\":1}}],[\"应用中的每一步操作及其输入输出有一个清晰的认识\",{\"1\":{\"714\":1}}],[\"应用开发的大一统基座模型\",{\"1\":{\"707\":1}}],[\"应用于真实的\",{\"1\":{\"539\":1}}],[\"应用层\",{\"0\":{\"504\":1}}],[\"应用量化低秩适应\",{\"1\":{\"495\":1}}],[\"应用自定义的权重初始化函数\",{\"1\":{\"323\":1}}],[\"应用注意力掩码\",{\"1\":{\"312\":1}}],[\"应用注意力权重\",{\"1\":{\"293\":1}}],[\"应用\",{\"1\":{\"294\":1,\"321\":1,\"455\":1,\"704\":2,\"712\":1,\"713\":1,\"804\":1,\"815\":1}}],[\"应用场景适应性受限\",{\"1\":{\"709\":1}}],[\"应用场景举例\",{\"1\":{\"239\":1}}],[\"应用场景\",{\"1\":{\"115\":1,\"470\":1}}],[\"应用到原始点云上\",{\"1\":{\"107\":1}}],[\"应用改良的交叉注意力机制\",{\"1\":{\"36\":1}}],[\"应该能生成\",{\"1\":{\"869\":1}}],[\"应该包含哪些信息\",{\"1\":{\"866\":1}}],[\"应该把\",{\"1\":{\"572\":1}}],[\"应该采用什么样的方法来进行训练\",{\"1\":{\"305\":1}}],[\"应该更高地加权第二个向量\",{\"1\":{\"97\":1}}],[\"应该关注哪些新能力\",{\"1\":{\"718\":1}}],[\"应该关注哪些点云点\",{\"1\":{\"41\":1}}],[\"应该关注图像中的哪些位置\",{\"1\":{\"41\":1}}],[\"每张图像包含成千上万个像素\",{\"1\":{\"864\":1}}],[\"每张图像生成一个序列\",{\"1\":{\"143\":1}}],[\"每批次的图像数量\",{\"1\":{\"803\":1}}],[\"每份采用不同的随机掩码模式\",{\"1\":{\"562\":1}}],[\"每生成一个新\",{\"1\":{\"544\":1}}],[\"每生成一个\",{\"1\":{\"542\":1}}],[\"每\",{\"1\":{\"541\":1}}],[\"每种异排列对应的全排列数\",{\"1\":{\"763\":2}}],[\"每种异排列对应的重复排列数\",{\"1\":{\"762\":2}}],[\"每种方法在不同任务上都优于其它方法\",{\"1\":{\"507\":1}}],[\"每种物体可以对应多种形状实例和功能类别\",{\"1\":{\"68\":2}}],[\"每家公司都去从头训练一个自己的大模型\",{\"1\":{\"482\":1}}],[\"每封电子邮件的实际分类取决于您选择的阈值\",{\"1\":{\"451\":1}}],[\"每隔一列\",{\"1\":{\"425\":1}}],[\"每隔一行\",{\"1\":{\"425\":1}}],[\"每行的总和表示所有预测正例\",{\"1\":{\"442\":1}}],[\"每行复制\",{\"1\":{\"364\":1}}],[\"每行是一个\",{\"1\":{\"41\":1}}],[\"每层卷积的中间通道数\",{\"1\":{\"848\":1}}],[\"每层卷积的通道数\",{\"1\":{\"793\":1}}],[\"每层是一次下采样或上采样\",{\"1\":{\"821\":1}}],[\"每层下采样一次\",{\"1\":{\"814\":1}}],[\"每层对应一个\",{\"1\":{\"385\":1}}],[\"每层聚焦不同抽象层次\",{\"1\":{\"385\":1}}],[\"每层\",{\"1\":{\"385\":1}}],[\"每层学习一个转折点\",{\"1\":{\"385\":1}}],[\"每层的通道数\",{\"1\":{\"821\":1}}],[\"每层的\",{\"1\":{\"272\":1}}],[\"每层逐步下采样\",{\"1\":{\"101\":1}}],[\"每次前向传播时将掩码乘到卷积核上\",{\"1\":{\"848\":1}}],[\"每次生成一张图片\",{\"1\":{\"847\":1}}],[\"每次生成一个遮挡块时\",{\"1\":{\"801\":1}}],[\"每次卷积后中心像素都会看漏一些信息\",{\"1\":{\"845\":1}}],[\"每次遮挡块最多的\",{\"1\":{\"801\":1}}],[\"每次遮挡一个矩形块区域\",{\"1\":{\"801\":1}}],[\"每次遮挡图像中的一个\",{\"1\":{\"772\":1}}],[\"每次取出辈分最大的函数\",{\"1\":{\"686\":1}}],[\"每次输入模型时动态生成掩码\",{\"1\":{\"562\":1}}],[\"每次输入序列时生成新的掩码模式\",{\"1\":{\"562\":1}}],[\"每次输入时重新生成掩码\",{\"1\":{\"560\":1}}],[\"每次调用函数都会创建一个新的局部作用域\",{\"1\":{\"336\":1}}],[\"每次计算后返回本次可能需要缓存的key\",{\"1\":{\"312\":1}}],[\"每次可以获取一条样本数据\",{\"1\":{\"274\":1}}],[\"每次一个\",{\"1\":{\"249\":1}}],[\"每次都是使用新的编码器更新\",{\"1\":{\"246\":1}}],[\"每次迭代更新学习率和权重衰减\",{\"1\":{\"186\":1}}],[\"每次迭代中\",{\"1\":{\"66\":1}}],[\"每轮推理时\",{\"1\":{\"544\":1}}],[\"每轮迭代更新\",{\"1\":{\"186\":1}}],[\"每轮只使用\",{\"1\":{\"131\":1}}],[\"每一步构造\",{\"1\":{\"817\":1}}],[\"每一列\",{\"1\":{\"591\":1}}],[\"每一小块大小不同\",{\"1\":{\"386\":1}}],[\"每一层transformer层能带来9\",{\"1\":{\"516\":1}}],[\"每一层的非线性变换\",{\"1\":{\"385\":1}}],[\"每一层只需学习局部特征\",{\"1\":{\"385\":1}}],[\"每一层\",{\"1\":{\"385\":1}}],[\"每一层bertlayer产生的key\",{\"1\":{\"312\":1}}],[\"每一个存储单元\",{\"1\":{\"421\":1}}],[\"每一个向量作为一个单独的输入\",{\"1\":{\"318\":1}}],[\"每一个patch作为一个token\",{\"1\":{\"318\":1}}],[\"每一行\",{\"1\":{\"591\":1}}],[\"每一行表示一张图像和所有文本之间的相似度\",{\"1\":{\"310\":1}}],[\"每一行对应一个向量\",{\"1\":{\"170\":1}}],[\"每一组在\",{\"1\":{\"186\":1}}],[\"每对图文样本只需通过一次视觉\",{\"1\":{\"127\":1}}],[\"每列是一个\",{\"1\":{\"41\":1,\"257\":1}}],[\"每个离散编码取到的概率是等同的\",{\"1\":{\"881\":1}}],[\"每个离散的数字都变成了一个特别的连续向量了\",{\"1\":{\"878\":1}}],[\"每个维度的含义或其之间的关系\",{\"1\":{\"866\":1}}],[\"每个维度上的\",{\"1\":{\"423\":1}}],[\"每个遮挡块最小\",{\"1\":{\"802\":1}}],[\"每个遮挡块最大\",{\"1\":{\"802\":1}}],[\"每个像素点是独立的伯努利分布\",{\"1\":{\"854\":1}}],[\"每个像素位置是一个\",{\"1\":{\"848\":1}}],[\"每个像素有\",{\"1\":{\"846\":1}}],[\"每个像素的值只能依赖于\",{\"1\":{\"846\":1}}],[\"每个像素的颜色取值只有\",{\"1\":{\"843\":1}}],[\"每个像素就已经看不到自己位置上的输入信息了\",{\"1\":{\"845\":1}}],[\"每个像素亮度相同\",{\"1\":{\"756\":1}}],[\"每个像素都被视为图像的基本单位\",{\"1\":{\"465\":1}}],[\"每个矩形代表了一个数据状态\",{\"1\":{\"712\":1}}],[\"每个椭圆形代表了\",{\"1\":{\"712\":1}}],[\"每个函数节点需要计算其导数\",{\"1\":{\"657\":1}}],[\"每个距离单独一个桶\",{\"1\":{\"591\":1}}],[\"每个距离有自己的偏置\",{\"1\":{\"591\":1}}],[\"每个桶每个头都有一个标量偏置\",{\"1\":{\"591\":1}}],[\"每个桶学一个标量偏置\",{\"1\":{\"591\":1}}],[\"每个元素是该相对位置对应的桶编号\",{\"1\":{\"591\":1}}],[\"每个元素是\",{\"1\":{\"591\":1}}],[\"每个元素都变成了\",{\"1\":{\"591\":1}}],[\"每个元素表示\",{\"1\":{\"591\":1}}],[\"每个元素表示对应样本被采样的概率权重\",{\"1\":{\"403\":1}}],[\"每个头64维\",{\"1\":{\"632\":1}}],[\"每个头有独立偏置\",{\"1\":{\"591\":1}}],[\"每个头的偏置可以不同\",{\"1\":{\"591\":1}}],[\"每个头的向量维度\",{\"1\":{\"590\":1}}],[\"每个头关注的区域或许不太一样\",{\"1\":{\"463\":1}}],[\"每个相对距离对应一个向量\",{\"1\":{\"590\":1}}],[\"每个位置被替换为最接近的\",{\"1\":{\"885\":1}}],[\"每个位置预留一个特殊\",{\"1\":{\"814\":1}}],[\"每个位置是\",{\"1\":{\"807\":1}}],[\"每个位置的表征\",{\"1\":{\"820\":1}}],[\"每个位置的\",{\"1\":{\"794\":1,\"798\":1}}],[\"每个位置的输出会通过一个独立的前馈神经网络进行进一步处理\",{\"1\":{\"622\":1}}],[\"每个位置\",{\"1\":{\"588\":1}}],[\"每个词汇还同时保留产生该词汇的原始文章\",{\"1\":{\"577\":1}}],[\"每个词的每个字符后都加上空格\",{\"1\":{\"476\":1}}],[\"每个句子在训练过程中会被看到\",{\"1\":{\"562\":1}}],[\"每个任务需要数千至数十万标注样本\",{\"1\":{\"527\":1}}],[\"每个这些序列用作者的模型独立处理后通过一个\",{\"1\":{\"512\":1}}],[\"每个实例有输入字符的序列构成\",{\"1\":{\"511\":1}}],[\"每个子层\",{\"1\":{\"622\":1}}],[\"每个子词出现次数加1\",{\"1\":{\"476\":1}}],[\"每个子词的出现次数\",{\"1\":{\"476\":1}}],[\"每个子步骤都由一个\",{\"1\":{\"28\":1}}],[\"每个变量自己的方差\",{\"1\":{\"455\":1}}],[\"每个列中的总和会显示所有真实正例\",{\"1\":{\"442\":1}}],[\"每个通道有\",{\"1\":{\"423\":1}}],[\"每个epoch采样样本数=总样本数\",{\"1\":{\"403\":1}}],[\"每个撒下去的小数点都用周围的4个整数点去\",{\"1\":{\"387\":2}}],[\"每个网格是\",{\"1\":{\"386\":1}}],[\"每个小块做\",{\"1\":{\"386\":1}}],[\"每个残差块还包含一条跨层的连接线\",{\"1\":{\"382\":1}}],[\"每个残差块包含两个3x3的卷积层\",{\"1\":{\"382\":1}}],[\"每个卷积层后面都跟着一个batch\",{\"1\":{\"382\":1}}],[\"每个卷积层后跟一个\",{\"1\":{\"109\":1}}],[\"每个图像由两个离散视觉token进行表示\",{\"1\":{\"814\":1}}],[\"每个图像块的尺寸\",{\"1\":{\"318\":1}}],[\"每个图像位置对应的所有点云点\",{\"1\":{\"41\":1}}],[\"每个patch是三通道的小图片\",{\"1\":{\"318\":1}}],[\"每个patch的高度和宽度\",{\"1\":{\"272\":1}}],[\"每个output\",{\"1\":{\"311\":1}}],[\"每个query\",{\"1\":{\"310\":1}}],[\"每个query通道维度做特征融合\",{\"1\":{\"76\":1}}],[\"每个模态单独使用重的transformer\",{\"1\":{\"282\":1}}],[\"每个进程都会调用\",{\"1\":{\"274\":1}}],[\"每个进程\",{\"1\":{\"273\":1}}],[\"每个注意力头的维度\",{\"1\":{\"272\":1}}],[\"每个特征\",{\"1\":{\"250\":1}}],[\"每个问题包含文本或图像上下文\",{\"1\":{\"235\":1}}],[\"每个教师视图监督除同索引学生视图外的所有学生视图\",{\"1\":{\"186\":1}}],[\"每个教师的全局视图监督所有学生视图\",{\"1\":{\"186\":1}}],[\"每个码本向量的维度\",{\"1\":{\"170\":1}}],[\"每个向量对应的码本索引\",{\"1\":{\"170\":1}}],[\"每个向量都被缩放到单位长度\",{\"1\":{\"170\":1}}],[\"每个向量的维度\",{\"1\":{\"169\":1,\"170\":1}}],[\"每个样本理论上都包含\",{\"1\":{\"873\":1}}],[\"每个样本一个\",{\"1\":{\"804\":1}}],[\"每个样本都需要做一个\",{\"1\":{\"249\":1}}],[\"每个样本对应的簇编号\",{\"1\":{\"170\":1}}],[\"每个样本为一个\",{\"1\":{\"18\":1}}],[\"每个格子表示是否有物体\",{\"1\":{\"114\":1}}],[\"每个原始点都有了一个新的特征向量\",{\"1\":{\"100\":1}}],[\"每个原始点都有了它最近的\",{\"1\":{\"100\":1}}],[\"每个原始点对应的\",{\"1\":{\"100\":1}}],[\"每个层是一个conv1d\",{\"1\":{\"100\":1}}],[\"每个结构中心点不变\",{\"1\":{\"96\":1}}],[\"每个关键点的多尺度特征表示\",{\"1\":{\"96\":1}}],[\"每个关键点对应的局部区域点和特征\",{\"1\":{\"92\":1}}],[\"每个尺度可以有不同的网络深度和宽度\",{\"1\":{\"96\":1}}],[\"每个尺度\",{\"1\":{\"95\":1}}],[\"每个半径定义了一个局部邻域的大小\",{\"1\":{\"95\":1}}],[\"每个查询点点局部特征\",{\"1\":{\"92\":1}}],[\"每个查询点对所有原始点的距离\",{\"1\":{\"92\":1}}],[\"每个邻域内采样的关键点数量\",{\"1\":{\"92\":2}}],[\"每个区域中点的数量𝐾和query的半径𝑟\",{\"1\":{\"90\":1}}],[\"每个\",{\"1\":{\"76\":5,\"142\":1,\"167\":3,\"169\":2,\"179\":1,\"257\":1,\"264\":1,\"273\":1,\"276\":1,\"277\":1,\"290\":1,\"363\":1,\"367\":2,\"387\":4,\"405\":2,\"410\":1,\"412\":1,\"591\":2,\"614\":3,\"769\":1,\"771\":1,\"793\":1,\"801\":1,\"803\":1,\"804\":1,\"814\":1,\"822\":1}}],[\"每个文本token询问所有点key后\",{\"1\":{\"72\":1}}],[\"每个形状实例随机匹配一个与其功能类型一致的问题\",{\"1\":{\"66\":1}}],[\"每个物体类别可有多个形状实例\",{\"1\":{\"65\":1}}],[\"每个物体都以点云形式表示\",{\"1\":{\"62\":1}}],[\"每个点都代表一个阈值\",{\"1\":{\"453\":1}}],[\"每个点都需要全局上下文\",{\"1\":{\"111\":1}}],[\"每个点通常包含\",{\"1\":{\"114\":1}}],[\"每个点有\",{\"1\":{\"100\":1,\"107\":1,\"114\":1}}],[\"每个点到当前所有已选中心点的最小距离\",{\"1\":{\"92\":1}}],[\"每个点是否属于当前问题描述的功能区域\",{\"1\":{\"64\":1}}],[\"每个点的分类结果\",{\"1\":{\"101\":1}}],[\"每个点的三个邻近点的权重\",{\"1\":{\"100\":1}}],[\"每个点的值\",{\"1\":{\"76\":1}}],[\"每个点的\",{\"1\":{\"46\":1}}],[\"每个点云约\",{\"1\":{\"67\":1}}],[\"每个点云点对应的所有图像位置\",{\"1\":{\"41\":1}}],[\"每个点云点与图像中每个位置之间的相似度得分\",{\"1\":{\"41\":1}}],[\"每个点云实例按可供性类别标注\",{\"1\":{\"18\":1}}],[\"每个点包括\",{\"1\":{\"18\":1}}],[\"防止梯度传播到某部分\",{\"1\":{\"885\":1}}],[\"防止跨模态预测\",{\"1\":{\"815\":2}}],[\"防止跨字符类别的合并\",{\"1\":{\"521\":1}}],[\"防止训练不稳定\",{\"1\":{\"797\":1}}],[\"防止同一个函数被多次添加到func列表中\",{\"1\":{\"686\":1}}],[\"防止溢出\",{\"1\":{\"591\":1}}],[\"防止出现\",{\"1\":{\"473\":1}}],[\"防止被背景淹没\",{\"1\":{\"470\":1}}],[\"防止模型只关注简单样本\",{\"1\":{\"470\":1}}],[\"防止模型偏向特定句式或长度\",{\"1\":{\"63\":1}}],[\"防止前景点\",{\"1\":{\"470\":1}}],[\"防止内积过大导致\",{\"1\":{\"418\":1}}],[\"防止原\",{\"1\":{\"278\":1}}],[\"防止点积结果过大\",{\"1\":{\"272\":1}}],[\"防止过拟合\",{\"1\":{\"234\":1,\"322\":4,\"537\":1,\"804\":1}}],[\"防止某一维度主导表示\",{\"1\":{\"178\":1}}],[\"防止除零错误\",{\"1\":{\"467\":1,\"468\":1,\"469\":1,\"470\":1}}],[\"防止除零的小常数\",{\"1\":{\"170\":1}}],[\"防止除以零\",{\"1\":{\"467\":2,\"468\":1,\"471\":1,\"473\":1}}],[\"防止除以\",{\"1\":{\"170\":1}}],[\"防止重复生成\",{\"1\":{\"143\":1}}],[\"防止忽略小区域\",{\"1\":{\"78\":1}}],[\"防止其影响后续计算\",{\"1\":{\"76\":1}}],[\"防止\",{\"1\":{\"41\":1,\"170\":1,\"473\":2}}],[\"仅比\",{\"1\":{\"866\":1}}],[\"仅比人类低几分\",{\"1\":{\"529\":1}}],[\"仅屏蔽其右侧\",{\"1\":{\"848\":1}}],[\"仅保留最可能的\",{\"1\":{\"820\":1}}],[\"仅取最后一个位置的\",{\"1\":{\"820\":1}}],[\"仅包含文本部分\",{\"1\":{\"815\":1}}],[\"仅包含全局视图\",{\"1\":{\"186\":1}}],[\"仅解码器\",{\"1\":{\"809\":1}}],[\"仅返回被遮挡位置的预测结果\",{\"1\":{\"804\":1}}],[\"仅返回\",{\"1\":{\"794\":1}}],[\"仅返回预测结果\",{\"1\":{\"40\":1}}],[\"仅当config\",{\"1\":{\"688\":1}}],[\"仅终端变量的导数需要被保留\",{\"1\":{\"688\":1}}],[\"仅供参考和学习\",{\"1\":{\"582\":1}}],[\"仅177gb\",{\"1\":{\"549\":1}}],[\"仅为49\",{\"1\":{\"529\":1}}],[\"仅提供任务描述\",{\"1\":{\"528\":1}}],[\"仅仅需要小小修改模型架构\",{\"1\":{\"506\":1}}],[\"仅借鉴了encoder结构\",{\"1\":{\"314\":1}}],[\"仅能和自己的\",{\"1\":{\"310\":1}}],[\"仅文本\",{\"1\":{\"277\":1,\"817\":1}}],[\"仅文本模态\",{\"1\":{\"272\":1}}],[\"仅图像模态\",{\"1\":{\"272\":1}}],[\"仅从其中提取特征\",{\"1\":{\"245\":1}}],[\"仅\",{\"1\":{\"236\":1,\"438\":1}}],[\"仅训练分类头\",{\"1\":{\"327\":1}}],[\"仅训练语言专家进行掩码语言建模\",{\"1\":{\"266\":1}}],[\"仅训练\",{\"1\":{\"204\":1}}],[\"仅训练新增参数\",{\"1\":{\"209\":1}}],[\"仅训练新增的\",{\"1\":{\"198\":1}}],[\"仅训练新引入的参数\",{\"1\":{\"199\":1}}],[\"仅微调\",{\"1\":{\"198\":1}}],[\"仅使用前\",{\"1\":{\"817\":1}}],[\"仅使用cpu就能完成整个训练过程\",{\"1\":{\"577\":1}}],[\"仅使用交叉熵损失\",{\"1\":{\"473\":1}}],[\"仅使用图文对比损失训练的模型性能显著低于我们统一训练框架下的模型\",{\"1\":{\"268\":1}}],[\"仅使用最后一层视觉特征\",{\"1\":{\"237\":1}}],[\"仅使用\",{\"1\":{\"198\":1,\"473\":1}}],[\"仅用\",{\"1\":{\"704\":1}}],[\"仅用squad数据\",{\"1\":{\"566\":1}}],[\"仅用internvit\",{\"1\":{\"196\":1}}],[\"仅用于生成\",{\"1\":{\"163\":1}}],[\"仅支持单模态任务\",{\"1\":{\"196\":1}}],[\"仅两张全局裁剪用于教师监督\",{\"1\":{\"186\":1}}],[\"仅学生网络\",{\"1\":{\"186\":1}}],[\"仅前\",{\"1\":{\"186\":1}}],[\"仅通过增加语言模型的规模\",{\"1\":{\"534\":1}}],[\"仅通过自然语言提示和示例\",{\"1\":{\"532\":1}}],[\"仅通过few\",{\"1\":{\"529\":1}}],[\"仅通过语言建模目标就能在零样本设置下完成多种nlp任务\",{\"1\":{\"524\":1}}],[\"仅通过\",{\"1\":{\"186\":1,\"202\":1}}],[\"仅通过扩充原始数据进行更长时间训练\",{\"1\":{\"136\":1}}],[\"仅需自然语言提示\",{\"1\":{\"522\":1}}],[\"仅需4个tanh神经元即可高精度拟合\",{\"1\":{\"385\":1}}],[\"仅需24小时\",{\"1\":{\"184\":1}}],[\"仅需\",{\"1\":{\"173\":1}}],[\"仅需在教师输出上应用\",{\"1\":{\"173\":1}}],[\"仅对\",{\"1\":{\"163\":1}}],[\"仅参数使用\",{\"1\":{\"160\":1}}],[\"仅在无对应文本\",{\"1\":{\"809\":1}}],[\"仅在分布式环境下启用\",{\"1\":{\"277\":1}}],[\"仅在\",{\"1\":{\"134\":1,\"272\":1,\"492\":1}}],[\"仅靠\",{\"1\":{\"112\":1}}],[\"仅靠局部特征很难判断某个点属于哪个部件\",{\"1\":{\"111\":1}}],[\"仅更新插入的\",{\"1\":{\"239\":1}}],[\"仅更新投影矩阵\",{\"1\":{\"234\":1}}],[\"仅更新\",{\"1\":{\"10\":1}}],[\"语音\",{\"1\":{\"704\":1}}],[\"语法简洁\",{\"1\":{\"688\":1}}],[\"语法纠错等任务中\",{\"1\":{\"529\":1}}],[\"语句连贯性\",{\"1\":{\"507\":1}}],[\"语言中\",{\"1\":{\"759\":1}}],[\"语言中间件\",{\"1\":{\"197\":1}}],[\"语言识别\",{\"1\":{\"548\":1}}],[\"语言多样性不足\",{\"1\":{\"539\":1}}],[\"语言建模能力\",{\"0\":{\"820\":1}}],[\"语言建模的研究可以追溯到\",{\"1\":{\"703\":1}}],[\"语言建模的核心框架\",{\"1\":{\"521\":1}}],[\"语言建模任务评估\",{\"1\":{\"522\":1}}],[\"语言建模头\",{\"1\":{\"295\":1}}],[\"语言可接受性\",{\"1\":{\"516\":1}}],[\"语言联合预训练\",{\"1\":{\"269\":1}}],[\"语言检索任务\",{\"1\":{\"269\":1}}],[\"语言检索\",{\"1\":{\"267\":1}}],[\"语言分类\",{\"1\":{\"267\":1}}],[\"语言分类任务上性能优异\",{\"1\":{\"260\":1}}],[\"语言分类任务表现有限\",{\"1\":{\"260\":1}}],[\"语言专家捕捉跨模态交互\",{\"1\":{\"264\":1}}],[\"语言专家\",{\"1\":{\"260\":2,\"264\":2}}],[\"语言对齐与生成能力\",{\"1\":{\"205\":1}}],[\"语言对比训练\",{\"1\":{\"198\":1}}],[\"语言生成训练\",{\"1\":{\"198\":1}}],[\"语言大模型\",{\"1\":{\"189\":1}}],[\"语言大规模预训练能提升多种视觉语言任务\",{\"1\":{\"149\":1}}],[\"语言任务中取得了竞争力甚至更优的性能\",{\"1\":{\"280\":1}}],[\"语言任务中取得显著进展\",{\"1\":{\"219\":1}}],[\"语言任务中表现出色\",{\"1\":{\"188\":1}}],[\"语言任务上以零样本方式迁移也表现优异\",{\"1\":{\"120\":1}}],[\"语言基础模型的发展却相对滞后\",{\"1\":{\"189\":1}}],[\"语言基础模型发展滞后于大型语言模型\",{\"1\":{\"188\":1}}],[\"语言基础模型\",{\"1\":{\"188\":1,\"206\":1}}],[\"语言表示学习主要分为两类\",{\"1\":{\"150\":1}}],[\"语言研究的发展\",{\"1\":{\"138\":1}}],[\"语言预训练方法大体可分为两类\",{\"1\":{\"261\":1}}],[\"语言预训练模型\",{\"1\":{\"260\":3,\"269\":1}}],[\"语言预训练所使用的图文对大多来自网页\",{\"1\":{\"157\":1}}],[\"语言预训练框架\",{\"1\":{\"138\":1}}],[\"语言预训练中使用合成图像描述的独特优势\",{\"1\":{\"124\":1}}],[\"语言预训练\",{\"0\":{\"122\":1},\"1\":{\"120\":1,\"280\":2}}],[\"语言查询特征\",{\"1\":{\"76\":1}}],[\"语言含义\",{\"1\":{\"76\":1}}],[\"语言引导的点特征筛选\",{\"1\":{\"72\":1}}],[\"语言引导的\",{\"1\":{\"70\":1,\"82\":1}}],[\"语言引导下的\",{\"1\":{\"60\":1}}],[\"语言辅助方法\",{\"1\":{\"51\":1}}],[\"语言后半段\",{\"1\":{\"43\":1}}],[\"语言前半段\",{\"1\":{\"43\":1}}],[\"语言部分的\",{\"1\":{\"43\":1}}],[\"语言\",{\"1\":{\"43\":1,\"260\":1}}],[\"语言模型发展脉络\",{\"1\":{\"552\":1}}],[\"语言模型会生成有害或偏见内容\",{\"1\":{\"536\":1}}],[\"语言模型可能直接学会执行任务\",{\"1\":{\"523\":1}}],[\"语言模型通过预测多样化文本中的任务演示\",{\"1\":{\"521\":1}}],[\"语言模型通过链式法则计算联合概率\",{\"1\":{\"521\":1}}],[\"语言模型本身可以通过观察任务的自然语言演示\",{\"1\":{\"521\":1}}],[\"语言模型本身可能通过无监督学习捕捉任务相关的知识\",{\"1\":{\"520\":1}}],[\"语言模型使用多层的\",{\"1\":{\"510\":1}}],[\"语言模型从nous\",{\"1\":{\"223\":1}}],[\"语言模型\",{\"1\":{\"42\":1,\"222\":1,\"234\":1,\"235\":1,\"704\":1}}],[\"语言指令理解特征\",{\"1\":{\"40\":1}}],[\"语义连续\",{\"1\":{\"801\":1}}],[\"语义\",{\"1\":{\"786\":1}}],[\"语义角色标注\",{\"1\":{\"617\":1}}],[\"语义解析\",{\"1\":{\"536\":1}}],[\"语义比较等\",{\"1\":{\"529\":1}}],[\"语义文本相似度数据集\",{\"1\":{\"515\":1}}],[\"语义组块chuking\",{\"1\":{\"508\":1}}],[\"语义相似度\",{\"1\":{\"515\":2}}],[\"语义相似度评估\",{\"1\":{\"506\":1,\"517\":1}}],[\"语义相识度\",{\"1\":{\"507\":1}}],[\"语义信息不应该发生变化\",{\"1\":{\"243\":1}}],[\"语义分割等\",{\"1\":{\"767\":1}}],[\"语义分割任务需要对图像中的每个像素进行分类\",{\"1\":{\"465\":1}}],[\"语义分割任务中\",{\"1\":{\"465\":1}}],[\"语义分割可以被看作是像素级别的图像分割\",{\"1\":{\"465\":1}}],[\"语义分割不仅需要识别图像中的物体\",{\"1\":{\"465\":1}}],[\"语义分割是计算机视觉领域中的一项任务\",{\"1\":{\"465\":1}}],[\"语义分割中常用的损失函数\",{\"0\":{\"464\":1},\"1\":{\"464\":1}}],[\"语义分割\",{\"0\":{\"465\":1,\"777\":1},\"1\":{\"188\":1,\"201\":1,\"465\":1}}],[\"语义一致性\",{\"1\":{\"186\":1,\"529\":1}}],[\"语义字典\",{\"1\":{\"186\":1}}],[\"语义对齐\",{\"1\":{\"33\":1}}],[\"语义空间受限\",{\"1\":{\"6\":1}}],[\"降为用4bit来表示\",{\"1\":{\"488\":1}}],[\"降训练成本\",{\"1\":{\"488\":1}}],[\"降低了产生幻觉的概率\",{\"1\":{\"711\":1}}],[\"降低了不同架构之间的切换成本\",{\"1\":{\"395\":1}}],[\"降低幻觉\",{\"1\":{\"711\":1}}],[\"降低部署风险\",{\"1\":{\"539\":1}}],[\"降低易分类样本的权重\",{\"1\":{\"470\":1}}],[\"降低动量负样本带来的扰动\",{\"1\":{\"159\":1}}],[\"降维适配器\",{\"0\":{\"44\":1},\"1\":{\"40\":1,\"44\":1}}],[\"降到\",{\"1\":{\"24\":1}}],[\"返回经过筛选后的\",{\"1\":{\"818\":1}}],[\"返回所有\",{\"1\":{\"804\":1}}],[\"返回两张不同视角图像\",{\"1\":{\"802\":1}}],[\"返回两个任务的结果\",{\"1\":{\"580\":1}}],[\"返回本次新增的遮挡patch数量\",{\"1\":{\"801\":1}}],[\"返回本次新增遮挡的patch数量\",{\"1\":{\"801\":1}}],[\"返回最终生成的遮挡掩码\",{\"1\":{\"801\":1}}],[\"返回最终的簇中心和每个簇的样本数\",{\"1\":{\"170\":2}}],[\"返回第1维度的元素数\",{\"1\":{\"689\":1}}],[\"返回构建得到的单个样本列表\",{\"1\":{\"579\":1}}],[\"返回处理后的句子列表\",{\"1\":{\"577\":1}}],[\"返回合并最高频字符对后的vocab\",{\"1\":{\"476\":1}}],[\"返回出现次数最多的前\",{\"1\":{\"401\":1}}],[\"返回对应数量的切分结果\",{\"1\":{\"398\":1}}],[\"返回在\",{\"1\":{\"376\":1}}],[\"返回值形如\",{\"1\":{\"614\":1}}],[\"返回值是按输入顺序交错的切分结果\",{\"1\":{\"398\":1}}],[\"返回值\",{\"1\":{\"373\":1,\"374\":1,\"377\":1,\"399\":1}}],[\"返回反向索引\",{\"1\":{\"372\":1}}],[\"返回计数\",{\"1\":{\"372\":1}}],[\"返回输入张量中\",{\"1\":{\"372\":1}}],[\"返回一个一维张量\",{\"1\":{\"377\":1}}],[\"返回一个长度为\",{\"1\":{\"375\":1}}],[\"返回一个和\",{\"1\":{\"373\":1}}],[\"返回一个新的张量\",{\"1\":{\"373\":1}}],[\"返回一个新张量\",{\"1\":{\"368\":1}}],[\"返回一个函数\",{\"1\":{\"339\":1}}],[\"返回视图\",{\"1\":{\"364\":1}}],[\"返回具有新形状的张量\",{\"1\":{\"362\":1}}],[\"返回具有新形状\",{\"1\":{\"361\":1}}],[\"返回分类标记对应的特征\",{\"1\":{\"319\":1,\"320\":1,\"323\":1}}],[\"返回数据集中图像的数量\",{\"1\":{\"316\":1}}],[\"返回数据集名称\",{\"1\":{\"274\":1}}],[\"返回字典格式结果\",{\"1\":{\"312\":1}}],[\"返回预测出来的\",{\"1\":{\"295\":1}}],[\"返回预测得分\",{\"1\":{\"295\":1}}],[\"返回结果字典\",{\"1\":{\"276\":1,\"277\":1}}],[\"返回结构化输出\",{\"1\":{\"162\":1}}],[\"返回推理结果字典\",{\"1\":{\"276\":1}}],[\"返回测试\",{\"1\":{\"274\":1}}],[\"返回验证\",{\"1\":{\"274\":1}}],[\"返回训练\",{\"1\":{\"274\":1}}],[\"返回多个增强后的\",{\"1\":{\"186\":1}}],[\"返回掩码后的\",{\"1\":{\"163\":1}}],[\"返回三个\",{\"1\":{\"147\":1}}],[\"返回的张量虽然是视图\",{\"1\":{\"360\":1}}],[\"返回的\",{\"1\":{\"276\":1,\"343\":1}}],[\"返回的每个\",{\"1\":{\"252\":1}}],[\"返回的是软概率分布\",{\"1\":{\"795\":1}}],[\"返回的是一个字典的子类\",{\"1\":{\"401\":1}}],[\"返回的是\",{\"1\":{\"186\":1,\"346\":1,\"374\":1}}],[\"返回的caption前不添加prompt\",{\"1\":{\"147\":1}}],[\"返回的高维隐向量维度为\",{\"1\":{\"30\":1}}],[\"返回itc损失和itm损失\",{\"1\":{\"145\":1}}],[\"返回每个点的分类结果和抽象特征\",{\"1\":{\"101\":1}}],[\"返回位置索引\",{\"1\":{\"92\":1}}],[\"返回目标物体区域特征图\",{\"1\":{\"59\":1}}],[\"返回拼接好的输入和\",{\"1\":{\"43\":1}}],[\"返回\",{\"1\":{\"40\":1,\"68\":1,\"78\":1,\"92\":1,\"100\":1,\"101\":2,\"107\":1,\"109\":1,\"163\":1,\"170\":1,\"272\":1,\"274\":1,\"332\":1,\"345\":1,\"433\":1,\"467\":2,\"468\":1,\"469\":1,\"470\":1,\"471\":1,\"473\":1,\"591\":2,\"795\":1,\"820\":1}}],[\"函数变化可能很陡\",{\"1\":{\"839\":1}}],[\"函数越平滑\",{\"1\":{\"839\":1}}],[\"函数完成了\",{\"1\":{\"803\":1}}],[\"函数来实现上述过程\",{\"1\":{\"795\":1}}],[\"函数负责绑定运算符方法\",{\"1\":{\"691\":1}}],[\"函数和\",{\"1\":{\"682\":1}}],[\"函数在处的导数定义为\",{\"1\":{\"650\":1}}],[\"函数的python化\",{\"0\":{\"671\":1}}],[\"函数的表达式为\",{\"1\":{\"660\":1}}],[\"函数的连续调用\",{\"0\":{\"645\":1}}],[\"函数的作用是将整个点云视为一个\",{\"1\":{\"92\":1}}],[\"函数类的设计\",{\"0\":{\"642\":1}}],[\"函数与计算图\",{\"0\":{\"641\":1}}],[\"函数生成目标序列的概率分布\",{\"1\":{\"622\":1}}],[\"函数复合\",{\"1\":{\"385\":3}}],[\"函数空间\",{\"1\":{\"385\":1}}],[\"函数替换器\",{\"1\":{\"349\":1}}],[\"函数替代了原来的\",{\"1\":{\"343\":1}}],[\"函数上\",{\"1\":{\"346\":1}}],[\"函数返回一个函数\",{\"1\":{\"339\":1}}],[\"函数接收另一个函数作为参数\",{\"1\":{\"339\":1}}],[\"函数定义了变量之间的对应关系\",{\"1\":{\"641\":1}}],[\"函数定义\",{\"1\":{\"336\":1,\"691\":1,\"692\":3}}],[\"函数定义见\",{\"1\":{\"82\":1}}],[\"函数或代码块内部定义的名字\",{\"1\":{\"336\":1}}],[\"函数中\",{\"1\":{\"248\":1}}],[\"函数\",{\"0\":{\"839\":1},\"1\":{\"40\":1,\"76\":1,\"105\":1,\"115\":1,\"274\":1,\"302\":1,\"304\":1,\"316\":1,\"342\":1,\"343\":1,\"346\":1,\"349\":1,\"471\":1,\"748\":2,\"826\":1,\"839\":1,\"868\":1}}],[\"设随机向量\",{\"1\":{\"866\":1}}],[\"设随机变量\",{\"1\":{\"727\":1,\"739\":1}}],[\"设真实标签是\",{\"1\":{\"832\":1}}],[\"设每次抛硬币结果\",{\"1\":{\"826\":1}}],[\"设样本数据为\",{\"1\":{\"826\":1}}],[\"设备\",{\"1\":{\"803\":1}}],[\"设想我们要从一张二维图像\",{\"1\":{\"759\":1}}],[\"设定文本序列的最大长度\",{\"1\":{\"820\":1}}],[\"设定传入的input和返回的output均为variable类型\",{\"1\":{\"643\":1}}],[\"设定下\",{\"1\":{\"529\":1}}],[\"设两维特征的协方差矩阵是\",{\"1\":{\"459\":1}}],[\"设动量模型在图像\",{\"1\":{\"157\":1}}],[\"设动量编码器生成的相似度为\",{\"1\":{\"157\":1}}],[\"设\",{\"1\":{\"155\":1,\"493\":1,\"727\":1,\"728\":1,\"737\":1,\"740\":1,\"741\":1,\"773\":1}}],[\"设为由编码器输出的\",{\"1\":{\"808\":1}}],[\"设为对\",{\"1\":{\"808\":1}}],[\"设为\",{\"1\":{\"143\":1,\"398\":1,\"809\":1,\"815\":1}}],[\"设是一个函数\",{\"1\":{\"115\":1}}],[\"设计特定任务作为学习信号\",{\"1\":{\"786\":1}}],[\"设计的一种\",{\"1\":{\"728\":1}}],[\"设计的一般原则及技巧\",{\"1\":{\"717\":1}}],[\"设计产品页面\",{\"1\":{\"717\":1}}],[\"设计后\",{\"1\":{\"717\":1}}],[\"设计功能\",{\"1\":{\"717\":1}}],[\"设计功能热图\",{\"1\":{\"51\":1}}],[\"设计合理\",{\"1\":{\"716\":1}}],[\"设计调优\",{\"1\":{\"716\":1}}],[\"设计function类作为基类\",{\"1\":{\"642\":1}}],[\"设计目的\",{\"1\":{\"591\":1}}],[\"设计或改进对比损失函数\",{\"1\":{\"248\":1}}],[\"设计\",{\"1\":{\"186\":1}}],[\"设计图文对比\",{\"1\":{\"149\":1}}],[\"设计局部\",{\"1\":{\"105\":1}}],[\"设计了\",{\"1\":{\"537\":1}}],[\"设计了一个统一架构\",{\"1\":{\"103\":1}}],[\"设计了多头部功能链式思维\",{\"1\":{\"5\":1}}],[\"设置重建损失函数\",{\"1\":{\"821\":1}}],[\"设置其优先级高于ndarray\",{\"1\":{\"690\":1}}],[\"设置变量的creator\",{\"1\":{\"664\":1}}],[\"设置的回调方法cllote\",{\"1\":{\"596\":1}}],[\"设置下均达到sota\",{\"1\":{\"549\":1}}],[\"设置下的表现\",{\"1\":{\"527\":1}}],[\"设置下完成多种自然语言处理任务\",{\"1\":{\"519\":1}}],[\"设置默认参数\",{\"1\":{\"471\":1}}],[\"设置全局参数\",{\"1\":{\"470\":1}}],[\"设置步幅为\",{\"1\":{\"427\":1}}],[\"设置柱状图的标题\",{\"1\":{\"316\":1}}],[\"设置y坐标\",{\"1\":{\"316\":1}}],[\"设置x坐标\",{\"1\":{\"316\":1}}],[\"设置为\",{\"1\":{\"514\":1}}],[\"设置为已初始化状态\",{\"1\":{\"169\":1}}],[\"设置为评估模式\",{\"1\":{\"83\":1}}],[\"设置渲染参数\",{\"1\":{\"83\":1}}],[\"设置颜色\",{\"1\":{\"83\":1}}],[\"设置训练轮数\",{\"1\":{\"83\":1}}],[\"设置学习率\",{\"1\":{\"83\":1}}],[\"设置batch\",{\"1\":{\"83\":1}}],[\"设置后台运行\",{\"1\":{\"83\":1}}],[\"设置\",{\"0\":{\"514\":1},\"1\":{\"40\":1,\"78\":1}}],[\"∈\",{\"1\":{\"40\":2,\"72\":2,\"73\":1,\"76\":1,\"82\":1,\"160\":1,\"186\":1,\"273\":1,\"469\":1,\"853\":1}}],[\"输入进解码器里\",{\"1\":{\"883\":1}}],[\"输入进模型\",{\"1\":{\"847\":1}}],[\"输入变化多少\",{\"1\":{\"839\":1}}],[\"输入的文本\",{\"1\":{\"817\":1}}],[\"输入的未归一化的\",{\"1\":{\"795\":1}}],[\"输入的图像张量\",{\"1\":{\"318\":1}}],[\"输入的图片尺寸必须为224x224\",{\"1\":{\"317\":1}}],[\"输入的图片尺寸并不是自定义的\",{\"1\":{\"317\":1}}],[\"输入向量为\",{\"1\":{\"771\":1}}],[\"输入越长\",{\"1\":{\"709\":1}}],[\"输入与输出的关系\",{\"1\":{\"616\":1}}],[\"输入会变成如下结构\",{\"1\":{\"614\":1}}],[\"输入数据格式\",{\"1\":{\"594\":1}}],[\"输入格式\",{\"1\":{\"562\":1,\"614\":1}}],[\"输入格式与下一句预测\",{\"1\":{\"562\":1}}],[\"输入由两个文本片段\",{\"1\":{\"560\":1}}],[\"输入词的val\",{\"1\":{\"544\":1}}],[\"输入词的key\",{\"1\":{\"544\":1}}],[\"输入微小变动影响大\",{\"1\":{\"530\":1}}],[\"输入文本\",{\"1\":{\"820\":1,\"822\":1}}],[\"输入文本序列长度\",{\"1\":{\"814\":1}}],[\"输入文本的嵌入表示\",{\"1\":{\"162\":1}}],[\"输入文档+对话历史+\",{\"1\":{\"521\":1}}],[\"输入通道为\",{\"1\":{\"848\":1}}],[\"输入通道\",{\"1\":{\"846\":2}}],[\"输入通道数\",{\"1\":{\"272\":2,\"846\":1}}],[\"输入通过作者的预训练模型会得到最好的\",{\"1\":{\"511\":1}}],[\"输入序列长度超过max\",{\"1\":{\"590\":1}}],[\"输入序列\",{\"1\":{\"481\":1,\"578\":1,\"618\":1}}],[\"输入维度为\",{\"1\":{\"804\":1}}],[\"输入维度\",{\"0\":{\"410\":1},\"1\":{\"544\":1}}],[\"输入关键字参数\",{\"1\":{\"401\":1}}],[\"输入一个\",{\"1\":{\"541\":1}}],[\"输入一个字典\",{\"1\":{\"401\":1}}],[\"输入一个可迭代对象\",{\"1\":{\"401\":1}}],[\"输入一张图像\",{\"1\":{\"186\":1}}],[\"输入调整等\",{\"1\":{\"359\":1}}],[\"输入加上经过归一化和\",{\"1\":{\"321\":1}}],[\"输入加上经过归一化和注意力层处理后的输出\",{\"1\":{\"321\":1}}],[\"输入encoder的最左侧部分添加了一个0\",{\"1\":{\"319\":1}}],[\"输入包含三部分\",{\"1\":{\"309\":1}}],[\"输入image\",{\"1\":{\"300\":1}}],[\"输入张量\",{\"1\":{\"272\":1,\"372\":1,\"373\":1,\"388\":1}}],[\"输入模态类型\",{\"1\":{\"272\":1}}],[\"输入任务专用分类器预测标签\",{\"1\":{\"267\":1}}],[\"输入表示\",{\"0\":{\"263\":1},\"1\":{\"521\":1}}],[\"输入是结构化的\",{\"1\":{\"512\":1}}],[\"输入是一个\",{\"1\":{\"415\":1}}],[\"输入是一个指令\",{\"1\":{\"232\":1}}],[\"输入是原始点云\",{\"1\":{\"107\":1}}],[\"输入分辨率保持\",{\"1\":{\"209\":1}}],[\"输入样本\",{\"1\":{\"170\":1,\"313\":1}}],[\"输入传递到\",{\"1\":{\"167\":1}}],[\"输入解码器\",{\"1\":{\"167\":1}}],[\"输入做前向传播\",{\"1\":{\"163\":1}}],[\"输入到解码器中即可生成图像\",{\"1\":{\"869\":1}}],[\"输入到vae中的图像尺寸\",{\"1\":{\"803\":1}}],[\"输入到mlp\",{\"1\":{\"319\":1}}],[\"输入到\",{\"1\":{\"162\":1,\"326\":1}}],[\"输入网页图像\",{\"1\":{\"128\":1}}],[\"输入形式\",{\"1\":{\"112\":1}}],[\"输入标准化\",{\"0\":{\"107\":1}}],[\"输入特征的维度\",{\"1\":{\"272\":1}}],[\"输入特征的通道数\",{\"1\":{\"100\":1}}],[\"输入特征\",{\"1\":{\"272\":1}}],[\"输入特征图\",{\"1\":{\"170\":1}}],[\"输入特征维度\",{\"1\":{\"45\":1,\"272\":1}}],[\"输入输出示例\",{\"1\":{\"98\":1}}],[\"输入点云变换矩阵\",{\"1\":{\"109\":1}}],[\"输入点云变换网络\",{\"1\":{\"109\":1}}],[\"输入点云可能来自不同角度\",{\"1\":{\"107\":1}}],[\"输入点云可能缺失或含有异常点\",{\"1\":{\"105\":1}}],[\"输入点云可能缺失或包含噪声\",{\"1\":{\"104\":1}}],[\"输入点云数据\",{\"1\":{\"83\":2}}],[\"输入点的特征维度\",{\"1\":{\"92\":1}}],[\"输入\",{\"1\":{\"72\":1,\"73\":1,\"74\":1,\"78\":1,\"82\":2,\"98\":1,\"100\":1,\"101\":1,\"186\":1,\"276\":1,\"277\":3,\"312\":1,\"389\":1,\"390\":1,\"408\":1,\"410\":1,\"467\":1,\"468\":1,\"521\":1,\"580\":1,\"631\":1,\"766\":1,\"814\":1,\"848\":1,\"885\":1}}],[\"输入为图像\",{\"1\":{\"264\":2}}],[\"输入为\",{\"1\":{\"46\":1,\"160\":1,\"318\":1,\"537\":1,\"788\":1,\"803\":1}}],[\"输入图像编码为离散的视觉token\",{\"1\":{\"815\":1}}],[\"输入图像通道数\",{\"1\":{\"793\":1}}],[\"输入图像被切分为默认的\",{\"1\":{\"774\":1}}],[\"输入图像被分割成\",{\"1\":{\"319\":1}}],[\"输入图像的离散\",{\"1\":{\"821\":1}}],[\"输入图像的数值尺度对训练稳定性和收敛非常重要\",{\"1\":{\"802\":1}}],[\"输入图像的标准化处理\",{\"1\":{\"802\":2}}],[\"输入图像的\",{\"1\":{\"801\":1}}],[\"输入图像的通道数\",{\"1\":{\"318\":1,\"319\":1}}],[\"输入图像的尺寸\",{\"1\":{\"318\":1,\"319\":1}}],[\"输入图像的高度和宽度\",{\"1\":{\"272\":1}}],[\"输入图像裁剪数量\",{\"1\":{\"186\":1}}],[\"输入图像大小\",{\"1\":{\"147\":1,\"804\":1,\"814\":1}}],[\"输入图像尺寸\",{\"1\":{\"142\":1,\"272\":1,\"793\":1,\"821\":1,\"822\":1}}],[\"输入图像及文本\",{\"1\":{\"128\":1}}],[\"输入图像\",{\"1\":{\"40\":1,\"167\":1,\"186\":1,\"234\":1,\"235\":1,\"794\":1,\"821\":1,\"822\":1,\"878\":1}}],[\"输出靠近\",{\"1\":{\"885\":1}}],[\"输出离散编码\",{\"0\":{\"880\":1}}],[\"输出分布不一定是高斯分布\",{\"1\":{\"865\":1}}],[\"输出分组标记\",{\"1\":{\"72\":1}}],[\"输出部分还是保持一致\",{\"1\":{\"843\":1}}],[\"输出第\",{\"1\":{\"843\":1}}],[\"输出概率高\",{\"1\":{\"840\":1}}],[\"输出我们记作\",{\"1\":{\"816\":1}}],[\"输出解析等都来自这个库\",{\"1\":{\"715\":1}}],[\"输出解析\",{\"1\":{\"714\":1}}],[\"输出解释\",{\"1\":{\"614\":1}}],[\"输出效果\",{\"1\":{\"689\":1}}],[\"输出处理\",{\"1\":{\"680\":1}}],[\"输出层\",{\"1\":{\"622\":1,\"848\":1}}],[\"输出后\",{\"1\":{\"618\":1}}],[\"输出做问答预测\",{\"1\":{\"614\":1}}],[\"输出token会与输入tokens\",{\"1\":{\"541\":1}}],[\"输出有害内容\",{\"1\":{\"539\":1}}],[\"输出更符合人类偏好\",{\"1\":{\"538\":1}}],[\"输出更少毒性内容\",{\"1\":{\"538\":1}}],[\"输出相较于标准\",{\"1\":{\"538\":1}}],[\"输出时将\",{\"1\":{\"492\":1}}],[\"输出序列y\",{\"1\":{\"481\":1}}],[\"输出位置\",{\"1\":{\"463\":1}}],[\"输出示例\",{\"1\":{\"434\":1}}],[\"输出会显示训练\",{\"1\":{\"398\":1}}],[\"输出图像形状\",{\"1\":{\"821\":1}}],[\"输出图像像素值是周围四个输入像素加权平均\",{\"1\":{\"390\":1}}],[\"输出图像特征\",{\"1\":{\"161\":1}}],[\"输出大小为\",{\"1\":{\"389\":1}}],[\"输出形状\",{\"1\":{\"367\":1,\"804\":1}}],[\"输出形状为\",{\"1\":{\"92\":2}}],[\"输出通道数\",{\"1\":{\"846\":1}}],[\"输出通道\",{\"1\":{\"318\":1,\"846\":2}}],[\"输出投影\",{\"1\":{\"272\":1}}],[\"输出投影后的\",{\"1\":{\"272\":1}}],[\"输出投影层的\",{\"1\":{\"272\":1}}],[\"输出一个固定维度的表示\",{\"1\":{\"885\":1}}],[\"输出一个固定维度的向量\",{\"1\":{\"255\":1}}],[\"输出一个softmax过的概率分布\",{\"1\":{\"880\":1}}],[\"输出一个复杂的\",{\"1\":{\"874\":1}}],[\"输出一个\",{\"1\":{\"386\":1}}],[\"输出一个字符\",{\"1\":{\"83\":1}}],[\"输出不一致时\",{\"1\":{\"236\":1}}],[\"输出是对整个序列的预测\",{\"1\":{\"820\":1}}],[\"输出是对这个回答的评分\",{\"1\":{\"232\":1}}],[\"输出是模型应该生成的响应\",{\"1\":{\"232\":1}}],[\"输出是一个变换矩阵\",{\"1\":{\"107\":1}}],[\"输出顺序\",{\"1\":{\"186\":1}}],[\"输出仅集中在一个维度\",{\"1\":{\"183\":1}}],[\"输出与教师特征的余弦相似度\",{\"1\":{\"167\":1}}],[\"输出维度为整个\",{\"1\":{\"814\":1}}],[\"输出维度为\",{\"1\":{\"580\":1}}],[\"输出维度\",{\"0\":{\"410\":1},\"1\":{\"160\":2}}],[\"输出合成描述\",{\"1\":{\"128\":1}}],[\"输出结果之后\",{\"1\":{\"323\":1}}],[\"输出结果都保持不变\",{\"1\":{\"115\":1}}],[\"输出结果\",{\"1\":{\"100\":1,\"170\":1,\"814\":1}}],[\"输出最终的插值后特征\",{\"1\":{\"100\":1}}],[\"输出的变化量最多等于输入变化量\",{\"1\":{\"839\":1}}],[\"输出的dot语言示例包含变量节点\",{\"1\":{\"696\":1}}],[\"输出的目标尺寸\",{\"1\":{\"388\":1}}],[\"输出的特征图\",{\"1\":{\"386\":1}}],[\"输出的特征送入一个小型\",{\"1\":{\"98\":1}}],[\"输出的统计特性不同\",{\"1\":{\"272\":1}}],[\"输出的样本数据\",{\"1\":{\"169\":1}}],[\"输出的\",{\"1\":{\"163\":1}}],[\"输出的数据集是经过图文对齐质量优化的图文对集合\",{\"1\":{\"140\":1}}],[\"输出的该\",{\"1\":{\"126\":1}}],[\"输出的隐藏状态映射回原始嵌入维度\",{\"1\":{\"44\":1}}],[\"输出类别概率\",{\"1\":{\"98\":1}}],[\"输出类别数\",{\"1\":{\"93\":1}}],[\"输出张量维度为\",{\"1\":{\"541\":1}}],[\"输出张量的最小长度\",{\"1\":{\"377\":1}}],[\"输出张量\",{\"1\":{\"76\":1,\"373\":1}}],[\"输出增强后的点特征\",{\"1\":{\"75\":1}}],[\"输出范围\",{\"1\":{\"46\":1,\"82\":1,\"469\":1}}],[\"输出为被\",{\"1\":{\"788\":1}}],[\"输出为标量奖励\",{\"1\":{\"537\":1}}],[\"输出为二分类\",{\"1\":{\"160\":1}}],[\"输出为\",{\"1\":{\"46\":1,\"101\":1,\"423\":1,\"804\":1,\"848\":1}}],[\"输出每个点的类别概率\",{\"1\":{\"101\":1}}],[\"输出每个点的\",{\"1\":{\"46\":2}}],[\"输出每个点云点的\",{\"1\":{\"46\":1}}],[\"输出映射回合适维度\",{\"1\":{\"40\":1}}],[\"输出\",{\"1\":{\"8\":1,\"14\":1,\"40\":1,\"46\":1,\"74\":1,\"91\":1,\"98\":1,\"100\":1,\"109\":1,\"160\":2,\"167\":1,\"186\":1,\"272\":2,\"277\":1,\"332\":1,\"333\":1,\"340\":1,\"343\":1,\"346\":2,\"374\":2,\"377\":3,\"378\":1,\"389\":1,\"390\":1,\"399\":1,\"408\":1,\"410\":1,\"423\":2,\"425\":4,\"426\":3,\"538\":1,\"541\":1,\"580\":1,\"614\":1,\"638\":2,\"647\":1,\"688\":2,\"689\":8,\"690\":4,\"692\":3,\"713\":1,\"804\":1,\"814\":1,\"821\":2,\"848\":2,\"854\":1,\"858\":1,\"885\":1}}],[\"不让它跑到离嵌入空间里的向量太远的地方\",{\"1\":{\"882\":1}}],[\"不强制对数据结构做过多限制\",{\"1\":{\"864\":1}}],[\"不允许看到当前像素\",{\"1\":{\"848\":1}}],[\"不屏蔽任何位置\",{\"1\":{\"848\":1}}],[\"不断把上一个时刻的输出作为输入\",{\"1\":{\"847\":1}}],[\"不断对点云进行下采样\",{\"1\":{\"99\":1}}],[\"不泄露未来信息\",{\"1\":{\"846\":1}}],[\"不使用任何信息\",{\"1\":{\"846\":1}}],[\"不使用传统的循环或卷积结构\",{\"1\":{\"622\":1}}],[\"不看任何输入\",{\"1\":{\"846\":1}}],[\"不妨对比下面这张示意图和上面那张示意图\",{\"1\":{\"845\":1}}],[\"不难看出\",{\"1\":{\"845\":1}}],[\"不涉及后续的改进版本\",{\"1\":{\"843\":1}}],[\"不涉及新技术的引入\",{\"1\":{\"272\":1}}],[\"不存在\",{\"1\":{\"835\":1}}],[\"不反向传播梯度\",{\"1\":{\"821\":1}}],[\"不重叠\",{\"1\":{\"815\":1}}],[\"不添加\",{\"1\":{\"809\":1}}],[\"不等式得到下界\",{\"1\":{\"807\":1}}],[\"不等式\",{\"1\":{\"807\":1,\"831\":1}}],[\"不限制\",{\"1\":{\"801\":1}}],[\"不启用\",{\"1\":{\"793\":1}}],[\"不启用kv\",{\"1\":{\"544\":1}}],[\"不管掩码图像\",{\"1\":{\"773\":1}}],[\"不管理\",{\"1\":{\"438\":1}}],[\"不幸的是\",{\"1\":{\"759\":1}}],[\"不碰那些太反直觉或病态的集合\",{\"1\":{\"728\":1}}],[\"不公开\",{\"1\":{\"704\":1}}],[\"不具备\",{\"1\":{\"690\":1}}],[\"不具备生成能力\",{\"1\":{\"616\":1}}],[\"不构建计算图\",{\"1\":{\"688\":1}}],[\"不保留中间结果\",{\"1\":{\"688\":1}}],[\"不当的内存管理可能导致内存泄漏或程序崩溃\",{\"1\":{\"687\":1}}],[\"不计入答案\",{\"1\":{\"616\":1}}],[\"不计算梯度\",{\"1\":{\"817\":1}}],[\"不计算\",{\"1\":{\"399\":1}}],[\"不足长度用padding填充\",{\"1\":{\"594\":1}}],[\"不为每个距离单独学一个参数\",{\"1\":{\"591\":1}}],[\"不为空\",{\"1\":{\"544\":1}}],[\"不直接加到注意力分数里\",{\"1\":{\"590\":1}}],[\"不直接优化最终目标\",{\"1\":{\"82\":1}}],[\"不可微的\",{\"1\":{\"868\":1}}],[\"不可导\",{\"1\":{\"796\":1}}],[\"不可学习的\",{\"1\":{\"587\":1}}],[\"不可靠\",{\"1\":{\"159\":1}}],[\"不少人很自然地有了这样子的想法\",{\"1\":{\"571\":1}}],[\"不跨文档\",{\"1\":{\"564\":1}}],[\"不再使用\",{\"1\":{\"848\":1}}],[\"不再需要外部的\",{\"1\":{\"814\":1}}],[\"不再预先固定掩码模式\",{\"1\":{\"562\":1}}],[\"不再这里一一介绍\",{\"1\":{\"488\":1}}],[\"不展开细聊\",{\"1\":{\"544\":1}}],[\"不展开计算细节\",{\"1\":{\"455\":1}}],[\"不代表所有潜在用户\",{\"1\":{\"539\":1}}],[\"不如在现有模型上投资对齐方法\",{\"1\":{\"539\":1}}],[\"不如抽样一部分数据来计算损失\",{\"1\":{\"248\":1}}],[\"不遵循指令等问题\",{\"1\":{\"535\":1}}],[\"不利于学习率等超参数设置\",{\"1\":{\"815\":1}}],[\"不利于迁移与泛化\",{\"1\":{\"531\":1}}],[\"不利于高维空间建模\",{\"1\":{\"112\":1}}],[\"不给任何示例\",{\"1\":{\"528\":1}}],[\"不清楚在学习文本表示时\",{\"1\":{\"507\":1}}],[\"不要求互斥\",{\"1\":{\"729\":1}}],[\"不要求原始张量是连续的\",{\"1\":{\"362\":1}}],[\"不要预训练\",{\"1\":{\"516\":1}}],[\"不要让llm只生成最合适的唯一一个结果\",{\"1\":{\"502\":1}}],[\"不变的情况下\",{\"1\":{\"773\":1}}],[\"不变\",{\"1\":{\"490\":1}}],[\"不平衡数据集的一个示例可能是一组数以千计的云彩照片\",{\"1\":{\"442\":1}}],[\"不平衡标签\",{\"1\":{\"398\":1}}],[\"不一定是字节\",{\"1\":{\"423\":1}}],[\"不一致\",{\"1\":{\"249\":1}}],[\"不一致则重新随机选\",{\"1\":{\"29\":1}}],[\"不相关\",{\"1\":{\"455\":1}}],[\"不相似\",{\"1\":{\"391\":1}}],[\"不相邻\",{\"1\":{\"372\":1}}],[\"不对应实际的\",{\"1\":{\"387\":1}}],[\"不对同索引的学生视图进行监督\",{\"1\":{\"186\":1}}],[\"不进行任何量化\",{\"1\":{\"387\":1}}],[\"不进行采样\",{\"1\":{\"92\":1}}],[\"不创建新张量\",{\"1\":{\"371\":1}}],[\"不复制数据\",{\"1\":{\"362\":1}}],[\"不是编码为\",{\"1\":{\"885\":1}}],[\"不是高斯分布\",{\"1\":{\"871\":1}}],[\"不是标准正态分布\",{\"1\":{\"867\":1}}],[\"不是标准差\",{\"1\":{\"748\":1}}],[\"不是像离散情况那样简单地枚举出来的\",{\"1\":{\"728\":1}}],[\"不是自回归生成器\",{\"1\":{\"616\":1}}],[\"不是三角函数\",{\"1\":{\"573\":1}}],[\"不是视图\",{\"1\":{\"363\":1}}],[\"不是函数原文档\",{\"1\":{\"346\":1}}],[\"不是\",{\"1\":{\"346\":1}}],[\"不是一千个类别\",{\"1\":{\"243\":1}}],[\"不会引入真正意义上的正则化因子\",{\"1\":{\"873\":1}}],[\"不会作为可训练参数\",{\"1\":{\"848\":1}}],[\"不会过滤掉任何词\",{\"1\":{\"476\":1}}],[\"不会影响其他环境或系统\",{\"1\":{\"438\":1}}],[\"不会产生块状感\",{\"1\":{\"390\":1}}],[\"不会对像素值进行加权平均或平滑处理\",{\"1\":{\"389\":1}}],[\"不会只看一个村\",{\"1\":{\"387\":1}}],[\"不会出现在model\",{\"1\":{\"366\":1}}],[\"不会被模型训练修改\",{\"1\":{\"814\":1}}],[\"不会被当作模型的可训练参数\",{\"1\":{\"366\":1}}],[\"不会被认为是可训练参数\",{\"1\":{\"170\":1}}],[\"不会跟踪计算图\",{\"1\":{\"365\":1}}],[\"不会复制数据\",{\"1\":{\"361\":1}}],[\"不会泄漏到外部\",{\"1\":{\"336\":1}}],[\"不产生新作用域\",{\"1\":{\"336\":3}}],[\"不适合处理需要复杂推理的\",{\"1\":{\"261\":1}}],[\"不就是分类操作吗\",{\"1\":{\"246\":1}}],[\"不做预训练\",{\"1\":{\"237\":1}}],[\"不做任何操作\",{\"1\":{\"170\":1}}],[\"不做任何变化\",{\"1\":{\"107\":1}}],[\"不含\",{\"1\":{\"210\":1,\"814\":1}}],[\"不监督同索引的学生视图\",{\"1\":{\"186\":1}}],[\"不过这里要注意一点\",{\"1\":{\"872\":1}}],[\"不过这种标签信息\",{\"1\":{\"242\":1}}],[\"不过我们知道\",{\"1\":{\"869\":1}}],[\"不过一个更恰当的术语可能是\",{\"1\":{\"748\":1}}],[\"不过迭代次数较多\",{\"1\":{\"697\":1}}],[\"不过\",{\"1\":{\"185\":1,\"443\":1,\"871\":1,\"873\":1}}],[\"不必显式区分图像也能学到好特征\",{\"1\":{\"175\":1}}],[\"不参与训练\",{\"1\":{\"814\":1}}],[\"不参与梯度更新\",{\"1\":{\"169\":1}}],[\"不参与反向传播\",{\"1\":{\"161\":1}}],[\"不修改原始函数代码的前提下\",{\"1\":{\"342\":1}}],[\"不修改\",{\"1\":{\"163\":1}}],[\"不匹配\",{\"1\":{\"162\":1}}],[\"不考虑元素之间的顺序\",{\"0\":{\"763\":1}}],[\"不考虑各维度数据的分布特征\",{\"1\":{\"457\":1}}],[\"不考虑从动量队列拿到的负样本\",{\"1\":{\"162\":1}}],[\"不考虑空间邻域关系\",{\"1\":{\"107\":1}}],[\"不包括输出层\",{\"1\":{\"848\":1}}],[\"不包括\",{\"1\":{\"117\":1}}],[\"不改变形状和大小\",{\"1\":{\"117\":1}}],[\"不改变物体形状和内部结构\",{\"1\":{\"116\":1}}],[\"不改变\",{\"1\":{\"116\":1}}],[\"不常用\",{\"1\":{\"115\":1,\"163\":1,\"614\":1}}],[\"不够大\",{\"1\":{\"112\":1}}],[\"不够精细\",{\"1\":{\"112\":1}}],[\"不稳定\",{\"1\":{\"107\":1}}],[\"不同头可以学习到不同的相对位置偏置模式\",{\"1\":{\"591\":1}}],[\"不同字母\",{\"1\":{\"590\":1}}],[\"不同的\",{\"1\":{\"571\":1}}],[\"不同的措辞\",{\"1\":{\"530\":1}}],[\"不同的消融研究如下表5\",{\"1\":{\"516\":1}}],[\"不同的分类角度\",{\"1\":{\"483\":1}}],[\"不同的相似性匹配损失\",{\"1\":{\"175\":1}}],[\"不同类别的\",{\"1\":{\"455\":1}}],[\"不同类别的物体处于不相邻的区域\",{\"1\":{\"242\":1}}],[\"不同样本累加到不同的簇行\",{\"1\":{\"379\":1}}],[\"不同样本之间的数值范围差异很大\",{\"1\":{\"170\":1}}],[\"不同特征之间能够进行更多样的组合\",{\"1\":{\"321\":1}}],[\"不同模态数据的提取与融合\",{\"1\":{\"308\":1}}],[\"不同\",{\"1\":{\"268\":1,\"547\":1,\"591\":1,\"766\":1}}],[\"不同于固定编码\",{\"1\":{\"588\":1}}],[\"不同于\",{\"1\":{\"265\":1}}],[\"不同配置对性能影响较小\",{\"1\":{\"197\":1}}],[\"不同分辨率的输入会被分组\",{\"1\":{\"186\":1}}],[\"不同位置\",{\"1\":{\"107\":1}}],[\"不同尺度的查询半径列表\",{\"1\":{\"96\":1}}],[\"不同尺度的特征被串联形成多尺度特征向量\",{\"1\":{\"95\":1}}],[\"不灵活等问题\",{\"1\":{\"103\":1}}],[\"不带法向量或其他属性\",{\"1\":{\"101\":1}}],[\"不能为负\",{\"1\":{\"853\":1}}],[\"不能看自己\",{\"1\":{\"846\":1}}],[\"不能看到\",{\"1\":{\"846\":1}}],[\"不能看到当前像素和右下角的像素\",{\"1\":{\"846\":1}}],[\"不能看到第\",{\"1\":{\"843\":1}}],[\"不能直接用反向传播训练神经网络\",{\"1\":{\"795\":1}}],[\"不能直接使用这些操作\",{\"1\":{\"100\":1}}],[\"不能\",{\"1\":{\"616\":1}}],[\"不能超出上下文范围\",{\"1\":{\"616\":1}}],[\"不能超过数据集大小\",{\"1\":{\"403\":1}}],[\"不能像\",{\"1\":{\"616\":1}}],[\"不能用\",{\"1\":{\"493\":1}}],[\"不能变成\",{\"1\":{\"364\":1}}],[\"不能作为\",{\"1\":{\"82\":1}}],[\"不通过缓存直接将内容打印到屏幕上\",{\"1\":{\"83\":1}}],[\"不支持的\",{\"1\":{\"802\":1}}],[\"不支持\",{\"1\":{\"82\":1,\"364\":1}}],[\"不像\",{\"1\":{\"82\":1,\"467\":1,\"469\":1,\"802\":1}}],[\"不仅依赖于生成器\",{\"1\":{\"868\":1}}],[\"不仅要包含数字的类别信息\",{\"1\":{\"866\":1}}],[\"不仅可以传入文本条件\",{\"1\":{\"817\":1}}],[\"不仅限于英语\",{\"1\":{\"705\":1}}],[\"不仅具备了现代框架应有的可视化与控制能力\",{\"1\":{\"695\":1}}],[\"不仅因为其前向计算功能\",{\"1\":{\"680\":1}}],[\"不仅在分类任务上逼近了有监督的基线模型\",{\"1\":{\"241\":1}}],[\"不仅考虑从当前分辨率下抽象得到的特征\",{\"1\":{\"97\":1}}],[\"不仅理解语言指令\",{\"1\":{\"82\":1}}],[\"不仅理解自己的语义\",{\"1\":{\"76\":1}}],[\"不仅看交集\",{\"1\":{\"82\":1}}],[\"不需要预测\",{\"1\":{\"815\":1}}],[\"不需要像\",{\"1\":{\"591\":1}}],[\"不需要先\",{\"1\":{\"467\":1}}],[\"不需要创建类的实例\",{\"1\":{\"316\":1}}],[\"不需要额外训练一个对比判别器或辅助网络\",{\"1\":{\"816\":1}}],[\"不需要额外增加一个视觉encoder\",{\"1\":{\"281\":1,\"284\":1}}],[\"不需要额外标注数据\",{\"1\":{\"239\":1}}],[\"不需要知道第三张图片是狗这个类别\",{\"1\":{\"242\":1}}],[\"不需要类别分类器\",{\"1\":{\"186\":1}}],[\"不需要超参数调节\",{\"1\":{\"179\":1}}],[\"不需要\",{\"1\":{\"82\":1}}],[\"不依赖于\",{\"1\":{\"867\":1}}],[\"不依赖任何训练标签\",{\"1\":{\"806\":1}}],[\"不依赖绝对数量\",{\"1\":{\"468\":1}}],[\"不依赖数据增强\",{\"1\":{\"179\":1}}],[\"不依赖目标检测器\",{\"1\":{\"149\":1}}],[\"不依赖特定阈值\",{\"1\":{\"82\":1}}],[\"不依赖\",{\"1\":{\"82\":1}}],[\"不加\",{\"1\":{\"75\":1}}],[\"不在训练中透露\",{\"1\":{\"66\":1}}],[\"不方便进行处理\",{\"1\":{\"38\":1}}],[\"待微调的参数量下降到原来的9\",{\"1\":{\"490\":1}}],[\"待填充的张量\",{\"1\":{\"369\":1}}],[\"待完善\",{\"0\":{\"38\":1}}],[\"待预测功能区域类型列表\",{\"1\":{\"29\":1}}],[\"待预测功能区域类型\",{\"1\":{\"29\":1}}],[\"待预测功能区域类型全部隐含在了样本对应的文件路径中\",{\"1\":{\"29\":1}}],[\"由一个\",{\"1\":{\"809\":1}}],[\"由多层\",{\"1\":{\"544\":1}}],[\"由标注者排序\",{\"1\":{\"537\":1}}],[\"由人类标注者根据偏好进行排序\",{\"1\":{\"537\":1}}],[\"由openai团队提出\",{\"1\":{\"519\":1}}],[\"由何恺明团队在2017年论文\",{\"1\":{\"470\":1}}],[\"由协方差控制\",{\"1\":{\"455\":1}}],[\"由权重\",{\"1\":{\"385\":1}}],[\"由此诱导出的\",{\"1\":{\"747\":1}}],[\"由此提出低秩自适应\",{\"1\":{\"491\":1}}],[\"由此可见vit工作的局限性\",{\"1\":{\"324\":1}}],[\"由此把图片转换为序列的embedding形式\",{\"1\":{\"318\":1}}],[\"由两个transformer模块组成\",{\"1\":{\"309\":1}}],[\"由两部分组成\",{\"1\":{\"178\":1}}],[\"由它们投票决定分类\",{\"1\":{\"179\":1}}],[\"由自注意力层与前馈层组成\",{\"1\":{\"179\":1}}],[\"由三层\",{\"1\":{\"178\":1}}],[\"由三角形面片组成的\",{\"1\":{\"114\":1}}],[\"由动量编码器构建\",{\"1\":{\"173\":1}}],[\"由编码器和量化器组成\",{\"1\":{\"167\":1}}],[\"由\",{\"1\":{\"72\":1,\"73\":1,\"88\":1,\"577\":1,\"771\":1,\"807\":1,\"809\":1}}],[\"由于训练轮次很少\",{\"1\":{\"886\":1}}],[\"由于训练数据量和模型计算量较大\",{\"1\":{\"305\":1}}],[\"由于算上了重建误差\",{\"1\":{\"882\":1}}],[\"由于期望的线性性质\",{\"1\":{\"868\":1}}],[\"由于我们用的是近似的编码分布\",{\"1\":{\"872\":1}}],[\"由于我们关心的是给定样本\",{\"1\":{\"867\":1}}],[\"由于我们可以轻松地用神经网络建模每个子像素的概率分布并完成采样\",{\"1\":{\"847\":1}}],[\"由于我们主要关注图像建模\",{\"1\":{\"809\":1}}],[\"由于整幅训练图像已知\",{\"1\":{\"843\":1}}],[\"由于对数是单调递增的\",{\"1\":{\"826\":1}}],[\"由于文本token和图像token被拼接在一起\",{\"1\":{\"814\":1}}],[\"由于潜在的视觉\",{\"1\":{\"770\":1}}],[\"由于概率密度函数的峰值\",{\"1\":{\"753\":1}}],[\"由于该集合是不可数的\",{\"1\":{\"728\":1}}],[\"由于大模型应用需要进行向量语义检索\",{\"1\":{\"717\":1}}],[\"由于与人类交流的出色能力\",{\"1\":{\"704\":1}}],[\"由于for语句反复使用variable实例x0和x1求导\",{\"1\":{\"697\":1}}],[\"由于减法不满足交换律\",{\"1\":{\"690\":1}}],[\"由于乘法满足交换律\",{\"1\":{\"690\":2}}],[\"由于目前variable\",{\"1\":{\"685\":1}}],[\"由于目前只支持竖线形状的计算图\",{\"1\":{\"668\":1}}],[\"由于目标功能区域的尺度\",{\"1\":{\"71\":1}}],[\"由于模型输出的logits\",{\"1\":{\"581\":1}}],[\"由于掩码模式是固定的\",{\"1\":{\"562\":1}}],[\"由于bert训练时会多次遍历数据\",{\"1\":{\"562\":1}}],[\"由于不涉及kv\",{\"1\":{\"544\":1}}],[\"由于gpt\",{\"1\":{\"522\":1}}],[\"由于矩阵\",{\"1\":{\"493\":1}}],[\"由于需要对每个像素进行分类\",{\"1\":{\"465\":1}}],[\"由于准确率包含混淆矩阵中的所有四种结果\",{\"1\":{\"443\":1}}],[\"由于坐标是浮点数\",{\"1\":{\"387\":1}}],[\"由于特征图的尺寸比原图小\",{\"1\":{\"386\":1}}],[\"由于作者是首次将transformer应用到图像领域\",{\"1\":{\"325\":1}}],[\"由于它们在预训练数据集上采用固定类别数的分类器\",{\"1\":{\"305\":1}}],[\"由于这些文本往往只是一个单词\",{\"1\":{\"301\":1}}],[\"由于数据量巨大\",{\"1\":{\"299\":1}}],[\"由于使用了\",{\"1\":{\"273\":1,\"426\":1}}],[\"由于正样本的定义规则是经过编码器之后所在的语义空间才为正样本\",{\"1\":{\"249\":1}}],[\"由于第一阶段中已获得了强大的表示能力\",{\"1\":{\"199\":1}}],[\"由于\",{\"1\":{\"186\":1,\"198\":1,\"313\":1,\"544\":1,\"622\":1,\"752\":1,\"808\":1,\"810\":1,\"848\":1,\"866\":1,\"881\":1,\"885\":1}}],[\"由于图文对来自自然语言描述\",{\"1\":{\"145\":1}}],[\"由于经过\",{\"1\":{\"136\":1}}],[\"由于高质量人工标注图文对\",{\"1\":{\"128\":1}}],[\"由于表情不同\",{\"1\":{\"112\":1}}],[\"由于子区域在计算第一个向量时包含的点更稀疏\",{\"1\":{\"97\":1}}],[\"由于点集在不同区域可能会有不同的采样密度\",{\"1\":{\"94\":1}}],[\"由于论文数据集还未开源\",{\"1\":{\"37\":1}}],[\"由成对的\",{\"1\":{\"16\":1}}],[\"加位置\",{\"1\":{\"822\":1}}],[\"加起来\",{\"1\":{\"731\":1}}],[\"加法规则\",{\"1\":{\"729\":1}}],[\"加法运算的add类已在上文中实现\",{\"1\":{\"690\":1}}],[\"加法运算的运算符重载\",{\"1\":{\"690\":1}}],[\"加到\",{\"1\":{\"771\":1}}],[\"加到注意力分数的时机\",{\"1\":{\"591\":1}}],[\"加到注意力分数\",{\"1\":{\"591\":1}}],[\"加到该头的注意力分数上\",{\"1\":{\"591\":1}}],[\"加\",{\"1\":{\"293\":1,\"590\":1}}],[\"加速收敛\",{\"1\":{\"511\":1}}],[\"加速\",{\"1\":{\"186\":1}}],[\"加单位矩阵\",{\"1\":{\"107\":1}}],[\"加入梯度修正\",{\"1\":{\"821\":1}}],[\"加入多个\",{\"1\":{\"777\":1}}],[\"加入了均匀先验\",{\"1\":{\"770\":1}}],[\"加入到验证集中\",{\"1\":{\"716\":1}}],[\"加入数值稳定性处理\",{\"1\":{\"473\":1}}],[\"加入数据增强后缓解\",{\"1\":{\"112\":1}}],[\"加入平滑项防止除以零\",{\"1\":{\"469\":1}}],[\"加入动量队列中的样本作为负样本\",{\"1\":{\"161\":1}}],[\"加入正则项约束变换矩阵接近正交\",{\"1\":{\"105\":1}}],[\"加入\",{\"1\":{\"75\":2,\"107\":1,\"467\":1,\"468\":2,\"804\":1}}],[\"加上因为近似不准而多花的那部分成本\",{\"1\":{\"831\":1}}],[\"加上位置\",{\"1\":{\"822\":1}}],[\"加上位置嵌入并进行随机丢弃\",{\"1\":{\"320\":1,\"323\":1}}],[\"加上参数规模的扩展\",{\"1\":{\"528\":1}}],[\"加上这样一句话\",{\"1\":{\"500\":1}}],[\"加上类型\",{\"1\":{\"277\":1}}],[\"加上\",{\"1\":{\"277\":2,\"371\":1,\"795\":1,\"800\":1,\"819\":1}}],[\"加上全局特征后\",{\"1\":{\"111\":1}}],[\"加上单位矩阵作为初始偏置\",{\"1\":{\"107\":1}}],[\"加上原始\",{\"1\":{\"72\":1}}],[\"加上经典的\",{\"1\":{\"36\":1}}],[\"加权惩罚项\",{\"1\":{\"471\":1}}],[\"加权\",{\"1\":{\"469\":1,\"511\":1}}],[\"加权标准化器\",{\"1\":{\"459\":1}}],[\"加权计数\",{\"1\":{\"377\":1}}],[\"加权和\",{\"1\":{\"115\":1}}],[\"加权平均插值\",{\"1\":{\"100\":1}}],[\"加权平均系数\",{\"1\":{\"100\":1}}],[\"加权交叉熵损失\",{\"1\":{\"473\":1}}],[\"加权交叉熵\",{\"1\":{\"78\":1}}],[\"加权后的输出\",{\"1\":{\"45\":2}}],[\"加权总损失\",{\"1\":{\"40\":1,\"794\":1}}],[\"加之原本在github上开源的代码后续被下架\",{\"1\":{\"37\":1}}],[\"加载离散\",{\"1\":{\"803\":1}}],[\"加载图像文件夹作为数据集\",{\"1\":{\"802\":1}}],[\"加载图像数据\",{\"1\":{\"28\":1}}],[\"加载检查点\",{\"1\":{\"581\":1}}],[\"加载该模型后\",{\"1\":{\"327\":1}}],[\"加载模型和\",{\"1\":{\"541\":1}}],[\"加载模型和处理器\",{\"1\":{\"302\":1,\"304\":1}}],[\"加载模型配置\",{\"1\":{\"83\":1}}],[\"加载初始化码本\",{\"1\":{\"169\":1}}],[\"加载文本编码器\",{\"1\":{\"160\":2}}],[\"加载\",{\"1\":{\"142\":1,\"147\":1,\"170\":1}}],[\"加载数据集\",{\"1\":{\"885\":1}}],[\"加载数据\",{\"1\":{\"142\":1}}],[\"加载预训练\",{\"1\":{\"886\":1}}],[\"加载预训练好的vit\",{\"1\":{\"327\":1}}],[\"加载预训练模型\",{\"0\":{\"327\":1},\"1\":{\"885\":1}}],[\"加载预训练视觉编码器与文本解码器\",{\"1\":{\"142\":1}}],[\"加载预训练权重\",{\"1\":{\"83\":1}}],[\"加载预训练多模态大模型\",{\"1\":{\"28\":1}}],[\"加载训练集\",{\"1\":{\"80\":1}}],[\"加载的标注数据中每个样本的组织形式如下\",{\"1\":{\"68\":1}}],[\"加载58种物体\",{\"1\":{\"68\":1}}],[\"加载标注数据\",{\"1\":{\"68\":1,\"83\":1}}],[\"加载点云数据\",{\"1\":{\"68\":1,\"83\":1}}],[\"加载点云数据和功能区域掩码\",{\"1\":{\"29\":1}}],[\"加载点云\",{\"1\":{\"58\":1}}],[\"加载点云样本\",{\"1\":{\"29\":1}}],[\"加载列表中所有点云样本\",{\"1\":{\"29\":1}}],[\"先验\",{\"1\":{\"807\":1}}],[\"先验分布\",{\"1\":{\"759\":1,\"798\":1}}],[\"先只看图像部分\",{\"1\":{\"807\":1}}],[\"先从标准正态分布采样\",{\"1\":{\"868\":1}}],[\"先从\",{\"1\":{\"807\":1}}],[\"先有预期\",{\"1\":{\"758\":1}}],[\"先定义计算图再执行\",{\"1\":{\"692\":1}}],[\"先算\",{\"1\":{\"591\":1}}],[\"先看两个输入的形状\",{\"1\":{\"590\":1}}],[\"先进先出\",{\"1\":{\"685\":1}}],[\"先进行\",{\"1\":{\"544\":1}}],[\"先进归一化方式或对比损失\",{\"1\":{\"173\":1}}],[\"先通过\",{\"1\":{\"470\":1}}],[\"先计算每一维的均值\",{\"1\":{\"455\":1}}],[\"先激活你的conda环境\",{\"1\":{\"438\":1}}],[\"先把目标区域平均切成小格子\",{\"1\":{\"387\":1}}],[\"先应用最内层的\",{\"1\":{\"350\":1}}],[\"先返回\",{\"1\":{\"345\":1}}],[\"先经过一层或多层\",{\"1\":{\"326\":1}}],[\"先交给预输出层进行处理\",{\"1\":{\"323\":1}}],[\"先利用大规模\",{\"1\":{\"269\":1}}],[\"先预训练好一个骨干模型\",{\"1\":{\"245\":1}}],[\"先生成答案再推理\",{\"1\":{\"237\":1}}],[\"先生成两张全局\",{\"1\":{\"186\":1}}],[\"先用pixelcnn采样出\",{\"1\":{\"878\":1}}],[\"先用\",{\"1\":{\"326\":1}}],[\"先用自定义\",{\"1\":{\"210\":1}}],[\"先用对比学习对齐图文表示\",{\"1\":{\"150\":1}}],[\"先在大规模噪声数据上对比学习\",{\"1\":{\"189\":1}}],[\"先以\",{\"1\":{\"159\":1,\"210\":1}}],[\"先对齐后融合\",{\"1\":{\"149\":1}}],[\"先升维后降维\",{\"1\":{\"59\":1}}],[\"先降维\",{\"1\":{\"36\":1}}],[\"先了解一下great项目对应的数据集目录结构\",{\"1\":{\"29\":1}}],[\"逐像素建模图像像素值的条件概率分布\",{\"1\":{\"848\":1}}],[\"逐\",{\"1\":{\"820\":1}}],[\"逐位置前馈神经网络\",{\"1\":{\"514\":1}}],[\"逐元素相加然后送入线性输出层\",{\"1\":{\"512\":1}}],[\"逐列\",{\"1\":{\"425\":1}}],[\"逐渐丰富了其功能\",{\"1\":{\"704\":1}}],[\"逐渐引入\",{\"1\":{\"159\":1}}],[\"逐渐恢复点数\",{\"1\":{\"98\":1}}],[\"逐点\",{\"1\":{\"107\":1,\"468\":1}}],[\"逐点误差\",{\"1\":{\"82\":1}}],[\"逐层通过\",{\"1\":{\"804\":1}}],[\"逐层编码\",{\"1\":{\"771\":1}}],[\"逐层提取边缘→纹理→部件→物体\",{\"1\":{\"385\":1}}],[\"逐层融合上下文信息\",{\"1\":{\"101\":1}}],[\"逐层恢复到原始点数\",{\"1\":{\"99\":1}}],[\"逐层将特征插值回原始点数量\",{\"1\":{\"98\":1}}],[\"逐层抽象后融合成全局特征\",{\"1\":{\"96\":1}}],[\"逐层点云特征列表\",{\"1\":{\"35\":1}}],[\"逐步进行完善和优化\",{\"1\":{\"717\":1}}],[\"逐步推理\",{\"1\":{\"706\":1}}],[\"逐步合并高频的字符对\",{\"1\":{\"475\":1}}],[\"逐步压缩信息\",{\"1\":{\"385\":1}}],[\"逐步聚合全局信息\",{\"1\":{\"319\":1}}],[\"逐步缩小差距\",{\"1\":{\"220\":1}}],[\"逐步提升模型性能\",{\"1\":{\"189\":1}}],[\"逐步向正交矩阵靠拢\",{\"1\":{\"107\":1}}],[\"逐步减少点的数量\",{\"1\":{\"98\":1}}],[\"逐步以自上而下的方式细化点特征图\",{\"1\":{\"71\":1}}],[\"逐步分析交互图像中的几何属性和交互意图\",{\"1\":{\"5\":1}}],[\"逐级做点集抽象得到的每层的点集坐标和点集特征集合\",{\"1\":{\"70\":1}}],[\"逐个拼接\",{\"1\":{\"43\":1}}],[\"通义\",{\"1\":{\"704\":1}}],[\"通义千问是由阿里巴巴基于\",{\"1\":{\"704\":1}}],[\"通义千问\",{\"1\":{\"703\":1,\"704\":2}}],[\"通俗易懂讲解lora微调\",{\"0\":{\"489\":1},\"1\":{\"489\":1}}],[\"通俗易懂解读bpe分词算法实现\",{\"0\":{\"475\":1},\"1\":{\"475\":1}}],[\"通俗讲人话\",{\"1\":{\"487\":1}}],[\"通道时\",{\"1\":{\"846\":3}}],[\"通道信息\",{\"1\":{\"846\":4}}],[\"通道编号\",{\"1\":{\"846\":1}}],[\"通道之间的因果关系\",{\"1\":{\"846\":1}}],[\"通道掩码\",{\"0\":{\"846\":1},\"1\":{\"846\":1}}],[\"通道数\",{\"1\":{\"272\":1,\"821\":1}}],[\"通道维度特征提取阶段\",{\"1\":{\"107\":1}}],[\"通道维度完成拼接后\",{\"1\":{\"59\":1}}],[\"通道维度作信息融合\",{\"1\":{\"36\":1}}],[\"通道维度上进行特征融合\",{\"1\":{\"34\":1,\"35\":1}}],[\"通用图像增强流程\",{\"1\":{\"802\":1}}],[\"通用大模型的架构\",{\"1\":{\"717\":1}}],[\"通用人工智能\",{\"1\":{\"708\":1}}],[\"通用网络层封装与模型训练流程构建\",{\"1\":{\"699\":1}}],[\"通用的任务未知task\",{\"1\":{\"506\":1}}],[\"通用近似定理中\",{\"1\":{\"385\":1}}],[\"通用近似定理\",{\"0\":{\"385\":1},\"1\":{\"385\":1}}],[\"通用视觉助手\",{\"1\":{\"235\":1}}],[\"通用任务\",{\"1\":{\"229\":1}}],[\"通用多模态任务\",{\"1\":{\"228\":1}}],[\"通常用作图像压缩或聚类\",{\"1\":{\"885\":1}}],[\"通常用于实现完整功能\",{\"1\":{\"691\":1}}],[\"通常用于分割模型中\",{\"1\":{\"468\":1}}],[\"通常并没有这样的正则化参数\",{\"1\":{\"873\":1}}],[\"通常的选择是将其设为\",{\"1\":{\"868\":1}}],[\"通常取对数得到对数似然\",{\"1\":{\"826\":1}}],[\"通常设置为\",{\"1\":{\"815\":1}}],[\"通常设为\",{\"1\":{\"403\":1}}],[\"通常图像\",{\"1\":{\"815\":1}}],[\"通常小于主图像\",{\"1\":{\"803\":1}}],[\"通常比卷积神经网络\",{\"1\":{\"766\":1}}],[\"通常需要重新训练来保持知识和数据的更新\",{\"1\":{\"711\":1}}],[\"通常需要使用高性能的\",{\"1\":{\"705\":1}}],[\"通常需要数千到数十万个标注样本\",{\"1\":{\"528\":1}}],[\"通常具有巨大的参数规模\",{\"1\":{\"705\":1}}],[\"通常大模型由三个阶段构成\",{\"1\":{\"703\":1}}],[\"通常指包含数百亿\",{\"1\":{\"703\":1}}],[\"通常在内存不足或满足特定条件时才会触发\",{\"1\":{\"687\":1}}],[\"通常在大规模数据集\",{\"1\":{\"317\":1}}],[\"通常这些开源的大模型都是需要用自有数据进行微调\",{\"1\":{\"482\":1}}],[\"通常问题不大\",{\"1\":{\"482\":1}}],[\"通常最后会将预训练生成的频次表和词汇表写入文件保存\",{\"1\":{\"476\":1}}],[\"通常最好优先考虑召回率\",{\"1\":{\"447\":1}}],[\"通常\",{\"1\":{\"470\":2,\"482\":1,\"501\":1,\"591\":1}}],[\"通常加入平滑项\",{\"1\":{\"469\":1}}],[\"通常意味着对各个轴进行更一般的排列组合\",{\"1\":{\"426\":1}}],[\"通常使用预训练的目标检测器\",{\"1\":{\"280\":1}}],[\"通常使用图文对比学习优化模型\",{\"1\":{\"261\":1}}],[\"通常使用轻量级的\",{\"1\":{\"189\":1}}],[\"通常会用\",{\"1\":{\"358\":1}}],[\"通常会加入一个\",{\"1\":{\"248\":1}}],[\"通常会设置一个上限k\",{\"1\":{\"90\":1}}],[\"通常保留原始结构\",{\"1\":{\"239\":1}}],[\"通常是标准正态分布\",{\"1\":{\"866\":1}}],[\"通常是均匀或高斯\",{\"1\":{\"840\":1}}],[\"通常是不同尺寸的原图\",{\"1\":{\"803\":1}}],[\"通常是高斯\",{\"1\":{\"773\":1}}],[\"通常是模糊的\",{\"1\":{\"759\":1}}],[\"通常是在1000亿参数\",{\"1\":{\"501\":1}}],[\"通常是字节\",{\"1\":{\"421\":1}}],[\"通常是原图的\",{\"1\":{\"386\":1}}],[\"通常是随机初始化或者初始化为零\",{\"1\":{\"320\":1}}],[\"通常是\",{\"1\":{\"274\":1,\"276\":1,\"324\":1,\"615\":1}}],[\"通常是图像内容的全面视觉描述\",{\"1\":{\"234\":1}}],[\"通常是旋转或反射\",{\"1\":{\"107\":1}}],[\"通常采用对比学习预训练的\",{\"1\":{\"223\":1}}],[\"通常仅3亿参数\",{\"1\":{\"216\":1}}],[\"通常为标准正态分布\",{\"1\":{\"854\":1}}],[\"通常为3\",{\"1\":{\"793\":1}}],[\"通常为4个采样点\",{\"1\":{\"387\":1}}],[\"通常为全\",{\"1\":{\"162\":1}}],[\"通常为\",{\"1\":{\"160\":1,\"793\":1,\"821\":1}}],[\"通常依赖预训练教师\",{\"1\":{\"150\":1}}],[\"通常我们会使用多个\",{\"1\":{\"82\":1}}],[\"通过正常反向传播重建误差更新\",{\"1\":{\"885\":1}}],[\"通过正弦和余弦函数分裂映射到偶数和奇数的维度\",{\"1\":{\"587\":1}}],[\"通过阅读这篇文章\",{\"1\":{\"877\":1}}],[\"通过一个确定性函数族\",{\"1\":{\"865\":1}}],[\"通过一些自动化的手段将web\",{\"1\":{\"305\":1}}],[\"通过加入\",{\"1\":{\"857\":1}}],[\"通过加偏置\",{\"1\":{\"591\":1}}],[\"通过设置\",{\"1\":{\"848\":1}}],[\"通过设计合理的预训练任务\",{\"1\":{\"248\":1}}],[\"通过给图像损失设置更高的权重\",{\"1\":{\"815\":1}}],[\"通过让一部分样本在训练时不给文本输入\",{\"1\":{\"815\":1}}],[\"通过最大化关于\",{\"1\":{\"809\":1}}],[\"通过最小化配置\",{\"1\":{\"204\":1}}],[\"通过卷积将图像划分为\",{\"1\":{\"804\":1}}],[\"通过卷积提取每个网格的视觉特征\",{\"1\":{\"280\":1}}],[\"通过遮挡图像\",{\"1\":{\"790\":1}}],[\"通过预测离散视觉\",{\"1\":{\"772\":1}}],[\"通过预训练权重实现视觉特征到llm表示的对齐\",{\"1\":{\"197\":1}}],[\"通过自监督学习的方式\",{\"1\":{\"767\":1}}],[\"通过自注意力机制与其他\",{\"1\":{\"319\":1}}],[\"通过自注意力建模模态内结构关系\",{\"1\":{\"54\":1}}],[\"通过高层语义的离散标记学习更有效的视觉表示\",{\"1\":{\"765\":1}}],[\"通过图像分词器生成\",{\"1\":{\"765\":1}}],[\"通过图1的结果可见\",{\"1\":{\"535\":1}}],[\"通过观察结果\",{\"1\":{\"759\":1}}],[\"通过反复地做并集\",{\"1\":{\"728\":1}}],[\"通过反向传播算法更新低秩矩阵\",{\"1\":{\"490\":1}}],[\"通过与\",{\"1\":{\"714\":1}}],[\"通过与其他\",{\"1\":{\"319\":1}}],[\"通过在训练集上训练模型\",{\"1\":{\"716\":1}}],[\"通过在特定数据集上进一步训练大语言模型\",{\"1\":{\"711\":1}}],[\"通过在长篇连续文本的多样化语料库上预训练\",{\"1\":{\"517\":1}}],[\"通过提供额外的背景知识和数据支持\",{\"1\":{\"709\":1}}],[\"通过提示词让它自己做任务\",{\"1\":{\"239\":1}}],[\"通过检索到的真实信息生成回答\",{\"1\":{\"711\":1}}],[\"通过检索和整合长文本信息\",{\"1\":{\"709\":1}}],[\"通过检索特定领域的相关文档\",{\"1\":{\"709\":1}}],[\"通过检索数据源\",{\"1\":{\"709\":1}}],[\"通过实时检索最新数据\",{\"1\":{\"709\":1}}],[\"通过采用\",{\"1\":{\"706\":1}}],[\"通过使用自然语言描述的多任务数据进行微调\",{\"1\":{\"706\":1}}],[\"通过使用自身参数的滑动平均作为教师\",{\"1\":{\"150\":1}}],[\"通过理解上下文并生成相应输出的方式来执行任务\",{\"1\":{\"706\":1}}],[\"通过稀疏计算以经济的成本训练强大的模型\",{\"1\":{\"704\":1}}],[\"通过改进的对齐技术\",{\"1\":{\"704\":1}}],[\"通过backward\",{\"1\":{\"697\":1}}],[\"通过seen\",{\"1\":{\"696\":1}}],[\"通过softmax函数转换后\",{\"1\":{\"300\":1}}],[\"通过homebrew执行\",{\"1\":{\"696\":1}}],[\"通过config类和no\",{\"1\":{\"693\":1}}],[\"通过cmafm模块将几何属性\",{\"1\":{\"6\":1}}],[\"通过列表处理可变长参数\",{\"1\":{\"693\":1}}],[\"通过梯度检验可知结果正确\",{\"1\":{\"692\":1}}],[\"通过运算符重载\",{\"1\":{\"692\":1}}],[\"通过对每个\",{\"1\":{\"758\":1}}],[\"通过对复杂测试函数求导\",{\"1\":{\"692\":1}}],[\"通过对比学习在大规模图文对中对齐表示\",{\"1\":{\"150\":1}}],[\"通过对比学习先对齐图像和文本的表示\",{\"1\":{\"149\":1}}],[\"通过步骤20\",{\"1\":{\"690\":1}}],[\"通过组合加法和乘法运算符\",{\"1\":{\"690\":1}}],[\"通过组合不同组件\",{\"1\":{\"196\":1}}],[\"通过retain\",{\"1\":{\"688\":1}}],[\"通过roi\",{\"1\":{\"54\":1}}],[\"通过output\",{\"1\":{\"687\":1}}],[\"通过弱引用主动打破function与variable之间的循环引用\",{\"1\":{\"687\":1}}],[\"通过以上修改\",{\"1\":{\"686\":1}}],[\"通过以下改进缩小差距\",{\"1\":{\"216\":1}}],[\"通过以下两个核心组件实现跨模态深度协同\",{\"1\":{\"196\":1}}],[\"通过以下关键设计解决上述问题\",{\"1\":{\"189\":1}}],[\"通过循环替代递归\",{\"1\":{\"668\":1}}],[\"通过递归或循环遍历计算图\",{\"1\":{\"665\":1}}],[\"通过计算图可以直观地表示变量与函数的关系\",{\"1\":{\"641\":1}}],[\"通过计算损失\",{\"1\":{\"319\":1}}],[\"通过填充掩码\",{\"1\":{\"622\":1}}],[\"通过调用\",{\"1\":{\"614\":1}}],[\"通过调整训练策略\",{\"1\":{\"563\":1}}],[\"通过调整这些关键因素\",{\"1\":{\"560\":1}}],[\"通过调整\",{\"1\":{\"473\":1}}],[\"通过调整步长\",{\"1\":{\"425\":1}}],[\"通过桶映射\",{\"1\":{\"591\":1}}],[\"通过全连接层\",{\"1\":{\"580\":1}}],[\"通过全连接层进行分类\",{\"1\":{\"93\":1}}],[\"通过系统优化bert的预训练策略\",{\"1\":{\"569\":1}}],[\"通过系统性的实验发现bert存在训练不足的问题\",{\"1\":{\"558\":1}}],[\"通过复制数据来增加多样性\",{\"1\":{\"562\":1}}],[\"通过复合实现指数级增长的分段线性区域\",{\"1\":{\"385\":1}}],[\"通过控制数据规模\",{\"1\":{\"561\":1}}],[\"通过优化训练策略\",{\"1\":{\"559\":1}}],[\"通过数据与训练优化达到大模型\",{\"1\":{\"549\":1}}],[\"通过xformers库实现因果多头注意力的高效计算\",{\"1\":{\"548\":1}}],[\"通过触发短语过滤预训练语料\",{\"1\":{\"536\":1}}],[\"通过人类反馈进行强化学习\",{\"1\":{\"535\":1}}],[\"通过人为构造\",{\"1\":{\"248\":1}}],[\"通过微调在多个任务上实现了sota\",{\"1\":{\"531\":1}}],[\"通过大语言模型的强大理解能力和生成能力\",{\"1\":{\"716\":1}}],[\"通过大规模预训练和精心设计的上下文输入\",{\"1\":{\"528\":1}}],[\"通过大规模训练显著提升了少样本学习能力\",{\"1\":{\"526\":1}}],[\"通过大量文本数据训练这些模型\",{\"1\":{\"703\":1}}],[\"通过大量\",{\"1\":{\"239\":1}}],[\"通过添加停用词过滤器\",{\"1\":{\"522\":1}}],[\"通过可逆去token化\",{\"1\":{\"522\":1}}],[\"通过引导llm解决子问题\",{\"1\":{\"503\":1}}],[\"通过引入两个可调节参数来增强模型对假阳性\",{\"1\":{\"471\":1}}],[\"通过引入动量蒸馏\",{\"1\":{\"157\":1}}],[\"通过把一个个的简单问题解决掉\",{\"1\":{\"503\":1}}],[\"通过解决这一系列的简单问题\",{\"1\":{\"503\":1}}],[\"通过增加旁路\",{\"1\":{\"495\":1}}],[\"通过简单有效的方案来达成轻量微调的目的\",{\"1\":{\"495\":1}}],[\"通过降低参数的精度\",{\"1\":{\"488\":1}}],[\"通过强化学习的方式\",{\"1\":{\"483\":1}}],[\"通过协方差矩阵找出\",{\"1\":{\"455\":1}}],[\"通过插值获得值后聚合\",{\"1\":{\"387\":1}}],[\"通过分析前面的词汇来预测下一个词汇\",{\"1\":{\"703\":1}}],[\"通过分层降维\",{\"1\":{\"385\":1}}],[\"通过分层组合简单函数\",{\"1\":{\"385\":1}}],[\"通过分类头\",{\"1\":{\"319\":1,\"320\":1,\"323\":1}}],[\"通过逐层抽象\",{\"1\":{\"385\":1}}],[\"通过encoder\",{\"1\":{\"323\":1}}],[\"通过投影层对合并后的张量进行线性变换\",{\"1\":{\"322\":1}}],[\"通过qkv线性层将输入x映射到dim\",{\"1\":{\"322\":1}}],[\"通过qllama实现动态特征交互\",{\"1\":{\"196\":1}}],[\"通过第一阶段的10个步骤\",{\"1\":{\"678\":1}}],[\"通过第一个全连接层\",{\"1\":{\"321\":1}}],[\"通过第二个全连接层\",{\"1\":{\"321\":1}}],[\"通过激活函数层\",{\"1\":{\"321\":1}}],[\"通过随机裁剪可以增加训练数据的多样性\",{\"1\":{\"317\":1}}],[\"通过随机丢弃来模拟不同密度的采样\",{\"1\":{\"96\":1}}],[\"通过视觉编码器\",{\"1\":{\"313\":1}}],[\"通过视觉编码器提取图像的视觉特征\",{\"1\":{\"143\":1}}],[\"通过学习image\",{\"1\":{\"311\":1}}],[\"通过模型获取图片的特征嵌入\",{\"1\":{\"302\":1}}],[\"通过模态专家捕获模态特定信息\",{\"1\":{\"260\":1}}],[\"通过linear\",{\"1\":{\"284\":1}}],[\"通过word\",{\"1\":{\"284\":1}}],[\"通过点积获得相似度\",{\"1\":{\"267\":1}}],[\"通过线性投影和归一化得到\",{\"1\":{\"265\":1}}],[\"通过线性层转为\",{\"1\":{\"179\":1}}],[\"通过跨模态注意力建模图像和文本的交互\",{\"1\":{\"261\":1}}],[\"通过跨模态注意力融合图像和文本表示\",{\"1\":{\"260\":1}}],[\"通过跨模态相似性\",{\"1\":{\"56\":1}}],[\"通过这一技巧\",{\"1\":{\"881\":1}}],[\"通过这些区间的并\",{\"1\":{\"728\":1}}],[\"通过这\",{\"1\":{\"680\":1,\"695\":1}}],[\"通过这种方式\",{\"1\":{\"246\":1,\"300\":1}}],[\"通过这个阶段训练后\",{\"1\":{\"234\":1}}],[\"通过结合在线聚类分配过程与直通估计器可以解决这一问题\",{\"1\":{\"808\":1}}],[\"通过结合人工标注数据和强化学习\",{\"1\":{\"232\":1}}],[\"通过结合描述交互的图像或语言与3d几何结构引入外部先验\",{\"1\":{\"6\":1}}],[\"通过机器生成的指令数据进行调优\",{\"1\":{\"232\":1}}],[\"通过持续优化的视觉编码器internvit\",{\"1\":{\"230\":1}}],[\"通过持续学习优化\",{\"1\":{\"222\":1}}],[\"通过持续学习策略增强视觉理解能力\",{\"1\":{\"220\":1}}],[\"通过持续学习策略优化大规模视觉基础模型\",{\"1\":{\"215\":1}}],[\"通过翻译管道\",{\"1\":{\"225\":1}}],[\"通过中英文问答对标注\",{\"1\":{\"216\":1}}],[\"通过将潜变量的分布从\",{\"1\":{\"873\":1}}],[\"通过将核心组件\",{\"1\":{\"714\":1}}],[\"通过将键值\",{\"1\":{\"704\":1}}],[\"通过将查询\",{\"1\":{\"704\":2}}],[\"通过将图像切成小片\",{\"1\":{\"328\":1}}],[\"通过将特征映射到特定的维度并进行非线性变换\",{\"1\":{\"323\":1}}],[\"通过将视觉基础模型扩展到\",{\"1\":{\"206\":1}}],[\"通过将局部区域中的每个点\",{\"1\":{\"91\":1}}],[\"通过注意力池化生成全局特征\",{\"1\":{\"197\":1}}],[\"通过超参数搜索\",{\"1\":{\"197\":1}}],[\"通过超参数搜索优化了深度\",{\"1\":{\"196\":1}}],[\"通过超大维度的\",{\"1\":{\"186\":1}}],[\"通过扩大模型规模和参数量\",{\"1\":{\"191\":1}}],[\"通过比较图像特征而不是分类\",{\"1\":{\"175\":1}}],[\"通过恢复被掩码的图像块\",{\"1\":{\"165\":1}}],[\"通过pointnet获取每个形心多尺度信息\",{\"1\":{\"96\":1}}],[\"通过较低温度参数\",{\"1\":{\"178\":1}}],[\"通过较大的邻域尺度避免过度稀疏的问题\",{\"1\":{\"95\":1}}],[\"通过较小的邻域尺度捕获细节\",{\"1\":{\"95\":1}}],[\"通过多任务微调训练语言模型\",{\"1\":{\"536\":1}}],[\"通过多个局部区域球查询提取不同尺度的局部特征\",{\"1\":{\"96\":1}}],[\"通过多层\",{\"1\":{\"93\":1,\"319\":1}}],[\"通过多头可供性链式思维\",{\"1\":{\"26\":1}}],[\"通过查找形心点周围的\",{\"1\":{\"88\":1}}],[\"通过局部特征学习器\",{\"1\":{\"86\":1}}],[\"通过\",{\"1\":{\"76\":2,\"105\":1,\"107\":1,\"122\":1,\"129\":1,\"167\":1,\"175\":1,\"198\":1,\"225\":1,\"262\":1,\"274\":2,\"312\":2,\"470\":1,\"522\":1,\"537\":1,\"538\":1,\"716\":3,\"796\":1,\"809\":1,\"821\":1,\"885\":1}}],[\"通过共享mlp迫使图像和点云特征在相同空间分布\",{\"1\":{\"59\":1}}],[\"通过瓶颈结构\",{\"1\":{\"59\":1}}],[\"通过mlp\",{\"1\":{\"59\":1}}],[\"通过双路交叉注意力分别建模物体\",{\"1\":{\"56\":1}}],[\"通过特征传播层上采样\",{\"1\":{\"54\":1}}],[\"通过智能体主动交互学习\",{\"1\":{\"51\":1}}],[\"通过智能体在虚拟环境中主动交互学习功能\",{\"1\":{\"49\":1}}],[\"通过密集跨模态相似性\",{\"1\":{\"49\":1}}],[\"通过标注物体交互区域建立几何结构与功能的固定关联\",{\"1\":{\"49\":1}}],[\"通过联合区域对齐模块\",{\"1\":{\"48\":1}}],[\"通过2d图像中的交互信息来预测3d物体的功能区域\",{\"1\":{\"48\":1}}],[\"通过适配器层将\",{\"1\":{\"40\":1}}],[\"通过建立意图与几何的显式关联\",{\"1\":{\"32\":1}}],[\"通过为每张图像配对多个点云\",{\"1\":{\"29\":1}}],[\"通过交叉注意力建模物体\",{\"1\":{\"49\":1}}],[\"通过交叉注意力层\",{\"1\":{\"13\":1}}],[\"通过交叉注意力机制计算对象几何特征\",{\"1\":{\"8\":1}}],[\"通过文本条件查询分割功能区域\",{\"1\":{\"7\":1}}],[\"泛化更好\",{\"1\":{\"591\":1}}],[\"泛化强\",{\"1\":{\"539\":1}}],[\"泛化机制的模糊性\",{\"1\":{\"530\":1}}],[\"泛化差\",{\"1\":{\"149\":1}}],[\"泛化能力有限\",{\"1\":{\"527\":1}}],[\"泛化能力\",{\"1\":{\"65\":1}}],[\"泛化\",{\"1\":{\"33\":1}}],[\"泛化性\",{\"1\":{\"538\":1}}],[\"泛化性就不足\",{\"1\":{\"246\":1}}],[\"泛化性不如\",{\"1\":{\"239\":1}}],[\"泛化性不足\",{\"1\":{\"7\":1}}],[\"泛化性差\",{\"1\":{\"51\":1}}],[\"泛化性下降明显\",{\"1\":{\"24\":1}}],[\"第四阶段共\",{\"1\":{\"700\":1}}],[\"第四阶段\",{\"1\":{\"699\":1}}],[\"第四范式\",{\"1\":{\"488\":1}}],[\"第3维\",{\"1\":{\"423\":1}}],[\"第3行\",{\"1\":{\"145\":2}}],[\"第2维\",{\"1\":{\"423\":1}}],[\"第2行\",{\"1\":{\"145\":2}}],[\"第1列到第3列\",{\"1\":{\"425\":1}}],[\"第1维\",{\"1\":{\"423\":1}}],[\"第1行\",{\"1\":{\"145\":2}}],[\"第0维\",{\"1\":{\"423\":1}}],[\"第\",{\"1\":{\"277\":1,\"364\":2,\"399\":1,\"590\":4,\"843\":1}}],[\"第三方代码实现\",{\"1\":{\"805\":1,\"812\":1}}],[\"第三个实验有\",{\"1\":{\"761\":1}}],[\"第三个学习目标是\",{\"1\":{\"278\":1}}],[\"第三维\",{\"1\":{\"590\":1}}],[\"第三张是狗\",{\"1\":{\"242\":1}}],[\"第三张图片不是同一个类别的信息\",{\"1\":{\"242\":1}}],[\"第三张图片不是一个类别\",{\"1\":{\"242\":1}}],[\"第三张图片和它们的距离比较远\",{\"1\":{\"242\":1}}],[\"第三张图片是狗\",{\"1\":{\"242\":1}}],[\"第三阶段\",{\"1\":{\"199\":1,\"694\":1}}],[\"第三步\",{\"1\":{\"98\":1}}],[\"第500个样本\",{\"1\":{\"83\":1}}],[\"第二张图的插值方式\",{\"1\":{\"802\":1}}],[\"第二张图的目标尺寸\",{\"1\":{\"802\":1}}],[\"第二张图片是人悲伤\",{\"1\":{\"242\":1}}],[\"第二项\",{\"1\":{\"807\":1,\"854\":1}}],[\"第二项即为我们的\",{\"1\":{\"773\":1}}],[\"第二项的解释\",{\"1\":{\"590\":1}}],[\"第二维\",{\"1\":{\"590\":1}}],[\"第二部分是一个移动平均的编码器\",{\"1\":{\"245\":1}}],[\"第二步是利用\",{\"1\":{\"872\":1}}],[\"第二步\",{\"1\":{\"98\":1}}],[\"第二个误差叫做专注误差\",{\"1\":{\"882\":1}}],[\"第二个实验有\",{\"1\":{\"761\":1}}],[\"第二个维度的偏差乘上\",{\"1\":{\"459\":1}}],[\"第二个维度方差是\",{\"1\":{\"459\":1}}],[\"第二个维度\",{\"1\":{\"423\":2}}],[\"第二个全连接层\",{\"1\":{\"321\":1}}],[\"第二个归一化层\",{\"1\":{\"321\":1}}],[\"第二个线性层再把高维特征映射回原来的维度\",{\"1\":{\"321\":1}}],[\"第二个参数\",{\"1\":{\"317\":1}}],[\"第二个学习目标是\",{\"1\":{\"277\":1}}],[\"第二个分支的编码器就更新得太快了\",{\"1\":{\"249\":1}}],[\"第二个分支不能随着走这一支的样本使用梯度回传进行更新\",{\"1\":{\"249\":1}}],[\"第二个是在训练的时候尽量保持一致性\",{\"1\":{\"246\":1}}],[\"第二个\",{\"1\":{\"45\":1,\"159\":1}}],[\"第二分支\",{\"1\":{\"45\":1}}],[\"第二阶段总结\",{\"0\":{\"693\":1}}],[\"第二阶段将从第11步延续\",{\"1\":{\"680\":1}}],[\"第二阶段的\",{\"1\":{\"272\":1}}],[\"第二阶段\",{\"1\":{\"33\":1,\"199\":1,\"277\":1,\"679\":1,\"773\":1}}],[\"第一层\",{\"1\":{\"848\":1}}],[\"第一层是一个叫做\",{\"1\":{\"107\":1}}],[\"第一项\",{\"1\":{\"807\":1,\"854\":1}}],[\"第一张图的插值方式\",{\"1\":{\"802\":1}}],[\"第一张图的目标尺寸\",{\"1\":{\"802\":1}}],[\"第一张图是人高兴\",{\"1\":{\"242\":1}}],[\"第一维\",{\"1\":{\"590\":1}}],[\"第一次输入完整句子\",{\"1\":{\"544\":1}}],[\"第一部分是一个队列\",{\"1\":{\"245\":1}}],[\"第一步是构建潜变量\",{\"1\":{\"872\":1}}],[\"第一步需要完成图像的切片和嵌入\",{\"1\":{\"272\":1}}],[\"第一步首先是对\",{\"1\":{\"186\":1}}],[\"第一步\",{\"1\":{\"98\":1}}],[\"第一个误差来自字典学习算法里的经典算法\",{\"1\":{\"882\":1}}],[\"第一个问题是\",{\"1\":{\"878\":1}}],[\"第一个卷积层用a类掩码\",{\"1\":{\"847\":1}}],[\"第一个实验有\",{\"1\":{\"761\":1}}],[\"第一个关键点\",{\"1\":{\"499\":1}}],[\"第一个维度方差是\",{\"1\":{\"459\":1}}],[\"第一个维度\",{\"1\":{\"423\":2}}],[\"第一个全连接层\",{\"1\":{\"321\":1}}],[\"第一个归一化层\",{\"1\":{\"321\":1}}],[\"第一个线性层将输入特征映射到更高维度的空间\",{\"1\":{\"321\":1}}],[\"第一个参数\",{\"1\":{\"317\":1}}],[\"第一个基于patch\",{\"1\":{\"280\":1}}],[\"第一个学习目标是\",{\"1\":{\"276\":1}}],[\"第一个是字典足够大\",{\"1\":{\"246\":1}}],[\"第一个向量提供了更细致的信息\",{\"1\":{\"97\":1}}],[\"第一个点\",{\"1\":{\"92\":1}}],[\"第一个\",{\"1\":{\"45\":1,\"159\":1,\"272\":1,\"463\":1}}],[\"第一分支\",{\"1\":{\"45\":1}}],[\"第一阶段只训练一个\",{\"1\":{\"773\":1}}],[\"第一阶段通过最小化重建损失\",{\"1\":{\"773\":1}}],[\"第一阶段中\",{\"1\":{\"680\":1}}],[\"第一阶段总结\",{\"0\":{\"678\":1}}],[\"第一阶段共包含10个步骤\",{\"1\":{\"634\":1}}],[\"第一阶段设计了三个训练目标\",{\"1\":{\"309\":1}}],[\"第一阶段\",{\"1\":{\"33\":1,\"199\":1,\"277\":1,\"633\":1,\"773\":1}}],[\"信息仍是连续的\",{\"1\":{\"885\":1}}],[\"信息增益\",{\"1\":{\"872\":1}}],[\"信息单位是\",{\"1\":{\"828\":2}}],[\"信息量越大\",{\"1\":{\"828\":1}}],[\"信息量\",{\"0\":{\"827\":1},\"1\":{\"828\":2,\"831\":1}}],[\"信息论视角\",{\"0\":{\"872\":1}}],[\"信息论最核心的问题是\",{\"1\":{\"828\":1}}],[\"信息论\",{\"0\":{\"827\":1}}],[\"信息瓶颈\",{\"1\":{\"800\":1}}],[\"信息更新成本低\",{\"1\":{\"711\":1}}],[\"信息偏差\",{\"1\":{\"709\":1}}],[\"信息检索等场景\",{\"1\":{\"391\":1}}],[\"信息丢失\",{\"1\":{\"386\":1}}],[\"信息\",{\"1\":{\"33\":1,\"186\":1}}],[\"把生成大图像的问题转换成了一个更简单的生成\",{\"1\":{\"883\":1}}],[\"把嵌入的更新和编码器的更新分开计算\",{\"1\":{\"883\":1}}],[\"把上面那个误差函数拆成了两部分\",{\"1\":{\"882\":1}}],[\"把图片编码成离散向量会更加自然\",{\"1\":{\"878\":1}}],[\"把图像变成一个短得多的向量\",{\"1\":{\"878\":1}}],[\"把图像编码成离散向量后\",{\"1\":{\"878\":1}}],[\"把图像\",{\"1\":{\"807\":1}}],[\"把这个\",{\"1\":{\"869\":1,\"873\":1}}],[\"把这些数字映射成它们发生的概率\",{\"1\":{\"727\":1}}],[\"把这些\",{\"1\":{\"616\":1}}],[\"把这些方向\",{\"1\":{\"459\":1}}],[\"把这些点的坐标归一化到以质心为中心的局部坐标系下\",{\"1\":{\"96\":1}}],[\"把第一个像素填入空图像\",{\"1\":{\"847\":1}}],[\"把世界事件映射成数字\",{\"1\":{\"727\":1}}],[\"把layernorm放到了前面\",{\"1\":{\"626\":1}}],[\"把llm的慢思考调动起来\",{\"1\":{\"500\":1}}],[\"把位置向量加到\",{\"1\":{\"591\":1}}],[\"把位置信息向量投影到和\",{\"1\":{\"590\":1}}],[\"把相对距离压缩到固定数量的桶里\",{\"1\":{\"591\":1}}],[\"把相似度矩阵对角线元素置为负无穷大\",{\"1\":{\"311\":1}}],[\"把新\",{\"1\":{\"544\":1}}],[\"把复杂问题分解成一系列的简单子问题\",{\"1\":{\"503\":1}}],[\"把要求尽可能明确\",{\"1\":{\"499\":1}}],[\"把人类的反馈\",{\"1\":{\"483\":1}}],[\"把数据的不同尺度和相关性都考虑进来\",{\"1\":{\"458\":1}}],[\"把数据转换成llm能识别的格式\",{\"1\":{\"308\":1}}],[\"把向量中每个元素除以向量的欧几里得长度\",{\"1\":{\"393\":1}}],[\"把向量中每个元素除以向量元素的绝对值之和\",{\"1\":{\"392\":1}}],[\"把一个\",{\"1\":{\"371\":1}}],[\"把12拆分成3和4\",{\"1\":{\"370\":1}}],[\"把c和d合并成一个维度\",{\"1\":{\"370\":1}}],[\"把原函数的\",{\"1\":{\"346\":1}}],[\"把原始点云\",{\"1\":{\"92\":1}}],[\"把query\",{\"1\":{\"311\":1}}],[\"把q\",{\"1\":{\"309\":1}}],[\"把当前\",{\"1\":{\"246\":1}}],[\"把f12\",{\"1\":{\"246\":1}}],[\"把对比学习看成了是一个字典查询的过程\",{\"1\":{\"245\":1}}],[\"把自监督学习解释为\",{\"1\":{\"175\":1}}],[\"把每个\",{\"1\":{\"821\":1}}],[\"把每个簇的样本数存下来\",{\"1\":{\"170\":1}}],[\"把每次训练的\",{\"1\":{\"246\":1}}],[\"把每张图像当作一个独立类别\",{\"1\":{\"175\":1}}],[\"把属于同一簇的样本向量加到对应的中心上\",{\"1\":{\"170\":1}}],[\"把空簇的计数临时设为\",{\"1\":{\"170\":1}}],[\"把全局特征复制\",{\"1\":{\"109\":1}}],[\"把它们\",{\"1\":{\"107\":1}}],[\"把它们相对于关键点的位置进行归一化\",{\"1\":{\"92\":1}}],[\"把不同尺度学到的特征拼接在一起\",{\"1\":{\"96\":1}}],[\"把邻域点的数据整理成适合卷积的格式\",{\"1\":{\"92\":1}}],[\"把邻近点的坐标和特征拼接在一起\",{\"1\":{\"92\":1}}],[\"把距离超过\",{\"1\":{\"92\":1}}],[\"把刚才找到的邻近点的坐标提取出来\",{\"1\":{\"92\":1}}],[\"把他的大小归一化到一个球中\",{\"1\":{\"86\":1}}],[\"把\",{\"1\":{\"33\":1,\"170\":2,\"248\":1,\"349\":1,\"591\":1,\"796\":1,\"880\":2}}],[\"把手\",{\"1\":{\"32\":1}}],[\"➜\",{\"1\":{\"33\":2}}],[\"qy\",{\"1\":{\"794\":4,\"798\":4,\"821\":2}}],[\"qwq\",{\"1\":{\"704\":2,\"718\":2}}],[\"qwen3\",{\"1\":{\"704\":2}}],[\"qwen2\",{\"1\":{\"704\":3}}],[\"qwen\",{\"1\":{\"193\":1,\"202\":1,\"218\":1,\"219\":1,\"704\":4}}],[\"qnli\",{\"1\":{\"566\":1}}],[\"qqp\",{\"1\":{\"515\":1}}],[\"q进行\",{\"1\":{\"495\":1}}],[\"qlora就是量化版的lora\",{\"1\":{\"488\":1}}],[\"qlora\",{\"0\":{\"488\":1},\"1\":{\"488\":1,\"495\":2}}],[\"qllama利用其大规模参数重组视觉表示并生成文本\",{\"1\":{\"197\":1}}],[\"qllama的优势包括\",{\"1\":{\"197\":1}}],[\"qllama是一个80亿参数的语言中间件\",{\"1\":{\"197\":1}}],[\"qllama\",{\"1\":{\"189\":1,\"196\":1,\"197\":1,\"198\":4,\"199\":5,\"202\":1,\"203\":1,\"204\":4,\"205\":1,\"206\":1,\"209\":1,\"210\":2}}],[\"q12\",{\"1\":{\"390\":1}}],[\"q11\",{\"1\":{\"390\":1}}],[\"q22\",{\"1\":{\"390\":1}}],[\"q21\",{\"1\":{\"390\":1}}],[\"q2t\",{\"1\":{\"310\":2}}],[\"q来自query\",{\"1\":{\"312\":1}}],[\"qk^t\",{\"1\":{\"272\":1,\"418\":1}}],[\"qk\",{\"1\":{\"272\":10,\"320\":1,\"321\":2,\"322\":2,\"323\":2}}],[\"qkv\",{\"1\":{\"160\":2,\"272\":18,\"320\":1,\"321\":2,\"322\":8,\"323\":2,\"463\":5,\"492\":1}}],[\"q=images\",{\"1\":{\"252\":1}}],[\"q=6\",{\"1\":{\"145\":1}}],[\"qa\",{\"1\":{\"235\":1,\"239\":1,\"537\":1,\"549\":1,\"614\":2,\"615\":2,\"616\":1}}],[\"quantisation\",{\"1\":{\"882\":1}}],[\"quantization\",{\"1\":{\"170\":1,\"387\":1,\"488\":1,\"787\":1,\"821\":1}}],[\"quantizer\",{\"1\":{\"170\":1}}],[\"quantized\",{\"1\":{\"164\":2,\"488\":1,\"495\":1,\"885\":12,\"886\":2}}],[\"quac\",{\"1\":{\"529\":2}}],[\"quora\",{\"1\":{\"515\":2}}],[\"queies\",{\"1\":{\"312\":1}}],[\"queue\",{\"1\":{\"145\":20,\"147\":16,\"160\":13,\"161\":3,\"254\":6,\"255\":1,\"257\":5,\"366\":1,\"367\":1}}],[\"queries被用来从image\",{\"1\":{\"309\":1}}],[\"queries是一组可学习的embeddings\",{\"1\":{\"309\":1}}],[\"queries\",{\"1\":{\"70\":1,\"76\":3,\"199\":1,\"255\":1,\"309\":3,\"310\":1,\"311\":1,\"313\":3}}],[\"query的数量\",{\"1\":{\"405\":1}}],[\"query的响应图进行平均池化\",{\"1\":{\"76\":1}}],[\"query和query\",{\"1\":{\"310\":1}}],[\"query是基于欧氏距离的均匀性假设\",{\"1\":{\"90\":1}}],[\"query通过确保每个局部区域都有一个固定的尺度\",{\"1\":{\"90\":1}}],[\"query通过固定区域尺度而不是固定邻居数量来定义邻域\",{\"1\":{\"90\":1}}],[\"query找到该查询点在半径为𝑟范围内点\",{\"1\":{\"90\":1}}],[\"query来查询形心的邻居点\",{\"1\":{\"90\":1}}],[\"query=self\",{\"1\":{\"76\":1}}],[\"query=x\",{\"1\":{\"75\":1}}],[\"query=q\",{\"1\":{\"75\":1}}],[\"query\",{\"1\":{\"14\":1,\"45\":13,\"70\":1,\"72\":8,\"74\":8,\"76\":10,\"92\":7,\"96\":2,\"98\":1,\"145\":1,\"162\":6,\"199\":1,\"246\":1,\"248\":1,\"250\":1,\"252\":2,\"255\":3,\"291\":1,\"293\":6,\"294\":1,\"303\":4,\"304\":4,\"309\":8,\"310\":2,\"311\":17,\"312\":30,\"313\":5,\"367\":2,\"404\":1,\"405\":1,\"407\":1,\"409\":1,\"410\":2,\"412\":2,\"414\":1,\"544\":7,\"591\":15,\"605\":7,\"632\":9,\"704\":4,\"781\":2}}],[\"questions这三个问答任务中\",{\"1\":{\"529\":1}}],[\"questions\",{\"1\":{\"522\":1,\"539\":1}}],[\"question数据可视化图\",{\"1\":{\"68\":1}}],[\"question数据可视化\",{\"1\":{\"63\":1}}],[\"question\",{\"0\":{\"63\":1},\"1\":{\"68\":6,\"76\":1,\"81\":2,\"82\":2,\"274\":1,\"275\":1,\"515\":1,\"521\":1,\"614\":1,\"758\":1}}],[\"question4\",{\"1\":{\"28\":2}}],[\"question3\",{\"1\":{\"28\":2}}],[\"question2\",{\"1\":{\"28\":2}}],[\"question1\",{\"1\":{\"28\":2}}],[\"qid\",{\"1\":{\"68\":5}}],[\"qformer\",{\"1\":{\"40\":1,\"204\":1,\"309\":2,\"311\":1,\"312\":3,\"313\":1}}],[\"q\",{\"0\":{\"406\":1},\"1\":{\"32\":8,\"40\":1,\"45\":9,\"70\":1,\"72\":6,\"74\":3,\"75\":5,\"76\":2,\"145\":11,\"147\":2,\"170\":8,\"186\":2,\"252\":2,\"254\":4,\"255\":9,\"256\":3,\"272\":17,\"309\":3,\"312\":2,\"313\":3,\"322\":5,\"367\":2,\"404\":1,\"410\":1,\"419\":2,\"463\":2,\"542\":1,\"544\":4,\"584\":3,\"590\":17,\"591\":5,\"632\":1,\"794\":1,\"798\":2,\"799\":3,\"821\":1,\"830\":1,\"831\":4,\"837\":1,\"854\":1,\"857\":1,\"881\":1,\"885\":2}}],[\"交替训练判别器和生成器\",{\"1\":{\"840\":1}}],[\"交替作用\",{\"1\":{\"73\":1}}],[\"交和补运算\",{\"1\":{\"728\":1}}],[\"交换操作数实现a\",{\"1\":{\"690\":2}}],[\"交换维度顺序\",{\"1\":{\"370\":1}}],[\"交并比\",{\"1\":{\"469\":2}}],[\"交错堆叠\",{\"1\":{\"326\":1}}],[\"交集\",{\"1\":{\"82\":1,\"467\":1,\"728\":1}}],[\"交叉熵定义为\",{\"1\":{\"832\":1}}],[\"交叉熵可以看作是平均信息量\",{\"1\":{\"831\":1}}],[\"交叉熵会大于熵\",{\"1\":{\"830\":1}}],[\"交叉熵衡量用分布\",{\"1\":{\"830\":1}}],[\"交叉熵\",{\"0\":{\"827\":1},\"1\":{\"830\":1,\"831\":1}}],[\"交叉熵在总损失中的占比越高\",{\"1\":{\"473\":1}}],[\"交叉熵是一个多分类问题的损失函数\",{\"1\":{\"248\":1}}],[\"交叉熵损失是一种衡量两个概率分布差异的指标\",{\"1\":{\"832\":1}}],[\"交叉熵损失为\",{\"1\":{\"470\":1}}],[\"交叉熵损失函数\",{\"1\":{\"248\":1}}],[\"交叉熵损失\",{\"0\":{\"832\":1},\"1\":{\"163\":1,\"473\":2}}],[\"交叉熵损失监督\",{\"1\":{\"55\":1}}],[\"交叉注意力运算\",{\"1\":{\"312\":1}}],[\"交叉注意力\",{\"1\":{\"312\":1}}],[\"交叉注意力则key和value都来自图像\",{\"1\":{\"312\":1}}],[\"交叉注意力建模交互上下文\",{\"1\":{\"54\":1}}],[\"交叉注意力模拟了这种双向推理过程\",{\"1\":{\"32\":1}}],[\"交互式可视化网站\",{\"1\":{\"735\":1}}],[\"交互的应用程序\",{\"1\":{\"715\":1}}],[\"交互层\",{\"1\":{\"713\":1}}],[\"交互浅\",{\"1\":{\"260\":1,\"261\":1}}],[\"交互难度大\",{\"1\":{\"149\":1}}],[\"交互区域特征\",{\"1\":{\"59\":1}}],[\"交互主体区域特征图\",{\"1\":{\"59\":1}}],[\"交互主体区域特征\",{\"1\":{\"59\":2}}],[\"交互主体框\",{\"1\":{\"58\":2}}],[\"交互\",{\"1\":{\"56\":1,\"76\":1}}],[\"交互信息与图像特征的融合\",{\"0\":{\"34\":1}}],[\"交互信息文本\",{\"1\":{\"29\":1}}],[\"交互文本信息与图像信息进行融合\",{\"1\":{\"30\":1}}],[\"交互文本和几何结构文本的信息通过改良的交叉注意力机制进行交互融合\",{\"1\":{\"30\":1}}],[\"交互行为名\",{\"1\":{\"29\":1}}],[\"交互图像\",{\"1\":{\"29\":1}}],[\"交互图像与\",{\"1\":{\"16\":1}}],[\"交互知识\",{\"1\":{\"28\":1}}],[\"交互部位\",{\"1\":{\"28\":1}}],[\"交互类比推理\",{\"1\":{\"12\":1}}],[\"交互细节描述\",{\"1\":{\"12\":1}}],[\"功能增强\",{\"0\":{\"689\":1}}],[\"功能说明\",{\"1\":{\"186\":1}}],[\"功能属性匹配\",{\"1\":{\"68\":1}}],[\"功能类别\",{\"1\":{\"68\":2}}],[\"功能类别预测\",{\"1\":{\"54\":1}}],[\"功能类型索引\",{\"1\":{\"68\":1}}],[\"功能类型\",{\"1\":{\"67\":1}}],[\"功能类型数\",{\"1\":{\"65\":1}}],[\"功能组合的标注数据\",{\"1\":{\"68\":1}}],[\"功能组合\",{\"1\":{\"63\":2,\"67\":1}}],[\"功能分类损失\",{\"1\":{\"55\":1}}],[\"功能揭示\",{\"1\":{\"54\":1}}],[\"功能模糊性\",{\"1\":{\"49\":1}}],[\"功能\",{\"1\":{\"49\":1}}],[\"功能可供性\",{\"1\":{\"49\":1}}],[\"功能意图\",{\"1\":{\"32\":1}}],[\"功能区域\",{\"1\":{\"83\":1,\"470\":2}}],[\"功能区域预测结果\",{\"1\":{\"83\":1}}],[\"功能区域识别任务中\",{\"1\":{\"82\":1}}],[\"功能区域分割\",{\"1\":{\"69\":1}}],[\"功能区域掩码\",{\"1\":{\"68\":3}}],[\"功能区域类型\",{\"1\":{\"29\":1}}],[\"功能区域热力图列表\",{\"1\":{\"29\":1}}],[\"功能区域热力图\",{\"1\":{\"29\":2}}],[\"7x7\",{\"1\":{\"845\":1,\"848\":1,\"885\":2}}],[\"700\",{\"1\":{\"714\":1}}],[\"704\",{\"1\":{\"594\":2}}],[\"70b的55\",{\"1\":{\"549\":1}}],[\"70b\",{\"1\":{\"547\":1,\"549\":2,\"704\":4}}],[\"70b和palm\",{\"1\":{\"546\":1}}],[\"79\",{\"1\":{\"549\":1,\"551\":1}}],[\"71\",{\"1\":{\"538\":1}}],[\"73±1\",{\"1\":{\"537\":1}}],[\"7个百分点\",{\"1\":{\"522\":1}}],[\"7×7\",{\"1\":{\"386\":6,\"387\":3}}],[\"75\",{\"1\":{\"332\":1,\"455\":1,\"470\":3,\"774\":1,\"817\":1}}],[\"751\",{\"1\":{\"65\":1,\"67\":1,\"69\":1}}],[\"7py1jdq1wp0nnyt3a\",{\"1\":{\"316\":1}}],[\"77\",{\"1\":{\"235\":1,\"550\":1,\"564\":1}}],[\"774\",{\"1\":{\"234\":1}}],[\"7b的0\",{\"1\":{\"549\":1,\"551\":1}}],[\"7b在1t\",{\"1\":{\"547\":1}}],[\"7b\",{\"1\":{\"198\":1,\"199\":3,\"208\":2,\"237\":1,\"704\":4}}],[\"7b初始化\",{\"1\":{\"197\":1}}],[\"7b初始化的80亿参数语言中间件\",{\"1\":{\"196\":1}}],[\"74\",{\"1\":{\"184\":1}}],[\"72b\",{\"1\":{\"704\":1}}],[\"72\",{\"1\":{\"184\":1,\"549\":1,\"566\":1}}],[\"76gb\",{\"1\":{\"559\":1,\"561\":1}}],[\"762m和1\",{\"1\":{\"522\":1}}],[\"76\",{\"1\":{\"173\":1,\"184\":1}}],[\"768\",{\"1\":{\"35\":2,\"46\":2,\"59\":2,\"70\":1,\"160\":4,\"318\":4,\"319\":6,\"320\":4,\"321\":1,\"323\":4,\"514\":1,\"593\":3,\"599\":2,\"774\":1}}],[\"784\",{\"1\":{\"856\":1,\"857\":1,\"860\":1}}],[\"78\",{\"1\":{\"173\":1,\"564\":2}}],[\"7章\",{\"1\":{\"134\":1}}],[\"7\",{\"0\":{\"68\":1,\"323\":1},\"1\":{\"30\":2,\"40\":1,\"58\":1,\"59\":5,\"75\":1,\"82\":1,\"105\":1,\"145\":4,\"161\":1,\"163\":1,\"186\":1,\"199\":1,\"245\":1,\"255\":1,\"276\":2,\"277\":2,\"313\":1,\"333\":3,\"354\":2,\"373\":1,\"374\":3,\"376\":1,\"386\":2,\"398\":1,\"421\":2,\"422\":2,\"423\":1,\"425\":2,\"471\":2,\"476\":1,\"506\":1,\"521\":1,\"522\":4,\"529\":3,\"530\":1,\"536\":1,\"537\":1,\"538\":1,\"541\":1,\"544\":1,\"549\":4,\"551\":1,\"564\":2,\"565\":1,\"566\":1,\"591\":3,\"690\":1,\"704\":6,\"728\":1,\"814\":1,\"815\":3,\"848\":6,\"878\":1,\"886\":10}}],[\"用训练好的\",{\"1\":{\"886\":1}}],[\"用训练好的模型权重\",{\"1\":{\"83\":1}}],[\"用概率分布形式表达即为最大化\",{\"1\":{\"865\":1}}],[\"用梯度下降更新生成器参数\",{\"1\":{\"840\":1}}],[\"用梯度下降更新判别器参数\",{\"1\":{\"840\":1}}],[\"用变分后验\",{\"1\":{\"807\":1}}],[\"用作\",{\"1\":{\"769\":1}}],[\"用到多少\",{\"1\":{\"725\":1,\"757\":1}}],[\"用其来表示函数\",{\"1\":{\"686\":1}}],[\"用方框表示函数\",{\"1\":{\"641\":1}}],[\"用每个\",{\"1\":{\"591\":1}}],[\"用爱因斯坦求和公式计算位置分数\",{\"1\":{\"590\":1}}],[\"用随机词替换\",{\"1\":{\"579\":1}}],[\"用随机高斯分布初始化\",{\"1\":{\"492\":1,\"493\":1}}],[\"用mask掩码替换\",{\"1\":{\"579\":1}}],[\"用两句话总结\",{\"1\":{\"539\":1}}],[\"用两个可能的替换说法来代替定义的代词\",{\"1\":{\"516\":1}}],[\"用奖励模型得分选择最佳模型\",{\"1\":{\"537\":1}}],[\"用正则化或投影技术缓解嵌入空间中的偏见\",{\"1\":{\"536\":1}}],[\"用正则匹配并替换匹配上的\",{\"1\":{\"476\":1}}],[\"用人类偏好训练强化学习代理\",{\"1\":{\"536\":1}}],[\"用人工标注的数据\",{\"1\":{\"483\":1}}],[\"用任务未知的生成式预训练模型和判别式微调在自然语言理解上取得了很强的效果\",{\"1\":{\"517\":1}}],[\"用以区分不同的句子\",{\"1\":{\"594\":1}}],[\"用以实现语言模型对人类意图的对齐\",{\"1\":{\"537\":1}}],[\"用以更好地对齐模型行为与用户意图\",{\"1\":{\"534\":1}}],[\"用以训练步数的\",{\"1\":{\"514\":1}}],[\"用以完成特定任务的指令\",{\"1\":{\"497\":1}}],[\"用分隔符分隔\",{\"1\":{\"512\":1}}],[\"用标记的数据对特定任务微调模型\",{\"1\":{\"509\":1}}],[\"用特定的训练数据\",{\"1\":{\"487\":1}}],[\"用特定训练数据去微调可能会把这个领域的表现变好\",{\"1\":{\"483\":1}}],[\"用传统机器学习中监督学习的方法\",{\"1\":{\"483\":1}}],[\"用法\",{\"1\":{\"455\":1}}],[\"用浅层网络逼近需要指数级神经元\",{\"1\":{\"385\":1}}],[\"用深度\",{\"1\":{\"385\":1}}],[\"用一个通用大模型\",{\"1\":{\"716\":1}}],[\"用一个简化版的例子说明上述过程\",{\"1\":{\"318\":1}}],[\"用一组由语言引导的动态卷积核\",{\"1\":{\"76\":1}}],[\"用文本描述去匹配最合适的图片内容\",{\"1\":{\"303\":1}}],[\"用当前图片外层目录的名字作为其分类名词\",{\"1\":{\"302\":1}}],[\"用卷积神经网络\",{\"1\":{\"280\":1}}],[\"用的图像\",{\"1\":{\"277\":1}}],[\"用户愈发期待像钢铁侠中\",{\"1\":{\"708\":1}}],[\"用户可与\",{\"1\":{\"704\":1}}],[\"用户可根据任务需求选择分辨率\",{\"1\":{\"216\":1}}],[\"用户本地运行时\",{\"1\":{\"620\":1}}],[\"用户为申请加入测试队列的群体\",{\"1\":{\"539\":1}}],[\"用户\",{\"1\":{\"539\":2}}],[\"用户行为\",{\"1\":{\"539\":1}}],[\"用户的\",{\"1\":{\"537\":1}}],[\"用户代码\",{\"1\":{\"273\":1}}],[\"用户创建\",{\"1\":{\"273\":1}}],[\"用户提交\",{\"1\":{\"538\":1,\"539\":1}}],[\"用户提交的指令\",{\"1\":{\"536\":1}}],[\"用户提交给\",{\"1\":{\"232\":1}}],[\"用户提问或指令\",{\"1\":{\"235\":1}}],[\"用学生初始化教师网络\",{\"1\":{\"186\":1}}],[\"用它提取并存储下游任务训练集的特征\",{\"1\":{\"179\":1}}],[\"用来自标准正态分布的随机向量和解码器来实现随机图像生成了\",{\"1\":{\"878\":1}}],[\"用来从模型中采样\",{\"1\":{\"873\":1}}],[\"用来计算一个数组或元组\",{\"1\":{\"840\":2}}],[\"用来衡量一个概率分布的不确定性\",{\"1\":{\"829\":1}}],[\"用来模拟采样的随机性\",{\"1\":{\"795\":1}}],[\"用来处理实数范围内的\",{\"1\":{\"728\":1}}],[\"用来填充的数值\",{\"1\":{\"369\":1}}],[\"用来判断条件是否成立\",{\"1\":{\"368\":1}}],[\"用来判断图像文本是否匹配\",{\"1\":{\"285\":1}}],[\"用来存储每个\",{\"1\":{\"170\":1}}],[\"用来做\",{\"1\":{\"169\":1}}],[\"用动量模型生成伪标签\",{\"1\":{\"149\":1}}],[\"用全连接层逐步压缩到\",{\"1\":{\"107\":1}}],[\"用不同\",{\"1\":{\"82\":1}}],[\"用增强后的语言查询去\",{\"1\":{\"76\":1}}],[\"用语言引导点特征分组\",{\"1\":{\"75\":1}}],[\"用\",{\"1\":{\"73\":1,\"137\":1,\"147\":1,\"169\":1,\"212\":1,\"277\":2,\"337\":1,\"355\":1,\"371\":1,\"467\":1,\"492\":2,\"493\":1,\"512\":1,\"590\":1,\"591\":1,\"594\":1,\"716\":1,\"762\":1,\"803\":1,\"804\":1,\"815\":1,\"821\":1,\"843\":1,\"867\":1,\"869\":2,\"885\":1}}],[\"用于控制不同误差之间的比例\",{\"1\":{\"882\":1}}],[\"用于鼓励编码结果稀疏\",{\"1\":{\"873\":1}}],[\"用于模型的第一层\",{\"1\":{\"846\":1}}],[\"用于模块共享的\",{\"1\":{\"814\":2}}],[\"用于缩放余弦相似度\",{\"1\":{\"822\":1}}],[\"用于输入预处理\",{\"1\":{\"821\":1}}],[\"用于输出分割结果\",{\"1\":{\"777\":1}}],[\"用于下一个\",{\"1\":{\"820\":1}}],[\"用于屏蔽非\",{\"1\":{\"818\":1}}],[\"用于屏蔽无效位置\",{\"1\":{\"272\":1}}],[\"用于从模型输出的\",{\"1\":{\"818\":1}}],[\"用于从视觉特征中提取信息\",{\"1\":{\"199\":1}}],[\"用于推理模式\",{\"1\":{\"817\":1}}],[\"用于推理阶段\",{\"1\":{\"815\":1}}],[\"用于增量推理\",{\"1\":{\"815\":1}}],[\"用于替换被遮挡的位置\",{\"1\":{\"804\":1}}],[\"用于混合精度训练的loss\",{\"1\":{\"803\":1}}],[\"用于送入离散\",{\"1\":{\"802\":1}}],[\"用于离散\",{\"1\":{\"802\":1}}],[\"用于反向传播离散\",{\"1\":{\"821\":1}}],[\"用于反向传播\",{\"1\":{\"796\":2}}],[\"用于解码器重建图像\",{\"1\":{\"795\":1}}],[\"用于解决一个新颖的任务\",{\"1\":{\"70\":1}}],[\"用于保持\",{\"1\":{\"793\":1}}],[\"用于保存所有特征\",{\"1\":{\"186\":1}}],[\"用于保存卷积层和批归一化层\",{\"1\":{\"100\":1}}],[\"用于获取视觉令牌\",{\"1\":{\"773\":1}}],[\"用于排除或降低某些不太可能的世界状态\",{\"1\":{\"759\":1}}],[\"用于确保整个密度函数的积分为\",{\"1\":{\"746\":1}}],[\"用于构建\",{\"1\":{\"715\":1}}],[\"用于构造\",{\"1\":{\"147\":1}}],[\"用于复杂的应用的调用序列\",{\"1\":{\"713\":2}}],[\"用于链的多次运行之间持久化应用程序状态\",{\"1\":{\"713\":1}}],[\"用于与人类对话式应用的大胆尝试\",{\"1\":{\"703\":1}}],[\"用于验证基础微分逻辑\",{\"1\":{\"692\":1}}],[\"用于封装功能\",{\"1\":{\"691\":1}}],[\"用于函数的输入接口\",{\"1\":{\"681\":1}}],[\"用于存储导数\",{\"1\":{\"659\":1}}],[\"用于存储训练集和验证集的图像预处理转换操作\",{\"1\":{\"317\":1}}],[\"用于指定在计算损失时忽略的标签索引\",{\"1\":{\"615\":1}}],[\"用于判断给出的两个句子是否连续\",{\"1\":{\"594\":1}}],[\"用于判断图文对是否匹配\",{\"1\":{\"156\":1}}],[\"用于精确表示短距离\",{\"1\":{\"591\":1}}],[\"用于提升表达能力\",{\"1\":{\"821\":1}}],[\"用于提升图文语料的质量\",{\"1\":{\"128\":1}}],[\"用于提取\",{\"1\":{\"580\":1}}],[\"用于我们的预训练任务\",{\"1\":{\"579\":1}}],[\"用于监督微调\",{\"1\":{\"537\":1}}],[\"用于交叉熵部分\",{\"1\":{\"473\":1}}],[\"用于抑制易分类样本\",{\"1\":{\"470\":1}}],[\"用于平衡正负样本数量差异\",{\"1\":{\"470\":1}}],[\"用于平衡训练效率与显存使用\",{\"1\":{\"142\":1}}],[\"用于度量两个集合之间的重叠程度\",{\"1\":{\"469\":1}}],[\"用于语义分割任务中评估模型的分割结果与真实分割标签之间的相似性\",{\"1\":{\"469\":1}}],[\"用于语言引导下的功能区域分割\",{\"1\":{\"78\":1}}],[\"用于类别加权\",{\"1\":{\"468\":1,\"469\":1,\"470\":1}}],[\"用于类别任务\",{\"1\":{\"398\":1}}],[\"用于选择模型和阈值的\",{\"0\":{\"453\":1}}],[\"用于选择难负样本\",{\"1\":{\"162\":1}}],[\"用于匹配查询\",{\"1\":{\"410\":1}}],[\"用于在构建\",{\"1\":{\"403\":1}}],[\"用于根据样本分布计算每个类别的权重\",{\"1\":{\"399\":1}}],[\"用于分布式训练的采样器\",{\"1\":{\"803\":1}}],[\"用于分层采样的标签数组\",{\"1\":{\"398\":1}}],[\"用于分类任务\",{\"1\":{\"262\":1,\"289\":1,\"319\":1}}],[\"用于可重复的随机化\",{\"1\":{\"398\":1}}],[\"用于把一个或多个并行数组按比例切分成训练集和测试集\",{\"1\":{\"398\":1}}],[\"用于按名字实例化模型\",{\"1\":{\"396\":1}}],[\"用于等比例放大或缩小\",{\"1\":{\"388\":1}}],[\"用于加权计数\",{\"1\":{\"377\":1}}],[\"用于统计可迭代对象中各元素出现的次数\",{\"1\":{\"401\":1}}],[\"用于统计\",{\"1\":{\"377\":1}}],[\"用于写入结果\",{\"1\":{\"358\":1}}],[\"用于沿指定轴将多个数组拼接在一起\",{\"1\":{\"333\":1}}],[\"用于同时生成查询\",{\"1\":{\"322\":1}}],[\"用于调整注意力分数\",{\"1\":{\"322\":1}}],[\"用于调节\",{\"1\":{\"248\":1}}],[\"用于防止过拟合\",{\"1\":{\"321\":1}}],[\"用于随机深度\",{\"1\":{\"321\":1}}],[\"用于位置嵌入后的随机丢弃\",{\"1\":{\"320\":1,\"323\":1}}],[\"用于位置编码或其他处理\",{\"1\":{\"272\":1}}],[\"用于预测图像的类别\",{\"1\":{\"319\":1}}],[\"用于预训练新模型\",{\"1\":{\"140\":1}}],[\"用于计算相似度\",{\"1\":{\"822\":1}}],[\"用于计算交叉熵损失\",{\"1\":{\"618\":1}}],[\"用于计算\",{\"1\":{\"312\":1,\"773\":1}}],[\"用于计算平均损失的项数\",{\"1\":{\"186\":1}}],[\"用于收集所有\",{\"1\":{\"278\":1}}],[\"用于表示\",{\"1\":{\"274\":1,\"355\":1}}],[\"用于最终评估模型效果\",{\"1\":{\"274\":1}}],[\"用于评估\",{\"1\":{\"274\":2}}],[\"用于定义重复性的模版流程\",{\"1\":{\"274\":1}}],[\"用于全局聚合\",{\"1\":{\"272\":1}}],[\"用于更复杂的跨模态分类任务\",{\"1\":{\"269\":1}}],[\"用于更新中心和处理空簇\",{\"1\":{\"170\":1}}],[\"用于处理\",{\"1\":{\"822\":1}}],[\"用于处理类别不平衡\",{\"1\":{\"471\":1,\"473\":1}}],[\"用于处理模态特定的信息\",{\"1\":{\"269\":1}}],[\"用于处理多视角输入\",{\"1\":{\"186\":1}}],[\"用于检索任务\",{\"1\":{\"262\":1}}],[\"用于零样本分类\",{\"1\":{\"196\":1}}],[\"用于教师温度调度\",{\"1\":{\"186\":1}}],[\"用于正则化\",{\"1\":{\"186\":1}}],[\"用于记录每个码本向量被使用的次数\",{\"1\":{\"170\":1}}],[\"用于训练时的条件\",{\"1\":{\"815\":1}}],[\"用于训练奖励模型\",{\"1\":{\"537\":1}}],[\"用于训练或评估模型\",{\"1\":{\"232\":1}}],[\"用于训练视觉\",{\"1\":{\"167\":1}}],[\"用于训练下一个更强的模型\",{\"1\":{\"128\":1}}],[\"用于文本编码\",{\"1\":{\"160\":1}}],[\"用于将输入文本编码为\",{\"1\":{\"820\":1}}],[\"用于将输入图像分割成多个图像块并进行嵌入\",{\"1\":{\"318\":1}}],[\"用于将图像转换为离散的视觉\",{\"1\":{\"803\":1}}],[\"用于将张量中的值限制在指定的范围内\",{\"1\":{\"615\":1}}],[\"用于将张量\",{\"1\":{\"473\":1}}],[\"用于将张量沿指定维度\",{\"1\":{\"374\":1}}],[\"用于将自定义模型注册到\",{\"1\":{\"396\":1}}],[\"用于将任意大小的候选框\",{\"1\":{\"387\":1}}],[\"用于将一个方法定义为静态方法\",{\"1\":{\"316\":1}}],[\"用于将一个批次的数据组合成一个张量\",{\"1\":{\"316\":1}}],[\"用于将\",{\"1\":{\"154\":1,\"715\":1,\"821\":1}}],[\"用于二分类匹配\",{\"1\":{\"147\":1}}],[\"用于多模态编码\",{\"1\":{\"264\":1}}],[\"用于多模态\",{\"1\":{\"147\":1}}],[\"用于生成训练标签\",{\"1\":{\"803\":1}}],[\"用于生成\",{\"1\":{\"147\":1}}],[\"用于拷贝和更新\",{\"1\":{\"147\":1}}],[\"用于对比损失\",{\"1\":{\"822\":1}}],[\"用于对比学习中的\",{\"1\":{\"160\":1}}],[\"用于对比学习\",{\"1\":{\"145\":1}}],[\"用于对生成图像进行\",{\"1\":{\"817\":1}}],[\"用于对张量\",{\"1\":{\"370\":1}}],[\"用于对齐语言模型在广泛任务分布下的行为\",{\"1\":{\"536\":1}}],[\"用于对齐视觉与语言特征\",{\"1\":{\"197\":1}}],[\"用于对齐图像和文本的表示空间\",{\"1\":{\"127\":1}}],[\"用于论文3\",{\"1\":{\"142\":1}}],[\"用于图像字幕生成\",{\"1\":{\"142\":1}}],[\"用于学习图文之间的细粒度对齐关系\",{\"1\":{\"127\":1}}],[\"用于其他任务\",{\"1\":{\"101\":1}}],[\"用于后续所有卷积层\",{\"1\":{\"846\":1}}],[\"用于后续解码时跳过填充\",{\"1\":{\"820\":1}}],[\"用于后续解码时区分提示与生成文本\",{\"1\":{\"142\":1}}],[\"用于后续对比学习\",{\"1\":{\"186\":1}}],[\"用于后续编码\",{\"1\":{\"167\":1}}],[\"用于后续比较\",{\"1\":{\"108\":1}}],[\"用于后续计算其他点到该点的距离\",{\"1\":{\"92\":1}}],[\"用于后续分割掩码预测\",{\"1\":{\"74\":1}}],[\"用于快速访问每个\",{\"1\":{\"92\":1}}],[\"用于衡量被错误分类为垃圾邮件的合法电子邮件的比例\",{\"1\":{\"445\":1}}],[\"用于衡量两个概率分布之间的匹配程度\",{\"1\":{\"82\":1}}],[\"用于衡量模型输出的\",{\"1\":{\"82\":1}}],[\"用于衡量预测掩码与真实标签之间的空间重合度\",{\"1\":{\"78\":1}}],[\"用于缓解类别不平衡问题\",{\"1\":{\"78\":1}}],[\"用于支持该任务\",{\"1\":{\"48\":1}}],[\"用于稳定训练过程\",{\"1\":{\"45\":1}}],[\"用于\",{\"1\":{\"45\":1,\"92\":1,\"147\":1,\"160\":1,\"161\":1,\"162\":1,\"163\":3,\"169\":1,\"170\":1,\"186\":1,\"274\":2,\"276\":1,\"277\":1,\"355\":1,\"537\":2,\"580\":1,\"591\":1,\"804\":1,\"814\":1,\"817\":2,\"821\":2}}],[\"用于降低计算复杂度\",{\"1\":{\"45\":1}}],[\"用于融合来自语言模型的不同语义信息\",{\"1\":{\"45\":1}}],[\"用几何结构\",{\"1\":{\"32\":1}}],[\"用意图文本\",{\"1\":{\"32\":1}}],[\"用resnet18对图像进行编码\",{\"1\":{\"30\":1}}],[\"用手握住壶把倒水\",{\"1\":{\"28\":1}}],[\"训练pixelcnn\",{\"1\":{\"878\":1}}],[\"训练vq\",{\"1\":{\"878\":1}}],[\"训练好的解码器\",{\"1\":{\"869\":1}}],[\"训练样本\",{\"1\":{\"865\":1}}],[\"训练速度快\",{\"1\":{\"864\":1}}],[\"训练速度快了n倍\",{\"1\":{\"843\":1}}],[\"训练这类模型长期以来面临三大难题\",{\"1\":{\"864\":1}}],[\"训练生成器\",{\"1\":{\"840\":1}}],[\"训练判别器\",{\"1\":{\"840\":1}}],[\"训练优化trick不进行讲解\",{\"1\":{\"815\":1}}],[\"训练优化策略\",{\"1\":{\"548\":1}}],[\"训练细节见附录\",{\"1\":{\"809\":1}}],[\"训练和无条件生成的代码实现如下所示\",{\"1\":{\"848\":1}}],[\"训练和使用阶段都要一致\",{\"1\":{\"802\":1}}],[\"训练和测试阶段共享相似的物体类别和功能类型的分布\",{\"1\":{\"65\":1}}],[\"训练得到的图像\",{\"1\":{\"770\":1}}],[\"训练的核心目标函数\",{\"1\":{\"854\":1}}],[\"训练的模型\",{\"1\":{\"704\":1}}],[\"训练的时候固定\",{\"1\":{\"492\":1}}],[\"训练能够准确预测下一个单词的\",{\"1\":{\"704\":1}}],[\"训练步骤分析\",{\"0\":{\"562\":1}}],[\"训练硬件与效率\",{\"1\":{\"561\":1}}],[\"训练动态\",{\"1\":{\"549\":1}}],[\"训练任务覆盖广泛\",{\"1\":{\"537\":1}}],[\"训练任务包括图文匹配\",{\"1\":{\"261\":1}}],[\"训练语言模型以遵循自然语言指令\",{\"1\":{\"536\":1}}],[\"训练语料所在的文件列表\",{\"1\":{\"476\":1}}],[\"训练语料为\",{\"1\":{\"476\":1}}],[\"训练依赖微软提供的高带宽gpu集群\",{\"1\":{\"528\":1}}],[\"训练一个自回归\",{\"1\":{\"807\":1}}],[\"训练一个\",{\"1\":{\"790\":1}}],[\"训练一个少量参数的小模型\",{\"1\":{\"485\":1}}],[\"训练一个轻量级的微调模型\",{\"1\":{\"482\":1}}],[\"训练一个奖励模型\",{\"1\":{\"232\":1}}],[\"训练成本非常高\",{\"1\":{\"482\":1}}],[\"训练数据加载器\",{\"1\":{\"803\":1}}],[\"训练数据中的敏感信息需要妥善处理\",{\"1\":{\"711\":1}}],[\"训练数据中的例子\",{\"1\":{\"232\":1}}],[\"训练数据主要为英文\",{\"1\":{\"539\":1}}],[\"训练数据和奖励信号均来自一组英语标注者\",{\"1\":{\"539\":1}}],[\"训练数据集\",{\"1\":{\"521\":1}}],[\"训练数据的标签数组\",{\"1\":{\"399\":1}}],[\"训练与评估流程的代码为模版代码\",{\"1\":{\"327\":1}}],[\"训练与测试灵活性\",{\"1\":{\"224\":1}}],[\"训练了10个epoch\",{\"1\":{\"327\":1}}],[\"训练代价\",{\"1\":{\"307\":1}}],[\"训练代码如下所示\",{\"1\":{\"252\":1}}],[\"训练代码\",{\"1\":{\"159\":1}}],[\"训练效率成为一个至关重要的因素\",{\"1\":{\"305\":1}}],[\"训练效率可以提高4倍\",{\"1\":{\"305\":1}}],[\"训练使用到的数据集和alexnet保持一致\",{\"1\":{\"302\":1}}],[\"训练出a和b即可得到∆w\",{\"1\":{\"487\":1}}],[\"训练出具有可迁移能力的视觉模型\",{\"1\":{\"297\":1}}],[\"训练出一个能预测人类偏好的奖励模型\",{\"1\":{\"535\":1}}],[\"训练出一个能自然理解图像内容\",{\"1\":{\"235\":1}}],[\"训练出一个能看懂图的视觉分词器\",{\"1\":{\"234\":1}}],[\"训练不稳定\",{\"1\":{\"277\":1}}],[\"训练更稳定但区分度下降\",{\"1\":{\"248\":1}}],[\"训练方式\",{\"1\":{\"239\":1}}],[\"训练策略如下\",{\"1\":{\"537\":1}}],[\"训练策略遵循了\",{\"1\":{\"528\":1}}],[\"训练策略\",{\"1\":{\"237\":1}}],[\"训练流程\",{\"1\":{\"234\":1,\"235\":1}}],[\"训练奖励模型\",{\"1\":{\"232\":1,\"534\":1}}],[\"训练监督模型\",{\"1\":{\"232\":1}}],[\"训练图像的分辨率从固定的448×448扩展为动态的448×448\",{\"1\":{\"223\":1}}],[\"训练初期冻结学生网络最后一层\",{\"1\":{\"186\":1}}],[\"训练初期模型尚不稳定\",{\"1\":{\"159\":1}}],[\"训练循环\",{\"1\":{\"186\":3,\"848\":1}}],[\"训练50个epoch能达到35\",{\"1\":{\"185\":1}}],[\"训练线性分类器\",{\"1\":{\"179\":1}}],[\"训练模式下\",{\"1\":{\"822\":1}}],[\"训练模式下更新\",{\"1\":{\"170\":1}}],[\"训练模型\",{\"0\":{\"856\":1},\"1\":{\"885\":1}}],[\"训练模型去区分它们\",{\"1\":{\"175\":1}}],[\"训练模型以自回归方式生成文本\",{\"1\":{\"127\":1}}],[\"训练模型根据图像生成文本描述\",{\"1\":{\"127\":1}}],[\"训练目标的引导\",{\"1\":{\"319\":1}}],[\"训练目标\",{\"1\":{\"234\":1,\"235\":1,\"239\":1,\"312\":1}}],[\"训练目标公式为\",{\"1\":{\"167\":1}}],[\"训练目标最大化\",{\"1\":{\"167\":1}}],[\"训练中\",{\"1\":{\"167\":1,\"857\":1}}],[\"训练完成后\",{\"1\":{\"165\":1,\"869\":1,\"878\":1,\"883\":1}}],[\"训练过程就比较常规了\",{\"1\":{\"581\":1}}],[\"训练过程与资源分配\",{\"1\":{\"528\":1}}],[\"训练过程中对\",{\"1\":{\"770\":1}}],[\"训练过程中的一些\",{\"1\":{\"537\":1}}],[\"训练过程中\",{\"1\":{\"167\":1,\"319\":1}}],[\"训练过程\",{\"0\":{\"860\":1},\"1\":{\"165\":1,\"803\":1}}],[\"训练过程代码实现基本遵循moco论文中所提出的动量慢更新对比学习代码实现\",{\"1\":{\"145\":1}}],[\"训练稳定\",{\"1\":{\"159\":1}}],[\"训练函数\",{\"1\":{\"142\":1}}],[\"训练多个模型\",{\"1\":{\"138\":1}}],[\"训练时提取\",{\"1\":{\"821\":1}}],[\"训练时设为\",{\"1\":{\"821\":1}}],[\"训练时必须提供图像\",{\"1\":{\"815\":1}}],[\"训练时末尾\",{\"1\":{\"815\":1}}],[\"训练时用\",{\"1\":{\"795\":1}}],[\"训练时\",{\"1\":{\"544\":1,\"802\":1,\"843\":1}}],[\"训练时将所有配对作为一个\",{\"1\":{\"537\":1}}],[\"训练时的对比缩放因子\",{\"1\":{\"277\":1}}],[\"训练时可能是\",{\"1\":{\"276\":1}}],[\"训练时最多12区块\",{\"1\":{\"224\":1}}],[\"训练时根据输入图像的宽高比和分辨率\",{\"1\":{\"222\":1}}],[\"训练时间的性价比\",{\"1\":{\"184\":1}}],[\"训练时间会更长\",{\"1\":{\"136\":1}}],[\"训练时会对每个图像随机采样\",{\"1\":{\"29\":1}}],[\"训练轮数为\",{\"1\":{\"131\":1}}],[\"训练配置如下\",{\"1\":{\"131\":1}}],[\"训练\",{\"0\":{\"79\":1,\"81\":1,\"299\":1,\"581\":1},\"1\":{\"68\":1,\"79\":1,\"186\":1,\"191\":1,\"198\":1,\"210\":1,\"211\":1,\"212\":1,\"266\":1,\"274\":1,\"277\":1,\"514\":1,\"537\":2,\"539\":3,\"560\":1,\"796\":1,\"807\":1,\"814\":1,\"840\":2,\"886\":2}}],[\"训练集与测试集性能对比\",{\"1\":{\"522\":1}}],[\"训练集与测试集中的物体与可供性类别相同\",{\"1\":{\"20\":1}}],[\"训练集的预处理转换操作\",{\"1\":{\"317\":1}}],[\"训练集通常打乱\",{\"1\":{\"274\":1}}],[\"训练集\",{\"1\":{\"68\":1}}],[\"训练阶段使用随机裁剪缩放和水平翻转\",{\"1\":{\"179\":1}}],[\"训练阶段唯一需要注意的一点就是数据集的构造过程中\",{\"1\":{\"142\":1}}],[\"训练阶段则是模型的核心迭代过程\",{\"1\":{\"81\":1}}],[\"训练阶段\",{\"0\":{\"885\":1},\"1\":{\"66\":1,\"227\":1,\"273\":1,\"822\":1,\"869\":1}}],[\"中这种依赖\",{\"1\":{\"868\":1}}],[\"中说明了这个问题的本质\",{\"1\":{\"866\":1}}],[\"中对\",{\"1\":{\"866\":1}}],[\"中对应位置的元素\",{\"1\":{\"368\":2}}],[\"中重参数化采样\",{\"1\":{\"853\":1}}],[\"中以概率方式采样一个\",{\"1\":{\"819\":1}}],[\"中以学习上下文表示\",{\"1\":{\"263\":1}}],[\"中获取\",{\"1\":{\"818\":1}}],[\"中获得广泛能力\",{\"1\":{\"531\":1}}],[\"中只用\",{\"1\":{\"800\":1}}],[\"中只有一组\",{\"1\":{\"92\":1}}],[\"中最成功的预训练方法之一\",{\"1\":{\"788\":1}}],[\"中也直接采用了类似的方法\",{\"1\":{\"778\":1}}],[\"中已经成为常规做法\",{\"1\":{\"778\":1}}],[\"中间\",{\"1\":{\"837\":1}}],[\"中间微调\",{\"0\":{\"778\":1},\"1\":{\"778\":1}}],[\"中间变量y和t的导数被立即释放\",{\"1\":{\"688\":1}}],[\"中间变量导数被清除\",{\"1\":{\"688\":1}}],[\"中间变量的导数往往无用\",{\"1\":{\"688\":1}}],[\"中推断出一个三维形状\",{\"1\":{\"759\":1}}],[\"中采样可以获得多少关于\",{\"1\":{\"872\":1}}],[\"中采样可以提供更快\",{\"1\":{\"869\":1}}],[\"中采样相比\",{\"1\":{\"872\":1}}],[\"中采样得到的不同\",{\"1\":{\"868\":1}}],[\"中采样的\",{\"1\":{\"867\":1,\"868\":1}}],[\"中采样的样本尽量和真实分布相似\",{\"1\":{\"864\":1}}],[\"中采样一个\",{\"1\":{\"820\":1,\"869\":1}}],[\"中采样\",{\"1\":{\"753\":1,\"857\":1}}],[\"中采用的是每个\",{\"1\":{\"145\":1}}],[\"中有\",{\"1\":{\"740\":1}}],[\"中蒸馏出的六个\",{\"1\":{\"704\":1}}],[\"中速\",{\"1\":{\"704\":1}}],[\"中支持多输出节点\",{\"1\":{\"682\":1}}],[\"中取出对应的\",{\"1\":{\"616\":1}}],[\"中取出被掩码位置的\",{\"1\":{\"580\":1}}],[\"中取值\",{\"1\":{\"581\":2}}],[\"中非常经典\",{\"1\":{\"577\":1}}],[\"中自己的值占大头也无所谓\",{\"1\":{\"575\":1}}],[\"中实际上会更加看重\",{\"1\":{\"575\":1}}],[\"中类型\",{\"1\":{\"575\":1}}],[\"中全面超越chinchilla\",{\"1\":{\"549\":1}}],[\"中快速适应新任务\",{\"1\":{\"531\":1}}],[\"中则表现平庸甚至接近随机\",{\"1\":{\"530\":1}}],[\"中零样本设定下创下新sota\",{\"1\":{\"529\":1}}],[\"中等模型\",{\"1\":{\"521\":1}}],[\"中随机采样得到\",{\"1\":{\"514\":1}}],[\"中随机抽样字典大小就可以了\",{\"1\":{\"250\":1}}],[\"中从数据集中抽多少个样本\",{\"1\":{\"403\":1}}],[\"中选择概率最高的\",{\"1\":{\"818\":1}}],[\"中选出排名前\",{\"1\":{\"811\":1}}],[\"中选定若干个浮点坐标点\",{\"1\":{\"387\":1}}],[\"中选取了\",{\"1\":{\"63\":1}}],[\"中为了解决\",{\"1\":{\"387\":1}}],[\"中为每张图像选择一个最相似的非匹配文本作为负样本\",{\"1\":{\"156\":1}}],[\"中生成等间隔数列的函数\",{\"1\":{\"332\":1}}],[\"中引入卷积操作\",{\"1\":{\"326\":1}}],[\"中进行进一步的处理\",{\"1\":{\"326\":1}}],[\"中加载数据时\",{\"1\":{\"316\":1}}],[\"中每个向量的维度\",{\"1\":{\"821\":1}}],[\"中每个整数出现的次数\",{\"1\":{\"377\":1}}],[\"中每个\",{\"1\":{\"310\":1}}],[\"中每个word映射到词空间\",{\"1\":{\"295\":1}}],[\"中常用的图像嵌入方法\",{\"1\":{\"272\":1}}],[\"中去\",{\"1\":{\"250\":1}}],[\"中来的\",{\"1\":{\"250\":1}}],[\"中文能力相对来说是非常不错的开源模型\",{\"1\":{\"704\":1}}],[\"中文能力突出\",{\"1\":{\"228\":1}}],[\"中文任务和高分辨率场景下的性能\",{\"1\":{\"225\":1}}],[\"中超越商业模型\",{\"1\":{\"216\":1}}],[\"中英文问答对\",{\"1\":{\"215\":1}}],[\"中新加入的可学习查询\",{\"1\":{\"199\":1}}],[\"中原本为\",{\"1\":{\"186\":1}}],[\"中处理\",{\"1\":{\"186\":1}}],[\"中分别进行一次前向计算\",{\"1\":{\"186\":1}}],[\"中未被观察到\",{\"1\":{\"182\":1}}],[\"中查找每个\",{\"1\":{\"167\":1}}],[\"中期\",{\"1\":{\"159\":1}}],[\"中更稳定地训练\",{\"1\":{\"157\":1}}],[\"中第一个线性层把输入特征投影到一个更高维度的空间后\",{\"1\":{\"321\":1}}],[\"中第\",{\"1\":{\"134\":1}}],[\"中优先选择对比相似度高的负样本来增强训练信号\",{\"1\":{\"127\":1}}],[\"中添加一层\",{\"1\":{\"126\":1}}],[\"中心像素还是能看到自己位置的输入信息\",{\"1\":{\"845\":1}}],[\"中心像素的值就会和输入图像毫无关系\",{\"1\":{\"845\":1}}],[\"中心像素能够看到左上角大部分像素的信息\",{\"1\":{\"845\":1}}],[\"中心差分近似可以问问gpt\",{\"1\":{\"651\":1}}],[\"中心或等距分布\",{\"1\":{\"387\":1}}],[\"中心更新的\",{\"1\":{\"186\":1}}],[\"中心和\",{\"1\":{\"169\":1}}],[\"中心\",{\"1\":{\"112\":1,\"186\":2}}],[\"中心化\",{\"1\":{\"83\":1,\"186\":1}}],[\"中用于训练的\",{\"1\":{\"854\":1}}],[\"中用于扩展张量尺寸但不复制数据的一种高效方法\",{\"1\":{\"364\":1}}],[\"中用于沿指定维度重复张量内容的操作\",{\"1\":{\"363\":1}}],[\"中用于将多个形状相同的张量沿一个新维度拼接的函数\",{\"1\":{\"358\":1}}],[\"中用于约束变换矩阵接近正交性的正则化损失函数\",{\"1\":{\"108\":1}}],[\"中用于点云\",{\"1\":{\"100\":1}}],[\"中用于从点云中选择具有代表性的采样点的一种策略\",{\"1\":{\"92\":1}}],[\"中均能有效提取特征\",{\"1\":{\"95\":1}}],[\"中找到最大的那个距离对应的点\",{\"1\":{\"92\":2}}],[\"中提出的\",{\"1\":{\"868\":1}}],[\"中提出\",{\"1\":{\"470\":1}}],[\"中提供了\",{\"1\":{\"274\":1}}],[\"中提到\",{\"1\":{\"78\":1}}],[\"中提取离散\",{\"1\":{\"794\":1}}],[\"中提取信息\",{\"1\":{\"412\":1}}],[\"中提取与\",{\"1\":{\"309\":2}}],[\"中提取对应的点\",{\"1\":{\"92\":1}}],[\"中提取\",{\"1\":{\"46\":1,\"616\":1}}],[\"中提取共性的几何属性\",{\"1\":{\"29\":1}}],[\"中的离散向量\",{\"1\":{\"885\":1}}],[\"中的稀疏正则化很相似\",{\"1\":{\"873\":1}}],[\"中的证明方法可能可以推广到多维情形\",{\"1\":{\"871\":1}}],[\"中的参数\",{\"1\":{\"865\":1}}],[\"中的参数微调就可以了\",{\"1\":{\"575\":1}}],[\"中的权重\",{\"1\":{\"814\":1}}],[\"中的索引\",{\"1\":{\"803\":1}}],[\"中的每个空间位置的向量与\",{\"1\":{\"885\":1}}],[\"中的每个\",{\"1\":{\"773\":1}}],[\"中的每个元素限制在\",{\"1\":{\"473\":1}}],[\"中的每个元素要加到目标张量的哪个位置\",{\"1\":{\"379\":1}}],[\"中的目标\",{\"1\":{\"773\":1}}],[\"中的目标函数模型后\",{\"1\":{\"511\":1}}],[\"中的词嵌入\",{\"1\":{\"769\":1}}],[\"中的几个语法技巧\",{\"1\":{\"681\":1}}],[\"中的全连接层权重\",{\"1\":{\"580\":1}}],[\"中的全局特征学习\",{\"1\":{\"92\":1}}],[\"中的不一样\",{\"1\":{\"573\":1}}],[\"中的值限制在区间\",{\"1\":{\"473\":1}}],[\"中的样本取平均\",{\"1\":{\"467\":1}}],[\"中的标准组件\",{\"1\":{\"387\":1}}],[\"中的出现次数\",{\"1\":{\"377\":1}}],[\"中的多个样本打包成一个大\",{\"1\":{\"358\":1}}],[\"中的语法\",{\"1\":{\"355\":1}}],[\"中的语言引导\",{\"1\":{\"78\":1}}],[\"中的一种\",{\"1\":{\"797\":1}}],[\"中的一种语法结构\",{\"1\":{\"342\":1}}],[\"中的一个嵌入向量\",{\"1\":{\"885\":1}}],[\"中的一个方法\",{\"1\":{\"615\":1}}],[\"中的一个函数\",{\"1\":{\"473\":1}}],[\"中的一个装饰器\",{\"1\":{\"316\":1}}],[\"中的变量\",{\"1\":{\"340\":1}}],[\"中的图像一一对应\",{\"1\":{\"316\":1}}],[\"中的视觉语言专家\",{\"1\":{\"268\":1}}],[\"中的特征加入队列\",{\"1\":{\"246\":1}}],[\"中的名词短语\",{\"1\":{\"234\":1}}],[\"中的指令调优思想引入多模态领域的研究\",{\"1\":{\"232\":1}}],[\"中的核心操作\",{\"1\":{\"115\":1}}],[\"中的核心模块\",{\"1\":{\"92\":1}}],[\"中的原始特征\",{\"1\":{\"98\":1}}],[\"中的\",{\"1\":{\"96\":1,\"248\":1,\"277\":1,\"339\":1,\"404\":1,\"571\":1,\"573\":1,\"798\":1,\"821\":1,\"867\":1,\"872\":1}}],[\"中的数据\",{\"1\":{\"76\":1}}],[\"中的空间卷积\",{\"1\":{\"73\":1}}],[\"中的自注意力机制\",{\"1\":{\"73\":1}}],[\"中筛选出同时满足\",{\"1\":{\"68\":1}}],[\"中椅子的\",{\"1\":{\"49\":1}}],[\"中使用的任务层设计\",{\"1\":{\"777\":1}}],[\"中使用的共享自注意力模块的消融实验结果\",{\"1\":{\"268\":1}}],[\"中使用\",{\"1\":{\"45\":1,\"115\":1}}],[\"中\",{\"1\":{\"29\":1,\"82\":1,\"108\":1,\"145\":1,\"157\":2,\"176\":1,\"199\":1,\"202\":1,\"248\":1,\"272\":2,\"274\":1,\"277\":1,\"300\":2,\"307\":2,\"311\":1,\"312\":1,\"317\":1,\"319\":5,\"362\":1,\"366\":2,\"385\":2,\"404\":1,\"405\":1,\"415\":1,\"422\":2,\"426\":1,\"438\":2,\"529\":1,\"562\":1,\"572\":1,\"580\":1,\"594\":1,\"614\":1,\"703\":1,\"758\":1,\"773\":1,\"793\":1,\"807\":1,\"854\":1,\"858\":1,\"866\":1,\"869\":1,\"873\":1,\"885\":1}}],[\">0\",{\"1\":{\"814\":1}}],[\">1\",{\"1\":{\"814\":1,\"815\":1}}],[\">1024\",{\"1\":{\"70\":1}}],[\">表示箭头连接\",{\"1\":{\"696\":1}}],[\">>\",{\"1\":{\"385\":1}}],[\">nk\",{\"1\":{\"255\":1,\"367\":1}}],[\">n\",{\"1\":{\"255\":1,\"367\":1}}],[\">bhlm\",{\"1\":{\"590\":3}}],[\">bn\",{\"1\":{\"170\":1}}],[\">bln\",{\"1\":{\"70\":1,\"76\":3}}],[\">=\",{\"1\":{\"82\":2,\"272\":1,\"275\":1,\"577\":1,\"814\":4,\"817\":1,\"821\":1}}],[\">2表示从节点1到节点3的有向边\",{\"1\":{\"696\":1}}],[\">2048\",{\"1\":{\"70\":1}}],[\">256\",{\"1\":{\"70\":1}}],[\">512\",{\"1\":{\"70\":1}}],[\">object\",{\"1\":{\"35\":1}}],[\">\",{\"1\":{\"29\":1,\"34\":3,\"35\":4,\"36\":3,\"40\":2,\"45\":3,\"46\":2,\"59\":5,\"82\":1,\"83\":2,\"92\":1,\"100\":1,\"111\":1,\"145\":1,\"170\":7,\"252\":2,\"254\":1,\"256\":1,\"257\":1,\"272\":3,\"274\":1,\"277\":1,\"294\":2,\"305\":2,\"312\":1,\"313\":1,\"319\":2,\"320\":2,\"321\":1,\"322\":8,\"323\":3,\"370\":4,\"372\":1,\"373\":1,\"389\":1,\"455\":1,\"463\":1,\"473\":1,\"476\":10,\"477\":7,\"478\":23,\"544\":2,\"578\":3,\"579\":2,\"591\":2,\"594\":3,\"596\":1,\"615\":1,\"632\":1,\"681\":1,\"686\":1,\"688\":1,\"696\":5,\"728\":1,\"762\":1,\"763\":1,\"794\":2,\"798\":1,\"801\":1,\"804\":2,\"814\":2,\"815\":4,\"821\":7,\"822\":5,\"853\":2,\"885\":4}}],[\"所在的高维空间\",{\"1\":{\"864\":1}}],[\"所参数化的分类分布\",{\"1\":{\"808\":1}}],[\"所参考源仓库未提供requirements\",{\"1\":{\"593\":1}}],[\"所提出的方法在性能上显著优于像素级自编码方案\",{\"1\":{\"772\":1}}],[\"所提供的代码展开进行讲解\",{\"1\":{\"620\":1}}],[\"所遮挡后的损坏图像\",{\"1\":{\"772\":1}}],[\"所采用的\",{\"1\":{\"536\":1}}],[\"所占的内存资源和计算资源呢\",{\"1\":{\"490\":1}}],[\"所谓\",{\"1\":{\"385\":1}}],[\"所具备的\",{\"1\":{\"314\":1}}],[\"所给代码删除了大量非核心逻辑\",{\"1\":{\"288\":1}}],[\"所需神经元\",{\"1\":{\"385\":1}}],[\"所需特征\",{\"1\":{\"277\":1}}],[\"所需的比特数\",{\"1\":{\"873\":1}}],[\"所需的信息量\",{\"1\":{\"872\":1}}],[\"所需的平均信息量\",{\"1\":{\"872\":1}}],[\"所需的总比特数\",{\"1\":{\"872\":1}}],[\"所需的交集\",{\"1\":{\"473\":1}}],[\"所需的关键词参数\",{\"1\":{\"143\":1}}],[\"所需的输入格式\",{\"1\":{\"43\":1}}],[\"所使用到的所有数据集对应的\",{\"1\":{\"274\":1}}],[\"所使用的训练数据总共包含约\",{\"1\":{\"131\":1}}],[\"所使用的隐藏状态空间维度\",{\"1\":{\"42\":1}}],[\"所以效果也比较差\",{\"1\":{\"886\":1}}],[\"所以近两年我们能看到很多使用了codebook的图像生成类工作\",{\"1\":{\"883\":1}}],[\"所以它不能很好地完成图像生成任务\",{\"1\":{\"878\":1}}],[\"所以它总是非负且有限\",{\"1\":{\"834\":1}}],[\"所以在优化过程中可以忽略\",{\"1\":{\"873\":1}}],[\"所以在反向传播前需调用各变量的cleargrad方法重置导数\",{\"1\":{\"697\":1}}],[\"所以还会有一个误差项\",{\"1\":{\"872\":1}}],[\"所以还是很有挑战性的\",{\"1\":{\"515\":1}}],[\"所以训练好的解码器知道\",{\"1\":{\"869\":1}}],[\"所以训练中我们就可以只最小化重建损失\",{\"1\":{\"773\":1}}],[\"所以反向传播可以计算出有效梯度用于随机梯度下降\",{\"1\":{\"868\":1}}],[\"所以整个图像的条件概率为\",{\"1\":{\"854\":1}}],[\"所以除以\",{\"1\":{\"752\":1}}],[\"所以模型的任务是\",{\"1\":{\"616\":1}}],[\"所以模型必须具有对点顺序的不变性\",{\"1\":{\"115\":1}}],[\"所以最终的答案只能来自原始输入文本中的某一段子串\",{\"1\":{\"616\":1}}],[\"所以我只是取其中的一部分数据\",{\"1\":{\"593\":1}}],[\"所以我们自然希望选择一个依赖于\",{\"1\":{\"867\":1}}],[\"所以我们用一个变换把它映射为正数\",{\"1\":{\"853\":1}}],[\"所以我们需要\",{\"1\":{\"853\":1}}],[\"所以我们需要一个规则体系来规定\",{\"1\":{\"728\":1}}],[\"所以我们需要加一个正则化项来鼓励变换矩阵接近正交矩阵\",{\"1\":{\"108\":1}}],[\"所以我们可以很容易地去建立一个字典\",{\"1\":{\"246\":1}}],[\"所以准确度不是在我的考虑范围之内\",{\"1\":{\"593\":1}}],[\"所以都用\",{\"1\":{\"590\":1}}],[\"所以要把负值平移到正数区间\",{\"1\":{\"590\":1}}],[\"所以要把它复制\",{\"1\":{\"111\":1}}],[\"所以就算\",{\"1\":{\"575\":1}}],[\"所以不过多展开\",{\"1\":{\"544\":1}}],[\"所以矩阵\",{\"1\":{\"493\":2}}],[\"所以正确的strides是\",{\"1\":{\"426\":1}}],[\"所以正样本和负样本要走同一个编码器\",{\"1\":{\"246\":1}}],[\"所以原本的格子边界保持得很清晰\",{\"1\":{\"389\":1}}],[\"所以使用装饰器会导致原函数的\",{\"1\":{\"346\":1}}],[\"所以参数量为\",{\"1\":{\"324\":1}}],[\"所以把\",{\"1\":{\"312\":1}}],[\"所以下面我们将首先对其\",{\"1\":{\"272\":1}}],[\"所以抽样的部分还是要大一点\",{\"1\":{\"248\":1}}],[\"所以作者提出\",{\"1\":{\"247\":1}}],[\"所以moco要做的就是\",{\"1\":{\"246\":1}}],[\"所以如果key这个字典足够大\",{\"1\":{\"246\":1}}],[\"所以cv领域并不适合去建立一个字典来学习模型\",{\"1\":{\"246\":1}}],[\"所以个体判别这个代理任务定义了什么是正样本\",{\"1\":{\"243\":1}}],[\"所以个体判别这个代理任务经过模型训练\",{\"1\":{\"243\":1}}],[\"所以这两张图片就可以称之为正样本\",{\"1\":{\"243\":1}}],[\"所以这个表达式的含义是\",{\"1\":{\"76\":1}}],[\"所以\",{\"1\":{\"117\":1,\"248\":2,\"346\":1,\"407\":1,\"470\":1,\"575\":1,\"587\":2,\"590\":1,\"727\":2,\"729\":1,\"731\":1,\"754\":1,\"798\":1,\"807\":1,\"838\":1,\"843\":1,\"866\":1}}],[\"所以小的才是有效点\",{\"1\":{\"92\":1}}],[\"所支持的23种物体类型和17种功能类型\",{\"1\":{\"68\":1}}],[\"所有元素的乘积\",{\"1\":{\"840\":2}}],[\"所有可能的\",{\"1\":{\"728\":1}}],[\"所有输入序列等长\",{\"1\":{\"594\":1}}],[\"所有序列都填充到max\",{\"1\":{\"594\":1}}],[\"所有样本列表构成batch数据返回\",{\"1\":{\"579\":1}}],[\"所有模型都在\",{\"1\":{\"780\":1}}],[\"所有模型都基于\",{\"1\":{\"537\":1}}],[\"所有模型都使用3000亿tokens进行训练\",{\"1\":{\"528\":1}}],[\"所有模型共享最大上下文窗口为2048\",{\"1\":{\"528\":1}}],[\"所有模型均采用相同的架构\",{\"1\":{\"522\":1}}],[\"所有模型均训练了32个周期\",{\"1\":{\"299\":1}}],[\"所有模型在\",{\"1\":{\"521\":1}}],[\"所有无偏差或增益权重设置为\",{\"1\":{\"514\":1}}],[\"所有的嵌入都存储在一个嵌入空间\",{\"1\":{\"883\":1}}],[\"所有的转换包括添加随机初初始化的开始和结束标记\",{\"1\":{\"512\":1}}],[\"所有的数据都将发生变化\",{\"1\":{\"86\":1}}],[\"所有注意力头\",{\"1\":{\"463\":1}}],[\"所有变量两两之间协方差的矩阵表示\",{\"1\":{\"455\":1}}],[\"所有这些指标都是基于单个分类阈值值计算得出的\",{\"1\":{\"449\":1}}],[\"所有行均指向原始数据的第\",{\"1\":{\"427\":1}}],[\"所有类别的\",{\"1\":{\"399\":1}}],[\"所有类别权重为\",{\"1\":{\"399\":1}}],[\"所有张量必须具有完全相同的\",{\"1\":{\"358\":1}}],[\"所有logits的平均作为最终的matching\",{\"1\":{\"311\":1}}],[\"所有参数可训练\",{\"1\":{\"211\":1}}],[\"所有参数均参与训练\",{\"1\":{\"208\":1}}],[\"所有参数都是可训练的\",{\"1\":{\"199\":1}}],[\"所有裁剪\",{\"1\":{\"186\":1}}],[\"所有特征拼接完成后\",{\"1\":{\"186\":1}}],[\"所有图文对的前向传播\",{\"1\":{\"162\":1}}],[\"所有\",{\"1\":{\"145\":1,\"167\":1,\"312\":2,\"728\":1}}],[\"所有卷积和\",{\"1\":{\"107\":1}}],[\"所有点相乘\",{\"1\":{\"115\":1}}],[\"所有点相加\",{\"1\":{\"115\":1}}],[\"所有点经过共享参数的\",{\"1\":{\"105\":1}}],[\"所有点组成的局部区域\",{\"1\":{\"92\":1}}],[\"所有尺度的特征保存到\",{\"1\":{\"96\":1}}],[\"所有尺度的网络并行运行\",{\"1\":{\"96\":1}}],[\"所有问题专属于评估阶段\",{\"1\":{\"66\":1}}],[\"所有物体几何结构文本数据\",{\"1\":{\"29\":1}}],[\"所有人类交互文本数据\",{\"1\":{\"29\":1}}],[\"所示\",{\"1\":{\"6\":1,\"17\":1,\"19\":1,\"136\":1,\"157\":1,\"167\":1,\"199\":2,\"262\":1,\"528\":2,\"759\":1,\"766\":1,\"767\":1}}],[\"+max\",{\"1\":{\"591\":1}}],[\"+512\",{\"1\":{\"591\":1}}],[\"+5\",{\"1\":{\"550\":1}}],[\"+9\",{\"1\":{\"550\":1}}],[\"+1\",{\"1\":{\"477\":2,\"478\":2,\"814\":1}}],[\"+i\",{\"1\":{\"147\":1}}],[\"+qid\",{\"1\":{\"68\":1}}],[\"+0\",{\"1\":{\"59\":9}}],[\"+=\",{\"1\":{\"29\":1,\"58\":1,\"82\":3,\"186\":2,\"302\":1,\"304\":1,\"312\":1,\"323\":2,\"476\":6,\"477\":2,\"478\":5,\"541\":1,\"579\":1,\"581\":1,\"590\":2,\"591\":3,\"696\":7,\"801\":2,\"815\":3,\"820\":1,\"822\":2,\"848\":1,\"856\":1,\"860\":1,\"885\":2,\"886\":1}}],[\"+\",{\"0\":{\"695\":2,\"854\":1},\"1\":{\"28\":4,\"29\":1,\"32\":2,\"36\":3,\"40\":4,\"43\":2,\"45\":9,\"46\":7,\"55\":1,\"58\":1,\"59\":8,\"72\":1,\"73\":2,\"74\":3,\"75\":1,\"76\":4,\"78\":15,\"81\":1,\"82\":3,\"83\":1,\"92\":2,\"93\":2,\"96\":6,\"98\":1,\"99\":1,\"100\":8,\"105\":1,\"107\":2,\"111\":1,\"112\":3,\"115\":1,\"116\":1,\"117\":1,\"122\":1,\"145\":20,\"147\":10,\"159\":2,\"161\":8,\"162\":5,\"163\":3,\"170\":2,\"173\":2,\"186\":15,\"198\":1,\"203\":1,\"205\":2,\"225\":1,\"232\":1,\"235\":1,\"256\":1,\"257\":2,\"268\":2,\"272\":13,\"276\":2,\"277\":7,\"278\":9,\"289\":1,\"292\":1,\"293\":2,\"294\":7,\"295\":2,\"299\":1,\"300\":1,\"302\":2,\"304\":2,\"307\":1,\"310\":1,\"311\":4,\"312\":6,\"316\":1,\"320\":2,\"321\":2,\"322\":11,\"323\":2,\"341\":1,\"342\":1,\"344\":1,\"387\":4,\"425\":1,\"442\":4,\"467\":3,\"468\":8,\"469\":4,\"471\":6,\"473\":6,\"476\":4,\"477\":5,\"478\":5,\"487\":2,\"515\":2,\"531\":1,\"537\":1,\"538\":2,\"539\":1,\"542\":2,\"544\":11,\"561\":1,\"565\":1,\"578\":2,\"579\":21,\"580\":5,\"581\":6,\"587\":1,\"590\":1,\"591\":4,\"594\":21,\"597\":4,\"599\":1,\"603\":2,\"605\":3,\"606\":2,\"610\":1,\"612\":2,\"615\":2,\"616\":1,\"617\":1,\"618\":6,\"626\":4,\"627\":1,\"630\":4,\"631\":1,\"652\":1,\"656\":2,\"684\":2,\"686\":2,\"688\":1,\"689\":1,\"690\":14,\"692\":14,\"696\":16,\"697\":3,\"700\":1,\"716\":1,\"717\":2,\"758\":1,\"793\":3,\"794\":2,\"795\":1,\"796\":4,\"798\":1,\"801\":4,\"804\":2,\"814\":7,\"815\":9,\"816\":1,\"817\":3,\"819\":1,\"820\":2,\"821\":8,\"822\":1,\"840\":3,\"846\":3,\"848\":3,\"853\":1,\"854\":2,\"859\":3,\"869\":1,\"881\":1,\"885\":4,\"886\":1}}],[\"推近\",{\"1\":{\"869\":1}}],[\"推荐阅读\",{\"0\":{\"875\":1}}],[\"推荐资料\",{\"0\":{\"841\":1}}],[\"推荐系统等多种应用场景\",{\"1\":{\"709\":1}}],[\"推荐系统\",{\"1\":{\"391\":1}}],[\"推导见附录\",{\"1\":{\"808\":1}}],[\"推导式\",{\"1\":{\"336\":1}}],[\"推出了其推理模型\",{\"1\":{\"704\":1}}],[\"推测约\",{\"1\":{\"704\":1}}],[\"推测其他交互\",{\"1\":{\"28\":1}}],[\"推动开源大模型发展\",{\"1\":{\"552\":1}}],[\"推动双向预训练\",{\"1\":{\"552\":1}}],[\"推动更通用\",{\"1\":{\"527\":1}}],[\"推动学界重新思考语言模型在多任务学习中的角色\",{\"1\":{\"523\":1}}],[\"推动技术民主化进程\",{\"1\":{\"230\":1}}],[\"推动了多模态大模型的发展\",{\"1\":{\"206\":1}}],[\"推动多模态应用发展\",{\"1\":{\"189\":1}}],[\"推动\",{\"1\":{\"69\":1}}],[\"推理过程\",{\"0\":{\"817\":1}}],[\"推理过程修改的关键\",{\"1\":{\"544\":1}}],[\"推理延迟\",{\"1\":{\"711\":1}}],[\"推理策略\",{\"1\":{\"706\":1}}],[\"推理能力限制\",{\"1\":{\"709\":1}}],[\"推理能力和代码能力提升非常显著\",{\"1\":{\"704\":1}}],[\"推理能力受限\",{\"1\":{\"24\":1}}],[\"推理深度和创意表达方面有显著提升\",{\"1\":{\"704\":1}}],[\"推理型大模型\",{\"1\":{\"704\":1}}],[\"推理型模型\",{\"1\":{\"704\":1}}],[\"推理型\",{\"1\":{\"704\":3}}],[\"推理模式下\",{\"1\":{\"822\":1}}],[\"推理模式优化\",{\"1\":{\"688\":1}}],[\"推理模式\",{\"1\":{\"688\":1,\"821\":1}}],[\"推理任务\",{\"1\":{\"575\":1}}],[\"推理任务仍存在幻觉\",{\"1\":{\"550\":1}}],[\"推理效率的核心目标\",{\"1\":{\"547\":1}}],[\"推理即编程\",{\"1\":{\"531\":1}}],[\"推理有限\",{\"1\":{\"530\":1}}],[\"推理与数学能力仍然有限\",{\"1\":{\"530\":1}}],[\"推理成本是不得不要考虑的一个因素\",{\"1\":{\"482\":1}}],[\"推理时可以用硬采样\",{\"1\":{\"795\":1}}],[\"推理时的常规流程\",{\"1\":{\"544\":1}}],[\"推理时\",{\"1\":{\"309\":1}}],[\"推理速度慢\",{\"1\":{\"260\":1,\"261\":1}}],[\"推理等\",{\"1\":{\"239\":1}}],[\"推理优先\",{\"1\":{\"237\":1}}],[\"推理阶段计算所有图像和文本表示\",{\"1\":{\"267\":1}}],[\"推理阶段\",{\"1\":{\"66\":1}}],[\"推理或训练分支\",{\"1\":{\"40\":1}}],[\"推理几何结构\",{\"1\":{\"28\":1}}],[\"推理几何形态支持该交互\",{\"1\":{\"28\":1}}],[\"推理除了当前交互以外\",{\"1\":{\"28\":1}}],[\"推理\",{\"0\":{\"300\":1},\"1\":{\"26\":1,\"500\":1,\"758\":1,\"817\":1}}],[\"推理的交互描述被\",{\"1\":{\"13\":1}}],[\"推理潜在意图\",{\"1\":{\"6\":1}}],[\"n=512\",{\"1\":{\"811\":1}}],[\"n=序列长度\",{\"1\":{\"272\":1}}],[\"nrow=8\",{\"1\":{\"848\":1}}],[\"nrow=5\",{\"1\":{\"840\":1}}],[\"nr\",{\"1\":{\"761\":1,\"762\":1}}],[\"n3\",{\"1\":{\"761\":1}}],[\"n2\",{\"1\":{\"761\":2,\"762\":1}}],[\"n1\",{\"1\":{\"761\":2,\"762\":1}}],[\"nbatches\",{\"1\":{\"632\":3}}],[\"n个解码器层\",{\"1\":{\"631\":1}}],[\"nvidia\",{\"1\":{\"561\":1,\"774\":1}}],[\"nfinal\",{\"1\":{\"544\":1}}],[\"ninput\",{\"1\":{\"541\":1}}],[\"ngo\",{\"1\":{\"536\":1,\"539\":1}}],[\"n维\",{\"1\":{\"487\":2}}],[\"ntoken\",{\"1\":{\"476\":2,\"478\":2}}],[\"ntransposed\",{\"1\":{\"426\":1}}],[\"nh\",{\"1\":{\"463\":6}}],[\"n阶张量的排列规律如下图所示\",{\"1\":{\"428\":1}}],[\"n为序列长度\",{\"1\":{\"322\":1}}],[\"nc\",{\"1\":{\"255\":3,\"367\":3}}],[\"ncrops\",{\"1\":{\"186\":5}}],[\"nce\",{\"1\":{\"175\":1,\"248\":5}}],[\"ndim\",{\"1\":{\"689\":4}}],[\"ndarray或variable\",{\"1\":{\"690\":1}}],[\"ndarray混合运算\",{\"1\":{\"690\":1}}],[\"ndarray\",{\"1\":{\"639\":1,\"673\":1,\"686\":1,\"689\":1,\"690\":1}}],[\"nd\",{\"1\":{\"170\":1}}],[\"n+1\",{\"1\":{\"160\":1,\"161\":3,\"295\":2,\"804\":3}}],[\"null\",{\"1\":{\"594\":1,\"815\":5,\"816\":5}}],[\"nucleus\",{\"1\":{\"133\":2,\"143\":2,\"313\":3}}],[\"numerically\",{\"1\":{\"814\":1}}],[\"numerical\",{\"1\":{\"652\":1,\"676\":2}}],[\"numpy\",{\"0\":{\"331\":1},\"1\":{\"83\":4,\"107\":1,\"300\":2,\"302\":4,\"304\":3,\"317\":2,\"332\":2,\"333\":1,\"372\":1,\"398\":1,\"399\":1,\"423\":3,\"431\":1,\"463\":2,\"638\":1,\"681\":1,\"696\":2,\"697\":2,\"840\":3}}],[\"nums\",{\"1\":{\"82\":2}}],[\"num个点云样本\",{\"1\":{\"29\":1}}],[\"num参数\",{\"1\":{\"29\":1}}],[\"number\",{\"1\":{\"29\":6,\"58\":6,\"92\":2,\"186\":8,\"254\":1,\"316\":1,\"632\":1,\"821\":1,\"840\":3}}],[\"num\",{\"1\":{\"29\":4,\"40\":1,\"41\":6,\"58\":2,\"59\":11,\"73\":3,\"80\":7,\"81\":1,\"82\":11,\"83\":4,\"93\":3,\"96\":2,\"98\":1,\"101\":8,\"142\":1,\"143\":5,\"145\":1,\"147\":1,\"160\":2,\"169\":8,\"170\":18,\"186\":2,\"252\":1,\"254\":3,\"272\":22,\"274\":16,\"277\":2,\"290\":2,\"302\":2,\"304\":2,\"312\":1,\"313\":6,\"316\":5,\"318\":5,\"319\":9,\"320\":11,\"321\":2,\"322\":24,\"323\":18,\"327\":4,\"332\":1,\"403\":4,\"463\":2,\"591\":25,\"593\":1,\"600\":1,\"603\":5,\"605\":5,\"615\":3,\"617\":6,\"618\":9,\"676\":2,\"793\":11,\"794\":5,\"798\":4,\"801\":22,\"802\":4,\"803\":1,\"804\":4,\"814\":25,\"815\":3,\"817\":9,\"818\":2,\"820\":1,\"821\":23,\"822\":6,\"848\":2,\"860\":1,\"861\":1,\"885\":12,\"886\":7}}],[\"num=12\",{\"1\":{\"28\":1}}],[\"nz\",{\"1\":{\"93\":1}}],[\"ny\",{\"1\":{\"93\":1}}],[\"nxk\",{\"1\":{\"255\":1}}],[\"nx1\",{\"1\":{\"255\":1}}],[\"nxc\",{\"1\":{\"255\":2}}],[\"nx\",{\"1\":{\"93\":1,\"255\":1}}],[\"neighbor\",{\"1\":{\"885\":1}}],[\"neighborhood\",{\"1\":{\"314\":1}}],[\"neox\",{\"1\":{\"552\":1}}],[\"neox方案\",{\"1\":{\"548\":1}}],[\"neural\",{\"1\":{\"528\":1,\"621\":1,\"622\":1,\"703\":1,\"843\":1}}],[\"ner\",{\"1\":{\"508\":1,\"617\":1}}],[\"nearest\",{\"0\":{\"389\":1},\"1\":{\"388\":2,\"463\":2,\"885\":1}}],[\"needed\",{\"1\":{\"302\":2,\"304\":2}}],[\"need\",{\"0\":{\"541\":1},\"1\":{\"272\":3}}],[\"nepochs\",{\"1\":{\"186\":2}}],[\"negativity\",{\"1\":{\"729\":1}}],[\"negatives\",{\"1\":{\"310\":2,\"471\":1}}],[\"negative\",{\"0\":{\"740\":1},\"1\":{\"78\":6,\"145\":8,\"147\":2,\"156\":1,\"162\":2,\"248\":1,\"254\":1,\"255\":1,\"265\":4,\"268\":2,\"275\":1,\"278\":2,\"471\":2,\"741\":1}}],[\"neg\",{\"1\":{\"145\":22,\"147\":22,\"162\":22,\"255\":2,\"278\":31,\"311\":20,\"690\":5,\"815\":2,\"820\":2}}],[\"next取出索引0或者1下标对应的值即可知道我们是否预测正确\",{\"1\":{\"581\":1}}],[\"next=false\",{\"1\":{\"579\":1}}],[\"next=true\",{\"1\":{\"579\":1}}],[\"next\",{\"0\":{\"573\":1},\"1\":{\"142\":1,\"295\":1,\"312\":1,\"544\":6,\"564\":1,\"571\":1,\"579\":2,\"580\":2,\"581\":2,\"594\":1,\"612\":5,\"848\":1,\"857\":1}}],[\"news数据集已开源以促进后续研究\",{\"1\":{\"569\":1}}],[\"news\",{\"1\":{\"559\":1,\"560\":1,\"561\":1,\"565\":1,\"567\":1}}],[\"new\",{\"0\":{\"378\":1},\"1\":{\"92\":46,\"96\":16,\"100\":9,\"170\":8,\"293\":2,\"312\":2,\"361\":1,\"362\":1,\"378\":2,\"541\":18,\"544\":2,\"605\":4}}],[\"net\",{\"1\":{\"98\":1,\"103\":1,\"105\":2,\"107\":3,\"112\":2,\"793\":2,\"886\":2}}],[\"networks等方法异曲同工\",{\"1\":{\"531\":1}}],[\"networks\",{\"1\":{\"321\":1,\"514\":1,\"531\":1,\"843\":1}}],[\"network\",{\"1\":{\"48\":1,\"107\":1,\"272\":1,\"521\":1,\"622\":1}}],[\"netpoll\",{\"1\":{\"2\":1}}],[\"nli和adversarial推理任务仍具挑战性\",{\"1\":{\"529\":1}}],[\"nli\",{\"1\":{\"515\":1,\"527\":1,\"575\":1}}],[\"nltk\",{\"1\":{\"478\":1}}],[\"nlvr2datamodule\",{\"1\":{\"274\":1}}],[\"nlvr2\",{\"1\":{\"260\":1,\"274\":1,\"275\":2}}],[\"nlp模型的第一层一般都是词嵌入层\",{\"1\":{\"878\":1}}],[\"nlp半监督学习\",{\"1\":{\"508\":1}}],[\"nlp\",{\"1\":{\"173\":1,\"232\":1,\"247\":1,\"299\":1,\"520\":1,\"527\":1,\"531\":1,\"536\":2,\"537\":1,\"538\":2,\"539\":1,\"571\":3,\"577\":3,\"704\":1,\"766\":1,\"778\":1,\"788\":1,\"843\":1}}],[\"nl=token数\",{\"1\":{\"40\":1}}],[\"nl\",{\"1\":{\"40\":4}}],[\"noise\",{\"1\":{\"248\":2,\"819\":3,\"840\":1}}],[\"noisy\",{\"1\":{\"104\":1}}],[\"noun\",{\"1\":{\"234\":1}}],[\"non\",{\"1\":{\"159\":1,\"579\":7,\"729\":1}}],[\"none\",{\"1\":{\"40\":1,\"43\":1,\"75\":1,\"76\":6,\"83\":2,\"92\":3,\"93\":1,\"96\":6,\"100\":2,\"101\":1,\"108\":2,\"109\":1,\"142\":3,\"145\":3,\"147\":1,\"160\":3,\"162\":1,\"163\":8,\"170\":3,\"252\":3,\"254\":1,\"256\":1,\"257\":1,\"272\":17,\"274\":4,\"277\":9,\"289\":2,\"293\":2,\"295\":3,\"302\":3,\"303\":2,\"304\":4,\"311\":4,\"312\":10,\"316\":2,\"318\":1,\"327\":1,\"346\":1,\"355\":1,\"366\":2,\"372\":1,\"388\":2,\"398\":2,\"399\":1,\"463\":1,\"476\":2,\"477\":2,\"478\":4,\"541\":1,\"544\":14,\"578\":3,\"591\":4,\"594\":4,\"597\":2,\"603\":2,\"605\":1,\"612\":2,\"615\":2,\"617\":2,\"618\":7,\"632\":4,\"659\":1,\"665\":1,\"668\":1,\"672\":1,\"673\":1,\"682\":2,\"683\":1,\"684\":3,\"686\":6,\"687\":1,\"688\":6,\"689\":5,\"696\":4,\"794\":4,\"798\":2,\"801\":1,\"804\":3,\"814\":3,\"816\":2,\"817\":6,\"820\":3,\"821\":3,\"822\":1}}],[\"no\",{\"0\":{\"365\":1},\"1\":{\"145\":2,\"147\":2,\"161\":1,\"162\":1,\"163\":1,\"170\":1,\"173\":1,\"178\":1,\"186\":2,\"255\":2,\"256\":1,\"257\":1,\"272\":2,\"273\":3,\"274\":10,\"278\":2,\"300\":2,\"302\":2,\"303\":1,\"304\":3,\"311\":1,\"538\":1,\"541\":1,\"544\":1,\"688\":3,\"691\":2,\"803\":1,\"817\":1,\"820\":1,\"821\":1,\"848\":6,\"857\":2,\"861\":1,\"886\":3}}],[\"nohup\",{\"1\":{\"83\":2}}],[\"notebook中直接显示图像\",{\"1\":{\"696\":1}}],[\"notes\",{\"1\":{\"46\":1}}],[\"notimplementederror\",{\"1\":{\"68\":1,\"274\":2,\"643\":1,\"660\":1,\"681\":2,\"802\":1}}],[\"not\",{\"1\":{\"68\":2,\"75\":1,\"80\":1,\"92\":3,\"96\":2,\"100\":1,\"143\":1,\"162\":1,\"163\":6,\"169\":2,\"170\":1,\"186\":1,\"254\":1,\"272\":7,\"274\":2,\"289\":1,\"293\":2,\"295\":1,\"302\":3,\"303\":2,\"304\":5,\"311\":3,\"312\":6,\"313\":1,\"316\":2,\"327\":2,\"353\":1,\"463\":1,\"477\":1,\"478\":2,\"544\":4,\"577\":2,\"578\":1,\"579\":1,\"594\":1,\"603\":1,\"605\":1,\"612\":2,\"615\":2,\"617\":2,\"618\":4,\"632\":3,\"665\":1,\"668\":1,\"673\":3,\"681\":1,\"682\":2,\"684\":2,\"686\":7,\"688\":5,\"689\":3,\"696\":5,\"794\":3,\"801\":1,\"803\":1,\"804\":2,\"814\":2,\"815\":2,\"821\":3,\"822\":1,\"885\":1,\"886\":1,\"889\":1}}],[\"norm=1\",{\"1\":{\"581\":1}}],[\"norm层之后同样是多头注意力层\",{\"1\":{\"321\":1}}],[\"normemavectorquantizer\",{\"1\":{\"170\":2}}],[\"normalization和relu激活函数\",{\"1\":{\"382\":1}}],[\"normalization\",{\"0\":{\"392\":1,\"393\":1},\"1\":{\"178\":1,\"272\":1,\"321\":1,\"548\":1,\"622\":1,\"704\":1,\"729\":1,\"821\":3}}],[\"normalize=false\",{\"1\":{\"840\":1}}],[\"normalize=true\",{\"1\":{\"840\":2}}],[\"normalized\",{\"1\":{\"170\":6}}],[\"normalize\",{\"1\":{\"29\":4,\"58\":2,\"68\":1,\"83\":2,\"145\":6,\"146\":2,\"147\":6,\"160\":2,\"161\":4,\"186\":5,\"252\":3,\"254\":1,\"255\":2,\"299\":2,\"309\":2,\"317\":2,\"463\":1,\"605\":1,\"802\":3,\"822\":1,\"840\":2}}],[\"normal\",{\"0\":{\"747\":1,\"751\":1},\"1\":{\"93\":6,\"96\":5,\"114\":1,\"272\":2,\"319\":1,\"320\":2,\"323\":2,\"746\":1,\"747\":1,\"750\":1,\"840\":1,\"853\":1}}],[\"norm3\",{\"1\":{\"76\":1}}],[\"norm\",{\"1\":{\"72\":3,\"74\":3,\"92\":3,\"93\":3,\"96\":3,\"100\":2,\"108\":1,\"160\":2,\"170\":1,\"179\":1,\"186\":3,\"272\":11,\"276\":1,\"277\":8,\"292\":1,\"295\":1,\"300\":2,\"302\":2,\"304\":2,\"318\":6,\"320\":1,\"321\":3,\"323\":7,\"581\":1,\"597\":1,\"599\":1,\"606\":1,\"609\":1,\"626\":2,\"628\":2,\"631\":2,\"803\":1,\"804\":1,\"814\":5,\"815\":1,\"817\":1,\"820\":1,\"821\":1}}],[\"norm2\",{\"1\":{\"36\":1,\"73\":2,\"74\":1,\"76\":1,\"272\":8,\"321\":2}}],[\"norm1\",{\"1\":{\"36\":1,\"73\":2,\"76\":1,\"272\":2,\"321\":2}}],[\"nsp任务\",{\"1\":{\"594\":1}}],[\"nsp任务非必要\",{\"1\":{\"567\":1}}],[\"nsp\",{\"1\":{\"558\":1,\"559\":2,\"560\":4,\"562\":1,\"580\":6,\"581\":2,\"582\":1,\"594\":1}}],[\"nsample=none\",{\"1\":{\"93\":1}}],[\"nsample=64\",{\"1\":{\"93\":1}}],[\"nsample=32\",{\"1\":{\"93\":1,\"101\":4}}],[\"nsample\",{\"1\":{\"92\":23,\"96\":4}}],[\"ns\",{\"1\":{\"40\":5,\"105\":1}}],[\"nphysically\",{\"1\":{\"426\":1}}],[\"npoint=64\",{\"1\":{\"101\":1}}],[\"npoint=256\",{\"1\":{\"101\":1}}],[\"npoint=16\",{\"1\":{\"101\":1}}],[\"npoint=1024\",{\"1\":{\"101\":1}}],[\"npoint=128\",{\"1\":{\"93\":1}}],[\"npoint=none\",{\"1\":{\"93\":1}}],[\"npoint=512\",{\"1\":{\"93\":1}}],[\"npoint\",{\"1\":{\"46\":2,\"59\":2,\"70\":2,\"92\":35,\"96\":4}}],[\"np\",{\"0\":{\"332\":1,\"333\":1},\"1\":{\"40\":1,\"68\":5,\"82\":15,\"83\":15,\"107\":2,\"186\":3,\"299\":5,\"300\":1,\"302\":6,\"303\":1,\"304\":8,\"332\":3,\"333\":9,\"372\":1,\"398\":5,\"399\":3,\"423\":2,\"638\":3,\"647\":2,\"662\":1,\"672\":1,\"673\":1,\"675\":4,\"676\":2,\"682\":1,\"684\":2,\"685\":1,\"686\":2,\"688\":6,\"689\":8,\"690\":6,\"692\":6,\"696\":6,\"697\":11,\"801\":1,\"820\":1,\"840\":6}}],[\"n\",{\"1\":{\"30\":1,\"32\":2,\"35\":1,\"36\":2,\"40\":1,\"41\":10,\"43\":6,\"45\":29,\"46\":21,\"59\":40,\"64\":2,\"70\":4,\"72\":1,\"74\":1,\"75\":1,\"76\":12,\"78\":2,\"80\":8,\"82\":3,\"83\":14,\"92\":30,\"96\":4,\"98\":4,\"100\":29,\"101\":7,\"107\":1,\"109\":5,\"111\":9,\"112\":3,\"145\":5,\"147\":5,\"161\":1,\"162\":4,\"169\":1,\"170\":24,\"186\":6,\"272\":9,\"299\":7,\"305\":1,\"322\":3,\"363\":1,\"364\":1,\"367\":2,\"375\":3,\"385\":1,\"388\":2,\"401\":2,\"410\":1,\"419\":4,\"426\":4,\"431\":1,\"435\":1,\"463\":3,\"467\":4,\"468\":4,\"469\":4,\"470\":4,\"471\":2,\"473\":1,\"491\":1,\"521\":1,\"552\":1,\"579\":3,\"580\":3,\"581\":1,\"584\":2,\"590\":7,\"591\":26,\"593\":1,\"620\":1,\"628\":3,\"631\":3,\"689\":2,\"696\":4,\"737\":1,\"762\":6,\"763\":1,\"772\":1,\"794\":4,\"798\":2,\"804\":7,\"811\":1,\"814\":2,\"815\":4,\"821\":11,\"822\":3,\"840\":4,\"853\":1,\"857\":2}}],[\"nn结果与moco\",{\"1\":{\"182\":1}}],[\"nn分类性能\",{\"1\":{\"181\":1}}],[\"nn\",{\"0\":{\"369\":1},\"1\":{\"30\":1,\"32\":1,\"33\":1,\"34\":11,\"35\":17,\"36\":15,\"41\":8,\"42\":4,\"44\":4,\"45\":12,\"46\":8,\"59\":31,\"70\":1,\"72\":1,\"73\":15,\"74\":1,\"75\":1,\"76\":2,\"78\":4,\"80\":1,\"92\":5,\"93\":8,\"96\":15,\"98\":6,\"100\":5,\"101\":5,\"107\":13,\"109\":7,\"110\":8,\"111\":8,\"142\":1,\"145\":9,\"146\":4,\"147\":9,\"160\":10,\"162\":1,\"169\":4,\"170\":3,\"173\":3,\"179\":1,\"186\":4,\"252\":1,\"254\":2,\"255\":2,\"272\":20,\"289\":3,\"290\":2,\"291\":1,\"292\":5,\"293\":2,\"295\":5,\"311\":1,\"312\":4,\"318\":5,\"319\":4,\"320\":6,\"321\":6,\"322\":5,\"323\":14,\"366\":1,\"388\":1,\"463\":3,\"467\":1,\"468\":1,\"469\":1,\"470\":1,\"471\":1,\"473\":1,\"544\":1,\"573\":1,\"580\":5,\"581\":3,\"584\":2,\"590\":8,\"591\":7,\"597\":5,\"599\":6,\"600\":2,\"601\":3,\"603\":2,\"605\":6,\"606\":3,\"607\":1,\"609\":2,\"610\":3,\"611\":2,\"614\":1,\"615\":1,\"617\":2,\"618\":2,\"623\":1,\"624\":2,\"626\":2,\"627\":1,\"628\":1,\"630\":1,\"631\":1,\"632\":3,\"793\":18,\"803\":3,\"804\":4,\"814\":6,\"821\":14,\"822\":8,\"840\":18,\"848\":25,\"852\":3,\"853\":6,\"859\":6,\"885\":9,\"886\":7}}],[\"nat\",{\"1\":{\"828\":1,\"831\":1,\"872\":1}}],[\"naturalquestions\",{\"1\":{\"549\":1}}],[\"natural\",{\"1\":{\"275\":1,\"301\":1,\"488\":1,\"522\":1,\"529\":1,\"536\":1}}],[\"nagative\",{\"1\":{\"516\":1}}],[\"nargs=\",{\"1\":{\"186\":2}}],[\"narrow\",{\"1\":{\"28\":2}}],[\"nangia\",{\"1\":{\"536\":1}}],[\"nanmean\",{\"1\":{\"82\":2}}],[\"nan\",{\"1\":{\"82\":3,\"473\":1,\"803\":1}}],[\"na\",{\"1\":{\"40\":1}}],[\"names=names\",{\"1\":{\"274\":1}}],[\"names\",{\"1\":{\"272\":1,\"274\":3,\"275\":1}}],[\"name=none\",{\"1\":{\"689\":1}}],[\"name=\",{\"1\":{\"83\":2,\"274\":1,\"593\":1,\"689\":2}}],[\"named\",{\"1\":{\"80\":2,\"327\":1}}],[\"name\",{\"1\":{\"29\":4,\"58\":2,\"68\":2,\"83\":1,\"274\":3,\"302\":8,\"304\":8,\"327\":4,\"341\":2,\"345\":2,\"346\":8,\"347\":1,\"351\":2,\"353\":2,\"366\":3,\"431\":5,\"541\":1,\"544\":1,\"577\":1,\"578\":2,\"593\":1,\"688\":4,\"689\":2,\"696\":14}}],[\"js散度就大\",{\"1\":{\"837\":1}}],[\"js散度小\",{\"1\":{\"837\":1}}],[\"js散度定义为\",{\"1\":{\"836\":1}}],[\"js散度的数学定义\",{\"0\":{\"836\":1}}],[\"js散度解决了这些问题\",{\"1\":{\"835\":1}}],[\"js散度是衡量两个概率分布差异的一个方法\",{\"1\":{\"834\":1}}],[\"js散度是什么\",{\"0\":{\"834\":1}}],[\"js散度\",{\"0\":{\"833\":1}}],[\"json\",{\"1\":{\"142\":2,\"145\":1,\"146\":1,\"147\":1,\"160\":1,\"316\":6,\"476\":6,\"478\":13,\"577\":4,\"578\":4,\"581\":1,\"593\":1}}],[\"jensen\",{\"0\":{\"833\":1},\"1\":{\"807\":2}}],[\"jet\",{\"1\":{\"697\":1}}],[\"jigsaw\",{\"1\":{\"786\":1}}],[\"jitter\",{\"1\":{\"186\":4}}],[\"jit\",{\"1\":{\"169\":1,\"170\":1}}],[\"jx\",{\"1\":{\"327\":1}}],[\"javascript\",{\"1\":{\"714\":1}}],[\"javaer\",{\"1\":{\"2\":1}}],[\"jarvis\",{\"1\":{\"708\":1}}],[\"jaques\",{\"1\":{\"536\":1}}],[\"jaccard\",{\"0\":{\"469\":1},\"1\":{\"469\":7}}],[\"jax\",{\"1\":{\"327\":1}}],[\"jupyter\",{\"1\":{\"696\":1}}],[\"judge\",{\"1\":{\"236\":1}}],[\"just\",{\"1\":{\"28\":1,\"59\":1}}],[\"jpeg\",{\"1\":{\"302\":1,\"304\":1}}],[\"jp\",{\"1\":{\"202\":1}}],[\"jpg\",{\"1\":{\"28\":1,\"186\":1,\"302\":1,\"304\":1,\"316\":2}}],[\"jft\",{\"1\":{\"191\":1,\"305\":2,\"810\":1}}],[\"join\",{\"1\":{\"68\":3,\"83\":2,\"142\":1,\"302\":3,\"303\":1,\"304\":4,\"316\":3,\"463\":1,\"476\":5,\"477\":2,\"478\":6,\"578\":2,\"696\":2}}],[\"joint\",{\"0\":{\"750\":1},\"1\":{\"36\":2,\"41\":4,\"45\":2,\"59\":7,\"820\":1}}],[\"jra模块\",{\"1\":{\"54\":1,\"56\":1}}],[\"jra\",{\"1\":{\"48\":1,\"59\":1}}],[\"j\",{\"1\":{\"35\":5,\"59\":13,\"96\":3,\"302\":2,\"304\":2,\"379\":7,\"399\":1,\"423\":2,\"427\":1,\"463\":3,\"581\":5,\"589\":2,\"590\":7,\"591\":14,\"801\":3,\"822\":2,\"848\":3,\"886\":3}}],[\"ubuntu安装\",{\"1\":{\"696\":1}}],[\"ulmfit\",{\"1\":{\"531\":1,\"577\":1}}],[\"utf\",{\"1\":{\"476\":4,\"477\":1,\"478\":7,\"548\":1,\"577\":3,\"578\":1}}],[\"utm\",{\"1\":{\"140\":1}}],[\"utility\",{\"1\":{\"83\":4}}],[\"util\",{\"1\":{\"83\":1}}],[\"utils\",{\"1\":{\"82\":1,\"83\":1,\"186\":12,\"252\":1,\"274\":1,\"275\":1,\"316\":3,\"317\":2,\"399\":2,\"403\":1,\"581\":1,\"691\":1,\"803\":2,\"840\":2,\"848\":2,\"852\":1}}],[\"u\",{\"1\":{\"83\":4,\"821\":1}}],[\"upon\",{\"1\":{\"544\":1}}],[\"upwork\",{\"1\":{\"537\":1}}],[\"updating\",{\"1\":{\"254\":1,\"257\":1}}],[\"update\",{\"0\":{\"256\":1},\"1\":{\"145\":1,\"147\":1,\"161\":1,\"169\":1,\"170\":1,\"186\":2,\"254\":1,\"255\":2,\"256\":2,\"274\":1,\"275\":8,\"278\":1,\"401\":1,\"476\":2,\"478\":1,\"544\":2}}],[\"up\",{\"1\":{\"35\":6,\"40\":1,\"42\":1,\"46\":6,\"59\":6,\"70\":11,\"76\":7,\"147\":1,\"187\":1,\"274\":1,\"488\":1}}],[\"upsample\",{\"1\":{\"35\":1,\"59\":1,\"100\":1}}],[\"umbrella\",{\"1\":{\"29\":1}}],[\"usage\",{\"1\":{\"170\":8}}],[\"usage=true\",{\"1\":{\"28\":1,\"170\":2}}],[\"using\",{\"1\":{\"28\":6,\"31\":6,\"632\":1,\"688\":2,\"691\":2}}],[\"users\",{\"1\":{\"593\":1}}],[\"user\",{\"1\":{\"353\":1,\"432\":1,\"434\":3,\"537\":1}}],[\"used\",{\"1\":{\"321\":1,\"594\":1}}],[\"use\",{\"1\":{\"28\":1,\"169\":1,\"170\":6,\"186\":3,\"255\":1,\"272\":4,\"275\":1,\"278\":1,\"302\":1,\"304\":1,\"309\":1,\"312\":5,\"313\":2,\"322\":1,\"544\":7,\"817\":2,\"840\":1}}],[\"unusual\",{\"1\":{\"605\":1}}],[\"unknown\",{\"1\":{\"848\":1}}],[\"unk\",{\"1\":{\"477\":1,\"478\":7,\"578\":5,\"579\":1,\"594\":2}}],[\"unter和pixel\",{\"1\":{\"282\":1}}],[\"undo\",{\"1\":{\"255\":1}}],[\"underfitting\",{\"1\":{\"522\":1}}],[\"underlying\",{\"1\":{\"516\":1}}],[\"understanding\",{\"1\":{\"119\":2,\"134\":1,\"505\":1}}],[\"under\",{\"1\":{\"22\":1,\"82\":3,\"104\":1}}],[\"uncased\",{\"1\":{\"147\":2}}],[\"unittest\",{\"1\":{\"675\":2,\"676\":1}}],[\"uniter\",{\"1\":{\"295\":1,\"789\":1}}],[\"unicode\",{\"1\":{\"521\":2,\"599\":1,\"609\":1}}],[\"uniform\",{\"0\":{\"371\":1},\"1\":{\"371\":1,\"773\":1,\"794\":3,\"798\":3,\"801\":3,\"815\":1,\"821\":3,\"885\":1}}],[\"unified\",{\"1\":{\"119\":2,\"134\":1,\"259\":2,\"270\":1}}],[\"uni\",{\"1\":{\"310\":2}}],[\"unique\",{\"0\":{\"372\":1},\"1\":{\"186\":2,\"372\":6,\"399\":1}}],[\"unilm\",{\"1\":{\"164\":1,\"171\":1,\"259\":1,\"269\":1,\"270\":1,\"764\":1}}],[\"unimodal\",{\"1\":{\"126\":1,\"127\":1}}],[\"union\",{\"0\":{\"469\":1},\"1\":{\"22\":1,\"82\":6,\"469\":5,\"544\":2}}],[\"unordered\",{\"1\":{\"104\":1,\"115\":1}}],[\"unbuffered\",{\"1\":{\"83\":1}}],[\"un\",{\"1\":{\"75\":1}}],[\"ungroup\",{\"1\":{\"75\":2}}],[\"ungrouping阶段\",{\"1\":{\"75\":1}}],[\"ungrouping\",{\"0\":{\"74\":1},\"1\":{\"71\":1,\"75\":3}}],[\"unshuffle\",{\"1\":{\"255\":3}}],[\"unsupervised\",{\"1\":{\"240\":2,\"518\":1,\"519\":1}}],[\"unsqueeze\",{\"1\":{\"70\":2,\"75\":1,\"76\":3,\"82\":2,\"83\":1,\"170\":1,\"255\":1,\"272\":1,\"310\":4,\"463\":3,\"541\":2,\"544\":1,\"580\":1,\"584\":1,\"590\":6,\"591\":5,\"597\":1,\"602\":2,\"632\":1,\"804\":1,\"820\":1,\"886\":1}}],[\"unseen\",{\"1\":{\"20\":2,\"23\":5,\"24\":1,\"65\":1,\"82\":1}}],[\"=原图尺寸\",{\"1\":{\"821\":1}}],[\"=w\",{\"1\":{\"821\":1}}],[\"=50000\",{\"1\":{\"697\":1}}],[\"=10000\",{\"1\":{\"697\":1}}],[\"=>\",{\"1\":{\"632\":1}}],[\"=self\",{\"1\":{\"30\":1}}],[\"======\",{\"1\":{\"272\":4,\"277\":34}}],[\"==============\",{\"1\":{\"310\":1,\"311\":1}}],[\"===================\",{\"1\":{\"310\":1,\"311\":1}}],[\"=====================\",{\"1\":{\"147\":12,\"186\":14}}],[\"=============================\",{\"1\":{\"885\":8}}],[\"=================================\",{\"1\":{\"162\":3}}],[\"========================\",{\"1\":{\"163\":1,\"312\":1}}],[\"=======================\",{\"1\":{\"147\":6}}],[\"=================\",{\"1\":{\"163\":1,\"312\":1}}],[\"===============\",{\"1\":{\"160\":4}}],[\"==========\",{\"1\":{\"161\":4,\"169\":4,\"277\":4}}],[\"=====\",{\"1\":{\"163\":4,\"590\":6}}],[\"==\",{\"1\":{\"29\":5,\"40\":1,\"58\":4,\"68\":3,\"82\":1,\"83\":2,\"92\":1,\"100\":1,\"142\":1,\"147\":1,\"163\":2,\"169\":1,\"170\":2,\"186\":2,\"257\":1,\"272\":4,\"274\":5,\"275\":1,\"291\":1,\"302\":1,\"304\":1,\"311\":1,\"312\":2,\"470\":1,\"477\":1,\"478\":1,\"541\":1,\"544\":2,\"577\":1,\"578\":2,\"581\":1,\"596\":1,\"599\":1,\"603\":1,\"609\":1,\"616\":1,\"617\":1,\"620\":1,\"632\":2,\"801\":2,\"802\":2,\"815\":3,\"816\":1,\"817\":1,\"820\":1,\"821\":2,\"822\":1,\"840\":1,\"848\":1,\"886\":1}}],[\"=\",{\"1\":{\"28\":15,\"29\":47,\"30\":7,\"32\":18,\"33\":3,\"34\":9,\"35\":21,\"36\":19,\"40\":20,\"41\":24,\"42\":1,\"43\":7,\"44\":1,\"45\":36,\"46\":18,\"58\":37,\"59\":94,\"63\":1,\"68\":25,\"70\":15,\"72\":4,\"73\":8,\"74\":5,\"75\":4,\"76\":27,\"78\":16,\"80\":15,\"81\":10,\"82\":35,\"83\":45,\"92\":63,\"93\":24,\"96\":53,\"98\":2,\"100\":24,\"101\":26,\"105\":2,\"107\":25,\"108\":5,\"109\":30,\"110\":13,\"111\":20,\"116\":1,\"142\":32,\"143\":12,\"145\":81,\"146\":28,\"147\":77,\"159\":7,\"160\":28,\"161\":23,\"162\":41,\"163\":44,\"169\":18,\"170\":57,\"185\":4,\"186\":59,\"252\":12,\"254\":12,\"255\":11,\"256\":1,\"257\":6,\"272\":92,\"274\":61,\"275\":4,\"276\":27,\"277\":71,\"278\":38,\"282\":3,\"289\":8,\"290\":3,\"291\":2,\"292\":7,\"293\":16,\"295\":22,\"299\":9,\"300\":10,\"302\":40,\"303\":9,\"304\":46,\"309\":10,\"310\":8,\"311\":40,\"312\":56,\"313\":10,\"316\":25,\"317\":6,\"318\":11,\"319\":12,\"320\":15,\"321\":19,\"322\":16,\"323\":28,\"324\":2,\"327\":5,\"332\":1,\"333\":7,\"336\":1,\"340\":2,\"341\":2,\"342\":1,\"343\":1,\"344\":1,\"345\":1,\"348\":1,\"349\":2,\"350\":1,\"351\":2,\"352\":4,\"353\":2,\"355\":3,\"359\":1,\"360\":1,\"361\":4,\"362\":1,\"363\":3,\"364\":6,\"366\":1,\"369\":5,\"370\":7,\"372\":6,\"373\":4,\"374\":4,\"375\":1,\"376\":1,\"377\":4,\"378\":2,\"387\":5,\"392\":1,\"393\":3,\"395\":3,\"396\":1,\"398\":3,\"399\":3,\"401\":2,\"403\":3,\"421\":1,\"423\":4,\"425\":2,\"426\":5,\"427\":5,\"455\":1,\"463\":29,\"467\":7,\"468\":12,\"469\":10,\"470\":17,\"471\":16,\"473\":15,\"476\":42,\"477\":19,\"478\":55,\"481\":3,\"521\":2,\"537\":2,\"541\":14,\"544\":60,\"562\":1,\"571\":1,\"577\":11,\"578\":30,\"579\":22,\"580\":21,\"581\":23,\"582\":4,\"584\":6,\"590\":32,\"591\":45,\"594\":14,\"596\":7,\"597\":16,\"599\":17,\"600\":2,\"601\":5,\"602\":10,\"603\":14,\"605\":25,\"606\":6,\"607\":4,\"609\":7,\"610\":5,\"611\":4,\"612\":11,\"614\":9,\"615\":17,\"616\":2,\"617\":16,\"618\":17,\"623\":5,\"624\":1,\"626\":2,\"627\":6,\"628\":3,\"630\":9,\"631\":4,\"632\":15,\"637\":1,\"638\":3,\"643\":3,\"647\":7,\"652\":4,\"656\":1,\"659\":2,\"660\":5,\"661\":2,\"662\":4,\"664\":1,\"665\":3,\"668\":4,\"672\":1,\"673\":1,\"675\":4,\"676\":3,\"681\":6,\"682\":7,\"683\":1,\"684\":11,\"685\":5,\"686\":22,\"687\":12,\"688\":30,\"689\":13,\"690\":44,\"691\":4,\"692\":13,\"696\":28,\"697\":44,\"725\":2,\"727\":1,\"731\":1,\"754\":1,\"757\":2,\"762\":3,\"763\":2,\"774\":2,\"793\":27,\"794\":20,\"795\":1,\"796\":6,\"798\":5,\"799\":1,\"801\":25,\"802\":7,\"803\":13,\"804\":25,\"807\":1,\"809\":1,\"814\":75,\"815\":36,\"816\":8,\"817\":33,\"818\":4,\"820\":20,\"821\":86,\"822\":69,\"828\":2,\"830\":1,\"831\":3,\"840\":28,\"848\":88,\"853\":14,\"854\":2,\"855\":3,\"856\":8,\"857\":8,\"859\":15,\"860\":8,\"861\":5,\"881\":1,\"885\":44,\"886\":34}}],[\"开区间\",{\"1\":{\"728\":1}}],[\"开发也有质的差异\",{\"1\":{\"716\":1}}],[\"开发在整体思路上有着较大的不同\",{\"1\":{\"716\":1}}],[\"开发大模型相关应用\",{\"1\":{\"716\":1}}],[\"开发者平台\",{\"1\":{\"715\":1}}],[\"开发者可以轻松地构建和定制\",{\"1\":{\"714\":1}}],[\"开发\",{\"1\":{\"704\":1,\"716\":2}}],[\"开发数据1k\",{\"1\":{\"593\":1}}],[\"开发具备\",{\"1\":{\"539\":1}}],[\"开发和维护的一个\",{\"1\":{\"395\":1}}],[\"开放接口控制\",{\"1\":{\"539\":1}}],[\"开放型和封闭型\",{\"1\":{\"537\":1}}],[\"开放任务\",{\"1\":{\"537\":1}}],[\"开箱即用\",{\"1\":{\"395\":1}}],[\"开销大\",{\"1\":{\"364\":1}}],[\"开启\",{\"1\":{\"276\":1}}],[\"开头提到过\",{\"1\":{\"247\":1}}],[\"开始从头训练\",{\"1\":{\"885\":1,\"886\":1}}],[\"开始一步一步谈起\",{\"1\":{\"878\":1}}],[\"开始的预训练\",{\"0\":{\"576\":1}}],[\"开始之前\",{\"1\":{\"481\":1}}],[\"开始数\",{\"1\":{\"425\":1}}],[\"开始顺序排列\",{\"1\":{\"421\":1}}],[\"开始调用\",{\"1\":{\"345\":1}}],[\"开始\",{\"1\":{\"344\":1,\"514\":1,\"576\":1,\"717\":1,\"820\":1}}],[\"开始生成句子\",{\"1\":{\"312\":1}}],[\"开始输出回答\",{\"1\":{\"235\":1}}],[\"开始充分利用动量编码器提供的软标签来训练\",{\"1\":{\"159\":1}}],[\"开壶盖\",{\"1\":{\"28\":1}}],[\"开源了\",{\"1\":{\"704\":1}}],[\"开源的一组参数规模从\",{\"1\":{\"704\":1}}],[\"开源贡献\",{\"1\":{\"567\":1}}],[\"开源项目\",{\"0\":{\"329\":1}}],[\"开源模型进展\",{\"1\":{\"552\":1}}],[\"开源模型在视觉\",{\"1\":{\"219\":1}}],[\"开源模型与商业专有模型\",{\"1\":{\"216\":1}}],[\"开源模型\",{\"1\":{\"192\":1}}],[\"开源网络库\",{\"1\":{\"2\":1}}],[\"开源框架\",{\"1\":{\"2\":1}}],[\"wgan\",{\"0\":{\"888\":1},\"1\":{\"888\":1}}],[\"wgan的成功\",{\"1\":{\"841\":1}}],[\"wget\",{\"1\":{\"593\":1}}],[\"w^2\",{\"1\":{\"801\":1}}],[\"wpe\",{\"1\":{\"544\":1}}],[\"wpa\",{\"1\":{\"285\":1}}],[\"wte\",{\"1\":{\"544\":1}}],[\"wmt\",{\"1\":{\"522\":1,\"537\":1}}],[\"w+∆w\",{\"1\":{\"487\":1}}],[\"wx\",{\"1\":{\"481\":1}}],[\"w>\",{\"1\":{\"476\":3,\"477\":2,\"478\":3}}],[\"w`代表输出特征图的宽和高\",{\"1\":{\"318\":1}}],[\"writer=none\",{\"1\":{\"803\":1}}],[\"writer=log\",{\"1\":{\"803\":1}}],[\"writer\",{\"1\":{\"803\":1}}],[\"write\",{\"1\":{\"316\":1,\"696\":2}}],[\"wrod\",{\"1\":{\"284\":1}}],[\"wraps\",{\"1\":{\"346\":3,\"347\":1,\"353\":3}}],[\"wrapper\",{\"1\":{\"341\":5,\"343\":4,\"344\":2,\"345\":3,\"346\":8,\"347\":2,\"353\":6}}],[\"wrap\",{\"1\":{\"68\":1}}],[\"wrapgrasp\",{\"1\":{\"29\":1,\"58\":1}}],[\"wukong\",{\"1\":{\"225\":1}}],[\"wd\",{\"1\":{\"186\":2,\"803\":2}}],[\"wake\",{\"1\":{\"872\":1}}],[\"way\",{\"1\":{\"541\":17}}],[\"warnings\",{\"1\":{\"304\":2}}],[\"warmup\",{\"1\":{\"159\":1,\"186\":11,\"774\":1}}],[\"walk\",{\"1\":{\"302\":1,\"304\":1}}],[\"wandb\",{\"1\":{\"276\":1}}],[\"want\",{\"1\":{\"83\":3}}],[\"water\",{\"1\":{\"157\":1}}],[\"wow\",{\"1\":{\"476\":1}}],[\"world\",{\"1\":{\"278\":5,\"311\":6,\"476\":1,\"477\":1}}],[\"word2idx\",{\"1\":{\"578\":14,\"579\":9,\"584\":1}}],[\"word2vec\",{\"1\":{\"248\":1,\"531\":1}}],[\"wordpunct\",{\"1\":{\"476\":1,\"477\":1,\"478\":2}}],[\"wordpiecetokenizer\",{\"1\":{\"578\":1}}],[\"wordpiece\",{\"1\":{\"263\":1}}],[\"word\",{\"1\":{\"274\":1,\"285\":3,\"311\":1,\"476\":10,\"478\":12,\"514\":1,\"522\":1,\"578\":17,\"579\":2,\"580\":4,\"597\":2}}],[\"words\",{\"1\":{\"142\":1,\"163\":2,\"305\":3,\"478\":5,\"597\":2}}],[\"worker\",{\"1\":{\"252\":1}}],[\"workers\",{\"1\":{\"186\":1,\"252\":1,\"274\":10}}],[\"workers=self\",{\"1\":{\"274\":6}}],[\"workers=args\",{\"1\":{\"186\":1,\"252\":1}}],[\"workers=\",{\"1\":{\"142\":1,\"145\":1,\"147\":1}}],[\"workers=8\",{\"1\":{\"80\":3}}],[\"work\",{\"0\":{\"121\":1,\"150\":1,\"248\":1,\"250\":1,\"261\":1}}],[\"would\",{\"1\":{\"70\":1}}],[\"wei\",{\"1\":{\"536\":1,\"552\":1}}],[\"weight=none\",{\"1\":{\"467\":1,\"468\":1,\"469\":1,\"470\":1,\"471\":1,\"473\":1}}],[\"weight=self\",{\"1\":{\"272\":1}}],[\"weighted\",{\"1\":{\"473\":5}}],[\"weightedrandomsampler\",{\"0\":{\"403\":1},\"1\":{\"403\":3}}],[\"weightedloss\",{\"1\":{\"163\":1}}],[\"weights=train\",{\"1\":{\"403\":1}}],[\"weights=w\",{\"1\":{\"377\":1}}],[\"weights=none\",{\"1\":{\"377\":1}}],[\"weights\",{\"1\":{\"145\":6,\"147\":6,\"162\":6,\"272\":1,\"278\":6,\"302\":2,\"304\":2,\"311\":4,\"323\":1,\"327\":5,\"377\":2,\"399\":3,\"403\":4,\"544\":3,\"580\":1,\"581\":1,\"602\":1,\"603\":1,\"610\":1}}],[\"weight\",{\"0\":{\"399\":1},\"1\":{\"80\":1,\"100\":4,\"142\":2,\"145\":2,\"147\":2,\"163\":1,\"169\":12,\"170\":5,\"186\":4,\"252\":2,\"272\":1,\"399\":8,\"428\":1,\"467\":3,\"468\":2,\"469\":2,\"470\":7,\"471\":4,\"473\":4,\"580\":9,\"581\":1,\"793\":3,\"794\":5,\"803\":2,\"814\":1,\"815\":8,\"821\":7,\"848\":3,\"885\":3,\"886\":4}}],[\"were\",{\"1\":{\"316\":1}}],[\"webquestions\",{\"1\":{\"529\":1}}],[\"webtext2\",{\"1\":{\"528\":1}}],[\"webtext的多样性和规模是关键\",{\"1\":{\"522\":1}}],[\"webtext训练集和测试集的困惑度同步下降\",{\"1\":{\"522\":1}}],[\"webtext\",{\"1\":{\"521\":4,\"524\":1}}],[\"web\",{\"1\":{\"305\":1}}],[\"weakref\",{\"1\":{\"687\":2,\"688\":1,\"696\":1}}],[\"weakly\",{\"1\":{\"305\":1}}],[\"wear\",{\"1\":{\"29\":1,\"58\":1,\"68\":1}}],[\"we\",{\"0\":{\"541\":1},\"1\":{\"78\":1,\"214\":2,\"539\":1,\"601\":1,\"603\":1,\"615\":1,\"632\":1}}],[\"w₂\",{\"1\":{\"74\":1}}],[\"winogender\",{\"1\":{\"536\":1,\"537\":1,\"538\":1,\"549\":1,\"551\":1}}],[\"winograd\",{\"1\":{\"522\":1}}],[\"windows\",{\"1\":{\"438\":1}}],[\"window\",{\"1\":{\"83\":4,\"802\":1}}],[\"wikitext2是wikitext\",{\"1\":{\"577\":1}}],[\"wikitext\",{\"1\":{\"522\":2,\"577\":15,\"581\":1}}],[\"wikipedia\",{\"1\":{\"521\":1,\"528\":1,\"560\":1,\"561\":1,\"565\":1,\"704\":1}}],[\"wikibkdatamodule\",{\"1\":{\"274\":1}}],[\"wikibk\",{\"1\":{\"274\":1}}],[\"will\",{\"1\":{\"478\":1}}],[\"wild\",{\"1\":{\"157\":2}}],[\"wightman\",{\"1\":{\"395\":1}}],[\"width=4\",{\"1\":{\"423\":1}}],[\"width=600\",{\"1\":{\"83\":1}}],[\"width\",{\"1\":{\"40\":1,\"142\":3,\"145\":7,\"146\":4,\"147\":6,\"160\":10,\"170\":1,\"272\":1,\"316\":1,\"423\":1,\"801\":5,\"804\":1,\"848\":6}}],[\"wise\",{\"1\":{\"30\":2,\"46\":1,\"59\":3,\"70\":2,\"427\":1,\"514\":1,\"802\":2}}],[\"without\",{\"0\":{\"542\":1},\"1\":{\"279\":2}}],[\"with\",{\"0\":{\"236\":1,\"543\":1},\"1\":{\"28\":4,\"37\":1,\"40\":1,\"68\":2,\"76\":3,\"83\":4,\"145\":2,\"147\":2,\"148\":2,\"161\":1,\"162\":1,\"163\":1,\"164\":2,\"170\":1,\"173\":1,\"178\":1,\"186\":1,\"214\":2,\"234\":1,\"255\":1,\"259\":2,\"270\":1,\"272\":4,\"275\":2,\"278\":4,\"300\":3,\"302\":2,\"304\":2,\"311\":1,\"316\":1,\"336\":2,\"369\":4,\"476\":3,\"478\":11,\"483\":2,\"533\":1,\"541\":1,\"544\":1,\"577\":3,\"578\":3,\"581\":1,\"594\":3,\"631\":1,\"688\":2,\"696\":2,\"803\":2,\"816\":1,\"817\":1,\"843\":2,\"848\":1,\"857\":2,\"861\":1,\"886\":3}}],[\"w\",{\"1\":{\"30\":3,\"34\":1,\"40\":4,\"41\":2,\"59\":4,\"145\":1,\"170\":7,\"252\":1,\"272\":6,\"276\":1,\"299\":5,\"309\":1,\"316\":1,\"318\":4,\"319\":1,\"320\":1,\"323\":1,\"370\":2,\"377\":1,\"388\":3,\"389\":2,\"390\":2,\"463\":5,\"471\":2,\"473\":1,\"476\":5,\"478\":5,\"487\":1,\"537\":1,\"577\":2,\"578\":1,\"590\":8,\"632\":4,\"696\":2,\"794\":9,\"798\":4,\"801\":9,\"802\":1,\"803\":1,\"804\":6,\"815\":1,\"821\":21,\"822\":3,\"846\":3,\"848\":2,\"885\":6,\"886\":7}}],[\"who\",{\"1\":{\"522\":1,\"539\":1}}],[\"whole\",{\"1\":{\"274\":1,\"285\":2}}],[\"when\",{\"1\":{\"815\":1}}],[\"whether\",{\"1\":{\"478\":1}}],[\"where\",{\"0\":{\"368\":1},\"1\":{\"70\":1,\"71\":1,\"170\":2,\"368\":1,\"438\":1,\"470\":1,\"591\":1,\"815\":1}}],[\"what\",{\"0\":{\"242\":1},\"1\":{\"758\":1}}],[\"white\",{\"1\":{\"300\":1}}],[\"whitening\",{\"1\":{\"175\":1}}],[\"while\",{\"1\":{\"29\":1,\"336\":2,\"477\":1,\"478\":1,\"541\":1,\"668\":1,\"682\":1,\"684\":1,\"686\":1,\"688\":1,\"692\":1,\"696\":1,\"801\":1}}],[\"which\",{\"1\":{\"28\":2,\"83\":3,\"438\":1,\"605\":1}}],[\"why\",{\"0\":{\"541\":1},\"1\":{\"28\":2}}],[\"解读目标函数\",{\"0\":{\"870\":1}}],[\"解读加代码实现\",{\"0\":{\"842\":1},\"1\":{\"842\":1}}],[\"解为样本均值和\",{\"1\":{\"826\":1}}],[\"解得极大似然估计\",{\"1\":{\"826\":1}}],[\"解题过程可靠\",{\"1\":{\"704\":1}}],[\"解释\",{\"1\":{\"423\":2,\"830\":1,\"832\":1,\"840\":1}}],[\"解包语法\",{\"1\":{\"681\":1}}],[\"解包\",{\"1\":{\"337\":2}}],[\"解包数据\",{\"1\":{\"323\":1}}],[\"解包编码器输出的不同层级特征\",{\"1\":{\"46\":1}}],[\"解组\",{\"1\":{\"71\":1}}],[\"解码成图像\",{\"1\":{\"886\":2}}],[\"解码成自然语言\",{\"1\":{\"616\":1}}],[\"解码成自然语言文本\",{\"1\":{\"616\":1}}],[\"解码离散表示\",{\"1\":{\"885\":1}}],[\"解码还原图像\",{\"1\":{\"821\":1}}],[\"解码图像\",{\"1\":{\"817\":1,\"821\":1}}],[\"解码出来的图像尽量接近原图\",{\"1\":{\"807\":1}}],[\"解码生成的token\",{\"1\":{\"313\":1}}],[\"解码生成的\",{\"1\":{\"143\":1}}],[\"解码过程\",{\"1\":{\"99\":1}}],[\"解码过程中点特征的语言引导能力\",{\"1\":{\"71\":1}}],[\"解码\",{\"1\":{\"98\":1,\"295\":2,\"821\":1}}],[\"解码器还是认得这个向量\",{\"1\":{\"878\":1}}],[\"解码器不仅认识编码器编出的向量\",{\"1\":{\"878\":1}}],[\"解码器是生成不出有意义的图片的\",{\"1\":{\"878\":1}}],[\"解码器只认识经编码器编出来的向量\",{\"1\":{\"878\":1}}],[\"解码器就是一个图像生成模型\",{\"1\":{\"878\":1}}],[\"解码器可以把一个向量解码成图片\",{\"1\":{\"878\":1}}],[\"解码器会输出一个图像\",{\"1\":{\"869\":1}}],[\"解码器输入\",{\"1\":{\"858\":1}}],[\"解码器输出\",{\"1\":{\"167\":1}}],[\"解码器将\",{\"1\":{\"821\":1}}],[\"解码器将这些查询与点云特征进行交互\",{\"1\":{\"70\":1}}],[\"解码器最终输出图像\",{\"1\":{\"821\":1}}],[\"解码器最终输出层\",{\"1\":{\"793\":1}}],[\"解码器最前面插入\",{\"1\":{\"821\":1}}],[\"解码器网络层列表\",{\"1\":{\"821\":1}}],[\"解码器第一层输入通道来自\",{\"1\":{\"821\":1}}],[\"解码器通道反转\",{\"1\":{\"821\":1}}],[\"解码器中卷积通道的基础维度\",{\"1\":{\"821\":1}}],[\"解码器重构图像\",{\"1\":{\"807\":1}}],[\"解码器重建图像\",{\"1\":{\"794\":1}}],[\"解码器在给定图像\",{\"1\":{\"807\":1}}],[\"解码器残差块\",{\"1\":{\"793\":1}}],[\"解码器初始输入通道\",{\"1\":{\"793\":1}}],[\"解码器的输入张量embedding\",{\"1\":{\"880\":1}}],[\"解码器的层数\",{\"1\":{\"821\":1}}],[\"解码器的下采样\",{\"1\":{\"793\":1}}],[\"解码器的最终输出通过一个线性层和\",{\"1\":{\"622\":1}}],[\"解码器层列表\",{\"1\":{\"793\":1}}],[\"解码器层\",{\"1\":{\"630\":1}}],[\"解码器进行文本生成\",{\"1\":{\"312\":1}}],[\"解码器生成文本描述\",{\"1\":{\"312\":1}}],[\"解码器根据教师模型编码的语义特征重建图像特征\",{\"1\":{\"165\":1}}],[\"解码器架构\",{\"1\":{\"142\":1}}],[\"解码器模型配置文件路径\",{\"1\":{\"142\":1}}],[\"解码器模型\",{\"1\":{\"138\":1,\"142\":1}}],[\"解码器模型难以用于图文检索\",{\"1\":{\"120\":1}}],[\"解码器参数共享与解耦\",{\"0\":{\"134\":1}}],[\"解码器适合生成任务但不适用于检索\",{\"1\":{\"122\":1}}],[\"解码器部分\",{\"1\":{\"101\":1}}],[\"解码器\",{\"1\":{\"98\":2,\"99\":1,\"101\":1,\"126\":1,\"198\":2,\"622\":1,\"631\":1,\"770\":2,\"793\":1,\"807\":4,\"853\":1,\"859\":1,\"869\":1,\"885\":1}}],[\"解码器与点云特征交互\",{\"1\":{\"76\":2}}],[\"解码器融合所有特征以预测可操作性特征\",{\"0\":{\"45\":1},\"1\":{\"40\":1}}],[\"解码结构提取多尺度点特征\",{\"1\":{\"70\":1}}],[\"解码输出\",{\"1\":{\"54\":1}}],[\"解码阶段\",{\"0\":{\"35\":1},\"1\":{\"886\":1}}],[\"解决变量重复使用时的梯度累加问题\",{\"1\":{\"693\":1}}],[\"解决方法\",{\"1\":{\"591\":1}}],[\"解决方案来自\",{\"1\":{\"868\":1}}],[\"解决方案与创新\",{\"1\":{\"216\":1}}],[\"解决方案与核心设计\",{\"1\":{\"189\":1}}],[\"解决方案\",{\"0\":{\"105\":1},\"1\":{\"29\":1,\"49\":1,\"687\":1}}],[\"解决子问题阶段\",{\"1\":{\"503\":1}}],[\"解决前景\",{\"1\":{\"470\":1}}],[\"解决模型训练时\",{\"1\":{\"470\":1}}],[\"解决数据集中\",{\"1\":{\"470\":1}}],[\"解决图文对数量有限\",{\"1\":{\"260\":1}}],[\"解决传统\",{\"1\":{\"165\":1}}],[\"解决点云姿态不一致问题\",{\"1\":{\"107\":1}}],[\"解决了共享变量梯度重置的问题\",{\"1\":{\"685\":1}}],[\"解决了点云处理中的四大技术难点\",{\"1\":{\"105\":1}}],[\"解决了两个问题\",{\"1\":{\"86\":1}}],[\"解决不同来源物体区域的对齐问题\",{\"1\":{\"48\":1}}],[\"解决此问题\",{\"1\":{\"7\":1}}],[\"解析几何属性\",{\"1\":{\"28\":1}}],[\"使生成样本更逼真\",{\"1\":{\"840\":1}}],[\"使开发者能够通过终端与\",{\"1\":{\"715\":1}}],[\"使开发者能以自然的数学表达式编写代码\",{\"1\":{\"690\":1}}],[\"使它们成为了解决复杂问题和应用于多领域的强大工具\",{\"1\":{\"706\":1}}],[\"使它们能够通过阅读大量文本来深入理解语言规则和模式\",{\"1\":{\"703\":1}}],[\"使深度学习框架具备自动求导能力\",{\"1\":{\"692\":1}}],[\"使variable实例具备ndarray的行为特征\",{\"1\":{\"689\":1}}],[\"使转置后的数据在新的布局中是连续存储的\",{\"1\":{\"426\":1}}],[\"使\",{\"1\":{\"198\":1}}],[\"使模型在训练时可以对这些\",{\"1\":{\"795\":1}}],[\"使模型在零样本分类\",{\"1\":{\"198\":1}}],[\"使模型能够从上下文恢复出缺失的高层语义表示\",{\"1\":{\"772\":1}}],[\"使模型能够更准确地识别何时以及如何调用外部工具\",{\"1\":{\"704\":1}}],[\"使模型能学到更强的图文对齐表示\",{\"1\":{\"161\":1}}],[\"使模型行为更可预测和可控\",{\"1\":{\"704\":1}}],[\"使模型聚焦难分类样本\",{\"1\":{\"470\":1}}],[\"使模型更关注难分类的样本\",{\"1\":{\"470\":1}}],[\"使特征分布更稳定\",{\"1\":{\"108\":1}}],[\"使网络能够应对实际中各种密度变换的情况\",{\"1\":{\"96\":1}}],[\"使网络能学习不同采样密度下局部点云特征的提取\",{\"1\":{\"96\":1}}],[\"使局部特征的表示不够精确\",{\"1\":{\"90\":1}}],[\"使得vq\",{\"1\":{\"878\":1}}],[\"使得满足标准正态分布\",{\"1\":{\"878\":1}}],[\"使得从\",{\"1\":{\"864\":1,\"865\":1}}],[\"使得卷积核的右下部分不产生贡献\",{\"1\":{\"845\":1}}],[\"使得开发者可以更容易地构建复杂和强大的应用程序\",{\"1\":{\"715\":1}}],[\"使得开发者能够轻松地将私有数据与\",{\"1\":{\"714\":1}}],[\"使得它们可以理解和生成不同媒体类型的内容\",{\"1\":{\"705\":1}}],[\"使得它们能够在统一的语义空间中进行有效的跨模态交互\",{\"1\":{\"41\":2}}],[\"使得低维对局部位置变化敏感\",{\"1\":{\"587\":1}}],[\"使得gpt\",{\"1\":{\"528\":1}}],[\"使得要充分做区分地训练模型非常有挑战性\",{\"1\":{\"506\":1}}],[\"使得模型能生成与\",{\"1\":{\"865\":1}}],[\"使得模型能够生成指定数字的图像\",{\"1\":{\"858\":1}}],[\"使得模型能够区分正负样本对\",{\"1\":{\"248\":1}}],[\"使得模型能够更有效地学习到有判别性的表示\",{\"1\":{\"248\":1}}],[\"使得模型训练具备了基础的\",{\"1\":{\"695\":1}}],[\"使得模型可以在资源有限的设备上进行训练和部署\",{\"1\":{\"495\":1}}],[\"使得模型在下游任务上的表现逐渐优化\",{\"1\":{\"490\":1}}],[\"使得模型在训练过程中可以更灵活地平衡这两部分损失\",{\"1\":{\"473\":1}}],[\"使得归一化后的向量的\",{\"1\":{\"392\":1,\"393\":1}}],[\"使得检测\",{\"1\":{\"386\":1}}],[\"使得预训练模型能够直接应用于下游任务\",{\"1\":{\"301\":1}}],[\"使得\",{\"1\":{\"277\":1,\"319\":1,\"587\":1,\"709\":1,\"839\":1}}],[\"使得用户可以在不改变模版流程的情况下\",{\"1\":{\"273\":1}}],[\"使得其代码看起来并不常规\",{\"1\":{\"273\":1}}],[\"使得后续指令调优时\",{\"1\":{\"234\":1}}],[\"使得语言模型具备视觉融合能力\",{\"1\":{\"199\":1}}],[\"使得比较时主要依赖\",{\"1\":{\"170\":1}}],[\"使得配对的图文具有更高的相似度得分\",{\"1\":{\"154\":1}}],[\"使得每个\",{\"1\":{\"136\":1}}],[\"使得每个点的权重之和为1\",{\"1\":{\"100\":1}}],[\"使得采样点在整个点云空间中分布尽可能均匀\",{\"1\":{\"92\":1}}],[\"使得在它们之间可以共享学习到的特征表示的权重\",{\"1\":{\"86\":1}}],[\"使其在长文本理解和复杂任务处理方面具有更强的优势\",{\"1\":{\"704\":1}}],[\"使其在ocr和中文任务上表现优异\",{\"1\":{\"220\":1}}],[\"使其行为更接近numpy数组\",{\"1\":{\"693\":1}}],[\"使其支持左右操作数为variable的情况\",{\"1\":{\"690\":1}}],[\"使其支持更复杂的计算和神经网络的构建\",{\"1\":{\"678\":1}}],[\"使其完全可开源\",{\"1\":{\"547\":1}}],[\"使其学会预测哪一输出更受偏好\",{\"1\":{\"537\":1}}],[\"使其能够建模长距离依赖关系\",{\"1\":{\"521\":1}}],[\"使其能够有效将图像映射到离散编码\",{\"1\":{\"167\":1}}],[\"使其能与\",{\"1\":{\"427\":1}}],[\"使其变得\",{\"1\":{\"361\":1}}],[\"使其变为序列形式\",{\"1\":{\"272\":1}}],[\"使其符合模型的输入要求\",{\"1\":{\"302\":1}}],[\"使其更好地理解和执行用户给出的自然语言指令\",{\"1\":{\"239\":1}}],[\"使其标准化\",{\"1\":{\"108\":1}}],[\"使其姿态统一\",{\"1\":{\"107\":1}}],[\"使其简短但仍有意义\",{\"1\":{\"63\":1}}],[\"使其专注于特定领域\",{\"1\":{\"26\":1}}],[\"使问题更具体地连接目标对象的功能\",{\"1\":{\"63\":1}}],[\"使功能表征与对齐特征相互增强\",{\"1\":{\"56\":1}}],[\"使用训练集提取离散\",{\"1\":{\"886\":1}}],[\"使用训练好的\",{\"1\":{\"120\":1}}],[\"使用神经网络等强函数逼近器\",{\"1\":{\"866\":1}}],[\"使用神经网络直接学习对称函数\",{\"1\":{\"115\":1}}],[\"使用交叉熵计算预测\",{\"1\":{\"803\":1}}],[\"使用交叉熵损失衡量生成与真实之间的差异\",{\"1\":{\"312\":1}}],[\"使用交叉熵损失训练\",{\"1\":{\"265\":1}}],[\"使用交叉熵损失函数\",{\"1\":{\"234\":1}}],[\"使用交叉熵损失\",{\"1\":{\"127\":1}}],[\"使用哪种类型的vae\",{\"1\":{\"803\":1}}],[\"使用均匀先验是为了鼓励编码器生成的离散\",{\"1\":{\"800\":1}}],[\"使用均匀先验的好处\",{\"1\":{\"800\":1}}],[\"使用离散表示\",{\"1\":{\"787\":1}}],[\"使用像素序列建模\",{\"1\":{\"785\":1}}],[\"使用预训练的\",{\"1\":{\"777\":1}}],[\"使用贝叶斯公式\",{\"1\":{\"758\":1}}],[\"使用统一的大模型可以极大地提高研发效率\",{\"1\":{\"707\":1}}],[\"使用文心\",{\"1\":{\"704\":2}}],[\"使用相似的架构和预训练任务\",{\"1\":{\"703\":1}}],[\"使用相同的骨干网络\",{\"1\":{\"186\":1}}],[\"使用梯度下降法寻找rosenbrock函数最小值的代码如下\",{\"1\":{\"697\":1}}],[\"使用梯度下降法能高效找到目标值\",{\"1\":{\"697\":1}}],[\"使用tinypytorch实现的代码如下\",{\"1\":{\"697\":1}}],[\"使用transformer架构为未来的多模态统一提供了可能性\",{\"1\":{\"328\":1}}],[\"使用funcs\",{\"1\":{\"696\":1}}],[\"使用farthest\",{\"1\":{\"89\":1}}],[\"使用函数类名作为标签\",{\"1\":{\"696\":1}}],[\"使用id\",{\"1\":{\"696\":1}}],[\"使用dot\",{\"1\":{\"696\":1}}],[\"使用弱引用解决循环引用\",{\"1\":{\"693\":1}}],[\"使用户无需关心data属性\",{\"1\":{\"689\":1}}],[\"使用with语句便捷切换模式\",{\"1\":{\"688\":1}}],[\"使用output\",{\"1\":{\"687\":1}}],[\"使用赋值运算符\",{\"1\":{\"687\":1}}],[\"使用列表保存待处理的函数\",{\"1\":{\"668\":1}}],[\"使用中心差分近似计算数值微分\",{\"1\":{\"651\":1}}],[\"使用示例\",{\"0\":{\"638\":1},\"1\":{\"688\":1,\"689\":1}}],[\"使用掩码机制确保模型在生成目标序列时只能看到当前及之前的词\",{\"1\":{\"622\":1}}],[\"使用爱因斯坦求和公式计算\",{\"1\":{\"590\":1}}],[\"使用nltk库\",{\"1\":{\"577\":1}}],[\"使用nltk库提供的sent\",{\"1\":{\"477\":1}}],[\"使用单句对\",{\"1\":{\"562\":1}}],[\"使用静态掩码\",{\"1\":{\"560\":1}}],[\"使用更多数据等\",{\"1\":{\"559\":1}}],[\"使用更长的序列以及动态调整掩码模式\",{\"1\":{\"558\":1}}],[\"使用更小的\",{\"1\":{\"173\":1}}],[\"使用旋转位置嵌入\",{\"1\":{\"548\":1}}],[\"使用sentencepiece的bpe算法\",{\"1\":{\"548\":1}}],[\"使用如下\",{\"1\":{\"537\":1}}],[\"使用人类标注者示范的优质输出\",{\"1\":{\"537\":1}}],[\"使用外部语言模型引导生成方向\",{\"1\":{\"536\":1}}],[\"使用数十个\",{\"1\":{\"536\":1}}],[\"使用奖励模型的反馈\",{\"1\":{\"535\":1}}],[\"使用bloom过滤器统计测试集与webtext的8\",{\"1\":{\"522\":1}}],[\"使用无监督预训练来提升在判别式任务上的表现是机器学习研究的长期目标\",{\"1\":{\"517\":1}}],[\"使用无监督预训练超参数设置\",{\"1\":{\"514\":1}}],[\"使用学习的位置嵌入\",{\"1\":{\"514\":1}}],[\"使用标注者示范数据\",{\"1\":{\"537\":1}}],[\"使用标注好的指令\",{\"1\":{\"232\":1}}],[\"使用标准的语言模型目标并最大化其似然\",{\"1\":{\"510\":1}}],[\"使用对应特定任务的监督目标来调整这些参数\",{\"1\":{\"507\":1}}],[\"使用对称函数\",{\"1\":{\"105\":1}}],[\"使用复杂的学习方案以及添加辅助学习目标的组合\",{\"1\":{\"507\":1}}],[\"使用不同的损失函数进行训练\",{\"1\":{\"474\":1}}],[\"使用不同句式结构\",{\"1\":{\"63\":1}}],[\"使用最广泛的联合概率分布是多元高斯分布\",{\"1\":{\"750\":1}}],[\"使用最近邻插值保持\",{\"1\":{\"463\":1}}],[\"使用最大池化聚合局部信息\",{\"1\":{\"96\":1}}],[\"使用简单\",{\"1\":{\"395\":1}}],[\"使用简单的点积或者浅层attention层来表示两种模态特征的相似性\",{\"1\":{\"282\":1}}],[\"使用双线性插值\",{\"1\":{\"387\":1}}],[\"使用截断正态分布初始化位置嵌入\",{\"1\":{\"320\":1,\"323\":1}}],[\"使用截断正态分布初始化分类标记\",{\"1\":{\"319\":1,\"320\":1,\"323\":1}}],[\"使用全连接\",{\"1\":{\"313\":1}}],[\"使用adamw优化器\",{\"1\":{\"299\":1}}],[\"使用池化后的图像特征点积计算特征相似性\",{\"1\":{\"282\":1}}],[\"使用在图像数据上预训练的\",{\"1\":{\"268\":1}}],[\"使用共享参数同时进行以下预训练任务\",{\"1\":{\"265\":1}}],[\"使用图像\",{\"1\":{\"261\":1}}],[\"使用卷积网络提取网格特征\",{\"1\":{\"261\":1}}],[\"使用深度融合编码器\",{\"1\":{\"261\":1}}],[\"使用动量更新\",{\"1\":{\"249\":1}}],[\"使用动量编码器对\",{\"1\":{\"163\":1}}],[\"使用动量编码器获取特征\",{\"1\":{\"145\":1}}],[\"使用倒数第二层视觉特征更有利于细节理解\",{\"1\":{\"237\":1}}],[\"使用较小的\",{\"1\":{\"237\":1}}],[\"使用可训练的投影矩阵\",{\"1\":{\"235\":1}}],[\"使用可学习的\",{\"1\":{\"10\":1}}],[\"使用强化学习优化策略\",{\"1\":{\"232\":1}}],[\"使用上述人类偏好数据\",{\"1\":{\"232\":1}}],[\"使用python的weakref模块创建弱引用\",{\"1\":{\"687\":1}}],[\"使用python的unittest模块编写测试用例\",{\"1\":{\"675\":1}}],[\"使用pycharm导入项目\",{\"1\":{\"593\":1}}],[\"使用perspectiveapi对100k提示生成内容进行毒性评分\",{\"1\":{\"551\":1}}],[\"使用paddleocr生成中英文文本标注\",{\"1\":{\"225\":1}}],[\"使用pointnet++编码点云\",{\"1\":{\"70\":1}}],[\"使用完整\",{\"1\":{\"198\":1}}],[\"使用大规模但噪声较多的公开网络图像\",{\"1\":{\"198\":1}}],[\"使用当前\",{\"1\":{\"186\":1}}],[\"使用余弦学习率衰减\",{\"1\":{\"537\":1}}],[\"使用余弦调度器\",{\"1\":{\"186\":1}}],[\"使用余弦相似度\",{\"1\":{\"170\":1}}],[\"使用了如下方式关联编码器的输出与解码器的输入\",{\"1\":{\"880\":1}}],[\"使用了如下逻辑\",{\"1\":{\"614\":1}}],[\"使用了一种叫做\",{\"1\":{\"881\":2}}],[\"使用了一种特别的方法对vq\",{\"1\":{\"878\":1}}],[\"使用了一个偏置项\",{\"1\":{\"78\":1}}],[\"使用了两类掩码卷积\",{\"1\":{\"845\":1}}],[\"使用了从互联网收集的\",{\"1\":{\"806\":1}}],[\"使用了综合性评估框架\",{\"1\":{\"537\":1}}],[\"使用了混合的图像描述和ocr专用数据集\",{\"1\":{\"223\":1}}],[\"使用了\",{\"1\":{\"186\":1,\"561\":1}}],[\"使用欧氏距离\",{\"1\":{\"170\":1}}],[\"使用经验策略\",{\"1\":{\"167\":1}}],[\"使用主分支特征与队列拼接结果计算图像\",{\"1\":{\"161\":1}}],[\"使用的图像输入\",{\"1\":{\"803\":1}}],[\"使用的设备\",{\"1\":{\"803\":1}}],[\"使用的均匀性\",{\"1\":{\"793\":1}}],[\"使用的是tnews数据集\",{\"1\":{\"593\":1}}],[\"使用的是transformer\",{\"1\":{\"507\":1}}],[\"使用的数据集\",{\"1\":{\"515\":1}}],[\"使用的\",{\"1\":{\"147\":1}}],[\"使用一个步长为\",{\"1\":{\"804\":1}}],[\"使用一个\",{\"1\":{\"246\":1}}],[\"使用一个线性分类头进行预测\",{\"1\":{\"127\":1}}],[\"使用一个轻量级的交叉注意力模块\",{\"1\":{\"72\":1}}],[\"使用分块策略\",{\"1\":{\"112\":1}}],[\"使用分割头预测最终的\",{\"0\":{\"46\":1},\"1\":{\"40\":1}}],[\"使用多语言llama初始化中间件\",{\"1\":{\"189\":1}}],[\"使用多模态混合的编码器\",{\"1\":{\"138\":1}}],[\"使用多层\",{\"1\":{\"111\":1,\"260\":1}}],[\"使用多个不同的\",{\"1\":{\"138\":1}}],[\"使用多个不同大小的邻域球\",{\"1\":{\"96\":1}}],[\"使用多个\",{\"1\":{\"92\":1}}],[\"使用多个阈值计算\",{\"1\":{\"82\":1}}],[\"使用反距离加权\",{\"1\":{\"100\":1}}],[\"使用mini\",{\"1\":{\"88\":1}}],[\"使用第4列作为默认掩码\",{\"1\":{\"83\":1}}],[\"使用另一个注意力模块\",{\"1\":{\"74\":2}}],[\"使用robert编码文本\",{\"1\":{\"70\":1}}],[\"使用残差连接\",{\"1\":{\"45\":1}}],[\"使用自注意力机制提炼两个模态之间的语义一致性\",{\"1\":{\"41\":1}}],[\"使用\",{\"0\":{\"346\":1},\"1\":{\"8\":1,\"31\":1,\"40\":4,\"43\":1,\"45\":4,\"46\":1,\"63\":2,\"70\":1,\"73\":1,\"76\":2,\"82\":2,\"92\":2,\"96\":1,\"98\":2,\"101\":2,\"105\":1,\"107\":1,\"109\":2,\"111\":1,\"112\":2,\"126\":2,\"128\":2,\"140\":1,\"143\":4,\"161\":1,\"169\":1,\"170\":3,\"182\":3,\"186\":2,\"204\":1,\"211\":1,\"220\":1,\"222\":1,\"232\":1,\"234\":2,\"235\":2,\"236\":1,\"239\":1,\"247\":1,\"265\":3,\"266\":1,\"267\":1,\"268\":4,\"277\":2,\"309\":1,\"312\":1,\"344\":1,\"346\":1,\"364\":1,\"495\":1,\"514\":1,\"537\":3,\"538\":2,\"539\":1,\"560\":2,\"580\":2,\"616\":1,\"696\":1,\"766\":1,\"774\":1,\"776\":1,\"785\":1,\"789\":1,\"793\":1,\"794\":1,\"795\":1,\"796\":2,\"797\":1,\"802\":2,\"803\":2,\"804\":1,\"814\":1,\"815\":1,\"817\":2,\"820\":1,\"821\":1,\"848\":2,\"869\":1,\"885\":1}}],[\"未找到预训练\",{\"1\":{\"886\":1}}],[\"未找到预训练模型\",{\"1\":{\"885\":1}}],[\"未\",{\"1\":{\"821\":1}}],[\"未指定\",{\"1\":{\"801\":1}}],[\"未患病\",{\"1\":{\"731\":1}}],[\"未归一化的对数概率\",{\"1\":{\"795\":1}}],[\"未归一化\",{\"1\":{\"614\":1}}],[\"未微调模型即接近sota\",{\"1\":{\"549\":1}}],[\"未能回答\",{\"1\":{\"538\":1}}],[\"未登录词\",{\"1\":{\"475\":1}}],[\"未使用\",{\"1\":{\"469\":1,\"470\":1,\"822\":1}}],[\"未投影\",{\"1\":{\"277\":1}}],[\"未经扰动训练时\",{\"1\":{\"112\":1}}],[\"未经roi\",{\"1\":{\"59\":1}}],[\"未见\",{\"1\":{\"49\":1,\"65\":1}}],[\"未来的理论研究有望揭示\",{\"1\":{\"871\":1}}],[\"未来将带来更多创新特性和性能提升\",{\"1\":{\"714\":1}}],[\"未来将持续优化对话和推理能力\",{\"1\":{\"230\":1}}],[\"未来方向\",{\"1\":{\"539\":1}}],[\"未来若需面向多元人群\",{\"1\":{\"539\":1}}],[\"未来研究方向\",{\"1\":{\"523\":1}}],[\"未来工作方向\",{\"1\":{\"269\":1}}],[\"未来可进一步探索以下方向以提升\",{\"1\":{\"138\":1}}],[\"未来\",{\"1\":{\"26\":1}}],[\"未充分挖掘物体间共享的几何不变性\",{\"1\":{\"6\":1}}],[\"有许多图像生成类任务的前沿工作都使用了一种叫做\",{\"1\":{\"877\":1}}],[\"有噪声的\",{\"1\":{\"819\":1}}],[\"有条件\",{\"1\":{\"816\":1}}],[\"有条件预测\",{\"1\":{\"816\":1}}],[\"有条件生成\",{\"1\":{\"815\":1}}],[\"有归一化操作\",{\"1\":{\"802\":1}}],[\"有病\",{\"1\":{\"731\":1}}],[\"有病的人不能诊断为健康\",{\"1\":{\"447\":1}}],[\"有较好的可解释性和可追踪性\",{\"1\":{\"711\":1}}],[\"有限的数据集可能无法显著提高性能\",{\"1\":{\"711\":1}}],[\"有限上下文容量成为当前few\",{\"1\":{\"530\":1}}],[\"有标签数据\",{\"1\":{\"705\":1}}],[\"有5万次\",{\"1\":{\"697\":1}}],[\"有一些图像生成模型\",{\"1\":{\"878\":1}}],[\"有一个特别的约束\",{\"1\":{\"843\":1}}],[\"有一个问题\",{\"1\":{\"386\":1}}],[\"有一点不同就是bert预训练阶段的学习目标是\",{\"1\":{\"581\":1}}],[\"有的问题就是没有答案的\",{\"1\":{\"575\":1}}],[\"有的是不同义的\",{\"1\":{\"515\":1}}],[\"有的是同义的\",{\"1\":{\"515\":1}}],[\"有帮助\",{\"1\":{\"535\":1,\"560\":1}}],[\"有监督微调\",{\"0\":{\"511\":1}}],[\"有监督预训练还是占据主导地位\",{\"1\":{\"246\":1}}],[\"有两个主要原因\",{\"1\":{\"507\":1}}],[\"有2个是正确的\",{\"1\":{\"502\":1}}],[\"有1个是错的\",{\"1\":{\"502\":1}}],[\"有几个注意点\",{\"1\":{\"501\":1}}],[\"有以下一些原因\",{\"1\":{\"482\":1}}],[\"有以下几个优点\",{\"1\":{\"469\":1}}],[\"有没有捷径可走呢\",{\"1\":{\"867\":1}}],[\"有没有低成本的方法微调大模型\",{\"1\":{\"491\":1}}],[\"有没有办法能够减少\",{\"1\":{\"490\":1}}],[\"有没有覆盖正确区域\",{\"1\":{\"467\":1}}],[\"有没有可能将\",{\"1\":{\"247\":1}}],[\"有\",{\"1\":{\"399\":2,\"423\":1,\"511\":1,\"538\":1,\"572\":3,\"703\":1,\"729\":3,\"731\":1,\"732\":1,\"752\":1,\"758\":1,\"867\":1}}],[\"有可能因为对于现有的任务来说\",{\"1\":{\"286\":1}}],[\"有了掩码卷积层后\",{\"1\":{\"848\":1}}],[\"有了分词器后\",{\"1\":{\"579\":1}}],[\"有了\",{\"1\":{\"274\":1,\"544\":1}}],[\"有了以上\",{\"1\":{\"75\":1}}],[\"有干扰\",{\"1\":{\"274\":1}}],[\"有助于构建更通用\",{\"1\":{\"539\":1}}],[\"有助于迁移\",{\"1\":{\"516\":1}}],[\"有助于模型学习到不同方向的特征\",{\"1\":{\"317\":1}}],[\"有助于提升对复杂图文对的泛化能力\",{\"1\":{\"266\":1}}],[\"有助于加快收敛\",{\"1\":{\"237\":1}}],[\"有个细节\",{\"1\":{\"249\":1}}],[\"有时我们也会讨论高斯分布的精度\",{\"1\":{\"746\":1}}],[\"有时会产生与客观事实不符的信息\",{\"1\":{\"709\":1}}],[\"有时更低\",{\"1\":{\"538\":1}}],[\"有时更贴近人类学习习惯\",{\"1\":{\"528\":1}}],[\"有时也会加入一个平滑项\",{\"1\":{\"467\":1}}],[\"有时只取\",{\"1\":{\"186\":1}}],[\"有时裁掉少量边缘\",{\"1\":{\"186\":1}}],[\"有关\",{\"1\":{\"176\":1}}],[\"有多少个\",{\"1\":{\"727\":1}}],[\"有多少个离散\",{\"1\":{\"170\":1}}],[\"有多少点被正确分类\",{\"1\":{\"467\":1}}],[\"有多少组点云\",{\"1\":{\"107\":1}}],[\"有些人可能会认为\",{\"1\":{\"873\":1}}],[\"有些模型是\",{\"1\":{\"847\":1}}],[\"有些\",{\"1\":{\"157\":1,\"186\":1}}],[\"有些位置被标记为\",{\"1\":{\"92\":1}}],[\"有效的关键组成\",{\"1\":{\"780\":1}}],[\"有效的部分\",{\"1\":{\"43\":1}}],[\"有效突破了输入长度的限制\",{\"1\":{\"709\":1}}],[\"有效\",{\"1\":{\"538\":1}}],[\"有效地从无标记的原始文本中学习的能力能减轻对监督学习的依赖\",{\"1\":{\"507\":1}}],[\"有效适应输入图像的不同分辨率和宽高比\",{\"1\":{\"224\":1}}],[\"有效提升了下游任务中的表现\",{\"1\":{\"140\":1}}],[\"有效语言部分\",{\"1\":{\"43\":1}}],[\"有望提升机器人在未知环境中的自主交互能力\",{\"1\":{\"26\":1}}],[\"有问题需要咨询的小伙伴\",{\"1\":{\"2\":1}}],[\"大致与单一部分损失相同\",{\"1\":{\"815\":1}}],[\"大致上两者结构是相同的\",{\"1\":{\"321\":1}}],[\"大量的模型容量会花在捕捉高频细节上\",{\"1\":{\"807\":1}}],[\"大量实验验证了我们提出的\",{\"1\":{\"26\":1}}],[\"大脑\",{\"1\":{\"703\":1}}],[\"大距离用对数压缩的桶\",{\"1\":{\"591\":1}}],[\"大批量训练提升mlm困惑度\",{\"1\":{\"564\":1}}],[\"大批量训练\",{\"1\":{\"562\":2,\"564\":1}}],[\"大规模统一建模方法具备强大的泛化与多任务能力\",{\"1\":{\"806\":1}}],[\"大规模模型和海量数据的结合\",{\"1\":{\"806\":1}}],[\"大规模语言模型在任务通用性与灵活性方面具有巨大潜力\",{\"1\":{\"532\":1}}],[\"大规模地在zero\",{\"1\":{\"531\":1}}],[\"大规模视觉编码器\",{\"1\":{\"197\":1}}],[\"大部分任务通过自然语言指令表达意图\",{\"1\":{\"537\":1}}],[\"大部分任务\",{\"1\":{\"514\":1}}],[\"大部分深度学习方法需要大量人工标注的数据\",{\"1\":{\"507\":1}}],[\"大公司或者研究机构\",{\"1\":{\"491\":1}}],[\"大\",{\"1\":{\"481\":1,\"587\":1}}],[\"大模型api使用\",{\"0\":{\"719\":1}}],[\"大模型开发与传统\",{\"1\":{\"716\":1}}],[\"大模型开发却更多是一个工程问题\",{\"1\":{\"716\":1}}],[\"大模型开发\",{\"0\":{\"716\":1},\"1\":{\"716\":2}}],[\"大模型可以成为\",{\"1\":{\"707\":1}}],[\"大模型研发\",{\"1\":{\"704\":1}}],[\"大模型领域仅存在预训练阶段的\",{\"1\":{\"703\":1}}],[\"大模型加速技术之kv\",{\"1\":{\"540\":1}}],[\"大模型使用较大的batch\",{\"1\":{\"528\":1}}],[\"大模型中有其中一部分参数\",{\"1\":{\"487\":1}}],[\"大模型参数很多\",{\"1\":{\"487\":1}}],[\"大模型的性能不断增长\",{\"1\":{\"703\":1}}],[\"大模型的微调有以下几条技术路线\",{\"1\":{\"483\":1}}],[\"大模型的微调分成两条技术路线\",{\"1\":{\"483\":1}}],[\"大模型的推理成本越高\",{\"1\":{\"482\":1}}],[\"大模型\",{\"1\":{\"481\":1,\"704\":2}}],[\"大模型微调大致发展历史\",{\"0\":{\"491\":1}}],[\"大模型微调\",{\"0\":{\"480\":1},\"1\":{\"480\":1}}],[\"大多数样本会集中在这个区域上\",{\"1\":{\"754\":1}}],[\"大多数样本应该靠近原点\",{\"1\":{\"753\":1}}],[\"大多数sota模型依赖于\",{\"1\":{\"531\":1}}],[\"大多数方法求解出来结果都一样的答案\",{\"1\":{\"502\":1}}],[\"大多数实际应用中都是如此\",{\"1\":{\"443\":1}}],[\"大多使用从网络收集的嘈杂图文对作为训练数据\",{\"1\":{\"120\":1}}],[\"大大提高学习效率\",{\"1\":{\"314\":1}}],[\"大家参考仓库源码即可\",{\"1\":{\"580\":1}}],[\"大家可以自行拉取项目完整代码进行学习\",{\"1\":{\"327\":1}}],[\"大家注意区分\",{\"1\":{\"309\":1}}],[\"大家请自行阅读源代码\",{\"1\":{\"186\":1}}],[\"大幅降低训练成本\",{\"1\":{\"307\":1}}],[\"大幅超越所有基线\",{\"1\":{\"23\":1}}],[\"大放异彩的一年\",{\"1\":{\"297\":1}}],[\"大于最大桶号的全部压到最后一个桶\",{\"1\":{\"591\":1}}],[\"大于\",{\"1\":{\"272\":1,\"321\":1}}],[\"大字典是怎么做到的\",{\"1\":{\"246\":1}}],[\"大型模型不仅可以缩短每个具体应用的开发周期\",{\"1\":{\"707\":1}}],[\"大型视觉编码器\",{\"1\":{\"205\":1}}],[\"大型语言模型\",{\"1\":{\"189\":1,\"216\":1,\"232\":1,\"535\":1,\"709\":1}}],[\"大的数值范围会主导距离计算\",{\"1\":{\"170\":1}}],[\"大语言模型的两个核心能力\",{\"1\":{\"716\":1}}],[\"大语言模型的发展历程虽然只有短短不到五年的时间\",{\"1\":{\"704\":1}}],[\"大语言模型是这个新模式的典型例子\",{\"1\":{\"707\":1}}],[\"大语言模型是一种具有强大语言处理能力的技术\",{\"1\":{\"705\":1}}],[\"大语言模型具有多种显著特点\",{\"1\":{\"705\":1}}],[\"大语言模型应用开发基础知识速览\",{\"1\":{\"702\":1}}],[\"大语言模型\",{\"0\":{\"118\":1,\"703\":1},\"1\":{\"229\":1,\"703\":2,\"716\":1}}],[\"大小转为\",{\"1\":{\"804\":1}}],[\"大小的\",{\"1\":{\"774\":1}}],[\"大小的图像\",{\"1\":{\"317\":1}}],[\"大小的队列特征\",{\"1\":{\"246\":1}}],[\"大小和字典大小是等价的\",{\"1\":{\"250\":1}}],[\"大小和字典大小剥离开\",{\"1\":{\"249\":1}}],[\"大小要足够的大\",{\"1\":{\"250\":1}}],[\"大小\",{\"1\":{\"169\":1,\"250\":1,\"272\":2,\"317\":1,\"386\":1,\"590\":1,\"727\":1}}],[\"大小不超过\",{\"1\":{\"105\":1}}],[\"大小为输入图像的patch数目\",{\"1\":{\"801\":1}}],[\"大小为\",{\"1\":{\"59\":1,\"167\":1,\"821\":1}}],[\"大区域\",{\"1\":{\"92\":1}}],[\"大局部区域\",{\"1\":{\"92\":1}}],[\"万对文本\",{\"1\":{\"810\":1}}],[\"万步训练过程在\",{\"1\":{\"774\":1}}],[\"万步\",{\"1\":{\"774\":1}}],[\"万\",{\"1\":{\"704\":1}}],[\"万亿个\",{\"1\":{\"704\":1}}],[\"万亿参数\",{\"1\":{\"704\":1}}],[\"万亿\",{\"1\":{\"481\":1,\"704\":1}}],[\"万个特征\",{\"1\":{\"250\":1}}],[\"万个标注完整的\",{\"1\":{\"26\":1}}],[\"万增长到\",{\"1\":{\"247\":1}}],[\"万条图文对\",{\"1\":{\"234\":1}}],[\"万高质量指令数据\",{\"1\":{\"198\":1}}],[\"万象多模态大模型\",{\"0\":{\"187\":1,\"214\":1}}],[\"万张图像作为验证集\",{\"1\":{\"809\":1}}],[\"万张图像\",{\"1\":{\"131\":1,\"774\":1}}],[\"万张交互图像与超过\",{\"1\":{\"26\":1}}],[\"涵盖广泛的主题和写作风格\",{\"1\":{\"521\":1}}],[\"涵盖多种任务类型\",{\"1\":{\"235\":1}}],[\"涵盖常见场景和文档图像\",{\"1\":{\"216\":1}}],[\"涵盖图像描述\",{\"1\":{\"198\":1}}],[\"涵盖\",{\"1\":{\"26\":1,\"225\":1,\"561\":1}}],[\"能不能把编码器的输出张量\",{\"1\":{\"880\":1}}],[\"能不能自己生成答案\",{\"1\":{\"616\":1}}],[\"能输入一个字符串或图像\",{\"1\":{\"874\":1}}],[\"能输出\",{\"1\":{\"847\":1}}],[\"能生成离散输出这一特性启发了后续很多生成模型\",{\"1\":{\"847\":1}}],[\"能生成连贯但虚构的内容\",{\"1\":{\"522\":1}}],[\"能最大化数据集的图像的出现概率\",{\"1\":{\"847\":1}}],[\"能确保\",{\"1\":{\"846\":1}}],[\"能用\",{\"1\":{\"846\":1}}],[\"能量视角下的gan模型\",{\"1\":{\"841\":1}}],[\"能促进更好的码本利用率\",{\"1\":{\"808\":1}}],[\"能让\",{\"1\":{\"797\":1}}],[\"能让无监督的对比学习取得很好的效果\",{\"1\":{\"245\":1}}],[\"能在下游任务上泛化得更好的原因之一\",{\"1\":{\"781\":1}}],[\"能跑起来\",{\"1\":{\"695\":1}}],[\"能映射的最大距离\",{\"1\":{\"591\":1}}],[\"能提升掩码语言模型的困惑度和下游任务性能\",{\"1\":{\"562\":1}}],[\"能处理非训练分布指令\",{\"1\":{\"538\":1}}],[\"能带来质的改善\",{\"1\":{\"535\":1}}],[\"能力提升伴随风险增加\",{\"1\":{\"551\":1}}],[\"能力\",{\"1\":{\"532\":1,\"695\":1,\"704\":2}}],[\"能力分布不均\",{\"1\":{\"530\":1}}],[\"能缓解类别不平衡问题\",{\"1\":{\"468\":1}}],[\"能缓解弱标注图文数据中的噪声问题\",{\"1\":{\"150\":1}}],[\"能避免切分导致某类在测试集中缺失\",{\"1\":{\"398\":1}}],[\"能自适应频率和相位\",{\"1\":{\"385\":1}}],[\"能起作用的原因在于\",{\"1\":{\"319\":1}}],[\"能否基于互联网上的大量文本来预训练视觉模型\",{\"1\":{\"305\":1}}],[\"能根据用户指令回答问题\",{\"1\":{\"239\":1}}],[\"能适应不同batch大小\",{\"1\":{\"178\":1}}],[\"能显著提升条件相关性\",{\"1\":{\"816\":1}}],[\"能显著提升模型性能\",{\"1\":{\"265\":1}}],[\"能显著提升\",{\"1\":{\"173\":1}}],[\"能更好处理异常误差\",{\"1\":{\"797\":1}}],[\"能更精准地控制内存释放时机\",{\"1\":{\"687\":1}}],[\"能更有效地重组视觉特征为llm兼容的序列\",{\"1\":{\"196\":1}}],[\"能更有效应对含噪声的网络数据\",{\"1\":{\"149\":1}}],[\"能更稳定地追踪模型训练动态\",{\"1\":{\"167\":1}}],[\"能反映边缘响应质量\",{\"1\":{\"82\":1}}],[\"能够成功解码的\",{\"1\":{\"868\":1}}],[\"能够自动关注对象边界或同类区域\",{\"1\":{\"781\":1}}],[\"能够自适应地选择最适合的特征尺度进行组合\",{\"1\":{\"96\":1}}],[\"能够对图像内容进行更高级别的抽象总结\",{\"1\":{\"772\":1}}],[\"能够以结构化的格式返回信息\",{\"1\":{\"714\":1}}],[\"能够以指数级减少所需的神经元数量\",{\"1\":{\"385\":1}}],[\"能够根据任务指令执行任务\",{\"1\":{\"706\":1}}],[\"能够理解和生成依赖于前文的文本内容\",{\"1\":{\"705\":1}}],[\"能够分析和理解用户提供的图片\",{\"1\":{\"704\":1}}],[\"能够匹配甚至超越后续提出的多种模型\",{\"1\":{\"559\":1}}],[\"能够泛化\",{\"1\":{\"539\":1}}],[\"能够通过检索对应应用场景数据的方式\",{\"1\":{\"709\":1}}],[\"能够通过预测任务的自然语言演示\",{\"1\":{\"523\":1}}],[\"能够通过预测任务的自然语言描述\",{\"1\":{\"520\":1}}],[\"能够通过自有数据\",{\"1\":{\"482\":1}}],[\"能够通过多层\",{\"1\":{\"319\":1}}],[\"能够动态地聚合图像信息\",{\"1\":{\"319\":1}}],[\"能够更好地聚合图像信息\",{\"1\":{\"319\":1}}],[\"能够很近似在整个数据集上做的多分类损失\",{\"1\":{\"249\":1}}],[\"能够很好地支持\",{\"1\":{\"62\":1}}],[\"能够有效重组视觉特征\",{\"1\":{\"198\":1}}],[\"能够参考其他\",{\"1\":{\"179\":1}}],[\"能够在零样本\",{\"1\":{\"519\":1}}],[\"能够在自监督学习中捕捉丰富的上下文信息\",{\"1\":{\"165\":1}}],[\"能够在开放场景下支持可供性理解\",{\"1\":{\"26\":1}}],[\"能够\",{\"1\":{\"157\":1}}],[\"能够突破预定义样本空间的限制\",{\"1\":{\"26\":1}}],[\"能正确捕捉如\",{\"1\":{\"23\":1}}],[\"结束调用\",{\"1\":{\"345\":1}}],[\"结束\",{\"1\":{\"344\":1,\"616\":1}}],[\"结束值\",{\"1\":{\"332\":1}}],[\"结束符\",{\"1\":{\"313\":1}}],[\"结果就是\",{\"1\":{\"800\":1}}],[\"结果就不会变\",{\"1\":{\"105\":1}}],[\"结果分析\",{\"1\":{\"692\":1}}],[\"结果验证\",{\"1\":{\"692\":2}}],[\"结果包含误差\",{\"1\":{\"653\":1}}],[\"结果是\",{\"1\":{\"590\":1}}],[\"结果是一个形状为\",{\"1\":{\"425\":1}}],[\"结果如下表3\",{\"1\":{\"515\":1}}],[\"结果如下\",{\"1\":{\"324\":1}}],[\"结果如下图所示\",{\"1\":{\"320\":1,\"697\":1}}],[\"结果发现在imagenet数据集上能够带来3\",{\"1\":{\"301\":1}}],[\"结果见表5\",{\"1\":{\"268\":1}}],[\"结果\",{\"0\":{\"529\":1,\"538\":1,\"549\":1},\"1\":{\"170\":1,\"354\":1,\"409\":1,\"559\":1,\"564\":2,\"565\":2,\"591\":1,\"759\":1}}],[\"结果显示\",{\"1\":{\"112\":1,\"201\":1,\"522\":1,\"527\":1,\"562\":1}}],[\"结果表明\",{\"1\":{\"75\":1,\"781\":1,\"806\":1}}],[\"结合全概率公式\",{\"1\":{\"733\":1}}],[\"结合全局池化增强语义表达\",{\"1\":{\"46\":1}}],[\"结合上述分析\",{\"1\":{\"717\":1}}],[\"结合特殊的数据或业务逻辑来提供独特功能的应用称为大模型开发\",{\"1\":{\"716\":1}}],[\"结合检索到的信息和模型的生成能力\",{\"1\":{\"709\":1}}],[\"结合缓存的attention\",{\"1\":{\"312\":1}}],[\"结合低分辨率和高分辨率特征\",{\"1\":{\"219\":1}}],[\"结合使用\",{\"1\":{\"178\":1}}],[\"结合视觉\",{\"1\":{\"167\":1}}],[\"结合文本通过多模态编码器处理\",{\"1\":{\"149\":1}}],[\"结合文本描述提升语义理解\",{\"1\":{\"51\":1}}],[\"结合\",{\"1\":{\"105\":1,\"198\":1}}],[\"结合了层级特征提取和多尺度融合机制\",{\"1\":{\"98\":1}}],[\"结合论文理解这些指标的意义\",{\"1\":{\"82\":1}}],[\"结合人工+gpt\",{\"1\":{\"69\":1}}],[\"结合其对应的功能类型和原始点云标注信息\",{\"1\":{\"64\":1}}],[\"结合cot在目标检测\",{\"1\":{\"7\":1}}],[\"结构的基础上添加一个任务层\",{\"1\":{\"775\":1}}],[\"结构的隐式关联\",{\"1\":{\"52\":1}}],[\"结构一致\",{\"1\":{\"752\":1}}],[\"结构正常的区间组合\",{\"1\":{\"728\":1}}],[\"结构化问答\",{\"1\":{\"530\":1}}],[\"结构与主模型相同\",{\"1\":{\"160\":1}}],[\"结构规整\",{\"1\":{\"114\":1}}],[\"结构单一\",{\"1\":{\"112\":1}}],[\"结构简单\",{\"1\":{\"112\":1}}],[\"结构多样性\",{\"1\":{\"63\":1}}],[\"结构融合\",{\"1\":{\"33\":1}}],[\"结构\",{\"0\":{\"623\":1,\"625\":1,\"629\":1},\"1\":{\"32\":1,\"98\":1,\"514\":1,\"560\":1,\"622\":1,\"817\":1}}],[\"结论如下\",{\"1\":{\"134\":1}}],[\"结论\",{\"0\":{\"26\":1,\"206\":1,\"230\":1,\"517\":1,\"532\":1,\"790\":1},\"1\":{\"459\":1,\"539\":1,\"780\":1}}],[\"同\",{\"1\":{\"398\":1}}],[\"同形状的整数张量\",{\"1\":{\"379\":1}}],[\"同形状的矩阵\",{\"1\":{\"163\":1}}],[\"同长度的浮点张量\",{\"1\":{\"377\":1}}],[\"同理\",{\"1\":{\"246\":1,\"730\":1}}],[\"同一卷积核在不同位置重复使用\",{\"1\":{\"385\":1}}],[\"同一个观测结果\",{\"1\":{\"759\":1}}],[\"同一个句子在训练的不同批次\",{\"1\":{\"562\":1}}],[\"同一个视频里的任意两帧是正样本\",{\"1\":{\"243\":1}}],[\"同一个类别的物体处于相邻的区域\",{\"1\":{\"242\":1}}],[\"同一物体区域可能支持多功能\",{\"1\":{\"49\":1}}],[\"同一物体在不同交互图像中被推理出不同的\",{\"1\":{\"25\":1}}],[\"同输入\",{\"1\":{\"170\":1}}],[\"同步各\",{\"1\":{\"170\":1}}],[\"同样可以比较好地记录二维信息\",{\"1\":{\"320\":1}}],[\"同样需要位置编码来记录各图像块之间的位置信息\",{\"1\":{\"320\":1}}],[\"同样\",{\"1\":{\"318\":1,\"493\":1,\"690\":1,\"704\":1,\"717\":1}}],[\"同样会将像素值从\",{\"1\":{\"317\":1}}],[\"同样会为coco数据集中每个样本的caption前添加固定长度的prompt\",{\"1\":{\"145\":1}}],[\"同样是数据增强的手段\",{\"1\":{\"317\":1}}],[\"同样给计算机视觉领域带来了巨大影响\",{\"1\":{\"297\":1}}],[\"同样采用余弦调度\",{\"1\":{\"179\":1}}],[\"同样地\",{\"1\":{\"156\":1,\"575\":1,\"759\":1,\"825\":1}}],[\"同时优化两个目标\",{\"1\":{\"869\":1}}],[\"同时优化三个预训练目标\",{\"1\":{\"127\":1}}],[\"同时应用\",{\"1\":{\"846\":2}}],[\"同时输出图像每一处的概率分布\",{\"1\":{\"843\":1}}],[\"同时实现简单且与基于patch的模型结构高度契合\",{\"1\":{\"801\":1}}],[\"同时仍保证梯度流通\",{\"1\":{\"795\":1}}],[\"同时去除视觉\",{\"1\":{\"780\":1}}],[\"同时降低了调用成本\",{\"1\":{\"709\":1}}],[\"同时降维\",{\"1\":{\"34\":1,\"35\":1}}],[\"同时还开源了代码模型和数学模型\",{\"1\":{\"704\":1}}],[\"同时还能适应更多的参数\",{\"1\":{\"495\":1}}],[\"同时开源了用\",{\"1\":{\"704\":1}}],[\"同时发布了\",{\"1\":{\"704\":2}}],[\"同时减少参数量和计算量\",{\"1\":{\"704\":1}}],[\"同时又优先处理列表末尾的函数\",{\"1\":{\"685\":1}}],[\"同时对长距离不必过于精细\",{\"1\":{\"591\":1}}],[\"同时对输入的文本数据回调\",{\"1\":{\"274\":1}}],[\"同时进行\",{\"1\":{\"574\":1}}],[\"同时表明bert的掩码语言模型目标在优化后仍具有竞争力\",{\"1\":{\"558\":1}}],[\"同时分析模型偏见\",{\"1\":{\"547\":1}}],[\"同时返回对应的key和val\",{\"1\":{\"544\":1}}],[\"同时构建适用于未来更强\",{\"1\":{\"539\":1}}],[\"同时允许空格合并以提高压缩效率\",{\"1\":{\"521\":1}}],[\"同时揭示了模型容量与任务性能之间的紧密关联\",{\"1\":{\"520\":1}}],[\"同时列表末尾追加<\",{\"1\":{\"477\":1}}],[\"同时末尾加上\",{\"1\":{\"476\":1}}],[\"同时完成断句分词任务\",{\"1\":{\"476\":1}}],[\"同时避免\",{\"1\":{\"475\":1}}],[\"同时也促进了社区的合作和共享\",{\"1\":{\"715\":1}}],[\"同时也引发了对未来人工智能的无限探索\",{\"1\":{\"708\":1}}],[\"同时也引发了对其伦理和风险问题的关注\",{\"1\":{\"705\":1}}],[\"同时也是方差\",{\"1\":{\"739\":1}}],[\"同时也是\",{\"1\":{\"471\":1}}],[\"同时也指运用该方法构建的模型\",{\"1\":{\"298\":1}}],[\"同时保持总损失数值稳定\",{\"1\":{\"815\":1}}],[\"同时保持了向后兼容性\",{\"1\":{\"714\":1}}],[\"同时保持了低资源部署的高效性\",{\"1\":{\"704\":1}}],[\"同时保持了模型性能\",{\"1\":{\"704\":2}}],[\"同时保持开源可复现性\",{\"1\":{\"553\":1}}],[\"同时保持预先训练的权重不变\",{\"1\":{\"491\":1}}],[\"同时保持空间连续性\",{\"1\":{\"465\":1}}],[\"同时保留一定的随机性和自然度\",{\"1\":{\"816\":1}}],[\"同时保留最有代表性的空间信息\",{\"1\":{\"386\":1}}],[\"同时保留其捕捉长距离依赖的优势\",{\"1\":{\"326\":1}}],[\"同时保留全局缩略图以捕捉上下文信息\",{\"1\":{\"215\":1}}],[\"同时提供了高质量的实现和训练权重\",{\"1\":{\"395\":1}}],[\"同时提出\",{\"1\":{\"260\":1}}],[\"同时作为特征数量\",{\"1\":{\"319\":1,\"320\":1,\"323\":1}}],[\"同时会将像素值从\",{\"1\":{\"317\":1}}],[\"同时删除不相关的视觉信息\",{\"1\":{\"313\":1}}],[\"同时因llm而具有了视觉推理能力\",{\"1\":{\"307\":1}}],[\"同时具有很好的性能\",{\"1\":{\"307\":1}}],[\"同时最小化个负样本的相似度\",{\"1\":{\"299\":1}}],[\"同时最小化非对角线的非匹配样本相似度得分\",{\"1\":{\"277\":1}}],[\"同时文本\",{\"1\":{\"266\":1}}],[\"同时共享自注意力层进行跨模态对齐\",{\"1\":{\"260\":1}}],[\"同时key\",{\"1\":{\"254\":1}}],[\"同时认为\",{\"1\":{\"243\":1}}],[\"同时支持对比学习\",{\"1\":{\"196\":1}}],[\"同时支持编码器\",{\"1\":{\"120\":1}}],[\"同时计算self\",{\"1\":{\"621\":1}}],[\"同时计算需求更低\",{\"1\":{\"184\":1}}],[\"同时计算开销更低\",{\"1\":{\"173\":1}}],[\"同时使用这个旁路的更新来模拟\",{\"1\":{\"492\":1}}],[\"同时使用居中和锐化\",{\"1\":{\"183\":1}}],[\"同时使用双三次插值\",{\"1\":{\"179\":1}}],[\"同时适用于\",{\"1\":{\"173\":1}}],[\"同时通过masked\",{\"1\":{\"581\":1}}],[\"同时通过\",{\"1\":{\"167\":1}}],[\"同时通过引入动量蒸馏\",{\"1\":{\"149\":1}}],[\"同时将flower\",{\"1\":{\"302\":1}}],[\"同时将损失记录在字典中\",{\"1\":{\"275\":1}}],[\"同时将对应的\",{\"1\":{\"163\":1}}],[\"同时将运行时输出写入日志\",{\"1\":{\"83\":1}}],[\"同时获取对应的\",{\"1\":{\"162\":1}}],[\"同时获取裁剪后的物体框\",{\"1\":{\"58\":1}}],[\"同时摒弃目标检测器\",{\"1\":{\"150\":1}}],[\"同时结合了一些前人工作的改进\",{\"1\":{\"704\":1}}],[\"同时结合图文对比\",{\"1\":{\"129\":1}}],[\"同时结合跨模态特征对齐\",{\"1\":{\"26\":1}}],[\"同时区分负样本\",{\"1\":{\"127\":1}}],[\"同时兼顾理解与生成任务\",{\"1\":{\"122\":1}}],[\"同时\",{\"1\":{\"120\":1,\"494\":1,\"527\":1,\"531\":1,\"569\":1,\"690\":1,\"714\":1,\"716\":2,\"867\":1,\"878\":1}}],[\"同时确保这些分区的处理方式允许在它们之间共享模型权重\",{\"1\":{\"86\":1}}],[\"同时缺少\",{\"1\":{\"86\":1}}],[\"同时等比例对物体框做同样的缩放\",{\"1\":{\"58\":1}}],[\"同时记录每类物体共对应多少不同的点云\",{\"1\":{\"58\":1}}],[\"同时记录每类物体对应的样本总量\",{\"1\":{\"29\":1}}],[\"同时判断是否与当前图片交互行为一致\",{\"1\":{\"29\":1}}],[\"同时包含部分新物体类别\",{\"1\":{\"20\":1}}],[\"时为\",{\"1\":{\"831\":1}}],[\"时获取离散\",{\"1\":{\"821\":1}}],[\"时增强条件影响\",{\"1\":{\"816\":1}}],[\"时退化为普通有条件生成\",{\"1\":{\"816\":1}}],[\"时放大图像\",{\"1\":{\"815\":1}}],[\"时成立\",{\"1\":{\"807\":1}}],[\"时生成样本\",{\"1\":{\"865\":1}}],[\"时生成\",{\"1\":{\"807\":1}}],[\"时生成的\",{\"1\":{\"807\":1}}],[\"时生效\",{\"1\":{\"398\":1}}],[\"时非常有用\",{\"1\":{\"744\":1}}],[\"时取\",{\"1\":{\"738\":1}}],[\"时的rosenbrock函数\",{\"1\":{\"697\":1}}],[\"时展开变量列表\",{\"1\":{\"681\":1}}],[\"时让它同时进行两个任务\",{\"1\":{\"571\":1}}],[\"时代的开启\",{\"1\":{\"703\":1}}],[\"时代推向了\",{\"1\":{\"531\":1}}],[\"时代\",{\"1\":{\"531\":1}}],[\"时才涌现出来的能力\",{\"1\":{\"501\":1}}],[\"时按原序切分\",{\"1\":{\"398\":1}}],[\"时使用\",{\"1\":{\"272\":1,\"321\":1,\"809\":1}}],[\"时间小于\",{\"1\":{\"728\":1}}],[\"时间\",{\"1\":{\"571\":1}}],[\"时间复杂度为二次方\",{\"1\":{\"260\":1}}],[\"时间戳等\",{\"1\":{\"114\":1}}],[\"时性能会下降\",{\"1\":{\"223\":1}}],[\"时性能略低\",{\"1\":{\"185\":1}}],[\"时效果最佳\",{\"1\":{\"182\":1}}],[\"时不是用\",{\"1\":{\"145\":1}}],[\"时\",{\"1\":{\"24\":1,\"78\":1,\"162\":1,\"185\":1,\"246\":2,\"264\":1,\"368\":2,\"398\":1,\"403\":1,\"425\":1,\"471\":4,\"492\":1,\"538\":1,\"544\":1,\"572\":1,\"589\":1,\"591\":1,\"686\":1,\"728\":1,\"729\":1,\"744\":1,\"749\":1,\"795\":1,\"796\":1,\"808\":1,\"815\":1,\"839\":1,\"867\":1,\"869\":1,\"871\":1}}],[\"下标构成的数组\",{\"1\":{\"880\":1}}],[\"下高概率的区域\",{\"1\":{\"867\":1}}],[\"下高概率的\",{\"1\":{\"867\":1}}],[\"下方信息\",{\"1\":{\"848\":1}}],[\"下次输入通道设为隐藏通道\",{\"1\":{\"793\":2}}],[\"下衡量\",{\"1\":{\"590\":1}}],[\"下载地址\",{\"1\":{\"577\":1}}],[\"下载预先训练的模型权重\",{\"1\":{\"463\":1}}],[\"下句的\",{\"1\":{\"573\":1}}],[\"下一个数字或者补充的像素有许多可能\",{\"1\":{\"874\":1}}],[\"下一个步骤会介绍并实现另一种优化方法\",{\"1\":{\"697\":1}}],[\"下一个句子预测损失\",{\"1\":{\"612\":1}}],[\"下一句话\",{\"1\":{\"573\":1}}],[\"下一句预测\",{\"1\":{\"560\":1,\"580\":2}}],[\"下一轮推理时直接读取缓存结果\",{\"1\":{\"544\":1}}],[\"下一轮计算时直接读取缓存结果\",{\"1\":{\"541\":1}}],[\"下一步我们又要根据嵌入空间把离散编码转回一个向量\",{\"1\":{\"880\":1}}],[\"下一步只送入新\",{\"1\":{\"544\":1}}],[\"下一步便可以通过\",{\"1\":{\"274\":1}}],[\"下进行训练\",{\"1\":{\"537\":1}}],[\"下表2是作者模型和之前sota模型nli的结果比较\",{\"1\":{\"515\":1}}],[\"下表中对比了vit\",{\"1\":{\"326\":1}}],[\"下\",{\"1\":{\"428\":2}}],[\"下图按照时间线给出了\",{\"1\":{\"704\":1}}],[\"下图展示的是步骤7中以元组形式返回的kv\",{\"1\":{\"544\":1}}],[\"下图展示了\",{\"1\":{\"311\":1}}],[\"下图给出了有\",{\"1\":{\"543\":1}}],[\"下图给出了无\",{\"1\":{\"542\":1}}],[\"下图给出的是\",{\"1\":{\"186\":1}}],[\"下游任务微调\",{\"0\":{\"267\":1}}],[\"下训练并\",{\"1\":{\"208\":1}}],[\"下分布在\",{\"1\":{\"179\":1}}],[\"下采样后的点坐标数据\",{\"1\":{\"100\":1}}],[\"下采样点的特征\",{\"1\":{\"100\":1}}],[\"下采样点数量\",{\"1\":{\"100\":1}}],[\"下采样点对应的特征数据\",{\"1\":{\"100\":1}}],[\"下采样点特征\",{\"1\":{\"98\":1}}],[\"下采样点坐标\",{\"1\":{\"98\":1}}],[\"下的\",{\"1\":{\"82\":1,\"868\":1}}],[\"下的表现\",{\"1\":{\"82\":1}}],[\"下面给出几个示例\",{\"1\":{\"826\":1}}],[\"下面给出\",{\"1\":{\"821\":1}}],[\"下面给出的是beit主模型的预训练流程核心的代码实现\",{\"1\":{\"803\":1}}],[\"下面给出的是\",{\"1\":{\"794\":1}}],[\"下面给出的是一个基于pointnet++的点云语义分割模型定义\",{\"1\":{\"101\":1}}],[\"下面为\",{\"1\":{\"683\":1}}],[\"下面将展示正式执行块状遮挡策略前的准备工作\",{\"1\":{\"801\":1}}],[\"下面将展示gpt2block模块的实现逻辑\",{\"1\":{\"544\":1}}],[\"下面将给出使用了\",{\"1\":{\"544\":1}}],[\"下面将给出captioner模块基于coco数据集\",{\"1\":{\"142\":1}}],[\"下面的3是因为我们用一次矩阵运算得到了拼接在一起的q\",{\"1\":{\"322\":1}}],[\"下面所给出的代码实现\",{\"1\":{\"322\":1}}],[\"下面来实际展示一下效果\",{\"1\":{\"303\":1}}],[\"下面会分小节独立对每个学习任务的计算过程进行详解\",{\"1\":{\"275\":1}}],[\"下面我们通过代码详细来看一下具体实现细节\",{\"1\":{\"815\":1}}],[\"下面我们将进入训练流程\",{\"1\":{\"327\":1}}],[\"下面我们将用于图片变换的transforms流水线和上面自定义的mydataset类都封装到dataloader去\",{\"1\":{\"317\":1}}],[\"下面我们将结合上面的模版流程\",{\"1\":{\"273\":1}}],[\"下面我们来看看论文中ltm的例子\",{\"1\":{\"503\":1}}],[\"下面我们来看论文中给的self\",{\"1\":{\"502\":1}}],[\"下面我们来看论文中给的cot的例子\",{\"1\":{\"501\":1}}],[\"下面我们来看\",{\"1\":{\"186\":1}}],[\"下面首先给出的是\",{\"1\":{\"147\":1}}],[\"下面先给出完整代码实现\",{\"1\":{\"590\":1}}],[\"下面先给出\",{\"1\":{\"145\":1}}],[\"下面详细介绍一下动态卷机核卷积的过程\",{\"1\":{\"76\":1}}],[\"下面只需要把以上的三个步骤按流程组织起来即可得到afm模块的完整实现了\",{\"1\":{\"75\":1}}],[\"下降了\",{\"1\":{\"24\":1}}],[\"下均显著优于现有方法\",{\"1\":{\"23\":1}}],[\"无偏调整前的\",{\"1\":{\"826\":1}}],[\"无判别器\",{\"1\":{\"816\":1}}],[\"无条件\",{\"1\":{\"816\":2}}],[\"无条件预测\",{\"1\":{\"816\":1}}],[\"无条件引导技术\",{\"0\":{\"816\":1}}],[\"无条件生成\",{\"1\":{\"815\":1}}],[\"无病\",{\"1\":{\"731\":1}}],[\"无限信息\",{\"1\":{\"873\":1}}],[\"无限多种可能的区间组合\",{\"1\":{\"728\":1}}],[\"无限接近于\",{\"1\":{\"246\":1}}],[\"无所不知\",{\"1\":{\"708\":1}}],[\"无所不能\",{\"1\":{\"708\":1}}],[\"无缝理解和生成多种形式内容\",{\"1\":{\"704\":1}}],[\"无外部数据\",{\"1\":{\"566\":1}}],[\"无提示时\",{\"1\":{\"538\":1}}],[\"无害\",{\"1\":{\"535\":1}}],[\"无梯度更新的few\",{\"1\":{\"531\":1}}],[\"无任务特定架构\",{\"1\":{\"531\":1}}],[\"无关的常数\",{\"1\":{\"758\":1}}],[\"无关\",{\"1\":{\"455\":1,\"867\":1,\"873\":1}}],[\"无放回采样\",{\"1\":{\"403\":1}}],[\"无干扰\",{\"1\":{\"274\":1}}],[\"无监督任务学习作为预训练技术成功的关键因素\",{\"1\":{\"523\":1}}],[\"无监督任务学习是预训练技术成功的关键因素之一\",{\"1\":{\"520\":1}}],[\"无监督多任务学习的可行性证明\",{\"1\":{\"521\":1}}],[\"无监督预训练+监督微调方式\",{\"1\":{\"508\":1}}],[\"无监督预训练\",{\"0\":{\"510\":1},\"1\":{\"508\":1,\"514\":1}}],[\"无监督学习得到的好的表示也能提供显著的提升\",{\"1\":{\"507\":1}}],[\"无监督学习最大的一个卖点\",{\"1\":{\"246\":1}}],[\"无监督学习的表现往往不如有监督学习\",{\"1\":{\"246\":1}}],[\"无监督学习真的可行\",{\"1\":{\"241\":1}}],[\"无监督就很难去建模\",{\"1\":{\"246\":1}}],[\"无权重衰减\",{\"1\":{\"212\":1}}],[\"无意义内容\",{\"1\":{\"198\":1}}],[\"无意图推理\",{\"1\":{\"24\":1}}],[\"无multi\",{\"1\":{\"184\":1}}],[\"无论\",{\"1\":{\"853\":1}}],[\"无论计算图结构多复杂\",{\"1\":{\"692\":1}}],[\"无论预处理方式\",{\"1\":{\"521\":1}}],[\"无论到什么程度\",{\"1\":{\"507\":1}}],[\"无论其有效性如何\",{\"1\":{\"442\":1}}],[\"无论是正类还是负类\",{\"1\":{\"443\":1}}],[\"无论是有监督还是自监督方法\",{\"1\":{\"305\":1}}],[\"无论是vit还是resnet\",{\"1\":{\"182\":1}}],[\"无论你如何打乱输入元素的顺序\",{\"1\":{\"115\":1}}],[\"无标签数据\",{\"1\":{\"705\":1}}],[\"无标签的\",{\"1\":{\"179\":1}}],[\"无标签的知识蒸馏\",{\"1\":{\"173\":1}}],[\"无标签场景\",{\"1\":{\"176\":1}}],[\"无须区分图像的学习方法\",{\"1\":{\"175\":1}}],[\"无序性\",{\"1\":{\"114\":1}}],[\"无需强行约束\",{\"1\":{\"853\":1}}],[\"无需人工标注即可通过自注意力机制学习语义区域和物体边界\",{\"1\":{\"766\":1}}],[\"无需重新训练\",{\"1\":{\"711\":1}}],[\"无需\",{\"1\":{\"704\":1}}],[\"无需手动推导导数公式\",{\"1\":{\"692\":1}}],[\"无需计算导数\",{\"1\":{\"688\":1}}],[\"无需等待gc\",{\"1\":{\"687\":1}}],[\"无需额外接口\",{\"1\":{\"692\":1}}],[\"无需额外预处理\",{\"1\":{\"562\":1}}],[\"无需额外架构调整\",{\"1\":{\"527\":1}}],[\"无需复杂结构调整\",{\"1\":{\"567\":1}}],[\"无需复杂架构调整\",{\"1\":{\"550\":1}}],[\"无需复制数据\",{\"1\":{\"562\":1}}],[\"无需参数更新\",{\"1\":{\"528\":1}}],[\"无需任务特定的监督训练\",{\"1\":{\"519\":1}}],[\"无需对架构或归一化方式做修改\",{\"1\":{\"173\":1}}],[\"无需预处理\",{\"1\":{\"112\":1}}],[\"无需切分\",{\"1\":{\"31\":1}}],[\"无局部聚合机制\",{\"1\":{\"112\":1}}],[\"无法闭式求解\",{\"1\":{\"869\":1}}],[\"无法精确计算的问题\",{\"1\":{\"867\":1}}],[\"无法直接计算\",{\"1\":{\"869\":1}}],[\"无法直接使用\",{\"1\":{\"766\":1}}],[\"无法直接用于每个点\",{\"1\":{\"111\":1}}],[\"无法及时反映最新的信息动态\",{\"1\":{\"709\":1}}],[\"无法回收\",{\"1\":{\"687\":1}}],[\"无法回答时\",{\"1\":{\"236\":1}}],[\"无法\",{\"1\":{\"616\":1}}],[\"无法利用结构化监督信号\",{\"1\":{\"530\":1}}],[\"无法更新参数\",{\"1\":{\"493\":1}}],[\"无法实现zero\",{\"1\":{\"305\":1}}],[\"无法模拟整个数据集\",{\"1\":{\"248\":1}}],[\"无法收敛\",{\"1\":{\"178\":1}}],[\"无法充分利用\",{\"1\":{\"112\":1}}],[\"无法区分顺序信息\",{\"1\":{\"112\":1}}],[\"无法有效利用局部结构\",{\"1\":{\"112\":1}}],[\"无法捕捉边缘\",{\"1\":{\"112\":1}}],[\"无法应对弯曲\",{\"1\":{\"112\":1}}],[\"无法像离散情形那样枚举所有子集\",{\"1\":{\"728\":1}}],[\"无法像\",{\"1\":{\"112\":1}}],[\"无法处理不在原文中的答案\",{\"1\":{\"616\":1}}],[\"无法处理非刚性变形\",{\"1\":{\"112\":1}}],[\"无法处理非刚性形变\",{\"1\":{\"112\":2}}],[\"无法处理开放词汇场景\",{\"1\":{\"7\":1}}],[\"无效\",{\"1\":{\"92\":1}}],[\"无相机参数方法\",{\"1\":{\"52\":1}}],[\"无\",{\"1\":{\"24\":1,\"204\":1,\"544\":1}}],[\"无跨模态融合\",{\"1\":{\"24\":1}}],[\"无几何推理\",{\"1\":{\"24\":1}}],[\"✗\",{\"1\":{\"24\":4}}],[\"表大小\",{\"1\":{\"590\":1}}],[\"表9\",{\"1\":{\"549\":1}}],[\"表5\",{\"1\":{\"549\":1}}],[\"表7\",{\"1\":{\"547\":1,\"549\":1}}],[\"表7展示了在\",{\"1\":{\"268\":1}}],[\"表8\",{\"1\":{\"547\":1,\"549\":1}}],[\"表征学习\",{\"0\":{\"309\":1},\"1\":{\"309\":1}}],[\"表征会很细\",{\"1\":{\"243\":1}}],[\"表征不一致\",{\"1\":{\"189\":1}}],[\"表征空间\",{\"1\":{\"186\":1}}],[\"表征\",{\"1\":{\"163\":1,\"167\":1,\"248\":1}}],[\"表征作为跨模态图文对表示\",{\"1\":{\"162\":1}}],[\"表征作为图文对的联合表示\",{\"1\":{\"156\":1}}],[\"表征映射到归一化的低维\",{\"1\":{\"154\":1}}],[\"表\",{\"1\":{\"137\":1,\"198\":4,\"537\":1,\"559\":1,\"590\":1,\"780\":1}}],[\"表4\",{\"1\":{\"134\":1,\"547\":1,\"549\":1}}],[\"表23列出了三种配置的超参数\",{\"1\":{\"213\":1}}],[\"表2\",{\"1\":{\"133\":1}}],[\"表14\",{\"1\":{\"551\":1}}],[\"表16\",{\"1\":{\"550\":1}}],[\"表13\",{\"1\":{\"549\":1,\"551\":1}}],[\"表13展示gpt\",{\"1\":{\"522\":1}}],[\"表10\",{\"1\":{\"549\":1,\"550\":1}}],[\"表11\",{\"1\":{\"547\":1,\"549\":1,\"551\":1}}],[\"表12\",{\"1\":{\"547\":1,\"549\":1,\"551\":1}}],[\"表1\",{\"1\":{\"132\":1,\"197\":1}}],[\"表达\",{\"1\":{\"800\":1}}],[\"表达不同维度之间的\",{\"1\":{\"455\":1}}],[\"表达能力增长方式\",{\"1\":{\"385\":1}}],[\"表达能力受限于\",{\"1\":{\"112\":1,\"239\":1}}],[\"表达式语言\",{\"1\":{\"714\":1,\"715\":1}}],[\"表达式\",{\"1\":{\"76\":1,\"354\":1,\"367\":1}}],[\"表现优于gpt\",{\"1\":{\"551\":1}}],[\"表现接近palm\",{\"1\":{\"549\":1}}],[\"表现出诸如捏造事实\",{\"1\":{\"535\":1}}],[\"表现不稳定的问题\",{\"1\":{\"531\":1}}],[\"表现不错\",{\"1\":{\"112\":1}}],[\"表现仍然较弱\",{\"1\":{\"530\":1}}],[\"表现远不如fine\",{\"1\":{\"529\":1}}],[\"表现则不及微调模型\",{\"1\":{\"529\":1}}],[\"表现为\",{\"1\":{\"520\":1}}],[\"表现类似\",{\"1\":{\"467\":1}}],[\"表现\",{\"1\":{\"138\":1,\"202\":1,\"507\":1}}],[\"表现良好\",{\"1\":{\"112\":1}}],[\"表明训练目标的改变\",{\"1\":{\"535\":1}}],[\"表明缩放定律\",{\"1\":{\"527\":1}}],[\"表明模型容量和训练数据规模仍需进一步扩大\",{\"1\":{\"523\":1}}],[\"表明模型容量是限制因素\",{\"1\":{\"522\":1}}],[\"表明进一步扩大模型和数据规模可能带来额外提升\",{\"1\":{\"522\":1}}],[\"表明进一步扩大数据或模型可能提升性能\",{\"1\":{\"521\":1}}],[\"表明在迁移中\",{\"1\":{\"516\":1}}],[\"表明\",{\"1\":{\"112\":1,\"183\":1,\"268\":3,\"522\":1}}],[\"表明交互意图推理对泛化至新\",{\"1\":{\"24\":1}}],[\"表面纹理等\",{\"1\":{\"112\":1}}],[\"表示给定潜变量\",{\"1\":{\"865\":1}}],[\"表示输出的\",{\"1\":{\"848\":1}}],[\"表示输入结束\",{\"1\":{\"235\":1}}],[\"表示还原为图像\",{\"1\":{\"821\":1}}],[\"表示保留\",{\"1\":{\"818\":1}}],[\"表示保持原来的大小\",{\"1\":{\"364\":1}}],[\"表示由\",{\"1\":{\"807\":3}}],[\"表示需要\",{\"1\":{\"804\":1}}],[\"表示只输出被\",{\"1\":{\"803\":1}}],[\"表示只在通道维度操作\",{\"1\":{\"107\":1}}],[\"表示哪些\",{\"1\":{\"803\":1}}],[\"表示哪些点属于目标功能区域\",{\"1\":{\"70\":1}}],[\"表示解码器\",{\"1\":{\"773\":1}}],[\"表示视觉令牌\",{\"1\":{\"773\":1}}],[\"表示原始图像\",{\"1\":{\"773\":1}}],[\"表示训练语料库\",{\"1\":{\"772\":1}}],[\"表示第\",{\"1\":{\"771\":1,\"776\":1}}],[\"表示为\",{\"1\":{\"769\":1,\"771\":1}}],[\"表示我们省略了分母\",{\"1\":{\"758\":1}}],[\"表示变量之间不相关\",{\"1\":{\"752\":1}}],[\"表示变量之间的相关性\",{\"1\":{\"455\":1}}],[\"表示分布的维度\",{\"1\":{\"868\":1}}],[\"表示分布的方差\",{\"1\":{\"746\":1}}],[\"表示分布的均值\",{\"1\":{\"746\":1}}],[\"表示成功的次数\",{\"1\":{\"741\":1}}],[\"表示成一个\",{\"1\":{\"738\":1}}],[\"表示这\",{\"1\":{\"740\":1}}],[\"表示这些位置不计入损失\",{\"1\":{\"276\":1}}],[\"表示类别概率的加权和\",{\"1\":{\"795\":1}}],[\"表示类别\",{\"1\":{\"738\":1}}],[\"表示当前样本属于第\",{\"1\":{\"738\":1}}],[\"表示当\",{\"1\":{\"738\":1}}],[\"表示选择类别\",{\"1\":{\"738\":1}}],[\"表示选择剩余所有维度\",{\"1\":{\"355\":1}}],[\"表示事件\",{\"1\":{\"729\":1}}],[\"表示正面\",{\"1\":{\"727\":1,\"826\":1}}],[\"表示正确对随机正例和负例进行排名的概率为\",{\"1\":{\"451\":1}}],[\"表示骰子掷出面为\",{\"1\":{\"727\":2}}],[\"表示实验中所有可能的结果组成的集合\",{\"1\":{\"726\":1}}],[\"表示将张量中的值限制在\",{\"1\":{\"615\":1}}],[\"表示注意力头数\",{\"1\":{\"591\":1}}],[\"表示要相乘后求和\",{\"1\":{\"590\":1}}],[\"表示编码维度\",{\"1\":{\"587\":1}}],[\"表示计算哪个位置的编码\",{\"1\":{\"587\":1}}],[\"表示位置索引\",{\"1\":{\"587\":1}}],[\"表示是否是连续句子\",{\"1\":{\"580\":1}}],[\"表示单词结束\",{\"1\":{\"476\":2}}],[\"表示对\",{\"1\":{\"470\":1}}],[\"表示对输入文本做\",{\"1\":{\"276\":1}}],[\"表示阈值\",{\"1\":{\"453\":1}}],[\"表示在假设\",{\"1\":{\"758\":1}}],[\"表示在我们看到任何数据之前\",{\"1\":{\"758\":1}}],[\"表示在这过程中抽到的\",{\"1\":{\"741\":1}}],[\"表示在行方向移动时\",{\"1\":{\"427\":1}}],[\"表示在最后一个维度的左侧填充1个元素\",{\"1\":{\"369\":1}}],[\"表示两分布差异最大\",{\"1\":{\"838\":1}}],[\"表示两行两列\",{\"1\":{\"425\":1}}],[\"表示两个向量方向相反\",{\"1\":{\"391\":1}}],[\"表示两个向量方向越接近\",{\"1\":{\"391\":1}}],[\"表示两个向量几乎正交\",{\"1\":{\"391\":1}}],[\"表示新视图从原始内存块中的哪个位置开始\",{\"1\":{\"425\":1}}],[\"表示比例\",{\"1\":{\"398\":1}}],[\"表示取最接近的整数索引\",{\"1\":{\"389\":1}}],[\"表示按照掩码位置\",{\"1\":{\"772\":1}}],[\"表示按列累加\",{\"1\":{\"379\":1}}],[\"表示按行累加\",{\"1\":{\"379\":1}}],[\"表示整数\",{\"1\":{\"377\":1}}],[\"表示先占位\",{\"1\":{\"366\":1}}],[\"表示向下取整的除法\",{\"1\":{\"354\":1}}],[\"表示模型更\",{\"1\":{\"538\":1}}],[\"表示模型的规模\",{\"1\":{\"327\":1}}],[\"表示模型预测的被\",{\"1\":{\"155\":1}}],[\"表示不强化\",{\"1\":{\"817\":1}}],[\"表示不在反向传播中参与梯度计算\",{\"1\":{\"796\":1}}],[\"表示不同变量之间的线性相关性\",{\"1\":{\"455\":1}}],[\"表示不进行归一化\",{\"1\":{\"318\":2}}],[\"表示不对图像做掩码\",{\"1\":{\"276\":1}}],[\"表示多模态\",{\"1\":{\"272\":1}}],[\"表示所有方向的方差相同\",{\"1\":{\"752\":2}}],[\"表示所有可能的实验结果\",{\"1\":{\"727\":1}}],[\"表示所有图像token有效\",{\"1\":{\"313\":1}}],[\"表示所有\",{\"1\":{\"272\":1}}],[\"表示进行图文对比学习\",{\"1\":{\"262\":1}}],[\"表示返回每个唯一值的计数\",{\"1\":{\"186\":1}}],[\"表示发生崩溃\",{\"1\":{\"183\":1}}],[\"表示停止梯度操作\",{\"1\":{\"167\":1}}],[\"表示无\",{\"1\":{\"161\":1}}],[\"表示被遮挡\",{\"1\":{\"773\":1}}],[\"表示被\",{\"1\":{\"155\":1}}],[\"表示图像编码器\",{\"1\":{\"773\":1}}],[\"表示图像特征没有被\",{\"1\":{\"143\":1}}],[\"表示图文对的真实匹配状态\",{\"1\":{\"156\":1}}],[\"表示图文对的多模态表示\",{\"1\":{\"126\":1}}],[\"表示结束\",{\"1\":{\"126\":1}}],[\"表示形式\",{\"1\":{\"114\":1}}],[\"表示最原始的点云\",{\"1\":{\"101\":1}}],[\"表示每一层mlp的输出通道数\",{\"1\":{\"100\":1}}],[\"表示每个类别的权重\",{\"1\":{\"399\":1}}],[\"表示每个元素在唯一值张量中的索引\",{\"1\":{\"372\":1}}],[\"表示每个图像块的大小是\",{\"1\":{\"317\":1}}],[\"表示每个样本和每个中心的相似度\",{\"1\":{\"170\":1}}],[\"表示每个\",{\"1\":{\"76\":1,\"591\":1}}],[\"表示每个点是否属于目标功能区域\",{\"1\":{\"470\":1}}],[\"表示每个点是否具有可操作性\",{\"1\":{\"46\":1}}],[\"表示每个点是否具有特定可操作性的概率\",{\"1\":{\"40\":1}}],[\"表示每个点属于功能区域的概率\",{\"1\":{\"470\":1}}],[\"表示每个点属于目标功能区域的概率\",{\"1\":{\"76\":1}}],[\"表示其属于目标功能区域的概率\",{\"1\":{\"76\":1}}],[\"表示该位置的图像特征\",{\"1\":{\"885\":1}}],[\"表示该函数中不进行梯度计算\",{\"1\":{\"820\":1}}],[\"表示该模型优于左侧曲线对应的模型\",{\"1\":{\"453\":1}}],[\"表示该维度上复制的次数\",{\"1\":{\"363\":1}}],[\"表示该层点数\",{\"1\":{\"72\":1}}],[\"表示该点是否具有可操作性\",{\"1\":{\"46\":1}}],[\"表示点属于该功能区域的概率\",{\"1\":{\"64\":1}}],[\"表示概率\",{\"1\":{\"46\":1}}],[\"表示填充\",{\"1\":{\"43\":1}}],[\"表示有效\",{\"1\":{\"43\":1}}],[\"表示\",{\"1\":{\"41\":2,\"76\":1,\"92\":1,\"107\":1,\"109\":1,\"157\":1,\"163\":1,\"167\":1,\"277\":1,\"312\":1,\"355\":1,\"379\":3,\"423\":1,\"451\":1,\"463\":1,\"580\":1,\"591\":4,\"594\":1,\"727\":1,\"801\":1,\"804\":4,\"809\":2,\"821\":1,\"822\":1,\"866\":1,\"872\":1,\"885\":1,\"886\":2}}],[\"表示池化后扩展为\",{\"1\":{\"14\":1}}],[\"表3\",{\"1\":{\"24\":1,\"134\":1,\"547\":1,\"549\":1}}],[\"0表示未遮挡\",{\"1\":{\"801\":1}}],[\"0时\",{\"1\":{\"690\":1}}],[\"0+cu113\",{\"1\":{\"620\":1}}],[\"0~255\",{\"1\":{\"848\":1}}],[\"0~total\",{\"1\":{\"814\":1}}],[\"0~seq\",{\"1\":{\"814\":1}}],[\"0~num\",{\"1\":{\"591\":3}}],[\"0~100\",{\"1\":{\"459\":1}}],[\"0~1\",{\"1\":{\"46\":1,\"398\":1}}],[\"0和sst\",{\"1\":{\"564\":1}}],[\"0分\",{\"1\":{\"551\":1}}],[\"0或1\",{\"1\":{\"470\":1}}],[\"08612\",{\"1\":{\"821\":1}}],[\"087\",{\"1\":{\"551\":1}}],[\"081\",{\"1\":{\"549\":1,\"551\":1}}],[\"08\",{\"1\":{\"237\":1,\"387\":1}}],[\"08485\",{\"1\":{\"231\":1}}],[\"0到1\",{\"1\":{\"218\":1}}],[\"01\",{\"1\":{\"201\":1,\"581\":1}}],[\"012个点云和5\",{\"1\":{\"49\":1}}],[\"02\",{\"1\":{\"272\":2,\"319\":1,\"320\":2,\"323\":2,\"774\":2}}],[\"02等\",{\"1\":{\"191\":1}}],[\"02413\",{\"1\":{\"85\":1}}],[\"04\",{\"1\":{\"179\":2,\"692\":2}}],[\"04744\",{\"1\":{\"37\":1}}],[\"0001\",{\"1\":{\"878\":1}}],[\"0002\",{\"1\":{\"840\":1}}],[\"000+基词\",{\"1\":{\"521\":1}}],[\"000\",{\"1\":{\"234\":1,\"235\":4,\"514\":1,\"560\":1}}],[\"001\",{\"1\":{\"160\":1,\"697\":3}}],[\"00593\",{\"1\":{\"102\":1}}],[\"07\",{\"1\":{\"145\":1,\"147\":1,\"160\":1,\"179\":1,\"254\":2}}],[\"093\",{\"1\":{\"75\":1,\"82\":1}}],[\"0387\",{\"1\":{\"866\":1}}],[\"03b\",{\"1\":{\"198\":1}}],[\"03\",{\"1\":{\"24\":1,\"593\":1}}],[\"0\",{\"0\":{\"187\":1,\"231\":1,\"316\":1},\"1\":{\"23\":2,\"29\":46,\"30\":1,\"32\":2,\"34\":1,\"35\":14,\"36\":2,\"41\":3,\"43\":4,\"45\":2,\"46\":12,\"58\":25,\"59\":22,\"64\":1,\"68\":4,\"70\":11,\"75\":4,\"76\":2,\"78\":4,\"80\":2,\"81\":2,\"82\":17,\"83\":9,\"92\":12,\"93\":2,\"96\":14,\"98\":1,\"100\":6,\"101\":2,\"107\":8,\"108\":1,\"109\":1,\"111\":1,\"127\":1,\"131\":1,\"142\":3,\"143\":3,\"145\":61,\"146\":4,\"147\":14,\"154\":1,\"157\":1,\"159\":4,\"160\":4,\"161\":5,\"162\":6,\"163\":6,\"170\":8,\"178\":1,\"179\":4,\"186\":27,\"187\":1,\"202\":1,\"208\":2,\"209\":1,\"211\":2,\"212\":1,\"231\":1,\"234\":8,\"236\":1,\"237\":1,\"248\":3,\"249\":1,\"252\":14,\"254\":4,\"255\":1,\"256\":1,\"257\":3,\"272\":29,\"274\":10,\"275\":1,\"276\":5,\"277\":11,\"278\":6,\"289\":1,\"293\":1,\"295\":2,\"300\":1,\"302\":1,\"304\":1,\"309\":2,\"310\":2,\"311\":5,\"312\":9,\"313\":3,\"316\":2,\"317\":23,\"318\":3,\"319\":3,\"320\":3,\"321\":2,\"322\":3,\"323\":6,\"332\":6,\"348\":2,\"355\":1,\"358\":1,\"360\":1,\"361\":1,\"364\":1,\"369\":9,\"371\":1,\"372\":2,\"374\":3,\"375\":2,\"376\":2,\"377\":15,\"378\":1,\"379\":1,\"387\":14,\"391\":1,\"398\":5,\"399\":13,\"401\":8,\"403\":1,\"421\":1,\"422\":2,\"423\":5,\"426\":1,\"427\":5,\"443\":1,\"444\":1,\"445\":3,\"446\":1,\"448\":2,\"450\":4,\"451\":6,\"453\":1,\"455\":4,\"463\":19,\"467\":2,\"468\":1,\"469\":6,\"470\":6,\"471\":4,\"473\":10,\"476\":4,\"477\":3,\"478\":5,\"492\":3,\"493\":10,\"514\":6,\"515\":1,\"522\":1,\"529\":1,\"537\":1,\"541\":7,\"544\":6,\"548\":1,\"549\":3,\"551\":2,\"559\":1,\"561\":1,\"565\":2,\"566\":2,\"573\":9,\"577\":2,\"578\":1,\"579\":2,\"580\":1,\"581\":3,\"582\":2,\"590\":19,\"591\":56,\"593\":1,\"594\":29,\"597\":1,\"599\":1,\"601\":1,\"602\":2,\"605\":2,\"609\":1,\"615\":3,\"616\":1,\"617\":1,\"620\":1,\"627\":1,\"630\":1,\"632\":3,\"638\":4,\"647\":1,\"662\":1,\"675\":4,\"681\":1,\"684\":1,\"685\":1,\"686\":3,\"688\":6,\"689\":3,\"690\":15,\"692\":18,\"696\":4,\"697\":43,\"704\":15,\"728\":2,\"731\":2,\"738\":2,\"747\":1,\"749\":1,\"752\":2,\"772\":1,\"774\":5,\"793\":3,\"794\":1,\"795\":1,\"798\":1,\"801\":9,\"802\":7,\"803\":1,\"804\":4,\"814\":33,\"815\":8,\"816\":1,\"817\":3,\"819\":2,\"820\":4,\"821\":13,\"822\":2,\"829\":2,\"831\":1,\"840\":16,\"843\":5,\"847\":1,\"848\":11,\"853\":5,\"854\":1,\"856\":1,\"857\":8,\"858\":1,\"859\":1,\"860\":1,\"861\":1,\"866\":2,\"867\":2,\"881\":1,\"882\":2,\"885\":7,\"886\":9}}],[\"05\",{\"1\":{\"23\":1,\"131\":1,\"186\":1,\"209\":1,\"236\":1,\"591\":1,\"731\":1,\"774\":1}}],[\"约占\",{\"1\":{\"817\":1}}],[\"约为主实验\",{\"1\":{\"780\":1}}],[\"约耗时五天\",{\"1\":{\"774\":1}}],[\"约40人\",{\"1\":{\"539\":1}}],[\"约4000多个样本\",{\"1\":{\"316\":1}}],[\"约束\",{\"1\":{\"536\":1}}],[\"约33\",{\"1\":{\"529\":1}}],[\"约95\",{\"1\":{\"522\":1}}],[\"约\",{\"1\":{\"23\":2,\"537\":1,\"774\":1}}],[\"8个头\",{\"1\":{\"632\":1}}],[\"88\",{\"1\":{\"565\":1}}],[\"889\",{\"1\":{\"17\":1}}],[\"84\",{\"1\":{\"564\":2}}],[\"8×32gb\",{\"1\":{\"561\":1}}],[\"8×8\",{\"1\":{\"181\":1}}],[\"8回退到字节级处理\",{\"1\":{\"548\":1}}],[\"8的语言建模基准上达到sota水平\",{\"1\":{\"524\":1}}],[\"8的数据集上刷新了零样本sota\",{\"1\":{\"522\":1}}],[\"8降至8\",{\"1\":{\"522\":1}}],[\"8以后支持\",{\"1\":{\"366\":1}}],[\"8b\",{\"1\":{\"199\":1,\"704\":5}}],[\"8bit=true\",{\"1\":{\"28\":1}}],[\"8600000\",{\"1\":{\"324\":1}}],[\"86×1000000\",{\"1\":{\"324\":1}}],[\"86m\",{\"1\":{\"324\":1}}],[\"86\",{\"1\":{\"140\":1}}],[\"896×1344\",{\"1\":{\"224\":1}}],[\"89\",{\"1\":{\"112\":1,\"522\":1,\"566\":2}}],[\"85\",{\"1\":{\"112\":1,\"202\":1,\"522\":1,\"529\":1,\"538\":1,\"731\":1}}],[\"87\",{\"1\":{\"75\":1,\"82\":1}}],[\"870\",{\"1\":{\"63\":2,\"65\":1,\"67\":1}}],[\"82\",{\"1\":{\"75\":1,\"201\":1,\"522\":1}}],[\"800\",{\"1\":{\"774\":1,\"780\":2}}],[\"8064\",{\"1\":{\"692\":1}}],[\"80gb\",{\"1\":{\"548\":1}}],[\"80层\",{\"1\":{\"548\":1}}],[\"80k\",{\"1\":{\"209\":1}}],[\"80\",{\"1\":{\"59\":3,\"163\":1,\"173\":1,\"186\":1,\"560\":1,\"572\":1,\"578\":2}}],[\"8\",{\"0\":{\"44\":1,\"69\":1},\"1\":{\"26\":1,\"34\":3,\"35\":6,\"40\":1,\"46\":2,\"59\":4,\"75\":1,\"80\":1,\"82\":2,\"96\":1,\"100\":1,\"101\":1,\"134\":1,\"161\":1,\"163\":1,\"173\":1,\"181\":1,\"185\":1,\"186\":1,\"196\":1,\"215\":1,\"276\":2,\"277\":2,\"333\":3,\"374\":2,\"387\":2,\"421\":2,\"422\":2,\"423\":1,\"425\":2,\"431\":1,\"470\":1,\"476\":5,\"477\":1,\"478\":7,\"494\":1,\"495\":2,\"515\":1,\"516\":1,\"529\":4,\"538\":1,\"539\":1,\"541\":1,\"549\":5,\"565\":1,\"566\":2,\"577\":3,\"578\":1,\"591\":2,\"632\":1,\"697\":1,\"704\":1,\"752\":1,\"759\":1,\"814\":1,\"815\":1,\"822\":2,\"840\":1,\"847\":1,\"848\":6,\"857\":7,\"868\":1,\"886\":3}}],[\"8192\",{\"1\":{\"250\":1,\"774\":1,\"807\":2,\"808\":1,\"809\":1}}],[\"81\",{\"1\":{\"23\":1,\"549\":1,\"566\":1}}],[\"依次通过每个编码器层\",{\"1\":{\"580\":1}}],[\"依此类推\",{\"1\":{\"422\":2}}],[\"依然称之为\",{\"1\":{\"179\":1}}],[\"依赖计算量大\",{\"1\":{\"864\":1}}],[\"依赖高质量的训练数\",{\"1\":{\"711\":1}}],[\"依赖于我们作出的一个假设\",{\"1\":{\"871\":1}}],[\"依赖于构建高质量的数据集\",{\"1\":{\"711\":1}}],[\"依赖于输入x的具体值\",{\"1\":{\"660\":1}}],[\"依赖任务特定的架构\",{\"1\":{\"527\":1}}],[\"依赖\",{\"1\":{\"438\":2}}],[\"依赖闭包机制来记住原函数的引用\",{\"1\":{\"341\":1}}],[\"依赖目标检测器\",{\"1\":{\"261\":1}}],[\"依赖浅层相似度计算\",{\"1\":{\"196\":1}}],[\"依赖视角选择\",{\"1\":{\"114\":1}}],[\"依赖初始点和距离度量方式的选择\",{\"1\":{\"89\":1}}],[\"依赖预定义类别\",{\"1\":{\"6\":1}}],[\"依旧表现出色\",{\"1\":{\"23\":1}}],[\"在嵌入空间里找最近邻\",{\"1\":{\"880\":1}}],[\"在后续文章中则被称作\",{\"1\":{\"878\":1}}],[\"在后续的文献中\",{\"1\":{\"847\":1}}],[\"在面对这种问题时\",{\"1\":{\"874\":1}}],[\"在面对带错误前提的指令时\",{\"1\":{\"538\":1}}],[\"在稀疏自编码器的目标函数中\",{\"1\":{\"873\":1}}],[\"在信息论中\",{\"1\":{\"872\":1}}],[\"在信息检索领域\",{\"1\":{\"708\":1}}],[\"在更实际设定下到底存在多少近似误差\",{\"1\":{\"871\":1}}],[\"在优化\",{\"1\":{\"870\":1}}],[\"在测试阶段\",{\"1\":{\"869\":2}}],[\"在测试集上调优模型\",{\"1\":{\"716\":1}}],[\"在固定\",{\"1\":{\"868\":1}}],[\"在固定计算预算下\",{\"1\":{\"547\":1}}],[\"在我们的设定中\",{\"1\":{\"868\":1}}],[\"在变分自编码器中\",{\"1\":{\"865\":1}}],[\"在变分推断中\",{\"1\":{\"807\":1}}],[\"在统计学里被称为自回归模型\",{\"1\":{\"847\":1}}],[\"在统计学中\",{\"1\":{\"825\":1}}],[\"在生成图像时\",{\"1\":{\"847\":1}}],[\"在生成每个像素时严格遵循\",{\"1\":{\"846\":1}}],[\"在和概率相关的指标上表现优秀\",{\"1\":{\"847\":1}}],[\"在正态分布假设下\",{\"1\":{\"826\":1}}],[\"在已有图像基础上补全未提供区域\",{\"1\":{\"817\":1}}],[\"在已知世界状态\",{\"1\":{\"759\":1}}],[\"在合并两部分损失时引入了一个\",{\"1\":{\"815\":1}}],[\"在合成任务和灵活性测试中展现强大泛化能力\",{\"1\":{\"529\":1}}],[\"在收敛时未发现过拟合迹象\",{\"1\":{\"809\":1}}],[\"在其\",{\"1\":{\"809\":1}}],[\"在其他任务\",{\"1\":{\"241\":1}}],[\"在松弛操作附近减小卷积感受野有助于其对真实\",{\"1\":{\"808\":1}}],[\"在编码器末端与解码器开头使用\",{\"1\":{\"808\":1}}],[\"在编程中\",{\"1\":{\"636\":1}}],[\"在log空间均匀采样后exp还原\",{\"1\":{\"801\":1}}],[\"在lambada数据集上\",{\"1\":{\"529\":1}}],[\"在类别维度上执行\",{\"1\":{\"795\":1}}],[\"在类别平衡时效果好\",{\"1\":{\"468\":1}}],[\"在下游视觉任务上微调\",{\"0\":{\"775\":1}}],[\"在下图中\",{\"1\":{\"712\":1}}],[\"在公式\",{\"1\":{\"758\":1}}],[\"在公开\",{\"1\":{\"538\":1}}],[\"在高维图像空间中\",{\"1\":{\"756\":1}}],[\"在高维空间中\",{\"1\":{\"459\":1,\"753\":2}}],[\"在高维空间\",{\"1\":{\"385\":1}}],[\"在二维空间中\",{\"1\":{\"752\":1}}],[\"在本代码中\",{\"1\":{\"798\":1}}],[\"在本节中\",{\"1\":{\"745\":1,\"751\":1}}],[\"在本文中\",{\"1\":{\"125\":1,\"507\":1}}],[\"在总共\",{\"1\":{\"738\":1}}],[\"在构建各种类型的模型时\",{\"1\":{\"735\":1}}],[\"在给定均值和协方差矩的约束下\",{\"1\":{\"750\":1}}],[\"在给定\",{\"1\":{\"730\":1,\"872\":1}}],[\"在事件\",{\"1\":{\"730\":1}}],[\"在事实型问答测试中\",{\"1\":{\"522\":1}}],[\"在有限的情况下\",{\"1\":{\"729\":1}}],[\"在持续时间的例子中\",{\"1\":{\"728\":1}}],[\"在线学习\",{\"0\":{\"722\":1}}],[\"在完成自监督预训练后\",{\"1\":{\"778\":1}}],[\"在完成\",{\"1\":{\"775\":1}}],[\"在完成前后端搭建之后\",{\"1\":{\"717\":1}}],[\"在完成上一步的初始化\",{\"1\":{\"717\":1}}],[\"在完全不做微调\",{\"1\":{\"173\":1}}],[\"在确定开发目标后\",{\"1\":{\"717\":1}}],[\"在验证集上最终验证模型效果来实现性能的评估\",{\"1\":{\"716\":1}}],[\"在开发过程中\",{\"1\":{\"713\":1}}],[\"在开源模型中领先\",{\"1\":{\"228\":1}}],[\"在提升大语言模型效果中\",{\"1\":{\"711\":1}}],[\"在理解和生成长篇内容时受限于有限的上下文窗口\",{\"1\":{\"709\":1}}],[\"在处理\",{\"1\":{\"797\":1}}],[\"在处理特定领域的专业知识时\",{\"1\":{\"709\":1}}],[\"在处理各种任务时表现出色\",{\"1\":{\"706\":1}}],[\"在处理文本时具有强大的上下文感知能力\",{\"1\":{\"705\":1}}],[\"在处理浮点型的\",{\"1\":{\"387\":1}}],[\"在各种基准测试中均优于\",{\"1\":{\"704\":1}}],[\"在各种任务中的表现均显著提升\",{\"1\":{\"703\":1}}],[\"在遵循复杂指令\",{\"1\":{\"704\":1}}],[\"在国内率先开启邀测\",{\"1\":{\"704\":1}}],[\"在性能和效率上有显著提升\",{\"1\":{\"704\":1}}],[\"在回答前会先生成一段思维链\",{\"1\":{\"704\":1}}],[\"在回答简单问题时冗长解释或\",{\"1\":{\"538\":1}}],[\"在知识广度\",{\"1\":{\"704\":1}}],[\"在语音互动中传递更丰富的情感变化\",{\"1\":{\"704\":1}}],[\"在语义分割任务中\",{\"1\":{\"465\":1}}],[\"在解决复杂任务和评估任务上展现出较大的性能提升\",{\"1\":{\"704\":1}}],[\"在解码器中\",{\"1\":{\"622\":1}}],[\"在他的经典论文\",{\"1\":{\"703\":1}}],[\"在点上\",{\"1\":{\"697\":1}}],[\"在点云中逐步选择离已选点尽可能远的点\",{\"1\":{\"92\":1}}],[\"在第\",{\"1\":{\"810\":1}}],[\"在第二阶段中\",{\"1\":{\"809\":1}}],[\"在第四阶段\",{\"1\":{\"700\":1}}],[\"在第三阶段\",{\"1\":{\"695\":1}}],[\"在第一阶段训练中\",{\"1\":{\"808\":1}}],[\"在第一阶段\",{\"1\":{\"680\":1}}],[\"在接收输入时自动将参数转换为variable\",{\"1\":{\"690\":1}}],[\"在表达式a\",{\"1\":{\"690\":3}}],[\"在tinypytorch中\",{\"1\":{\"687\":2}}],[\"在transformer\",{\"1\":{\"323\":1}}],[\"在transformer中\",{\"1\":{\"320\":1}}],[\"在transformer模型中\",{\"1\":{\"314\":1}}],[\"在步骤14中\",{\"1\":{\"685\":1}}],[\"在反向传播过程中\",{\"1\":{\"684\":1}}],[\"在调用如\",{\"1\":{\"681\":1}}],[\"在variable的backward方法中自动初始化梯度\",{\"1\":{\"672\":1}}],[\"在variable类中添加name属性\",{\"1\":{\"689\":1}}],[\"在variable类中添加backward方法\",{\"1\":{\"665\":1}}],[\"在variable类中添加creator属性\",{\"1\":{\"664\":1}}],[\"在function类的\",{\"1\":{\"664\":1}}],[\"在few\",{\"1\":{\"528\":1}}],[\"在上一节中\",{\"1\":{\"879\":1}}],[\"在上下文明确的情况下\",{\"1\":{\"727\":1}}],[\"在上下文中找到最可能的答案起始位置和结束位置\",{\"1\":{\"616\":1}}],[\"在上面的推理过程中\",{\"1\":{\"541\":1}}],[\"在上面的例子中\",{\"1\":{\"502\":1}}],[\"在上面的结构图中可以看到\",{\"1\":{\"319\":1}}],[\"在问答任务中一般不会使用这个输出\",{\"1\":{\"614\":1}}],[\"在问答任务中\",{\"1\":{\"614\":1}}],[\"在问答上提升5\",{\"1\":{\"506\":1}}],[\"在返回前进行预处理\",{\"1\":{\"596\":1}}],[\"在标准\",{\"1\":{\"773\":1}}],[\"在标准自注意力中\",{\"1\":{\"590\":1}}],[\"在标准的\",{\"1\":{\"405\":1}}],[\"在注意力得分矩阵计算完毕后\",{\"1\":{\"584\":1}}],[\"在注意力机制\",{\"1\":{\"404\":1}}],[\"在glue\",{\"1\":{\"562\":1}}],[\"在gpt\",{\"1\":{\"531\":1}}],[\"在bert和roberta的预训练中\",{\"1\":{\"562\":1}}],[\"在boolq\",{\"1\":{\"529\":1}}],[\"在配备\",{\"1\":{\"561\":1}}],[\"在首轮推理的过程中\",{\"1\":{\"544\":1}}],[\"在偏见测试中未表现出优势\",{\"1\":{\"538\":1}}],[\"在加入指导性提示\",{\"1\":{\"538\":1}}],[\"在所有规模下均优于\",{\"1\":{\"538\":1}}],[\"在所有划分\",{\"1\":{\"23\":1}}],[\"在用户任务分布中\",{\"1\":{\"538\":1}}],[\"在用户偏好评估中仍表现更优\",{\"1\":{\"534\":1}}],[\"在三个参数规模\",{\"1\":{\"537\":1}}],[\"在人类偏好标注中\",{\"1\":{\"537\":1}}],[\"在使用\",{\"1\":{\"614\":1}}],[\"在使用gpt\",{\"1\":{\"530\":1}}],[\"在使用cot这种prompt\",{\"1\":{\"501\":1}}],[\"在使用clip模型进行zero\",{\"1\":{\"301\":1}}],[\"在特定任务上\",{\"1\":{\"530\":1}}],[\"在特定任务相关的数据集上执行有监督全量参数微调\",{\"1\":{\"490\":1}}],[\"在某些特定情形下\",{\"1\":{\"871\":1}}],[\"在某些问题中\",{\"1\":{\"747\":1}}],[\"在某些任务中可与sota模型媲美\",{\"1\":{\"530\":1}}],[\"在某些标准数据集\",{\"1\":{\"112\":1}}],[\"在zero\",{\"1\":{\"529\":1}}],[\"在阅读理解任务中\",{\"1\":{\"529\":1}}],[\"在没有使用外部检索信息\",{\"1\":{\"529\":1}}],[\"在封闭式问答任务中接近甚至超越sota\",{\"1\":{\"529\":1}}],[\"在任务特定数据集上更新模型权重\",{\"1\":{\"528\":1}}],[\"在少样本设置下\",{\"1\":{\"527\":1}}],[\"在one\",{\"1\":{\"522\":1}}],[\"在webtext验证集上仍未完全收敛\",{\"1\":{\"522\":1}}],[\"在nli和qqp任务上辅助lm目标有帮助\",{\"1\":{\"516\":1}}],[\"在nlp中\",{\"1\":{\"507\":1}}],[\"在nlp领域\",{\"1\":{\"305\":1}}],[\"在文章末尾添加\",{\"1\":{\"521\":1}}],[\"在文档和问题给定条件下\",{\"1\":{\"516\":1}}],[\"在文本序列开头加上\",{\"1\":{\"815\":1}}],[\"在文本词索引空间中的起始索引\",{\"1\":{\"815\":1}}],[\"在文本单模态数据上预训练语言专家\",{\"1\":{\"260\":1}}],[\"在文本前添加\",{\"1\":{\"126\":1}}],[\"在阈值下进行预测的\",{\"1\":{\"516\":1}}],[\"在零样本上\",{\"1\":{\"516\":1}}],[\"在应用到很多任务时可以提高语言建模的能力并且transformer更具结构化的注意力记忆\",{\"1\":{\"516\":1}}],[\"在superglue基准测试中\",{\"1\":{\"529\":1}}],[\"在sts\",{\"1\":{\"515\":1}}],[\"在storycloze和hellaswag等故事完形任务中\",{\"1\":{\"529\":1}}],[\"在story\",{\"1\":{\"515\":1}}],[\"在seq\",{\"1\":{\"311\":1}}],[\"在句子级别打乱顺序以破坏长距离结构信息\",{\"1\":{\"514\":1}}],[\"在作者的实验中\",{\"1\":{\"510\":1}}],[\"在迁移阶段\",{\"1\":{\"507\":1}}],[\"在迁移到其他数据集时也需要加上新的分类器进行有监督训练\",{\"1\":{\"305\":1}}],[\"在迁移到下游任务时\",{\"1\":{\"305\":1}}],[\"在12个的9个数据集取得了sota结果\",{\"1\":{\"517\":1}}],[\"在12个数据集上的9个取得sota结果\",{\"1\":{\"515\":1}}],[\"在12个研究任务中9个提升到sota\",{\"1\":{\"506\":1,\"507\":1}}],[\"在18个多模态基准测试中展现出媲美商业模型的性能\",{\"1\":{\"230\":1}}],[\"在原始预训练语言模型\",{\"1\":{\"492\":1}}],[\"在原始点数量下的每个点都拥有一个合理的特征向量\",{\"1\":{\"100\":1}}],[\"在微调完成后\",{\"1\":{\"490\":1}}],[\"在微调过程中\",{\"1\":{\"490\":1}}],[\"在准备好的数据集上\",{\"1\":{\"490\":1}}],[\"在推理大模型方面\",{\"1\":{\"704\":1}}],[\"在推理方面就十分出色\",{\"1\":{\"704\":1}}],[\"在推理能力\",{\"1\":{\"704\":1}}],[\"在推理型模型中可选择性展示思考过程\",{\"1\":{\"704\":1}}],[\"在推理阶段可以从\",{\"1\":{\"857\":1}}],[\"在推理阶段\",{\"1\":{\"688\":1}}],[\"在推理阶段用文本输入指定任务\",{\"1\":{\"531\":1}}],[\"在推理时为模型提供10\",{\"1\":{\"528\":1}}],[\"在推理过程中\",{\"1\":{\"492\":1}}],[\"在推理的过程中直接将∆w加到w上去\",{\"1\":{\"487\":1}}],[\"在推动通用人工智能\",{\"1\":{\"216\":1}}],[\"在python开发中\",{\"1\":{\"691\":1}}],[\"在python的运算符重载中\",{\"1\":{\"690\":1}}],[\"在python中\",{\"1\":{\"690\":1}}],[\"在prompt中加入的示例不是1条\",{\"1\":{\"501\":1}}],[\"在prompt中加入一些示例\",{\"1\":{\"501\":1}}],[\"在prompt中加入一些例子\",{\"1\":{\"500\":1}}],[\"在prompt上下文中添加适当的条件\",{\"1\":{\"486\":1}}],[\"在pointnet中\",{\"1\":{\"86\":1}}],[\"在x前面加上了一些特定的内容\",{\"1\":{\"485\":1}}],[\"在具体执行特定任务的时候按需调用\",{\"1\":{\"485\":1}}],[\"在考虑数据分布形状后\",{\"1\":{\"459\":1}}],[\"在垃圾邮件分类器示例中\",{\"1\":{\"451\":1}}],[\"在垃圾邮件分类示例中\",{\"1\":{\"443\":1,\"444\":1,\"445\":1,\"446\":1,\"447\":1}}],[\"在评估思路上\",{\"1\":{\"716\":1}}],[\"在评估模型和选择阈值时\",{\"1\":{\"447\":1}}],[\"在评估阶段\",{\"1\":{\"274\":1}}],[\"在激活的\",{\"1\":{\"438\":1}}],[\"在当前环境下安装包\",{\"0\":{\"438\":1}}],[\"在逻辑上表现为每行都是\",{\"1\":{\"427\":1}}],[\"在逻辑转置中\",{\"1\":{\"426\":1}}],[\"在数学\",{\"1\":{\"704\":2}}],[\"在数学上\",{\"1\":{\"444\":1,\"446\":1,\"448\":1}}],[\"在数据预处理阶段\",{\"1\":{\"562\":1}}],[\"在数据方面\",{\"1\":{\"129\":1}}],[\"在数组运算中的底层实现原理\",{\"1\":{\"427\":1}}],[\"在内存中是行优先存储\",{\"1\":{\"425\":1}}],[\"在列优先顺序\",{\"1\":{\"422\":1}}],[\"在行优先顺序\",{\"1\":{\"422\":1}}],[\"在映射机制里\",{\"1\":{\"421\":1}}],[\"在机器学习\",{\"1\":{\"421\":1}}],[\"在目标检测任务中\",{\"1\":{\"386\":1}}],[\"在目标物体区域掩码之上\",{\"1\":{\"59\":1}}],[\"在思想上都体现了用更多自由度提升精度\",{\"1\":{\"385\":1}}],[\"在同一个模型内部做有条件与无条件两种预测\",{\"1\":{\"816\":1}}],[\"在同一设备上\",{\"1\":{\"378\":1}}],[\"在同一张交互图像中存在多个物体时\",{\"1\":{\"25\":1}}],[\"在末尾补\",{\"1\":{\"377\":1}}],[\"在最后一层的表示向量\",{\"1\":{\"776\":1}}],[\"在最后一个维度两边各填充2个\",{\"1\":{\"369\":1}}],[\"在最后一个维度左边不填充\",{\"1\":{\"369\":1}}],[\"在最后一个维度左边填充1个0\",{\"1\":{\"369\":1}}],[\"在最后加维度\",{\"1\":{\"355\":1}}],[\"在外面仍然可见\",{\"1\":{\"336\":1}}],[\"在如此大规模的数据集上进行预训练\",{\"1\":{\"327\":1}}],[\"在深度学习框架中\",{\"1\":{\"687\":1,\"690\":1}}],[\"在深度学习与生成模型中\",{\"1\":{\"455\":1}}],[\"在深度学习领域\",{\"1\":{\"324\":1}}],[\"在深层\",{\"1\":{\"272\":1}}],[\"在每次前向传播前将不允许访问的卷积核位置置零\",{\"1\":{\"848\":1}}],[\"在每一步中\",{\"1\":{\"712\":1}}],[\"在每一层\",{\"1\":{\"319\":1}}],[\"在每个\",{\"1\":{\"537\":1}}],[\"在每个小格子里撒几个点\",{\"1\":{\"387\":1}}],[\"在每个层上\",{\"1\":{\"88\":1}}],[\"在代码\",{\"1\":{\"538\":1,\"549\":1}}],[\"在代码中\",{\"1\":{\"318\":1,\"819\":1}}],[\"在代理任务上做文章\",{\"1\":{\"248\":1}}],[\"在柱状图上添加数值标签\",{\"1\":{\"316\":1}}],[\"在计算iou得分之前\",{\"1\":{\"472\":1}}],[\"在计算余弦相似度\",{\"1\":{\"393\":1}}],[\"在计算机视觉领域展现出强大潜力\",{\"1\":{\"766\":1}}],[\"在计算机视觉领域非常常用\",{\"1\":{\"395\":1}}],[\"在计算机视觉领域\",{\"1\":{\"305\":1,\"708\":1}}],[\"在计算成本和准确率之间取得了良好平衡\",{\"1\":{\"204\":1}}],[\"在imagenet数据集上可以提升1\",{\"1\":{\"301\":1}}],[\"在imagenet分类\",{\"1\":{\"189\":1}}],[\"在之前的问题上表现明显变差\",{\"1\":{\"491\":1}}],[\"在之前的例子中\",{\"1\":{\"301\":1}}],[\"在之前有很多优秀的对比学习工作\",{\"1\":{\"246\":1}}],[\"在一般情况下也不一定是高斯分布\",{\"1\":{\"871\":1}}],[\"在一些不够大的llm上\",{\"1\":{\"501\":1}}],[\"在一些数据集上的表现比不过c类方法\",{\"1\":{\"286\":1}}],[\"在一个掩码图像建模\",{\"1\":{\"767\":1}}],[\"在一个周期内只能包含少量相邻的位置\",{\"1\":{\"587\":1}}],[\"在一个简单的二维情况\",{\"1\":{\"426\":1}}],[\"在一个epoch内固定教师参数\",{\"1\":{\"178\":1}}],[\"在大模型开发中\",{\"1\":{\"716\":1}}],[\"在大部分任务中基本上\",{\"1\":{\"514\":1}}],[\"在大多数情况下\",{\"1\":{\"283\":1}}],[\"在大规模文本语料上学习高容量的语言模型\",{\"1\":{\"509\":1}}],[\"在大规模场景理解任务中表现一般\",{\"1\":{\"112\":1}}],[\"在大规模或实时应用中可能成为瓶颈\",{\"1\":{\"26\":1}}],[\"在网络深层中\",{\"1\":{\"282\":1}}],[\"在参数或者计算上\",{\"1\":{\"282\":1}}],[\"在融合层之后\",{\"1\":{\"277\":1}}],[\"在模拟环境中用人类反馈改进行为策略\",{\"1\":{\"536\":1}}],[\"在模版流程的各种阶段都做了什么\",{\"1\":{\"273\":1}}],[\"在模型训练和推理过程中\",{\"1\":{\"495\":1}}],[\"在模型训练时可能会出现问题\",{\"1\":{\"249\":1}}],[\"在模型架构中\",{\"1\":{\"326\":1}}],[\"在模型初始化时\",{\"1\":{\"320\":1}}],[\"在模型规模\",{\"1\":{\"196\":1}}],[\"在模型设计上提出了一个灵活\",{\"1\":{\"129\":1}}],[\"在拆分多模态输入时使用\",{\"1\":{\"272\":1}}],[\"在检索和分类任务中都优于标准\",{\"1\":{\"268\":1}}],[\"在图文检索中\",{\"1\":{\"302\":1}}],[\"在图文检索任务中\",{\"1\":{\"260\":1}}],[\"在图像或序列生成任务中\",{\"1\":{\"816\":1}}],[\"在图像与文本结合任务中\",{\"1\":{\"789\":1}}],[\"在图像单模态数据上预训练视觉专家和自注意力模块\",{\"1\":{\"260\":1}}],[\"在图像识别中加入\",{\"1\":{\"239\":1}}],[\"在图像分类和语义分割任务上优于从零训练的模型和其他自监督方法\",{\"1\":{\"766\":1}}],[\"在图像分类任务中\",{\"1\":{\"314\":1,\"326\":1}}],[\"在图像分类\",{\"1\":{\"205\":1}}],[\"在全局平均池化之后\",{\"1\":{\"255\":1}}],[\"在全参数微调下\",{\"1\":{\"201\":1}}],[\"在执行的时候\",{\"1\":{\"250\":1}}],[\"在蒸馏相关内容里其实提到过\",{\"1\":{\"248\":1}}],[\"在看\",{\"1\":{\"248\":1}}],[\"在损失函数上做文章\",{\"1\":{\"248\":1}}],[\"在预训练过程中\",{\"1\":{\"774\":1}}],[\"在预训练阶段随机掩码部分图像块并让模型预测原始视觉标记\",{\"1\":{\"765\":1}}],[\"在预训练阶段学习泛化模式\",{\"1\":{\"531\":1}}],[\"在预训练\",{\"1\":{\"571\":1}}],[\"在预训练层面进行数据过滤\",{\"1\":{\"539\":1}}],[\"在预训练和使用该模型时\",{\"1\":{\"327\":1}}],[\"在预训练时\",{\"1\":{\"317\":1,\"766\":1}}],[\"在预训练中使用更大规模的\",{\"1\":{\"269\":1}}],[\"在预训练的基础上\",{\"1\":{\"233\":1}}],[\"在预训练模型基础上继续使用\",{\"1\":{\"137\":1}}],[\"在copa任务中仅落后1\",{\"1\":{\"529\":1}}],[\"在cv领域\",{\"1\":{\"246\":1}}],[\"在chartqa和ocrbench上超越所有商业模型\",{\"1\":{\"228\":1}}],[\"在caption前添加prompt\",{\"1\":{\"142\":1}}],[\"在无标记数据上使用语言模型目标来学习神经网络初始化的参数\",{\"1\":{\"507\":1}}],[\"在无需ocr工具的情况下展现强大的多模态能力\",{\"1\":{\"218\":1}}],[\"在无空间先验下实现跨源特征对齐\",{\"1\":{\"52\":1}}],[\"在8个任务中达到sota\",{\"1\":{\"216\":1}}],[\"在中文任务中表现优于gpt\",{\"1\":{\"216\":1}}],[\"在此类任务中依然适用\",{\"1\":{\"527\":1}}],[\"在此实现中未使用\",{\"1\":{\"469\":1}}],[\"在此版本中\",{\"1\":{\"223\":1}}],[\"在此阶段\",{\"1\":{\"208\":1}}],[\"在此基础上\",{\"1\":{\"176\":1}}],[\"在对抗性问题上易产生幻觉\",{\"1\":{\"551\":1}}],[\"在对毒性任务加入\",{\"1\":{\"536\":1}}],[\"在对话式问答数据集上\",{\"1\":{\"522\":1}}],[\"在对话任务\",{\"1\":{\"204\":1}}],[\"在对比学习框架中\",{\"1\":{\"246\":1}}],[\"在对比学习\",{\"1\":{\"157\":1}}],[\"在不进行任何梯度更新的前提下\",{\"1\":{\"532\":1}}],[\"在不进行梯度更新的前提下实现任务适应\",{\"1\":{\"528\":1}}],[\"在不损失太多性能的情况下减少了模型的大小\",{\"1\":{\"495\":1}}],[\"在不改变大模型的前提下\",{\"1\":{\"486\":1}}],[\"在不复制数据的前提下\",{\"1\":{\"361\":1}}],[\"在不使用指令微调的前提下\",{\"1\":{\"202\":1}}],[\"在不同情形下它发生的概率\",{\"1\":{\"731\":1}}],[\"在不同微调策略下\",{\"1\":{\"201\":1}}],[\"在不同解码阶段注入语言线索\",{\"1\":{\"71\":1}}],[\"在不同解码层注入语言信息\",{\"1\":{\"70\":1}}],[\"在英中双语的\",{\"1\":{\"202\":1}}],[\"在该步中\",{\"1\":{\"717\":1}}],[\"在该步骤中\",{\"1\":{\"717\":1}}],[\"在该阶段\",{\"1\":{\"199\":2}}],[\"在该框架中\",{\"1\":{\"178\":1}}],[\"在自注意力机制之后\",{\"1\":{\"622\":1}}],[\"在自注意力里\",{\"1\":{\"591\":1}}],[\"在自然语言处理中的成功启发\",{\"1\":{\"790\":1}}],[\"在自然语言处理领域\",{\"1\":{\"708\":1}}],[\"在自然语言处理领域取得了突破性进展\",{\"1\":{\"192\":1}}],[\"在自然语言推理任务\",{\"1\":{\"529\":1}}],[\"在自己的数据上继续训练\",{\"1\":{\"491\":1}}],[\"在自回归生成时\",{\"1\":{\"312\":1}}],[\"在自监督学习中\",{\"1\":{\"178\":1}}],[\"在单进程下运行完整的\",{\"1\":{\"186\":1}}],[\"在单模态编码器上进行图文对比学习\",{\"1\":{\"153\":1}}],[\"在两句话之间和句末加\",{\"1\":{\"573\":1}}],[\"在两类提示分布\",{\"1\":{\"538\":1}}],[\"在两个线性层之间通常会插入一个非线性激活函数\",{\"1\":{\"321\":1}}],[\"在两个视频\",{\"1\":{\"120\":1}}],[\"在两台8\",{\"1\":{\"184\":1}}],[\"在dino中\",{\"1\":{\"182\":1}}],[\"在前一阶段\",{\"1\":{\"695\":1}}],[\"在前向传播中\",{\"1\":{\"618\":1}}],[\"在前向过程中\",{\"1\":{\"492\":1}}],[\"在前面我们介绍了\",{\"1\":{\"493\":1}}],[\"在前景像素远少于背景像素时表现良好\",{\"1\":{\"473\":1}}],[\"在前\",{\"1\":{\"179\":1}}],[\"在默认参数设置下\",{\"1\":{\"178\":1}}],[\"在传统的知识蒸馏中\",{\"1\":{\"178\":1}}],[\"在协同蒸馏里\",{\"1\":{\"176\":1}}],[\"在资源有限的场景下\",{\"1\":{\"173\":1}}],[\"在视觉问答\",{\"1\":{\"260\":1}}],[\"在视觉\",{\"1\":{\"260\":1}}],[\"在视觉推理任务上准确率偏低\",{\"1\":{\"260\":1}}],[\"在视觉中的潜力\",{\"1\":{\"173\":1}}],[\"在视觉识别任务中表现出竞争力\",{\"1\":{\"173\":1}}],[\"在输入序列长度不一致时\",{\"1\":{\"622\":1}}],[\"在输入中添加可学习的前缀\",{\"1\":{\"239\":1}}],[\"在输入数据\",{\"1\":{\"170\":1}}],[\"在输入\",{\"1\":{\"167\":1}}],[\"在实现中应当如下处理\",{\"1\":{\"684\":1}}],[\"在实现时可采用自然语言处理\",{\"1\":{\"299\":1}}],[\"在实现时\",{\"1\":{\"90\":1}}],[\"在实验部分也采用了这些基准\",{\"1\":{\"536\":1}}],[\"在实验中\",{\"1\":{\"167\":1,\"474\":1,\"769\":1}}],[\"在实践中\",{\"1\":{\"450\":1}}],[\"在实践中通过梯度下降自动学习逼近策略\",{\"1\":{\"385\":1}}],[\"在实际中\",{\"1\":{\"868\":1}}],[\"在实际中要通过具体分布建模\",{\"1\":{\"854\":1}}],[\"在实际部署中可能导致意外错误\",{\"1\":{\"530\":1}}],[\"在实际的模型中\",{\"1\":{\"481\":1}}],[\"在实际训练中更稳定\",{\"1\":{\"469\":1}}],[\"在实际正例数量非常少\",{\"1\":{\"446\":1}}],[\"在实际正例数量非常少的不平衡数据集中\",{\"1\":{\"444\":1}}],[\"在实际负例数量非常少\",{\"1\":{\"445\":1}}],[\"在实际应用中可以选用常见的卷积神经网络\",{\"1\":{\"299\":1}}],[\"在进行开发前\",{\"1\":{\"717\":1}}],[\"在进行普通计算\",{\"1\":{\"686\":1}}],[\"在进行\",{\"1\":{\"162\":1}}],[\"在多项基准测试中超越了\",{\"1\":{\"704\":1}}],[\"在多个视觉任务中\",{\"1\":{\"790\":1}}],[\"在多个下游任务\",{\"1\":{\"766\":1}}],[\"在多个基准测试中达到与更大规模专有模型相当的性能\",{\"1\":{\"553\":1}}],[\"在多个方面仍存在不足\",{\"1\":{\"539\":1}}],[\"在多个nlp任务上的零样本\",{\"1\":{\"522\":1}}],[\"在多个任务\",{\"1\":{\"120\":1}}],[\"在多数情况下会返回原张量的视图\",{\"1\":{\"362\":1}}],[\"在多维数组或张量索引时\",{\"1\":{\"355\":1}}],[\"在多模态对话基准\",{\"1\":{\"203\":1}}],[\"在多语言理解和代码生成等方面表现出色\",{\"1\":{\"704\":1}}],[\"在多语言图像→文本检索任务\",{\"1\":{\"202\":1}}],[\"在多语言版本的\",{\"1\":{\"202\":1}}],[\"在多任务\",{\"1\":{\"157\":1}}],[\"在噪声标签数据上提高学习效果\",{\"1\":{\"157\":1}}],[\"在众多下游任务中都实现了最先进\",{\"1\":{\"138\":1}}],[\"在保持\",{\"1\":{\"773\":1}}],[\"在保持相同计算成本下\",{\"1\":{\"562\":1}}],[\"在保持预训练高效的前提下\",{\"1\":{\"122\":1}}],[\"在保证性能的同时\",{\"1\":{\"261\":1}}],[\"在保证高性能的同时显著降低了计算成本\",{\"1\":{\"150\":1}}],[\"在保留细节信息的同时兼容多样化的图像分辨率\",{\"1\":{\"224\":1}}],[\"在保留信息的同时提升训练数据质量\",{\"1\":{\"120\":1}}],[\"在速度和效率上占优\",{\"1\":{\"112\":1}}],[\"在部件分割任务中\",{\"1\":{\"112\":1}}],[\"在通道维度进行拼接\",{\"1\":{\"109\":1}}],[\"在分类任务中更有用\",{\"1\":{\"614\":1}}],[\"在分类任务中\",{\"1\":{\"470\":1}}],[\"在分类任务上性能更好\",{\"1\":{\"261\":1}}],[\"在分割任务中\",{\"1\":{\"105\":1}}],[\"在分组内进行信息交换\",{\"1\":{\"75\":1}}],[\"在这一节里\",{\"1\":{\"879\":1}}],[\"在这一理论指导下\",{\"1\":{\"531\":1}}],[\"在这篇文章中\",{\"1\":{\"877\":1}}],[\"在这段代码中\",{\"1\":{\"798\":1}}],[\"在这种连续的空间里\",{\"1\":{\"728\":1}}],[\"在这种情况下\",{\"1\":{\"97\":1,\"250\":1,\"305\":1,\"507\":1,\"873\":2}}],[\"在这方面表现较差\",{\"1\":{\"703\":1}}],[\"在这之后用生成模型分配的剩下序列的平均token对数概率高的作为结果\",{\"1\":{\"516\":1}}],[\"在这些任务中\",{\"1\":{\"538\":1}}],[\"在这些示例中\",{\"1\":{\"501\":1}}],[\"在这些点中选出若干个中心点\",{\"1\":{\"87\":1}}],[\"在这里\",{\"1\":{\"481\":1,\"809\":1}}],[\"在这里一次性计算\",{\"1\":{\"272\":1}}],[\"在这个特定条件下\",{\"1\":{\"871\":1}}],[\"在这个分数上再加一个与\",{\"1\":{\"591\":1}}],[\"在这个装饰器修饰的函数内\",{\"1\":{\"365\":1}}],[\"在这个高维空间里\",{\"1\":{\"321\":1}}],[\"在这个流派只有一个编码器\",{\"1\":{\"250\":1}}],[\"在这个向量上做交叉熵\",{\"1\":{\"248\":1}}],[\"在这个过程中\",{\"1\":{\"242\":1,\"243\":1,\"248\":1,\"300\":1}}],[\"在这个任务上\",{\"1\":{\"235\":1}}],[\"在multinli上转移embedding能提升结果\",{\"1\":{\"516\":1}}],[\"在multinli和race上的性能随着层数的变化而变化\",{\"1\":{\"516\":1}}],[\"在mmbench\",{\"1\":{\"228\":1}}],[\"在mrg中\",{\"1\":{\"97\":1}}],[\"在msg中\",{\"1\":{\"95\":1}}],[\"在训练时\",{\"1\":{\"843\":1,\"878\":1}}],[\"在训练时引入随机丢弃形心来模拟不同密度情况\",{\"1\":{\"96\":1}}],[\"在训练时引入不同密度的点集情况\",{\"1\":{\"96\":1}}],[\"在训练公式\",{\"1\":{\"511\":1}}],[\"在训练或验证数据集可能会加入一些\",{\"1\":{\"274\":1}}],[\"在训练过程中不断把\",{\"1\":{\"869\":1}}],[\"在训练过程中发现\",{\"1\":{\"245\":1}}],[\"在训练过程中\",{\"1\":{\"170\":1,\"232\":1,\"298\":1}}],[\"在训练中\",{\"1\":{\"157\":1,\"274\":1}}],[\"在训练和测试中不作为显式监督信号\",{\"1\":{\"64\":1}}],[\"在密集采样的区域中学到的特征可能无法很好地泛化到稀疏采样的区域\",{\"1\":{\"94\":1}}],[\"在屋里空间或某些特定的抽象空间中\",{\"1\":{\"90\":1}}],[\"在平移不变性上也有局限性\",{\"1\":{\"86\":1}}],[\"在论文的最后\",{\"1\":{\"326\":1}}],[\"在论文中\",{\"1\":{\"299\":1,\"323\":1,\"324\":1,\"882\":1}}],[\"在论文中提到\",{\"1\":{\"112\":1}}],[\"在论文\",{\"1\":{\"78\":1}}],[\"在扩展过程中\",{\"1\":{\"63\":1}}],[\"在跨模态融合后\",{\"1\":{\"41\":1}}],[\"在混合精度下运行\",{\"1\":{\"40\":1}}],[\"在几何形状变化显著的同类物体中\",{\"1\":{\"25\":1}}],[\"在\",{\"1\":{\"23\":1,\"29\":1,\"33\":1,\"45\":1,\"71\":1,\"73\":1,\"76\":1,\"78\":1,\"82\":2,\"83\":1,\"92\":3,\"107\":1,\"108\":1,\"112\":1,\"126\":2,\"134\":1,\"140\":1,\"156\":1,\"167\":1,\"170\":1,\"173\":4,\"175\":1,\"198\":1,\"201\":2,\"202\":1,\"203\":1,\"208\":1,\"209\":1,\"215\":1,\"235\":1,\"245\":2,\"247\":1,\"248\":1,\"249\":1,\"277\":1,\"297\":1,\"302\":1,\"317\":1,\"326\":2,\"332\":1,\"336\":1,\"362\":1,\"377\":1,\"378\":1,\"452\":2,\"453\":1,\"492\":2,\"495\":1,\"531\":1,\"538\":4,\"559\":1,\"572\":1,\"591\":6,\"614\":2,\"616\":1,\"618\":1,\"682\":1,\"690\":2,\"692\":1,\"697\":1,\"703\":1,\"704\":2,\"707\":1,\"714\":1,\"730\":1,\"747\":1,\"770\":1,\"774\":1,\"796\":1,\"806\":1,\"807\":1,\"809\":1,\"815\":1,\"821\":1,\"835\":1,\"854\":1,\"866\":2,\"869\":1,\"881\":1,\"885\":1}}],[\"总的信息量\",{\"1\":{\"872\":1}}],[\"总的排列方式共有\",{\"1\":{\"762\":1}}],[\"总是\",{\"1\":{\"853\":1}}],[\"总长度\",{\"1\":{\"817\":1}}],[\"总长度超过模型最大长度\",{\"1\":{\"815\":1}}],[\"总输入序列长度\",{\"1\":{\"814\":1}}],[\"总词表中的每个\",{\"1\":{\"814\":1}}],[\"总词表大小\",{\"1\":{\"814\":2}}],[\"总词汇量\",{\"1\":{\"578\":1}}],[\"总序列长度\",{\"1\":{\"814\":1}}],[\"总共要\",{\"1\":{\"802\":1}}],[\"总共可用\",{\"1\":{\"801\":1}}],[\"总共得到\",{\"1\":{\"63\":1}}],[\"总数调整\",{\"1\":{\"814\":1}}],[\"总数\",{\"1\":{\"801\":1}}],[\"总数量\",{\"1\":{\"801\":1}}],[\"总数的\",{\"1\":{\"774\":1}}],[\"总数据量达160gb\",{\"1\":{\"565\":1}}],[\"总排列数\",{\"1\":{\"762\":2,\"763\":2}}],[\"总句对数量\",{\"1\":{\"582\":1}}],[\"总掩码的词数量\",{\"1\":{\"582\":1}}],[\"总计超过\",{\"1\":{\"561\":1}}],[\"总计\",{\"1\":{\"560\":1}}],[\"总计1\",{\"1\":{\"547\":1}}],[\"总规模1\",{\"1\":{\"548\":1}}],[\"总之\",{\"1\":{\"511\":1,\"516\":1,\"535\":1,\"708\":1}}],[\"总\",{\"1\":{\"277\":2}}],[\"总批量大小\",{\"1\":{\"208\":1,\"209\":1}}],[\"总体的损失函数可以写成\",{\"1\":{\"882\":1}}],[\"总体而言\",{\"1\":{\"515\":1}}],[\"总体来看\",{\"1\":{\"305\":1}}],[\"总体\",{\"1\":{\"199\":1}}],[\"总体数据统计\",{\"1\":{\"17\":1}}],[\"总视图数量\",{\"1\":{\"186\":1}}],[\"总损失为\",{\"1\":{\"885\":1}}],[\"总损失由三个部分组成\",{\"1\":{\"885\":1}}],[\"总损失\",{\"1\":{\"78\":1,\"186\":1,\"581\":1,\"821\":1}}],[\"总损失包含三项\",{\"1\":{\"55\":1}}],[\"总样本数\",{\"1\":{\"65\":1}}],[\"总结为一句话\",{\"1\":{\"800\":1}}],[\"总结系统\",{\"1\":{\"539\":1}}],[\"总结并解释\",{\"1\":{\"538\":1}}],[\"总结一句话\",{\"1\":{\"239\":1}}],[\"总结一下这篇文章\",{\"1\":{\"239\":1}}],[\"总结文章\",{\"1\":{\"232\":1}}],[\"总结表格\",{\"1\":{\"112\":1}}],[\"总结\",{\"0\":{\"69\":1,\"205\":1,\"328\":1,\"352\":1,\"410\":1,\"460\":1,\"524\":1,\"553\":1,\"569\":1,\"883\":1},\"1\":{\"33\":1,\"90\":1,\"105\":1,\"294\":1,\"355\":1,\"385\":1,\"455\":1,\"521\":1,\"528\":1,\"529\":1,\"530\":1,\"531\":1,\"538\":1,\"539\":1,\"548\":1,\"550\":1,\"551\":1,\"616\":1,\"687\":1,\"728\":1}}],[\"总训练轮次\",{\"1\":{\"22\":1}}],[\"xc+1\",{\"1\":{\"886\":1}}],[\"xc\",{\"1\":{\"859\":2,\"886\":2}}],[\"xcit\",{\"1\":{\"186\":1}}],[\"x|z\",{\"1\":{\"854\":2}}],[\"x^\",{\"1\":{\"690\":1}}],[\"x的tf\",{\"1\":{\"692\":1}}],[\"x的正向传播简单地对输入取反\",{\"1\":{\"690\":1}}],[\"x的\",{\"1\":{\"690\":1}}],[\"x需要调用x的\",{\"1\":{\"690\":1}}],[\"x时\",{\"1\":{\"690\":2}}],[\"xs\",{\"1\":{\"681\":5,\"686\":2,\"688\":2,\"690\":1}}],[\"xsystem\",{\"1\":{\"235\":2}}],[\"xu\",{\"1\":{\"536\":1,\"811\":1}}],[\"x和y之间的关系是\",{\"1\":{\"481\":1}}],[\"xm\",{\"1\":{\"481\":1}}],[\"xmf\",{\"1\":{\"22\":1}}],[\"x方向和y方向的线性插值的叠加\",{\"1\":{\"390\":1}}],[\"x0\",{\"1\":{\"390\":2,\"652\":2,\"688\":4,\"690\":31,\"696\":5,\"697\":36}}],[\"xlnet\",{\"1\":{\"531\":1,\"559\":1}}],[\"xlabel\",{\"1\":{\"316\":1,\"697\":1}}],[\"xlm\",{\"1\":{\"202\":1}}],[\"x=i\",{\"1\":{\"316\":1}}],[\"xticks\",{\"1\":{\"316\":1}}],[\"xtd\",{\"1\":{\"202\":1}}],[\"x4等等也经过e12得到了真正的负样本表征f2\",{\"1\":{\"246\":1}}],[\"x3\",{\"1\":{\"246\":1,\"295\":3}}],[\"xa\",{\"1\":{\"235\":1}}],[\"x2\",{\"1\":{\"295\":3,\"481\":1}}],[\"x2a\",{\"1\":{\"235\":1}}],[\"x2instruct\",{\"1\":{\"235\":1}}],[\"xinstruct\",{\"1\":{\"235\":1}}],[\"xie\",{\"1\":{\"176\":1}}],[\"xi\",{\"1\":{\"105\":1}}],[\"xn\",{\"1\":{\"105\":3,\"295\":3}}],[\"x1的计算图\",{\"1\":{\"696\":1}}],[\"x1的导数公式为\",{\"1\":{\"690\":1}}],[\"x1的反向传播中\",{\"1\":{\"690\":1}}],[\"x12叫做x11的正样本\",{\"1\":{\"246\":1}}],[\"x1a\",{\"1\":{\"235\":1}}],[\"x1instruct\",{\"1\":{\"235\":1}}],[\"x1\",{\"1\":{\"105\":3,\"390\":2,\"481\":1,\"652\":2,\"688\":3,\"690\":34,\"696\":5,\"697\":34,\"704\":1}}],[\"xx\",{\"1\":{\"83\":1}}],[\"xyz2\",{\"1\":{\"98\":2,\"100\":6}}],[\"xyz1\",{\"1\":{\"98\":3,\"100\":6}}],[\"xyz\",{\"1\":{\"30\":4,\"59\":4,\"70\":5,\"76\":1,\"92\":60,\"93\":11,\"96\":31,\"98\":2,\"101\":22}}],[\"x\",{\"1\":{\"29\":2,\"34\":2,\"35\":2,\"36\":3,\"58\":2,\"59\":6,\"68\":2,\"72\":4,\"73\":10,\"74\":5,\"75\":3,\"76\":2,\"93\":12,\"96\":10,\"101\":9,\"107\":29,\"109\":32,\"110\":10,\"111\":20,\"114\":2,\"170\":1,\"186\":8,\"252\":3,\"272\":69,\"276\":10,\"277\":10,\"295\":3,\"318\":8,\"319\":14,\"320\":15,\"321\":21,\"322\":9,\"323\":19,\"336\":4,\"340\":4,\"352\":2,\"355\":4,\"359\":1,\"360\":1,\"361\":3,\"362\":1,\"363\":6,\"364\":9,\"368\":2,\"369\":5,\"370\":7,\"372\":6,\"373\":4,\"374\":4,\"376\":1,\"377\":6,\"378\":2,\"387\":3,\"389\":1,\"390\":2,\"395\":2,\"398\":10,\"419\":7,\"423\":6,\"452\":1,\"455\":1,\"463\":9,\"473\":2,\"476\":6,\"478\":4,\"481\":1,\"487\":1,\"537\":2,\"590\":5,\"605\":7,\"616\":1,\"624\":2,\"626\":3,\"627\":8,\"628\":4,\"630\":12,\"631\":4,\"632\":7,\"638\":4,\"643\":5,\"644\":2,\"647\":6,\"652\":3,\"656\":3,\"660\":2,\"661\":2,\"662\":1,\"665\":3,\"668\":4,\"671\":4,\"675\":5,\"676\":5,\"681\":2,\"682\":4,\"684\":17,\"685\":2,\"686\":13,\"688\":19,\"689\":11,\"690\":24,\"692\":26,\"696\":25,\"697\":6,\"737\":1,\"793\":3,\"801\":1,\"804\":30,\"831\":3,\"848\":57,\"853\":4,\"854\":7,\"859\":5,\"860\":7,\"881\":2,\"885\":17,\"886\":4}}],[\"x9x\",{\"1\":{\"4\":1}}],[\"引用计数无法降至0\",{\"1\":{\"687\":1}}],[\"引用计数\",{\"1\":{\"687\":1}}],[\"引用计数和分代垃圾回收\",{\"1\":{\"687\":1}}],[\"引起的对齐误差问题而提出的关键组件\",{\"1\":{\"387\":1}}],[\"引号中是\",{\"1\":{\"367\":1}}],[\"引言\",{\"0\":{\"165\":1,\"173\":1,\"297\":1,\"421\":1,\"559\":1,\"634\":1,\"680\":1,\"695\":1,\"700\":1,\"806\":1,\"843\":1,\"864\":1,\"877\":1}}],[\"引入这个式子\",{\"1\":{\"867\":1}}],[\"引入近似但误差较小\",{\"1\":{\"864\":1}}],[\"引入一个可计算的近似后验\",{\"1\":{\"807\":1}}],[\"引入一组可学习的\",{\"1\":{\"70\":1}}],[\"引入注意力机制和辅助损失\",{\"1\":{\"806\":1}}],[\"引入上下文\",{\"1\":{\"531\":1}}],[\"引入到对大模型的微调中去\",{\"1\":{\"483\":1}}],[\"引入带有\",{\"1\":{\"268\":1}}],[\"引入通用多模态\",{\"1\":{\"260\":1}}],[\"引入了先进的检索技术\",{\"1\":{\"714\":1}}],[\"引入了多模态能力\",{\"1\":{\"704\":1}}],[\"引入了新数据集\",{\"1\":{\"559\":1}}],[\"引入了额外的推理延迟\",{\"1\":{\"491\":1}}],[\"引入了一组模态专家\",{\"1\":{\"269\":1}}],[\"引入了向量量化知识蒸馏\",{\"1\":{\"167\":1}}],[\"引入了两个变换网络\",{\"1\":{\"108\":1}}],[\"引入更丰富的监督\",{\"1\":{\"159\":1}}],[\"引入多尺度采样等\",{\"1\":{\"112\":1}}],[\"引入两个空间变换网络\",{\"1\":{\"105\":1}}],[\"引入\",{\"1\":{\"103\":1,\"105\":1,\"112\":1,\"165\":1,\"537\":1,\"539\":1,\"693\":1,\"695\":2}}],[\"引入交互先验\",{\"1\":{\"7\":1}}],[\"引导方法\",{\"1\":{\"816\":1}}],[\"引导答案生成\",{\"1\":{\"521\":1}}],[\"引导模型学习有用的特征\",{\"1\":{\"248\":1}}],[\"引导模型生成特定任务的结果\",{\"1\":{\"239\":1}}],[\"引导语言模型更好地遵循用户指令\",{\"1\":{\"232\":1}}],[\"引导下提取的点云信息增强后的图像特征\",{\"1\":{\"41\":1}}],[\"引导\",{\"1\":{\"28\":1}}],[\"引导的3d可供性方法\",{\"1\":{\"22\":1}}],[\"包初始化文件\",{\"1\":{\"691\":1}}],[\"包和库是组织代码的重要方式\",{\"1\":{\"691\":1}}],[\"包\",{\"1\":{\"438\":1,\"691\":1}}],[\"包类型\",{\"1\":{\"438\":1}}],[\"包可能会安装到基础环境或系统\",{\"1\":{\"438\":1}}],[\"包会安装到该环境的\",{\"1\":{\"438\":1}}],[\"包名\",{\"1\":{\"431\":1}}],[\"包裹起来\",{\"1\":{\"350\":1}}],[\"包括三项\",{\"1\":{\"885\":1}}],[\"包括声名远扬的stable\",{\"1\":{\"877\":1}}],[\"包括或不包括自己\",{\"1\":{\"848\":1}}],[\"包括位置\",{\"1\":{\"804\":1}}],[\"包括图像增强\",{\"1\":{\"803\":1}}],[\"包括图像分类\",{\"1\":{\"188\":1}}],[\"包括颜色抖动\",{\"1\":{\"802\":1}}],[\"包括让\",{\"1\":{\"714\":1}}],[\"包括中间步骤的数据流传输\",{\"1\":{\"714\":1}}],[\"包括批量处理\",{\"1\":{\"714\":1}}],[\"包括写文章\",{\"1\":{\"708\":1}}],[\"包括生成有害内容\",{\"1\":{\"705\":1}}],[\"包括文本分割\",{\"1\":{\"714\":1}}],[\"包括文本\",{\"1\":{\"705\":1}}],[\"包括了\",{\"1\":{\"704\":1}}],[\"包括开源和闭源\",{\"1\":{\"704\":1}}],[\"包括问题和上下文\",{\"1\":{\"614\":1}}],[\"包括wikitext\",{\"1\":{\"577\":1}}],[\"包括动态掩码\",{\"1\":{\"569\":1}}],[\"包括但不限于\",{\"1\":{\"537\":1}}],[\"包括预归一化\",{\"1\":{\"528\":1}}],[\"包括翻译\",{\"1\":{\"526\":1}}],[\"包括探索gpt\",{\"1\":{\"523\":1}}],[\"包括penn\",{\"1\":{\"522\":1}}],[\"包括以下步骤\",{\"1\":{\"803\":1}}],[\"包括以下几步\",{\"1\":{\"487\":1}}],[\"包括以下核心模块\",{\"1\":{\"70\":1}}],[\"包括基于对比学习的方法\",{\"1\":{\"305\":1}}],[\"包括\",{\"1\":{\"140\":1,\"186\":1,\"225\":1,\"319\":1,\"395\":1,\"536\":1,\"561\":1,\"691\":1,\"704\":3,\"712\":1,\"846\":1}}],[\"包括理解类任务和生成类任务\",{\"1\":{\"138\":1}}],[\"包括前向传播\",{\"1\":{\"81\":1,\"803\":1}}],[\"包括与多个先进方法的对比以及消融实验和可视化分析\",{\"1\":{\"21\":1}}],[\"包含离散\",{\"1\":{\"770\":1}}],[\"包含整个样本空间和空集\",{\"1\":{\"728\":1}}],[\"包含绘图的完整代码\",{\"1\":{\"697\":1}}],[\"包含多层pow\",{\"1\":{\"696\":1}}],[\"包含add函数节点和变量连接\",{\"1\":{\"696\":1}}],[\"包含高次项和交叉项\",{\"1\":{\"692\":1}}],[\"包含争议性内容\",{\"1\":{\"537\":1}}],[\"包含从\",{\"1\":{\"423\":1}}],[\"包含优化器\",{\"1\":{\"395\":1}}],[\"包含切分后的张量块\",{\"1\":{\"374\":1}}],[\"包含大约\",{\"1\":{\"327\":1}}],[\"包含一个线性层和一个\",{\"1\":{\"323\":1}}],[\"包含分类token\",{\"1\":{\"322\":1}}],[\"包含所有图像对应类别的列表\",{\"1\":{\"316\":1}}],[\"包含所有图像文件路径的列表\",{\"1\":{\"316\":1}}],[\"包含所有裁剪的拼接结果\",{\"1\":{\"186\":1}}],[\"包含图像和对应的标签\",{\"1\":{\"316\":1}}],[\"包含图像和可选文本\",{\"1\":{\"313\":1}}],[\"包含图像信息\",{\"1\":{\"312\":1}}],[\"包含\",{\"1\":{\"312\":1,\"375\":1,\"803\":1,\"804\":1}}],[\"包含数据增强\",{\"1\":{\"395\":1}}],[\"包含数据路径\",{\"1\":{\"274\":1}}],[\"包含数据集\",{\"1\":{\"274\":1}}],[\"包含约\",{\"1\":{\"234\":1,\"235\":1}}],[\"包含60亿参数的视觉编码器\",{\"1\":{\"189\":1}}],[\"包含三个目标\",{\"1\":{\"153\":1}}],[\"包含三个关键步骤\",{\"1\":{\"71\":1}}],[\"包含两个文档片段和nsp损失\",{\"1\":{\"562\":1}}],[\"包含两个模块\",{\"1\":{\"128\":1}}],[\"包含两张分辨率较高的\",{\"1\":{\"178\":1}}],[\"包含两种适应性特征学习层\",{\"1\":{\"94\":1}}],[\"包含表面细节\",{\"1\":{\"114\":1}}],[\"包含7\",{\"1\":{\"49\":1}}],[\"包含jra模块\",{\"1\":{\"49\":1}}],[\"包含物体的坐标\",{\"1\":{\"8\":1}}],[\"包含15k交互图像和38k标注的3d物体实例\",{\"1\":{\"5\":1}}],[\"类卷积了\",{\"1\":{\"845\":1}}],[\"类卷积也是不行的\",{\"1\":{\"845\":1}}],[\"类卷积\",{\"1\":{\"845\":4}}],[\"类掩码卷积后\",{\"1\":{\"845\":1}}],[\"类掩码卷积呢\",{\"1\":{\"845\":1}}],[\"类掩码卷积\",{\"1\":{\"845\":5}}],[\"类和\",{\"1\":{\"845\":1}}],[\"类模型中广泛使用\",{\"1\":{\"772\":1}}],[\"类变量\",{\"1\":{\"738\":1}}],[\"类将\",{\"1\":{\"686\":1}}],[\"类提供一个新的方法\",{\"1\":{\"683\":1}}],[\"类以支持\",{\"1\":{\"681\":1}}],[\"类gpt式生成式模型进行推理的过程\",{\"1\":{\"542\":1,\"543\":1}}],[\"类的唯一区别在于卷积核的中心像素是否产生贡献\",{\"1\":{\"845\":1}}],[\"类的概率\",{\"1\":{\"795\":1}}],[\"类的\",{\"1\":{\"686\":1,\"793\":1,\"794\":1}}],[\"类的样本数\",{\"1\":{\"399\":1}}],[\"类的比例与原始近似一致\",{\"1\":{\"398\":1}}],[\"类的实现\",{\"1\":{\"186\":1}}],[\"类装饰器通常通过实现\",{\"1\":{\"351\":1}}],[\"类装饰器\",{\"0\":{\"351\":1}}],[\"类方法\",{\"0\":{\"347\":1}}],[\"类体代码在独立的命名空间里执行\",{\"1\":{\"336\":1}}],[\"类定义\",{\"1\":{\"336\":1,\"691\":1}}],[\"类型必须是\",{\"1\":{\"848\":1}}],[\"类型报错\",{\"1\":{\"802\":1}}],[\"类型应用前景的思考\",{\"1\":{\"708\":1}}],[\"类型签名会失效\",{\"1\":{\"346\":1}}],[\"类型检查\",{\"1\":{\"346\":1}}],[\"类型\",{\"1\":{\"276\":1,\"277\":1,\"282\":4,\"352\":1,\"354\":1,\"616\":1,\"814\":1,\"848\":2}}],[\"类型的索引\",{\"1\":{\"276\":1}}],[\"类用于完成多数据源加载的任务\",{\"1\":{\"274\":1}}],[\"类没有直接对外提供现成的\",{\"1\":{\"272\":1}}],[\"类额外提供了\",{\"1\":{\"272\":1}}],[\"类负责完成通用模版流程的抽取\",{\"1\":{\"274\":1}}],[\"类负责完成前向传播流程的组织\",{\"1\":{\"272\":1}}],[\"类负责完成\",{\"1\":{\"272\":1}}],[\"类负责存储和更新\",{\"1\":{\"170\":1}}],[\"类似的两阶段训练流程\",{\"1\":{\"773\":1}}],[\"类似自然语言\",{\"1\":{\"770\":1}}],[\"类似物理学中的相变现象\",{\"1\":{\"706\":1}}],[\"类似地\",{\"1\":{\"690\":2}}],[\"类似预激活残差网络\",{\"1\":{\"521\":1}}],[\"类似数据库查询\",{\"1\":{\"414\":1}}],[\"类似模式匹配\",{\"1\":{\"370\":1}}],[\"类似gpt\",{\"1\":{\"216\":1}}],[\"类似\",{\"1\":{\"198\":1,\"210\":1,\"297\":1}}],[\"类似于图像领域的\",{\"1\":{\"788\":1}}],[\"类似于图像分类的训练流程\",{\"1\":{\"777\":1}}],[\"类似于多项式逼近中的基函数组合\",{\"1\":{\"385\":1}}],[\"类似于在cnn中权重共享的概念\",{\"1\":{\"86\":1}}],[\"类似于传统的全连接层或\",{\"1\":{\"73\":1}}],[\"类似于\",{\"1\":{\"73\":1,\"248\":1,\"372\":1,\"704\":1}}],[\"类来将输入图像批次列表按照分辨率进行分组\",{\"1\":{\"186\":1}}],[\"类实现\",{\"1\":{\"186\":1}}],[\"类中提供的方法\",{\"1\":{\"366\":1}}],[\"类中\",{\"1\":{\"107\":1}}],[\"类\",{\"1\":{\"65\":2,\"67\":2,\"274\":2,\"318\":1,\"680\":1,\"738\":1,\"848\":1}}],[\"类比\",{\"1\":{\"28\":1}}],[\"类比额外交互\",{\"1\":{\"28\":1}}],[\"类比推理\",{\"0\":{\"12\":1}}],[\"类别维\",{\"1\":{\"821\":1}}],[\"类别概率的计算方式如下\",{\"1\":{\"776\":1}}],[\"类别平衡权重\",{\"1\":{\"470\":1}}],[\"类别样本越少\",{\"1\":{\"403\":1}}],[\"类别权重\",{\"1\":{\"399\":2,\"471\":1,\"473\":1}}],[\"类别数量不平衡\",{\"1\":{\"470\":1}}],[\"类别数量少\",{\"1\":{\"403\":1}}],[\"类别数\",{\"1\":{\"399\":1}}],[\"类别不平衡越严重\",{\"1\":{\"470\":1}}],[\"类别不平衡的问题\",{\"1\":{\"470\":1}}],[\"类别不平衡\",{\"1\":{\"399\":1,\"467\":1}}],[\"类别\",{\"1\":{\"239\":3,\"272\":1,\"399\":3,\"848\":1}}],[\"类别下图像与点云的数量比例\",{\"1\":{\"19\":1}}],[\"类别间存在明显的多对多关系\",{\"1\":{\"19\":1}}],[\"类平衡分析\",{\"1\":{\"19\":1}}],[\"多不精确\",{\"1\":{\"873\":1}}],[\"多卷几层后\",{\"1\":{\"845\":1}}],[\"多分类交叉熵\",{\"1\":{\"832\":1}}],[\"多分辨率分组\",{\"0\":{\"97\":1},\"1\":{\"97\":1}}],[\"多种\",{\"1\":{\"814\":1}}],[\"多种可供性\",{\"1\":{\"25\":1}}],[\"多输入与多输出\",{\"0\":{\"681\":1}}],[\"多输入\",{\"1\":{\"680\":1}}],[\"多元正态分布\",{\"0\":{\"751\":1}}],[\"多元场景下也称为偏导数\",{\"1\":{\"656\":1}}],[\"多元高斯\",{\"1\":{\"455\":1}}],[\"多元高斯分布的行为可能会显得非常反直觉\",{\"1\":{\"753\":1}}],[\"多元高斯分布的概率密度函数定义如下\",{\"1\":{\"752\":1}}],[\"多元高斯分布被称为二维高斯分布\",{\"1\":{\"752\":1}}],[\"多元高斯分布\",{\"1\":{\"455\":1}}],[\"多项系数\",{\"1\":{\"738\":1}}],[\"多项选择题\",{\"1\":{\"618\":1}}],[\"多项选择任务是指给定一个问题和多个候选答案\",{\"1\":{\"618\":1}}],[\"多项选择任务\",{\"0\":{\"618\":1}}],[\"多项式项数\",{\"1\":{\"385\":1}}],[\"多项式\",{\"1\":{\"385\":2}}],[\"多项式阶数\",{\"1\":{\"385\":1}}],[\"多项式函数空间\",{\"1\":{\"385\":1}}],[\"多项式逼近通过增加阶数\",{\"1\":{\"385\":1}}],[\"多项式逼近需要\",{\"1\":{\"385\":1}}],[\"多项式逼近的基函数是固定的\",{\"1\":{\"385\":1}}],[\"多项式逼近\",{\"1\":{\"385\":2}}],[\"多领域竞争力\",{\"1\":{\"549\":1}}],[\"多群体条件对齐\",{\"1\":{\"539\":1}}],[\"多数投票69\",{\"1\":{\"549\":1}}],[\"多数比较数据仅有\",{\"1\":{\"539\":1}}],[\"多数据集\",{\"1\":{\"274\":1}}],[\"多条件限制\",{\"1\":{\"539\":1}}],[\"多步推理\",{\"1\":{\"530\":1}}],[\"多语言支持\",{\"1\":{\"705\":1}}],[\"多语言理解和创意生成方面有显著提升\",{\"1\":{\"704\":1}}],[\"多语言翻译能力显著提升\",{\"1\":{\"529\":1}}],[\"多语言能力\",{\"1\":{\"216\":1}}],[\"多达千亿\",{\"1\":{\"481\":1}}],[\"多次折叠\",{\"1\":{\"385\":1}}],[\"多维索引中的省略维度\",{\"1\":{\"355\":1}}],[\"多头潜在注意力\",{\"1\":{\"704\":1}}],[\"多头自注意力机制通过并行计算多个注意力头\",{\"1\":{\"622\":1}}],[\"多头自注意力机制\",{\"1\":{\"607\":1,\"622\":1}}],[\"多头自注意力计算流程图\",{\"1\":{\"605\":1,\"632\":1}}],[\"多头自注意力中每个head会根据分配给自己的这部分特征维度\",{\"1\":{\"463\":1}}],[\"多头自注意力\",{\"0\":{\"322\":1,\"632\":1}}],[\"多头自注意力层\",{\"1\":{\"321\":1}}],[\"多头注意力机制\",{\"1\":{\"272\":1}}],[\"多头注意力的头数\",{\"1\":{\"272\":2}}],[\"多任务理解\",{\"1\":{\"549\":1}}],[\"多任务与多语言学习的基础\",{\"1\":{\"531\":1}}],[\"多任务学习的概率视角\",{\"1\":{\"521\":1}}],[\"多任务学习的挑战与机遇\",{\"1\":{\"520\":1}}],[\"多任务学习\",{\"1\":{\"520\":1}}],[\"多任务\",{\"1\":{\"274\":1}}],[\"多轮交互\",{\"1\":{\"550\":1}}],[\"多轮对话能力\",{\"1\":{\"233\":1}}],[\"多轮对话\",{\"1\":{\"228\":1}}],[\"多轮数据集\",{\"1\":{\"138\":1}}],[\"多阶段训练策略\",{\"1\":{\"205\":1}}],[\"多阶段编码\",{\"1\":{\"70\":1}}],[\"多功能性\",{\"1\":{\"189\":1}}],[\"多线程加载数据\",{\"1\":{\"186\":1}}],[\"多视角裁剪增强\",{\"1\":{\"173\":1}}],[\"多视角图像\",{\"1\":{\"114\":1}}],[\"多视角\",{\"1\":{\"112\":2,\"178\":1}}],[\"多\",{\"1\":{\"98\":1,\"186\":1,\"278\":1}}],[\"多个应用可以只依赖于一个或少数几个大模型进行统一建设\",{\"1\":{\"707\":1}}],[\"多个包的集合\",{\"1\":{\"691\":1}}],[\"多个模块的集合\",{\"1\":{\"691\":1}}],[\"多个函数可以连续调用\",{\"1\":{\"646\":1}}],[\"多个距离共享一个桶\",{\"1\":{\"591\":1}}],[\"多个变量\",{\"1\":{\"455\":1}}],[\"多个装饰器叠加时的执行顺序\",{\"0\":{\"350\":1}}],[\"多个装饰器嵌套时更容易出错\",{\"1\":{\"346\":1}}],[\"多个合成描述\",{\"1\":{\"138\":1}}],[\"多个\",{\"1\":{\"98\":2,\"580\":1}}],[\"多个物体场景\",{\"1\":{\"25\":1}}],[\"多尺度生成器架构\",{\"1\":{\"806\":1}}],[\"多尺度建模能力\",{\"1\":{\"112\":1}}],[\"多尺度聚合机制\",{\"1\":{\"112\":1}}],[\"多尺度特征提取机制\",{\"1\":{\"96\":1}}],[\"多尺度分组分类模型\",{\"0\":{\"96\":1}}],[\"多尺度分组\",{\"0\":{\"95\":1},\"1\":{\"94\":1,\"95\":1,\"96\":1}}],[\"多尺度上采样模块\",{\"1\":{\"46\":1}}],[\"多阈值下的\",{\"1\":{\"82\":1}}],[\"多阈值评估更稳定\",{\"1\":{\"82\":1}}],[\"多形状的功能区域的感知能力\",{\"1\":{\"71\":1}}],[\"多层感知机\",{\"1\":{\"59\":1,\"73\":1}}],[\"多模态的概率分布\",{\"1\":{\"874\":1}}],[\"多模态预训练\",{\"0\":{\"789\":1}}],[\"多模态支持\",{\"1\":{\"705\":1}}],[\"多模态融合\",{\"1\":{\"704\":1}}],[\"多模态能力\",{\"1\":{\"704\":1}}],[\"多模态因果自监督\",{\"1\":{\"312\":1}}],[\"多模态网络设计\",{\"1\":{\"307\":1}}],[\"多模态模型\",{\"1\":{\"704\":1}}],[\"多模态模型vit原理与图片分类实战演练\",{\"1\":{\"314\":1}}],[\"多模态模型在过往发展的过程中\",{\"1\":{\"307\":1}}],[\"多模态模型clip原理与图片分类\",{\"1\":{\"296\":1}}],[\"多模态生成任务中充当解码器\",{\"1\":{\"295\":1}}],[\"多模态交互核心\",{\"1\":{\"294\":1}}],[\"多模态交叉注意力\",{\"1\":{\"291\":1}}],[\"多模态交叉注意力模块\",{\"1\":{\"45\":1}}],[\"多模态时\",{\"1\":{\"290\":1}}],[\"多模态关键点\",{\"1\":{\"290\":1,\"291\":1}}],[\"多模态论文中常用的改编版本的bert代码实现记录\",{\"1\":{\"287\":1}}],[\"多模态常用改编bert代码实现\",{\"0\":{\"287\":1}}],[\"多模态编码\",{\"1\":{\"277\":1}}],[\"多模态情况\",{\"1\":{\"272\":1}}],[\"多模态专家混合\",{\"0\":{\"264\":1}}],[\"多模态\",{\"0\":{\"258\":1,\"288\":1},\"1\":{\"704\":1}}],[\"多模态聊天机器人\",{\"1\":{\"235\":1}}],[\"多模态对话等任务上的领先性能\",{\"1\":{\"206\":1}}],[\"多模态对话等任务上全面领先于现有开源模型\",{\"1\":{\"205\":1}}],[\"多模态对话\",{\"1\":{\"197\":1}}],[\"多模态混合的编码器\",{\"1\":{\"126\":1}}],[\"多模态数据的\",{\"1\":{\"43\":1}}],[\"多模态嵌入\",{\"1\":{\"43\":2}}],[\"多模态特征投影到语言语义空间\",{\"0\":{\"42\":1},\"1\":{\"40\":1}}],[\"多样化描述更有利于学习\",{\"1\":{\"120\":1}}],[\"多样化的几何变体\",{\"1\":{\"29\":1}}],[\"多样性未公开\",{\"1\":{\"550\":1}}],[\"多样性不足\",{\"1\":{\"539\":1}}],[\"多样性目标\",{\"1\":{\"521\":1}}],[\"多样性\",{\"1\":{\"6\":1}}],[\"多实例鲁棒性\",{\"1\":{\"25\":1}}],[\"多对多关系分析\",{\"1\":{\"19\":1}}],[\"含有编码器和解码器结构\",{\"1\":{\"866\":1}}],[\"含special\",{\"1\":{\"594\":1}}],[\"含非\",{\"1\":{\"438\":1}}],[\"含义\",{\"1\":{\"76\":2,\"352\":1,\"367\":1,\"410\":2,\"455\":1,\"590\":1,\"831\":1,\"846\":1}}],[\"含\",{\"1\":{\"18\":1,\"209\":1,\"210\":1}}],[\"覆盖了从\",{\"1\":{\"714\":1}}],[\"覆盖\",{\"1\":{\"704\":1}}],[\"覆盖默认温度参数\",{\"1\":{\"794\":1}}],[\"覆盖默认\",{\"1\":{\"272\":1}}],[\"覆盖小于50\",{\"1\":{\"178\":1}}],[\"覆盖原图超过50\",{\"1\":{\"178\":1}}],[\"覆盖以下数据集\",{\"1\":{\"131\":1}}],[\"覆盖23类物体和17种功能\",{\"1\":{\"49\":1}}],[\"覆盖类别\",{\"1\":{\"17\":1}}],[\"覆盖多对多关联\",{\"1\":{\"6\":1}}],[\"而必须保留空间布局\",{\"1\":{\"885\":1}}],[\"而反向传播时\",{\"1\":{\"881\":1}}],[\"而反向传播算法可以高效地求出每个变量的导数\",{\"1\":{\"648\":1}}],[\"而ae会编码出连续向量\",{\"1\":{\"878\":1}}],[\"而实际上\",{\"1\":{\"878\":1}}],[\"而随机噪声的图像概率较低\",{\"1\":{\"864\":1}}],[\"而如果一直使用\",{\"1\":{\"845\":1}}],[\"而那部分成本就是\",{\"1\":{\"831\":1}}],[\"而最可能的是两面都为正面\",{\"1\":{\"825\":1}}],[\"而最大的vit模型vit\",{\"1\":{\"299\":1}}],[\"而基础的\",{\"1\":{\"816\":1}}],[\"而视觉质量没有显著下降\",{\"1\":{\"807\":1}}],[\"而视觉编码器通常仅约10亿参数\",{\"1\":{\"189\":1}}],[\"而低频结构才是使得物体在视觉上可被我们辨认的关键\",{\"1\":{\"807\":1}}],[\"而逆概率问题关注的则是\",{\"1\":{\"759\":1}}],[\"而没病的人也有误报\",{\"1\":{\"731\":1}}],[\"而没有建模点与点之间的局部几何关系\",{\"1\":{\"112\":1}}],[\"而可能是\",{\"1\":{\"728\":1}}],[\"而更需要掌握使用大模型的实践技巧\",{\"1\":{\"716\":1}}],[\"而每个子像素的概率仅由它之前的子像素决定\",{\"1\":{\"847\":1}}],[\"而每次反向传播时导数会累加\",{\"1\":{\"697\":1}}],[\"而每一层\",{\"1\":{\"544\":1}}],[\"而弱引用不会增加对象的引用计数\",{\"1\":{\"687\":1}}],[\"而弱引用可通过避免循环引用直接解决问题\",{\"1\":{\"687\":1}}],[\"而言可能产生显著的性能损耗\",{\"1\":{\"687\":1}}],[\"而链式法则的计算需要知晓每个函数在正向传播时的输入值和输出值\",{\"1\":{\"660\":1}}],[\"而tinypytorch的变量实现为variable类\",{\"1\":{\"636\":1}}],[\"而本系列旨在揭开这些技术和机制的神秘面纱\",{\"1\":{\"634\":1}}],[\"而注意力机制更关注的是文本中不同位置之间的动态语义关联\",{\"1\":{\"587\":1}}],[\"而针对这20\",{\"1\":{\"579\":1}}],[\"而要考虑它的上下文\",{\"1\":{\"572\":1}}],[\"而设计这些模型并测试其\",{\"1\":{\"571\":1}}],[\"而后续工作通过多任务微调\",{\"1\":{\"568\":1}}],[\"而roberta的目标是通过系统性地复现\",{\"1\":{\"568\":1}}],[\"而roberta改为每次输入时动态生成掩码\",{\"1\":{\"564\":1}}],[\"而roberta通过系统性的调整\",{\"1\":{\"562\":1}}],[\"而原始\",{\"1\":{\"561\":1}}],[\"而hoffmann推荐的10b模型仅训练200b\",{\"1\":{\"547\":1}}],[\"而llama\",{\"1\":{\"546\":1}}],[\"而common\",{\"1\":{\"528\":1}}],[\"而现有模型难以实现类似能力\",{\"1\":{\"527\":1}}],[\"而现代模型\",{\"1\":{\"527\":1}}],[\"而无需显式指定输出分布的结构\",{\"1\":{\"874\":1}}],[\"而无需显式监督\",{\"1\":{\"521\":1,\"523\":1}}],[\"而无需事先见过具体示例\",{\"1\":{\"706\":1}}],[\"而无需额外的训练或参数更新\",{\"1\":{\"706\":1}}],[\"而无需调用特定函数\",{\"1\":{\"690\":1}}],[\"而无需考虑pad词的全局上下文信息是否需要进行计算\",{\"1\":{\"584\":1}}],[\"而无需依赖专有数据\",{\"1\":{\"546\":1}}],[\"而无需明确的监督信号\",{\"1\":{\"524\":1}}],[\"而无需参数调整或架构修改\",{\"1\":{\"520\":1}}],[\"而通用系统需要能够根据任务描述动态调整行为\",{\"1\":{\"521\":1}}],[\"而通过引入特定的归纳偏置\",{\"1\":{\"314\":1}}],[\"而机器学习系统通常需要数百至数千个任务示例才能实现良好的泛化\",{\"1\":{\"520\":1}}],[\"而特定任务学习的标注数据有非常少\",{\"1\":{\"506\":1}}],[\"而给的问题却是难度大很多的问题\",{\"1\":{\"503\":1}}],[\"而一些领域差距比较大的任务可能需要更大的\",{\"1\":{\"494\":1}}],[\"而对于并行输出所有概率分布的\",{\"1\":{\"843\":1}}],[\"而对于较短的句子\",{\"1\":{\"581\":1}}],[\"而对于\",{\"1\":{\"492\":1}}],[\"而模型的输入输出维度不变\",{\"1\":{\"492\":1}}],[\"而用了qlora之后\",{\"1\":{\"488\":1}}],[\"而过度参数化的大模型背后\",{\"1\":{\"487\":1}}],[\"而prefix\",{\"1\":{\"486\":1}}],[\"而这个恒等式又来自于概率的乘法法则\",{\"1\":{\"758\":1}}],[\"而这些函数都可以同样好地最大化\",{\"1\":{\"871\":1}}],[\"而这些属性往往是相关联的\",{\"1\":{\"866\":1}}],[\"而这些\",{\"1\":{\"727\":1}}],[\"而这些内容可以影响x生成期望中y的概率\",{\"1\":{\"485\":1}}],[\"而这里我们将会反转这个逻辑\",{\"1\":{\"303\":1}}],[\"而当需要评估样本概率时\",{\"1\":{\"869\":1}}],[\"而当\",{\"1\":{\"471\":1}}],[\"而假负例\",{\"1\":{\"453\":1}}],[\"而降低阈值则会产生相反的效果\",{\"1\":{\"446\":1}}],[\"而物理转置中\",{\"1\":{\"426\":1}}],[\"而我们检测到一个\",{\"1\":{\"386\":1}}],[\"而深层网络只需多项式数量\",{\"1\":{\"385\":1}}],[\"而单层网络需要\",{\"1\":{\"385\":1}}],[\"而神经网络的全连接层只能接受固定大小的输入\",{\"1\":{\"386\":1}}],[\"而神经网络的函数复合\",{\"1\":{\"385\":1}}],[\"而神经网络的基函数\",{\"1\":{\"385\":1}}],[\"而神经网络\",{\"1\":{\"385\":1}}],[\"而神经网络通过非线性激活和分层结构\",{\"1\":{\"385\":1}}],[\"而多项式需极高阶数才能近似突变\",{\"1\":{\"385\":1}}],[\"而多模态大型语言模型\",{\"1\":{\"216\":1}}],[\"而预训练过程中使用的输入图像尺寸通常固定为\",{\"1\":{\"317\":1}}],[\"而vit将其放到前面\",{\"1\":{\"321\":1}}],[\"而vit\",{\"1\":{\"314\":1}}],[\"而vit则选择了三种不同尺寸的模型\",{\"1\":{\"299\":1}}],[\"而非随机噪声\",{\"1\":{\"865\":1}}],[\"而非低频结构上\",{\"1\":{\"807\":1}}],[\"而非像素或对比目标\",{\"1\":{\"786\":1}}],[\"而非像素值\",{\"1\":{\"766\":1}}],[\"而非以\",{\"1\":{\"780\":1}}],[\"而非高层语义\",{\"1\":{\"766\":1}}],[\"而非直接回归像素值\",{\"1\":{\"765\":1}}],[\"而非实时回收循环引用对象\",{\"1\":{\"687\":1}}],[\"而非生成答案\",{\"1\":{\"616\":1}}],[\"而非本质的\",{\"1\":{\"539\":1}}],[\"而非验证\",{\"1\":{\"537\":1}}],[\"而非具备深层理解与推理能力的系统\",{\"1\":{\"530\":1}}],[\"而非真正理解语言和任务的系统\",{\"1\":{\"530\":1}}],[\"而非通用的多任务处理者\",{\"1\":{\"520\":1}}],[\"而非物理复制数据\",{\"1\":{\"427\":1}}],[\"而非\",{\"1\":{\"312\":1,\"535\":1,\"539\":1,\"808\":1}}],[\"而非训练时间变长\",{\"1\":{\"136\":1}}],[\"而图像编码器\",{\"1\":{\"299\":1,\"300\":1}}],[\"而图像编码器则用于提取图像的特征\",{\"1\":{\"299\":1}}],[\"而剩余的个文本\",{\"1\":{\"299\":1}}],[\"而且任何一个词都有可能是被替换掉的\",{\"1\":{\"572\":1}}],[\"而且能适应不同大小数据集\",{\"1\":{\"515\":1}}],[\"而且下游任务表现出相似甚至更好的性能\",{\"1\":{\"286\":1}}],[\"而且动量队列可能重复包含同一个样本\",{\"1\":{\"145\":1}}],[\"而dual\",{\"1\":{\"283\":1}}],[\"而开源模型主要依赖英语数据\",{\"1\":{\"216\":1}}],[\"而开源模型多采用固定分辨率\",{\"1\":{\"216\":1}}],[\"而开源模型的视觉基础模型\",{\"1\":{\"216\":1}}],[\"而文本编码器\",{\"1\":{\"199\":1}}],[\"而参数数量相同时\",{\"1\":{\"197\":1}}],[\"而不支持随机图像生成\",{\"1\":{\"878\":1}}],[\"而不善于处理离散的输入\",{\"1\":{\"878\":1}}],[\"而不认识其他的向量\",{\"1\":{\"878\":1}}],[\"而不像早期方法那样依赖\",{\"1\":{\"866\":1}}],[\"而不必担心底层的基础设施和运维工作\",{\"1\":{\"715\":1}}],[\"而不能看到未来的词\",{\"1\":{\"622\":1}}],[\"而不能为\",{\"1\":{\"476\":1}}],[\"而不会说这个人性别是0\",{\"1\":{\"878\":1}}],[\"而不会影响\",{\"1\":{\"873\":1}}],[\"而不会因为约束太严而训练困难\",{\"1\":{\"846\":1}}],[\"而不会将精力聚焦在优化模型本身上\",{\"1\":{\"716\":1}}],[\"而不会考虑模型分类\",{\"1\":{\"442\":1}}],[\"而不会释放\",{\"1\":{\"340\":1}}],[\"而不需要依赖专有或不可访问的数据集\",{\"1\":{\"704\":1}}],[\"而不需要重新计算所有之前\",{\"1\":{\"544\":1}}],[\"而不需要显式复制数据\",{\"1\":{\"427\":1}}],[\"而不需要人为地去标注这种标签信息\",{\"1\":{\"242\":1}}],[\"而不需要改变整个模型参数\",{\"1\":{\"239\":1}}],[\"而不是非得用\",{\"1\":{\"847\":1}}],[\"而不是单方面去看某一个人的位置\",{\"1\":{\"837\":1}}],[\"而不是图像\",{\"1\":{\"820\":1}}],[\"而不是简单地选最大值\",{\"1\":{\"819\":1}}],[\"而不是密度最大的中心点\",{\"1\":{\"756\":1}}],[\"而不是重新生成一个新的答案\",{\"1\":{\"616\":1}}],[\"而不是进行真正意义上的概念抽象和泛化\",{\"1\":{\"530\":1}}],[\"而不是原始像素\",{\"1\":{\"770\":1}}],[\"而不是原始\",{\"1\":{\"514\":1}}],[\"而不是逐点分类\",{\"1\":{\"467\":1}}],[\"而不是真正地重新排列数据\",{\"1\":{\"426\":1}}],[\"而不是\",{\"1\":{\"374\":1,\"387\":1,\"467\":1}}],[\"而不是全局去重\",{\"1\":{\"372\":1}}],[\"而不是只靠\",{\"1\":{\"277\":1}}],[\"而不是对抗干扰样本的能力\",{\"1\":{\"274\":1}}],[\"而不是表面相似性\",{\"1\":{\"186\":1}}],[\"而不是数值大小\",{\"1\":{\"170\":1}}],[\"而不仅仅是单一标签\",{\"1\":{\"173\":1}}],[\"而不仅仅依赖单一实例\",{\"1\":{\"29\":1}}],[\"而语言模型中的掩码词都是高层语义\",{\"1\":{\"165\":1}}],[\"而在实践中我们发现使用更大的\",{\"1\":{\"807\":1}}],[\"而在本阶段\",{\"1\":{\"680\":1}}],[\"而在物理转置中\",{\"1\":{\"426\":1}}],[\"而在返回的内部函数中\",{\"1\":{\"341\":1}}],[\"而在掩码语言建模\",{\"1\":{\"157\":1}}],[\"而在\",{\"1\":{\"145\":1,\"176\":1}}],[\"而自动爬取的网页图文对\",{\"1\":{\"128\":1}}],[\"而嵌入层\",{\"1\":{\"126\":1}}],[\"而点云是无序集合\",{\"1\":{\"115\":1}}],[\"而是输出了多个\",{\"1\":{\"880\":1}}],[\"而是一个ae\",{\"1\":{\"878\":1}}],[\"而是想在一个由同一个人写成的数字串中添加数字\",{\"1\":{\"874\":1}}],[\"而是优化采样方式\",{\"1\":{\"866\":1}}],[\"而是采用了块状遮挡\",{\"1\":{\"772\":1}}],[\"而是采用缓慢更新呢\",{\"1\":{\"249\":1}}],[\"而是将大模型作为一个调用工具\",{\"1\":{\"716\":1}}],[\"而是真正朝着\",{\"1\":{\"695\":1}}],[\"而是真实泛化能力\",{\"1\":{\"522\":1}}],[\"而是对输入文本中每个\",{\"1\":{\"616\":1}}],[\"而是把相对距离压缩到若干个桶\",{\"1\":{\"591\":1}}],[\"而是把距离映射到少量\",{\"1\":{\"591\":1}}],[\"而是还要和\",{\"1\":{\"590\":1}}],[\"而是学习出来的\",{\"1\":{\"573\":1}}],[\"而是学会根据用户指令理解任务意图并生成合适的结果\",{\"1\":{\"232\":1}}],[\"而是训练策略和数据规模的优化\",{\"1\":{\"569\":1}}],[\"而是在网络的每一层添加了位置编码\",{\"1\":{\"704\":1}}],[\"而是在\",{\"1\":{\"562\":1}}],[\"而是特定群体与目标下的实用性对齐\",{\"1\":{\"539\":1}}],[\"而是列举可能性并犹豫\",{\"1\":{\"538\":1}}],[\"而是有机融合并推升了这些已有成果\",{\"1\":{\"531\":1}}],[\"而是按质量设权重采样\",{\"1\":{\"528\":1}}],[\"而是组合学到的知识\",{\"1\":{\"522\":1}}],[\"而是利用llm结果的多样性\",{\"1\":{\"502\":1}}],[\"而是多条\",{\"1\":{\"501\":1}}],[\"而是关注预测和\",{\"1\":{\"468\":1}}],[\"而是综合周围村子的情况加权得出\",{\"1\":{\"387\":1}}],[\"而是直接覆盖梯度值\",{\"1\":{\"684\":1}}],[\"而是直接让模型在训练过程中优化位置信息\",{\"1\":{\"588\":1}}],[\"而是直接存在于函数作用域里\",{\"1\":{\"336\":1}}],[\"而是直接作为\",{\"1\":{\"176\":1}}],[\"而是由调用方\",{\"1\":{\"272\":1}}],[\"而是由学生网络迭代生成\",{\"1\":{\"178\":1}}],[\"而是100多万个类别\",{\"1\":{\"243\":1}}],[\"而是\",{\"1\":{\"147\":1,\"538\":1,\"539\":1}}],[\"而是能够捕获多个尺度上的局部特征\",{\"1\":{\"95\":1}}],[\"而是通过单一语言建模目标\",{\"1\":{\"531\":1}}],[\"而是通过以下方式创建了一个新的\",{\"1\":{\"425\":1}}],[\"而是通过\",{\"1\":{\"41\":1,\"73\":1,\"145\":1}}],[\"而是通过监督点级热图\",{\"1\":{\"15\":1}}],[\"而\",{\"1\":{\"78\":1,\"83\":1,\"133\":1,\"162\":1,\"199\":1,\"277\":1,\"297\":1,\"340\":1,\"470\":1,\"481\":1,\"493\":1,\"538\":1,\"539\":1,\"560\":2,\"571\":1,\"575\":3,\"703\":1,\"772\":1,\"802\":1,\"847\":1,\"853\":1,\"867\":1,\"868\":1}}],[\"而下面这行代码实现的是一个\",{\"1\":{\"76\":1}}],[\"而几何结构文本则是单一连贯的几何描述\",{\"1\":{\"31\":1}}],[\"而great通过几何\",{\"1\":{\"7\":1}}],[\"这么做不是最高效的\",{\"1\":{\"880\":1}}],[\"这通常表现为模糊无意义的\",{\"1\":{\"874\":1}}],[\"这需要一定的信息量\",{\"1\":{\"872\":1}}],[\"这需要一个\",{\"1\":{\"86\":1}}],[\"这正是\",{\"1\":{\"854\":1}}],[\"这正好对应\",{\"1\":{\"590\":1}}],[\"这项衡量的是\",{\"1\":{\"854\":1}}],[\"这项工作为后续gpt系列模型的发展奠定了理论基础和方法框架\",{\"1\":{\"524\":1}}],[\"这让模型能更好地捕捉本通道的历史上下文\",{\"1\":{\"846\":1}}],[\"这很简单\",{\"1\":{\"846\":1}}],[\"这下\",{\"1\":{\"845\":1}}],[\"这打破了\",{\"1\":{\"845\":1}}],[\"这满足\",{\"1\":{\"845\":1}}],[\"这次的改进并不能加速采样\",{\"1\":{\"843\":1}}],[\"这相当于在图像上单独训练一个\",{\"1\":{\"808\":1}}],[\"这\",{\"1\":{\"761\":1}}],[\"这非常反直觉\",{\"1\":{\"756\":1}}],[\"这等价于找出\",{\"1\":{\"727\":1}}],[\"这对于\",{\"1\":{\"714\":1}}],[\"这影响了其对问题的理解和回答\",{\"1\":{\"709\":1}}],[\"这可能意味着\",{\"1\":{\"871\":1}}],[\"这可能会影响到其在相关领域的回答质量\",{\"1\":{\"709\":1}}],[\"这可能导致模型的知识更新滞后\",{\"1\":{\"709\":1}}],[\"这可能是因为参数量增加需要更多的语料\",{\"1\":{\"494\":1}}],[\"这引发了对未来人工智能发展的许多思考和计划\",{\"1\":{\"708\":1}}],[\"这引发我们对于\",{\"1\":{\"708\":1}}],[\"这被称为似然函数\",{\"1\":{\"758\":1}}],[\"这被称为观测分布\",{\"1\":{\"758\":1}}],[\"这被称为先验分布\",{\"1\":{\"758\":1}}],[\"这被称为\",{\"1\":{\"703\":1}}],[\"这使得我们可以更容易地计算\",{\"1\":{\"867\":1}}],[\"这使得\",{\"1\":{\"807\":1}}],[\"这使得开发者能够对\",{\"1\":{\"714\":1}}],[\"这使得它们在对话\",{\"1\":{\"705\":1}}],[\"这使得它们能够捕捉更多的语言知识和复杂的语法结构\",{\"1\":{\"705\":1}}],[\"这使得它在细粒度识别\",{\"1\":{\"112\":1}}],[\"这使得其语义编码能力得到了极大的增强\",{\"1\":{\"704\":1}}],[\"这使得当表达式为np\",{\"1\":{\"690\":1}}],[\"这和原始论文稍有不同\",{\"1\":{\"626\":1}}],[\"这和使用\",{\"1\":{\"245\":1}}],[\"这比较容易并行\",{\"1\":{\"621\":1}}],[\"这段代码的意思是\",{\"1\":{\"616\":1}}],[\"这三张图分别打印了\",{\"1\":{\"587\":1}}],[\"这三个关键要素是\",{\"1\":{\"425\":1}}],[\"这三个步骤构成了一个完整的跨模态融合流程\",{\"1\":{\"71\":1}}],[\"这尤其适合当需要长时依赖\",{\"1\":{\"577\":1}}],[\"这本质上是一个三分类的问题\",{\"1\":{\"575\":1}}],[\"这本书里介绍了我们人类大脑的\",{\"1\":{\"500\":1}}],[\"这其实是一个好处\",{\"1\":{\"873\":1}}],[\"这其实是一个很容易理解的任务\",{\"1\":{\"572\":1}}],[\"这其实是\",{\"1\":{\"758\":1}}],[\"这其实就是在说\",{\"1\":{\"616\":1}}],[\"这其实也是一种标签信息\",{\"1\":{\"242\":1}}],[\"这为后续的变分推断方法奠定了基础\",{\"1\":{\"866\":1}}],[\"这为自动微分奠定了基础\",{\"1\":{\"648\":1}}],[\"这为\",{\"1\":{\"537\":1}}],[\"这为未来探索更灵活的文本生成方式提供了启示\",{\"1\":{\"523\":1}}],[\"这造成了目标的不一致\",{\"1\":{\"535\":1}}],[\"这说明gpt\",{\"1\":{\"529\":1}}],[\"这得益于更高效的数据利用率\",{\"1\":{\"528\":1}}],[\"这限制了其在金融\",{\"1\":{\"530\":1}}],[\"这限制了模型的广泛应用\",{\"1\":{\"527\":1}}],[\"这限制了它们在许多缺乏标记数据领域的适用性\",{\"1\":{\"507\":1}}],[\"这跟之前的工作一样\",{\"1\":{\"511\":1}}],[\"这句话会引导llm\",{\"1\":{\"500\":1}}],[\"这句话没看懂没关系\",{\"1\":{\"244\":1}}],[\"这会占用大量的内存资源并消耗较多的计算资源\",{\"1\":{\"495\":1}}],[\"这会导致无法对模型参数求导\",{\"1\":{\"868\":1}}],[\"这会导致\",{\"1\":{\"773\":1}}],[\"这会导致如下图所示的共享变量a的梯度被重复累加\",{\"1\":{\"685\":1}}],[\"这会导致在跨任务上性能降低14\",{\"1\":{\"516\":1}}],[\"这会导致尺度大的特征\",{\"1\":{\"459\":1}}],[\"这会导致特征图上的空间对齐误差\",{\"1\":{\"387\":1}}],[\"这主要是因为如果矩阵\",{\"1\":{\"493\":1}}],[\"这条路径叫peft\",{\"1\":{\"483\":1}}],[\"这条路径叫全量微调fft\",{\"1\":{\"483\":1}}],[\"这表示从\",{\"1\":{\"741\":1}}],[\"这表示在内存中访问该张量时\",{\"1\":{\"423\":1}}],[\"这表明它在需要长期优化和知识整合的任务中仍有较大局限\",{\"1\":{\"530\":1}}],[\"这表明其具有一定程度的推理和快速适应能力\",{\"1\":{\"529\":1}}],[\"这表明大模型能够更好地吸收语言知识和上下文信息\",{\"1\":{\"529\":1}}],[\"这表明预训练模型中的每一层都包含了解决目标问题有用的功能\",{\"1\":{\"516\":1}}],[\"这表明训练clip模型需要消耗大量的资源\",{\"1\":{\"299\":1}}],[\"这表明\",{\"1\":{\"176\":1,\"223\":1,\"806\":1}}],[\"这有助于模型发现输入数据中更复杂的模式和关系\",{\"1\":{\"321\":1}}],[\"这也算是一类事件\",{\"1\":{\"728\":1}}],[\"这也是变分推断的精髓所在\",{\"1\":{\"869\":1}}],[\"这也是我们理解的编码全局位置信息的含义\",{\"1\":{\"587\":1}}],[\"这也是一个非常严重的问题\",{\"1\":{\"482\":1}}],[\"这也是为什么结构图中mlp\",{\"1\":{\"319\":1}}],[\"这也间接说明\",{\"1\":{\"137\":1}}],[\"这几乎是不可能完成的任务\",{\"1\":{\"314\":1}}],[\"这减少了llm学习视觉语言对齐的负担\",{\"1\":{\"313\":1}}],[\"这大大限制了它们的迁移能力和扩展性\",{\"1\":{\"305\":1}}],[\"这远远低于imagenet上的sota\",{\"1\":{\"305\":1}}],[\"这方面的工作并不多\",{\"1\":{\"305\":1}}],[\"这展示了其在图像分类任务中的灵活性和强大能力\",{\"1\":{\"300\":1}}],[\"这不刚好嘛\",{\"1\":{\"878\":1}}],[\"这不仅展示了clip的强大功能\",{\"1\":{\"300\":1}}],[\"这不就是\",{\"1\":{\"247\":1}}],[\"这保证了评估指标\",{\"1\":{\"274\":1}}],[\"这时我们不再使用编码器\",{\"1\":{\"869\":1}}],[\"这时分类分布可以写为\",{\"1\":{\"738\":1}}],[\"这时候cot的效果就不尽如人意\",{\"1\":{\"503\":1}}],[\"这时候也需要对大模型进行微调\",{\"1\":{\"482\":1}}],[\"这时候针对每个用户的数据\",{\"1\":{\"482\":1}}],[\"这时候微调就非常适用\",{\"1\":{\"482\":1}}],[\"这时候就要去掉干扰\",{\"1\":{\"274\":1}}],[\"这时就可以自定义\",{\"1\":{\"316\":1}}],[\"这时使用动量更新即可\",{\"1\":{\"246\":1}}],[\"这边\",{\"1\":{\"250\":1}}],[\"这要求\",{\"1\":{\"250\":1}}],[\"这部分的\",{\"1\":{\"881\":1}}],[\"这部分关键参数就是上面提到的低维的本质模型\",{\"1\":{\"487\":1}}],[\"这部分数据是过时的\",{\"1\":{\"249\":1}}],[\"这部分代码实现如下\",{\"1\":{\"72\":1,\"73\":1}}],[\"这篇论文介绍了gpt\",{\"1\":{\"526\":1}}],[\"这篇论文\",{\"1\":{\"519\":1}}],[\"这篇论文中介绍的方法\",{\"1\":{\"503\":1}}],[\"这篇论文里讲的另一个prompt\",{\"1\":{\"502\":1}}],[\"这篇论文里讲的一个prompt\",{\"1\":{\"501\":1}}],[\"这篇论文首次尝试使用仅支持文本输入的\",{\"1\":{\"232\":1}}],[\"这篇论文提出了一项新的任务和一个配套的数据集\",{\"1\":{\"60\":1}}],[\"这篇论文提出了一种新颖的任务设定\",{\"1\":{\"48\":1}}],[\"这整个过程就是\",{\"1\":{\"170\":1}}],[\"这启发了\",{\"1\":{\"165\":1}}],[\"这与稀疏自编码器\",{\"1\":{\"873\":1}}],[\"这与原始bert的结论相反\",{\"1\":{\"562\":1}}],[\"这与few\",{\"1\":{\"531\":1}}],[\"这与多项式逼近等传统方法有本质区别\",{\"1\":{\"385\":1}}],[\"这与传统的预训练加微调的方法有所不同\",{\"1\":{\"301\":1}}],[\"这与知识蒸馏领域的常见做法一致\",{\"1\":{\"137\":1}}],[\"这与在传统cnn中学习图像局部区域特征的过程相似\",{\"1\":{\"86\":1}}],[\"这就引出了两类掩码的配合使用\",{\"1\":{\"846\":1}}],[\"这就引出了\",{\"1\":{\"796\":1}}],[\"这就定义了随机变量\",{\"1\":{\"727\":1}}],[\"这就构成了函数与变量的\",{\"1\":{\"686\":1}}],[\"这就实现了\",{\"1\":{\"459\":1}}],[\"这就产生了一个问题\",{\"1\":{\"386\":1}}],[\"这就要求网络中的某些关键操作必须是对称函数\",{\"1\":{\"115\":1}}],[\"这就是一个新的\",{\"1\":{\"869\":1}}],[\"这就是为什么我们说样本会集中在距离原点约为\",{\"1\":{\"755\":1}}],[\"这就是贝叶斯法则在离散和连续两种情形下的表达方式\",{\"1\":{\"734\":1}}],[\"这就是梯度下降法\",{\"1\":{\"697\":1}}],[\"这就是答案\",{\"1\":{\"616\":1}}],[\"这就是捕捉局部位置关系\",{\"1\":{\"587\":1}}],[\"这就是我们在\",{\"1\":{\"854\":1}}],[\"这就是我们在优化的\",{\"1\":{\"854\":1}}],[\"这就是我们的掩码图像建模\",{\"1\":{\"773\":1}}],[\"这就是我们要去学习prompt\",{\"1\":{\"497\":1}}],[\"这就是我们熟悉的\",{\"1\":{\"459\":1}}],[\"这就是blip\",{\"1\":{\"307\":1}}],[\"这就是\",{\"1\":{\"108\":1,\"500\":1,\"727\":1}}],[\"这就是下一个\",{\"1\":{\"92\":2}}],[\"这两种表示方式分别作为预训练中的输入和输出\",{\"1\":{\"768\":1}}],[\"这两种信息在表示形式和语义侧重点上存在差异\",{\"1\":{\"587\":1}}],[\"这两种特征被concat为一个复合特征向量\",{\"1\":{\"97\":1}}],[\"这两个问题的一个重要难点是\",{\"1\":{\"874\":1}}],[\"这两个网络互相对抗\",{\"1\":{\"840\":1}}],[\"这两个网络输出的是变换矩阵\",{\"1\":{\"108\":1}}],[\"这两个向量都在同一个向量空间中\",{\"1\":{\"590\":1}}],[\"这两个数表示\",{\"1\":{\"575\":1}}],[\"这两个模型都属于融合图像与文本的多模态模型\",{\"1\":{\"297\":1}}],[\"这两个操作交替进行\",{\"1\":{\"73\":1}}],[\"这里为了与标准机器学习的习惯保持一致\",{\"1\":{\"874\":1}}],[\"这里为了方便理解\",{\"1\":{\"481\":1}}],[\"这里提到的函数\",{\"1\":{\"871\":1}}],[\"这里生成器的目标是让判别器认为生成样本是真的\",{\"1\":{\"840\":1}}],[\"这里设置为1\",{\"1\":{\"814\":2}}],[\"这里设置为图像块的大小\",{\"1\":{\"318\":2}}],[\"这里关于\",{\"1\":{\"814\":1}}],[\"这里他们写作\",{\"1\":{\"807\":1}}],[\"这里试验顺序重要\",{\"1\":{\"741\":1}}],[\"这里将数值数据封装在variable中\",{\"1\":{\"697\":1}}],[\"这里我准备做一个文本分类任务\",{\"1\":{\"593\":1}}],[\"这里保持一致性\",{\"1\":{\"591\":1}}],[\"这里pad部分指的是对于不同的句子\",{\"1\":{\"581\":1}}],[\"这里也非常像我们人类学习解决复杂问题的过程\",{\"1\":{\"503\":1}}],[\"这里有像我们人类解决问题的过程\",{\"1\":{\"502\":1}}],[\"这里简单推理一下\",{\"1\":{\"493\":1}}],[\"这里简单介绍一下cls\",{\"1\":{\"319\":1}}],[\"这里先简单介绍一下\",{\"1\":{\"488\":1}}],[\"这里面∆w主是我们要微调得到的结果\",{\"1\":{\"487\":1}}],[\"这里把所有\",{\"1\":{\"473\":1}}],[\"这里采用的是\",{\"1\":{\"577\":1}}],[\"这里采用的方法是一种\",{\"1\":{\"470\":1}}],[\"这里采用了余弦相似度的计算方法\",{\"1\":{\"302\":1}}],[\"这里使用符号\",{\"1\":{\"758\":1}}],[\"这里使用的是负的\",{\"1\":{\"473\":1}}],[\"这里使用的是之前讲过的个体判别任务\",{\"1\":{\"246\":1}}],[\"这里使用\",{\"1\":{\"470\":1}}],[\"这里暂时未使用\",{\"1\":{\"468\":1}}],[\"这里解释一下\",{\"1\":{\"426\":1}}],[\"这里按\",{\"1\":{\"372\":1}}],[\"这里没有去掉最后那个\",{\"1\":{\"372\":1}}],[\"这里是想解决反馈系统的效率问题\",{\"1\":{\"483\":1}}],[\"这里是用0填充\",{\"1\":{\"369\":1}}],[\"这里是一个长度为2的元组\",{\"1\":{\"369\":1}}],[\"这里不直接使用\",{\"1\":{\"473\":1}}],[\"这里不再贴出\",{\"1\":{\"327\":1}}],[\"这里不过多进行展开\",{\"1\":{\"147\":1}}],[\"这里需要注意一点\",{\"1\":{\"581\":1}}],[\"这里需要激活\",{\"1\":{\"468\":1}}],[\"这里需要将其分离开来\",{\"1\":{\"322\":1}}],[\"这里需要和\",{\"1\":{\"145\":1}}],[\"这里主要有两种位置编码思路\",{\"1\":{\"320\":1}}],[\"这里对训练集的处理方式是随机切成224x224像素的图片\",{\"1\":{\"317\":1}}],[\"这里对提取的文本特征和图像特征进行对比学习\",{\"1\":{\"299\":1}}],[\"这里共有个正样本\",{\"1\":{\"299\":1}}],[\"这里以搜索向日葵花为例\",{\"1\":{\"303\":1}}],[\"这里以\",{\"1\":{\"274\":1}}],[\"这里全\",{\"1\":{\"272\":1}}],[\"这里就是\",{\"1\":{\"250\":1}}],[\"这里只取第一个元素\",{\"1\":{\"186\":1}}],[\"这里只取前b个样本\",{\"1\":{\"162\":1}}],[\"这里的例子比较简单\",{\"1\":{\"575\":1}}],[\"这里的关键是在prompt中加入的示例\",{\"1\":{\"501\":1}}],[\"这里的原因\",{\"1\":{\"321\":1}}],[\"这里的相似度直接计算文本特征和图像特征的余弦相似性\",{\"1\":{\"299\":1}}],[\"这里的重点是\",{\"1\":{\"252\":1}}],[\"这里的\",{\"1\":{\"157\":1,\"170\":1,\"318\":1,\"853\":1,\"873\":1}}],[\"这里的三个\",{\"1\":{\"93\":1}}],[\"这里\",{\"1\":{\"154\":1,\"277\":1,\"340\":1,\"510\":2,\"590\":1,\"682\":1,\"727\":1,\"748\":1,\"807\":1,\"828\":1}}],[\"这里tgt就是roberta编码得到的文本特征嵌入向量\",{\"1\":{\"76\":1}}],[\"这在计算上代价很高\",{\"1\":{\"868\":1}}],[\"这在模拟某些\",{\"1\":{\"744\":1}}],[\"这在lora这篇论文中也被称为低秩分解自适应技术\",{\"1\":{\"490\":1}}],[\"这在某些场景下会导致位置偏差\",{\"1\":{\"386\":1}}],[\"这在调试\",{\"1\":{\"346\":1}}],[\"这在日志记录\",{\"1\":{\"342\":1}}],[\"这在处理非均匀采样的数据时可能不是最优的选择\",{\"1\":{\"90\":1}}],[\"这在使用\",{\"1\":{\"83\":1}}],[\"这样才能让总的信息量变得有限\",{\"1\":{\"873\":1}}],[\"这样才能确保所有路径的贡献都被纳入最终的梯度值\",{\"1\":{\"684\":1}}],[\"这样处理之后\",{\"1\":{\"873\":1}}],[\"这样采样\",{\"1\":{\"853\":1}}],[\"这样用自己之前时刻的状态预测下一个状态的模型\",{\"1\":{\"847\":1}}],[\"这样即可缩小松弛后的验证\",{\"1\":{\"808\":1}}],[\"这样分开好处是\",{\"1\":{\"807\":1}}],[\"这样标准的\",{\"1\":{\"769\":1}}],[\"这样它就可以恢复\",{\"1\":{\"704\":1}}],[\"这样前一半桶表示左方向\",{\"1\":{\"591\":1}}],[\"这样既让模型\",{\"1\":{\"591\":1}}],[\"这样得到的结果是一个标量\",{\"1\":{\"590\":1}}],[\"这样在后续的softmax计算中\",{\"1\":{\"584\":1}}],[\"这样在训练中最小化损失就等于最大化重叠度\",{\"1\":{\"471\":1}}],[\"这样难免会影响到最终的结果\",{\"1\":{\"575\":1}}],[\"这样强迫模型在编码当前时刻词的时候不能太依赖当前的词\",{\"1\":{\"572\":1}}],[\"这样不断反复直到遇到终止符\",{\"1\":{\"541\":1}}],[\"这样不就不一致了吗\",{\"1\":{\"246\":1}}],[\"这样llm输出的内容也会更加贴合我们的需求\",{\"1\":{\"499\":1}}],[\"这样越接近\",{\"1\":{\"469\":1}}],[\"这样计算量就大大减小了\",{\"1\":{\"318\":1}}],[\"这样就公平\",{\"1\":{\"837\":1}}],[\"这样就将原本不定尺寸的\",{\"1\":{\"386\":1}}],[\"这样就能让\",{\"1\":{\"321\":1,\"618\":1}}],[\"这样就可以完成vit的训练过程\",{\"1\":{\"323\":1}}],[\"这样就可以提取出对最终任务有帮助的特征组合\",{\"1\":{\"321\":1}}],[\"这样就可以直接利用交互层来处理视觉特征\",{\"1\":{\"281\":1,\"284\":1}}],[\"这样就成了一个一维序列\",{\"1\":{\"318\":1}}],[\"这样可以提高\",{\"1\":{\"800\":1}}],[\"这样可以提升计算效率\",{\"1\":{\"322\":1}}],[\"这样可以看出每个头分别关注图像的哪部分区域\",{\"1\":{\"463\":1}}],[\"这样可以减少内存使用和计算开销\",{\"1\":{\"365\":1}}],[\"这样可以为\",{\"1\":{\"326\":1}}],[\"这样可以在模型的不同阶段交替利用\",{\"1\":{\"326\":1}}],[\"这样可以在每个部分上独立地学习特征\",{\"1\":{\"86\":1}}],[\"这样可以保证模型的特征提取能力和性能\",{\"1\":{\"317\":1}}],[\"这样每个卷积核对应一个\",{\"1\":{\"272\":1}}],[\"这样每个点在预测标签时都能看到整个物体的上下文\",{\"1\":{\"105\":1}}],[\"这样字典是高度一致的\",{\"1\":{\"250\":1}}],[\"这样我们就可以将期望写为如下形式\",{\"1\":{\"868\":1}}],[\"这样我们只需采样一个\",{\"1\":{\"868\":1}}],[\"这样我们的队列就可以设置得很大\",{\"1\":{\"246\":1}}],[\"这样我们会得到两个不太一样的照片\",{\"1\":{\"243\":1}}],[\"这样做其实类似于把骨干网络当成一个特征提取器\",{\"1\":{\"245\":1}}],[\"这样做的意义在于\",{\"1\":{\"816\":1}}],[\"这样做的好处是\",{\"1\":{\"572\":1}}],[\"这样做的目的是提高模型的效率和泛化能力\",{\"1\":{\"86\":1}}],[\"这样做的原因是因为交互文本由当前图片反映的交互行为和模型额外补充的当前物体存在的其他交互行为构成\",{\"1\":{\"31\":1}}],[\"这样一来我们就绕过了后验分布\",{\"1\":{\"867\":1}}],[\"这样一来\",{\"1\":{\"176\":1,\"490\":1,\"807\":1}}],[\"这样的设定具有计算上的优势\",{\"1\":{\"868\":1}}],[\"这样的设计使得\",{\"1\":{\"157\":1}}],[\"这样的模型不一定实用\",{\"1\":{\"864\":1}}],[\"这样的集合都定义概率\",{\"1\":{\"728\":1}}],[\"这样的\",{\"1\":{\"616\":1}}],[\"这样的大模型\",{\"1\":{\"491\":1}}],[\"这样的大模型中\",{\"1\":{\"475\":1}}],[\"这样的格式来生成文本描述\",{\"1\":{\"301\":1}}],[\"这样的共享设计能够提升训练效率\",{\"1\":{\"126\":1}}],[\"这样模型就能根据上下文更准确地做出判断\",{\"1\":{\"111\":1}}],[\"这样\",{\"1\":{\"95\":2,\"107\":1,\"280\":1,\"318\":1,\"469\":1,\"562\":1,\"591\":1,\"690\":1,\"707\":1,\"843\":1,\"878\":4,\"882\":1,\"883\":1}}],[\"这种解决问题的思路可以应用到所有图像生成类任务上\",{\"1\":{\"883\":1}}],[\"这种解释也叫作\",{\"1\":{\"872\":1}}],[\"这种技术是说\",{\"1\":{\"881\":1}}],[\"这种技术被广泛应用于扩散模型\",{\"1\":{\"816\":1}}],[\"这种现象是合理的\",{\"1\":{\"873\":1}}],[\"这种参数的存在依赖于我们对\",{\"1\":{\"873\":1}}],[\"这种重参数化只是数学上的变换\",{\"1\":{\"873\":1}}],[\"这种修改不会改变模型本质\",{\"1\":{\"873\":1}}],[\"这种视角也正是许多\",{\"1\":{\"872\":1}}],[\"这种下界估计虽然不是完全精确\",{\"1\":{\"869\":1}}],[\"这种最大似然方法保证模型倾向于生成训练样本及其相似样本\",{\"1\":{\"865\":1}}],[\"这种每次生成一个像素\",{\"1\":{\"847\":1}}],[\"这种掩码设计\",{\"1\":{\"846\":1}}],[\"这种机制可以巧妙地掩盖住每个像素右侧和下侧的信息\",{\"1\":{\"845\":1}}],[\"这种根据实验结果推断最有可能的硬币属性\",{\"1\":{\"825\":1}}],[\"这种遮挡方式\",{\"1\":{\"801\":1}}],[\"这种内在学习能力可能是\",{\"1\":{\"781\":1}}],[\"这种分布之所以受欢迎\",{\"1\":{\"750\":1}}],[\"这种分离的设计让模型更灵活\",{\"1\":{\"413\":1}}],[\"这种含有两个参数的分布比泊松分布更具有建模灵活性\",{\"1\":{\"744\":1}}],[\"这种组合你也得能谈\",{\"1\":{\"728\":1}}],[\"这种能力可能是通过对代码的训练获得的\",{\"1\":{\"706\":1}}],[\"这种能力允许语言模型在提供自然语言指令或多个任务示例的情况下\",{\"1\":{\"706\":1}}],[\"这种归一化方法可以避免梯度爆炸和消失的问题\",{\"1\":{\"704\":1}}],[\"这种情况下\",{\"1\":{\"687\":1,\"728\":1}}],[\"这种位置编码方式能够根据具体的任务和数据特点\",{\"1\":{\"588\":1}}],[\"这种位置编码方法也存在以下一些不足之处\",{\"1\":{\"587\":1}}],[\"这种不可解释性限制了其在高风险领域的应用\",{\"1\":{\"530\":1}}],[\"这种\",{\"1\":{\"528\":1,\"530\":2,\"690\":1,\"778\":1}}],[\"这种性能差异揭示了当前方法的边界\",{\"1\":{\"523\":1}}],[\"这种局限性部分源于单任务\",{\"1\":{\"520\":1}}],[\"这种转置后的布局在缓存访问上可能效率较低\",{\"1\":{\"426\":1}}],[\"这种差异一方面是由于文本和图像属于两个完全不同的模态\",{\"1\":{\"305\":1}}],[\"这种预训练通常是基于有监督学习的\",{\"1\":{\"305\":1}}],[\"这种格式\",{\"1\":{\"301\":1}}],[\"这种策略有助于模型学习跨模态对齐能力\",{\"1\":{\"274\":1}}],[\"这种模型最朴素的实现方法\",{\"1\":{\"843\":1}}],[\"这种模型\",{\"1\":{\"248\":1}}],[\"这种提升并不依赖增加模型参数\",{\"1\":{\"181\":1}}],[\"这种传播方式有两类\",{\"1\":{\"176\":1}}],[\"这种方式效率极低\",{\"1\":{\"866\":1}}],[\"这种方式需要我们手动把两个分布都以\",{\"1\":{\"799\":1}}],[\"这种方式在输出为标量的情况下计算效率更高\",{\"1\":{\"656\":1}}],[\"这种方式在训练初期让模型更多依赖于\",{\"1\":{\"159\":1}}],[\"这种方式的问题是\",{\"1\":{\"542\":1}}],[\"这种方式避免了目标检测的步骤\",{\"1\":{\"280\":1}}],[\"这种方式显著提升了模型的效果\",{\"1\":{\"269\":1}}],[\"这种方式比直接使用图像\",{\"1\":{\"266\":1}}],[\"这种方法虽然效果强大\",{\"1\":{\"531\":1}}],[\"这种方法无需微调\",{\"1\":{\"521\":1}}],[\"这种方法重新引入了大量特定任务的定制化输入\",{\"1\":{\"512\":1}}],[\"这种方法不需要复制数据\",{\"1\":{\"426\":1}}],[\"这种方法实际上与nlp领域的一个研究方向\",{\"1\":{\"301\":1}}],[\"这种方法能够捕获较为精细的对象信息\",{\"1\":{\"280\":1}}],[\"这种方法的优势在于\",{\"1\":{\"179\":1}}],[\"这种方法通常被称为\",{\"1\":{\"176\":1}}],[\"这种方法大大增强了网络处理非均匀采样数据的能力\",{\"1\":{\"96\":1}}],[\"这种方法使得网络能够在细节丰富的区域\",{\"1\":{\"95\":1}}],[\"这种方法使网络能够通过在训练期间随机丢弃输入点\",{\"1\":{\"95\":1}}],[\"这种伪标签不仅能补充视觉信息中的遗漏\",{\"1\":{\"157\":1}}],[\"这种非均匀性为点集特征学习带来了显著挑战\",{\"1\":{\"94\":1}}],[\"这种类别不平衡\",{\"1\":{\"82\":1}}],[\"这种设计使得网络能够更好地处理深层特征\",{\"1\":{\"382\":1}}],[\"这种设计使得网络只关注\",{\"1\":{\"112\":1}}],[\"这种设计使得语言信息能有效地指导点特征的学习过程\",{\"1\":{\"75\":1}}],[\"这种设计无需依赖具体的可供性分类标签\",{\"1\":{\"15\":1}}],[\"这意味着在\",{\"1\":{\"873\":1}}],[\"这意味着重复计算\",{\"1\":{\"544\":1}}],[\"这意味着对齐方法不仅优化模型行为\",{\"1\":{\"539\":1}}],[\"这意味着few\",{\"1\":{\"530\":1}}],[\"这意味着它能够在没有任何特定任务训练数据的情况下\",{\"1\":{\"300\":1}}],[\"这意味着即使是不同的局部子集\",{\"1\":{\"86\":1}}],[\"这意味着\",{\"1\":{\"82\":1,\"112\":1,\"451\":1,\"455\":1,\"706\":1,\"755\":1,\"839\":1,\"866\":1}}],[\"这是变分自编码器\",{\"1\":{\"857\":1}}],[\"这是最大值\",{\"1\":{\"838\":1}}],[\"这是视觉场景理解中的一个经典问题\",{\"1\":{\"759\":1}}],[\"这是由python的运算符调度机制决定的\",{\"1\":{\"690\":1}}],[\"这是抽取式问答模型的局限性\",{\"1\":{\"616\":1}}],[\"这是固定的位置编码\",{\"1\":{\"588\":1}}],[\"这是毋庸置疑的\",{\"1\":{\"575\":1}}],[\"这是因为vq\",{\"1\":{\"878\":1}}],[\"这是因为\",{\"1\":{\"847\":1}}],[\"这是因为样本几乎全部落在离\",{\"1\":{\"756\":1}}],[\"这是因为同一个变量对输出的影响路径有多条\",{\"1\":{\"684\":1}}],[\"这是因为它们的训练目标是最大化互联网文本的下一个词预测概率\",{\"1\":{\"535\":1}}],[\"这是因为在实际采集过程中\",{\"1\":{\"107\":1}}],[\"这是我们使用llm的人的职责\",{\"1\":{\"497\":1}}],[\"这是交叉熵损失\",{\"1\":{\"470\":1}}],[\"这是通过\",{\"1\":{\"425\":1}}],[\"这是注意力权重矩阵的来源\",{\"1\":{\"407\":1}}],[\"这是它最大的优势\",{\"1\":{\"362\":1}}],[\"这是一个普通的\",{\"1\":{\"885\":1}}],[\"这是一个从\",{\"1\":{\"819\":1}}],[\"这是一个根本上的病态问题\",{\"1\":{\"759\":1}}],[\"这是一个一举多得\",{\"1\":{\"707\":1}}],[\"这是一个椅子\",{\"1\":{\"111\":1}}],[\"这是一项本质上的进步\",{\"1\":{\"707\":1}}],[\"这是一种全新的\",{\"1\":{\"707\":1}}],[\"这是一种数据增强的方式\",{\"1\":{\"317\":1}}],[\"这是一款在推理和通用任务上有显著提升的模型\",{\"1\":{\"704\":1}}],[\"这是为了满足\",{\"1\":{\"800\":1}}],[\"这是为了让字典里的特征尽可能保持一致\",{\"1\":{\"245\":1}}],[\"这是为了每个\",{\"1\":{\"143\":1}}],[\"这是首次尝试将大语言模型用于模型集成\",{\"1\":{\"236\":1}}],[\"这是实现\",{\"1\":{\"235\":1}}],[\"这是后续指令调优的基础\",{\"1\":{\"233\":1}}],[\"这是第一个系统性地将\",{\"1\":{\"232\":1}}],[\"这是主流做法\",{\"1\":{\"199\":1}}],[\"这是\",{\"1\":{\"76\":1,\"92\":1,\"163\":1,\"232\":1,\"272\":1,\"312\":1,\"501\":1,\"502\":1,\"503\":1,\"800\":1}}],[\"这是训练中未曾遇到过的功能\",{\"1\":{\"65\":1}}],[\"这个操作是求不了导的\",{\"1\":{\"880\":1}}],[\"这个操作被称为\",{\"1\":{\"92\":1}}],[\"这个类别的序号就是我们想要的整数\",{\"1\":{\"880\":1}}],[\"这个问题是无解的\",{\"1\":{\"878\":1}}],[\"这个问题的答案\",{\"1\":{\"575\":1}}],[\"这个离散向量构成的空间是不好采样的\",{\"1\":{\"878\":1}}],[\"这个嵌入层在vq\",{\"1\":{\"878\":1}}],[\"这个测试时的网络结构在图5中有示意\",{\"1\":{\"869\":1}}],[\"这个设计使得模型输出能\",{\"1\":{\"865\":1}}],[\"这个约束能防止函数的变化太快\",{\"1\":{\"839\":1}}],[\"这个平均距离越大\",{\"1\":{\"837\":1}}],[\"这个最大点称为参数的最大似然估计\",{\"1\":{\"825\":1}}],[\"这个对比模型会根据图像和文字的匹配程度给出一个评分\",{\"1\":{\"811\":1}}],[\"这个求和很难直接算\",{\"1\":{\"807\":1}}],[\"这个损失鼓励\",{\"1\":{\"798\":1}}],[\"这个向量序列随后被送入\",{\"1\":{\"771\":1}}],[\"这个除数被称为边际似然\",{\"1\":{\"758\":1}}],[\"这个分布的一个显著特点是\",{\"1\":{\"749\":1}}],[\"这个分布可以被看作是标准正态分布\",{\"1\":{\"747\":1}}],[\"这个结论来自于\",{\"1\":{\"729\":1}}],[\"这个公式\",{\"1\":{\"867\":1}}],[\"这个公式可以由以下恒等式直接推出\",{\"1\":{\"758\":1}}],[\"这个公式适用于任意两个事件\",{\"1\":{\"729\":1}}],[\"这个公式对应的是\",{\"1\":{\"729\":1}}],[\"这个公式其实可以直接用在对比学习中\",{\"1\":{\"248\":1}}],[\"这个事件也应该存在\",{\"1\":{\"728\":1}}],[\"这个事件存在\",{\"1\":{\"728\":1}}],[\"这个事情的性价比非常低\",{\"1\":{\"482\":1}}],[\"这个规则体系就是σ\",{\"1\":{\"728\":1}}],[\"这个数据集来源是这里\",{\"1\":{\"593\":1}}],[\"这个数据集中剩余的所有图片都是负样本\",{\"1\":{\"243\":1}}],[\"这个整数就是偏置查表的索引\",{\"1\":{\"591\":1}}],[\"这个怎么去理解\",{\"1\":{\"587\":1}}],[\"这个阶段的prompt中包含三部分内容\",{\"1\":{\"503\":1}}],[\"这个阶段的prompt中要包含分解问题的示例\",{\"1\":{\"503\":1}}],[\"这个阶段相当于在语言模型的词空间中\",{\"1\":{\"234\":1}}],[\"这个词\",{\"1\":{\"481\":1,\"847\":1}}],[\"这个表达式其实是通过\",{\"1\":{\"470\":1}}],[\"这个衰减因子能够使得易分类的样本\",{\"1\":{\"470\":1}}],[\"这个矩阵的每一个元素对应于\",{\"1\":{\"885\":1}}],[\"这个矩阵是\",{\"1\":{\"455\":1}}],[\"这个矩阵就叫\",{\"1\":{\"455\":1}}],[\"这个矩阵表示的是每个\",{\"1\":{\"407\":1}}],[\"这个矩阵表示对点云所做的变换\",{\"1\":{\"107\":1}}],[\"这个新内存布局使得每一行是连续的\",{\"1\":{\"426\":1}}],[\"这个新维度就是拼接的那一维\",{\"1\":{\"358\":1}}],[\"这个张量会成为模型的一个成员\",{\"1\":{\"366\":1}}],[\"这个维度上添加一维\",{\"1\":{\"320\":1}}],[\"这个就是额外添加的一个\",{\"1\":{\"319\":1}}],[\"这个token\",{\"1\":{\"319\":1}}],[\"这个功能具体实现在其内部的\",{\"1\":{\"272\":1}}],[\"这个输出向量会通过其\",{\"1\":{\"255\":1}}],[\"这个增强方法\",{\"1\":{\"252\":1}}],[\"这个值\",{\"1\":{\"249\":1}}],[\"这个时候\",{\"1\":{\"248\":1}}],[\"这个是softmax的公式\",{\"1\":{\"248\":1}}],[\"这个动态的字典分为两个部分\",{\"1\":{\"245\":1}}],[\"这个名字就是来源于前两个单词的前两个字母\",{\"1\":{\"244\":1}}],[\"这个粒度其实是很细\",{\"1\":{\"243\":1}}],[\"这个代理任务\",{\"1\":{\"243\":1}}],[\"这个代理任务是指\",{\"1\":{\"243\":1}}],[\"这个变换矩阵是近似正交的\",{\"1\":{\"107\":1}}],[\"这个模型使用了\",{\"1\":{\"96\":1}}],[\"这个模块实现了\",{\"1\":{\"96\":1}}],[\"这个特征向量代表了这个局部区域的高维特征\",{\"1\":{\"92\":1}}],[\"这个函数在误差较小时近似于\",{\"1\":{\"797\":1}}],[\"这个函数的有一个输入参数\",{\"1\":{\"626\":1}}],[\"这个函数的作用是将输入的文本转化为对应的嵌入表示\",{\"1\":{\"302\":1}}],[\"这个函数的作用是从点云中找出每个查询点周围一定半径范围内的邻近点索引\",{\"1\":{\"92\":1}}],[\"这个函数的作用是从输入点云中\",{\"1\":{\"92\":1}}],[\"这个函数实现的是根据给定的索引\",{\"1\":{\"92\":1}}],[\"这个函数实现的是最远点采样\",{\"1\":{\"92\":1}}],[\"这个过程可以理解为一种由语言引导的搜索\",{\"1\":{\"811\":1}}],[\"这个过程有点像\",{\"1\":{\"501\":1}}],[\"这个过程其实也是自监督训练的一个过程\",{\"1\":{\"242\":1}}],[\"这个过程类似于在传统的卷积神经网络中如何处理图像的小区域\",{\"1\":{\"86\":1}}],[\"这个过程发生在数据集准备阶段\",{\"1\":{\"28\":1}}],[\"这个\",{\"1\":{\"74\":1,\"302\":1,\"795\":1,\"873\":1}}],[\"这些生成工具对设计师等用户非常有用\",{\"1\":{\"864\":1}}],[\"这些像素之间存在复杂的依赖关系\",{\"1\":{\"864\":1}}],[\"这些问题限制了模型在实际应用中的表现\",{\"1\":{\"806\":1}}],[\"这些都属于\",{\"1\":{\"728\":1}}],[\"这些涌现能力让\",{\"1\":{\"706\":1}}],[\"这些特点使得\",{\"1\":{\"864\":1}}],[\"这些特点使\",{\"1\":{\"705\":1}}],[\"这些特点使它们在自然语言处理和其他领域中引起了广泛的兴趣和研究\",{\"1\":{\"705\":1}}],[\"这些特征\",{\"1\":{\"249\":1}}],[\"这些函数被称为测试函数\",{\"1\":{\"692\":1}}],[\"这些位置的概率就会接近0\",{\"1\":{\"584\":1}}],[\"这些是\",{\"1\":{\"578\":1}}],[\"这些词汇是从wikipedia的优质文章和标杆文章中提取得到\",{\"1\":{\"577\":1}}],[\"这些改进通常依赖于更大模型和更多数据\",{\"1\":{\"568\":1}}],[\"这些改进共同构成了roberta的核心优化策略\",{\"1\":{\"562\":1}}],[\"这些改进包括更长的训练时间\",{\"1\":{\"558\":1}}],[\"这些改写使得在预训练模型架构上用最小的修改就会有效\",{\"1\":{\"507\":1}}],[\"这些研究强调\",{\"1\":{\"536\":1}}],[\"这些限制提示我们\",{\"1\":{\"530\":1}}],[\"这些任务测试了gpt\",{\"1\":{\"529\":1}}],[\"这些发现为后续gpt\",{\"1\":{\"523\":1}}],[\"这些实验为后续研究\",{\"1\":{\"522\":1}}],[\"这些实验表明\",{\"1\":{\"237\":1}}],[\"这些设计使\",{\"1\":{\"521\":1}}],[\"这些设计让训练流程非常完整\",{\"1\":{\"395\":1}}],[\"这些系统往往对数据分布或任务定义的微小变化非常敏感\",{\"1\":{\"520\":1}}],[\"这些输入转换使作者避免跨任务架构的大改\",{\"1\":{\"512\":1}}],[\"这些参数会以随机梯度下降训练\",{\"1\":{\"510\":1}}],[\"这些不确定性使得开发有效的语言处理半监督学习方法变得困难\",{\"1\":{\"507\":1}}],[\"这些地址从\",{\"1\":{\"421\":1}}],[\"这些区域的大小各不相同\",{\"1\":{\"386\":1}}],[\"这些变量依然存在\",{\"1\":{\"340\":1}}],[\"这些代码块里定义的变量\",{\"1\":{\"336\":1}}],[\"这些代理任务\",{\"1\":{\"242\":1}}],[\"这些值会根据模型的损失函数不断调整\",{\"1\":{\"320\":1}}],[\"这些相似度值可以被视为logits\",{\"1\":{\"300\":1}}],[\"这些图像特征会与之前得到的个文本特征进行余弦相似度计算\",{\"1\":{\"300\":1}}],[\"这些文本随后被输入到文本编码器\",{\"1\":{\"300\":1}}],[\"这些数据集包括\",{\"1\":{\"704\":1}}],[\"这些数据在论文中被称为webimagetext\",{\"1\":{\"299\":1}}],[\"这些数据由\",{\"1\":{\"235\":1}}],[\"这些表示会被输入到\",{\"1\":{\"263\":1}}],[\"这些规则可以去定义哪些图片是相似的\",{\"1\":{\"242\":1}}],[\"这些指令可以是开放式的\",{\"1\":{\"232\":1}}],[\"这些指标共同构成了\",{\"1\":{\"82\":1}}],[\"这些模型都是把图像的颜色看成一个连续的浮点数\",{\"1\":{\"847\":1}}],[\"这些模型都是以cnn为基础\",{\"1\":{\"621\":1}}],[\"这些模型的发布旨在促进研究社区的开放访问和研究\",{\"1\":{\"546\":1}}],[\"这些模型的优势在于大规模参数\",{\"1\":{\"218\":1}}],[\"这些模型多基于纯视觉数据\",{\"1\":{\"191\":1}}],[\"这些工作主要依赖轻量级适配层\",{\"1\":{\"193\":1}}],[\"这些\",{\"1\":{\"179\":1,\"223\":1,\"572\":1}}],[\"这些分布由网络输出经过\",{\"1\":{\"178\":1}}],[\"这些信息可以直接在最后一个\",{\"1\":{\"173\":1}}],[\"这些预训练目标利用上下文信息提供了更丰富的学习信号\",{\"1\":{\"173\":1}}],[\"这些点大致构成物体的骨架\",{\"1\":{\"112\":1}}],[\"这些点彼此之间的最小距离尽可能大\",{\"1\":{\"89\":1}}],[\"这些方法常用于图像生成\",{\"1\":{\"787\":1}}],[\"这些方法训练稳定\",{\"1\":{\"786\":1}}],[\"这些方法需要构造正负样本对\",{\"1\":{\"784\":1}}],[\"这些方法为\",{\"1\":{\"536\":1}}],[\"这些方法在数据需求和任务适应能力之间形成一个光谱\",{\"1\":{\"528\":1}}],[\"这些方法仍依赖监督数据\",{\"1\":{\"520\":1}}],[\"这些方法仍受限于训练语义空间\",{\"1\":{\"7\":1}}],[\"这些方法都有各自的特点\",{\"1\":{\"491\":1}}],[\"这些方法使用深层transformer进行交互作用\",{\"1\":{\"282\":1}}],[\"这些方法大多忽略了高层语义信息\",{\"1\":{\"165\":1}}],[\"这些方法会导致信息损失\",{\"1\":{\"103\":1}}],[\"这些人离我太远了\",{\"1\":{\"92\":1}}],[\"这些功能标签仅用于构造问题和定位正确功能区域\",{\"1\":{\"64\":1}}],[\"这些功能标注是人工标注的\",{\"1\":{\"62\":1}}],[\"这一工具\",{\"1\":{\"883\":1}}],[\"这一点提供了理论上的安慰\",{\"1\":{\"871\":1}}],[\"这一操作本质上是非连续的\",{\"1\":{\"868\":1}}],[\"这一特性也允许我们指定颜色的亮度级别\",{\"1\":{\"847\":1}}],[\"这一复杂任务以前通常需要专门设计的方案才能实现\",{\"1\":{\"806\":1}}],[\"这一里程碑式的更新\",{\"1\":{\"714\":1}}],[\"这一阶段\",{\"1\":{\"693\":1}}],[\"这一扩展使我们的函数定义更接近\",{\"1\":{\"681\":1}}],[\"这一策略虽限制数据量\",{\"1\":{\"547\":1}}],[\"这一设计理念直接反映在模型架构选择上\",{\"1\":{\"547\":1}}],[\"这一方法起初应用于强化学习场景\",{\"1\":{\"536\":1}}],[\"这一研究为探索语言模型的元学习机制和实际应用奠定了基础\",{\"1\":{\"527\":1}}],[\"这一研究为功能学习领域提供了新的视角\",{\"1\":{\"48\":1}}],[\"这一发现也暗示\",{\"1\":{\"871\":1}}],[\"这一发现标志着大型语言模型\",{\"1\":{\"703\":1}}],[\"这一发现挑战了单纯追求参数规模的范式\",{\"1\":{\"547\":1}}],[\"这一发现表明\",{\"1\":{\"524\":1}}],[\"这一发现为理解当前预训练模型的有效性提供了新视角\",{\"1\":{\"523\":1}}],[\"这一发现为构建通用语言系统提供了新方向\",{\"1\":{\"520\":1}}],[\"这一框架允许模型不仅生成文本\",{\"1\":{\"521\":1}}],[\"这一块的技巧性很强\",{\"1\":{\"500\":1}}],[\"这一条件\",{\"1\":{\"385\":1}}],[\"这一部分的目标是\",{\"1\":{\"312\":1}}],[\"这一过程类似于\",{\"1\":{\"775\":1}}],[\"这一过程对大规模计算框架\",{\"1\":{\"687\":1}}],[\"这一过程与训练时相同\",{\"1\":{\"300\":1}}],[\"这一过程通过对每个子区域应用集合抽象层\",{\"1\":{\"97\":1}}],[\"这一成果为开源多模态模型的发展提供了重要支持\",{\"1\":{\"215\":1}}],[\"这一渐进式策略确保模型\",{\"1\":{\"198\":1}}],[\"这一现象在其他动量方法\",{\"1\":{\"182\":1}}],[\"这一机制类似\",{\"1\":{\"178\":1}}],[\"这一步是不可导的\",{\"1\":{\"881\":1}}],[\"这一步是为了保证图像的整体比例不变\",{\"1\":{\"317\":1}}],[\"这一步到底引入了多少误差\",{\"1\":{\"870\":1}}],[\"这一步通常是这样做的\",{\"1\":{\"591\":1}}],[\"这一步很关键\",{\"1\":{\"346\":1}}],[\"这一步的操作在论文中是直接采用切割的处理办法\",{\"1\":{\"318\":1}}],[\"这一步不动\",{\"1\":{\"807\":1}}],[\"这一步不计算梯度\",{\"1\":{\"163\":1}}],[\"这一步不在\",{\"1\":{\"107\":1}}],[\"这一步相当于图像任务中的\",{\"1\":{\"100\":1}}],[\"这一最具挑战性的设置下\",{\"1\":{\"23\":1}}],[\"这类度量难以设计\",{\"1\":{\"866\":1}}],[\"这类方法试图从原始图像中恢复遮挡部分\",{\"1\":{\"785\":1}}],[\"这类似于计算机图形学中的一个实际问题\",{\"1\":{\"874\":1}}],[\"这类似于\",{\"1\":{\"769\":1}}],[\"这类抽取式问答任务中\",{\"1\":{\"616\":1}}],[\"这类指令\",{\"1\":{\"538\":1}}],[\"这类\",{\"1\":{\"23\":1,\"367\":1}}],[\"激活参数\",{\"1\":{\"704\":1}}],[\"激活检查点\",{\"1\":{\"548\":1}}],[\"激活模型的相关能力\",{\"1\":{\"521\":1}}],[\"激活后\",{\"1\":{\"432\":1}}],[\"激活环境的命令\",{\"1\":{\"432\":1}}],[\"激活已有知识\",{\"1\":{\"239\":1}}],[\"激活函数层\",{\"1\":{\"321\":1}}],[\"激活函数类型\",{\"1\":{\"272\":1}}],[\"激活函数\",{\"1\":{\"98\":1,\"321\":1,\"323\":2,\"471\":1,\"514\":1,\"548\":1,\"580\":2,\"599\":2,\"704\":2}}],[\"激活交互主体所在区域\",{\"1\":{\"59\":1}}],[\"激活\",{\"0\":{\"432\":1},\"1\":{\"15\":1,\"295\":1,\"704\":1}}],[\"融合了所有可能的数字和各种可能的书写风格\",{\"1\":{\"874\":1}}],[\"融合了\",{\"1\":{\"704\":1}}],[\"融合模块\",{\"1\":{\"307\":2}}],[\"融合模式\",{\"1\":{\"277\":2}}],[\"融合后的\",{\"1\":{\"277\":2}}],[\"融合后的文本特征\",{\"1\":{\"74\":1}}],[\"融合输入\",{\"1\":{\"277\":1}}],[\"融合编码器\",{\"1\":{\"261\":1,\"269\":1}}],[\"融合编码器架构\",{\"1\":{\"260\":1}}],[\"融合过程在多模态编码器的每一层中通过跨模态注意力\",{\"1\":{\"152\":1}}],[\"融合两者优势\",{\"1\":{\"150\":1}}],[\"融合特征\",{\"1\":{\"147\":1}}],[\"融合+增强\",{\"1\":{\"100\":1}}],[\"融合多个\",{\"1\":{\"76\":1}}],[\"融合多模态空间特征\",{\"0\":{\"41\":1},\"1\":{\"40\":1}}],[\"融合所有\",{\"1\":{\"76\":1}}],[\"融合生成功能表征\",{\"1\":{\"54\":1}}],[\"融合不同来源的信息\",{\"1\":{\"45\":1}}],[\"融合通道信息\",{\"1\":{\"45\":1}}],[\"融合\",{\"1\":{\"40\":1,\"277\":3}}],[\"融合语言与视觉特征\",{\"1\":{\"40\":1}}],[\"融合表示为\",{\"1\":{\"14\":1}}],[\"融合至\",{\"1\":{\"14\":1}}],[\"卷积将通道数映射为\",{\"1\":{\"848\":1}}],[\"卷积层总数\",{\"1\":{\"848\":1}}],[\"卷积核大小\",{\"1\":{\"848\":1}}],[\"卷积核的空间大小\",{\"1\":{\"846\":1}}],[\"卷积核个数为768的卷积层来进行实现\",{\"1\":{\"318\":1}}],[\"卷积后剩余的长和宽相乘作为时间维度\",{\"1\":{\"318\":1}}],[\"卷积映射\",{\"1\":{\"272\":1}}],[\"卷积\",{\"1\":{\"14\":1,\"73\":1,\"107\":1,\"808\":1,\"821\":1}}],[\"跨度预测和自回归预训练\",{\"1\":{\"568\":1}}],[\"跨领域泛化能力\",{\"1\":{\"522\":1}}],[\"跨gpu部分实现\",{\"1\":{\"145\":1}}],[\"跨模态大模型\",{\"1\":{\"704\":1}}],[\"跨模态对齐\",{\"1\":{\"277\":1}}],[\"跨模态输出\",{\"1\":{\"277\":1}}],[\"跨模态\",{\"1\":{\"272\":2,\"277\":8}}],[\"跨模态互助\",{\"1\":{\"269\":1}}],[\"跨模态注意力\",{\"1\":{\"291\":1}}],[\"跨模态注意力机制\",{\"1\":{\"76\":1}}],[\"跨模态注意力矩阵\",{\"1\":{\"41\":1}}],[\"跨模态融合层\",{\"1\":{\"277\":1}}],[\"跨模态融合\",{\"1\":{\"6\":1}}],[\"跨注意力融合公式为\",{\"1\":{\"14\":1}}],[\"kingma\",{\"1\":{\"868\":1}}],[\"kimi\",{\"1\":{\"703\":1}}],[\"kim\",{\"1\":{\"126\":1}}],[\"kru13\",{\"1\":{\"748\":1}}],[\"kolmogorov\",{\"1\":{\"729\":1}}],[\"korthikanti\",{\"1\":{\"548\":1}}],[\"k^t\",{\"1\":{\"591\":1}}],[\"katherine\",{\"1\":{\"816\":1}}],[\"kaplan\",{\"1\":{\"552\":1}}],[\"karma\",{\"1\":{\"521\":1}}],[\"karpathy\",{\"1\":{\"142\":1,\"274\":4}}],[\"kv\",{\"0\":{\"540\":1,\"541\":1},\"1\":{\"541\":1,\"544\":11,\"704\":1,\"815\":2,\"817\":2}}],[\"k通常为10\",{\"1\":{\"528\":1}}],[\"k采样\",{\"1\":{\"522\":1}}],[\"kg\",{\"1\":{\"455\":1}}],[\"k矩阵乘积\",{\"1\":{\"325\":1}}],[\"kmeans\",{\"1\":{\"169\":7,\"170\":9}}],[\"kd\",{\"1\":{\"165\":3,\"167\":4}}],[\"kullback\",{\"1\":{\"157\":1,\"798\":1,\"867\":1}}],[\"k=int\",{\"1\":{\"316\":1}}],[\"k=images\",{\"1\":{\"252\":1}}],[\"k=2\",{\"1\":{\"110\":1,\"522\":1}}],[\"k=64\",{\"1\":{\"109\":1}}],[\"k×k\",{\"1\":{\"108\":1}}],[\"k\",{\"0\":{\"406\":1,\"818\":1},\"1\":{\"72\":3,\"74\":3,\"76\":2,\"96\":3,\"105\":1,\"110\":1,\"111\":11,\"112\":5,\"161\":4,\"163\":1,\"169\":4,\"170\":15,\"173\":3,\"179\":1,\"182\":1,\"252\":3,\"254\":10,\"255\":13,\"256\":4,\"257\":3,\"272\":8,\"274\":1,\"275\":4,\"278\":2,\"309\":1,\"316\":2,\"322\":7,\"367\":2,\"404\":1,\"410\":1,\"419\":2,\"423\":1,\"463\":2,\"537\":2,\"542\":1,\"544\":2,\"578\":2,\"584\":4,\"590\":26,\"591\":5,\"605\":2,\"632\":9,\"738\":1,\"811\":1,\"817\":3,\"818\":11,\"820\":4,\"839\":3}}],[\"kwargs=cache\",{\"1\":{\"544\":1}}],[\"kwargs说明\",{\"1\":{\"544\":1}}],[\"kwargs\",{\"1\":{\"68\":1,\"73\":1,\"143\":3,\"272\":1,\"274\":4,\"313\":2,\"341\":2,\"344\":3,\"345\":2,\"346\":4,\"347\":2,\"351\":2,\"353\":7,\"396\":2,\"544\":2,\"804\":1,\"816\":4,\"848\":2,\"886\":2}}],[\"kld\",{\"1\":{\"854\":2}}],[\"kl损失的权重\",{\"1\":{\"821\":1}}],[\"kl散度有时会无穷大\",{\"1\":{\"835\":1}}],[\"kl散度不对称\",{\"1\":{\"835\":1}}],[\"kl散度的\",{\"1\":{\"834\":1}}],[\"kl散度\",{\"0\":{\"827\":1,\"854\":1},\"1\":{\"831\":1,\"837\":1}}],[\"kl散度损失\",{\"1\":{\"821\":1}}],[\"kl散度计算\",{\"0\":{\"798\":1}}],[\"kl散度约束\",{\"1\":{\"55\":1}}],[\"kl\",{\"1\":{\"59\":2,\"157\":1,\"161\":1,\"163\":2,\"536\":1,\"537\":2,\"773\":2,\"793\":5,\"794\":7,\"798\":3,\"799\":4,\"800\":1,\"807\":4,\"808\":1,\"821\":11,\"831\":2,\"853\":1,\"854\":1,\"857\":1,\"867\":5,\"868\":1,\"869\":2,\"871\":1,\"872\":2,\"873\":1,\"881\":2}}],[\"knn查询寻找最近的k个邻居\",{\"1\":{\"90\":1}}],[\"knn\",{\"1\":{\"90\":1}}],[\"knife\",{\"1\":{\"29\":1,\"58\":1,\"68\":1}}],[\"knowledge\",{\"0\":{\"13\":1,\"123\":1},\"1\":{\"28\":2,\"32\":2,\"35\":1,\"150\":1,\"176\":1,\"178\":1}}],[\"keep\",{\"1\":{\"617\":1}}],[\"keepdims=true\",{\"1\":{\"302\":1,\"304\":1}}],[\"keepdim=true\",{\"1\":{\"100\":1,\"107\":1,\"109\":1,\"145\":1,\"170\":1,\"186\":1,\"277\":4,\"300\":2,\"463\":1,\"541\":1,\"544\":1,\"885\":1}}],[\"kernel=7\",{\"1\":{\"848\":2}}],[\"kernel\",{\"1\":{\"76\":1,\"107\":1,\"272\":2,\"318\":2,\"793\":4,\"804\":1,\"821\":5,\"848\":21,\"886\":1}}],[\"kernels\",{\"1\":{\"70\":1,\"76\":2}}],[\"kettle\",{\"1\":{\"24\":1,\"28\":12,\"29\":1,\"31\":6}}],[\"keyword\",{\"1\":{\"337\":1}}],[\"key来自query\",{\"1\":{\"312\":1}}],[\"key=pairs\",{\"1\":{\"476\":1,\"477\":1,\"478\":1}}],[\"key=value\",{\"1\":{\"337\":1}}],[\"key=self\",{\"1\":{\"76\":1}}],[\"key=gt\",{\"1\":{\"75\":1}}],[\"key=x\",{\"1\":{\"75\":1}}],[\"key=lambda\",{\"1\":{\"68\":1,\"476\":3,\"478\":2,\"686\":1,\"688\":1,\"696\":1}}],[\"key和value为融合后的文本特征\",{\"1\":{\"74\":1}}],[\"key和value都是点云特征\",{\"1\":{\"72\":1}}],[\"keys\",{\"1\":{\"29\":1,\"58\":1,\"254\":1,\"255\":2,\"257\":7,\"274\":17,\"476\":1,\"478\":1,\"544\":2}}],[\"keyboard\",{\"1\":{\"29\":1,\"58\":1,\"68\":1}}],[\"key\",{\"1\":{\"14\":1,\"32\":8,\"45\":19,\"63\":1,\"68\":4,\"70\":1,\"72\":8,\"74\":11,\"75\":1,\"76\":7,\"145\":1,\"162\":6,\"246\":1,\"250\":1,\"252\":2,\"254\":2,\"255\":6,\"256\":3,\"257\":2,\"274\":7,\"291\":1,\"293\":5,\"294\":2,\"311\":3,\"312\":44,\"316\":2,\"404\":1,\"405\":2,\"407\":1,\"410\":1,\"412\":1,\"414\":1,\"544\":43,\"591\":16,\"605\":7,\"632\":7,\"704\":2,\"781\":1}}],[\"将编码器的梯度绕过非可导的\",{\"1\":{\"885\":1}}],[\"将编码索引映射回码本向量并\",{\"1\":{\"170\":1}}],[\"将与原来\",{\"1\":{\"873\":1}}],[\"将与较差的指标相似\",{\"1\":{\"448\":1}}],[\"将不可微的采样操作拆解为一个可微的确定性函数加一个随机变量\",{\"1\":{\"853\":1}}],[\"将不断从业务逻辑中收集当下\",{\"1\":{\"716\":1}}],[\"将掩码全部置为\",{\"1\":{\"848\":1}}],[\"将掩码图像中目标物体所在区域激活\",{\"1\":{\"59\":1}}],[\"将梯度传递给\",{\"1\":{\"821\":1}}],[\"将梯度分别乘以x1和x0\",{\"1\":{\"690\":1}}],[\"将采样到的新\",{\"1\":{\"820\":1}}],[\"将两者按下式混合\",{\"1\":{\"816\":1}}],[\"将两个方向的\",{\"1\":{\"78\":1}}],[\"将两个注意力输出拼接在一起\",{\"1\":{\"45\":1}}],[\"将离散视觉词空间索引对应的概率分布设置为0\",{\"1\":{\"814\":1}}],[\"将离散化思想引入图像预训练任务\",{\"1\":{\"787\":1}}],[\"将对\",{\"1\":{\"808\":1}}],[\"将对角线置零\",{\"1\":{\"278\":1}}],[\"将被遮挡的\",{\"1\":{\"804\":1}}],[\"将像素从\",{\"1\":{\"802\":1}}],[\"将未遮挡的patch设置为遮挡\",{\"1\":{\"801\":1}}],[\"将通道映射到\",{\"1\":{\"793\":1}}],[\"将连续表示映射为离散\",{\"1\":{\"787\":1}}],[\"将连续的语义空间离散化为紧凑的视觉\",{\"1\":{\"165\":1}}],[\"将二维图像划分为一系列\",{\"1\":{\"769\":1}}],[\"将先验概率\",{\"1\":{\"758\":1}}],[\"将组件组合实现端到端应用\",{\"1\":{\"713\":1}}],[\"将增强后的信息输入到生成模型中\",{\"1\":{\"710\":1}}],[\"将用户的问题输入到检索系统中\",{\"1\":{\"710\":1}}],[\"将处理后的数据存储在对应的数据库中\",{\"1\":{\"710\":1}}],[\"将处理后的数据转化为检索模型可以使用的格式\",{\"1\":{\"710\":1}}],[\"将生成内容与检索到的原始资料建立链接\",{\"1\":{\"709\":1}}],[\"将生成模型分配的平均对数概率高的token作为答案\",{\"1\":{\"516\":1}}],[\"将上下文长度大幅提升至\",{\"1\":{\"704\":1}}],[\"将复杂问题分解为可管理的子问题\",{\"1\":{\"704\":1}}],[\"将计算结果绘制在图上\",{\"1\":{\"697\":1}}],[\"将普通数值计算转换为可微分计算\",{\"1\":{\"692\":1}}],[\"将other参数统一转换为ndarray\",{\"1\":{\"690\":1}}],[\"将ndarray或数值转换为variable\",{\"1\":{\"690\":1}}],[\"将非variable对象转换为variable实例\",{\"1\":{\"690\":1}}],[\"将function对variable的引用改为弱引用\",{\"1\":{\"687\":1}}],[\"将强引用改为弱引用\",{\"1\":{\"687\":1}}],[\"将蜕变为一个更通用\",{\"1\":{\"680\":1}}],[\"将数值微分的结果与反向传播的结果进行比较\",{\"1\":{\"676\":1}}],[\"将数据集压缩包下载到dataset目录下\",{\"1\":{\"577\":1}}],[\"将数据下载到当前项目目录下\",{\"1\":{\"302\":1}}],[\"将函数类封装为python函数\",{\"1\":{\"644\":1,\"671\":1}}],[\"将选项展平\",{\"1\":{\"618\":1}}],[\"将距离范围\",{\"1\":{\"591\":1}}],[\"将距离转换为\",{\"1\":{\"100\":1}}],[\"将相对位置映射到\",{\"1\":{\"591\":1}}],[\"将相同分辨率的\",{\"1\":{\"186\":1}}],[\"将所有子模块组合为完整的\",{\"1\":{\"793\":1}}],[\"将所有输入序列填充到等长max\",{\"1\":{\"579\":1}}],[\"将所有文本合并成一个字符串\",{\"1\":{\"578\":1}}],[\"将一整段文本按\",{\"1\":{\"577\":1}}],[\"将一篇文章\",{\"1\":{\"575\":1}}],[\"将一个形状为\",{\"1\":{\"426\":1}}],[\"将一个批次的数据拆分为图像和标签两个元组\",{\"1\":{\"316\":1}}],[\"将句子中各个字对应位置的\",{\"1\":{\"575\":1}}],[\"将训练数据复制\",{\"1\":{\"562\":1}}],[\"将训练语料中的每个单词按字符拆分\",{\"1\":{\"476\":1}}],[\"将kv\",{\"1\":{\"544\":1}}],[\"将抽象对齐技术成功应用于现实世界模型部署\",{\"1\":{\"539\":1}}],[\"将预训练语言模型从\",{\"1\":{\"531\":1}}],[\"将预训练模型的参数\",{\"1\":{\"490\":1}}],[\"将预训练模型冻结\",{\"1\":{\"179\":1}}],[\"将文档和问题跟每个可能答案拼接起来\",{\"1\":{\"512\":1}}],[\"将文本词索引空间对应的概率分布设置为0\",{\"1\":{\"814\":1}}],[\"将文本的交叉熵损失乘以\",{\"1\":{\"809\":1}}],[\"将文本和图像的\",{\"1\":{\"815\":1}}],[\"将文本和图像\",{\"1\":{\"809\":1}}],[\"将文本和图像序列拼接\",{\"1\":{\"276\":1}}],[\"将文本和query\",{\"1\":{\"311\":1}}],[\"将文本看成一个词序列\",{\"1\":{\"284\":1}}],[\"将文本特征输入\",{\"1\":{\"276\":1}}],[\"将文本特征作为查询\",{\"1\":{\"72\":1}}],[\"将文本拆分为子词\",{\"1\":{\"263\":1}}],[\"将文本语义信息与点云特征进行跨模态融合\",{\"1\":{\"71\":1}}],[\"将文本切分为多个句子\",{\"1\":{\"31\":1}}],[\"将原始图像编码为离散\",{\"1\":{\"815\":1}}],[\"将原始的\",{\"1\":{\"490\":1}}],[\"将原始点云\",{\"1\":{\"109\":1}}],[\"将原本用16bit表示的参数\",{\"1\":{\"488\":1}}],[\"将∆w进行低维分解∆w=ab\",{\"1\":{\"487\":1}}],[\"将y=wx变成y=\",{\"1\":{\"487\":1}}],[\"将w变成\",{\"1\":{\"483\":1}}],[\"将传入的最高频字符对中的两个字符用空格拼接起来\",{\"1\":{\"476\":1}}],[\"将样本的权重进行动态调整\",{\"1\":{\"470\":1}}],[\"将注意力图中注意力权重大于指定阈值的区域进行高亮显示\",{\"1\":{\"463\":1}}],[\"将注意力权重矩阵与v相乘\",{\"1\":{\"322\":1}}],[\"将模型暂时设为\",{\"1\":{\"821\":1}}],[\"将模型设置为\",{\"1\":{\"820\":1}}],[\"将模型切换到\",{\"1\":{\"817\":1}}],[\"将模型放入到仓库对应位置\",{\"1\":{\"593\":1}}],[\"将模型以元组形式返回的缓存重新封装为legacy\",{\"1\":{\"544\":1}}],[\"将模型的预测作为行\",{\"1\":{\"442\":1}}],[\"将模型层数从48层缩减至45层\",{\"1\":{\"223\":1}}],[\"将维度大小为\",{\"1\":{\"427\":1}}],[\"将该梯度向量与初始误差向量相乘\",{\"1\":{\"472\":1}}],[\"将该\",{\"1\":{\"386\":1}}],[\"将张量沿\",{\"1\":{\"374\":1}}],[\"将多个注意力头的输出合并为一个张量\",{\"1\":{\"322\":1}}],[\"将多头注意力的输出进行线性变换\",{\"1\":{\"322\":1}}],[\"将q和k的转置相乘\",{\"1\":{\"322\":1}}],[\"将隐藏特征映射到输出特征空间\",{\"1\":{\"321\":1}}],[\"将分类标记和图像块嵌入拼接\",{\"1\":{\"319\":1,\"320\":1,\"323\":1}}],[\"将分辨率相同的批次合并后输入模型\",{\"1\":{\"186\":1}}],[\"将卷积后的通道维数作为embedding的维度\",{\"1\":{\"318\":1}}],[\"将裁剪后的图像调整为\",{\"1\":{\"317\":1}}],[\"将标签元组转换为一个一维张量\",{\"1\":{\"316\":1}}],[\"将标准\",{\"1\":{\"264\":1}}],[\"将横坐标0\",{\"1\":{\"316\":1}}],[\"将缓存的\",{\"1\":{\"312\":1}}],[\"将第一个\",{\"1\":{\"312\":1}}],[\"将会在下文进行详细讲解\",{\"1\":{\"311\":1}}],[\"将inputfeatures\",{\"1\":{\"594\":1}}],[\"将input\",{\"1\":{\"309\":1}}],[\"将图片编码成\",{\"1\":{\"309\":1}}],[\"将图像转换为\",{\"1\":{\"804\":1}}],[\"将图像转为视觉\",{\"1\":{\"803\":1}}],[\"将图像送入模型并仅预测被\",{\"1\":{\"803\":1}}],[\"将图像从\",{\"1\":{\"802\":1}}],[\"将图像划分为\",{\"1\":{\"801\":1}}],[\"将图像划分为固定大小的网格\",{\"1\":{\"280\":1}}],[\"将图像编码为离散\",{\"1\":{\"789\":1}}],[\"将图像预训练目标设计为\",{\"1\":{\"786\":1}}],[\"将图像数据移动到指定设备上\",{\"1\":{\"323\":1}}],[\"将图像的短边缩放为\",{\"1\":{\"317\":1}}],[\"将图像元组堆叠成一个四维张量\",{\"1\":{\"316\":1}}],[\"将图像切块看成一个图像块序列\",{\"1\":{\"284\":1}}],[\"将图像切分为\",{\"1\":{\"272\":1,\"822\":1}}],[\"将图像切分为不重叠的\",{\"1\":{\"179\":1}}],[\"将图像切分成\",{\"1\":{\"272\":3}}],[\"将图像和文本向量拼接得到图像\",{\"1\":{\"263\":1}}],[\"将图像\",{\"1\":{\"261\":1,\"263\":1,\"815\":1}}],[\"将图像特征注入到文本流中\",{\"1\":{\"290\":1}}],[\"将图像特征\",{\"1\":{\"235\":1}}],[\"将图像分割为\",{\"1\":{\"222\":1}}],[\"将图像分割为1至40个448×448像素的区块\",{\"1\":{\"216\":1}}],[\"将图像patch和点云点拼接成一个统一的token序列\",{\"1\":{\"41\":1}}],[\"将图像+点云特征插入语言嵌入中\",{\"1\":{\"40\":1}}],[\"将待分类的图像输入到图像编码器\",{\"1\":{\"300\":1}}],[\"将个文本特征和个图像特征两两组合\",{\"1\":{\"299\":1}}],[\"将正匹配的图文对与相似但不匹配的负样本区分开来\",{\"1\":{\"278\":1}}],[\"将问题转化为一个二分类问题\",{\"1\":{\"248\":1}}],[\"将最有用的信息提供给\",{\"1\":{\"313\":1}}],[\"将最老的\",{\"1\":{\"246\":1}}],[\"将最后一层\",{\"1\":{\"98\":1}}],[\"将英文数据转为中文\",{\"1\":{\"225\":1}}],[\"将高分辨率图像分割为多个低分辨率区块处理\",{\"1\":{\"219\":1}}],[\"将其带入\",{\"1\":{\"867\":1}}],[\"将其变为归一化分布\",{\"1\":{\"758\":1}}],[\"将其喂进一个参数为\",{\"1\":{\"511\":1}}],[\"将其重塑为一个\",{\"1\":{\"423\":1}}],[\"将其展平就变成了一个长度为768的向量\",{\"1\":{\"318\":1}}],[\"将其动态分割为\",{\"1\":{\"215\":1}}],[\"将其代入标准的对比学习\",{\"1\":{\"157\":1}}],[\"将这种\",{\"1\":{\"775\":1}}],[\"将这个问题转化为一个多标签分类任务\",{\"1\":{\"305\":1}}],[\"将这一批特征拼接到输出中\",{\"1\":{\"186\":1}}],[\"将这些图像\",{\"1\":{\"817\":1}}],[\"将这些图文对转换为如下格式\",{\"1\":{\"234\":1}}],[\"将这些掩码token对应的嵌入向量映射到词向量空间中去\",{\"1\":{\"580\":1}}],[\"将这些排序用作训练奖励模型\",{\"1\":{\"537\":1}}],[\"将这些特征映射到类别空间\",{\"1\":{\"110\":2}}],[\"将这些知识注入点云特征并与图像特征融合\",{\"1\":{\"8\":1}}],[\"将这些知识与点云和图像特征结合\",{\"1\":{\"5\":1}}],[\"将知识蒸馏扩展到\",{\"1\":{\"176\":1}}],[\"将知识传播到大量无标签数据中\",{\"1\":{\"176\":1}}],[\"将特征训练为匹配\",{\"1\":{\"175\":1}}],[\"将特征映射到\",{\"1\":{\"46\":1}}],[\"将簇内样本向量求平均\",{\"1\":{\"170\":1}}],[\"将主编码器和动量编码器配对\",{\"1\":{\"160\":1}}],[\"将主模型和动量模型参数组织成配对\",{\"1\":{\"147\":1}}],[\"将空间划分成立方体格子\",{\"1\":{\"114\":1}}],[\"将每个结果\",{\"1\":{\"727\":1}}],[\"将每个\",{\"1\":{\"614\":1,\"807\":1}}],[\"将每个词从str转换为list列表形式\",{\"1\":{\"477\":1}}],[\"将每个样本分配到最近的簇\",{\"1\":{\"170\":1}}],[\"将每个样本属于的物体类型\",{\"1\":{\"29\":1}}],[\"将每个点的局部特征与整个点云的全局特征拼接起来\",{\"1\":{\"109\":1}}],[\"将全局特征与每个点的局部特征拼接起来\",{\"1\":{\"105\":1}}],[\"将全局语义向量扩展回原始点云数量\",{\"1\":{\"46\":1}}],[\"将点云转换为体素网格\",{\"1\":{\"103\":1}}],[\"将点云投影到图像平面\",{\"1\":{\"52\":1}}],[\"将之前计算好的权重扩展维度\",{\"1\":{\"100\":1}}],[\"将坐标和特征从\",{\"1\":{\"100\":1}}],[\"将稀疏点集points2插值到密集点集xyz1的位置上\",{\"1\":{\"100\":1}}],[\"将稀疏点集的特征插值回原始点集的位置上\",{\"1\":{\"100\":1}}],[\"将邻域点组合成局部点云组\",{\"1\":{\"98\":1}}],[\"将来自下一级\",{\"1\":{\"97\":1}}],[\"将view\",{\"1\":{\"92\":1}}],[\"将当前词的key和val进行缓存\",{\"1\":{\"544\":1}}],[\"将当前词列表中每个子词映射为字典中对于的词id\",{\"1\":{\"477\":2}}],[\"将当前动量特征送入队列\",{\"1\":{\"161\":1}}],[\"将当前选中的\",{\"1\":{\"92\":1}}],[\"将当前样本的物体信息值追加到对应列表中\",{\"1\":{\"68\":1}}],[\"将转换后的坐标以及点的附加特征\",{\"1\":{\"91\":1}}],[\"将响应值映射到\",{\"1\":{\"76\":1}}],[\"将融合特征重新分配给每个点\",{\"1\":{\"74\":2}}],[\"将融合特征映射回点空间\",{\"0\":{\"74\":1}}],[\"将融合后的\",{\"1\":{\"42\":1}}],[\"将融合后的空间特征通过适配器上采样到与语言模型匹配的维度\",{\"1\":{\"40\":1}}],[\"将异构特征\",{\"1\":{\"59\":1}}],[\"将交互主体区域框在特征图中框出的区域\",{\"1\":{\"59\":1}}],[\"将交互主体框和目标物体框等比例缩小\",{\"1\":{\"59\":1}}],[\"将目标物体区域框在特征图中框出的区域\",{\"1\":{\"59\":1}}],[\"将输入序列\",{\"1\":{\"622\":1}}],[\"将输入和目标张量展平为一维\",{\"1\":{\"471\":1,\"473\":1}}],[\"将输入和目标展平成一维张量便于计算\",{\"1\":{\"469\":1}}],[\"将输入和目标展平成一维张量\",{\"1\":{\"468\":1}}],[\"将输入展平便于后续计算\",{\"1\":{\"470\":1}}],[\"将输入展平成一维张量\",{\"1\":{\"467\":1}}],[\"将输入映射到\",{\"1\":{\"469\":1}}],[\"将输入映射到概率空间\",{\"1\":{\"468\":1}}],[\"将输入映射到低维空间以进行\",{\"1\":{\"45\":1}}],[\"将输入直接连接到输出\",{\"1\":{\"382\":1}}],[\"将输入特征映射到隐藏特征空间\",{\"1\":{\"321\":1}}],[\"将输入图像大小和\",{\"1\":{\"804\":1}}],[\"将输入图像划分为\",{\"1\":{\"804\":1}}],[\"将输入图像\",{\"1\":{\"804\":1,\"885\":1}}],[\"将输入图像进行图像块嵌入\",{\"1\":{\"319\":1,\"320\":1,\"323\":1}}],[\"将输入图像编码为一系列嵌入向量\",{\"1\":{\"152\":1}}],[\"将输入图片\",{\"1\":{\"318\":1}}],[\"将输入文本转换为嵌入列表后和query\",{\"1\":{\"311\":1}}],[\"将输入的维度dim映射到dim\",{\"1\":{\"322\":1}}],[\"将输入的\",{\"1\":{\"309\":1}}],[\"将输入的图像张量\",{\"1\":{\"272\":1}}],[\"将输入的图像切分成小\",{\"1\":{\"272\":1}}],[\"将输入\",{\"1\":{\"277\":1,\"588\":1}}],[\"将输入从\",{\"1\":{\"170\":1}}],[\"将输入分别投影到低维空间\",{\"1\":{\"45\":1}}],[\"将语言嵌入\",{\"1\":{\"43\":1}}],[\"将\",{\"1\":{\"14\":1,\"15\":1,\"43\":1,\"44\":1,\"63\":1,\"82\":1,\"186\":1,\"234\":1,\"236\":1,\"269\":1,\"272\":1,\"276\":5,\"277\":1,\"295\":1,\"312\":2,\"317\":2,\"318\":1,\"326\":1,\"386\":1,\"387\":1,\"427\":1,\"467\":1,\"471\":1,\"495\":1,\"536\":2,\"539\":1,\"704\":1,\"790\":1,\"796\":1,\"802\":2,\"808\":1,\"813\":1,\"814\":2,\"815\":1,\"818\":1,\"819\":1,\"820\":1,\"821\":2,\"822\":1,\"867\":2,\"873\":1,\"885\":2,\"886\":1}}],[\"从编码器输出\",{\"1\":{\"881\":1}}],[\"从概率分布里随机采样一个类别\",{\"1\":{\"880\":1}}],[\"从信息论的角度看\",{\"1\":{\"873\":1}}],[\"从公式\",{\"1\":{\"873\":1}}],[\"从公式来说\",{\"1\":{\"246\":1}}],[\"从手写文本生成更多手写内容\",{\"1\":{\"864\":1}}],[\"从三维植物模型生成更多植被以填充游戏场景\",{\"1\":{\"864\":1}}],[\"从标准正态分布中采样\",{\"1\":{\"857\":1,\"869\":1}}],[\"从左上到右下\",{\"1\":{\"846\":1}}],[\"从起始长度到\",{\"1\":{\"817\":1}}],[\"从零直达wgan\",{\"1\":{\"841\":1}}],[\"从零生成完整图像\",{\"1\":{\"817\":1}}],[\"从零构建深度学习框架\",{\"0\":{\"633\":1,\"679\":1,\"694\":1,\"699\":1}}],[\"从2015年起\",{\"1\":{\"806\":1}}],[\"从变分自编码器的视角\",{\"0\":{\"773\":1}}],[\"从中可以计算区间概率\",{\"1\":{\"728\":1}}],[\"从样本数据出发\",{\"1\":{\"758\":1}}],[\"从样本空间\",{\"1\":{\"727\":1}}],[\"从样本中随机选取\",{\"1\":{\"170\":2}}],[\"从deepseek\",{\"1\":{\"718\":1}}],[\"从构建一个\",{\"1\":{\"717\":1}}],[\"从实际业务需求出发构造小批量验证集\",{\"1\":{\"716\":1}}],[\"从实验结果来看\",{\"1\":{\"245\":1}}],[\"从一个模块流向另一个模块\",{\"1\":{\"712\":1}}],[\"从一张输入图像生成多个视角\",{\"1\":{\"186\":1}}],[\"从简单函数组合进化到模块化神经网络\",{\"1\":{\"700\":1}}],[\"从输出信息可看到\",{\"1\":{\"697\":1}}],[\"从输出变量出发遍历所有节点\",{\"1\":{\"696\":1}}],[\"从输入点云\",{\"1\":{\"92\":1}}],[\"从输入点中选取一组点\",{\"1\":{\"88\":1}}],[\"从自动微分迈向可训练的神经网络模型\",{\"0\":{\"700\":1}}],[\"从自动微分迈向通用框架\",{\"0\":{\"680\":1}}],[\"从自动微分走向\",{\"0\":{\"695\":1}}],[\"从弱引用中获取variable实例\",{\"1\":{\"687\":1}}],[\"从递归改为循环\",{\"1\":{\"678\":1}}],[\"从递归到循环\",{\"0\":{\"666\":1}}],[\"从源张量中提取特定位置的元素\",{\"1\":{\"581\":1}}],[\"从bertencoders编码输出结果中提取出被掩码的位置对应的嵌入向量\",{\"1\":{\"580\":1}}],[\"从4开始\",{\"1\":{\"578\":1}}],[\"从统计语言模型\",{\"1\":{\"552\":1}}],[\"从词向量到上下文表示的发展历程\",{\"1\":{\"531\":1}}],[\"从早期的词向量\",{\"1\":{\"520\":1}}],[\"从早期的alexnet和cnn架构\",{\"1\":{\"191\":1}}],[\"从预训练到微调迁移学习过程中\",{\"1\":{\"516\":1}}],[\"从预测结果中找出每个样本预测概率最大的类别索引\",{\"1\":{\"323\":1}}],[\"从无标注文本中充分利用词级别以外的信息是有挑战性的\",{\"1\":{\"507\":1}}],[\"从上图中\",{\"1\":{\"503\":1}}],[\"从易至难技术\",{\"0\":{\"503\":1}}],[\"从结果集合中投票选择\",{\"1\":{\"502\":1}}],[\"从这个意义上来说\",{\"1\":{\"873\":1}}],[\"从这个视角出发\",{\"1\":{\"873\":1}}],[\"从这个分布中采样出一个\",{\"1\":{\"869\":1}}],[\"从这个数据集中\",{\"1\":{\"243\":1}}],[\"从这些公理可以推导出一些常用结论\",{\"1\":{\"729\":1}}],[\"从这可以看出要全参数微调大语言模型\",{\"1\":{\"492\":1}}],[\"从个人使用情况来说\",{\"1\":{\"491\":1}}],[\"从成本和效果的角度综合考虑\",{\"1\":{\"484\":1}}],[\"从训练数据的来源\",{\"1\":{\"483\":1}}],[\"从参数规模的角度\",{\"1\":{\"483\":1}}],[\"从字符级别开始\",{\"1\":{\"475\":1}}],[\"从shape列表的最右边往左遍历\",{\"1\":{\"428\":1}}],[\"从对应的\",{\"1\":{\"412\":1}}],[\"从不同大小的\",{\"1\":{\"386\":1}}],[\"从内到外\",{\"0\":{\"350\":1}}],[\"从qkv张量中分离出查询\",{\"1\":{\"322\":1}}],[\"从数据库中检索相关信息\",{\"1\":{\"710\":1}}],[\"从数据集\",{\"1\":{\"316\":1}}],[\"从数据对的数量来看\",{\"1\":{\"299\":1}}],[\"从冻结的llm引到vision\",{\"1\":{\"308\":1}}],[\"从冻结的image\",{\"1\":{\"308\":1}}],[\"从任务难度来看\",{\"1\":{\"305\":1}}],[\"从候选分类文本集合中取出其分类名词\",{\"1\":{\"302\":1}}],[\"从指定层开始\",{\"1\":{\"277\":1}}],[\"从第44步到第57步\",{\"1\":{\"700\":1}}],[\"从第二个位置开始\",{\"1\":{\"463\":1}}],[\"从第二个开始\",{\"1\":{\"312\":1}}],[\"从第一个数据模块读取通用配置\",{\"1\":{\"274\":1}}],[\"从第几层开始使用\",{\"1\":{\"272\":1}}],[\"从第几层开始启用\",{\"1\":{\"147\":1}}],[\"从哪一层开始\",{\"1\":{\"272\":1}}],[\"从所有\",{\"1\":{\"265\":1}}],[\"从所有点中选出每个通道的最大响应值\",{\"1\":{\"107\":1,\"109\":1}}],[\"从多个角度描述图像内容\",{\"1\":{\"234\":1}}],[\"从多个角度渲染点云或\",{\"1\":{\"114\":1}}],[\"从35种预设宽高比中选择最接近输入图像的配置\",{\"1\":{\"224\":1}}],[\"从1\",{\"1\":{\"218\":1}}],[\"从粗粒度对齐过渡到细粒度优化\",{\"1\":{\"198\":1}}],[\"从本章开始为每个chapter设计如下目录结构\",{\"1\":{\"691\":1}}],[\"从本节开始\",{\"1\":{\"275\":1,\"576\":1,\"821\":1}}],[\"从本节开始我们将对官方开源的\",{\"1\":{\"186\":1}}],[\"从本质上来说\",{\"1\":{\"86\":1}}],[\"从同一张图片中生成多个视角\",{\"1\":{\"178\":1}}],[\"从稀疏点恢复到原始点密度\",{\"1\":{\"101\":1}}],[\"从下采样点中取出每个原始点对应的最近邻点的特征\",{\"1\":{\"100\":1}}],[\"从最稀疏的点开始\",{\"1\":{\"98\":1,\"99\":1}}],[\"从点云中选出有代表性的点作为中心点\",{\"1\":{\"98\":1}}],[\"从点云中根据索引提取特定点\",{\"1\":{\"92\":1}}],[\"从点云中找出最相关的功能区域\",{\"1\":{\"76\":1}}],[\"从原始点云中选出\",{\"1\":{\"92\":1}}],[\"从交互区域特征和背景特征中提取相关信息分别单独加到自己身上\",{\"1\":{\"59\":1}}],[\"从文件路径中提取物体名\",{\"1\":{\"58\":1}}],[\"从图中可看出逐渐接近星号所指的目的地位置\",{\"1\":{\"697\":1}}],[\"从图像数据库合成新的未见图像\",{\"1\":{\"864\":1}}],[\"从图像的中心位置裁剪出\",{\"1\":{\"317\":1}}],[\"从图像\",{\"1\":{\"51\":1}}],[\"从图片路径中截取得到物体名\",{\"1\":{\"29\":1}}],[\"从索引区间中随机采样pair\",{\"1\":{\"29\":1}}],[\"从而生成新的\",{\"1\":{\"886\":1}}],[\"从而影响现有的机器学习算法\",{\"1\":{\"871\":1}}],[\"从而形成可供\",{\"1\":{\"804\":1}}],[\"从而形成更完整的语言上下文理解\",{\"1\":{\"76\":1}}],[\"从而充分利用整个\",{\"1\":{\"800\":1}}],[\"从而避免编码器只用很少几个\",{\"1\":{\"798\":1}}],[\"从而避免了\",{\"1\":{\"797\":1}}],[\"从而避免一个函数的backward方法被错误地多次调用\",{\"1\":{\"686\":1}}],[\"从而\",{\"1\":{\"755\":1}}],[\"从而不断迭代优化\",{\"1\":{\"717\":1}}],[\"从而将传统的模型训练调优转变成了更简单\",{\"1\":{\"716\":1}}],[\"从而简化应用程序的开发流程\",{\"1\":{\"712\":1}}],[\"从而显著提升了回答的准确性与深度\",{\"1\":{\"709\":1}}],[\"从而显著提升了模型的性能\",{\"1\":{\"704\":1}}],[\"从而得出最终答案\",{\"1\":{\"706\":1}}],[\"从而得到\",{\"1\":{\"867\":1}}],[\"从而得到最终的\",{\"1\":{\"537\":1}}],[\"从而得到一个相似度权重矩阵\",{\"1\":{\"463\":1}}],[\"从而得到另外两张图\",{\"1\":{\"243\":1}}],[\"从而无法被自动回收\",{\"1\":{\"687\":1}}],[\"从而增强模型的表达能力\",{\"1\":{\"622\":1}}],[\"从而增强了模型的表达能力\",{\"1\":{\"321\":1}}],[\"从而可以在网络结构上直接与已有方法进行对比\",{\"1\":{\"771\":1}}],[\"从而可以解决长距离依赖的问题\",{\"1\":{\"621\":1}}],[\"从而可以提供一些监督信号给到模型去训练\",{\"1\":{\"242\":1}}],[\"从而很难并行\",{\"1\":{\"621\":1}}],[\"从而赋予\",{\"1\":{\"588\":1}}],[\"从而弥补其原生结构中缺少位置感知能力的缺陷\",{\"1\":{\"587\":1}}],[\"从而在各种nlp\",{\"1\":{\"705\":1}}],[\"从而在注意力机制中就不会考虑到这些pad部分的token了\",{\"1\":{\"584\":1}}],[\"从而在实际应用中实现更快\",{\"1\":{\"26\":1}}],[\"从而计算交叉熵损失就很简单了\",{\"1\":{\"581\":1}}],[\"从而模型训练学习到每个词的含义需要更大量的数据集且最终效果也不会很好\",{\"1\":{\"578\":1}}],[\"从而帮助社区更好地理解不同改进的相对贡献\",{\"1\":{\"568\":1}}],[\"从而发现数据内部的逻辑与联系\",{\"1\":{\"495\":1}}],[\"从而应用于自己的业务场景\",{\"1\":{\"491\":1}}],[\"从而引导模型学习更多语义信息\",{\"1\":{\"470\":1}}],[\"从而减少对显式监督的依赖\",{\"1\":{\"520\":1}}],[\"从而减少对分类正确样本的贡献\",{\"1\":{\"470\":1}}],[\"从而减少计算复杂度并保持性能\",{\"1\":{\"73\":1}}],[\"从而导致偏差\",{\"1\":{\"459\":1}}],[\"从而导致更大的训练代价\",{\"1\":{\"307\":1}}],[\"从而扩展张量的形状\",{\"1\":{\"363\":1}}],[\"从而提高了其理解和生成文本的能力\",{\"1\":{\"704\":1}}],[\"从而提高模型的分类性能\",{\"1\":{\"323\":1}}],[\"从而提升了在专业领域内的问题回答质量和深度\",{\"1\":{\"709\":1}}],[\"从而提升了用户对生成内容的信任度\",{\"1\":{\"709\":1}}],[\"从而提升对目标函数的拟合精度\",{\"1\":{\"385\":1}}],[\"从而提升分类任务的表现\",{\"1\":{\"268\":1}}],[\"从而提升视觉语言预训练效果\",{\"1\":{\"268\":1}}],[\"从而提升其在各种任务上的泛化能力\",{\"1\":{\"232\":1}}],[\"从而提升泛化能力和鲁棒性\",{\"1\":{\"162\":1}}],[\"从而提升鲁棒性和泛化能力\",{\"1\":{\"157\":1}}],[\"从而提升模型对多尺度\",{\"1\":{\"71\":1}}],[\"从而完成图像分类任务\",{\"1\":{\"319\":1}}],[\"从而缓解类别不平衡问题\",{\"1\":{\"403\":1}}],[\"从而缓解了灾难性的遗忘问题\",{\"1\":{\"313\":1}}],[\"从而缓解对大规模比较的需求\",{\"1\":{\"175\":1}}],[\"从而训练模型学会细粒度跨模态对齐\",{\"1\":{\"278\":1}}],[\"从而训练网络在面对实际应用中可能遇到的各种采样密度时\",{\"1\":{\"96\":1}}],[\"从而改善训练稳定性\",{\"1\":{\"272\":1}}],[\"从而学会生成图像的离散表示\",{\"1\":{\"813\":1}}],[\"从而学会根据输入数据的变化自适应地加权不同尺度上检测到的模式\",{\"1\":{\"95\":1}}],[\"从而学习更泛化的表示\",{\"1\":{\"260\":1}}],[\"从而能够训练更大的模型\",{\"1\":{\"495\":1}}],[\"从而能够保持队列中的特征尽可能的\",{\"1\":{\"249\":1}}],[\"从而能够更好地捕捉点云的局部结构和层次信息\",{\"1\":{\"112\":1}}],[\"从而让特征的获取过程保持一致性\",{\"1\":{\"246\":1}}],[\"从而让字典的规模变得很大\",{\"1\":{\"245\":1}}],[\"从而让中间学习到的字典特征尽可能保持一致\",{\"1\":{\"244\":1}}],[\"从而更贴近人类期望\",{\"1\":{\"232\":1}}],[\"从而为用户提供更加流畅的体验\",{\"1\":{\"714\":1}}],[\"从而为学生提供更高质量的特征目标\",{\"1\":{\"178\":1}}],[\"从而为后续的动态卷积和掩码预测提供基础\",{\"1\":{\"76\":1}}],[\"从而实现图文联合生成\",{\"1\":{\"817\":1}}],[\"从而实现图像自监督预训练任务中的\",{\"1\":{\"804\":1}}],[\"从而实现强大的图像表征学习能力\",{\"1\":{\"790\":1}}],[\"从而实现对图像的细粒度理解和分析\",{\"1\":{\"465\":1}}],[\"从而实现对原函数行为的增强或修改\",{\"1\":{\"341\":1}}],[\"从而实现对局部图像信息的建模\",{\"1\":{\"167\":1}}],[\"从而实现高效的视觉\",{\"1\":{\"269\":1}}],[\"从而实现\",{\"1\":{\"178\":1}}],[\"从而实现模型压缩\",{\"1\":{\"176\":1}}],[\"从而实现点云的分层特征学习\",{\"1\":{\"92\":1}}],[\"从而使对比学习更加稳健\",{\"1\":{\"145\":1}}],[\"从而考虑负样本中的潜在正样本\",{\"1\":{\"127\":1}}],[\"从而保证变换是刚性的\",{\"1\":{\"107\":1}}],[\"从而插值得到该点的特征\",{\"1\":{\"100\":1}}],[\"从而消除模态间的分布差异\",{\"1\":{\"59\":1}}],[\"从而获得对语言深层次的理解\",{\"1\":{\"703\":1}}],[\"从而获得平滑的过渡效果\",{\"1\":{\"390\":1}}],[\"从而获得\",{\"1\":{\"28\":1}}],[\"从\",{\"0\":{\"570\":1,\"576\":1,\"878\":1},\"1\":{\"13\":1,\"24\":1,\"46\":1,\"63\":1,\"68\":1,\"92\":1,\"107\":1,\"147\":1,\"179\":1,\"186\":1,\"250\":1,\"272\":1,\"277\":3,\"309\":2,\"425\":1,\"427\":1,\"514\":1,\"521\":1,\"535\":1,\"580\":1,\"590\":2,\"616\":1,\"704\":1,\"712\":1,\"818\":1,\"821\":1,\"846\":1,\"869\":1,\"872\":1,\"880\":1,\"886\":1}}],[\"从几何结构解释该部位可以交互的原因\",{\"1\":{\"11\":1}}],[\"模拟用户需求的任务\",{\"1\":{\"537\":1}}],[\"模拟人类通过观察学习物体功能的能力\",{\"1\":{\"49\":1}}],[\"模拟人类对交互方式的联想\",{\"1\":{\"12\":1}}],[\"模拟人观察交互图像时的思维链条\",{\"1\":{\"28\":1}}],[\"模版方法设计模型\",{\"1\":{\"273\":1}}],[\"模态融合比较轻量\",{\"1\":{\"307\":1}}],[\"模态融合比较弱\",{\"1\":{\"307\":1}}],[\"模态融合模式\",{\"1\":{\"162\":1}}],[\"模态交互部分可以分成两种方式\",{\"1\":{\"283\":1}}],[\"模态专家混合网络\",{\"1\":{\"264\":1}}],[\"模态间交互通过余弦相似度或线性投影实现\",{\"1\":{\"261\":1}}],[\"模态间交互通过特征向量的余弦相似度进行\",{\"1\":{\"260\":1}}],[\"模长\",{\"1\":{\"170\":1}}],[\"模式自动恢复\",{\"1\":{\"688\":1}}],[\"模式切换示例\",{\"1\":{\"688\":1}}],[\"模式匹配引擎\",{\"1\":{\"530\":1}}],[\"模式运行\",{\"1\":{\"277\":1}}],[\"模式保持\",{\"1\":{\"186\":1}}],[\"模式\",{\"1\":{\"163\":2,\"216\":1,\"277\":3,\"316\":1,\"399\":1,\"692\":1,\"817\":2,\"820\":2,\"821\":1}}],[\"模式控制\",{\"1\":{\"163\":1}}],[\"模式中提供\",{\"1\":{\"163\":1}}],[\"模型权重\",{\"1\":{\"885\":1,\"886\":1}}],[\"模型生成的图像\",{\"1\":{\"866\":1}}],[\"模型若先随机选择一个数字\",{\"1\":{\"865\":1}}],[\"模型评估\",{\"0\":{\"857\":1}}],[\"模型实例化\",{\"1\":{\"848\":1}}],[\"模型实现如下\",{\"1\":{\"886\":1}}],[\"模型实现与优化\",{\"1\":{\"561\":1}}],[\"模型实现\",{\"0\":{\"70\":1,\"275\":1}}],[\"模型所在设备\",{\"1\":{\"848\":1}}],[\"模型获取输出\",{\"1\":{\"820\":1}}],[\"模型头部输出\",{\"1\":{\"820\":1}}],[\"模型具备一定的图像到图像转换能力\",{\"1\":{\"806\":1}}],[\"模型进行尝试\",{\"1\":{\"806\":1}}],[\"模型进一步使用\",{\"1\":{\"537\":1}}],[\"模型表达能力受限\",{\"1\":{\"800\":1}}],[\"模型表现更好\",{\"1\":{\"268\":1}}],[\"模型表现良好\",{\"1\":{\"112\":1}}],[\"模型和\",{\"1\":{\"776\":1}}],[\"模型和cc\",{\"1\":{\"569\":1}}],[\"模型输入\",{\"1\":{\"713\":1}}],[\"模型输出应不受刚性变换影响\",{\"1\":{\"104\":1}}],[\"模型输出的预测结果\",{\"1\":{\"471\":1}}],[\"模型输出的预测值\",{\"1\":{\"467\":1}}],[\"模型输出的\",{\"1\":{\"468\":1}}],[\"模型输出的概率值或二值化结果\",{\"1\":{\"469\":1}}],[\"模型输出的概率值大于某个值时\",{\"1\":{\"446\":1}}],[\"模型输出的概率值\",{\"1\":{\"82\":1,\"468\":1,\"473\":1}}],[\"模型输出的原始\",{\"1\":{\"78\":1,\"469\":1,\"470\":1}}],[\"模型等\",{\"1\":{\"713\":1}}],[\"模型学习特定领域的数据有助于减少幻觉\",{\"1\":{\"711\":1}}],[\"模型学会将图像中与分类任务相关的信息汇聚到\",{\"1\":{\"319\":1}}],[\"模型学会如何通过注意力机制将图像的有效信息汇聚到\",{\"1\":{\"319\":2}}],[\"模型定制\",{\"1\":{\"711\":1}}],[\"模型也采用了\",{\"1\":{\"704\":1}}],[\"模型还使用了高效的数据并行和流水线并行技术\",{\"1\":{\"704\":1}}],[\"模型是典型的\",{\"1\":{\"704\":1}}],[\"模型是过参数化的\",{\"1\":{\"491\":1}}],[\"模型展现出了一些惊人的能力\",{\"1\":{\"703\":1}}],[\"模型类\",{\"1\":{\"700\":1}}],[\"模型类型\",{\"1\":{\"147\":1}}],[\"模型代表\",{\"1\":{\"616\":1}}],[\"模型代码解析的核心部分\",{\"1\":{\"275\":1}}],[\"模型代码解读\",{\"0\":{\"270\":1,\"791\":1,\"812\":1},\"1\":{\"270\":1,\"791\":1,\"812\":1,\"821\":1}}],[\"模型代码解读与复现\",{\"0\":{\"37\":1,\"60\":1}}],[\"模型代码进行修改的\",{\"1\":{\"271\":1}}],[\"模型代码实现是基于\",{\"1\":{\"271\":1}}],[\"模型代码实现进行详细讲解\",{\"1\":{\"186\":1}}],[\"模型那样逐词生成新内容\",{\"1\":{\"616\":1}}],[\"模型有点大\",{\"1\":{\"593\":1}}],[\"模型就无法处理了\",{\"1\":{\"588\":1}}],[\"模型返回的logits\",{\"1\":{\"581\":1}}],[\"模型整体实现也比较简单\",{\"1\":{\"580\":1}}],[\"模型很难学到它们的语义表示\",{\"1\":{\"578\":1}}],[\"模型要判断出这个假设是\",{\"1\":{\"575\":1}}],[\"模型要理解并遵循人类语言中的任务描述\",{\"1\":{\"239\":1}}],[\"模型层\",{\"0\":{\"556\":1}}],[\"模型越大毒性倾向越高\",{\"1\":{\"549\":1}}],[\"模型与序列并行\",{\"1\":{\"548\":1}}],[\"模型会根据前\",{\"1\":{\"843\":1}}],[\"模型会对每个选项分别编码\",{\"1\":{\"618\":1}}],[\"模型会输出两个数\",{\"1\":{\"575\":1}}],[\"模型会输出一个回答\",{\"1\":{\"541\":1}}],[\"模型会通过mask的上下文信息\",{\"1\":{\"285\":1}}],[\"模型顺从性过高\",{\"1\":{\"539\":1}}],[\"模型仍可能在对抗性攻击下暴露隐私\",{\"1\":{\"539\":1}}],[\"模型仍存在简单错误与对\",{\"1\":{\"538\":1}}],[\"模型应能自动识别并拒绝执行\",{\"1\":{\"539\":1}}],[\"模型机制\",{\"1\":{\"539\":1}}],[\"模型行为问题\",{\"1\":{\"539\":1}}],[\"模型行为干预与有害输出缓解策略\",{\"1\":{\"536\":1}}],[\"模型中的每一步都变成\",{\"1\":{\"858\":1}}],[\"模型中使用了三种不同的自注意力掩码\",{\"1\":{\"809\":1}}],[\"模型中常用的特殊\",{\"1\":{\"578\":1}}],[\"模型中\",{\"1\":{\"539\":1,\"704\":1}}],[\"模型泛化能力强\",{\"1\":{\"538\":1}}],[\"模型显著提升回答的真实性与信息性\",{\"1\":{\"538\":1}}],[\"模型均优于\",{\"1\":{\"538\":1}}],[\"模型比\",{\"1\":{\"538\":1}}],[\"模型提供输入\",{\"1\":{\"537\":1}}],[\"模型提取图像的特征图\",{\"1\":{\"326\":1}}],[\"模型依然在用户指令任务中获得更高的偏好评分\",{\"1\":{\"536\":1}}],[\"模型依然能稳定预测合理的交互区域\",{\"1\":{\"25\":1}}],[\"模型性能随规模扩展而持续提升\",{\"1\":{\"529\":1}}],[\"模型性能下降\",{\"1\":{\"268\":1}}],[\"模型容易过拟合训练数据的虚假相关性\",{\"1\":{\"527\":1}}],[\"模型容量与零样本性能强相关\",{\"1\":{\"522\":1}}],[\"模型容量与任务性能呈对数线性关系\",{\"1\":{\"522\":1}}],[\"模型容量增加直接缩小了与人类表现的差距\",{\"1\":{\"522\":1}}],[\"模型容量对任务性能至关重要\",{\"1\":{\"519\":1}}],[\"模型规模和数据量可能是性能瓶颈\",{\"1\":{\"806\":1}}],[\"模型规模与毒性正相关\",{\"1\":{\"551\":1}}],[\"模型规模与毒性\",{\"1\":{\"549\":1}}],[\"模型规模与性能的重新思考\",{\"1\":{\"547\":1}}],[\"模型规模与少样本学习能力呈正相关\",{\"1\":{\"527\":1}}],[\"模型规模扩展趋势与\",{\"1\":{\"531\":1}}],[\"模型规模的扩大可能显著提升上下文学习能力\",{\"1\":{\"527\":1}}],[\"模型规模的扩大带来了性能的持续提升\",{\"1\":{\"526\":1}}],[\"模型规模对性能有显著影响\",{\"1\":{\"237\":1}}],[\"模型局限性及其社会影响\",{\"1\":{\"526\":1}}],[\"模型倾向于使用简单的检索启发式\",{\"1\":{\"522\":1}}],[\"模型主要依赖于这个低的内在维度\",{\"1\":{\"491\":1}}],[\"模型更不喜欢\",{\"1\":{\"471\":2}}],[\"模型更新参数\",{\"1\":{\"319\":1}}],[\"模型分类错误\",{\"1\":{\"470\":1}}],[\"模型已经学会了将数据编码到一个\",{\"1\":{\"869\":1}}],[\"模型已经具备基本的视觉理解能力\",{\"1\":{\"234\":1}}],[\"模型已自信分类\",{\"1\":{\"470\":1}}],[\"模型被大量简单负样本主导\",{\"1\":{\"470\":1}}],[\"模型被强制学会将图像的有效信息汇聚到\",{\"1\":{\"319\":1}}],[\"模型将随机选择的正例正确排在随机选择的负例之上的概率为\",{\"1\":{\"451\":1}}],[\"模型将正例排在负例之上的概率\",{\"1\":{\"451\":1}}],[\"模型将完全依赖随机初始化的参数去\",{\"1\":{\"76\":1}}],[\"模型才会将该样本分类为正类\",{\"1\":{\"446\":1}}],[\"模型库\",{\"1\":{\"396\":1}}],[\"模型仓库\",{\"1\":{\"395\":1}}],[\"模型丰富\",{\"1\":{\"395\":1}}],[\"模型自动学习到了如果注意画面中的分类主体\",{\"1\":{\"325\":1}}],[\"模型计算每个\",{\"1\":{\"319\":1}}],[\"模型难以计算\",{\"1\":{\"318\":1}}],[\"模型名称\",{\"1\":{\"304\":1,\"704\":4}}],[\"模型预测出的功能区域\",{\"1\":{\"467\":1}}],[\"模型预测出来的\",{\"1\":{\"295\":1}}],[\"模型预测被掩码的\",{\"1\":{\"265\":1}}],[\"模型预测该点属于功能区域的概率\",{\"1\":{\"82\":1}}],[\"模型在编码\",{\"1\":{\"572\":1}}],[\"模型在训练过程中看到更多的掩码变体\",{\"1\":{\"562\":1}}],[\"模型在训练期间学会了抓取包和杯子\",{\"1\":{\"65\":1}}],[\"模型在一些公开\",{\"1\":{\"539\":1}}],[\"模型在未明确训练的任务上也表现良好\",{\"1\":{\"539\":1}}],[\"模型在\",{\"1\":{\"521\":1,\"538\":1,\"704\":1}}],[\"模型在微调时可以作为双编码器\",{\"1\":{\"262\":1}}],[\"模型灵活性高\",{\"1\":{\"260\":1}}],[\"模型吗\",{\"1\":{\"247\":1}}],[\"模型通过在输入前后插入一些可训练的提示词来\",{\"1\":{\"239\":1}}],[\"模型通常在固定低分辨率\",{\"1\":{\"223\":1}}],[\"模型可以自由学习\",{\"1\":{\"853\":1}}],[\"模型可以编码\",{\"1\":{\"591\":1}}],[\"模型可以更好泛化到更长的序列\",{\"1\":{\"589\":1}}],[\"模型可以更好地理解和生成图文结合的内容\",{\"1\":{\"234\":1}}],[\"模型可以学习到更适合该类文本的位置表示方式\",{\"1\":{\"588\":1}}],[\"模型可能学到一种\",{\"1\":{\"587\":1}}],[\"模型可能过拟合这些特定的掩码模式\",{\"1\":{\"562\":1}}],[\"模型可能就只会学习到和query使用同样编码器的那个key\",{\"1\":{\"246\":1}}],[\"模型可自适应调整分辨率\",{\"1\":{\"229\":1}}],[\"模型训练过程是不可微的\",{\"1\":{\"770\":1}}],[\"模型训练过程中采用混合并行策略以适应大规模参数训练\",{\"1\":{\"528\":1}}],[\"模型训练过程中\",{\"1\":{\"159\":1}}],[\"模型训练\",{\"1\":{\"537\":2}}],[\"模型训练的第二阶段\",{\"1\":{\"235\":1}}],[\"模型训练的第一阶段\",{\"1\":{\"234\":1}}],[\"模型尝试生成尽可能高奖励的回答\",{\"1\":{\"232\":1}}],[\"模型作为视觉基础模型\",{\"1\":{\"223\":1}}],[\"模型深度对速度的影响在gpu计算饱和后可以忽略\",{\"1\":{\"197\":1}}],[\"模型优势\",{\"1\":{\"189\":1,\"216\":1}}],[\"模型完整的训练流程\",{\"1\":{\"186\":1}}],[\"模型对非二元代词\",{\"1\":{\"549\":1}}],[\"模型对真实类别的预测概率\",{\"1\":{\"470\":1}}],[\"模型对正负样本差异更加敏感\",{\"1\":{\"248\":1}}],[\"模型对所有输入输出一致的分布\",{\"1\":{\"183\":1}}],[\"模型对物体关键交互区域的识别能力下降\",{\"1\":{\"24\":1}}],[\"模型不是叫\",{\"1\":{\"843\":1}}],[\"模型不可解释性问题严重\",{\"1\":{\"530\":1}}],[\"模型不会崩溃\",{\"1\":{\"182\":1}}],[\"模型不再被\",{\"1\":{\"157\":1}}],[\"模型前向传播整体流程\",{\"1\":{\"813\":1}}],[\"模型前向传播代码如下所示\",{\"1\":{\"255\":1}}],[\"模型前向传播中的\",{\"1\":{\"161\":1,\"162\":1,\"163\":1}}],[\"模型前向\",{\"1\":{\"163\":1}}],[\"模型由三个主要部分组成\",{\"1\":{\"152\":1}}],[\"模型基于\",{\"1\":{\"147\":1}}],[\"模型使用的是训练好的\",{\"1\":{\"821\":1}}],[\"模型使用了大规模的数据过滤和清洗技术\",{\"1\":{\"704\":1}}],[\"模型使用\",{\"1\":{\"131\":1}}],[\"模型设计上\",{\"1\":{\"126\":1}}],[\"模型架构图\",{\"1\":{\"622\":1}}],[\"模型架构改进\",{\"1\":{\"548\":1}}],[\"模型架构与规模设计\",{\"1\":{\"528\":1}}],[\"模型架构\",{\"0\":{\"126\":1,\"595\":1,\"622\":1},\"1\":{\"125\":1,\"521\":1}}],[\"模型构建两个模块\",{\"1\":{\"120\":1}}],[\"模型限制\",{\"1\":{\"120\":1}}],[\"模型为\",{\"1\":{\"114\":1}}],[\"模型必须对输入点的排列顺序不敏感\",{\"1\":{\"104\":1}}],[\"模型需要从中选择最合适的答案\",{\"1\":{\"618\":1}}],[\"模型需要为每个点预测一个类别标签\",{\"1\":{\"98\":1}}],[\"模型需要根据自然语言问题识别点云中最相关的功能区域\",{\"1\":{\"78\":1}}],[\"模型需要根据自然语言问题\",{\"1\":{\"71\":1}}],[\"模型推理\",{\"1\":{\"83\":1}}],[\"模型初始化代码如下所示\",{\"1\":{\"254\":1}}],[\"模型初始化\",{\"0\":{\"814\":1},\"1\":{\"80\":1,\"160\":1}}],[\"模型的具体含义取决于我们想用它完成什么\",{\"1\":{\"864\":1}}],[\"模型的具体配置\",{\"1\":{\"514\":1}}],[\"模型的输入和输出的取值范围都位于\",{\"1\":{\"847\":1}}],[\"模型的输入不再使用位置编码\",{\"1\":{\"704\":1}}],[\"模型的输出是\",{\"1\":{\"843\":1}}],[\"模型的初始化流程\",{\"1\":{\"814\":1}}],[\"模型的基本原则是通过语言建模将世界知识压缩到仅解码器\",{\"1\":{\"704\":1}}],[\"模型的每个测试样本前会插入k条示例\",{\"1\":{\"528\":1}}],[\"模型的迁移能力逐渐增强\",{\"1\":{\"520\":1}}],[\"模型的认知\",{\"1\":{\"495\":1}}],[\"模型的参数是根据这个特定尺寸的输入数据进行优化和学习的\",{\"1\":{\"317\":1}}],[\"模型的前向传播流程\",{\"1\":{\"815\":1}}],[\"模型的前向传播流程和albef实现基本一致\",{\"1\":{\"147\":1}}],[\"模型的前向传播阶段会根据学习任务列表\",{\"1\":{\"275\":1}}],[\"模型的代码实现\",{\"1\":{\"821\":1}}],[\"模型的代码实现中定义了\",{\"1\":{\"792\":1}}],[\"模型的代码实现中额外抽取了一个抽象类\",{\"1\":{\"274\":1}}],[\"模型的代码实现中主要使用了以下两个库\",{\"1\":{\"271\":1}}],[\"模型的代码实现应该比较亲切\",{\"1\":{\"271\":1}}],[\"模型的泛化性就很强\",{\"1\":{\"246\":1}}],[\"模型的运行完整流程图\",{\"1\":{\"186\":1}}],[\"模型的\",{\"1\":{\"147\":1,\"278\":1}}],[\"模型的训练流程\",{\"1\":{\"186\":1}}],[\"模型的训练代码\",{\"1\":{\"147\":1}}],[\"模型的训练过程大体分为了\",{\"1\":{\"79\":1}}],[\"模型的监督信号\",{\"1\":{\"78\":1}}],[\"模型变体包括\",{\"1\":{\"131\":1}}],[\"模型变体\",{\"1\":{\"75\":1}}],[\"模型目标\",{\"1\":{\"70\":1}}],[\"模型结构与训练细节\",{\"1\":{\"537\":1}}],[\"模型结构与原始\",{\"1\":{\"232\":1}}],[\"模型结构图\",{\"1\":{\"39\":1}}],[\"模型结构\",{\"0\":{\"39\":1,\"87\":1,\"308\":1},\"1\":{\"120\":1,\"122\":1,\"234\":1,\"235\":1}}],[\"模型\",{\"0\":{\"30\":1,\"59\":1,\"381\":1,\"463\":1,\"580\":1,\"853\":1,\"859\":1},\"1\":{\"114\":1,\"145\":1,\"163\":1,\"197\":1,\"199\":1,\"203\":1,\"237\":1,\"247\":1,\"254\":1,\"269\":1,\"295\":1,\"299\":1,\"468\":1,\"481\":1,\"537\":4,\"580\":1,\"616\":1,\"700\":1,\"704\":9,\"713\":1,\"803\":2,\"814\":1,\"840\":1,\"843\":1,\"848\":1,\"886\":4}}],[\"模型能够泛化到新标注者的偏好\",{\"1\":{\"537\":1}}],[\"模型能够学习到丰富的图像特征和模式\",{\"1\":{\"327\":1}}],[\"模型能够学习从\",{\"1\":{\"29\":1}}],[\"模型能从无标记数据中充分利用语义信息\",{\"1\":{\"507\":1}}],[\"模型能准确对每个对象生成独立的\",{\"1\":{\"25\":1}}],[\"模型无法收敛\",{\"1\":{\"182\":1}}],[\"模型无法精确聚焦于关键交互部位\",{\"1\":{\"24\":1}}],[\"模型无法进行类比推理\",{\"1\":{\"24\":1}}],[\"模块查看参数\",{\"1\":{\"346\":1}}],[\"模块作用域\",{\"1\":{\"336\":1}}],[\"模块文件的顶层作用域\",{\"1\":{\"336\":1}}],[\"模块可以看作是一个特征预处理模块\",{\"1\":{\"323\":1}}],[\"模块的\",{\"1\":{\"544\":1}}],[\"模块的代码属于模版代码\",{\"1\":{\"272\":1}}],[\"模块的前向传播\",{\"1\":{\"46\":1}}],[\"模块增强后的数据集上\",{\"1\":{\"147\":1}}],[\"模块同样也是基于\",{\"1\":{\"145\":1}}],[\"模块在\",{\"1\":{\"143\":1}}],[\"模块微调阶段\",{\"1\":{\"140\":1}}],[\"模块实现\",{\"0\":{\"140\":1}}],[\"模块通过\",{\"1\":{\"132\":1}}],[\"模块通过剔除噪声文本完成隐式知识过滤\",{\"1\":{\"123\":1}}],[\"模块用生成的语义丰富描述进行蒸馏\",{\"1\":{\"123\":1}}],[\"模块用于最终的\",{\"1\":{\"46\":1}}],[\"模块\",{\"0\":{\"141\":1,\"144\":1,\"292\":1},\"1\":{\"10\":1,\"71\":1,\"307\":1,\"326\":1,\"336\":1,\"544\":1,\"691\":2,\"821\":1}}],[\"描述了\",{\"1\":{\"872\":1}}],[\"描述的神经网络结构类似图4左侧所示的网络\",{\"1\":{\"868\":1}}],[\"描述在给定\",{\"1\":{\"759\":1}}],[\"描述这个新视图的维度大小\",{\"1\":{\"425\":1}}],[\"描述输入和输出维度的对应关系\",{\"1\":{\"370\":1}}],[\"描述短小的问题\",{\"1\":{\"260\":1}}],[\"描述器与过滤器的组合能显著提升性能\",{\"1\":{\"120\":1}}],[\"描述器\",{\"1\":{\"120\":1}}],[\"描述功能的文本提示\",{\"1\":{\"83\":1}}],[\"描述\",{\"1\":{\"63\":1,\"82\":4,\"112\":1,\"115\":1,\"467\":1,\"468\":1,\"469\":1,\"473\":1}}],[\"描述图像中人与物体的交互方式\",{\"1\":{\"12\":1}}],[\"描述图像中人与物体之间的完整交互过程\",{\"1\":{\"12\":1}}],[\"描述实际交互\",{\"1\":{\"6\":1}}],[\"进入堆叠gpt2block模块前向传播流程\",{\"1\":{\"544\":1}}],[\"进入pointnet++经典的特征传播阶段\",{\"1\":{\"35\":1}}],[\"进来\",{\"1\":{\"249\":1}}],[\"进而求出\",{\"1\":{\"826\":1}}],[\"进而可以自由构建\",{\"1\":{\"713\":1}}],[\"进而导致大模型的输出质量打折口\",{\"1\":{\"482\":1}}],[\"进而更新自身表示\",{\"1\":{\"179\":1}}],[\"进而影响\",{\"1\":{\"170\":1}}],[\"进一步改进重建质量与稳定性\",{\"1\":{\"787\":1}}],[\"进一步加剧性能下降\",{\"1\":{\"780\":1}}],[\"进一步增强了模型性能\",{\"1\":{\"704\":1}}],[\"进一步增强特征\",{\"1\":{\"101\":1}}],[\"进一步强化变量的\",{\"1\":{\"689\":1}}],[\"进一步提升了样本质量\",{\"1\":{\"806\":1}}],[\"进一步提升了性能\",{\"1\":{\"568\":1}}],[\"进一步提取和融合特征\",{\"1\":{\"100\":1}}],[\"进一步提取各自模态内部的语义一致性与结构关系\",{\"1\":{\"41\":1}}],[\"进一步降低了2\",{\"1\":{\"522\":1}}],[\"进一步来说\",{\"1\":{\"507\":1}}],[\"进一步帮llm明确要求\",{\"1\":{\"499\":1}}],[\"进一步减少冗余\",{\"1\":{\"385\":1}}],[\"进一步地\",{\"1\":{\"300\":1}}],[\"进一步推动了模型的下游表现\",{\"1\":{\"280\":1}}],[\"进一步对齐\",{\"1\":{\"277\":1}}],[\"进一步对齐视觉与语言特征\",{\"1\":{\"198\":1}}],[\"进一步训练模型理解和执行更复杂的视觉指令任务\",{\"1\":{\"233\":1}}],[\"进一步微调模型\",{\"1\":{\"232\":1}}],[\"进一步扩展了\",{\"1\":{\"704\":1}}],[\"进一步扩展了这个方法来预测n\",{\"1\":{\"305\":1}}],[\"进一步扩展了文本与视觉信息的交互能力\",{\"1\":{\"216\":1}}],[\"进一步扩大语料规模\",{\"1\":{\"138\":1}}],[\"进一步引入了视觉定位能力\",{\"1\":{\"193\":1}}],[\"进一步分析\",{\"1\":{\"182\":1}}],[\"进一步发展\",{\"1\":{\"176\":1}}],[\"进一步从几何结构角度推理为什么该部位适合交互\",{\"1\":{\"11\":1}}],[\"进行某种形式的优化\",{\"1\":{\"870\":1}}],[\"进行严重近似\",{\"1\":{\"864\":1}}],[\"进行矩阵乘法\",{\"1\":{\"821\":1}}],[\"进行随机采样\",{\"1\":{\"817\":1}}],[\"进行评估\",{\"1\":{\"808\":1}}],[\"进行采样来估计\",{\"1\":{\"869\":1}}],[\"进行采样\",{\"1\":{\"794\":1,\"795\":1}}],[\"进行缩放\",{\"1\":{\"774\":1}}],[\"进行边际化\",{\"1\":{\"758\":1}}],[\"进行个性化定制\",{\"1\":{\"717\":1}}],[\"进行自然的语音和视频交流\",{\"1\":{\"704\":1}}],[\"进行解压\",{\"1\":{\"593\":1}}],[\"进行二分类任务\",{\"1\":{\"580\":1}}],[\"进行预测即可\",{\"1\":{\"575\":1}}],[\"进行预训练\",{\"1\":{\"153\":1,\"309\":1}}],[\"进行经典的多头自注意力运算\",{\"1\":{\"544\":1}}],[\"进行划分\",{\"1\":{\"537\":1}}],[\"进行的进一步优化\",{\"1\":{\"502\":1}}],[\"进行思考\",{\"1\":{\"500\":1}}],[\"进行一次降维再升维的操作\",{\"1\":{\"492\":1}}],[\"进行训练\",{\"1\":{\"490\":1,\"806\":1}}],[\"进行训练和评估\",{\"1\":{\"140\":1}}],[\"进行全量的训练\",{\"1\":{\"483\":1}}],[\"进行高亮即可\",{\"1\":{\"463\":1}}],[\"进行逐元素运算\",{\"1\":{\"427\":1}}],[\"进行逐级上采样\",{\"1\":{\"46\":1}}],[\"进行相加操作\",{\"1\":{\"427\":1}}],[\"进行重新排列\",{\"1\":{\"426\":1}}],[\"进行\",{\"1\":{\"425\":1,\"575\":1,\"774\":1}}],[\"进行灵活\",{\"1\":{\"370\":1}}],[\"进行局部特征提取\",{\"1\":{\"326\":1}}],[\"进行反向传播\",{\"1\":{\"323\":1}}],[\"进行并行输入\",{\"1\":{\"318\":1}}],[\"进行文本编码\",{\"1\":{\"312\":1}}],[\"进行聚合\",{\"1\":{\"274\":1}}],[\"进行单模态预训练\",{\"1\":{\"269\":1}}],[\"进行编码\",{\"1\":{\"268\":1,\"309\":2}}],[\"进行缓慢更新的代码实现如下所示\",{\"1\":{\"256\":1}}],[\"进行了进一步的量化\",{\"1\":{\"488\":1}}],[\"进行了一次随机抽样\",{\"1\":{\"248\":1}}],[\"进行了以下筛选\",{\"1\":{\"234\":1}}],[\"进行测试\",{\"1\":{\"245\":1}}],[\"进行渐进式对齐\",{\"1\":{\"206\":1}}],[\"进行对比\",{\"1\":{\"204\":1,\"268\":1}}],[\"进行数据增强\",{\"1\":{\"186\":1}}],[\"进行初始化\",{\"1\":{\"170\":1}}],[\"进行更新\",{\"1\":{\"169\":1}}],[\"进行替换\",{\"1\":{\"163\":1}}],[\"进行线性变换\",{\"1\":{\"161\":1}}],[\"进行线性映射形成\",{\"1\":{\"14\":1}}],[\"进行蒸馏监督\",{\"1\":{\"157\":1}}],[\"进行归一化\",{\"1\":{\"145\":1,\"323\":1}}],[\"进行分词并转为\",{\"1\":{\"143\":1}}],[\"进行分类\",{\"1\":{\"112\":1,\"617\":1}}],[\"进行增强\",{\"1\":{\"140\":1}}],[\"进行特征插值和上采样\",{\"1\":{\"101\":1}}],[\"进行特征学习\",{\"1\":{\"86\":1}}],[\"进行多尺度特征提取和下采样\",{\"1\":{\"101\":1}}],[\"进行推理的代码\",{\"1\":{\"544\":1}}],[\"进行推理\",{\"1\":{\"83\":1}}],[\"进行内积操作\",{\"1\":{\"76\":1}}],[\"进行组内和通道间的信息混合\",{\"0\":{\"73\":1}}],[\"进行联合推理\",{\"1\":{\"40\":1}}],[\"进行信息压缩\",{\"1\":{\"36\":1}}],[\"进行微调\",{\"1\":{\"10\":1}}],[\"识别错误并主动纠正\",{\"1\":{\"704\":1}}],[\"识别点云中的功能区域\",{\"1\":{\"71\":1}}],[\"识别交互部位\",{\"1\":{\"28\":1}}],[\"识别交互部件\",{\"1\":{\"6\":1}}],[\"识别图像中物体与人发生交互的部分\",{\"1\":{\"11\":1}}],[\"pmf\",{\"1\":{\"727\":4,\"739\":1}}],[\"ppl\",{\"1\":{\"529\":2}}],[\"ppo\",{\"1\":{\"232\":1,\"535\":1,\"536\":2,\"537\":11,\"538\":8,\"539\":3}}],[\"pwd=vket\",{\"1\":{\"327\":1}}],[\"pwd=qvmq\",{\"1\":{\"316\":1}}],[\"p采样\",{\"1\":{\"313\":1}}],[\"png将dot格式文件转换为png图像\",{\"1\":{\"696\":1}}],[\"png\",{\"1\":{\"302\":1,\"304\":1,\"316\":2,\"463\":2,\"696\":4,\"840\":1,\"848\":2}}],[\"platform\",{\"1\":{\"708\":1}}],[\"place\",{\"1\":{\"578\":2}}],[\"plain\",{\"1\":{\"537\":1}}],[\"playground\",{\"1\":{\"537\":1}}],[\"play\",{\"1\":{\"29\":1,\"536\":1}}],[\"plug\",{\"1\":{\"536\":1}}],[\"plus\",{\"1\":{\"218\":1}}],[\"plm\",{\"1\":{\"492\":3,\"706\":1}}],[\"plot\",{\"1\":{\"316\":2,\"696\":4,\"697\":2}}],[\"plt\",{\"1\":{\"303\":4,\"304\":5,\"316\":7,\"463\":1,\"697\":11,\"852\":1,\"857\":5,\"861\":2,\"886\":6}}],[\"pl\",{\"1\":{\"275\":4,\"276\":11,\"277\":20,\"278\":11}}],[\"ps\",{\"1\":{\"186\":2}}],[\"pseudo\",{\"1\":{\"157\":2}}],[\"pg\",{\"1\":{\"186\":3}}],[\"p=dropout\",{\"1\":{\"632\":1}}],[\"p=drop\",{\"1\":{\"272\":1,\"320\":1,\"323\":1}}],[\"p=top\",{\"1\":{\"143\":1,\"313\":1}}],[\"p=0\",{\"1\":{\"110\":1,\"143\":1,\"186\":4,\"252\":1,\"313\":1,\"470\":2,\"802\":1}}],[\"pkill\",{\"1\":{\"83\":1}}],[\"pkl\",{\"1\":{\"68\":2,\"83\":2,\"792\":2}}],[\"py中导入核心类并初始化运算符重载\",{\"1\":{\"691\":1}}],[\"py文件\",{\"1\":{\"593\":1,\"691\":1}}],[\"pypi\",{\"1\":{\"438\":1}}],[\"pyplot\",{\"1\":{\"304\":1,\"697\":1,\"852\":1,\"886\":1}}],[\"py\",{\"1\":{\"83\":3,\"93\":1,\"96\":1,\"274\":1,\"287\":1,\"316\":1,\"336\":1,\"463\":1,\"544\":1,\"593\":2,\"691\":6}}],[\"python会调用x的\",{\"1\":{\"690\":1}}],[\"python会根据操作数的类型选择不同的方法调用路径\",{\"1\":{\"690\":1}}],[\"python数值类型\",{\"1\":{\"690\":1}}],[\"python首先尝试调用左操作数a的\",{\"1\":{\"690\":1}}],[\"python中\",{\"1\":{\"690\":1}}],[\"python通过跟踪对象的引用次数来管理内存\",{\"1\":{\"687\":1}}],[\"python的内存管理主要依靠两种机制\",{\"1\":{\"687\":1}}],[\"python=3\",{\"1\":{\"431\":2,\"593\":1,\"620\":1}}],[\"python\",{\"0\":{\"335\":1,\"400\":1},\"1\":{\"83\":7,\"316\":1,\"336\":6,\"339\":1,\"340\":1,\"342\":1,\"346\":1,\"355\":1,\"401\":1,\"431\":2,\"438\":7,\"593\":1,\"681\":1,\"690\":1,\"714\":1}}],[\"pytorch中使用比较多的tensor的阶为4\",{\"1\":{\"428\":1}}],[\"pytorch张量存储与访问原理\",{\"0\":{\"420\":1},\"1\":{\"420\":1}}],[\"pytorchlightning\",{\"1\":{\"273\":1}}],[\"pytorch版本\",{\"0\":{\"106\":1}}],[\"pytorch\",{\"0\":{\"357\":1,\"402\":1,\"850\":1},\"1\":{\"76\":1,\"85\":2,\"102\":2,\"131\":1,\"163\":1,\"271\":1,\"272\":1,\"273\":5,\"274\":1,\"316\":2,\"317\":2,\"327\":1,\"358\":1,\"362\":1,\"363\":1,\"364\":1,\"365\":1,\"366\":1,\"378\":1,\"395\":2,\"403\":1,\"422\":1,\"473\":1,\"573\":1,\"593\":3,\"615\":1,\"792\":1,\"795\":1,\"797\":1,\"799\":1,\"850\":1,\"854\":1,\"881\":2}}],[\"pd\",{\"1\":{\"68\":1}}],[\"pdf等格式\",{\"1\":{\"696\":1}}],[\"pdfs\",{\"1\":{\"225\":1}}],[\"pdf\",{\"1\":{\"60\":1,\"696\":1,\"717\":1,\"728\":2,\"746\":1,\"748\":1,\"749\":1,\"752\":1}}],[\"phenomenon\",{\"1\":{\"754\":1}}],[\"photos下的子目录名作为我们的候选待匹配分类文本列表\",{\"1\":{\"302\":1}}],[\"photos\",{\"1\":{\"302\":4,\"304\":2}}],[\"photos目录下读取出所有图片的路径\",{\"1\":{\"302\":1}}],[\"photo\",{\"1\":{\"300\":2,\"301\":2,\"302\":2,\"303\":1,\"304\":2}}],[\"phase\",{\"1\":{\"276\":5,\"277\":15,\"278\":5}}],[\"phrase\",{\"1\":{\"234\":1}}],[\"phrasing\",{\"1\":{\"63\":1}}],[\"philosophy\",{\"1\":{\"550\":1}}],[\"phi\",{\"1\":{\"41\":7,\"59\":7}}],[\"p3\",{\"1\":{\"46\":1}}],[\"p2\",{\"1\":{\"46\":1,\"822\":3}}],[\"p1\",{\"1\":{\"46\":1,\"822\":3}}],[\"p0\",{\"1\":{\"46\":1}}],[\"p+n\",{\"1\":{\"41\":1,\"59\":1}}],[\"ptx\",{\"1\":{\"536\":1,\"537\":4,\"538\":5,\"539\":1}}],[\"ptb\",{\"1\":{\"522\":1,\"577\":1}}],[\"pt较高\",{\"1\":{\"470\":1}}],[\"pth\",{\"1\":{\"327\":1,\"463\":4,\"581\":2,\"885\":2,\"886\":2}}],[\"ptr\",{\"1\":{\"145\":1,\"147\":1,\"160\":1,\"254\":1,\"257\":9}}],[\"pts\",{\"1\":{\"109\":2,\"111\":2}}],[\"pt\",{\"1\":{\"40\":1,\"82\":1,\"83\":1,\"142\":1,\"143\":1,\"145\":1,\"146\":1,\"147\":1,\"159\":1,\"186\":2,\"302\":2,\"304\":2,\"309\":1,\"470\":7,\"544\":1}}],[\"pca\",{\"1\":{\"455\":2}}],[\"pcd\",{\"1\":{\"83\":4}}],[\"pc\",{\"1\":{\"29\":2,\"58\":1,\"68\":1,\"83\":11}}],[\"pup\",{\"1\":{\"777\":1}}],[\"punctuation\",{\"1\":{\"577\":1}}],[\"pull\",{\"1\":{\"29\":1,\"68\":1}}],[\"push\",{\"1\":{\"29\":1,\"58\":1,\"68\":1}}],[\"p\",{\"1\":{\"29\":3,\"30\":2,\"35\":22,\"36\":7,\"41\":15,\"45\":6,\"46\":27,\"58\":3,\"59\":56,\"70\":19,\"72\":1,\"74\":4,\"75\":1,\"80\":6,\"82\":6,\"143\":1,\"186\":2,\"313\":1,\"470\":3,\"476\":2,\"478\":2,\"491\":2,\"544\":1,\"578\":3,\"632\":5,\"799\":4,\"821\":1,\"822\":4,\"830\":1,\"831\":5,\"848\":1,\"849\":1,\"854\":3}}],[\"piqa\",{\"1\":{\"549\":1}}],[\"pii\",{\"1\":{\"537\":1}}],[\"pip\",{\"1\":{\"438\":9,\"620\":1}}],[\"pin\",{\"1\":{\"186\":1,\"252\":1,\"274\":3}}],[\"pil\",{\"1\":{\"186\":1,\"304\":1,\"316\":1,\"317\":2,\"802\":1}}],[\"picture\",{\"1\":{\"142\":2,\"143\":2,\"145\":1}}],[\"pickle\",{\"1\":{\"68\":2,\"83\":3}}],[\"pixels\",{\"1\":{\"802\":3}}],[\"pixelcnn不是唯一一种可用的拟合离散分布的模型\",{\"1\":{\"883\":1}}],[\"pixelcnn能输出某个像素的某个颜色通道取0~255中某个值的概率分布\",{\"1\":{\"878\":1}}],[\"pixelcnn能拟合一个离散的分布\",{\"1\":{\"878\":1}}],[\"pixelcnn的核心思想是给图像的子像素定义一个先后顺序\",{\"1\":{\"847\":1}}],[\"pixelcnn++\",{\"1\":{\"843\":1}}],[\"pixelcnn\",{\"0\":{\"842\":1},\"1\":{\"787\":1,\"842\":1,\"843\":9,\"845\":7,\"846\":3,\"847\":14,\"848\":8,\"886\":30}}],[\"pixel\",{\"1\":{\"28\":5,\"222\":1,\"261\":2,\"772\":1,\"843\":1}}],[\"piad数据集\",{\"1\":{\"49\":1}}],[\"piad\",{\"1\":{\"17\":1,\"20\":1,\"29\":1,\"58\":1}}],[\"piadv2\",{\"1\":{\"16\":1,\"20\":1,\"21\":1,\"26\":1}}],[\"palm\",{\"1\":{\"549\":1,\"550\":1,\"703\":1,\"704\":1}}],[\"palm方案\",{\"1\":{\"548\":1}}],[\"palm等依赖未公开数据\",{\"1\":{\"547\":1}}],[\"package\",{\"1\":{\"438\":1,\"691\":1}}],[\"packages\",{\"1\":{\"438\":1}}],[\"passed\",{\"1\":{\"594\":1,\"815\":1}}],[\"pass\",{\"1\":{\"348\":1,\"349\":1,\"350\":1,\"549\":1,\"578\":1,\"628\":1,\"696\":1}}],[\"past\",{\"1\":{\"162\":1,\"311\":3,\"312\":27,\"544\":27}}],[\"pandas\",{\"1\":{\"431\":1}}],[\"pan\",{\"1\":{\"316\":1,\"327\":1}}],[\"page\",{\"1\":{\"300\":1}}],[\"padded\",{\"1\":{\"369\":6}}],[\"padding位置为0\",{\"1\":{\"276\":1}}],[\"padding=3\",{\"1\":{\"886\":1}}],[\"padding=2\",{\"1\":{\"848\":1}}],[\"padding=kernel\",{\"1\":{\"848\":1}}],[\"padding=1\",{\"1\":{\"793\":4,\"821\":2,\"885\":4,\"886\":1}}],[\"padding=true\",{\"1\":{\"302\":1,\"304\":1}}],[\"padding=\",{\"1\":{\"40\":1,\"142\":1,\"145\":1,\"146\":1,\"147\":1,\"159\":1,\"309\":1}}],[\"padding\",{\"0\":{\"584\":1},\"1\":{\"40\":2,\"43\":3,\"70\":1,\"74\":4,\"75\":1,\"76\":8,\"142\":1,\"143\":1,\"161\":1,\"289\":2,\"309\":1,\"312\":6,\"369\":2,\"544\":1,\"579\":1,\"580\":1,\"594\":6,\"597\":1,\"602\":1,\"603\":1,\"622\":1,\"814\":4,\"815\":2,\"817\":1,\"820\":3,\"822\":2,\"848\":1}}],[\"pad\",{\"0\":{\"369\":1},\"1\":{\"142\":1,\"143\":5,\"147\":1,\"163\":2,\"312\":1,\"313\":2,\"369\":10,\"478\":3,\"578\":2,\"579\":9,\"580\":3,\"584\":11,\"594\":3,\"814\":1,\"815\":1,\"820\":1}}],[\"parse\",{\"1\":{\"840\":1}}],[\"parser\",{\"1\":{\"186\":3,\"840\":12}}],[\"paris\",{\"1\":{\"616\":3}}],[\"paragraph\",{\"1\":{\"577\":7}}],[\"paraphrase\",{\"1\":{\"515\":1}}],[\"para\",{\"1\":{\"327\":2}}],[\"parameter\",{\"1\":{\"145\":1,\"147\":1,\"160\":1,\"169\":3,\"213\":1,\"272\":6,\"299\":1,\"319\":1,\"320\":2,\"323\":2,\"483\":1,\"485\":1,\"488\":1,\"591\":2,\"610\":1,\"822\":1}}],[\"parameters\",{\"1\":{\"80\":2,\"142\":1,\"145\":1,\"147\":1,\"186\":3,\"252\":1,\"254\":2,\"256\":2,\"327\":1,\"366\":1,\"581\":2,\"602\":1,\"840\":2,\"848\":2,\"856\":1,\"860\":1,\"885\":1,\"886\":1}}],[\"params=model\",{\"1\":{\"142\":1,\"145\":1,\"147\":1}}],[\"params\",{\"1\":{\"80\":3,\"145\":1,\"147\":1,\"160\":1,\"186\":3}}],[\"param\",{\"1\":{\"80\":2,\"186\":1,\"254\":5,\"256\":5,\"316\":5,\"318\":6}}],[\"parts\",{\"1\":{\"617\":1}}],[\"partial\",{\"1\":{\"272\":1,\"274\":1,\"323\":1,\"339\":1}}],[\"partition\",{\"1\":{\"731\":1}}],[\"partitioning\",{\"1\":{\"86\":2}}],[\"partitions\",{\"0\":{\"20\":1}}],[\"part\",{\"1\":{\"28\":11,\"83\":3}}],[\"paper\",{\"1\":{\"60\":1,\"327\":1,\"605\":1}}],[\"papers\",{\"1\":{\"60\":1}}],[\"pa\",{\"1\":{\"46\":5,\"59\":5}}],[\"pattern\",{\"1\":{\"370\":2}}],[\"patch数量\",{\"1\":{\"801\":1}}],[\"patch16\",{\"1\":{\"327\":6}}],[\"patch14\",{\"1\":{\"302\":2,\"304\":1}}],[\"patchembedding\",{\"1\":{\"272\":1}}],[\"patchembed\",{\"1\":{\"272\":4,\"318\":2,\"804\":1}}],[\"patches=args\",{\"1\":{\"802\":3}}],[\"patches=none\",{\"1\":{\"801\":1}}],[\"patches=4\",{\"1\":{\"801\":1}}],[\"patches\",{\"1\":{\"73\":3,\"86\":1,\"272\":7,\"318\":5,\"319\":6,\"320\":4,\"322\":11,\"323\":4,\"327\":1,\"328\":1,\"801\":26,\"802\":7,\"804\":5,\"822\":5}}],[\"patch大小的重要性\",{\"0\":{\"181\":1}}],[\"patch\",{\"0\":{\"769\":1},\"1\":{\"41\":5,\"59\":2,\"73\":9,\"126\":1,\"160\":2,\"161\":1,\"167\":8,\"173\":3,\"179\":3,\"181\":2,\"186\":4,\"212\":1,\"261\":1,\"263\":5,\"268\":2,\"272\":42,\"276\":1,\"277\":2,\"280\":1,\"283\":1,\"285\":1,\"294\":1,\"318\":12,\"319\":11,\"320\":5,\"323\":5,\"327\":1,\"463\":11,\"767\":1,\"768\":1,\"769\":8,\"770\":1,\"771\":6,\"772\":12,\"774\":4,\"776\":2,\"780\":1,\"781\":3,\"785\":1,\"788\":2,\"790\":1,\"798\":1,\"800\":1,\"801\":17,\"802\":11,\"803\":3,\"804\":34,\"821\":1,\"822\":20,\"885\":1}}],[\"path$bert\",{\"1\":{\"593\":2}}],[\"paths\",{\"1\":{\"302\":17,\"303\":6,\"304\":21}}],[\"path=args\",{\"1\":{\"803\":1}}],[\"path=prev\",{\"1\":{\"593\":1}}],[\"path=val\",{\"1\":{\"317\":1}}],[\"path=train\",{\"1\":{\"317\":1}}],[\"path=0\",{\"1\":{\"272\":1}}],[\"path=dpr\",{\"1\":{\"272\":1}}],[\"path=\",{\"1\":{\"169\":1,\"170\":2}}],[\"path\",{\"1\":{\"28\":6,\"29\":30,\"58\":24,\"68\":3,\"82\":3,\"83\":5,\"142\":3,\"169\":4,\"170\":4,\"186\":4,\"272\":16,\"302\":12,\"303\":2,\"304\":14,\"316\":30,\"317\":5,\"320\":1,\"321\":7,\"323\":2,\"463\":1,\"476\":6,\"478\":10,\"577\":12,\"578\":5,\"581\":5,\"696\":8,\"697\":1,\"802\":1,\"803\":1}}],[\"pair+nsp\",{\"1\":{\"562\":2}}],[\"pairwise\",{\"1\":{\"537\":1}}],[\"pair是否match\",{\"1\":{\"311\":1}}],[\"pairs\",{\"1\":{\"67\":1,\"145\":1,\"147\":1,\"160\":1,\"476\":9,\"477\":4,\"478\":10,\"515\":1,\"536\":1,\"537\":1,\"538\":1,\"549\":1,\"551\":1,\"579\":14}}],[\"pair\",{\"1\":{\"29\":5,\"58\":3,\"475\":1,\"476\":17,\"477\":14,\"478\":42,\"521\":1,\"594\":2}}],[\"pair=2\",{\"1\":{\"29\":1,\"58\":1}}],[\"priming\",{\"1\":{\"817\":6}}],[\"prior\",{\"1\":{\"733\":1,\"758\":1}}],[\"priority\",{\"1\":{\"690\":2}}],[\"price函数为例\",{\"1\":{\"696\":1}}],[\"price函数求导\",{\"1\":{\"692\":1}}],[\"print\",{\"1\":{\"28\":4,\"82\":1,\"83\":2,\"159\":1,\"169\":2,\"170\":2,\"186\":2,\"302\":6,\"303\":4,\"304\":10,\"316\":3,\"327\":1,\"332\":1,\"333\":1,\"339\":2,\"340\":1,\"341\":3,\"343\":3,\"344\":3,\"345\":2,\"346\":8,\"347\":2,\"348\":1,\"351\":3,\"353\":2,\"355\":1,\"363\":1,\"369\":4,\"372\":6,\"373\":2,\"374\":2,\"378\":1,\"398\":2,\"399\":1,\"401\":4,\"421\":1,\"423\":7,\"425\":4,\"426\":10,\"463\":1,\"541\":3,\"544\":3,\"577\":2,\"581\":3,\"638\":2,\"647\":1,\"688\":2,\"689\":8,\"690\":4,\"692\":3,\"696\":1,\"697\":2,\"803\":2,\"814\":1,\"840\":2,\"848\":2,\"856\":1,\"860\":1,\"885\":4,\"886\":4}}],[\"prc\",{\"1\":{\"452\":1}}],[\"prod\",{\"1\":{\"840\":4}}],[\"product\",{\"1\":{\"115\":1,\"405\":1,\"575\":2,\"605\":1,\"632\":1,\"758\":1}}],[\"procedure\",{\"1\":{\"578\":1,\"579\":1}}],[\"process\",{\"1\":{\"577\":3,\"623\":1}}],[\"processor\",{\"1\":{\"302\":3,\"304\":3}}],[\"processing\",{\"1\":{\"301\":1,\"488\":1}}],[\"promt\",{\"1\":{\"544\":2}}],[\"prompt敏感性高\",{\"1\":{\"530\":1}}],[\"prompt依赖性强\",{\"1\":{\"530\":1}}],[\"prompt写得好不好\",{\"1\":{\"497\":1}}],[\"prompt太长会因超过限制而被截断\",{\"1\":{\"482\":1}}],[\"prompts\",{\"1\":{\"313\":1,\"486\":1,\"537\":3,\"538\":1}}],[\"prompting有一个直观的认知\",{\"1\":{\"503\":1}}],[\"prompting技巧\",{\"1\":{\"502\":1}}],[\"prompting\",{\"1\":{\"301\":1,\"488\":1,\"501\":1,\"503\":1,\"521\":1}}],[\"prompt+pre\",{\"1\":{\"142\":1}}],[\"prompt=config\",{\"1\":{\"142\":1}}],[\"prompt\",{\"0\":{\"239\":1,\"485\":1,\"496\":1},\"1\":{\"11\":2,\"12\":2,\"28\":9,\"142\":10,\"143\":8,\"239\":11,\"301\":3,\"482\":3,\"485\":5,\"486\":1,\"488\":1,\"491\":2,\"496\":1,\"497\":2,\"499\":1,\"501\":1,\"530\":1,\"531\":1,\"537\":8,\"538\":1,\"539\":1,\"544\":4,\"713\":1,\"715\":1,\"716\":10,\"717\":12,\"817\":2,\"820\":1}}],[\"prototypical\",{\"1\":{\"531\":1}}],[\"provided\",{\"1\":{\"478\":2}}],[\"proximal\",{\"1\":{\"232\":1,\"537\":1}}],[\"pro\",{\"1\":{\"218\":1,\"704\":3}}],[\"prob=1\",{\"1\":{\"816\":1}}],[\"prob=0\",{\"1\":{\"815\":1}}],[\"probabilistic\",{\"1\":{\"703\":1,\"758\":1}}],[\"probabilities\",{\"1\":{\"605\":1}}],[\"probability=\",{\"1\":{\"274\":1}}],[\"probability\",{\"0\":{\"731\":1},\"1\":{\"160\":2,\"163\":6,\"727\":1,\"728\":1,\"733\":2}}],[\"problems\",{\"0\":{\"759\":1}}],[\"problem\",{\"1\":{\"535\":1,\"759\":1}}],[\"probs\",{\"1\":{\"293\":4,\"300\":3,\"312\":7,\"605\":5,\"818\":3,\"848\":2,\"886\":2}}],[\"prob\",{\"1\":{\"274\":1,\"292\":1,\"597\":1,\"599\":1,\"603\":1,\"605\":1,\"606\":1,\"617\":1,\"618\":1,\"815\":6,\"816\":1}}],[\"probing\",{\"1\":{\"213\":1,\"245\":1}}],[\"property\",{\"1\":{\"274\":5,\"689\":4}}],[\"properties\",{\"1\":{\"172\":2}}],[\"propagation\",{\"1\":{\"98\":4,\"99\":1,\"100\":1,\"101\":2}}],[\"projected\",{\"1\":{\"632\":1}}],[\"projects\",{\"1\":{\"306\":1}}],[\"projections\",{\"1\":{\"632\":1}}],[\"projection转化成visual\",{\"1\":{\"284\":1}}],[\"projection方法将输入图片切片投影提取特征\",{\"1\":{\"283\":1}}],[\"projection来做visual\",{\"1\":{\"280\":1,\"283\":1}}],[\"projection的多模态预训练模型\",{\"1\":{\"280\":1}}],[\"projection\",{\"1\":{\"160\":2,\"186\":1,\"632\":1,\"814\":1,\"821\":1}}],[\"proj\",{\"1\":{\"32\":6,\"34\":3,\"35\":4,\"36\":5,\"45\":32,\"59\":5,\"80\":2,\"83\":2,\"145\":18,\"146\":4,\"147\":12,\"160\":8,\"161\":4,\"272\":9,\"277\":4,\"299\":2,\"309\":2,\"318\":2,\"321\":1,\"322\":6,\"463\":2,\"544\":2,\"624\":2,\"804\":2}}],[\"pretext\",{\"0\":{\"786\":1}}],[\"pretraining\",{\"0\":{\"277\":1,\"285\":1,\"785\":1,\"788\":1,\"789\":1},\"1\":{\"171\":2,\"272\":1,\"275\":1,\"537\":1,\"557\":1,\"802\":1,\"803\":1}}],[\"pretrain\",{\"1\":{\"147\":3,\"537\":1}}],[\"pretrainedtokenizer\",{\"1\":{\"594\":1}}],[\"pretrained=false\",{\"1\":{\"396\":1}}],[\"pretrained=true\",{\"1\":{\"395\":1,\"396\":1}}],[\"pretrained=config\",{\"1\":{\"142\":1,\"145\":1}}],[\"pretrained\",{\"1\":{\"28\":2,\"142\":1,\"145\":1,\"147\":2,\"160\":2,\"274\":1,\"302\":4,\"304\":4,\"541\":2,\"544\":1}}],[\"precomputed\",{\"1\":{\"605\":1}}],[\"precision\",{\"1\":{\"471\":1,\"746\":1}}],[\"prev\",{\"1\":{\"593\":1,\"816\":2,\"817\":1}}],[\"preview\",{\"0\":{\"250\":1},\"1\":{\"704\":3}}],[\"present\",{\"1\":{\"312\":2}}],[\"press\",{\"1\":{\"29\":1,\"58\":1,\"68\":1}}],[\"prepare\",{\"1\":{\"273\":1,\"274\":5,\"476\":2,\"478\":4,\"579\":3}}],[\"prefix\",{\"0\":{\"486\":1},\"1\":{\"143\":1,\"239\":2,\"345\":3,\"486\":5,\"491\":2}}],[\"pre\",{\"0\":{\"153\":1,\"266\":1,\"774\":1},\"1\":{\"119\":2,\"120\":1,\"134\":1,\"179\":1,\"233\":1,\"259\":2,\"268\":2,\"270\":1,\"298\":1,\"301\":1,\"323\":3,\"327\":2,\"488\":1,\"492\":1,\"505\":1,\"506\":1,\"548\":1,\"704\":2,\"764\":2,\"775\":1}}],[\"pred的进行pad填充\",{\"1\":{\"581\":1}}],[\"predictor\",{\"1\":{\"173\":1,\"178\":1}}],[\"predicted\",{\"1\":{\"83\":1,\"302\":6,\"304\":6}}],[\"predict\",{\"1\":{\"83\":2,\"142\":1,\"273\":8,\"274\":1,\"301\":1,\"488\":1,\"575\":1}}],[\"predictions\",{\"1\":{\"611\":2}}],[\"prediction\",{\"0\":{\"573\":1},\"1\":{\"78\":1,\"83\":1,\"163\":5,\"295\":7,\"305\":1,\"312\":6,\"564\":1,\"571\":1,\"594\":1,\"611\":2,\"612\":4,\"815\":1}}],[\"pred\",{\"1\":{\"78\":10,\"82\":4,\"83\":24,\"323\":5,\"579\":7,\"580\":7}}],[\"pepper\",{\"1\":{\"762\":2}}],[\"penn\",{\"1\":{\"577\":1}}],[\"penalty\",{\"1\":{\"143\":1}}],[\"penalty=repetition\",{\"1\":{\"143\":1}}],[\"penalty=1\",{\"1\":{\"143\":2,\"313\":1}}],[\"petaflop\",{\"1\":{\"539\":3}}],[\"peft\",{\"1\":{\"488\":1,\"495\":1}}],[\"peft是目前业界比较流行的微调方案\",{\"1\":{\"484\":1}}],[\"peft也是目前比较主流的微调方案\",{\"1\":{\"483\":1}}],[\"peft主要想解决的问题\",{\"1\":{\"483\":1}}],[\"people\",{\"1\":{\"28\":6,\"31\":4,\"234\":1}}],[\"perplexity\",{\"1\":{\"521\":1,\"522\":1}}],[\"perspective\",{\"1\":{\"538\":1}}],[\"persistent=false\",{\"1\":{\"814\":1}}],[\"persistent\",{\"1\":{\"366\":2}}],[\"person\",{\"1\":{\"28\":8,\"31\":2,\"234\":1,\"300\":1}}],[\"perm\",{\"1\":{\"885\":6}}],[\"permissionerror\",{\"1\":{\"353\":1}}],[\"permutation\",{\"1\":{\"104\":1,\"115\":2}}],[\"permute维度\",{\"1\":{\"36\":2}}],[\"permute后\",{\"1\":{\"35\":1}}],[\"permute\",{\"0\":{\"360\":1},\"1\":{\"30\":2,\"32\":2,\"34\":1,\"35\":2,\"36\":2,\"41\":2,\"45\":1,\"59\":3,\"92\":4,\"96\":4,\"100\":5,\"101\":1,\"272\":1,\"293\":1,\"310\":1,\"312\":1,\"322\":2,\"360\":2,\"361\":2,\"362\":1,\"463\":1,\"591\":3,\"605\":2,\"848\":1,\"885\":3,\"886\":1}}],[\"per\",{\"1\":{\"98\":1,\"99\":2,\"274\":1,\"277\":12,\"322\":6,\"591\":1,\"593\":2,\"802\":2,\"803\":1}}],[\"performing\",{\"1\":{\"169\":1,\"170\":1}}],[\"performs\",{\"1\":{\"28\":2}}],[\"performance\",{\"0\":{\"25\":1},\"1\":{\"571\":1}}],[\"perception\",{\"1\":{\"11\":1,\"28\":2}}],[\"poisson\",{\"0\":{\"739\":1}}],[\"pointer\",{\"1\":{\"254\":1,\"257\":1,\"425\":1}}],[\"pointcnn\",{\"1\":{\"112\":1}}],[\"pointcloud\",{\"1\":{\"83\":2,\"92\":2}}],[\"pointfeat\",{\"1\":{\"109\":2}}],[\"point点云数据\",{\"1\":{\"70\":1}}],[\"pointrefer模型结构图\",{\"1\":{\"70\":1}}],[\"pointrefer\",{\"1\":{\"70\":5,\"76\":1,\"78\":1,\"80\":1,\"82\":2,\"83\":4}}],[\"pointnetdensecls\",{\"1\":{\"111\":3}}],[\"pointnetcls\",{\"1\":{\"110\":3}}],[\"pointnetfeat\",{\"1\":{\"109\":3,\"110\":4,\"111\":3}}],[\"pointnetfeaturepropagation\",{\"1\":{\"35\":3,\"46\":5,\"59\":3,\"100\":3,\"101\":4}}],[\"pointnet网络模型结构图\",{\"1\":{\"106\":1}}],[\"pointnet后\",{\"1\":{\"93\":3}}],[\"pointnetsetabstractionmsg\",{\"1\":{\"96\":5}}],[\"pointnetsetabstraction\",{\"1\":{\"92\":3,\"93\":3,\"96\":1,\"101\":4}}],[\"pointnet来提取局部区域中的特征\",{\"1\":{\"91\":1}}],[\"pointnet将局部区域编码为特征向量\",{\"1\":{\"88\":1}}],[\"pointnet\",{\"0\":{\"91\":1},\"1\":{\"85\":1,\"87\":1,\"88\":2,\"92\":2,\"96\":1,\"98\":1,\"102\":2,\"103\":1,\"105\":4,\"107\":4,\"108\":2,\"109\":1,\"110\":1,\"111\":1,\"112\":26,\"115\":2}}],[\"pointnet2\",{\"1\":{\"85\":2,\"93\":1,\"96\":2}}],[\"pointnet编码点云\",{\"1\":{\"59\":1}}],[\"pointnet++提出了密度自适应pointnet层\",{\"1\":{\"94\":1}}],[\"pointnet++提取特征\",{\"1\":{\"54\":1}}],[\"pointnet++应用pointnet递归地对输入集进行嵌套分区\",{\"1\":{\"86\":1}}],[\"pointnet++选择pointnet作为局部特征学习器\",{\"1\":{\"86\":1}}],[\"pointnet++在进行点集划分时\",{\"1\":{\"86\":1}}],[\"pointnet++的下一个任务是学习这些子集\",{\"1\":{\"86\":1}}],[\"pointnet++需要一种方法来有效地将点云分割成多个部分\",{\"1\":{\"86\":1}}],[\"pointnet++\",{\"1\":{\"8\":1,\"14\":1,\"22\":1,\"30\":1,\"40\":1,\"70\":3,\"71\":1,\"86\":1,\"92\":3,\"93\":2,\"96\":2,\"98\":2,\"99\":1,\"100\":1,\"101\":1,\"112\":4}}],[\"points2\",{\"1\":{\"98\":2,\"100\":7}}],[\"points1\",{\"1\":{\"98\":2,\"100\":7}}],[\"points\",{\"1\":{\"29\":9,\"35\":1,\"40\":1,\"58\":9,\"63\":1,\"83\":18,\"92\":68,\"93\":7,\"96\":39,\"98\":2,\"99\":7,\"100\":15,\"101\":27,\"104\":2,\"107\":1}}],[\"point\",{\"1\":{\"16\":1,\"28\":3,\"29\":28,\"30\":1,\"40\":8,\"41\":6,\"46\":3,\"58\":14,\"59\":1,\"68\":6,\"70\":3,\"76\":3,\"81\":3,\"82\":6,\"83\":15,\"89\":1,\"92\":7,\"96\":2,\"98\":2,\"99\":2,\"105\":1,\"107\":2,\"112\":2,\"114\":1}}],[\"pop\",{\"1\":{\"668\":1,\"682\":1,\"684\":1,\"686\":1,\"688\":1,\"696\":2}}],[\"pope\",{\"1\":{\"198\":1,\"203\":1}}],[\"portion\",{\"1\":{\"594\":1}}],[\"ported\",{\"1\":{\"327\":1}}],[\"portrait\",{\"1\":{\"300\":1}}],[\"policy\",{\"1\":{\"232\":3,\"535\":1,\"537\":1}}],[\"polar\",{\"1\":{\"157\":1}}],[\"power\",{\"1\":{\"485\":1,\"821\":1}}],[\"pow\",{\"1\":{\"170\":2,\"690\":5,\"692\":2,\"854\":1}}],[\"pond\",{\"1\":{\"157\":1}}],[\"pos=bool\",{\"1\":{\"803\":1,\"804\":2}}],[\"pos=self\",{\"1\":{\"70\":1,\"76\":1}}],[\"posed\",{\"1\":{\"759\":1}}],[\"posterior\",{\"1\":{\"733\":1,\"758\":2}}],[\"possible\",{\"1\":{\"478\":1}}],[\"positive和\",{\"1\":{\"516\":1}}],[\"positives\",{\"1\":{\"471\":1}}],[\"positive\",{\"1\":{\"78\":6,\"145\":1,\"252\":1,\"255\":2,\"469\":1,\"471\":4}}],[\"positions\",{\"1\":{\"615\":7,\"616\":1}}],[\"positions=none\",{\"1\":{\"615\":2}}],[\"position=cache\",{\"1\":{\"544\":1}}],[\"position=none\",{\"1\":{\"544\":1}}],[\"positional\",{\"0\":{\"586\":1,\"587\":1},\"1\":{\"320\":1,\"337\":1,\"587\":1,\"588\":1,\"622\":1,\"804\":1}}],[\"position\",{\"0\":{\"589\":1,\"590\":1,\"591\":1},\"1\":{\"28\":2,\"76\":1,\"92\":5,\"96\":2,\"163\":2,\"272\":11,\"276\":4,\"277\":12,\"289\":2,\"295\":2,\"311\":9,\"312\":2,\"514\":1,\"544\":16,\"573\":1,\"591\":25,\"597\":12,\"602\":2,\"603\":2,\"612\":2,\"615\":2,\"617\":2,\"618\":6,\"704\":1,\"802\":2,\"814\":1}}],[\"pos\",{\"1\":{\"76\":8,\"145\":7,\"147\":2,\"162\":2,\"255\":2,\"272\":11,\"276\":1,\"277\":2,\"278\":7,\"320\":5,\"323\":5,\"578\":10,\"579\":6,\"580\":9,\"581\":2,\"590\":10,\"591\":10,\"617\":1,\"803\":7,\"804\":14,\"814\":2,\"815\":2,\"820\":1,\"822\":4}}],[\"pos1d\",{\"1\":{\"70\":1,\"76\":1}}],[\"po\",{\"1\":{\"36\":6}}],[\"pooled\",{\"1\":{\"289\":5,\"601\":4,\"602\":2,\"603\":4,\"611\":2,\"612\":2,\"614\":2,\"618\":4}}],[\"pooler\",{\"1\":{\"276\":1,\"289\":3,\"383\":1,\"580\":7,\"602\":2}}],[\"pooling\",{\"0\":{\"386\":1},\"1\":{\"92\":1,\"98\":1,\"105\":5,\"107\":1,\"112\":7,\"115\":3,\"145\":2,\"146\":1,\"147\":2,\"295\":1,\"386\":6,\"387\":1,\"776\":1}}],[\"pool后\",{\"1\":{\"36\":1}}],[\"pool\",{\"1\":{\"36\":2,\"46\":4,\"59\":8,\"157\":1,\"580\":2,\"601\":1}}],[\"pour\",{\"1\":{\"6\":1,\"7\":1,\"23\":1,\"28\":4,\"29\":1,\"31\":2,\"32\":1,\"58\":1,\"68\":1}}],[\"该目标函数的形式如下\",{\"1\":{\"873\":1}}],[\"该结构如图4右侧所示\",{\"1\":{\"868\":1}}],[\"该像素由之前所有像素决定的生成模型\",{\"1\":{\"847\":1}}],[\"该松弛会变得精确\",{\"1\":{\"808\":1}}],[\"该下界仅在\",{\"1\":{\"807\":1}}],[\"该数据集不包含\",{\"1\":{\"810\":1}}],[\"该数据集包含\",{\"1\":{\"810\":1}}],[\"该数据集包含约\",{\"1\":{\"774\":1}}],[\"该数据集大大超越了前作\",{\"1\":{\"17\":1}}],[\"该分布会表现得像高斯分布\",{\"1\":{\"748\":1}}],[\"该架构巧妙地整合了从庞大知识库中检索到的相关信息\",{\"1\":{\"709\":1}}],[\"该架构支持以下三种功能模式\",{\"1\":{\"126\":1}}],[\"该函数对\",{\"1\":{\"868\":1}}],[\"该函数常作为优化问题的基准函数使用\",{\"1\":{\"697\":1}}],[\"该函数的形状如下图所示\",{\"1\":{\"697\":1}}],[\"该函数自动调用系统命令转换文件\",{\"1\":{\"696\":1}}],[\"该函数形式复杂\",{\"1\":{\"692\":1}}],[\"该函数作用是针对给定的图片路径\",{\"1\":{\"302\":1}}],[\"该\",{\"1\":{\"584\":1,\"772\":1,\"809\":1}}],[\"该流程可参见论文图\",{\"1\":{\"537\":1}}],[\"该方向在对话系统\",{\"1\":{\"536\":1}}],[\"该方法避免了传统像素级重建的局限性\",{\"1\":{\"765\":1}}],[\"该方法包括三个关键步骤\",{\"1\":{\"535\":1}}],[\"该方法正是clip在vlp领域发扬光大的\",{\"1\":{\"310\":1}}],[\"该方法的主要计算量都集中在模态交互上\",{\"1\":{\"282\":1}}],[\"该方法负责完成具体的一轮训练实现\",{\"1\":{\"275\":1}}],[\"该方法实现过程比较复杂\",{\"1\":{\"274\":1}}],[\"该方法会将所有\",{\"1\":{\"257\":1}}],[\"该方法通过灵活分割图像图块\",{\"1\":{\"224\":1}}],[\"该方法依赖于\",{\"1\":{\"178\":1}}],[\"该方法无需额外模型\",{\"1\":{\"150\":1}}],[\"该方法能够有效从噪声图文对中学习\",{\"1\":{\"125\":1}}],[\"该方法能更好的覆盖整个点集\",{\"1\":{\"89\":1}}],[\"该方法摆脱了对几何标注或固定场景的依赖\",{\"1\":{\"49\":1}}],[\"该方法在piad数据集上表现优异\",{\"1\":{\"48\":1}}],[\"该方法从交互图像中进行推理\",{\"1\":{\"26\":1}}],[\"该任务通过随机遮挡一部分图像\",{\"1\":{\"772\":1}}],[\"该任务要求预测句子的最后一个词\",{\"1\":{\"522\":1}}],[\"该任务主要是对一个给定句子\",{\"1\":{\"515\":1}}],[\"该任务的学习目标是通过硬负样本策略\",{\"1\":{\"278\":1}}],[\"该任务的学习目标是采用对比学习策略\",{\"1\":{\"277\":1}}],[\"该任务的学习目标是根据未被掩码的图像序列和文本序列\",{\"1\":{\"276\":1}}],[\"该设置不需要这些目标任务和无标记语料库是一个领域的\",{\"1\":{\"507\":1}}],[\"该系数也等于f1得分\",{\"1\":{\"471\":1}}],[\"该参数未在当前代码中使用\",{\"1\":{\"467\":1}}],[\"该图展示了\",{\"1\":{\"427\":1}}],[\"该缓冲区会包含在\",{\"1\":{\"366\":1}}],[\"该类的作用是将二维图像分割成多个图像块\",{\"1\":{\"318\":1}}],[\"该示例中的任务涉及8个类别\",{\"1\":{\"300\":1}}],[\"该功能由\",{\"1\":{\"272\":1}}],[\"该模块可以为后续的分类任务提供更具区分性和稳定性的特征表示\",{\"1\":{\"323\":1}}],[\"该模块用于编码图像\",{\"1\":{\"268\":1}}],[\"该模型的结构如图6所示\",{\"1\":{\"874\":1}}],[\"该模型的输入是一对\",{\"1\":{\"232\":1}}],[\"该模型能够灵活生成高质量图像\",{\"1\":{\"806\":1}}],[\"该模型同样采用端到端微调的方式\",{\"1\":{\"777\":1}}],[\"该模型在上下文\",{\"1\":{\"510\":1}}],[\"该模型在文本上处理长期依赖提供了更结构化的内存\",{\"1\":{\"507\":1}}],[\"该模型是在\",{\"1\":{\"327\":1}}],[\"该模型联合训练一个cnn和文本transformer来预测图像的文本描述\",{\"1\":{\"305\":1}}],[\"该模型通过将视觉基础模型扩展到60亿参数\",{\"1\":{\"188\":1}}],[\"该向量即表示一个\",{\"1\":{\"255\":1}}],[\"该编码器支持密集预测任务\",{\"1\":{\"197\":1}}],[\"该过程由make\",{\"1\":{\"579\":1}}],[\"该过程由\",{\"1\":{\"186\":1}}],[\"该过程借助内部维护的\",{\"1\":{\"170\":1}}],[\"该范围确保局部区域的尺度是固定的\",{\"1\":{\"90\":1}}],[\"该部分首先回顾了自然语言处理\",{\"1\":{\"531\":1}}],[\"该部分包含\",{\"1\":{\"11\":1,\"12\":1}}],[\"该部位的几何属性推理\",{\"1\":{\"28\":1}}],[\"该物体常见的其他交互\",{\"1\":{\"28\":1}}],[\"该框架结合了多模态大语言模型\",{\"1\":{\"5\":1}}],[\"以决定我们允许模型\",{\"1\":{\"873\":1}}],[\"以简化表示\",{\"1\":{\"868\":1}}],[\"以手写数字为例\",{\"1\":{\"866\":1}}],[\"以生成手写数字图像为例\",{\"1\":{\"865\":1}}],[\"以生成相应的文本特征\",{\"1\":{\"300\":1}}],[\"以图像为例\",{\"1\":{\"864\":1}}],[\"以强化条件信号的方法\",{\"1\":{\"816\":1}}],[\"以匹配\",{\"1\":{\"815\":1}}],[\"以一定概率随机删除文本条件\",{\"1\":{\"815\":1}}],[\"以确保初始化时的稳定训练\",{\"1\":{\"808\":1}}],[\"以确保问题多样性和语义丰富性\",{\"1\":{\"63\":1}}],[\"以自回归的方式将文本和图像\",{\"1\":{\"807\":1}}],[\"以至于定义均值的积分并不收敛\",{\"1\":{\"749\":1}}],[\"以调用\",{\"1\":{\"716\":1}}],[\"以改善多媒体交互\",{\"1\":{\"708\":1}}],[\"以goldstein\",{\"1\":{\"696\":1}}],[\"以目录形式存在\",{\"1\":{\"691\":1}}],[\"以乘法为例\",{\"1\":{\"690\":1}}],[\"以def\",{\"1\":{\"690\":2}}],[\"以加速模型的训练和扩展其中\",{\"1\":{\"704\":1}}],[\"以加速训练并提高模型的稳定性\",{\"1\":{\"622\":1}}],[\"以加法a\",{\"1\":{\"690\":1}}],[\"以释放内存供后续计算使用\",{\"1\":{\"687\":1}}],[\"以平方函数为例\",{\"1\":{\"661\":1}}],[\"以平衡计算效率\",{\"1\":{\"548\":1}}],[\"以往为了解决不同的\",{\"1\":{\"571\":1}}],[\"以无监督的方式利用大量无标注文本\",{\"1\":{\"571\":1}}],[\"以88\",{\"1\":{\"566\":1}}],[\"以防泄露\",{\"1\":{\"711\":1}}],[\"以防对齐过程中性能退化\",{\"1\":{\"537\":1}}],[\"以防下游\",{\"1\":{\"276\":1}}],[\"以降低毒性输出倾向\",{\"1\":{\"536\":1}}],[\"以上模型的上下文长度为\",{\"1\":{\"704\":1}}],[\"以上就是variable类的新\",{\"1\":{\"682\":1}}],[\"以上下文为接口\",{\"1\":{\"528\":1}}],[\"以上代码注释中统一用b代替image\",{\"1\":{\"309\":1}}],[\"以研究性能与规模之间的关系\",{\"1\":{\"528\":1}}],[\"以研究模型容量对性能的影响\",{\"1\":{\"521\":1}}],[\"以节省\",{\"1\":{\"495\":1}}],[\"以此来评判dall\",{\"1\":{\"822\":1}}],[\"以此来模拟所谓的内在秩\",{\"1\":{\"492\":1}}],[\"以此来简化子实现类需要做的操作\",{\"1\":{\"274\":1}}],[\"以增加模型接触不同任务\",{\"1\":{\"521\":1}}],[\"以增大生成期望序列的概率\",{\"1\":{\"485\":1}}],[\"以增强理解\",{\"1\":{\"536\":1}}],[\"以增强性能\",{\"1\":{\"299\":1}}],[\"以增强\",{\"1\":{\"71\":1}}],[\"以增强泛化能力\",{\"1\":{\"19\":1}}],[\"以输入\",{\"1\":{\"477\":1}}],[\"以三个变量为例\",{\"1\":{\"455\":1}}],[\"以两个变量为例\",{\"1\":{\"455\":1}}],[\"以避免安装到错误的位置\",{\"1\":{\"438\":1}}],[\"以避免模型将匹配图文对挑选为负样本\",{\"1\":{\"311\":1}}],[\"以使得模型能够学习到最适合当前任务的位置表示\",{\"1\":{\"320\":1}}],[\"以最大程度地惩罚降低iou得分的预测结果\",{\"1\":{\"472\":1}}],[\"以最大化互信息\",{\"1\":{\"310\":1}}],[\"以最小化损失\",{\"1\":{\"319\":1}}],[\"以保留图像的空间信息\",{\"1\":{\"319\":1}}],[\"以保持与其他模型的一致性\",{\"1\":{\"319\":1,\"320\":1,\"323\":1}}],[\"以保持计算的可管理性\",{\"1\":{\"90\":1}}],[\"以保持原始模型识别能力的同时增强其推理能力\",{\"1\":{\"10\":1}}],[\"以vit\",{\"1\":{\"318\":1}}],[\"以bos\",{\"1\":{\"313\":1}}],[\"以利用\",{\"1\":{\"313\":1}}],[\"以细粒度对齐\",{\"1\":{\"311\":1}}],[\"以弥合模态差距\",{\"1\":{\"308\":1}}],[\"以每个文本描述为一行\",{\"1\":{\"303\":1}}],[\"以获取图像特征\",{\"1\":{\"300\":1}}],[\"以获得更强的局部几何感知能力\",{\"1\":{\"96\":1}}],[\"以支持通用的多模态预训练\",{\"1\":{\"269\":1}}],[\"以支持训练阶段的匹配与推理\",{\"1\":{\"18\":1}}],[\"以分析不同训练策略的影响\",{\"1\":{\"237\":1}}],[\"以奖励模型为环境反馈信号\",{\"1\":{\"537\":1}}],[\"以奖励模型为\",{\"1\":{\"232\":1}}],[\"以促进mllm社区发展\",{\"1\":{\"216\":1}}],[\"以促进视觉\",{\"1\":{\"138\":1}}],[\"以提高数据质量和多样性\",{\"1\":{\"704\":1}}],[\"以提高效率\",{\"1\":{\"198\":1,\"866\":1}}],[\"以提升相似度分布的差异性\",{\"1\":{\"822\":1}}],[\"以提升大批次训练的稳定性\",{\"1\":{\"561\":1}}],[\"以提升效率\",{\"1\":{\"528\":1}}],[\"以提升特征质量\",{\"1\":{\"176\":1}}],[\"以预训练权重初始化网络\",{\"1\":{\"179\":1}}],[\"以\",{\"0\":{\"415\":1},\"1\":{\"159\":1,\"186\":4,\"317\":1,\"514\":1,\"703\":1,\"802\":1,\"847\":1}}],[\"以下小节总结了其中一些常见分布\",{\"1\":{\"735\":1}}],[\"以下模型的上下文长度为\",{\"1\":{\"704\":1}}],[\"以下情况会增加引用计数\",{\"1\":{\"687\":1}}],[\"以下内容来自\",{\"1\":{\"385\":1}}],[\"以下引用clip论文图做说明\",{\"1\":{\"310\":1}}],[\"以下为动量编码器分支\",{\"1\":{\"161\":1}}],[\"以下首先给出的是\",{\"1\":{\"147\":1}}],[\"以下是你提供内容的逐段翻译与解释\",{\"1\":{\"752\":1}}],[\"以下是大语言模型的一些主要特点\",{\"1\":{\"705\":1}}],[\"以下是具体分析\",{\"1\":{\"385\":1}}],[\"以下是一个官方给出的clip模型的示例\",{\"1\":{\"300\":1}}],[\"以下是两者的主要区别\",{\"1\":{\"239\":1}}],[\"以下是论文\",{\"1\":{\"134\":1}}],[\"以下是对\",{\"1\":{\"129\":1,\"536\":1}}],[\"以下代码是我自己写的一个测试代码\",{\"1\":{\"83\":1}}],[\"以计算以下三种损失\",{\"1\":{\"127\":1}}],[\"以实现对生成样本的控制\",{\"1\":{\"858\":1}}],[\"以实现生成任务\",{\"1\":{\"126\":1}}],[\"以实现最佳的性能\",{\"1\":{\"96\":1}}],[\"以及经过筛选的\",{\"1\":{\"810\":1}}],[\"以及误差\",{\"1\":{\"797\":1}}],[\"以及函数等更复杂的样本空间\",{\"1\":{\"728\":1}}],[\"以及每一个功能的大体实现逻辑\",{\"1\":{\"717\":1}}],[\"以及即将推出的\",{\"1\":{\"704\":1}}],[\"以及对错误数据\",{\"1\":{\"717\":1}}],[\"以及对\",{\"1\":{\"704\":1}}],[\"以及add\",{\"1\":{\"691\":1}}],[\"以及特定群体优先原则\",{\"1\":{\"539\":1}}],[\"以及一系列元数据\",{\"1\":{\"537\":1}}],[\"以及一个权重归一化的全连接层组成\",{\"1\":{\"178\":1}}],[\"以及缺乏透明性等\",{\"1\":{\"530\":1}}],[\"以及如何高效地进行多次调用和推理\",{\"1\":{\"714\":1}}],[\"以及如何更好地利用其隐含学习到的多任务能力\",{\"1\":{\"524\":1}}],[\"以及如何通过局部特征学习器\",{\"1\":{\"86\":1}}],[\"以及研究双向表示\",{\"1\":{\"523\":1}}],[\"以及分割字符嵌入矩阵\",{\"1\":{\"511\":1}}],[\"以及语言模型来提升标记的语义角色\",{\"1\":{\"508\":1}}],[\"以及prompt的长度\",{\"1\":{\"501\":1}}],[\"以及训练的方法的角度\",{\"1\":{\"483\":1}}],[\"以及seq\",{\"1\":{\"309\":1}}],[\"以及\",{\"1\":{\"225\":1,\"521\":1,\"704\":1,\"807\":1}}],[\"以及多张较低分辨率的\",{\"1\":{\"178\":1}}],[\"以及在多模态编码器上进行掩码语言模型\",{\"1\":{\"153\":1}}],[\"以及数据集自举策略\",{\"1\":{\"125\":1}}],[\"以适配后面的卷积操作\",{\"1\":{\"100\":1}}],[\"以便计算余弦相似度\",{\"1\":{\"822\":1}}],[\"以便开发各种下游应用\",{\"1\":{\"712\":1}}],[\"以便生成模型可以更好地理解和使用\",{\"1\":{\"710\":1}}],[\"以便一起处理\",{\"1\":{\"618\":1}}],[\"以便送入全连接层进行分类和回归\",{\"1\":{\"387\":1}}],[\"以便\",{\"1\":{\"309\":1}}],[\"以便处理通道维\",{\"1\":{\"170\":1}}],[\"以便和特征相乘\",{\"1\":{\"100\":1}}],[\"以便可以在这些分区上独立地学习特征\",{\"1\":{\"86\":1}}],[\"以便可以在这些区域上应用局部操作\",{\"1\":{\"86\":1}}],[\"以结合来自不同尺度的特征\",{\"1\":{\"95\":1}}],[\"以反映其相对位置\",{\"1\":{\"91\":1}}],[\"以限制每个局部区域中考虑的点的数量\",{\"1\":{\"90\":1}}],[\"以产生一个更少元素的新集合\",{\"1\":{\"88\":1}}],[\"以二维欧几里得空间为例\",{\"1\":{\"87\":1}}],[\"以开放词汇的方式定位3d物体的功能区域\",{\"1\":{\"5\":1}}],[\"其结构如下图所示\",{\"1\":{\"878\":1}}],[\"其前向传播没有问题\",{\"1\":{\"868\":1}}],[\"其可以写成如下闭式表达\",{\"1\":{\"868\":1}}],[\"其分布为维度为\",{\"1\":{\"866\":1}}],[\"其值由\",{\"1\":{\"866\":1}}],[\"其伯努利分布定义为\",{\"1\":{\"854\":1}}],[\"其反映的实际是整个统一词空间上的概率分布\",{\"1\":{\"814\":1}}],[\"其反向传播逻辑为将上游梯度原封不动地传递给两个输入变量\",{\"1\":{\"690\":1}}],[\"其下界为\",{\"1\":{\"807\":1}}],[\"其下标索引公式可表示为\",{\"1\":{\"425\":1}}],[\"其质量直接决定预训练效果\",{\"1\":{\"802\":1}}],[\"其视觉\",{\"1\":{\"774\":1}}],[\"其具体方法总结如下\",{\"1\":{\"772\":1}}],[\"其重建目标函数如下\",{\"1\":{\"770\":1}}],[\"其\",{\"1\":{\"753\":1}}],[\"其形式为\",{\"1\":{\"749\":1}}],[\"其形状是\",{\"1\":{\"423\":1}}],[\"其形状和大小保持不变的运动方式\",{\"1\":{\"116\":1}}],[\"其概率密度函数可表示为\",{\"1\":{\"752\":1}}],[\"其概率密度函数为\",{\"1\":{\"747\":1,\"866\":1}}],[\"其概率质量函数定义为\",{\"1\":{\"741\":1}}],[\"其它位置保留原\",{\"1\":{\"804\":1}}],[\"其它元素为\",{\"1\":{\"738\":1}}],[\"其它方法都有各自的一些问题\",{\"1\":{\"491\":1}}],[\"其定义如下\",{\"1\":{\"728\":1}}],[\"其定义为\",{\"1\":{\"446\":1}}],[\"其三个面分别标记为\",{\"1\":{\"727\":1}}],[\"其技术核心点虽然在大语言模型上\",{\"1\":{\"716\":1}}],[\"其涵盖了模型的输入与输出处理\",{\"1\":{\"714\":1}}],[\"其工作流程可以简单地分为数据处理\",{\"1\":{\"710\":1}}],[\"其性能可与具备\",{\"1\":{\"704\":1}}],[\"其性能与商业模型\",{\"1\":{\"215\":1}}],[\"其最大值可能不在梯度指示方向\",{\"1\":{\"697\":1}}],[\"其最后的全连接层\",{\"1\":{\"255\":1}}],[\"其式子为\",{\"1\":{\"697\":1}}],[\"其支持节点和箭头构成的数据结构可视化\",{\"1\":{\"696\":1}}],[\"其类型可能是原生数值\",{\"1\":{\"690\":1}}],[\"其导数公式为\",{\"1\":{\"690\":1}}],[\"其导数依赖于输出值\",{\"1\":{\"660\":1}}],[\"其导数\",{\"1\":{\"660\":2}}],[\"其由七大主要部分构成\",{\"1\":{\"622\":1}}],[\"其计算量会随着维度的增加不仅需要更多的计算时间\",{\"1\":{\"587\":1}}],[\"其周期就越长\",{\"1\":{\"587\":1}}],[\"其掩码数量可能会偏少\",{\"1\":{\"581\":1}}],[\"其架构为\",{\"1\":{\"571\":1}}],[\"其预训练任务包括\",{\"1\":{\"560\":1}}],[\"其设计始终围绕推理效率目标\",{\"1\":{\"548\":1}}],[\"其特点在于仅使用公开可用的数据集进行训练\",{\"1\":{\"546\":1}}],[\"其特点如下\",{\"1\":{\"260\":1}}],[\"其任务形式和风格可能代表一类高频商业用途\",{\"1\":{\"539\":1}}],[\"其回答\",{\"1\":{\"538\":1}}],[\"其输出就是期望值\",{\"1\":{\"868\":1}}],[\"其输出也比175b的原始gpt\",{\"1\":{\"535\":1}}],[\"其输出支持密集特征图\",{\"1\":{\"196\":1}}],[\"其表现呈现出高度任务依赖性\",{\"1\":{\"530\":1}}],[\"其表现多次逼近甚至超越传统fine\",{\"1\":{\"529\":1}}],[\"其表达能力是有限的\",{\"1\":{\"321\":1}}],[\"其局限性\",{\"1\":{\"527\":1}}],[\"其优势包括\",{\"1\":{\"521\":1}}],[\"其关键特点是\",{\"1\":{\"521\":1}}],[\"其将结构化文本输入处理为单一的连续字符序列\",{\"1\":{\"507\":1}}],[\"其维度分别为\",{\"1\":{\"490\":1}}],[\"其目标是为图像中的每个像素分配一个特定的语义类别标签\",{\"1\":{\"465\":1}}],[\"其目标是让预训练语言模型\",{\"1\":{\"232\":1}}],[\"其曲线下面积\",{\"1\":{\"451\":1}}],[\"其数学定义为\",{\"1\":{\"443\":1,\"445\":1}}],[\"其在内存中列优先布局\",{\"1\":{\"422\":1}}],[\"其在内存中行优先布局\",{\"1\":{\"422\":1}}],[\"其在冻结骨干网络的前提下\",{\"1\":{\"201\":1}}],[\"其均能匹配到正确的文本标签\",{\"1\":{\"300\":1}}],[\"其规模与gpt\",{\"1\":{\"299\":1}}],[\"其主要改进包括\",{\"1\":{\"563\":1}}],[\"其主要用于\",{\"1\":{\"295\":1}}],[\"其主要功能是\",{\"1\":{\"101\":1}}],[\"其是首个使用patch\",{\"1\":{\"280\":1}}],[\"其实\",{\"1\":{\"882\":1}}],[\"其实是一个\",{\"1\":{\"881\":2}}],[\"其实等价于问\",{\"1\":{\"727\":1}}],[\"其实也就是按照拓扑排序的方式去遍历计算图\",{\"1\":{\"685\":1}}],[\"其实在某些训练集里\",{\"1\":{\"575\":1}}],[\"其实这本质上还是个分类问题\",{\"1\":{\"575\":1}}],[\"其实该过程中执行了n次推理过程\",{\"1\":{\"541\":1}}],[\"其实就得到了注意力掩码矩阵\",{\"1\":{\"463\":1}}],[\"其实就可以用在对比学习上\",{\"1\":{\"248\":1}}],[\"其实那些负样本很有可能是潜在的正样本\",{\"1\":{\"248\":1}}],[\"其实有一个很有意思的点\",{\"1\":{\"243\":1}}],[\"其次我们会调用\",{\"1\":{\"821\":1}}],[\"其次是准备训练数据\",{\"1\":{\"593\":1}}],[\"其次\",{\"1\":{\"246\":1,\"302\":1,\"487\":1,\"516\":1,\"524\":1}}],[\"其已有的知识\",{\"1\":{\"239\":1}}],[\"其开源的模型权重和研究方法为多模态ai发展提供了重要基准\",{\"1\":{\"230\":1}}],[\"其模块化设计\",{\"1\":{\"225\":1}}],[\"其参数量提升42倍\",{\"1\":{\"196\":1}}],[\"其核心挑战在于\",{\"1\":{\"766\":1}}],[\"其核心思想借鉴了bert的掩码语言建模任务\",{\"1\":{\"765\":1}}],[\"其核心思想是通过调整难易样本的权重\",{\"1\":{\"470\":1}}],[\"其核心思想是将每张图像通过视觉\",{\"1\":{\"167\":1}}],[\"其核心功能是保存和管理数据\",{\"1\":{\"636\":1}}],[\"其核心改进包括以下三点\",{\"1\":{\"215\":1}}],[\"其核心目标是将来自不同模态\",{\"1\":{\"59\":1}}],[\"其余设置为\",{\"1\":{\"820\":1}}],[\"其余位置仍为\",{\"1\":{\"818\":1}}],[\"其余位置设为\",{\"1\":{\"163\":1}}],[\"其余部分无论输出什么东西\",{\"1\":{\"572\":1}}],[\"其余部分不做损失\",{\"1\":{\"572\":1,\"581\":1}}],[\"其余部分共享\",{\"1\":{\"134\":1}}],[\"其余100万\",{\"1\":{\"248\":1}}],[\"其余的key离query远\",{\"1\":{\"246\":1}}],[\"其余的照片又分为了很多类别\",{\"1\":{\"243\":1}}],[\"其余参数冻结\",{\"1\":{\"239\":1}}],[\"其余参数保持冻结\",{\"1\":{\"10\":1}}],[\"其两大创新点\",{\"1\":{\"120\":1}}],[\"其他可推出的结论\",{\"1\":{\"729\":1}}],[\"其他运算符绑定\",{\"1\":{\"691\":1}}],[\"其他路径上的梯度信息将丢失\",{\"1\":{\"684\":1}}],[\"其他代码\",{\"1\":{\"664\":1,\"672\":1,\"673\":1}}],[\"其他下游任务\",{\"0\":{\"613\":1}}],[\"其他模型2tb\",{\"1\":{\"549\":1}}],[\"其他数据如wikipedia\",{\"1\":{\"548\":1}}],[\"其他全部相同\",{\"1\":{\"541\":1}}],[\"其他方向\",{\"0\":{\"479\":1}}],[\"其他方法使用的复杂组件\",{\"1\":{\"173\":1}}],[\"其他方法倾向于错误地预测为训练集中频繁出现的\",{\"1\":{\"23\":1}}],[\"其他位置必须\",{\"1\":{\"364\":1}}],[\"其他权重全部冻结\",{\"1\":{\"327\":1}}],[\"其他配置\",{\"1\":{\"272\":1}}],[\"其他视频里的帧是负样本\",{\"1\":{\"243\":1}}],[\"其他两类为单轮对话\",{\"1\":{\"235\":1}}],[\"其他语言任务表现较差\",{\"1\":{\"216\":1}}],[\"其他为0\",{\"1\":{\"161\":1}}],[\"其他开源许可网站\",{\"1\":{\"17\":1}}],[\"其图像数量是前者的三倍\",{\"1\":{\"17\":1}}],[\"其中变分自编码器\",{\"1\":{\"864\":1}}],[\"其中我们最常使用\",{\"1\":{\"821\":1}}],[\"其中前4维为词空间索引\",{\"1\":{\"814\":1}}],[\"其中当温度\",{\"1\":{\"808\":1}}],[\"其中第一项为阶段一\",{\"1\":{\"773\":1}}],[\"其中第三步通过反向传播全量更新模型参数的过程如下\",{\"1\":{\"490\":1}}],[\"其中词表\",{\"1\":{\"770\":1}}],[\"其中的概率和为\",{\"1\":{\"758\":1}}],[\"其中的layers就是transformer\",{\"1\":{\"324\":1}}],[\"其中每个图像\",{\"1\":{\"809\":1}}],[\"其中每个元素可以取\",{\"1\":{\"807\":1}}],[\"其中每个矩形的高表示相对计算量大小\",{\"1\":{\"282\":1}}],[\"其中每一个事件就是事件空间中的一个元素\",{\"1\":{\"727\":1}}],[\"其中一个备受关注的项目就是\",{\"1\":{\"712\":1}}],[\"其中一个类别出现的频率非常低\",{\"1\":{\"443\":1}}],[\"其中和是常数\",{\"1\":{\"697\":1}}],[\"其中训练数据使用1k\",{\"1\":{\"593\":1}}],[\"其中关于bertencoders编码并输出结果的整个过程如下图所示\",{\"1\":{\"580\":1}}],[\"其中4项任务\",{\"1\":{\"566\":1}}],[\"其中80\",{\"1\":{\"562\":1}}],[\"其中sst\",{\"1\":{\"515\":1}}],[\"其中single\",{\"1\":{\"283\":1}}],[\"其中秩\",{\"1\":{\"492\":1}}],[\"其中您感兴趣的罕见云彩类型\",{\"1\":{\"442\":1}}],[\"其中包含多个形状相同的\",{\"1\":{\"358\":1}}],[\"其中包括注意力可视化\",{\"1\":{\"325\":1}}],[\"其中包括两个理解任务和一个生成任务\",{\"1\":{\"127\":1}}],[\"其中0标志位表示word\",{\"1\":{\"284\":1}}],[\"其中word\",{\"1\":{\"284\":1}}],[\"其中region\",{\"1\":{\"283\":1}}],[\"其中有\",{\"1\":{\"265\":1}}],[\"其中基础图块大小为448×448\",{\"1\":{\"223\":1}}],[\"其中默认使用\",{\"1\":{\"131\":1}}],[\"其中额外添加的\",{\"1\":{\"126\":1}}],[\"其中\",{\"1\":{\"8\":2,\"14\":1,\"15\":1,\"28\":1,\"54\":1,\"64\":1,\"72\":2,\"73\":1,\"74\":1,\"82\":2,\"98\":1,\"105\":1,\"154\":1,\"155\":1,\"156\":1,\"157\":1,\"167\":2,\"178\":4,\"183\":1,\"215\":1,\"234\":1,\"235\":2,\"252\":1,\"263\":2,\"265\":1,\"297\":1,\"299\":1,\"318\":1,\"386\":1,\"389\":1,\"391\":2,\"399\":1,\"405\":1,\"427\":1,\"458\":1,\"459\":1,\"467\":1,\"468\":2,\"469\":1,\"470\":2,\"471\":1,\"473\":2,\"490\":1,\"492\":1,\"537\":1,\"560\":1,\"590\":2,\"691\":1,\"696\":1,\"704\":1,\"726\":1,\"727\":1,\"728\":1,\"729\":1,\"733\":1,\"737\":2,\"738\":3,\"739\":1,\"740\":1,\"741\":1,\"746\":1,\"748\":1,\"749\":1,\"752\":2,\"753\":1,\"756\":1,\"769\":1,\"771\":2,\"772\":3,\"773\":1,\"776\":1,\"795\":2,\"798\":1,\"799\":1,\"807\":1,\"816\":1,\"819\":1,\"826\":1,\"832\":1,\"836\":1,\"846\":1,\"854\":1,\"865\":1,\"866\":2,\"867\":1,\"868\":3,\"873\":2,\"874\":1,\"882\":1,\"885\":1}}],[\"5️⃣\",{\"1\":{\"885\":1}}],[\"5平均分刷新sota\",{\"1\":{\"566\":1}}],[\"5点\",{\"1\":{\"522\":1}}],[\"5b模型仍欠拟合\",{\"1\":{\"522\":1}}],[\"5b模型\",{\"1\":{\"522\":1}}],[\"5b参数模型在多数任务上逼近或超越监督基线\",{\"1\":{\"522\":1}}],[\"5b参数\",{\"1\":{\"522\":1}}],[\"5b\",{\"1\":{\"521\":2,\"704\":2}}],[\"5是五分类\",{\"1\":{\"515\":1}}],[\"5的情感极性区分的更细致\",{\"1\":{\"515\":1}}],[\"5的概率将文本对应的图片替换成不同的图片\",{\"1\":{\"285\":1}}],[\"5的开发基于internvit\",{\"1\":{\"223\":1}}],[\"5作为开源多模态大语言模型\",{\"1\":{\"230\":1}}],[\"5v\",{\"1\":{\"218\":1}}],[\"5版本模型具备了强大的鲁棒性\",{\"1\":{\"223\":1}}],[\"5版本\",{\"1\":{\"218\":1}}],[\"5在18个多模态基准测试中表现优异\",{\"1\":{\"216\":1}}],[\"5e\",{\"1\":{\"209\":1,\"514\":1,\"774\":1}}],[\"595\",{\"1\":{\"234\":1}}],[\"59\",{\"1\":{\"203\":1,\"704\":1}}],[\"5500\",{\"1\":{\"594\":2}}],[\"55\",{\"1\":{\"201\":1,\"455\":1}}],[\"558k\",{\"1\":{\"210\":1}}],[\"558\",{\"1\":{\"75\":1}}],[\"5×5\",{\"1\":{\"181\":1}}],[\"5376\",{\"1\":{\"692\":1}}],[\"53\",{\"1\":{\"83\":1,\"225\":1,\"235\":1,\"236\":1}}],[\"504\",{\"1\":{\"582\":1}}],[\"50k词汇表\",{\"1\":{\"562\":1}}],[\"50000\",{\"1\":{\"697\":1}}],[\"500k步时\",{\"1\":{\"565\":1}}],[\"500\",{\"1\":{\"83\":3}}],[\"50\",{\"1\":{\"83\":1,\"105\":1,\"173\":1,\"182\":1,\"186\":2,\"198\":1,\"208\":1,\"332\":1,\"451\":2,\"522\":1,\"578\":2,\"579\":3,\"704\":1,\"774\":2,\"818\":1}}],[\"51\",{\"1\":{\"758\":1}}],[\"516\",{\"1\":{\"65\":1}}],[\"512k\",{\"1\":{\"704\":1}}],[\"512\",{\"1\":{\"30\":6,\"34\":11,\"35\":19,\"36\":11,\"41\":1,\"46\":6,\"59\":32,\"93\":6,\"96\":5,\"99\":4,\"101\":1,\"107\":3,\"110\":3,\"111\":3,\"210\":1,\"514\":1,\"560\":1,\"561\":1,\"591\":1,\"793\":2,\"800\":2,\"821\":2,\"822\":4,\"840\":4,\"886\":1}}],[\"58\",{\"1\":{\"63\":2,\"65\":1,\"67\":1,\"201\":1,\"235\":1}}],[\"5400\",{\"1\":{\"703\":1}}],[\"540b的53\",{\"1\":{\"549\":1}}],[\"540b\",{\"1\":{\"549\":4,\"703\":1}}],[\"540b等顶尖模型表现相当\",{\"1\":{\"546\":1}}],[\"54\",{\"1\":{\"22\":1}}],[\"5250\",{\"1\":{\"582\":1}}],[\"52\",{\"1\":{\"22\":1,\"549\":1}}],[\"56\",{\"1\":{\"17\":1,\"20\":1,\"22\":1}}],[\"57\",{\"1\":{\"17\":1,\"549\":1}}],[\"5\",{\"0\":{\"22\":1,\"23\":1,\"24\":1,\"25\":1,\"66\":1,\"214\":1,\"293\":1,\"321\":1,\"838\":1,\"856\":1,\"860\":1},\"1\":{\"10\":1,\"17\":1,\"26\":1,\"28\":1,\"30\":1,\"35\":1,\"36\":1,\"40\":1,\"41\":1,\"45\":1,\"58\":1,\"59\":13,\"63\":1,\"76\":1,\"78\":3,\"80\":1,\"81\":1,\"82\":2,\"83\":2,\"96\":1,\"98\":1,\"101\":1,\"131\":1,\"145\":6,\"147\":1,\"159\":2,\"160\":1,\"161\":1,\"163\":3,\"169\":1,\"170\":3,\"181\":1,\"184\":1,\"186\":4,\"196\":1,\"201\":1,\"203\":2,\"204\":1,\"208\":1,\"209\":1,\"210\":1,\"215\":2,\"216\":1,\"220\":1,\"222\":1,\"223\":1,\"225\":1,\"227\":2,\"237\":1,\"255\":1,\"272\":4,\"273\":1,\"276\":2,\"277\":3,\"300\":1,\"301\":1,\"305\":1,\"312\":1,\"313\":1,\"316\":1,\"317\":19,\"322\":1,\"327\":1,\"332\":3,\"333\":3,\"336\":1,\"344\":1,\"355\":3,\"364\":3,\"369\":5,\"373\":2,\"374\":3,\"375\":1,\"377\":4,\"378\":1,\"385\":1,\"387\":4,\"399\":1,\"421\":2,\"422\":2,\"423\":3,\"425\":5,\"426\":7,\"428\":1,\"451\":2,\"453\":1,\"470\":3,\"471\":4,\"473\":4,\"476\":1,\"506\":1,\"507\":2,\"514\":2,\"515\":1,\"521\":1,\"522\":5,\"527\":1,\"528\":1,\"529\":3,\"530\":1,\"531\":1,\"537\":1,\"541\":1,\"544\":2,\"547\":2,\"548\":4,\"549\":4,\"550\":2,\"551\":1,\"559\":1,\"561\":2,\"580\":2,\"587\":1,\"590\":2,\"591\":7,\"593\":1,\"597\":1,\"647\":1,\"689\":1,\"704\":18,\"728\":1,\"731\":1,\"752\":1,\"780\":1,\"802\":2,\"803\":1,\"810\":1,\"814\":1,\"817\":1,\"818\":2,\"820\":1,\"821\":3,\"840\":3,\"848\":6,\"853\":3,\"854\":1,\"859\":1,\"867\":1,\"868\":2,\"869\":1,\"870\":1,\"872\":2,\"873\":1,\"878\":1}}],[\"e模型的文生图质量\",{\"1\":{\"822\":1}}],[\"echo\",{\"1\":{\"708\":1}}],[\"edge\",{\"1\":{\"696\":4}}],[\"e=3\",{\"1\":{\"575\":2}}],[\"efficient\",{\"1\":{\"483\":1,\"485\":1,\"488\":2,\"541\":17,\"545\":1}}],[\"efficientnet\",{\"1\":{\"395\":1}}],[\"eow\",{\"1\":{\"478\":3}}],[\"eol\",{\"1\":{\"477\":2,\"478\":3}}],[\"eos\",{\"1\":{\"143\":2,\"313\":1,\"541\":2,\"544\":2}}],[\"ee\",{\"1\":{\"476\":1}}],[\"estimator\",{\"1\":{\"795\":1,\"821\":1,\"881\":1,\"885\":2}}],[\"estimation\",{\"0\":{\"825\":1},\"1\":{\"248\":2}}],[\"escape\",{\"1\":{\"476\":1,\"478\":1}}],[\"e^\",{\"1\":{\"470\":1}}],[\"euclidean\",{\"0\":{\"457\":1}}],[\"einops\",{\"1\":{\"370\":2}}],[\"einstein\",{\"1\":{\"76\":1,\"255\":1,\"367\":1,\"370\":1}}],[\"einsum\",{\"0\":{\"367\":1},\"1\":{\"70\":1,\"76\":5,\"170\":1,\"255\":2,\"367\":4,\"590\":2,\"794\":2,\"821\":2,\"822\":2}}],[\"e5005f0a\",{\"1\":{\"327\":1}}],[\"equal\",{\"1\":{\"821\":1}}],[\"equals\",{\"1\":{\"632\":1}}],[\"equivariance\",{\"1\":{\"314\":1}}],[\"eq\",{\"1\":{\"145\":3,\"323\":1,\"584\":1}}],[\"et\",{\"0\":{\"590\":1},\"1\":{\"126\":5,\"127\":2,\"131\":4,\"521\":3,\"536\":17,\"537\":2,\"539\":2,\"548\":1,\"550\":1,\"552\":10}}],[\"eta\",{\"1\":{\"80\":1}}],[\"eye\",{\"1\":{\"108\":1}}],[\"epsilon\",{\"1\":{\"323\":1}}],[\"eps=config\",{\"1\":{\"292\":1,\"295\":1,\"597\":1,\"599\":1,\"606\":1,\"609\":1}}],[\"eps=1e\",{\"1\":{\"80\":1,\"160\":2,\"169\":1,\"170\":2,\"272\":1,\"323\":1,\"473\":1,\"652\":1,\"676\":1}}],[\"eps\",{\"1\":{\"169\":3,\"170\":4,\"292\":1,\"295\":1,\"473\":5,\"597\":1,\"599\":1,\"606\":1,\"609\":1,\"652\":3,\"853\":2,\"859\":2}}],[\"epochs=4\",{\"1\":{\"593\":1}}],[\"epochs=args\",{\"1\":{\"186\":1}}],[\"epochs\",{\"1\":{\"147\":1,\"186\":11,\"252\":1,\"273\":1,\"562\":1,\"581\":2,\"803\":1,\"840\":4,\"856\":2,\"885\":3}}],[\"epoch>0\",{\"1\":{\"145\":1,\"159\":1}}],[\"epoch+1\",{\"1\":{\"81\":1,\"848\":1,\"856\":1,\"860\":1,\"885\":1,\"886\":1}}],[\"epoch\",{\"1\":{\"10\":1,\"80\":1,\"81\":2,\"82\":2,\"83\":1,\"136\":2,\"142\":5,\"145\":4,\"147\":6,\"159\":3,\"179\":2,\"186\":10,\"252\":5,\"273\":10,\"323\":2,\"403\":1,\"537\":1,\"581\":4,\"774\":2,\"780\":3,\"803\":9,\"840\":4,\"848\":2,\"856\":2,\"857\":1,\"860\":2,\"885\":2,\"886\":2}}],[\"each\",{\"1\":{\"145\":2,\"147\":2,\"170\":1,\"478\":1,\"610\":1,\"628\":1,\"840\":1}}],[\"easy\",{\"1\":{\"78\":1,\"470\":1}}],[\"earphone\",{\"1\":{\"29\":1,\"58\":1,\"68\":1}}],[\"emerging\",{\"1\":{\"172\":2}}],[\"ema\",{\"0\":{\"169\":1},\"1\":{\"147\":2,\"160\":2,\"161\":1,\"167\":2,\"169\":5,\"170\":15,\"176\":1,\"178\":1,\"186\":8,\"885\":1}}],[\"employ\",{\"1\":{\"78\":1}}],[\"empty\",{\"1\":{\"68\":1,\"186\":1,\"815\":1}}],[\"emb=false\",{\"1\":{\"272\":1}}],[\"embed=true\",{\"1\":{\"272\":1}}],[\"embed\",{\"1\":{\"73\":7,\"76\":3,\"145\":7,\"146\":3,\"147\":7,\"160\":14,\"161\":2,\"169\":4,\"170\":20,\"186\":6,\"272\":31,\"276\":1,\"277\":2,\"299\":2,\"318\":9,\"319\":13,\"320\":15,\"322\":9,\"323\":17,\"327\":1,\"544\":6,\"623\":8,\"804\":12,\"817\":1}}],[\"embeds则拼接\",{\"1\":{\"311\":1}}],[\"embeds=query\",{\"1\":{\"309\":1,\"311\":1,\"312\":2,\"313\":1}}],[\"embeds=encoder\",{\"1\":{\"163\":1}}],[\"embeds=inputs\",{\"1\":{\"163\":1}}],[\"embeds=none\",{\"1\":{\"163\":2,\"276\":1,\"277\":1,\"311\":1,\"312\":1}}],[\"embeds=llm\",{\"1\":{\"40\":1}}],[\"embeds\",{\"1\":{\"40\":4,\"43\":10,\"142\":3,\"143\":5,\"145\":16,\"146\":4,\"147\":16,\"161\":10,\"162\":22,\"163\":4,\"276\":13,\"277\":12,\"309\":4,\"311\":16,\"312\":3,\"313\":6,\"544\":7,\"821\":6}}],[\"embedding相同维度\",{\"1\":{\"313\":1}}],[\"embedding计算出key和value\",{\"1\":{\"312\":1}}],[\"embedding送到二分类器中\",{\"1\":{\"311\":1}}],[\"embedding分别都嵌入了一个额外的可学习\",{\"1\":{\"284\":1}}],[\"embedding部分\",{\"1\":{\"284\":2}}],[\"embedding标志位来区分\",{\"1\":{\"284\":1}}],[\"embedding通过可学习的modal\",{\"1\":{\"284\":1}}],[\"embedding和visual\",{\"1\":{\"284\":2}}],[\"embedding和modality\",{\"1\":{\"282\":1}}],[\"embedding进行concate\",{\"1\":{\"284\":2}}],[\"embedding进行相加\",{\"1\":{\"284\":2}}],[\"embedding是现有vlp模型的瓶颈\",{\"1\":{\"283\":1}}],[\"embedding存在着差异\",{\"1\":{\"283\":1}}],[\"embedding基本上都使用类bert结构\",{\"1\":{\"283\":1}}],[\"embedding的方法总共有三大类\",{\"1\":{\"283\":1}}],[\"embedding的方法\",{\"1\":{\"280\":1,\"283\":1}}],[\"embeddingema\",{\"1\":{\"169\":1,\"170\":4}}],[\"embeddings=512\",{\"1\":{\"885\":1,\"886\":2}}],[\"embeddings前面\",{\"1\":{\"313\":1}}],[\"embeddings和query\",{\"1\":{\"311\":1}}],[\"embeddings\",{\"1\":{\"40\":1,\"43\":1,\"76\":2,\"143\":1,\"145\":2,\"147\":2,\"162\":2,\"163\":1,\"276\":4,\"277\":4,\"289\":1,\"294\":1,\"302\":12,\"303\":4,\"304\":15,\"309\":3,\"311\":17,\"580\":1,\"597\":23,\"601\":1,\"602\":2,\"610\":1,\"612\":1,\"804\":1,\"885\":8,\"886\":5}}],[\"embedding\",{\"1\":{\"35\":1,\"40\":1,\"43\":1,\"45\":1,\"46\":1,\"76\":1,\"169\":2,\"170\":16,\"179\":1,\"186\":1,\"263\":2,\"272\":16,\"276\":5,\"277\":10,\"282\":3,\"284\":4,\"289\":2,\"302\":4,\"303\":1,\"304\":3,\"311\":1,\"312\":1,\"318\":1,\"320\":1,\"573\":5,\"580\":3,\"590\":5,\"591\":4,\"597\":3,\"602\":2,\"704\":1,\"713\":1,\"793\":1,\"795\":1,\"804\":4,\"814\":6,\"815\":7,\"821\":3,\"822\":12,\"878\":1,\"885\":13,\"886\":1}}],[\"emb\",{\"1\":{\"30\":1,\"34\":6,\"35\":12,\"36\":16,\"41\":14,\"42\":4,\"44\":2,\"45\":20,\"46\":14,\"59\":41,\"70\":3,\"80\":2,\"83\":2,\"272\":3,\"303\":2,\"304\":2,\"580\":1,\"590\":5,\"814\":13,\"815\":8,\"820\":2,\"822\":15}}],[\"events\",{\"1\":{\"730\":1}}],[\"every\",{\"1\":{\"159\":1,\"316\":5,\"478\":1,\"803\":1}}],[\"eva\",{\"1\":{\"191\":1,\"201\":1,\"395\":1}}],[\"evaluation\",{\"1\":{\"537\":1,\"820\":1}}],[\"evaluating\",{\"1\":{\"82\":1}}],[\"evaluate\",{\"1\":{\"82\":1,\"581\":1}}],[\"eval\",{\"1\":{\"28\":1,\"82\":1,\"83\":1,\"273\":3,\"274\":3,\"541\":1,\"544\":1,\"593\":2,\"817\":2,\"820\":1,\"821\":2,\"848\":1,\"857\":1,\"861\":1,\"886\":2}}],[\"ev\",{\"1\":{\"45\":2}}],[\"ek\",{\"1\":{\"45\":2}}],[\"e\",{\"0\":{\"805\":1,\"812\":1},\"1\":{\"40\":1,\"45\":7,\"59\":10,\"147\":10,\"297\":3,\"299\":6,\"302\":4,\"303\":2,\"304\":6,\"476\":5,\"537\":2,\"575\":2,\"696\":1,\"762\":2,\"789\":1,\"792\":1,\"794\":1,\"802\":5,\"803\":1,\"805\":2,\"812\":2,\"813\":2,\"814\":1,\"815\":4,\"816\":1,\"817\":1,\"820\":2,\"821\":3,\"881\":2,\"885\":2,\"886\":2}}],[\"exit\",{\"1\":{\"803\":1}}],[\"exist\",{\"1\":{\"303\":1,\"304\":1,\"316\":1,\"577\":2,\"840\":2}}],[\"exists\",{\"1\":{\"302\":1,\"303\":1,\"304\":2,\"316\":1,\"578\":1,\"581\":1,\"696\":1,\"815\":5,\"816\":1,\"817\":2,\"822\":1}}],[\"exact=16\",{\"1\":{\"591\":1}}],[\"exact\",{\"1\":{\"591\":9}}],[\"examples\",{\"1\":{\"78\":2,\"278\":1,\"470\":2}}],[\"exchange\",{\"1\":{\"548\":1}}],[\"exception\",{\"1\":{\"302\":2,\"303\":1,\"304\":3}}],[\"except\",{\"1\":{\"302\":2,\"303\":1,\"304\":3,\"336\":2,\"696\":1,\"885\":1,\"886\":1}}],[\"extend\",{\"1\":{\"577\":1}}],[\"extended\",{\"1\":{\"289\":1,\"312\":1,\"602\":6}}],[\"extension\",{\"1\":{\"302\":2,\"304\":2,\"696\":3}}],[\"extract\",{\"1\":{\"29\":2,\"58\":1}}],[\"export\",{\"1\":{\"593\":1}}],[\"exponential\",{\"1\":{\"157\":1,\"170\":1}}],[\"exp\",{\"1\":{\"277\":2,\"299\":1,\"470\":6,\"647\":5,\"671\":2,\"801\":1,\"822\":1,\"853\":3,\"854\":1,\"859\":1}}],[\"experimental\",{\"1\":{\"536\":1}}],[\"experiments\",{\"0\":{\"130\":1},\"1\":{\"129\":1}}],[\"experts\",{\"0\":{\"272\":1},\"1\":{\"259\":2,\"260\":1,\"264\":2,\"269\":1,\"270\":1}}],[\"expansion\",{\"1\":{\"73\":4}}],[\"expanduser\",{\"1\":{\"696\":1}}],[\"expanded\",{\"1\":{\"364\":1}}],[\"expand\",{\"0\":{\"364\":1},\"1\":{\"46\":1,\"59\":1,\"272\":1,\"309\":1,\"311\":1,\"313\":1,\"319\":1,\"320\":1,\"323\":1,\"362\":1,\"364\":8,\"580\":1,\"584\":1,\"597\":1,\"804\":2}}],[\"explain\",{\"1\":{\"28\":2}}],[\"entire\",{\"1\":{\"605\":1}}],[\"entropy\",{\"0\":{\"832\":1},\"1\":{\"78\":1,\"145\":1,\"147\":1,\"162\":1,\"163\":1,\"265\":1,\"276\":1,\"277\":4,\"278\":1,\"299\":3,\"310\":2,\"311\":1,\"468\":5,\"470\":4,\"473\":2,\"538\":1,\"815\":5,\"822\":3,\"854\":4}}],[\"enginnering\",{\"1\":{\"716\":1}}],[\"engineering技巧的时候\",{\"1\":{\"501\":1}}],[\"engineering技术\",{\"1\":{\"142\":1}}],[\"engineering呢\",{\"1\":{\"497\":1}}],[\"engineering的技巧\",{\"1\":{\"501\":1,\"502\":1}}],[\"engineering的原因\",{\"1\":{\"497\":1}}],[\"engineering的实践表明\",{\"1\":{\"486\":1}}],[\"engineering的效果达不到要求\",{\"1\":{\"482\":1}}],[\"engineering的方式\",{\"1\":{\"482\":1}}],[\"engineering的方式是一种相对来说容易上手的使用大模型的方式\",{\"1\":{\"482\":1}}],[\"engineering\",{\"0\":{\"496\":1,\"497\":1},\"1\":{\"301\":1,\"482\":1,\"496\":1,\"497\":1,\"500\":1,\"716\":3,\"717\":4}}],[\"english\",{\"1\":{\"521\":3}}],[\"environments\",{\"1\":{\"434\":1}}],[\"envs\",{\"1\":{\"434\":3}}],[\"env\",{\"1\":{\"434\":1,\"435\":1}}],[\"ensemble\",{\"0\":{\"236\":1},\"1\":{\"236\":1}}],[\"ensure\",{\"1\":{\"63\":1,\"476\":3,\"478\":3,\"577\":2}}],[\"en\",{\"1\":{\"198\":1,\"202\":1,\"225\":1}}],[\"endpoint\",{\"1\":{\"332\":1}}],[\"end\",{\"1\":{\"186\":4,\"233\":2,\"273\":13,\"302\":4,\"304\":4,\"478\":1,\"614\":12,\"615\":14,\"616\":5}}],[\"enables\",{\"1\":{\"503\":1}}],[\"enable\",{\"1\":{\"170\":1,\"688\":5}}],[\"enclosing\",{\"1\":{\"336\":2}}],[\"enc\",{\"1\":{\"145\":1,\"147\":1,\"580\":2,\"793\":8,\"821\":18,\"822\":9}}],[\"encoded\",{\"1\":{\"247\":1,\"594\":7}}],[\"encode\",{\"1\":{\"126\":1,\"300\":2,\"541\":1,\"544\":1,\"578\":3,\"623\":2,\"820\":1,\"853\":2,\"859\":2}}],[\"encoder输入\",{\"1\":{\"802\":1}}],[\"encoder输出结果之后\",{\"1\":{\"323\":1}}],[\"encoder输出的embeddings里提取与input\",{\"1\":{\"309\":1}}],[\"encoder模型结构图\",{\"1\":{\"628\":1}}],[\"encoderdecoder\",{\"1\":{\"623\":2}}],[\"encoderdecoder模型结构图\",{\"1\":{\"623\":1}}],[\"encoder中mlp\",{\"1\":{\"324\":1}}],[\"encoder中重复堆叠encoder\",{\"1\":{\"324\":1}}],[\"encoder的结构\",{\"1\":{\"321\":1}}],[\"encoderlayer模型结构图\",{\"1\":{\"627\":1}}],[\"encoderlayer\",{\"0\":{\"627\":1},\"1\":{\"312\":1,\"580\":1,\"627\":2}}],[\"encoder提取的图像embeddings\",{\"1\":{\"309\":1}}],[\"encoder提取图像特征\",{\"1\":{\"300\":1}}],[\"encoder引到vision\",{\"1\":{\"308\":1}}],[\"encoder不参与梯度运算\",{\"1\":{\"254\":1}}],[\"encoder进行初始化\",{\"1\":{\"254\":1}}],[\"encoder参数使用query\",{\"1\":{\"254\":1}}],[\"encoders\",{\"1\":{\"254\":1,\"580\":2}}],[\"encoder2\",{\"1\":{\"30\":1}}],[\"encoder\",{\"0\":{\"126\":1,\"321\":1,\"623\":1,\"625\":1,\"628\":1},\"1\":{\"30\":3,\"35\":3,\"40\":2,\"46\":3,\"59\":5,\"70\":1,\"80\":2,\"99\":1,\"120\":1,\"126\":4,\"127\":2,\"138\":1,\"142\":5,\"143\":4,\"145\":24,\"146\":7,\"147\":26,\"160\":13,\"161\":5,\"162\":15,\"163\":17,\"167\":1,\"169\":1,\"173\":1,\"175\":1,\"254\":8,\"255\":4,\"256\":5,\"260\":2,\"261\":2,\"262\":2,\"269\":2,\"276\":1,\"277\":1,\"282\":1,\"289\":5,\"290\":5,\"291\":4,\"292\":4,\"293\":6,\"294\":2,\"295\":4,\"299\":8,\"300\":4,\"307\":2,\"309\":4,\"311\":2,\"312\":20,\"313\":5,\"319\":1,\"571\":3,\"602\":2,\"616\":3,\"622\":2,\"623\":4,\"628\":3,\"765\":1,\"790\":1,\"792\":1,\"793\":2,\"794\":1,\"798\":2,\"802\":3,\"821\":2,\"867\":1,\"875\":1,\"885\":8,\"886\":1}}],[\"encoding=\",{\"1\":{\"476\":4,\"477\":1,\"478\":7,\"577\":3,\"578\":1}}],[\"encodings\",{\"1\":{\"170\":4}}],[\"encoding\",{\"0\":{\"13\":1,\"586\":1,\"587\":1,\"589\":1},\"1\":{\"70\":3,\"170\":5,\"475\":1,\"521\":1,\"562\":1,\"587\":1,\"588\":1,\"622\":1,\"772\":1,\"885\":7}}],[\"enqueue\",{\"0\":{\"257\":1},\"1\":{\"145\":1,\"147\":1,\"161\":1,\"255\":2,\"257\":2}}],[\"enrichment\",{\"1\":{\"63\":1}}],[\"enhance\",{\"1\":{\"41\":6,\"59\":4}}],[\"enumerate\",{\"1\":{\"29\":1,\"68\":2,\"81\":1,\"82\":1,\"83\":1,\"92\":1,\"96\":1,\"100\":1,\"159\":1,\"186\":3,\"252\":1,\"276\":1,\"277\":2,\"302\":1,\"304\":1,\"316\":2,\"323\":1,\"544\":1,\"578\":2,\"579\":1,\"581\":1,\"600\":1,\"803\":1,\"840\":1,\"848\":1,\"856\":1}}],[\"elb\",{\"1\":{\"807\":1,\"808\":6,\"809\":1}}],[\"elbo\",{\"1\":{\"773\":1,\"807\":5,\"854\":1,\"869\":1}}],[\"ele\",{\"1\":{\"581\":4}}],[\"element\",{\"1\":{\"427\":1}}],[\"elements\",{\"1\":{\"401\":2}}],[\"elmo\",{\"1\":{\"514\":1,\"515\":1,\"531\":1}}],[\"elicits\",{\"1\":{\"501\":1}}],[\"elif\",{\"1\":{\"146\":1,\"272\":1,\"274\":2,\"312\":1,\"336\":1,\"544\":1,\"578\":1,\"802\":1,\"848\":1}}],[\"eldan\",{\"1\":{\"385\":1}}],[\"ellipsis\",{\"0\":{\"355\":1},\"1\":{\"355\":1}}],[\"else\",{\"1\":{\"29\":5,\"40\":2,\"43\":1,\"58\":4,\"68\":3,\"72\":2,\"74\":2,\"82\":1,\"83\":1,\"92\":4,\"93\":2,\"96\":3,\"100\":2,\"109\":2,\"143\":1,\"145\":2,\"159\":1,\"162\":1,\"163\":2,\"169\":2,\"170\":2,\"272\":9,\"274\":5,\"276\":2,\"277\":3,\"278\":1,\"289\":1,\"293\":1,\"295\":1,\"302\":1,\"303\":1,\"304\":2,\"311\":2,\"312\":4,\"313\":1,\"316\":1,\"318\":1,\"321\":1,\"323\":1,\"327\":2,\"336\":1,\"477\":3,\"478\":4,\"544\":4,\"578\":4,\"594\":2,\"596\":1,\"599\":1,\"603\":1,\"609\":1,\"617\":1,\"618\":3,\"681\":1,\"684\":1,\"686\":2,\"688\":2,\"696\":1,\"793\":1,\"794\":1,\"801\":2,\"802\":1,\"804\":2,\"814\":3,\"816\":1,\"817\":2,\"820\":1,\"821\":2,\"822\":1,\"840\":2,\"848\":2,\"856\":1,\"860\":1,\"885\":1,\"886\":1}}],[\"elowen\",{\"0\":{\"3\":1}}],[\"error\",{\"1\":{\"22\":1,\"82\":4,\"302\":2,\"303\":1,\"304\":3}}],[\"个向量每个向量的距离\",{\"1\":{\"880\":1}}],[\"个向量作为初始中心\",{\"1\":{\"170\":2}}],[\"个后的生成样本效果\",{\"1\":{\"857\":1}}],[\"个灰度级来描述图像\",{\"1\":{\"847\":1}}],[\"个离散的概率分布\",{\"1\":{\"847\":1}}],[\"个子像素\",{\"1\":{\"846\":1}}],[\"个经过\",{\"1\":{\"843\":1}}],[\"个像素点\",{\"1\":{\"854\":1}}],[\"个像素之后的信息\",{\"1\":{\"843\":1}}],[\"个像素及后续像素的信息\",{\"1\":{\"843\":1}}],[\"个像素只能看到前\",{\"1\":{\"843\":1}}],[\"个像素取某种颜色的概率的数组\",{\"1\":{\"843\":1}}],[\"个像素\",{\"1\":{\"843\":2}}],[\"个像素的信息\",{\"1\":{\"843\":1}}],[\"个像素的真值和预测的概率分布求交叉熵损失函数\",{\"1\":{\"843\":1}}],[\"个像素的概率分布\",{\"1\":{\"843\":2}}],[\"个像素输出第\",{\"1\":{\"843\":1}}],[\"个数\",{\"1\":{\"821\":1}}],[\"个数字\",{\"1\":{\"423\":1}}],[\"个码本向量的均匀分类分布\",{\"1\":{\"808\":1}}],[\"个视觉\",{\"1\":{\"772\":1}}],[\"个字母进行排列\",{\"1\":{\"762\":1}}],[\"个也彼此相同\",{\"1\":{\"762\":1}}],[\"个彼此相同\",{\"1\":{\"762\":1}}],[\"个不同的元素中取\",{\"1\":{\"763\":1}}],[\"个不同的元素\",{\"1\":{\"762\":1}}],[\"个实验一共有\",{\"1\":{\"761\":1}}],[\"个实验\",{\"1\":{\"761\":1}}],[\"个自由参数\",{\"1\":{\"752\":2}}],[\"个是蓝球\",{\"1\":{\"740\":1}}],[\"个是红球\",{\"1\":{\"740\":1}}],[\"个球中蓝球的数量\",{\"1\":{\"740\":1}}],[\"个球\",{\"1\":{\"740\":2}}],[\"个的组合数\",{\"1\":{\"737\":1}}],[\"个性化大模型应用需要有个性化数据库进行支撑\",{\"1\":{\"717\":1}}],[\"个集成\",{\"1\":{\"714\":1}}],[\"个核心组件组成\",{\"1\":{\"713\":1}}],[\"个月的最快记录\",{\"1\":{\"704\":1}}],[\"个步骤\",{\"1\":{\"680\":1,\"695\":1,\"700\":1}}],[\"个选项\",{\"1\":{\"618\":1}}],[\"个选项中选择正确答案\",{\"1\":{\"561\":1}}],[\"个位置向量第\",{\"1\":{\"587\":1}}],[\"个位置\",{\"1\":{\"587\":1}}],[\"个词之间\",{\"1\":{\"616\":1}}],[\"个词\",{\"1\":{\"575\":1}}],[\"个词到第\",{\"1\":{\"575\":1}}],[\"个人理解是因为\",{\"1\":{\"575\":1}}],[\"个人对上述内容的理解\",{\"1\":{\"385\":1}}],[\"个句子相接\",{\"1\":{\"571\":1}}],[\"个句子在原始本文中是否跟第\",{\"1\":{\"571\":1}}],[\"个英语语料库\",{\"1\":{\"561\":1}}],[\"个响应\",{\"1\":{\"537\":1}}],[\"个注意力头\",{\"1\":{\"514\":1}}],[\"个序列表示\",{\"1\":{\"512\":1}}],[\"个示例\",{\"1\":{\"445\":1,\"446\":1}}],[\"个通道\",{\"1\":{\"423\":1}}],[\"个角的中间位置\",{\"1\":{\"387\":1}}],[\"个神经元才能达到相同效果\",{\"1\":{\"385\":1}}],[\"个线性区域的函数\",{\"1\":{\"385\":1}}],[\"个分段\",{\"1\":{\"385\":1}}],[\"个分布尽可能均匀的采样点索引\",{\"1\":{\"92\":1}}],[\"个元素彼此相同\",{\"1\":{\"762\":1}}],[\"个元素的向量\",{\"1\":{\"758\":1}}],[\"个元素中选出\",{\"1\":{\"737\":1}}],[\"个元素及其频数\",{\"1\":{\"401\":1}}],[\"个元素\",{\"1\":{\"355\":1,\"423\":6,\"427\":1,\"762\":1}}],[\"个元素作为输入图像\",{\"1\":{\"277\":1}}],[\"个等间隔数\",{\"1\":{\"332\":1}}],[\"个类别和\",{\"1\":{\"327\":1}}],[\"个可能的取值\",{\"1\":{\"758\":1}}],[\"个可能取值的离散随机变量\",{\"1\":{\"733\":1}}],[\"个可能配对中识别正确配对\",{\"1\":{\"265\":1}}],[\"个可训练参数\",{\"1\":{\"324\":2}}],[\"个图像\",{\"1\":{\"265\":1,\"771\":1,\"772\":1,\"776\":1,\"807\":1,\"817\":1}}],[\"个图文对\",{\"1\":{\"162\":1}}],[\"个图文表示\",{\"1\":{\"154\":1}}],[\"个用新的编码器做一个编码\",{\"1\":{\"250\":1}}],[\"个样本进行重排序的策略\",{\"1\":{\"811\":1}}],[\"个样本特征\",{\"1\":{\"398\":1}}],[\"个样本对应第\",{\"1\":{\"277\":1}}],[\"个样本\",{\"1\":{\"249\":1,\"399\":3}}],[\"个下游任务\",{\"1\":{\"245\":1}}],[\"个多模态基准测试中表现优异\",{\"1\":{\"215\":1}}],[\"个裁剪\",{\"1\":{\"186\":1}}],[\"个局部\",{\"1\":{\"186\":2}}],[\"个局部裁剪\",{\"1\":{\"186\":1}}],[\"个全局\",{\"1\":{\"186\":2}}],[\"个全局裁剪\",{\"1\":{\"186\":3}}],[\"个来自不同视角下的批次图像\",{\"1\":{\"186\":1}}],[\"个最近邻\",{\"1\":{\"179\":1}}],[\"个最近邻点索引\",{\"1\":{\"100\":1}}],[\"个为负样本\",{\"1\":{\"162\":1}}],[\"个为正样本\",{\"1\":{\"162\":1}}],[\"个负样本和一个正样本\",{\"1\":{\"248\":1}}],[\"个负样本\",{\"1\":{\"162\":2,\"265\":1}}],[\"个正样本\",{\"1\":{\"162\":2,\"277\":1}}],[\"个历史负样本\",{\"1\":{\"161\":1}}],[\"个输出\",{\"1\":{\"107\":1}}],[\"个坐标值\",{\"1\":{\"107\":1}}],[\"个邻近点的特征\",{\"1\":{\"100\":1}}],[\"个邻近点\",{\"1\":{\"100\":1}}],[\"个关键点作为局部区域中心\",{\"1\":{\"96\":1}}],[\"个关键点对应的全局区域特征向量\",{\"1\":{\"93\":1}}],[\"个关键点对应的局部区域特征向量\",{\"1\":{\"93\":2}}],[\"个关键点的坐标\",{\"1\":{\"93\":3}}],[\"个维度\",{\"1\":{\"92\":1}}],[\"个具有代表性的点\",{\"1\":{\"92\":1}}],[\"个定制化问题\",{\"1\":{\"67\":1}}],[\"个专家设计的问题\",{\"1\":{\"63\":1,\"65\":1}}],[\"个问题\",{\"1\":{\"63\":1}}],[\"个代表性问题\",{\"1\":{\"63\":1}}],[\"个同类别点云\",{\"1\":{\"29\":1}}],[\"个点的值按这个比例加起来\",{\"1\":{\"387\":1}}],[\"个点的子集决定\",{\"1\":{\"112\":1}}],[\"个点云\",{\"1\":{\"65\":1,\"69\":1}}],[\"个点\",{\"1\":{\"18\":1,\"67\":1,\"92\":2,\"100\":3}}],[\"个\",{\"1\":{\"10\":1,\"161\":2,\"167\":2,\"179\":3,\"199\":1,\"215\":1,\"263\":1,\"537\":1,\"763\":1,\"769\":1,\"772\":1,\"774\":4,\"800\":2,\"801\":2,\"807\":1,\"809\":3,\"815\":1,\"817\":3,\"818\":1,\"820\":1,\"857\":1}}],[\"t=1\",{\"1\":{\"811\":1}}],[\"twitter\",{\"1\":{\"816\":1}}],[\"twins\",{\"1\":{\"784\":1}}],[\"twocropstransform\",{\"1\":{\"252\":3}}],[\"two\",{\"1\":{\"28\":2,\"252\":1,\"308\":2,\"314\":1,\"594\":1}}],[\"tmp\",{\"1\":{\"696\":5}}],[\"t指定输出格式\",{\"1\":{\"696\":1}}],[\"tying\",{\"1\":{\"580\":1}}],[\"typical\",{\"1\":{\"753\":1}}],[\"typing\",{\"1\":{\"478\":1}}],[\"types\",{\"1\":{\"814\":3}}],[\"typeerror\",{\"1\":{\"673\":1,\"686\":1,\"689\":1}}],[\"type=args\",{\"1\":{\"803\":1}}],[\"type=bert\",{\"1\":{\"593\":1}}],[\"type=\",{\"1\":{\"276\":1,\"277\":4}}],[\"type=none\",{\"1\":{\"272\":1}}],[\"type=int\",{\"1\":{\"186\":1,\"840\":7}}],[\"type=float\",{\"1\":{\"186\":2,\"840\":3}}],[\"type==\",{\"1\":{\"29\":1,\"58\":1}}],[\"type\",{\"1\":{\"28\":2,\"29\":8,\"58\":9,\"68\":1,\"163\":3,\"170\":1,\"272\":4,\"276\":7,\"277\":8,\"284\":3,\"311\":1,\"594\":9,\"596\":4,\"597\":9,\"602\":3,\"603\":3,\"612\":3,\"614\":2,\"615\":3,\"616\":1,\"617\":3,\"618\":7,\"673\":1,\"686\":1,\"689\":1,\"802\":2,\"803\":1,\"804\":1,\"840\":1,\"848\":6,\"886\":5}}],[\"tgz\",{\"1\":{\"577\":2}}],[\"tgt2\",{\"1\":{\"76\":6}}],[\"tgt\",{\"1\":{\"70\":1,\"76\":21,\"623\":12,\"630\":2,\"631\":2}}],[\"t0++\",{\"1\":{\"536\":1}}],[\"t0\",{\"1\":{\"536\":1}}],[\"tl\",{\"1\":{\"521\":1,\"522\":1}}],[\"tlr\",{\"1\":{\"80\":1}}],[\"tqdm\",{\"1\":{\"476\":1,\"478\":3}}],[\"tverskyloss\",{\"1\":{\"471\":2}}],[\"tversky指数简化为dice系数\",{\"1\":{\"471\":1}}],[\"tversky\",{\"0\":{\"471\":1},\"1\":{\"471\":9,\"473\":1}}],[\"tnews\",{\"1\":{\"593\":4}}],[\"tn\",{\"1\":{\"442\":3,\"443\":1}}],[\"tpu\",{\"1\":{\"705\":1}}],[\"tp+α⋅fp+β⋅fn\",{\"1\":{\"471\":1}}],[\"tp\",{\"1\":{\"442\":3,\"443\":1,\"469\":1,\"471\":6}}],[\"tpr\",{\"1\":{\"82\":1,\"444\":2,\"450\":3,\"453\":3}}],[\"tf\",{\"1\":{\"392\":1,\"593\":2}}],[\"t2q\",{\"1\":{\"310\":2}}],[\"t2i\",{\"1\":{\"145\":13,\"147\":12,\"161\":8,\"162\":4,\"275\":1,\"277\":10,\"278\":6,\"310\":4,\"311\":5}}],[\"tinypytorch计算图转换为dot语言\",{\"1\":{\"696\":1}}],[\"tinypytorch采用define\",{\"1\":{\"692\":1}}],[\"tinypytorch的动态计算图模式使其在易用性和灵活性上表现突出\",{\"1\":{\"692\":1}}],[\"tinypytorch的核心能力总结\",{\"1\":{\"692\":1}}],[\"tinypytorch的计算图需要动态构建和销毁\",{\"1\":{\"687\":1}}],[\"tinypytorch框架能自动处理复杂表达式的微分\",{\"1\":{\"692\":1}}],[\"tinypytorch框架实现了完整的运算符重载体系\",{\"1\":{\"690\":1}}],[\"tinypytorch当前的反向传播会保留所有变量的导数\",{\"1\":{\"688\":1}}],[\"tinypytorch中的循环引用\",{\"1\":{\"687\":1}}],[\"tinypytorch尽量用最少的代码实现了现代深度学习框架的功能\",{\"1\":{\"634\":1}}],[\"tinypytorch\",{\"0\":{\"701\":1},\"1\":{\"633\":2,\"634\":1,\"679\":2,\"680\":2,\"691\":1,\"694\":2,\"695\":2,\"699\":2,\"700\":1}}],[\"tinybert\",{\"1\":{\"570\":2}}],[\"tie\",{\"1\":{\"580\":1}}],[\"title\",{\"1\":{\"303\":1,\"304\":1,\"316\":1,\"697\":1,\"857\":2}}],[\"timing\",{\"1\":{\"353\":1}}],[\"time\",{\"1\":{\"302\":10,\"304\":10,\"353\":5,\"544\":1,\"703\":1}}],[\"timm\",{\"0\":{\"395\":1},\"1\":{\"272\":1,\"395\":8,\"396\":3}}],[\"t5策略\",{\"1\":{\"591\":1}}],[\"t5relativepositionbias\",{\"1\":{\"591\":1}}],[\"t5\",{\"0\":{\"591\":1},\"1\":{\"232\":1,\"239\":1,\"531\":2,\"552\":1,\"591\":9,\"616\":1}}],[\"tau\",{\"1\":{\"795\":1,\"796\":1,\"821\":1}}],[\"tau=temp\",{\"1\":{\"794\":1,\"795\":1,\"796\":1}}],[\"taking\",{\"1\":{\"601\":1}}],[\"takes\",{\"1\":{\"478\":1}}],[\"taken\",{\"1\":{\"302\":2,\"304\":1,\"605\":1}}],[\"take\",{\"1\":{\"252\":1,\"605\":1,\"623\":1,\"632\":1}}],[\"tax\",{\"1\":{\"536\":1,\"537\":1,\"538\":2,\"539\":1}}],[\"tag\",{\"1\":{\"508\":1}}],[\"tage\",{\"1\":{\"309\":1}}],[\"tabby\",{\"1\":{\"300\":1}}],[\"table\",{\"1\":{\"29\":1,\"58\":1,\"68\":1,\"82\":2,\"274\":1,\"561\":1,\"590\":1,\"591\":6}}],[\"tanhdecay\",{\"1\":{\"395\":1}}],[\"tanh\",{\"1\":{\"289\":1,\"323\":2,\"601\":1,\"695\":1,\"840\":1}}],[\"tao\",{\"1\":{\"248\":1}}],[\"task\",{\"0\":{\"243\":1,\"574\":1,\"786\":1},\"1\":{\"275\":2,\"515\":1,\"521\":2,\"527\":1,\"582\":2,\"593\":1,\"594\":1}}],[\"tasks\",{\"1\":{\"171\":2,\"187\":1,\"268\":1,\"275\":9,\"278\":1,\"537\":1}}],[\"tails\",{\"1\":{\"749\":1}}],[\"tail\",{\"1\":{\"83\":1}}],[\"target=labels\",{\"1\":{\"803\":1}}],[\"target=false\",{\"1\":{\"799\":2}}],[\"target=true\",{\"1\":{\"794\":1,\"798\":1,\"799\":1}}],[\"targets=none\",{\"1\":{\"163\":1}}],[\"targets=labels\",{\"1\":{\"163\":1}}],[\"targets\",{\"1\":{\"81\":1,\"82\":11,\"142\":3,\"145\":8,\"147\":10,\"157\":1,\"161\":9,\"163\":5,\"255\":1,\"310\":3,\"467\":7,\"468\":11,\"469\":7,\"470\":7,\"471\":7,\"473\":8}}],[\"target\",{\"0\":{\"799\":1},\"1\":{\"78\":8,\"145\":2,\"147\":4,\"157\":1,\"163\":1,\"252\":2,\"469\":1,\"470\":1,\"579\":2,\"623\":1,\"799\":2,\"801\":6,\"821\":1,\"848\":4,\"886\":3}}],[\"t×d\",{\"1\":{\"72\":1}}],[\"tutorial\",{\"0\":{\"863\":1},\"1\":{\"863\":2}}],[\"turbo\",{\"1\":{\"704\":1}}],[\"turn\",{\"1\":{\"628\":1}}],[\"tuned\",{\"1\":{\"554\":1}}],[\"tuned模型\",{\"1\":{\"529\":3}}],[\"tuned大型模型表现\",{\"1\":{\"529\":1}}],[\"tuned方法的能力\",{\"1\":{\"528\":1}}],[\"tune\",{\"1\":{\"232\":1}}],[\"tuning完全不相同的另一条技术路线\",{\"1\":{\"487\":1}}],[\"tuning和prefix\",{\"1\":{\"487\":1}}],[\"tuning也保证了基座模型本身是没有变的\",{\"1\":{\"486\":1}}],[\"tuning是在transformer的encoder和decoder的网络中都加了一些特定的前缀\",{\"1\":{\"486\":1}}],[\"tuning是在embedding环节\",{\"1\":{\"486\":1}}],[\"tuning是发生在embedding这个环节的\",{\"1\":{\"485\":1}}],[\"tuning就是在保证函数本身不变的前提下\",{\"1\":{\"485\":1}}],[\"tuning的是类似的\",{\"1\":{\"486\":1}}],[\"tuning的灵感来源是\",{\"1\":{\"486\":1}}],[\"tuning的具体细节\",{\"1\":{\"485\":1,\"486\":1}}],[\"tuning的基本原理是在输入序列x之前\",{\"1\":{\"485\":1}}],[\"tuning的出发点\",{\"1\":{\"485\":1,\"486\":1}}],[\"tuning\",{\"0\":{\"10\":1,\"239\":2,\"480\":1,\"485\":1,\"486\":1,\"575\":1,\"778\":1},\"1\":{\"198\":1,\"201\":1,\"213\":2,\"232\":3,\"233\":1,\"239\":13,\"480\":1,\"483\":3,\"485\":1,\"486\":1,\"488\":1,\"491\":7,\"492\":2,\"506\":1,\"528\":1,\"537\":1,\"575\":1,\"775\":1}}],[\"tuple\",{\"1\":{\"40\":1,\"163\":1,\"186\":2,\"272\":1,\"274\":1,\"316\":1,\"319\":2,\"322\":1,\"337\":2,\"374\":2,\"476\":2,\"477\":1,\"478\":6,\"544\":7,\"614\":1,\"681\":2,\"682\":1,\"684\":1,\"686\":2,\"688\":2,\"801\":1,\"804\":1,\"815\":1,\"821\":1}}],[\"txt文件\",{\"1\":{\"593\":1}}],[\"txt\",{\"1\":{\"40\":1,\"309\":1,\"438\":2,\"620\":2,\"696\":8}}],[\"t\",{\"0\":{\"748\":2},\"1\":{\"30\":9,\"34\":5,\"35\":3,\"36\":6,\"70\":11,\"72\":1,\"76\":11,\"80\":1,\"82\":5,\"98\":1,\"103\":1,\"105\":2,\"107\":3,\"112\":2,\"145\":6,\"146\":1,\"147\":4,\"161\":3,\"170\":3,\"252\":1,\"254\":4,\"255\":1,\"257\":1,\"263\":2,\"265\":2,\"267\":1,\"272\":1,\"277\":2,\"299\":15,\"300\":2,\"302\":1,\"304\":1,\"316\":1,\"419\":1,\"421\":3,\"423\":3,\"426\":16,\"470\":2,\"477\":2,\"581\":1,\"584\":1,\"688\":3,\"696\":2,\"748\":2,\"819\":7,\"821\":5,\"822\":4,\"885\":1}}],[\"tesla\",{\"1\":{\"774\":1}}],[\"testcase\",{\"1\":{\"675\":1,\"676\":1}}],[\"testenv\",{\"1\":{\"434\":2}}],[\"test\",{\"0\":{\"398\":1},\"1\":{\"58\":1,\"65\":1,\"80\":4,\"82\":1,\"142\":3,\"145\":4,\"273\":9,\"274\":28,\"302\":2,\"304\":1,\"398\":16,\"506\":1,\"507\":1,\"522\":1,\"577\":8,\"675\":2,\"676\":1,\"703\":1}}],[\"term\",{\"1\":{\"577\":1}}],[\"terms\",{\"1\":{\"186\":3,\"478\":3,\"615\":1}}],[\"telgarsky\",{\"1\":{\"385\":1}}],[\"te和mi分别是visual\",{\"1\":{\"282\":1}}],[\"te\",{\"1\":{\"282\":1}}],[\"teacher\",{\"1\":{\"163\":2,\"175\":1,\"178\":1,\"186\":40}}],[\"tensordataset\",{\"1\":{\"594\":1}}],[\"tensorrt\",{\"1\":{\"426\":1}}],[\"tensor2\",{\"1\":{\"367\":1}}],[\"tensor1\",{\"1\":{\"367\":1}}],[\"tensors\",{\"1\":{\"358\":2}}],[\"tensors=\",{\"1\":{\"40\":1,\"142\":1,\"143\":1,\"145\":1,\"146\":1,\"147\":1,\"159\":1,\"302\":2,\"304\":2,\"309\":1,\"544\":1}}],[\"tensorboard\",{\"1\":{\"276\":1}}],[\"tensorflow\",{\"1\":{\"85\":1,\"102\":1,\"428\":1}}],[\"tensor\",{\"0\":{\"371\":1,\"374\":1,\"378\":1,\"379\":1},\"1\":{\"43\":1,\"58\":2,\"59\":2,\"76\":6,\"143\":1,\"163\":1,\"169\":3,\"170\":1,\"186\":3,\"278\":3,\"289\":2,\"292\":2,\"300\":1,\"316\":1,\"317\":2,\"322\":1,\"358\":2,\"361\":1,\"362\":1,\"363\":4,\"364\":5,\"366\":5,\"367\":1,\"369\":7,\"370\":3,\"371\":1,\"372\":11,\"373\":5,\"374\":6,\"375\":1,\"376\":1,\"377\":7,\"378\":1,\"379\":3,\"421\":3,\"423\":3,\"425\":13,\"426\":4,\"467\":4,\"468\":4,\"469\":4,\"470\":4,\"541\":2,\"544\":4,\"581\":2,\"591\":1,\"599\":2,\"601\":2,\"606\":2,\"607\":3,\"615\":1,\"794\":1,\"798\":1,\"802\":3,\"814\":1,\"818\":1,\"820\":2,\"821\":1,\"822\":1,\"840\":5}}],[\"tennisracket\",{\"1\":{\"29\":1}}],[\"temperature=1\",{\"1\":{\"819\":1}}],[\"temperature=temperature\",{\"1\":{\"817\":1,\"820\":1}}],[\"temperature\",{\"1\":{\"248\":1,\"254\":1,\"255\":1,\"299\":1,\"793\":3,\"794\":1,\"817\":1,\"819\":4,\"820\":1,\"821\":5,\"822\":2}}],[\"temp=0\",{\"1\":{\"186\":1}}],[\"temp3\",{\"1\":{\"78\":2}}],[\"temp2\",{\"1\":{\"78\":3}}],[\"temp1\",{\"1\":{\"78\":3}}],[\"temp\",{\"1\":{\"29\":2,\"58\":2,\"78\":2,\"81\":2,\"82\":5,\"145\":7,\"147\":5,\"160\":4,\"161\":4,\"186\":22,\"310\":2,\"578\":2,\"794\":4,\"795\":1,\"821\":5,\"822\":3}}],[\"textual\",{\"1\":{\"515\":1}}],[\"text和text\",{\"1\":{\"310\":1}}],[\"text最相关的视觉信息\",{\"1\":{\"309\":1}}],[\"text转化为18291个类别\",{\"1\":{\"305\":1}}],[\"texts\",{\"1\":{\"299\":1,\"300\":2,\"302\":1,\"304\":1,\"820\":4}}],[\"text→image\",{\"1\":{\"277\":2}}],[\"textonly\",{\"1\":{\"275\":2}}],[\"text=texts\",{\"1\":{\"302\":1,\"304\":1}}],[\"text=true\",{\"1\":{\"276\":2}}],[\"text=false\",{\"1\":{\"276\":1,\"277\":2,\"278\":3}}],[\"text=1\",{\"1\":{\"274\":1}}],[\"text=0\",{\"1\":{\"274\":4,\"277\":1}}],[\"text=self\",{\"1\":{\"274\":3}}],[\"textmlm\",{\"1\":{\"272\":2,\"275\":1}}],[\"textvqa\",{\"1\":{\"228\":1,\"230\":1}}],[\"textcaps\",{\"1\":{\"225\":1}}],[\"text\",{\"0\":{\"154\":1,\"156\":1,\"278\":1,\"310\":1,\"311\":1,\"312\":1},\"1\":{\"29\":18,\"30\":7,\"34\":1,\"40\":3,\"43\":1,\"70\":4,\"71\":1,\"76\":2,\"80\":2,\"83\":7,\"126\":2,\"127\":4,\"142\":7,\"143\":2,\"145\":60,\"146\":17,\"147\":60,\"156\":1,\"159\":4,\"160\":21,\"161\":30,\"162\":24,\"163\":7,\"202\":1,\"260\":2,\"262\":2,\"265\":2,\"272\":22,\"274\":24,\"275\":1,\"276\":30,\"277\":53,\"278\":50,\"282\":2,\"285\":1,\"289\":1,\"294\":4,\"299\":6,\"300\":13,\"302\":9,\"303\":9,\"304\":16,\"307\":2,\"309\":17,\"310\":11,\"311\":32,\"312\":5,\"313\":1,\"316\":1,\"369\":3,\"476\":2,\"478\":2,\"521\":2,\"541\":7,\"544\":2,\"562\":1,\"578\":8,\"594\":2,\"805\":1,\"812\":1,\"814\":35,\"815\":34,\"817\":23,\"820\":26,\"822\":48}}],[\"triviaqa零样本68\",{\"1\":{\"549\":1}}],[\"trinh\",{\"1\":{\"522\":1}}],[\"trilinear\",{\"1\":{\"388\":1}}],[\"tripod\",{\"1\":{\"300\":1}}],[\"trick\",{\"1\":{\"59\":1,\"796\":1,\"815\":1,\"868\":1,\"869\":1}}],[\"treebank\",{\"1\":{\"515\":1,\"522\":1,\"577\":1}}],[\"tree\",{\"1\":{\"164\":1,\"171\":1,\"259\":1,\"270\":1,\"306\":1,\"764\":1}}],[\"try\",{\"1\":{\"73\":1,\"83\":1,\"302\":2,\"303\":1,\"304\":3,\"336\":2,\"688\":1,\"696\":1,\"885\":1,\"886\":1}}],[\"truncate\",{\"1\":{\"476\":2,\"478\":4}}],[\"truncation=true\",{\"1\":{\"40\":1,\"142\":1,\"145\":1,\"146\":1,\"147\":1,\"159\":1,\"309\":1}}],[\"truncation\",{\"1\":{\"40\":2}}],[\"trunc\",{\"1\":{\"272\":2,\"319\":1,\"320\":2,\"323\":2}}],[\"truths\",{\"1\":{\"840\":1}}],[\"truthfulqa\",{\"1\":{\"536\":1,\"537\":1,\"538\":2,\"551\":1}}],[\"truth\",{\"0\":{\"64\":1},\"1\":{\"78\":2,\"82\":2,\"162\":1,\"248\":1,\"277\":7,\"467\":2,\"468\":1,\"469\":2,\"470\":1,\"471\":1}}],[\"truediv\",{\"1\":{\"690\":1}}],[\"true=已初始化\",{\"1\":{\"169\":1}}],[\"true\",{\"1\":{\"29\":1,\"40\":2,\"76\":1,\"82\":5,\"96\":1,\"109\":1,\"142\":1,\"145\":1,\"146\":2,\"147\":1,\"160\":1,\"162\":2,\"163\":3,\"169\":4,\"170\":3,\"272\":1,\"274\":1,\"316\":1,\"327\":1,\"332\":2,\"366\":3,\"368\":1,\"372\":2,\"398\":1,\"403\":1,\"426\":1,\"469\":1,\"471\":3,\"473\":1,\"477\":1,\"478\":1,\"544\":2,\"688\":1,\"697\":1,\"796\":1,\"814\":4,\"821\":3,\"840\":1,\"848\":8,\"885\":1,\"886\":1}}],[\"trust\",{\"1\":{\"28\":2}}],[\"traditional\",{\"1\":{\"541\":5}}],[\"traversal\",{\"1\":{\"507\":1}}],[\"trange\",{\"1\":{\"476\":3,\"478\":2}}],[\"transf\",{\"1\":{\"820\":4}}],[\"transfo\",{\"1\":{\"186\":2}}],[\"transfo2\",{\"1\":{\"186\":2}}],[\"transfo1\",{\"1\":{\"186\":2}}],[\"transform=data\",{\"1\":{\"317\":2}}],[\"transform=none\",{\"1\":{\"316\":1}}],[\"transform=transforms\",{\"1\":{\"840\":1}}],[\"transform=transform\",{\"1\":{\"186\":1,\"802\":1,\"848\":1,\"855\":1,\"885\":1}}],[\"transform=feature\",{\"1\":{\"110\":1,\"111\":2}}],[\"transform=false\",{\"1\":{\"110\":1,\"111\":1}}],[\"transforms\",{\"1\":{\"186\":14,\"252\":7,\"317\":10,\"463\":4,\"802\":11,\"840\":5,\"848\":4,\"852\":1,\"855\":1,\"885\":2}}],[\"transformation\",{\"1\":{\"108\":1}}],[\"transformations\",{\"1\":{\"104\":1}}],[\"transform\",{\"1\":{\"108\":3,\"109\":5,\"110\":3,\"111\":2,\"142\":1,\"186\":1,\"252\":5,\"274\":13,\"295\":5,\"316\":5,\"317\":4,\"463\":2,\"609\":3,\"610\":2,\"802\":14,\"803\":1,\"848\":1,\"855\":1,\"885\":1}}],[\"transformer架构\",{\"1\":{\"531\":1}}],[\"transformer架构导入偏差是有帮助的\",{\"1\":{\"516\":1}}],[\"transformer比lstm能获取长距离信息\",{\"1\":{\"508\":1}}],[\"transformer跨各种各样任务的迁移性能更强\",{\"1\":{\"507\":1}}],[\"transformer证明了使用transformer结构可以有效处理图像数据\",{\"1\":{\"328\":1}}],[\"transformer需要输入的是一维的token\",{\"1\":{\"318\":1}}],[\"transformer的核心流程实现\",{\"1\":{\"315\":1}}],[\"transformer的模型结构相比于transformer来说更简单\",{\"1\":{\"314\":1}}],[\"transformer是2021年谷歌在iclr上提出的算法\",{\"1\":{\"314\":1}}],[\"transformer结合起来用于多模态transformer\",{\"1\":{\"280\":1}}],[\"transformers\",{\"1\":{\"172\":2,\"274\":1,\"304\":1,\"541\":1,\"544\":3,\"764\":2,\"765\":1,\"790\":1}}],[\"transformerdecoderlayer\",{\"1\":{\"76\":1}}],[\"transformer\",{\"0\":{\"264\":2,\"272\":1,\"291\":1,\"415\":1,\"771\":1},\"1\":{\"70\":1,\"73\":2,\"76\":2,\"107\":1,\"112\":3,\"115\":1,\"126\":1,\"127\":2,\"150\":1,\"152\":2,\"163\":1,\"167\":2,\"173\":4,\"179\":3,\"191\":1,\"197\":1,\"260\":6,\"261\":4,\"262\":2,\"263\":2,\"264\":3,\"266\":1,\"268\":9,\"269\":1,\"272\":8,\"276\":4,\"277\":15,\"279\":2,\"293\":1,\"294\":1,\"297\":3,\"299\":3,\"302\":2,\"305\":1,\"308\":1,\"314\":1,\"319\":3,\"321\":1,\"326\":10,\"327\":2,\"395\":2,\"404\":1,\"415\":1,\"492\":1,\"510\":2,\"511\":1,\"514\":3,\"521\":2,\"528\":1,\"531\":1,\"560\":1,\"571\":3,\"573\":1,\"575\":2,\"580\":3,\"587\":1,\"605\":1,\"616\":1,\"620\":5,\"622\":4,\"703\":1,\"704\":3,\"766\":3,\"769\":1,\"771\":4,\"772\":1,\"774\":3,\"775\":1,\"780\":1,\"784\":1,\"789\":1,\"790\":2,\"796\":1,\"802\":4,\"803\":3,\"804\":6,\"806\":2,\"807\":8,\"809\":2,\"811\":1,\"814\":8,\"815\":4,\"816\":1,\"817\":1,\"820\":3,\"822\":12}}],[\"translate\",{\"1\":{\"521\":1}}],[\"translation\",{\"1\":{\"314\":1}}],[\"trans\",{\"1\":{\"108\":6,\"109\":11,\"110\":4,\"111\":4,\"426\":7}}],[\"transposed\",{\"1\":{\"426\":1}}],[\"transpose\",{\"0\":{\"359\":1,\"426\":1},\"1\":{\"29\":2,\"34\":1,\"35\":2,\"36\":1,\"58\":1,\"59\":3,\"68\":1,\"70\":7,\"73\":2,\"76\":1,\"83\":1,\"100\":1,\"108\":1,\"109\":4,\"111\":1,\"162\":5,\"257\":1,\"272\":4,\"293\":6,\"312\":8,\"318\":1,\"322\":4,\"359\":1,\"360\":3,\"361\":1,\"362\":1,\"426\":2,\"463\":2,\"544\":3,\"584\":1,\"590\":5,\"591\":2,\"605\":5,\"632\":3,\"804\":1}}],[\"train=true\",{\"1\":{\"840\":1,\"848\":1,\"855\":1,\"885\":1}}],[\"trained\",{\"1\":{\"492\":1,\"593\":2}}],[\"trainer\",{\"1\":{\"273\":36,\"274\":12}}],[\"traindir\",{\"1\":{\"252\":1}}],[\"trains=\",{\"1\":{\"142\":1,\"145\":1,\"147\":1}}],[\"training语言模型\",{\"1\":{\"506\":1}}],[\"training\",{\"0\":{\"153\":1,\"266\":1,\"774\":1},\"1\":{\"81\":1,\"119\":2,\"120\":1,\"134\":1,\"170\":2,\"176\":1,\"198\":2,\"233\":1,\"259\":2,\"268\":2,\"270\":1,\"273\":2,\"275\":2,\"276\":1,\"277\":1,\"278\":1,\"298\":1,\"316\":1,\"327\":1,\"505\":1,\"533\":1,\"544\":2,\"562\":1,\"564\":1,\"581\":1,\"704\":1,\"764\":2,\"775\":1,\"803\":2,\"815\":2,\"840\":2}}],[\"train\",{\"0\":{\"159\":1,\"252\":1,\"398\":1},\"1\":{\"29\":8,\"58\":8,\"65\":1,\"68\":2,\"80\":4,\"81\":3,\"83\":5,\"142\":9,\"145\":7,\"147\":2,\"159\":1,\"186\":4,\"252\":11,\"273\":6,\"274\":26,\"276\":2,\"277\":1,\"278\":1,\"301\":1,\"316\":7,\"317\":7,\"323\":1,\"398\":12,\"403\":8,\"476\":1,\"478\":1,\"488\":1,\"577\":8,\"581\":1,\"593\":3,\"594\":1,\"596\":6,\"802\":1,\"803\":9,\"840\":2,\"848\":6,\"855\":3,\"856\":6,\"857\":1,\"860\":6,\"885\":5,\"886\":1}}],[\"trashcan\",{\"1\":{\"29\":1,\"58\":1,\"68\":1}}],[\"tool\",{\"1\":{\"717\":1}}],[\"toothbrush\",{\"1\":{\"29\":1}}],[\"toxicity\",{\"0\":{\"551\":1}}],[\"to=1\",{\"1\":{\"371\":1}}],[\"totensor\",{\"1\":{\"186\":1,\"252\":1,\"317\":2,\"463\":1,\"802\":4,\"840\":1,\"848\":1,\"855\":1,\"885\":1}}],[\"total\",{\"0\":{\"731\":1},\"1\":{\"43\":2,\"78\":1,\"81\":1,\"82\":4,\"145\":1,\"186\":4,\"275\":2,\"277\":2,\"302\":4,\"304\":4,\"322\":3,\"469\":2,\"581\":3,\"582\":2,\"612\":2,\"615\":2,\"814\":14,\"815\":3,\"817\":3,\"848\":3,\"885\":6,\"886\":3}}],[\"touvron\",{\"1\":{\"131\":1}}],[\"token分配一个唯一的词索引\",{\"1\":{\"815\":1}}],[\"token分类任务\",{\"0\":{\"617\":1}}],[\"token分类\",{\"1\":{\"575\":2}}],[\"token能力\",{\"1\":{\"814\":1}}],[\"token用于分类任务即可\",{\"1\":{\"603\":1}}],[\"token序列\",{\"1\":{\"541\":1}}],[\"token窗口中\",{\"1\":{\"528\":1}}],[\"token提取出来\",{\"1\":{\"323\":1}}],[\"token对齐\",{\"1\":{\"319\":1}}],[\"token开头\",{\"1\":{\"313\":1}}],[\"token的作用\",{\"1\":{\"319\":1}}],[\"token的相似度\",{\"1\":{\"310\":1}}],[\"token的原始特征\",{\"1\":{\"276\":1}}],[\"token作为最后的相似度得分\",{\"1\":{\"310\":2}}],[\"token作为input\",{\"1\":{\"309\":1}}],[\"token是有效的\",{\"1\":{\"309\":1}}],[\"token压缩\",{\"1\":{\"222\":1}}],[\"token做投影\",{\"1\":{\"145\":2}}],[\"tokens可知这些被掩码token对应的真实词作为label\",{\"1\":{\"581\":1}}],[\"tokens后hellaswag分数提升至82\",{\"1\":{\"549\":1}}],[\"tokens训练耗时约21天\",{\"1\":{\"548\":1}}],[\"tokens训练后性能持续提升\",{\"1\":{\"547\":1}}],[\"tokens即停止\",{\"1\":{\"547\":1}}],[\"tokens=padding\",{\"1\":{\"820\":1}}],[\"tokens=false\",{\"1\":{\"594\":1,\"803\":2,\"804\":1}}],[\"tokens=50\",{\"1\":{\"544\":1}}],[\"tokens=true\",{\"1\":{\"143\":1,\"313\":1,\"616\":2}}],[\"tokens形状\",{\"1\":{\"313\":1}}],[\"tokens做attention\",{\"1\":{\"312\":1}}],[\"tokens的embeddings在seq\",{\"1\":{\"311\":1}}],[\"tokens同时输入bertmodel时\",{\"1\":{\"311\":1}}],[\"tokens部分的mask列表\",{\"1\":{\"594\":1}}],[\"tokens部分的每个位置都映射到2维匹配空间\",{\"1\":{\"311\":1}}],[\"tokens部分的结果\",{\"1\":{\"311\":1}}],[\"tokens拼接得到的结果和图像嵌入进行cross\",{\"1\":{\"311\":1}}],[\"tokens列表中所有句子掩码数量一致\",{\"1\":{\"581\":1}}],[\"tokens列表\",{\"1\":{\"311\":1}}],[\"tokens\",{\"1\":{\"40\":3,\"75\":2,\"169\":8,\"170\":7,\"272\":2,\"300\":2,\"309\":9,\"310\":3,\"311\":16,\"312\":16,\"313\":6,\"319\":1,\"320\":2,\"323\":2,\"476\":4,\"477\":6,\"478\":7,\"514\":1,\"521\":1,\"528\":1,\"530\":1,\"541\":6,\"544\":4,\"547\":1,\"548\":2,\"561\":1,\"578\":17,\"579\":13,\"580\":4,\"581\":2,\"584\":4,\"594\":6,\"605\":1,\"614\":2,\"616\":2,\"704\":1,\"773\":1,\"793\":7,\"794\":5,\"798\":4,\"802\":4,\"804\":4,\"814\":37,\"815\":17,\"817\":9,\"820\":19,\"821\":14,\"822\":3}}],[\"token\",{\"0\":{\"319\":1,\"770\":1},\"1\":{\"40\":2,\"43\":5,\"46\":3,\"72\":2,\"73\":4,\"76\":10,\"126\":5,\"142\":4,\"143\":12,\"145\":1,\"147\":3,\"155\":2,\"156\":1,\"160\":1,\"161\":3,\"162\":1,\"163\":14,\"165\":5,\"167\":4,\"170\":4,\"179\":7,\"186\":1,\"198\":1,\"208\":1,\"212\":2,\"224\":2,\"234\":1,\"263\":1,\"265\":2,\"268\":2,\"272\":9,\"276\":16,\"277\":14,\"289\":3,\"294\":1,\"295\":1,\"309\":1,\"310\":1,\"312\":16,\"313\":5,\"319\":23,\"320\":5,\"323\":5,\"463\":6,\"476\":10,\"477\":4,\"478\":10,\"510\":1,\"512\":1,\"516\":1,\"541\":7,\"542\":2,\"544\":20,\"560\":2,\"572\":3,\"573\":4,\"578\":4,\"579\":2,\"580\":4,\"587\":2,\"588\":2,\"589\":3,\"590\":5,\"591\":2,\"594\":35,\"596\":4,\"597\":9,\"601\":4,\"602\":2,\"603\":2,\"610\":1,\"612\":3,\"614\":9,\"615\":2,\"616\":8,\"617\":4,\"618\":6,\"704\":3,\"768\":1,\"770\":9,\"771\":1,\"772\":7,\"773\":3,\"774\":2,\"780\":4,\"786\":1,\"787\":2,\"788\":3,\"789\":4,\"790\":2,\"793\":6,\"794\":2,\"796\":2,\"798\":3,\"800\":3,\"801\":1,\"802\":8,\"803\":7,\"804\":24,\"807\":19,\"809\":15,\"813\":2,\"814\":18,\"815\":26,\"816\":1,\"817\":26,\"818\":3,\"819\":3,\"820\":22,\"821\":18,\"822\":5,\"885\":1}}],[\"tokenize方法进行分词\",{\"1\":{\"477\":1}}],[\"tokenize方法完成分词功能\",{\"1\":{\"476\":1}}],[\"tokenize方法完成断句功能\",{\"1\":{\"476\":1}}],[\"tokenize\",{\"1\":{\"147\":1,\"300\":1,\"476\":2,\"477\":2,\"478\":4,\"514\":1,\"577\":1,\"578\":4}}],[\"tokenizer生成标签\",{\"1\":{\"802\":1}}],[\"tokenizer=self\",{\"1\":{\"274\":1}}],[\"tokenizers\",{\"1\":{\"164\":2}}],[\"tokenizer\",{\"1\":{\"28\":5,\"40\":4,\"142\":6,\"143\":7,\"145\":4,\"146\":3,\"147\":7,\"159\":2,\"160\":4,\"163\":3,\"167\":4,\"274\":19,\"309\":1,\"312\":2,\"313\":4,\"477\":7,\"478\":1,\"541\":5,\"544\":6,\"548\":1,\"578\":1,\"579\":17,\"581\":6,\"616\":4,\"704\":1,\"770\":4,\"773\":1,\"774\":1,\"789\":1,\"802\":9,\"820\":5}}],[\"tokenization\",{\"1\":{\"40\":1,\"614\":1}}],[\"topk\",{\"1\":{\"300\":1,\"818\":1}}],[\"top\",{\"0\":{\"818\":1},\"1\":{\"28\":2,\"63\":1,\"143\":2,\"173\":3,\"184\":1,\"300\":2,\"313\":3,\"522\":1,\"801\":5,\"817\":3,\"818\":8,\"820\":3}}],[\"to\",{\"0\":{\"503\":1},\"1\":{\"28\":1,\"36\":6,\"40\":1,\"59\":9,\"71\":1,\"78\":1,\"83\":3,\"92\":7,\"142\":2,\"143\":2,\"145\":3,\"146\":2,\"147\":4,\"159\":2,\"161\":2,\"162\":1,\"163\":1,\"170\":1,\"186\":1,\"214\":4,\"233\":1,\"255\":1,\"272\":3,\"277\":3,\"278\":1,\"299\":2,\"302\":6,\"304\":5,\"307\":1,\"309\":2,\"311\":3,\"312\":1,\"313\":2,\"318\":1,\"323\":3,\"327\":1,\"346\":3,\"371\":1,\"463\":1,\"476\":14,\"477\":3,\"478\":53,\"488\":2,\"503\":2,\"521\":1,\"533\":1,\"539\":1,\"541\":16,\"544\":2,\"581\":2,\"591\":2,\"593\":3,\"594\":1,\"601\":1,\"602\":1,\"605\":4,\"621\":1,\"632\":1,\"696\":5,\"803\":1,\"804\":3,\"805\":1,\"812\":1,\"814\":4,\"815\":1,\"820\":1,\"821\":1,\"822\":6,\"840\":3,\"848\":3,\"856\":2,\"857\":2,\"860\":3,\"861\":2,\"885\":2,\"886\":4}}],[\"torchvision\",{\"1\":{\"840\":3,\"848\":2,\"852\":1,\"885\":1}}],[\"torch==1\",{\"1\":{\"620\":1}}],[\"torchscript\",{\"1\":{\"322\":1}}],[\"torch\",{\"0\":{\"365\":1,\"369\":1,\"372\":1,\"373\":1,\"374\":1,\"375\":1,\"376\":1,\"377\":1},\"1\":{\"28\":2,\"32\":8,\"34\":1,\"35\":2,\"36\":1,\"40\":1,\"41\":4,\"43\":6,\"45\":5,\"46\":3,\"58\":2,\"59\":13,\"70\":3,\"76\":5,\"78\":21,\"80\":3,\"81\":2,\"82\":1,\"83\":4,\"92\":12,\"96\":3,\"100\":3,\"107\":6,\"108\":4,\"109\":7,\"111\":4,\"142\":2,\"143\":1,\"145\":30,\"146\":1,\"147\":26,\"160\":4,\"161\":7,\"162\":14,\"163\":9,\"169\":8,\"170\":10,\"186\":14,\"252\":2,\"254\":2,\"255\":5,\"256\":1,\"257\":1,\"272\":12,\"273\":3,\"274\":2,\"276\":4,\"277\":3,\"278\":18,\"293\":2,\"300\":3,\"302\":4,\"304\":5,\"309\":1,\"310\":3,\"311\":17,\"312\":6,\"313\":2,\"316\":5,\"317\":2,\"319\":2,\"320\":3,\"323\":5,\"327\":1,\"355\":3,\"358\":3,\"361\":1,\"363\":2,\"364\":3,\"366\":2,\"367\":3,\"368\":1,\"369\":1,\"370\":3,\"372\":8,\"373\":6,\"374\":3,\"375\":2,\"376\":2,\"377\":8,\"378\":1,\"388\":1,\"395\":1,\"403\":1,\"421\":3,\"423\":7,\"425\":2,\"426\":4,\"463\":4,\"469\":1,\"470\":6,\"473\":4,\"541\":6,\"544\":16,\"580\":2,\"581\":4,\"584\":2,\"590\":12,\"591\":19,\"596\":1,\"597\":2,\"605\":2,\"610\":1,\"614\":4,\"620\":1,\"632\":2,\"794\":3,\"798\":3,\"803\":8,\"804\":1,\"814\":5,\"815\":7,\"817\":3,\"818\":2,\"820\":6,\"821\":3,\"822\":4,\"840\":10,\"848\":15,\"852\":5,\"853\":4,\"854\":1,\"856\":2,\"857\":3,\"859\":5,\"860\":3,\"861\":3,\"885\":8,\"886\":10}}],[\"through\",{\"1\":{\"628\":1,\"793\":4,\"794\":1,\"795\":2,\"796\":4,\"821\":8,\"881\":1,\"885\":2}}],[\"threads\",{\"1\":{\"840\":1}}],[\"thre\",{\"1\":{\"82\":2}}],[\"thres=0\",{\"1\":{\"818\":2}}],[\"thres=filter\",{\"1\":{\"817\":1,\"820\":1}}],[\"thres\",{\"1\":{\"82\":2,\"817\":2,\"818\":1,\"820\":2}}],[\"threshold\",{\"1\":{\"82\":9,\"463\":2,\"467\":1}}],[\"thresholding\",{\"1\":{\"82\":2}}],[\"than\",{\"1\":{\"541\":6,\"821\":1}}],[\"that\",{\"1\":{\"28\":6,\"63\":1,\"541\":13}}],[\"thinking\",{\"1\":{\"704\":2}}],[\"think\",{\"1\":{\"500\":1}}],[\"this\",{\"1\":{\"28\":3,\"43\":7,\"70\":1,\"83\":3,\"300\":1,\"605\":1}}],[\"th\",{\"1\":{\"463\":7}}],[\"theory\",{\"1\":{\"870\":1}}],[\"theorem\",{\"1\":{\"112\":1,\"385\":1,\"732\":1}}],[\"then\",{\"1\":{\"775\":1}}],[\"these\",{\"1\":{\"615\":1}}],[\"there\",{\"1\":{\"610\":1}}],[\"they\",{\"1\":{\"603\":1}}],[\"them\",{\"1\":{\"549\":1,\"551\":1}}],[\"their\",{\"1\":{\"478\":4,\"549\":1,\"551\":1}}],[\"thecvf\",{\"1\":{\"60\":1}}],[\"theta\",{\"1\":{\"45\":4,\"59\":4}}],[\"the\",{\"0\":{\"751\":1},\"1\":{\"28\":56,\"31\":12,\"40\":1,\"59\":2,\"63\":2,\"78\":1,\"82\":2,\"83\":3,\"147\":1,\"157\":1,\"170\":1,\"214\":2,\"252\":1,\"254\":3,\"255\":1,\"256\":1,\"257\":1,\"277\":1,\"300\":1,\"303\":1,\"304\":1,\"316\":1,\"478\":2,\"485\":1,\"515\":1,\"562\":1,\"577\":1,\"594\":4,\"601\":3,\"605\":5,\"610\":3,\"615\":1,\"616\":2,\"617\":1,\"620\":1,\"628\":1,\"632\":2,\"696\":1,\"758\":1,\"817\":1,\"821\":1,\"822\":1,\"840\":3,\"843\":1}}],[\"thought\",{\"0\":{\"9\":1,\"28\":1,\"501\":1},\"1\":{\"7\":1,\"26\":1,\"501\":2,\"502\":1,\"706\":1}}],[\"fmap\",{\"1\":{\"814\":8}}],[\"f放缩因子\",{\"1\":{\"656\":1}}],[\"f1放缩因子\",{\"1\":{\"656\":2}}],[\"f1达89\",{\"1\":{\"565\":1,\"566\":1}}],[\"f1从87\",{\"1\":{\"565\":1}}],[\"f1\",{\"0\":{\"448\":1},\"1\":{\"448\":4,\"522\":2,\"529\":1,\"564\":1,\"656\":2}}],[\"ff\",{\"1\":{\"814\":6}}],[\"fft的原理\",{\"1\":{\"483\":1}}],[\"ffmpeg\",{\"1\":{\"438\":1}}],[\"ffn\",{\"1\":{\"74\":1,\"126\":2,\"264\":5,\"268\":1,\"272\":4,\"277\":11,\"542\":1}}],[\"fw\",{\"1\":{\"388\":1}}],[\"fh\",{\"1\":{\"388\":1}}],[\"f2放缩因子\",{\"1\":{\"656\":2}}],[\"f2\",{\"1\":{\"246\":1,\"656\":1}}],[\"f2d\",{\"1\":{\"40\":1}}],[\"f3放缩因子\",{\"1\":{\"656\":1}}],[\"f30kcaptionkarpathydatamodule\",{\"1\":{\"274\":1}}],[\"f30k\",{\"1\":{\"274\":1}}],[\"f3\",{\"1\":{\"246\":2,\"656\":1}}],[\"f3d\",{\"1\":{\"40\":1}}],[\"few\",{\"1\":{\"525\":1,\"527\":1,\"528\":1,\"529\":3,\"531\":2,\"537\":2,\"538\":2}}],[\"fe\",{\"1\":{\"285\":3}}],[\"feedforward\",{\"1\":{\"294\":1,\"814\":2}}],[\"feed\",{\"1\":{\"272\":1,\"514\":1,\"544\":2,\"622\":1,\"627\":4,\"630\":5}}],[\"feedback\",{\"1\":{\"232\":1,\"483\":2,\"533\":1,\"535\":1,\"536\":1}}],[\"featmap\",{\"1\":{\"463\":6}}],[\"feat相似度最大的那个query\",{\"1\":{\"310\":2}}],[\"feats\",{\"1\":{\"276\":12,\"277\":42,\"278\":5,\"309\":1,\"310\":5}}],[\"feat=false\",{\"1\":{\"109\":2,\"111\":1}}],[\"feat=true\",{\"1\":{\"109\":2,\"110\":1}}],[\"feat\",{\"1\":{\"70\":8,\"76\":8,\"109\":10,\"110\":4,\"111\":4,\"145\":22,\"146\":4,\"147\":18,\"161\":25,\"309\":1,\"310\":8,\"840\":5}}],[\"featured\",{\"1\":{\"577\":1}}],[\"feature的方法快了4倍\",{\"1\":{\"286\":1}}],[\"feature的方法速度快了60倍\",{\"1\":{\"286\":1}}],[\"feature方法直接使用cnn提取grid的特征\",{\"1\":{\"283\":1}}],[\"feature方法通常采用faster\",{\"1\":{\"283\":1}}],[\"features=none\",{\"1\":{\"321\":2}}],[\"features=mlp\",{\"1\":{\"272\":3,\"321\":1}}],[\"features=dim\",{\"1\":{\"272\":3,\"321\":1}}],[\"features\",{\"1\":{\"35\":1,\"40\":1,\"98\":2,\"162\":4,\"255\":2,\"272\":2,\"277\":8,\"300\":10,\"302\":4,\"304\":4,\"305\":1,\"319\":3,\"320\":3,\"321\":15,\"323\":5,\"428\":1,\"594\":1,\"804\":2}}],[\"feature\",{\"1\":{\"35\":2,\"36\":1,\"40\":18,\"41\":19,\"45\":9,\"46\":10,\"59\":18,\"73\":2,\"76\":1,\"86\":2,\"92\":1,\"96\":1,\"98\":5,\"99\":1,\"100\":1,\"101\":2,\"108\":3,\"109\":5,\"110\":4,\"111\":3,\"233\":1,\"254\":1,\"280\":2,\"387\":3,\"814\":1}}],[\"fn放缩因子\",{\"1\":{\"656\":1}}],[\"fn负责对返回的一个batch\",{\"1\":{\"596\":1}}],[\"fname=fname\",{\"1\":{\"463\":1}}],[\"fname\",{\"1\":{\"463\":2}}],[\"fn=collate\",{\"1\":{\"596\":1}}],[\"fn=val\",{\"1\":{\"317\":1}}],[\"fn=train\",{\"1\":{\"317\":1}}],[\"fn=self\",{\"1\":{\"274\":6}}],[\"fn叫做\",{\"1\":{\"246\":1}}],[\"fn\",{\"1\":{\"170\":5,\"246\":1,\"295\":3,\"316\":2,\"317\":2,\"442\":3,\"443\":1,\"471\":8,\"473\":2,\"596\":2,\"599\":3,\"609\":3,\"793\":1,\"794\":1,\"821\":2,\"886\":2}}],[\"fns=\",{\"1\":{\"142\":1,\"145\":1,\"147\":1}}],[\"fnn\",{\"1\":{\"36\":1}}],[\"fstn\",{\"1\":{\"109\":2}}],[\"f^2\",{\"1\":{\"105\":1}}],[\"fxia22\",{\"1\":{\"102\":1}}],[\"flush=true\",{\"1\":{\"541\":1,\"544\":1}}],[\"floor\",{\"1\":{\"354\":1,\"386\":1}}],[\"flowerclassify\",{\"1\":{\"302\":1,\"304\":1}}],[\"flower\",{\"1\":{\"302\":4,\"304\":2,\"316\":8}}],[\"floattensor\",{\"1\":{\"544\":5,\"840\":2}}],[\"float32\",{\"1\":{\"107\":1,\"186\":1}}],[\"float64\",{\"1\":{\"83\":4,\"696\":1}}],[\"float\",{\"1\":{\"58\":2,\"59\":2,\"70\":2,\"76\":3,\"83\":1,\"145\":1,\"163\":1,\"254\":2,\"272\":3,\"277\":4,\"278\":2,\"300\":2,\"316\":1,\"354\":1,\"398\":1,\"463\":1,\"467\":1,\"468\":1,\"469\":1,\"470\":3,\"581\":2,\"591\":1,\"690\":1,\"803\":1,\"815\":1,\"818\":1,\"848\":2,\"860\":1,\"861\":1,\"886\":1}}],[\"flashattention\",{\"1\":{\"704\":1}}],[\"flash\",{\"1\":{\"704\":6}}],[\"flat\",{\"1\":{\"840\":2,\"857\":2}}],[\"flat迭代器等\",{\"1\":{\"689\":1}}],[\"flattened\",{\"1\":{\"170\":5,\"885\":3}}],[\"flatten\",{\"1\":{\"82\":2,\"272\":2,\"318\":1,\"803\":2,\"804\":1,\"814\":1,\"815\":1,\"821\":2}}],[\"flag\",{\"1\":{\"274\":3,\"300\":1,\"478\":1}}],[\"flan\",{\"1\":{\"232\":1,\"239\":1,\"536\":1}}],[\"flip\",{\"1\":{\"186\":4}}],[\"flickr30k\",{\"1\":{\"140\":1,\"202\":2,\"211\":2}}],[\"fct\",{\"1\":{\"163\":2,\"295\":2,\"312\":2,\"603\":4,\"612\":3,\"615\":3,\"617\":3,\"618\":2}}],[\"fc3\",{\"1\":{\"93\":2,\"96\":2,\"107\":2,\"110\":2,\"853\":2,\"859\":2}}],[\"fc2\",{\"1\":{\"93\":2,\"96\":2,\"107\":2,\"110\":2,\"321\":2,\"853\":2,\"859\":2}}],[\"fc1\",{\"1\":{\"93\":2,\"96\":2,\"107\":2,\"110\":2,\"321\":2,\"853\":2,\"859\":2}}],[\"fc\",{\"1\":{\"36\":3,\"107\":1,\"156\":1,\"186\":2,\"254\":1,\"313\":1,\"323\":1,\"580\":5,\"853\":4,\"859\":4}}],[\"fp4\",{\"1\":{\"101\":2}}],[\"fp\",{\"1\":{\"99\":3,\"101\":1,\"442\":3,\"443\":1,\"471\":8,\"473\":2}}],[\"fps是一种在点云\",{\"1\":{\"89\":1}}],[\"fps\",{\"1\":{\"89\":1,\"92\":7,\"96\":1,\"98\":1}}],[\"fpr\",{\"1\":{\"82\":1,\"445\":3,\"450\":3,\"453\":2}}],[\"fp16\",{\"1\":{\"561\":1,\"602\":1}}],[\"fp1\",{\"1\":{\"35\":2,\"46\":3,\"59\":2,\"70\":1,\"101\":2}}],[\"fp2\",{\"1\":{\"35\":2,\"46\":3,\"59\":2,\"70\":1,\"101\":2}}],[\"fp3\",{\"1\":{\"35\":2,\"46\":4,\"59\":2,\"70\":1,\"101\":2}}],[\"field\",{\"1\":{\"728\":3}}],[\"fig\",{\"1\":{\"857\":2,\"861\":1}}],[\"figsize=\",{\"1\":{\"697\":1,\"857\":2,\"861\":1}}],[\"figure\",{\"1\":{\"387\":1,\"528\":2,\"536\":1,\"537\":1,\"538\":7,\"539\":4,\"627\":1,\"630\":1,\"632\":1,\"697\":1}}],[\"fit\",{\"1\":{\"273\":5,\"274\":6}}],[\"fill\",{\"1\":{\"142\":1,\"145\":2,\"147\":4,\"161\":1,\"162\":2,\"170\":2,\"272\":1,\"278\":2,\"312\":1,\"313\":1,\"584\":1,\"632\":1,\"815\":1,\"820\":1,\"840\":2,\"848\":1}}],[\"filtered\",{\"1\":{\"817\":2,\"820\":2}}],[\"filterwarnings\",{\"1\":{\"304\":1}}],[\"filter\",{\"0\":{\"144\":1},\"1\":{\"120\":1,\"123\":1,\"128\":2,\"132\":4,\"134\":2,\"138\":1,\"140\":1,\"145\":1,\"817\":1,\"820\":1}}],[\"filtering\",{\"1\":{\"120\":1,\"128\":1,\"234\":1}}],[\"filenotfounderror\",{\"1\":{\"885\":1,\"886\":1}}],[\"filename=to\",{\"1\":{\"696\":1}}],[\"file=\",{\"1\":{\"696\":2}}],[\"file$bert\",{\"1\":{\"593\":1}}],[\"filepath\",{\"1\":{\"477\":1}}],[\"filepaths\",{\"1\":{\"476\":5,\"478\":6}}],[\"file\",{\"1\":{\"29\":7,\"58\":5,\"142\":1,\"160\":1,\"302\":5,\"304\":5,\"316\":2,\"577\":2,\"578\":3,\"696\":3}}],[\"files\",{\"1\":{\"29\":11,\"58\":8,\"302\":2,\"304\":2,\"478\":1}}],[\"first\",{\"1\":{\"92\":2,\"147\":1,\"237\":1,\"289\":2,\"594\":2,\"601\":3,\"840\":2}}],[\"finfo\",{\"1\":{\"815\":1,\"820\":1}}],[\"find\",{\"1\":{\"68\":2,\"303\":2,\"304\":2,\"478\":1}}],[\"fingers\",{\"1\":{\"28\":2,\"31\":2}}],[\"finally\",{\"1\":{\"336\":1,\"688\":1}}],[\"final\",{\"1\":{\"28\":1,\"98\":1,\"632\":1}}],[\"finetune\",{\"0\":{\"711\":1},\"1\":{\"299\":1,\"395\":1,\"711\":1}}],[\"finetuning\",{\"1\":{\"275\":1,\"488\":1}}],[\"fine\",{\"0\":{\"10\":1,\"480\":1,\"575\":1,\"778\":1},\"1\":{\"198\":1,\"232\":1,\"233\":1,\"480\":1,\"483\":3,\"488\":1,\"492\":2,\"506\":1,\"528\":1,\"537\":1,\"554\":1,\"575\":1,\"775\":1}}],[\"fake\",{\"1\":{\"840\":4}}],[\"fairseq\",{\"1\":{\"561\":1}}],[\"fast\",{\"1\":{\"577\":2}}],[\"fastai\",{\"1\":{\"577\":1}}],[\"faster\",{\"1\":{\"261\":1,\"386\":1,\"387\":1}}],[\"fast=false\",{\"1\":{\"28\":1}}],[\"far\",{\"1\":{\"214\":2}}],[\"farthest\",{\"1\":{\"92\":8,\"96\":1,\"98\":1}}],[\"fallback\",{\"1\":{\"690\":1}}],[\"falcon等\",{\"1\":{\"192\":1}}],[\"false=未初始化\",{\"1\":{\"169\":1}}],[\"false\",{\"1\":{\"40\":1,\"109\":1,\"142\":3,\"145\":2,\"146\":1,\"163\":2,\"169\":3,\"170\":1,\"186\":1,\"254\":2,\"274\":38,\"327\":1,\"366\":1,\"368\":1,\"398\":1,\"403\":1,\"471\":6,\"477\":1,\"478\":1,\"544\":2,\"688\":2,\"793\":2,\"794\":3,\"814\":8,\"817\":1,\"821\":6,\"822\":7,\"840\":1,\"885\":1,\"886\":1}}],[\"facial\",{\"1\":{\"300\":1}}],[\"face\",{\"1\":{\"274\":1}}],[\"facebook\",{\"1\":{\"247\":1}}],[\"facebookresearch\",{\"1\":{\"172\":1,\"240\":1,\"463\":1}}],[\"factor=args\",{\"1\":{\"463\":2}}],[\"factor=none\",{\"1\":{\"388\":2}}],[\"factor\",{\"1\":{\"59\":3,\"388\":3}}],[\"faucet\",{\"1\":{\"29\":1,\"58\":1,\"68\":1}}],[\"f\",{\"1\":{\"28\":8,\"30\":6,\"33\":4,\"34\":3,\"35\":7,\"36\":21,\"41\":2,\"46\":5,\"59\":58,\"68\":6,\"70\":2,\"73\":2,\"74\":1,\"78\":1,\"82\":1,\"83\":8,\"92\":1,\"93\":3,\"96\":4,\"100\":1,\"101\":2,\"105\":2,\"107\":5,\"109\":2,\"110\":3,\"111\":4,\"145\":11,\"146\":2,\"147\":11,\"161\":8,\"162\":3,\"163\":2,\"169\":1,\"170\":2,\"186\":4,\"272\":2,\"276\":8,\"277\":21,\"278\":7,\"299\":4,\"302\":7,\"303\":4,\"304\":11,\"309\":2,\"310\":2,\"311\":3,\"336\":3,\"340\":2,\"341\":1,\"345\":2,\"346\":2,\"347\":1,\"351\":1,\"352\":8,\"353\":2,\"369\":4,\"423\":2,\"463\":2,\"467\":1,\"468\":3,\"470\":2,\"471\":1,\"476\":3,\"478\":6,\"541\":3,\"544\":2,\"577\":8,\"578\":7,\"581\":3,\"624\":1,\"652\":3,\"665\":4,\"668\":4,\"673\":1,\"676\":1,\"682\":5,\"684\":4,\"686\":8,\"687\":1,\"688\":9,\"689\":2,\"696\":16,\"697\":2,\"793\":2,\"794\":3,\"795\":2,\"796\":1,\"798\":2,\"799\":3,\"815\":4,\"817\":1,\"821\":6,\"822\":3,\"840\":2,\"848\":1,\"852\":1,\"853\":2,\"854\":2,\"856\":1,\"859\":2,\"860\":2,\"861\":1,\"885\":6,\"886\":2}}],[\"france\",{\"1\":{\"616\":2}}],[\"french\",{\"1\":{\"521\":3}}],[\"freeze\",{\"1\":{\"186\":1}}],[\"free\",{\"0\":{\"816\":1},\"1\":{\"178\":1,\"816\":1}}],[\"frequencies\",{\"1\":{\"478\":5}}],[\"frequency\",{\"1\":{\"478\":10}}],[\"freqs\",{\"1\":{\"476\":25,\"477\":2,\"478\":30}}],[\"freq\",{\"1\":{\"159\":1,\"476\":7,\"478\":5,\"803\":1}}],[\"frozen\",{\"1\":{\"309\":1}}],[\"frobenius\",{\"1\":{\"108\":2}}],[\"from=0\",{\"1\":{\"371\":1}}],[\"from\",{\"1\":{\"28\":7,\"31\":2,\"47\":1,\"83\":3,\"107\":1,\"142\":1,\"145\":2,\"147\":2,\"160\":3,\"169\":1,\"232\":1,\"302\":2,\"303\":2,\"304\":8,\"305\":2,\"309\":1,\"316\":2,\"327\":2,\"347\":1,\"370\":1,\"371\":1,\"398\":1,\"399\":1,\"401\":2,\"423\":1,\"478\":6,\"535\":1,\"541\":3,\"544\":5,\"571\":1,\"581\":1,\"594\":2,\"605\":1,\"632\":1,\"691\":7,\"696\":4,\"697\":3,\"765\":1,\"790\":1,\"840\":4,\"848\":4,\"852\":2,\"857\":1,\"886\":1}}],[\"frcnn\",{\"1\":{\"22\":1}}],[\"ftfy\",{\"1\":{\"514\":1}}],[\"ft\",{\"1\":{\"24\":1}}],[\"func函数\",{\"1\":{\"696\":1}}],[\"funcs\",{\"1\":{\"668\":4,\"682\":4,\"684\":4,\"686\":5,\"688\":5,\"696\":5}}],[\"func\",{\"1\":{\"339\":2,\"341\":5,\"343\":3,\"344\":2,\"345\":4,\"346\":6,\"347\":4,\"349\":5,\"350\":3,\"351\":4,\"352\":2,\"353\":11,\"664\":2,\"686\":6,\"688\":3,\"696\":10}}],[\"functools\",{\"1\":{\"274\":1,\"339\":1,\"346\":3}}],[\"function及运算符相关类\",{\"1\":{\"691\":1}}],[\"function引用variable\",{\"1\":{\"687\":1}}],[\"function和variable之间原本存在强引用循环\",{\"1\":{\"687\":1}}],[\"function和variable实例存在循环引用\",{\"1\":{\"687\":1}}],[\"function实例引用输入和输出的variable实例\",{\"1\":{\"687\":1}}],[\"functional\",{\"0\":{\"369\":1},\"1\":{\"78\":1,\"145\":2,\"147\":2,\"160\":2,\"254\":1,\"255\":2,\"388\":1,\"463\":2,\"852\":1}}],[\"function\",{\"1\":{\"28\":2,\"105\":1,\"115\":1,\"252\":1,\"323\":1,\"339\":1,\"385\":1,\"605\":1,\"643\":2,\"647\":1,\"660\":1,\"661\":1,\"664\":1,\"680\":1,\"681\":2,\"686\":2,\"687\":1,\"688\":1,\"690\":6,\"691\":1,\"695\":1,\"696\":1,\"697\":1,\"704\":2,\"727\":1,\"728\":1,\"840\":1,\"860\":1}}],[\"functions\",{\"0\":{\"15\":1},\"1\":{\"691\":1}}],[\"fuse\",{\"1\":{\"148\":2}}],[\"fusion\",{\"0\":{\"14\":1},\"1\":{\"30\":2,\"33\":1,\"34\":3,\"35\":6,\"36\":3,\"40\":1,\"41\":1,\"45\":2,\"59\":2,\"70\":1,\"162\":2,\"163\":2,\"260\":1,\"261\":1,\"262\":1,\"269\":1}}],[\"full\",{\"1\":{\"145\":1,\"163\":3,\"213\":1,\"276\":1,\"277\":1,\"483\":1,\"492\":2,\"562\":1,\"591\":1,\"752\":1,\"818\":1}}],[\"fullattncatblock\",{\"1\":{\"74\":1}}],[\"fool\",{\"1\":{\"840\":1}}],[\"found\",{\"1\":{\"303\":1,\"304\":1,\"316\":1,\"889\":1}}],[\"foundation\",{\"1\":{\"187\":1,\"485\":1,\"545\":1,\"554\":1,\"707\":1}}],[\"folded\",{\"1\":{\"747\":1}}],[\"folders\",{\"1\":{\"4\":1,\"47\":1}}],[\"follow\",{\"1\":{\"533\":1,\"627\":1,\"630\":1}}],[\"following\",{\"1\":{\"232\":2,\"536\":1,\"594\":1}}],[\"focalloss\",{\"1\":{\"470\":2}}],[\"focal\",{\"0\":{\"470\":1},\"1\":{\"15\":1,\"40\":1,\"55\":1,\"78\":6,\"469\":1,\"470\":23}}],[\"forgetting\",{\"1\":{\"483\":1}}],[\"forge\",{\"1\":{\"438\":1}}],[\"fortran\",{\"1\":{\"423\":1}}],[\"foreign\",{\"1\":{\"171\":2}}],[\"format=\",{\"1\":{\"463\":1}}],[\"format\",{\"1\":{\"82\":1,\"316\":5,\"327\":1,\"594\":1,\"686\":1,\"696\":5,\"803\":1}}],[\"former的生成方法\",{\"1\":{\"313\":1}}],[\"former学习\",{\"1\":{\"312\":1}}],[\"former类比为一个self\",{\"1\":{\"309\":1}}],[\"former模块做模态融合\",{\"1\":{\"307\":1}}],[\"former\",{\"1\":{\"40\":1,\"309\":4,\"312\":2,\"313\":3}}],[\"forward\",{\"0\":{\"255\":1},\"1\":{\"30\":1,\"32\":1,\"33\":1,\"34\":2,\"35\":2,\"36\":2,\"40\":1,\"41\":1,\"45\":2,\"46\":1,\"59\":7,\"70\":2,\"72\":3,\"73\":1,\"74\":3,\"75\":1,\"76\":2,\"78\":1,\"92\":1,\"93\":1,\"96\":2,\"98\":1,\"100\":1,\"101\":1,\"107\":1,\"109\":1,\"110\":1,\"111\":1,\"142\":1,\"145\":1,\"146\":1,\"147\":1,\"161\":1,\"162\":1,\"163\":1,\"170\":1,\"186\":2,\"250\":1,\"255\":1,\"272\":5,\"275\":2,\"277\":1,\"278\":1,\"289\":2,\"290\":1,\"291\":1,\"292\":2,\"293\":1,\"295\":3,\"309\":1,\"311\":1,\"312\":5,\"318\":1,\"319\":3,\"320\":3,\"321\":2,\"322\":1,\"323\":3,\"463\":1,\"467\":1,\"468\":1,\"469\":1,\"470\":1,\"471\":1,\"473\":1,\"514\":1,\"544\":5,\"580\":1,\"584\":1,\"590\":1,\"591\":1,\"597\":1,\"599\":3,\"600\":1,\"601\":1,\"602\":1,\"603\":1,\"605\":2,\"606\":1,\"607\":1,\"609\":1,\"610\":1,\"611\":1,\"612\":1,\"615\":1,\"617\":1,\"618\":1,\"622\":1,\"623\":1,\"624\":1,\"626\":1,\"627\":5,\"628\":1,\"630\":6,\"631\":1,\"632\":1,\"643\":3,\"647\":1,\"660\":1,\"675\":1,\"681\":3,\"686\":1,\"688\":1,\"690\":5,\"793\":1,\"794\":2,\"796\":1,\"804\":4,\"815\":1,\"816\":1,\"817\":1,\"821\":2,\"822\":1,\"840\":2,\"848\":3,\"853\":1,\"859\":1,\"885\":4,\"886\":3}}],[\"fork\",{\"1\":{\"29\":1}}],[\"for\",{\"0\":{\"277\":1},\"1\":{\"4\":1,\"29\":3,\"43\":1,\"58\":2,\"59\":2,\"68\":3,\"73\":1,\"80\":2,\"81\":2,\"82\":4,\"83\":1,\"92\":3,\"96\":4,\"100\":2,\"107\":1,\"119\":2,\"134\":1,\"142\":2,\"143\":1,\"145\":6,\"147\":6,\"159\":1,\"162\":7,\"169\":1,\"170\":3,\"171\":2,\"186\":12,\"187\":1,\"240\":2,\"252\":3,\"254\":1,\"255\":1,\"256\":1,\"257\":1,\"272\":2,\"273\":2,\"274\":7,\"275\":5,\"276\":1,\"277\":4,\"278\":6,\"290\":2,\"293\":5,\"300\":1,\"302\":6,\"303\":2,\"304\":8,\"311\":2,\"312\":8,\"316\":9,\"323\":2,\"327\":1,\"336\":4,\"374\":2,\"403\":1,\"463\":2,\"470\":1,\"476\":15,\"477\":5,\"478\":19,\"485\":1,\"486\":1,\"528\":1,\"544\":2,\"577\":4,\"578\":8,\"579\":7,\"580\":2,\"581\":4,\"600\":2,\"605\":5,\"610\":1,\"627\":1,\"628\":1,\"630\":1,\"631\":1,\"632\":1,\"681\":3,\"682\":3,\"684\":2,\"686\":6,\"687\":2,\"688\":8,\"690\":2,\"696\":5,\"697\":2,\"718\":1,\"793\":1,\"801\":3,\"802\":8,\"803\":2,\"804\":1,\"814\":3,\"817\":2,\"820\":2,\"821\":2,\"840\":2,\"848\":4,\"856\":2,\"857\":2,\"860\":2,\"861\":1,\"885\":2,\"886\":7}}],[\"4×4\",{\"1\":{\"801\":1}}],[\"4×3\",{\"1\":{\"427\":2}}],[\"4x4卷积下采样\",{\"1\":{\"793\":1}}],[\"4b\",{\"1\":{\"704\":1}}],[\"4o\",{\"1\":{\"704\":5}}],[\"4个特殊词\",{\"1\":{\"578\":1}}],[\"4次\",{\"1\":{\"562\":2}}],[\"4t\",{\"1\":{\"547\":1,\"548\":2,\"549\":1}}],[\"465953\",{\"1\":{\"697\":1}}],[\"465651\",{\"1\":{\"697\":1}}],[\"465348\",{\"1\":{\"697\":1}}],[\"465046\",{\"1\":{\"697\":1}}],[\"464743\",{\"1\":{\"697\":1}}],[\"464440\",{\"1\":{\"697\":1}}],[\"464137\",{\"1\":{\"697\":1}}],[\"463833\",{\"1\":{\"697\":1}}],[\"4638\",{\"1\":{\"594\":2}}],[\"46\",{\"1\":{\"537\":1}}],[\"4点\",{\"1\":{\"522\":1}}],[\"4监督基线的性能\",{\"1\":{\"522\":1}}],[\"4种不同规模的模型\",{\"1\":{\"521\":1}}],[\"4f\",{\"1\":{\"353\":1,\"848\":1,\"856\":1,\"860\":1,\"885\":2,\"886\":1}}],[\"4替换为相应的类别名称\",{\"1\":{\"316\":1}}],[\"4的视觉能力\",{\"1\":{\"218\":1}}],[\"4k分辨率\",{\"1\":{\"222\":1,\"227\":1}}],[\"4k\",{\"1\":{\"215\":1}}],[\"4v仍有差距\",{\"1\":{\"228\":1}}],[\"4v的\",{\"1\":{\"216\":1}}],[\"4v\",{\"1\":{\"214\":2,\"215\":2,\"216\":2,\"218\":1,\"228\":2,\"230\":1,\"704\":1}}],[\"4c\",{\"1\":{\"198\":1}}],[\"4等\",{\"1\":{\"193\":1}}],[\"404\",{\"1\":{\"889\":1}}],[\"405b\",{\"1\":{\"704\":3}}],[\"40gb文本\",{\"1\":{\"521\":1}}],[\"40图块\",{\"1\":{\"227\":1}}],[\"40区块\",{\"1\":{\"222\":1}}],[\"400m数据\",{\"1\":{\"307\":1}}],[\"400\",{\"1\":{\"198\":1,\"697\":5}}],[\"40\",{\"1\":{\"186\":2,\"215\":1,\"389\":5,\"514\":1,\"537\":1,\"562\":1,\"696\":1,\"766\":1,\"772\":2,\"774\":1}}],[\"406\",{\"1\":{\"186\":1,\"252\":1,\"463\":1}}],[\"4096\",{\"1\":{\"45\":1,\"101\":2}}],[\"4g\",{\"1\":{\"184\":1}}],[\"4423742632\",{\"1\":{\"696\":1}}],[\"4423761088\",{\"1\":{\"696\":1}}],[\"448\",{\"1\":{\"817\":1}}],[\"448px\",{\"1\":{\"223\":3}}],[\"448×448\",{\"1\":{\"215\":1}}],[\"44\",{\"1\":{\"181\":1}}],[\"4️⃣\",{\"0\":{\"75\":1},\"1\":{\"100\":1,\"885\":1}}],[\"416\",{\"1\":{\"65\":1}}],[\"4大小的特征图\",{\"1\":{\"59\":3}}],[\"4960\",{\"1\":{\"594\":2}}],[\"496\",{\"1\":{\"224\":1}}],[\"49\",{\"1\":{\"30\":2,\"34\":6,\"35\":5,\"704\":1}}],[\"4847711968\",{\"1\":{\"696\":2}}],[\"4847712064\",{\"1\":{\"696\":4}}],[\"4847712112\",{\"1\":{\"696\":2}}],[\"4873\",{\"1\":{\"594\":2}}],[\"48层\",{\"1\":{\"196\":1}}],[\"485\",{\"1\":{\"186\":1,\"234\":1,\"252\":1,\"463\":1}}],[\"48\",{\"1\":{\"24\":1,\"302\":1,\"387\":1,\"692\":3,\"696\":1}}],[\"4775983056\",{\"1\":{\"696\":2}}],[\"4788\",{\"1\":{\"594\":2}}],[\"47\",{\"1\":{\"22\":1}}],[\"45层\",{\"1\":{\"222\":1}}],[\"456\",{\"1\":{\"186\":1,\"252\":1,\"463\":1}}],[\"45\",{\"1\":{\"22\":1}}],[\"4e\",{\"1\":{\"10\":1}}],[\"4\",{\"0\":{\"15\":1,\"25\":1,\"65\":1,\"236\":2,\"292\":1,\"320\":1,\"831\":1,\"837\":1,\"855\":1},\"1\":{\"8\":1,\"10\":1,\"22\":1,\"28\":5,\"29\":2,\"30\":1,\"35\":1,\"36\":1,\"40\":1,\"41\":1,\"58\":1,\"59\":28,\"63\":3,\"69\":1,\"76\":2,\"78\":3,\"81\":1,\"82\":2,\"83\":3,\"93\":3,\"96\":3,\"101\":1,\"105\":1,\"142\":3,\"145\":3,\"147\":5,\"157\":1,\"161\":1,\"163\":2,\"179\":1,\"186\":7,\"198\":1,\"199\":2,\"203\":1,\"208\":1,\"219\":1,\"222\":1,\"228\":1,\"232\":1,\"235\":2,\"236\":6,\"252\":5,\"255\":1,\"272\":3,\"273\":1,\"276\":2,\"277\":2,\"295\":4,\"312\":1,\"313\":1,\"322\":1,\"327\":1,\"333\":5,\"355\":3,\"361\":1,\"363\":7,\"364\":4,\"369\":5,\"370\":4,\"373\":2,\"374\":7,\"375\":1,\"376\":1,\"378\":1,\"385\":2,\"387\":6,\"401\":3,\"421\":2,\"422\":2,\"423\":10,\"425\":6,\"426\":7,\"427\":3,\"453\":1,\"463\":1,\"470\":1,\"476\":5,\"494\":1,\"495\":2,\"514\":2,\"515\":1,\"521\":1,\"522\":5,\"527\":1,\"528\":1,\"529\":5,\"530\":1,\"531\":1,\"536\":1,\"537\":2,\"538\":2,\"539\":1,\"541\":1,\"544\":8,\"547\":1,\"548\":3,\"549\":5,\"550\":2,\"559\":1,\"561\":4,\"565\":1,\"575\":1,\"578\":1,\"580\":2,\"581\":2,\"587\":1,\"590\":6,\"591\":10,\"597\":1,\"618\":1,\"632\":1,\"652\":1,\"675\":1,\"676\":1,\"689\":6,\"699\":1,\"704\":26,\"772\":1,\"780\":1,\"802\":3,\"803\":1,\"814\":2,\"815\":1,\"848\":7,\"854\":1,\"857\":1,\"885\":4,\"886\":1}}],[\"4375\",{\"1\":{\"817\":1}}],[\"43类\",{\"1\":{\"17\":1}}],[\"43类物体\",{\"1\":{\"6\":1}}],[\"43\",{\"1\":{\"8\":1,\"22\":1,\"29\":1,\"817\":1}}],[\"最基础的生成模型能够数值计算\",{\"1\":{\"864\":1}}],[\"最基本装饰器\",{\"1\":{\"352\":1}}],[\"最基本的函数装饰器\",{\"0\":{\"343\":1}}],[\"最重要的能力之一\",{\"1\":{\"857\":1}}],[\"最重要的是\",{\"1\":{\"708\":1}}],[\"最便捷的方法是定义一个带参数\",{\"1\":{\"847\":1}}],[\"最好还是使用\",{\"1\":{\"843\":1}}],[\"最好要弄清楚为什么预训练模型会有效\",{\"1\":{\"516\":1}}],[\"最高效的\",{\"1\":{\"816\":1}}],[\"最高支持\",{\"1\":{\"215\":1}}],[\"最多\",{\"1\":{\"809\":1}}],[\"最多尝试10次生成遮挡块\",{\"1\":{\"801\":1}}],[\"最多保留\",{\"1\":{\"92\":1}}],[\"最广泛使用的一元分布是高斯分布\",{\"1\":{\"746\":1}}],[\"最简单的方法是和多分类模型一样\",{\"1\":{\"880\":1}}],[\"最简单的情况是实验的结果是可数的\",{\"1\":{\"727\":1}}],[\"最简单的转置就是将行和列交换\",{\"1\":{\"426\":1}}],[\"最显著的特征之一是它们的\",{\"1\":{\"706\":1}}],[\"最显著的点\",{\"1\":{\"112\":1}}],[\"最强性能\",{\"1\":{\"704\":1}}],[\"最强知识型\",{\"1\":{\"704\":1}}],[\"最早的\",{\"1\":{\"704\":1}}],[\"最快\",{\"1\":{\"704\":1}}],[\"最有说服力的证据就是到目前为止大量使用预训练的词嵌入来提升一系列nlp任务表现\",{\"1\":{\"507\":1}}],[\"最开始三个阶按照\",{\"1\":{\"428\":1}}],[\"最新论文模型\",{\"1\":{\"395\":1}}],[\"最相关的视觉信息\",{\"1\":{\"309\":2}}],[\"最近的一个像素\",{\"1\":{\"389\":1}}],[\"最近的一些工作采用新的模型架构和预训练方法来从文本学习视觉特征\",{\"1\":{\"305\":1}}],[\"最近邻搜索\",{\"1\":{\"885\":1}}],[\"最近邻插值是最简单的一种上采样方法\",{\"1\":{\"389\":1}}],[\"最近邻\",{\"0\":{\"389\":1}}],[\"最近邻分类器\",{\"1\":{\"179\":1}}],[\"最老的那个部分\",{\"1\":{\"249\":1}}],[\"最初\",{\"1\":{\"806\":1}}],[\"最初用于语言模型\",{\"1\":{\"248\":1}}],[\"最初是为了让小模型模仿大模型的输出\",{\"1\":{\"176\":1}}],[\"最具创新性的部分\",{\"1\":{\"232\":1}}],[\"最佳方案是\",{\"1\":{\"134\":1}}],[\"最大似然估计就是求解优化问题\",{\"1\":{\"826\":1}}],[\"最大似然估计是一种利用观测数据反向推断模型参数的方法\",{\"1\":{\"825\":1}}],[\"最大似然估计\",{\"0\":{\"825\":1}}],[\"最大值是\",{\"1\":{\"835\":1}}],[\"最大值\",{\"1\":{\"819\":1}}],[\"最大宽高比\",{\"1\":{\"801\":1}}],[\"最大序列长度\",{\"1\":{\"580\":1}}],[\"最大模型\",{\"1\":{\"521\":1}}],[\"最大\",{\"1\":{\"514\":1}}],[\"最大的\",{\"1\":{\"825\":1}}],[\"最大的参数值为估计结果\",{\"1\":{\"825\":1}}],[\"最大的优点就是上述特定数据领域的表现会好很多\",{\"1\":{\"483\":1}}],[\"最大的resnet模型rn50x64需要在592个v100\",{\"1\":{\"299\":1}}],[\"最大生成长度\",{\"1\":{\"313\":1}}],[\"最大化真实数据的概率\",{\"1\":{\"874\":1}}],[\"最大化来自数据集的图像\",{\"1\":{\"847\":1}}],[\"最大化每个样本中被遮挡位置的预测准确性\",{\"1\":{\"772\":1}}],[\"最大化相似度矩阵对角线的相似度得分\",{\"1\":{\"277\":1}}],[\"最大化正样本的得分\",{\"1\":{\"248\":1}}],[\"最大文本序列长度\",{\"1\":{\"272\":1}}],[\"最大文本长度\",{\"1\":{\"40\":1,\"272\":1}}],[\"最大池化\",{\"1\":{\"115\":1,\"386\":1}}],[\"最远点\",{\"1\":{\"92\":4}}],[\"最远点采样\",{\"1\":{\"92\":2,\"96\":1}}],[\"最贴近实际应用需求\",{\"1\":{\"82\":1}}],[\"最后用下标去嵌入空间里取向量\",{\"1\":{\"880\":1}}],[\"最后把vq\",{\"1\":{\"877\":1}}],[\"最后把所有点的值求平均\",{\"1\":{\"387\":1}}],[\"最后与文本token\",{\"1\":{\"815\":1}}],[\"最后实现较好的泛化效果\",{\"1\":{\"716\":1}}],[\"最后形成完整的模型链路来解决整个业务逻辑\",{\"1\":{\"716\":1}}],[\"最后重新\",{\"1\":{\"618\":1}}],[\"最后返回两个列表\",{\"1\":{\"579\":1}}],[\"最后经\",{\"1\":{\"541\":1}}],[\"最后相加\",{\"1\":{\"492\":1}}],[\"最后得到当前句子对应的token列表\",{\"1\":{\"477\":1}}],[\"最后便是根据注意力掩码矩阵应用在原图像上\",{\"1\":{\"463\":1}}],[\"最后再经过一个线性层映射回原始维度\",{\"1\":{\"415\":1}}],[\"最后再与i\",{\"1\":{\"30\":1}}],[\"最后组合成全局解\",{\"1\":{\"385\":1}}],[\"最后交换第\",{\"1\":{\"318\":1}}],[\"最后的效果才能好\",{\"1\":{\"286\":1}}],[\"最后的归一化层\",{\"1\":{\"272\":1}}],[\"最后和modal\",{\"1\":{\"284\":2}}],[\"最后来看一下\",{\"1\":{\"186\":1}}],[\"最后一项\",{\"1\":{\"868\":1}}],[\"最后一次失败\",{\"1\":{\"741\":1}}],[\"最后一次\",{\"1\":{\"277\":1}}],[\"最后一个维度\",{\"1\":{\"186\":1}}],[\"最后一层\",{\"1\":{\"277\":2}}],[\"最后一层的\",{\"1\":{\"160\":1}}],[\"最后一层输出\",{\"1\":{\"109\":1}}],[\"最后一层抽象特征\",{\"1\":{\"101\":1}}],[\"最后一层使用\",{\"1\":{\"98\":1}}],[\"最后\",{\"1\":{\"128\":1,\"208\":1,\"302\":1,\"516\":1,\"524\":1,\"809\":1,\"870\":1}}],[\"最后将结果转换为\",{\"1\":{\"302\":1}}],[\"最后将每个点的局部特征与整个点云的全局特征拼接起来\",{\"1\":{\"111\":1}}],[\"最后将这两个特征送入解码器以获得可供性输出\",{\"1\":{\"8\":1}}],[\"最后通过两个卷积层输出每个点的分类结果\",{\"1\":{\"101\":1}}],[\"最后通过全连接层完成分类任务\",{\"1\":{\"96\":1}}],[\"最后拼接结果\",{\"1\":{\"96\":1}}],[\"最后加上残差连接形成最终输出\",{\"1\":{\"74\":1}}],[\"最小描述长度\",{\"1\":{\"872\":1}}],[\"最小可行性产品\",{\"1\":{\"717\":1}}],[\"最小值也可能不在梯度反方向\",{\"1\":{\"697\":1}}],[\"最小模型仅1\",{\"1\":{\"522\":1}}],[\"最小模型\",{\"1\":{\"521\":1}}],[\"最小生成长度\",{\"1\":{\"313\":1}}],[\"最小化语言模型输出与真实答案之间的交叉熵损失\",{\"1\":{\"235\":1}}],[\"最小化语言模型输出与真实答案之间的差异\",{\"1\":{\"234\":1}}],[\"最小化图像\",{\"1\":{\"198\":1}}],[\"最小池化\",{\"1\":{\"115\":1}}],[\"最小距离\",{\"1\":{\"92\":1}}],[\"最小\",{\"1\":{\"23\":1,\"801\":1}}],[\"最终需要还原整张图像\",{\"1\":{\"885\":1}}],[\"最终会收敛到公式\",{\"1\":{\"868\":1}}],[\"最终我们要优化的目标是\",{\"1\":{\"868\":1}}],[\"最终图像\",{\"1\":{\"817\":1}}],[\"最终文本\",{\"1\":{\"817\":1}}],[\"最终归一化输出\",{\"1\":{\"804\":1}}],[\"最终要\",{\"1\":{\"801\":1}}],[\"最终总共遮掉\",{\"1\":{\"801\":1}}],[\"最终完成一个能训练分类任务的通用框架\",{\"1\":{\"700\":1}}],[\"最终影响训练结果\",{\"1\":{\"684\":1}}],[\"最终答案就是上下文中这两个位置之间的字符串\",{\"1\":{\"616\":1}}],[\"最终答案是大多数投票的结果\",{\"1\":{\"502\":1}}],[\"最终预测得\",{\"1\":{\"575\":1}}],[\"最终选择full\",{\"1\":{\"562\":1,\"564\":1}}],[\"最终选择了参数约为\",{\"1\":{\"204\":1}}],[\"最终选择了深度48\",{\"1\":{\"197\":1}}],[\"最终演进至transformer架构\",{\"1\":{\"552\":1}}],[\"最终在多个基准测试中超越更大规模的闭源模型\",{\"1\":{\"548\":1}}],[\"最终学习率为峰值10\",{\"1\":{\"548\":1}}],[\"最终所得的instructgpt模型\",{\"1\":{\"534\":1}}],[\"最终结果在公开测试集或开发集上报告\",{\"1\":{\"528\":1}}],[\"最终把复杂问题也解决了\",{\"1\":{\"503\":1}}],[\"最终解出了新的问题\",{\"1\":{\"501\":1}}],[\"最终解码为3d功能热图\",{\"1\":{\"6\":1}}],[\"最终子词频率\",{\"1\":{\"476\":1}}],[\"最终生成一个既能表示常见单词\",{\"1\":{\"475\":1}}],[\"最终都会被映射为一维\",{\"1\":{\"421\":1}}],[\"最终每个\",{\"1\":{\"412\":1,\"614\":1}}],[\"最终每个采样得到的关键点所在的局部领域\",{\"1\":{\"92\":1}}],[\"最终初始化视觉\",{\"1\":{\"260\":1}}],[\"最终准确率达到\",{\"1\":{\"236\":1}}],[\"最终使1\",{\"1\":{\"223\":1}}],[\"最终使用\",{\"1\":{\"46\":1}}],[\"最终实现强大的多模态理解和生成能力\",{\"1\":{\"198\":1}}],[\"最终损失是\",{\"1\":{\"471\":1}}],[\"最终损失函数为\",{\"1\":{\"178\":1}}],[\"最终损失为加权和\",{\"1\":{\"55\":1}}],[\"最终的训练效果也是一般\",{\"1\":{\"582\":1}}],[\"最终的图像输入表示为\",{\"1\":{\"263\":1}}],[\"最终的\",{\"1\":{\"163\":1}}],[\"最终计算\",{\"1\":{\"156\":1}}],[\"最终构建出高质量的自举数据集\",{\"1\":{\"140\":1}}],[\"最终分类头\",{\"1\":{\"101\":1}}],[\"最终回到原始点数量\",{\"1\":{\"98\":1}}],[\"最终得到目标公式\",{\"1\":{\"867\":1}}],[\"最终得到图像\",{\"1\":{\"264\":1}}],[\"最终得到约\",{\"1\":{\"234\":1}}],[\"最终得到\",{\"1\":{\"92\":1,\"591\":1}}],[\"最终取所有样本的\",{\"1\":{\"82\":1}}],[\"最终\",{\"1\":{\"78\":1,\"107\":1,\"300\":1,\"319\":2,\"470\":1,\"559\":1,\"575\":1,\"587\":1,\"591\":1}}],[\"最终通过分类头\",{\"1\":{\"804\":1}}],[\"最终通过这些\",{\"1\":{\"76\":1}}],[\"最终通过卷积操作生成分割掩码\",{\"1\":{\"70\":1}}],[\"最终输出的隐藏向量\",{\"1\":{\"772\":1}}],[\"最终输出的维度是\",{\"1\":{\"409\":1}}],[\"最终输出为\",{\"1\":{\"771\":1}}],[\"最终输出\",{\"1\":{\"111\":1}}],[\"最终输出每个类别的概率分布\",{\"1\":{\"110\":1}}],[\"最终输出高维特征\",{\"1\":{\"109\":1}}],[\"最终输出与点的顺序无关\",{\"1\":{\"105\":1}}],[\"最终输出特征\",{\"1\":{\"100\":1}}],[\"最终输出就是\",{\"1\":{\"96\":1}}],[\"最终输出形状为\",{\"1\":{\"76\":1}}],[\"最终输出融合特征\",{\"1\":{\"73\":1}}],[\"最终输出头\",{\"1\":{\"46\":1}}],[\"最终将融合后的图像特征\",{\"1\":{\"15\":1}}],[\"最终点云融合特征表示为\",{\"1\":{\"14\":1}}],[\"最深层特征\",{\"1\":{\"14\":1}}],[\"见附录图\",{\"1\":{\"538\":1}}],[\"见论文第\",{\"1\":{\"536\":1}}],[\"见论文\",{\"1\":{\"387\":1}}],[\"见表7\",{\"1\":{\"566\":1}}],[\"见表3\",{\"1\":{\"564\":1}}],[\"见表\",{\"1\":{\"528\":2,\"529\":2}}],[\"见表6\",{\"1\":{\"268\":1,\"566\":1}}],[\"见表5\",{\"1\":{\"268\":1,\"566\":2}}],[\"见表4\",{\"1\":{\"268\":1,\"565\":2}}],[\"见表2的参数字段与学习率配置\",{\"1\":{\"547\":1}}],[\"见表2\",{\"1\":{\"216\":1,\"522\":1,\"564\":1}}],[\"见表1的采样比例与磁盘大小\",{\"1\":{\"548\":1}}],[\"见表1\",{\"1\":{\"216\":1,\"564\":1}}],[\"见过\",{\"1\":{\"65\":1}}],[\"见图\",{\"1\":{\"529\":5,\"537\":1,\"807\":1}}],[\"见图3\",{\"1\":{\"222\":1}}],[\"见图2\",{\"1\":{\"216\":1}}],[\"见图1训练损失曲线\",{\"1\":{\"547\":1}}],[\"见图1\",{\"1\":{\"216\":1}}],[\"见图4\",{\"1\":{\"216\":1}}],[\"见图4b\",{\"1\":{\"196\":1}}],[\"见图8\",{\"1\":{\"25\":1}}],[\"见图7\",{\"1\":{\"25\":1}}],[\"见图6\",{\"1\":{\"25\":1}}],[\"见图5\",{\"1\":{\"24\":1}}],[\"见\",{\"1\":{\"8\":3,\"29\":1,\"536\":1,\"539\":2}}],[\"r单独进行重排\",{\"1\":{\"762\":1}}],[\"r的相对顺序不变\",{\"1\":{\"762\":1}}],[\"rv\",{\"1\":{\"727\":1}}],[\"r1看scaling\",{\"1\":{\"718\":1}}],[\"r1\",{\"1\":{\"704\":5}}],[\"rtruediv\",{\"1\":{\"690\":1}}],[\"rte\",{\"1\":{\"566\":1}}],[\"rte数据集比较小\",{\"1\":{\"515\":1}}],[\"rdiv\",{\"1\":{\"690\":2}}],[\"rsub\",{\"1\":{\"690\":8}}],[\"rl\",{\"1\":{\"538\":1,\"703\":1,\"704\":1}}],[\"rlhf\",{\"1\":{\"232\":2,\"535\":1,\"536\":4,\"538\":1,\"539\":5}}],[\"rmsnorm\",{\"1\":{\"704\":1}}],[\"rmul\",{\"1\":{\"690\":6,\"691\":1}}],[\"rm\",{\"1\":{\"535\":1,\"537\":7}}],[\"r=1\",{\"1\":{\"494\":1}}],[\"r就是上述假设中的低维\",{\"1\":{\"487\":1}}],[\"r维\",{\"1\":{\"487\":1}}],[\"rwightman\",{\"1\":{\"327\":1}}],[\"rn50x16和rnx64\",{\"1\":{\"299\":1}}],[\"rn50x4\",{\"1\":{\"299\":1}}],[\"rnn等模型的缺点是需要顺序计算\",{\"1\":{\"621\":1}}],[\"rnn\",{\"1\":{\"105\":1,\"359\":1,\"527\":1,\"552\":1}}],[\"rcnn\",{\"1\":{\"281\":1}}],[\"rudinger\",{\"1\":{\"536\":1}}],[\"rule\",{\"0\":{\"758\":1},\"1\":{\"421\":1,\"729\":2,\"730\":1,\"732\":1,\"758\":2}}],[\"ruppert平均\",{\"1\":{\"182\":1}}],[\"runtime等加速库中可以更好地利用缓存从而提升性能\",{\"1\":{\"426\":1}}],[\"runs\",{\"1\":{\"83\":1}}],[\"run\",{\"1\":{\"29\":7,\"58\":8,\"83\":1,\"439\":1,\"593\":1,\"692\":4,\"696\":1}}],[\"rp\",{\"1\":{\"591\":5}}],[\"rpr\",{\"1\":{\"591\":1}}],[\"rpb\",{\"0\":{\"591\":1},\"1\":{\"591\":2}}],[\"rpe\",{\"0\":{\"589\":1}}],[\"rpo\",{\"0\":{\"76\":1}}],[\"rpd\",{\"1\":{\"70\":1,\"76\":2}}],[\"r^\",{\"1\":{\"72\":2,\"73\":1}}],[\"rb\",{\"1\":{\"68\":2,\"83\":2}}],[\"rb×cp×np\",{\"1\":{\"40\":1}}],[\"rb×ci×h×w\",{\"1\":{\"40\":1}}],[\"rotary\",{\"1\":{\"704\":1,\"814\":7,\"822\":2}}],[\"rosenbrock\",{\"1\":{\"697\":6}}],[\"rosenbrock函数的严格定义是\",{\"1\":{\"697\":1}}],[\"ross\",{\"1\":{\"395\":1}}],[\"rop\",{\"1\":{\"690\":2}}],[\"rope\",{\"1\":{\"548\":2,\"704\":4}}],[\"robustly\",{\"1\":{\"557\":1,\"563\":1}}],[\"roberta在glue\",{\"1\":{\"569\":1}}],[\"roberta在9项任务中全面超越bert和xlnet\",{\"1\":{\"566\":1}}],[\"roberta证明更长训练\",{\"1\":{\"567\":1}}],[\"roberta延长至300k~500k步\",{\"1\":{\"565\":1}}],[\"roberta新增cc\",{\"1\":{\"565\":1}}],[\"roberta增大至8k\",{\"1\":{\"564\":1}}],[\"roberta核心改进总结\",{\"0\":{\"563\":1}}],[\"roberta改用full\",{\"1\":{\"564\":1}}],[\"roberta改用基于字节的bpe\",{\"1\":{\"562\":1}}],[\"roberta改为动态掩码\",{\"1\":{\"562\":1}}],[\"roberta采用8k批次进行训练\",{\"1\":{\"562\":1}}],[\"roberta尝试增大批次至2k和8k\",{\"1\":{\"562\":1}}],[\"roberta对比了多种输入格式\",{\"1\":{\"562\":1}}],[\"roberta的改进表明\",{\"1\":{\"567\":1}}],[\"roberta的改进\",{\"1\":{\"562\":1}}],[\"roberta是一项针对bert预训练方法的优化研究\",{\"1\":{\"558\":1}}],[\"roberta\",{\"0\":{\"557\":1},\"1\":{\"8\":1,\"13\":1,\"30\":1,\"31\":1,\"72\":1,\"557\":2,\"559\":4,\"560\":5,\"561\":5,\"563\":1}}],[\"rouge分数仅略高于随机选句基线\",{\"1\":{\"522\":1}}],[\"round\",{\"1\":{\"389\":1,\"801\":2}}],[\"row\",{\"1\":{\"422\":1,\"423\":1,\"577\":2}}],[\"rocket\",{\"1\":{\"300\":1}}],[\"roc\",{\"0\":{\"449\":1,\"450\":1,\"453\":1},\"1\":{\"82\":4,\"450\":3,\"451\":3,\"452\":1,\"453\":2}}],[\"root\",{\"1\":{\"68\":3,\"83\":3,\"142\":1,\"274\":1,\"302\":2,\"304\":2,\"316\":8}}],[\"root=\",{\"1\":{\"68\":1,\"848\":1,\"855\":1,\"885\":1}}],[\"roipool\",{\"1\":{\"387\":2}}],[\"roipooling\",{\"1\":{\"387\":1}}],[\"roialign目标\",{\"1\":{\"387\":1}}],[\"roialign\",{\"1\":{\"387\":2}}],[\"roi\",{\"0\":{\"386\":1,\"387\":1},\"1\":{\"59\":24,\"386\":15,\"387\":6}}],[\"rag\",{\"0\":{\"709\":1,\"711\":1},\"1\":{\"709\":8,\"710\":1,\"711\":4,\"712\":1,\"718\":1}}],[\"race阅读理解\",{\"1\":{\"566\":1}}],[\"race和squad\",{\"1\":{\"558\":1}}],[\"race数据集由初高中考试题构成\",{\"1\":{\"515\":1}}],[\"race\",{\"1\":{\"506\":1,\"507\":1,\"529\":1,\"559\":1,\"561\":1}}],[\"ram\",{\"1\":{\"421\":1}}],[\"ramp\",{\"1\":{\"147\":1}}],[\"radd\",{\"1\":{\"690\":10,\"691\":1}}],[\"radford\",{\"1\":{\"521\":1,\"552\":1}}],[\"radam\",{\"1\":{\"395\":1}}],[\"radius=none\",{\"1\":{\"93\":1}}],[\"radius=0\",{\"1\":{\"93\":2,\"101\":4}}],[\"radius^2\",{\"1\":{\"92\":1}}],[\"radius\",{\"1\":{\"92\":12,\"96\":7}}],[\"raffel\",{\"1\":{\"552\":1}}],[\"raf\",{\"1\":{\"285\":2}}],[\"ratio\",{\"1\":{\"272\":2,\"320\":1,\"321\":7,\"322\":2,\"323\":4,\"473\":4,\"801\":8}}],[\"ratio=dpr\",{\"1\":{\"323\":1}}],[\"ratio=drop\",{\"1\":{\"321\":1,\"323\":1}}],[\"ratio=attn\",{\"1\":{\"321\":1,\"323\":1}}],[\"ratio=0\",{\"1\":{\"320\":3,\"321\":3,\"322\":2,\"323\":3}}],[\"ratio=mlp\",{\"1\":{\"272\":1,\"323\":1}}],[\"ratio=4\",{\"1\":{\"59\":2,\"160\":2,\"272\":2,\"320\":1,\"321\":1,\"323\":1}}],[\"rate的缩写\",{\"1\":{\"697\":1}}],[\"rate=2e\",{\"1\":{\"593\":1}}],[\"rate=0\",{\"1\":{\"272\":3}}],[\"rate=args\",{\"1\":{\"186\":1}}],[\"rate\",{\"1\":{\"80\":1,\"186\":1,\"272\":8,\"316\":2,\"840\":1}}],[\"raise\",{\"1\":{\"68\":1,\"274\":2,\"316\":1,\"353\":1,\"578\":1,\"643\":1,\"660\":1,\"673\":1,\"681\":2,\"686\":1,\"689\":1,\"802\":1}}],[\"raw=dict\",{\"1\":{\"80\":1,\"83\":1}}],[\"raw\",{\"1\":{\"46\":10,\"59\":6,\"80\":1,\"83\":1,\"276\":2,\"277\":2,\"467\":1,\"468\":1,\"605\":1,\"815\":2}}],[\"rand\",{\"1\":{\"578\":2,\"676\":1}}],[\"randaugment\",{\"1\":{\"395\":1}}],[\"randperm\",{\"0\":{\"375\":1},\"1\":{\"375\":2}}],[\"randn\",{\"1\":{\"145\":2,\"147\":2,\"160\":2,\"169\":1,\"254\":1,\"355\":1,\"361\":1,\"364\":1,\"370\":3,\"378\":1,\"395\":1,\"853\":1,\"857\":1,\"859\":1,\"861\":1}}],[\"randint\",{\"0\":{\"376\":1},\"1\":{\"29\":1,\"68\":1,\"92\":1,\"163\":1,\"376\":2,\"578\":1,\"801\":2}}],[\"randomsampler\",{\"1\":{\"596\":1}}],[\"randomstate\",{\"1\":{\"398\":1}}],[\"randomresizedcropandinterpolationwithtwopic\",{\"1\":{\"802\":1}}],[\"randomresizedcrop\",{\"1\":{\"186\":3,\"252\":1,\"317\":2}}],[\"randomgrayscale\",{\"1\":{\"186\":1,\"252\":1}}],[\"randomapply\",{\"1\":{\"186\":1}}],[\"randomhorizontalflip\",{\"1\":{\"186\":1,\"252\":1,\"317\":1,\"802\":1}}],[\"random\",{\"1\":{\"29\":2,\"58\":1,\"68\":1,\"95\":1,\"163\":5,\"252\":1,\"316\":2,\"398\":4,\"578\":5,\"579\":4,\"676\":1,\"727\":1,\"801\":6,\"840\":1}}],[\"range\",{\"1\":{\"29\":6,\"43\":1,\"58\":4,\"59\":2,\"81\":1,\"82\":2,\"92\":1,\"96\":2,\"142\":1,\"145\":3,\"147\":3,\"162\":2,\"170\":1,\"186\":5,\"252\":1,\"272\":1,\"277\":2,\"278\":5,\"290\":2,\"302\":1,\"304\":1,\"311\":2,\"312\":1,\"316\":2,\"323\":1,\"336\":2,\"463\":2,\"476\":2,\"477\":1,\"478\":3,\"544\":1,\"578\":1,\"579\":2,\"580\":1,\"581\":1,\"600\":1,\"697\":2,\"793\":1,\"801\":3,\"803\":1,\"814\":16,\"815\":2,\"817\":1,\"820\":1,\"821\":1,\"840\":1,\"848\":3,\"856\":1,\"857\":2,\"860\":1,\"861\":1,\"885\":1,\"886\":6}}],[\"ranking\",{\"1\":{\"537\":1}}],[\"rank=0\",{\"1\":{\"273\":1}}],[\"rank=false\",{\"1\":{\"145\":1}}],[\"rank=config\",{\"1\":{\"145\":1}}],[\"rank\",{\"1\":{\"10\":1,\"145\":6,\"278\":8,\"487\":1,\"489\":1,\"491\":1,\"492\":1,\"596\":1}}],[\"rivershavewings\",{\"1\":{\"816\":1}}],[\"riezler\",{\"1\":{\"536\":1}}],[\"rigid\",{\"1\":{\"108\":1,\"116\":1}}],[\"right\",{\"1\":{\"40\":1,\"369\":1,\"630\":1,\"814\":1}}],[\"ride\",{\"1\":{\"29\":1}}],[\"r\",{\"1\":{\"36\":2,\"201\":1,\"202\":1,\"261\":1,\"283\":1,\"386\":2,\"387\":2,\"438\":1,\"476\":3,\"478\":6,\"494\":2,\"537\":3,\"577\":1,\"578\":2,\"590\":12,\"620\":1,\"761\":2,\"763\":1,\"846\":10}}],[\"rgb图像为3\",{\"1\":{\"793\":1}}],[\"rgb图像\",{\"1\":{\"793\":1}}],[\"rgb为彩色图片\",{\"1\":{\"316\":1}}],[\"rgb\",{\"1\":{\"29\":1,\"58\":1,\"114\":1,\"142\":1,\"272\":1,\"302\":1,\"304\":1,\"316\":3,\"318\":1,\"807\":6,\"821\":1,\"846\":2}}],[\"reinmax\",{\"1\":{\"821\":8}}],[\"reinforcement\",{\"1\":{\"232\":1,\"483\":2,\"535\":1}}],[\"reed\",{\"1\":{\"806\":1}}],[\"reject\",{\"1\":{\"539\":1}}],[\"reversed\",{\"1\":{\"821\":1}}],[\"reverse=true\",{\"1\":{\"476\":1,\"478\":1}}],[\"reversible\",{\"1\":{\"814\":4}}],[\"revealed\",{\"1\":{\"59\":1}}],[\"removed\",{\"1\":{\"478\":1}}],[\"remove\",{\"1\":{\"435\":1}}],[\"remote\",{\"1\":{\"28\":2}}],[\"requirements\",{\"1\":{\"438\":2,\"620\":2}}],[\"require\",{\"1\":{\"353\":1}}],[\"requires\",{\"1\":{\"80\":2,\"169\":3,\"186\":1,\"254\":1,\"272\":3,\"327\":1,\"814\":1,\"840\":2}}],[\"reddit\",{\"1\":{\"521\":1,\"561\":1}}],[\"red\",{\"1\":{\"300\":1,\"697\":1}}],[\"reduce\",{\"1\":{\"170\":8}}],[\"reduce=none\",{\"1\":{\"163\":1}}],[\"reduction==\",{\"1\":{\"295\":1}}],[\"reduction=reduction\",{\"1\":{\"295\":1,\"312\":1}}],[\"reduction=\",{\"1\":{\"295\":1,\"312\":1,\"468\":1,\"470\":1,\"794\":1,\"798\":1,\"854\":2}}],[\"reduction\",{\"1\":{\"163\":1,\"312\":1,\"470\":1}}],[\"reward\",{\"1\":{\"232\":2,\"537\":1}}],[\"retain\",{\"1\":{\"688\":3}}],[\"retstep\",{\"1\":{\"332\":1}}],[\"ret\",{\"1\":{\"275\":13,\"276\":7,\"277\":15,\"278\":8,\"591\":5,\"696\":4}}],[\"retrieval\",{\"0\":{\"709\":1},\"1\":{\"145\":4,\"202\":1,\"709\":1,\"718\":1}}],[\"returnfps\",{\"1\":{\"92\":1}}],[\"returnfps=false\",{\"1\":{\"92\":1}}],[\"returns\",{\"1\":{\"43\":1,\"45\":1,\"46\":1,\"83\":2,\"478\":9,\"594\":1}}],[\"return\",{\"1\":{\"28\":4,\"29\":2,\"30\":1,\"32\":1,\"33\":1,\"34\":2,\"35\":2,\"36\":2,\"40\":4,\"41\":1,\"43\":1,\"45\":2,\"46\":1,\"58\":2,\"59\":8,\"68\":3,\"70\":1,\"72\":2,\"73\":1,\"74\":2,\"75\":1,\"76\":2,\"78\":1,\"83\":2,\"92\":13,\"93\":1,\"96\":3,\"98\":1,\"100\":1,\"101\":1,\"107\":1,\"108\":1,\"109\":2,\"110\":1,\"111\":1,\"142\":4,\"143\":3,\"145\":6,\"146\":5,\"147\":7,\"159\":1,\"161\":2,\"162\":2,\"163\":14,\"169\":1,\"170\":3,\"186\":5,\"252\":1,\"255\":1,\"272\":4,\"274\":15,\"275\":4,\"276\":2,\"277\":3,\"278\":1,\"289\":2,\"290\":1,\"291\":1,\"292\":2,\"293\":1,\"295\":5,\"302\":9,\"303\":4,\"304\":13,\"309\":3,\"311\":2,\"312\":10,\"313\":1,\"316\":7,\"318\":2,\"319\":2,\"320\":2,\"321\":2,\"322\":1,\"323\":2,\"327\":1,\"339\":1,\"340\":1,\"341\":2,\"343\":1,\"344\":3,\"345\":4,\"346\":4,\"347\":2,\"348\":1,\"351\":1,\"353\":6,\"372\":6,\"396\":1,\"463\":1,\"467\":1,\"468\":1,\"469\":1,\"470\":1,\"471\":1,\"473\":1,\"476\":7,\"477\":5,\"478\":22,\"544\":9,\"577\":1,\"578\":5,\"579\":2,\"580\":1,\"584\":2,\"590\":1,\"591\":2,\"594\":6,\"596\":1,\"597\":1,\"599\":3,\"600\":1,\"601\":1,\"602\":1,\"603\":1,\"605\":2,\"606\":1,\"607\":1,\"609\":1,\"610\":1,\"611\":1,\"612\":1,\"615\":1,\"617\":1,\"618\":1,\"623\":3,\"624\":1,\"626\":1,\"627\":1,\"628\":1,\"630\":1,\"631\":1,\"632\":2,\"643\":2,\"644\":1,\"647\":2,\"652\":1,\"660\":1,\"661\":1,\"671\":2,\"681\":1,\"686\":1,\"688\":2,\"689\":7,\"690\":24,\"692\":3,\"696\":6,\"697\":2,\"793\":1,\"794\":10,\"801\":2,\"802\":2,\"803\":2,\"804\":6,\"815\":5,\"816\":2,\"817\":3,\"818\":1,\"819\":1,\"820\":1,\"821\":13,\"822\":4,\"840\":3,\"848\":2,\"853\":4,\"854\":1,\"859\":4,\"885\":4,\"886\":3}}],[\"regression\",{\"1\":{\"603\":1}}],[\"register\",{\"0\":{\"366\":1,\"396\":1},\"1\":{\"145\":4,\"147\":3,\"160\":3,\"169\":2,\"170\":3,\"186\":1,\"254\":2,\"312\":1,\"366\":2,\"396\":2,\"814\":1,\"848\":1,\"886\":1}}],[\"region\",{\"1\":{\"59\":1,\"82\":1,\"92\":2,\"279\":2,\"280\":1,\"387\":1}}],[\"regularizer\",{\"1\":{\"108\":3}}],[\"reg\",{\"1\":{\"105\":1}}],[\"recurrent\",{\"1\":{\"843\":1}}],[\"recon\",{\"1\":{\"794\":2,\"821\":2,\"854\":3,\"856\":2,\"857\":4,\"860\":2,\"885\":11,\"886\":2}}],[\"recons\",{\"1\":{\"794\":2,\"821\":2}}],[\"reconstruction\",{\"1\":{\"773\":1,\"857\":1}}],[\"record等任务上表现接近sota\",{\"1\":{\"529\":1}}],[\"recompute\",{\"1\":{\"388\":2}}],[\"recovered\",{\"1\":{\"98\":1}}],[\"recall\",{\"0\":{\"444\":1},\"1\":{\"202\":2,\"471\":1}}],[\"recip\",{\"1\":{\"100\":3}}],[\"receiver\",{\"0\":{\"450\":1},\"1\":{\"82\":1}}],[\"rendering\",{\"1\":{\"103\":1}}],[\"render\",{\"1\":{\"83\":1}}],[\"ref\",{\"1\":{\"687\":1,\"688\":1}}],[\"refers\",{\"1\":{\"277\":1}}],[\"reference\",{\"1\":{\"83\":2,\"781\":1}}],[\"referred\",{\"1\":{\"70\":2,\"76\":3}}],[\"refrigerator\",{\"1\":{\"29\":1,\"58\":1,\"68\":1}}],[\"reparameterization\",{\"1\":{\"868\":1,\"869\":1}}],[\"reparameterize\",{\"1\":{\"853\":2,\"859\":2}}],[\"repr\",{\"1\":{\"689\":1}}],[\"representations\",{\"0\":{\"590\":1}}],[\"representation\",{\"0\":{\"309\":1,\"787\":1},\"1\":{\"148\":2,\"150\":1,\"240\":2,\"309\":3,\"310\":2,\"311\":2,\"320\":1,\"323\":3,\"327\":1,\"571\":1,\"616\":1,\"765\":1,\"790\":1}}],[\"repo\",{\"1\":{\"302\":1,\"304\":1}}],[\"replacement\",{\"1\":{\"403\":1}}],[\"replacement=true\",{\"1\":{\"403\":2}}],[\"replace\",{\"1\":{\"257\":1,\"302\":1,\"304\":1,\"578\":2,\"689\":1}}],[\"replaced\",{\"1\":{\"163\":3}}],[\"repetition\",{\"1\":{\"143\":3,\"313\":1}}],[\"repeated\",{\"1\":{\"363\":1}}],[\"repeat\",{\"0\":{\"363\":1},\"1\":{\"36\":1,\"92\":6,\"100\":1,\"107\":1,\"109\":1,\"143\":1,\"170\":2,\"313\":1,\"363\":7,\"364\":1}}],[\"rephrase\",{\"1\":{\"68\":3}}],[\"relposattention\",{\"1\":{\"590\":1}}],[\"releases\",{\"1\":{\"327\":1}}],[\"rel\",{\"1\":{\"276\":1,\"277\":2,\"590\":12,\"804\":4}}],[\"relative\",{\"0\":{\"589\":1,\"590\":1,\"591\":1},\"1\":{\"272\":10,\"276\":3,\"277\":8,\"591\":26}}],[\"relationship\",{\"1\":{\"611\":4,\"612\":4}}],[\"relation\",{\"1\":{\"59\":3}}],[\"related\",{\"0\":{\"121\":1,\"150\":1,\"248\":1,\"261\":1},\"1\":{\"321\":1}}],[\"relu神经元可自动学习\",{\"1\":{\"385\":1}}],[\"relu\",{\"1\":{\"34\":2,\"35\":3,\"36\":2,\"41\":2,\"42\":1,\"44\":1,\"45\":1,\"46\":2,\"59\":5,\"92\":2,\"93\":2,\"96\":5,\"98\":1,\"100\":4,\"101\":1,\"107\":8,\"109\":2,\"110\":4,\"111\":3,\"700\":1,\"704\":1,\"793\":6,\"821\":3,\"848\":24,\"853\":3,\"859\":2,\"885\":2,\"886\":2}}],[\"re\",{\"1\":{\"29\":1,\"476\":2,\"478\":3}}],[\"real\",{\"1\":{\"840\":5}}],[\"realnews\",{\"1\":{\"704\":1}}],[\"realtoxicityprompts\",{\"1\":{\"537\":1,\"538\":1,\"549\":1,\"551\":1}}],[\"rearrange\",{\"0\":{\"370\":1},\"1\":{\"170\":4,\"370\":7,\"794\":1,\"798\":1,\"814\":2,\"815\":2,\"821\":2,\"822\":1}}],[\"reader\",{\"1\":{\"577\":3}}],[\"ready\",{\"1\":{\"478\":1}}],[\"read\",{\"1\":{\"29\":5,\"58\":4,\"68\":1,\"83\":2,\"316\":1,\"317\":1,\"476\":1,\"477\":1,\"478\":1,\"593\":9}}],[\"reasoning\",{\"0\":{\"11\":1,\"12\":1},\"1\":{\"11\":1,\"12\":1,\"28\":4,\"235\":1,\"237\":1,\"275\":1,\"501\":1,\"502\":1,\"503\":1,\"549\":1}}],[\"resblocks\",{\"1\":{\"821\":2}}],[\"resblock\",{\"1\":{\"793\":3,\"821\":7}}],[\"rescale\",{\"1\":{\"774\":1}}],[\"respectful\",{\"1\":{\"551\":1}}],[\"respectful类毒性分0\",{\"1\":{\"549\":1}}],[\"response\",{\"1\":{\"232\":1,\"537\":1}}],[\"response4\",{\"1\":{\"28\":2}}],[\"response3\",{\"1\":{\"28\":2}}],[\"response2\",{\"1\":{\"28\":2}}],[\"response1\",{\"1\":{\"28\":2}}],[\"restval\",{\"1\":{\"274\":1}}],[\"res\",{\"1\":{\"160\":2}}],[\"resolution\",{\"0\":{\"97\":1},\"1\":{\"94\":1,\"98\":1}}],[\"research\",{\"1\":{\"73\":1,\"327\":1,\"515\":1}}],[\"resid\",{\"1\":{\"544\":1}}],[\"residual\",{\"1\":{\"72\":1,\"74\":1,\"294\":1,\"544\":6,\"622\":1}}],[\"resize\",{\"1\":{\"29\":2,\"58\":2,\"317\":2,\"463\":1,\"840\":1}}],[\"resulting\",{\"1\":{\"478\":1}}],[\"result\",{\"1\":{\"28\":1,\"68\":5,\"341\":2,\"344\":2,\"345\":2,\"351\":2,\"353\":2}}],[\"results\",{\"0\":{\"23\":1},\"1\":{\"81\":1,\"82\":3}}],[\"reshaped\",{\"1\":{\"618\":4}}],[\"reshape后\",{\"1\":{\"34\":1,\"35\":1}}],[\"reshape\",{\"0\":{\"362\":1},\"1\":{\"8\":1,\"34\":2,\"35\":2,\"92\":1,\"107\":1,\"170\":3,\"272\":2,\"293\":1,\"322\":4,\"362\":6,\"398\":1,\"423\":2,\"463\":5,\"544\":1,\"618\":1,\"848\":1}}],[\"resnet和混合模型的效果均不如vit模型\",{\"1\":{\"326\":1}}],[\"resnet和混合模型在不同图像分类数据集上的测试结果\",{\"1\":{\"326\":1}}],[\"resnet101\",{\"1\":{\"299\":1}}],[\"resnet18在图像分类任务中表现出色\",{\"1\":{\"382\":1}}],[\"resnet18是一种深度残差网络\",{\"1\":{\"382\":1}}],[\"resnet18\",{\"0\":{\"382\":1},\"1\":{\"22\":1,\"40\":1,\"59\":1}}],[\"resnet50\",{\"1\":{\"299\":1,\"395\":1,\"396\":1}}],[\"resnet包含五种不同尺寸的模型\",{\"1\":{\"299\":1}}],[\"resnet提取特征\",{\"1\":{\"54\":1}}],[\"resnet\",{\"1\":{\"8\":1,\"173\":1,\"178\":1,\"245\":1,\"254\":1,\"255\":1,\"280\":1,\"299\":1,\"326\":1,\"386\":1,\"395\":1,\"821\":4}}],[\"随着不断迭代\",{\"1\":{\"704\":1}}],[\"随着各阶段计算量的增加\",{\"1\":{\"703\":1}}],[\"随着语言模型规模的扩大\",{\"1\":{\"703\":1}}],[\"随着\",{\"1\":{\"695\":1,\"703\":1}}],[\"随着序列长度的增加\",{\"1\":{\"587\":1}}],[\"随着时代演进\",{\"1\":{\"571\":1}}],[\"随着模型规模扩展\",{\"1\":{\"532\":1}}],[\"随着假负例的减少\",{\"1\":{\"446\":1}}],[\"随着假正例的减少\",{\"1\":{\"446\":1}}],[\"随着训练的进行\",{\"1\":{\"319\":1}}],[\"随着3d数据集\",{\"1\":{\"7\":1}}],[\"随训练进程按余弦调度从\",{\"1\":{\"178\":1}}],[\"随模型保存\",{\"1\":{\"170\":1}}],[\"随后\",{\"1\":{\"223\":1,\"703\":1,\"774\":1,\"806\":1}}],[\"随后线性衰减\",{\"1\":{\"131\":1}}],[\"随后将\",{\"1\":{\"8\":1}}],[\"随机噪声分布\",{\"1\":{\"840\":1}}],[\"随机对输入的文本条件进行\",{\"1\":{\"815\":1}}],[\"随机调整亮度\",{\"1\":{\"802\":1}}],[\"随机水平翻转和双图采样\",{\"1\":{\"802\":1}}],[\"随机单\",{\"1\":{\"801\":1}}],[\"随机掩码约\",{\"1\":{\"766\":1}}],[\"随机\",{\"1\":{\"727\":1,\"741\":1,\"815\":1}}],[\"随机的是它作用的输入\",{\"1\":{\"727\":1}}],[\"随机变量是函数\",{\"1\":{\"727\":1}}],[\"随机变量等于这个值的概率是多少\",{\"1\":{\"727\":1}}],[\"随机变量\",{\"1\":{\"727\":2}}],[\"随机生成等量的非相邻句对\",{\"1\":{\"579\":1}}],[\"随机把一句话中\",{\"1\":{\"572\":1}}],[\"随机高斯分布初始化\",{\"1\":{\"492\":1}}],[\"随机以0\",{\"1\":{\"285\":2}}],[\"随机丢弃整个残差分支\",{\"1\":{\"272\":1}}],[\"随机裁剪\",{\"1\":{\"802\":1}}],[\"随机裁剪输入图像\",{\"1\":{\"317\":1}}],[\"随机裁剪的区域面积\",{\"1\":{\"186\":1}}],[\"随机裁剪区域的最小和最大面积比例\",{\"1\":{\"186\":1}}],[\"随机裁剪区域的相对尺度范围\",{\"1\":{\"186\":1}}],[\"随机裁剪并缩放到\",{\"1\":{\"186\":1}}],[\"随机裁剪图片\",{\"1\":{\"58\":1}}],[\"随机灰度化\",{\"1\":{\"186\":1}}],[\"随机翻转\",{\"1\":{\"186\":1}}],[\"随机初始化\",{\"1\":{\"169\":1,\"209\":1,\"222\":1}}],[\"随机采样时\",{\"1\":{\"878\":1}}],[\"随机采样遮挡块在图像上的左上角位置\",{\"1\":{\"801\":1}}],[\"随机采样遮挡块的长宽比\",{\"1\":{\"801\":1}}],[\"随机采样目标遮挡面积\",{\"1\":{\"801\":1}}],[\"随机采样\",{\"1\":{\"133\":1}}],[\"随机选择\",{\"1\":{\"560\":1}}],[\"随机选择文本序列中的\",{\"1\":{\"265\":1}}],[\"随机选\",{\"1\":{\"68\":1}}],[\"随机配对使模型暴露于各种语义上下文中\",{\"1\":{\"66\":1}}],[\"分工明确\",{\"1\":{\"807\":1}}],[\"分为训练\",{\"1\":{\"593\":1}}],[\"分为三类\",{\"1\":{\"537\":1}}],[\"分为三种响应类型\",{\"1\":{\"235\":1}}],[\"分隔\",{\"1\":{\"575\":1}}],[\"分隔符\",{\"1\":{\"235\":1}}],[\"分层cache\",{\"1\":{\"544\":1}}],[\"分层学习率衰减\",{\"1\":{\"211\":1}}],[\"分解阶段\",{\"1\":{\"503\":1}}],[\"分词器对象\",{\"1\":{\"820\":1}}],[\"分词器的实现较为简单\",{\"1\":{\"578\":1}}],[\"分词器实现\",{\"0\":{\"578\":1}}],[\"分词器完整代码实现\",{\"1\":{\"478\":1}}],[\"分词过程\",{\"0\":{\"477\":1}}],[\"分母中\",{\"1\":{\"471\":1}}],[\"分母中的\",{\"1\":{\"471\":1}}],[\"分母是两者的并集\",{\"1\":{\"469\":1}}],[\"分母累加那里的\",{\"1\":{\"248\":1}}],[\"分子是预测和\",{\"1\":{\"469\":1}}],[\"分成固定数量的\",{\"1\":{\"387\":1}}],[\"分成\",{\"1\":{\"386\":1}}],[\"分治策略\",{\"1\":{\"385\":1}}],[\"分批次预测\",{\"1\":{\"302\":1}}],[\"分批次从图像列表中取出一批图像\",{\"1\":{\"302\":1}}],[\"分数上加偏置\",{\"1\":{\"591\":1}}],[\"分数修正表\",{\"1\":{\"591\":1}}],[\"分数为1\",{\"1\":{\"515\":1}}],[\"分数\",{\"1\":{\"293\":1,\"468\":1,\"591\":1,\"614\":1}}],[\"分数归一化\",{\"1\":{\"45\":1}}],[\"分析规模带来的质变\",{\"1\":{\"552\":1}}],[\"分析表明\",{\"1\":{\"522\":1}}],[\"分析比较2048单元的单层lstm和transformer\",{\"1\":{\"516\":1}}],[\"分析\",{\"0\":{\"516\":1}}],[\"分析能力\",{\"1\":{\"501\":1}}],[\"分析一下\",{\"1\":{\"273\":1}}],[\"分析了不同的参数共享策略对模型性能的影响\",{\"1\":{\"134\":1}}],[\"分开处理文本和图像序列\",{\"1\":{\"272\":1}}],[\"分支下计算\",{\"1\":{\"277\":1}}],[\"分支\",{\"1\":{\"272\":1}}],[\"分阶段预训练\",{\"0\":{\"266\":1}}],[\"分阶段预训练策略利用大规模图像单模态和文本单模态数据\",{\"1\":{\"260\":1}}],[\"分阶段预训练策略\",{\"1\":{\"260\":1}}],[\"分块\",{\"1\":{\"374\":1}}],[\"分块与缩略图\",{\"1\":{\"224\":1}}],[\"分块策略\",{\"1\":{\"219\":1}}],[\"分两步\",{\"1\":{\"210\":1}}],[\"分\",{\"1\":{\"203\":1}}],[\"分离出\",{\"1\":{\"807\":1}}],[\"分离自注意力\",{\"1\":{\"268\":1}}],[\"分离\",{\"1\":{\"186\":1}}],[\"分辨率过高可能略微降低效果\",{\"1\":{\"229\":1}}],[\"分辨率输入\",{\"1\":{\"215\":1}}],[\"分辨率\",{\"1\":{\"186\":2,\"198\":1,\"208\":2,\"211\":1,\"263\":1}}],[\"分配\",{\"1\":{\"170\":1}}],[\"分配权重\",{\"1\":{\"100\":1}}],[\"分割掩码等\",{\"1\":{\"806\":1}}],[\"分割掩码的涌现似乎是自监督方法的普遍属性\",{\"1\":{\"173\":1}}],[\"分割掩码的普遍性与关键条件\",{\"1\":{\"173\":1}}],[\"分割时的量化\",{\"1\":{\"387\":1}}],[\"分割\",{\"1\":{\"196\":1,\"241\":1,\"766\":1,\"780\":1}}],[\"分割等任务\",{\"1\":{\"196\":1}}],[\"分割性能更好\",{\"1\":{\"386\":1}}],[\"分割性能\",{\"1\":{\"112\":1}}],[\"分割精度不高\",{\"1\":{\"112\":1}}],[\"分割任务依赖拼接机制\",{\"1\":{\"112\":1}}],[\"分割任务\",{\"0\":{\"111\":1}}],[\"分割网络\",{\"1\":{\"101\":1}}],[\"分割的整体结构\",{\"1\":{\"98\":1}}],[\"分割出\",{\"1\":{\"40\":1}}],[\"分别对两张图做不同处理\",{\"1\":{\"802\":1}}],[\"分别对应\",{\"1\":{\"792\":1}}],[\"分别对图像和文本做前向推理\",{\"1\":{\"277\":1}}],[\"分别提供基础版\",{\"1\":{\"704\":1}}],[\"分别提取图像特征和文本特征\",{\"1\":{\"299\":1}}],[\"分别提取特征\",{\"1\":{\"96\":1}}],[\"分别适用于不同的场景\",{\"1\":{\"704\":1}}],[\"分别计算答案起始下标和结束下标预测得到的交叉熵损失\",{\"1\":{\"615\":1}}],[\"分别送入不同的\",{\"1\":{\"575\":1}}],[\"分别为更受欢迎和较差的响应\",{\"1\":{\"537\":1}}],[\"分别如下\",{\"1\":{\"309\":1}}],[\"分别基于lenet\",{\"1\":{\"302\":1}}],[\"分别进行多次独立的前向传播完成对应学习任务推进损失的计算\",{\"1\":{\"275\":1}}],[\"分别进行微调\",{\"1\":{\"134\":1}}],[\"分别采用不同的注意力参数对图像\",{\"1\":{\"268\":1}}],[\"分别编码方式比融合编码器推理速度快得多\",{\"1\":{\"267\":1}}],[\"分别编码图像和文本\",{\"1\":{\"267\":1,\"269\":1}}],[\"分别使用视觉或语言专家编码\",{\"1\":{\"264\":1}}],[\"分别在\",{\"1\":{\"211\":1}}],[\"分别记为\",{\"1\":{\"178\":1}}],[\"分别表示真实的\",{\"1\":{\"154\":1}}],[\"分别初始化自\",{\"1\":{\"152\":1}}],[\"分别用于生成和过滤文本\",{\"1\":{\"128\":1}}],[\"分别是编码器和解码器函数\",{\"1\":{\"873\":1}}],[\"分别是文本编码器\",{\"1\":{\"299\":1}}],[\"分别是\",{\"1\":{\"108\":1,\"423\":1}}],[\"分别是最大值和它们的位置索引\",{\"1\":{\"92\":1,\"107\":1,\"109\":1}}],[\"分别从以下角度衡量模型表现\",{\"1\":{\"82\":1}}],[\"分别得到三个从不同视角下计算出来的相似度矩阵\",{\"1\":{\"463\":1}}],[\"分别得到\",{\"1\":{\"8\":1}}],[\"分类作为监督任务\",{\"1\":{\"785\":1}}],[\"分类分布与多项分布\",{\"0\":{\"738\":1}}],[\"分类输出\",{\"1\":{\"580\":1}}],[\"分类结果\",{\"1\":{\"580\":1}}],[\"分类器的参数\",{\"1\":{\"776\":1}}],[\"分类器来预测对应的视觉\",{\"1\":{\"772\":1}}],[\"分类器预测所有可能的候选块\",{\"1\":{\"766\":1}}],[\"分类器共享词嵌入矩阵\",{\"1\":{\"580\":1}}],[\"分类器\",{\"1\":{\"580\":2,\"776\":1}}],[\"分类层使用\",{\"1\":{\"514\":1}}],[\"分类阈值\",{\"1\":{\"446\":1}}],[\"分类标记\",{\"1\":{\"319\":1,\"320\":1,\"323\":1}}],[\"分类累加了\",{\"1\":{\"248\":1}}],[\"分类准备的全连接层\",{\"1\":{\"186\":1}}],[\"分类准确率\",{\"1\":{\"112\":1}}],[\"分类准确率仅下降约\",{\"1\":{\"105\":1}}],[\"分类头\",{\"1\":{\"160\":1,\"323\":1}}],[\"分类损失\",{\"1\":{\"145\":1}}],[\"分类性能\",{\"1\":{\"112\":1,\"173\":1}}],[\"分类性能略逊于多视角方法\",{\"1\":{\"112\":1}}],[\"分类精度略低\",{\"1\":{\"112\":1}}],[\"分类任务是指对输入文本中的每个\",{\"1\":{\"617\":1}}],[\"分类任务的类别数\",{\"1\":{\"319\":1}}],[\"分类任务中对缺失点具有一定鲁棒性\",{\"1\":{\"112\":1}}],[\"分类任务\",{\"0\":{\"110\":1},\"1\":{\"239\":1,\"261\":1,\"700\":1}}],[\"分类类别数\",{\"1\":{\"101\":1}}],[\"分类每个点\",{\"1\":{\"98\":1}}],[\"分类判别能力\",{\"1\":{\"82\":1}}],[\"分类\",{\"1\":{\"82\":1,\"101\":1,\"162\":1,\"465\":1,\"515\":1,\"537\":1,\"780\":1,\"793\":1}}],[\"分类误差\",{\"1\":{\"78\":1,\"473\":1}}],[\"分组并在组内共享键\",{\"1\":{\"704\":2}}],[\"分组查询注意力\",{\"1\":{\"704\":2}}],[\"分组后的文本引导特征\",{\"1\":{\"73\":2}}],[\"分组操作实现了\",{\"1\":{\"72\":1}}],[\"分组\",{\"1\":{\"71\":1}}],[\"分区\",{\"1\":{\"65\":1}}],[\"分布作为输出模型\",{\"1\":{\"873\":1}}],[\"分布越\",{\"1\":{\"829\":1}}],[\"分布逼近\",{\"1\":{\"821\":1}}],[\"分布更加均衡\",{\"1\":{\"800\":1}}],[\"分布采样的噪声\",{\"1\":{\"795\":1,\"819\":1}}],[\"分布的平滑度\",{\"1\":{\"795\":1}}],[\"分布被称为\",{\"1\":{\"749\":1}}],[\"分布上的实验结果\",{\"1\":{\"538\":1}}],[\"分布评估\",{\"1\":{\"537\":1}}],[\"分布是一个\",{\"1\":{\"455\":2}}],[\"分布会更尖锐\",{\"1\":{\"248\":1}}],[\"分布会很平滑\",{\"1\":{\"248\":1}}],[\"分布式收集所有\",{\"1\":{\"278\":1}}],[\"分布式环境充分利用多卡资源\",{\"1\":{\"277\":1}}],[\"分布式环境通过\",{\"1\":{\"277\":1}}],[\"分布式采样器\",{\"1\":{\"274\":1}}],[\"分布式\",{\"1\":{\"273\":1}}],[\"分布式同步\",{\"1\":{\"170\":1}}],[\"分布式训练支持\",{\"1\":{\"170\":1}}],[\"分布之间的\",{\"1\":{\"163\":1}}],[\"分布中采样\",{\"1\":{\"147\":1}}],[\"分布一致性\",{\"1\":{\"82\":1}}],[\"分布\",{\"0\":{\"748\":1},\"1\":{\"41\":2,\"55\":1,\"145\":1,\"748\":2,\"798\":1,\"821\":2,\"837\":1,\"848\":1,\"869\":1}}],[\"分多个步骤\",{\"1\":{\"28\":1}}],[\"分步推理\",{\"1\":{\"6\":1}}],[\"92\",{\"1\":{\"235\":2,\"236\":1}}],[\"914\",{\"1\":{\"234\":1}}],[\"98900063\",{\"1\":{\"697\":1}}],[\"98\",{\"1\":{\"209\":1}}],[\"98b\",{\"1\":{\"198\":1}}],[\"95\",{\"1\":{\"208\":1,\"302\":1}}],[\"9b\",{\"1\":{\"204\":1,\"704\":5,\"756\":1}}],[\"9b参数\",{\"1\":{\"196\":1}}],[\"998\",{\"1\":{\"697\":1}}],[\"997\",{\"1\":{\"697\":1}}],[\"99449622\",{\"1\":{\"697\":1}}],[\"994\",{\"1\":{\"697\":1}}],[\"993\",{\"1\":{\"697\":1}}],[\"992\",{\"1\":{\"697\":1}}],[\"996\",{\"1\":{\"178\":1,\"697\":1}}],[\"99\",{\"1\":{\"169\":1,\"170\":2,\"249\":1,\"443\":1,\"564\":1,\"731\":1}}],[\"995\",{\"1\":{\"145\":1,\"147\":1,\"160\":1,\"697\":1}}],[\"999\",{\"1\":{\"80\":1,\"254\":2,\"697\":1,\"774\":1,\"840\":1}}],[\"960\",{\"1\":{\"582\":1}}],[\"96x96\",{\"1\":{\"186\":1}}],[\"96\",{\"1\":{\"96\":1,\"186\":2,\"199\":1,\"202\":1,\"237\":1}}],[\"9027\",{\"1\":{\"582\":1}}],[\"90\",{\"1\":{\"52\":1,\"112\":1,\"235\":1,\"566\":1,\"703\":1}}],[\"9\",{\"0\":{\"45\":1},\"1\":{\"8\":1,\"22\":1,\"23\":1,\"40\":1,\"59\":1,\"80\":1,\"82\":1,\"107\":4,\"112\":1,\"143\":1,\"145\":3,\"161\":1,\"186\":1,\"198\":1,\"201\":1,\"208\":1,\"209\":1,\"211\":1,\"225\":1,\"276\":2,\"277\":2,\"313\":1,\"369\":4,\"373\":1,\"374\":1,\"376\":1,\"421\":2,\"422\":2,\"423\":1,\"425\":2,\"431\":1,\"470\":1,\"473\":1,\"506\":1,\"507\":1,\"522\":1,\"529\":2,\"537\":1,\"538\":1,\"539\":2,\"541\":1,\"549\":3,\"550\":1,\"561\":1,\"593\":1,\"620\":1,\"689\":1,\"703\":1,\"704\":5,\"714\":1,\"731\":1,\"774\":1,\"793\":1,\"821\":1,\"829\":1,\"858\":1,\"868\":3}}],[\"即此次计算无梯度\",{\"1\":{\"881\":1}}],[\"即先计算向量与嵌入空间\",{\"1\":{\"880\":1}}],[\"即先在大语料上预训练\",{\"1\":{\"531\":1}}],[\"即压缩\",{\"1\":{\"872\":1}}],[\"即出现不连续性\",{\"1\":{\"868\":1}}],[\"即最大化\",{\"1\":{\"854\":1}}],[\"即当前位置\",{\"1\":{\"848\":1}}],[\"即输入图像中哪些像素的信息能够传递到中心像素上\",{\"1\":{\"845\":1}}],[\"即第\",{\"1\":{\"843\":1}}],[\"即寻找使似然函数取得最大值的参数\",{\"1\":{\"826\":1}}],[\"即似然\",{\"1\":{\"825\":1}}],[\"即温度\",{\"1\":{\"811\":1}}],[\"即每一个值被采样到的可能性完全相等\",{\"1\":{\"801\":1}}],[\"即每个图像中每个\",{\"1\":{\"821\":1}}],[\"即每个图像块经过卷积操作后得到的特征向量的维度\",{\"1\":{\"318\":1}}],[\"即每个位置对每个\",{\"1\":{\"591\":1}}],[\"即每个\",{\"1\":{\"170\":1,\"403\":1}}],[\"即每个点的各个类别得分\",{\"1\":{\"111\":1}}],[\"即每个点都有一个类别预测\",{\"1\":{\"101\":1}}],[\"即每个点对应的\",{\"1\":{\"40\":1}}],[\"即每个查询点有一个特征向量\",{\"1\":{\"92\":1}}],[\"即每个局部邻域内的点数量维度\",{\"1\":{\"92\":1}}],[\"即无条件\",{\"1\":{\"815\":1}}],[\"即无法再生成有效遮挡块\",{\"1\":{\"801\":1}}],[\"即无功能区域\",{\"1\":{\"82\":1}}],[\"即是均匀分布\",{\"1\":{\"798\":1}}],[\"即离散编码类别数\",{\"1\":{\"793\":1}}],[\"即离原点越远\",{\"1\":{\"754\":1}}],[\"即不遮挡\",{\"1\":{\"780\":1}}],[\"即约占图像\",{\"1\":{\"774\":1}}],[\"即取视觉令牌的最大概率值\",{\"1\":{\"773\":1}}],[\"即假设\",{\"1\":{\"773\":1}}],[\"即从潜在变量\",{\"1\":{\"871\":1}}],[\"即从被破坏的图像恢复原始图像\",{\"1\":{\"773\":1}}],[\"即从大量候选中选出正确样本\",{\"1\":{\"248\":1}}],[\"即还原被遮挡\",{\"1\":{\"772\":1}}],[\"即求和\",{\"1\":{\"758\":1}}],[\"即确定程度\",{\"1\":{\"758\":1}}],[\"即灰色图像\",{\"1\":{\"756\":1}}],[\"即没有期望值\",{\"1\":{\"749\":1}}],[\"即归一化常数\",{\"1\":{\"749\":1}}],[\"即所谓的标准正态分布\",{\"1\":{\"746\":1}}],[\"即所有实际正例被正确分类为正例的比例\",{\"1\":{\"444\":1}}],[\"即所有\",{\"1\":{\"43\":1}}],[\"即方差小\",{\"1\":{\"746\":1}}],[\"即方差的倒数\",{\"1\":{\"746\":1}}],[\"即蓝球个数\",{\"1\":{\"741\":1}}],[\"即互斥\",{\"1\":{\"729\":1}}],[\"即为事件空间中的每个集合赋予一个\",{\"1\":{\"727\":1}}],[\"即为与当前文本描述相似度最高的那副图片\",{\"1\":{\"303\":1}}],[\"即要开发的应用的应用场景\",{\"1\":{\"717\":1}}],[\"即要分成多少类\",{\"1\":{\"170\":1}}],[\"即后训练阶段的强化学习\",{\"1\":{\"703\":1}}],[\"即学习率\",{\"1\":{\"697\":1}}],[\"即调用\",{\"1\":{\"690\":3}}],[\"即y\",{\"1\":{\"690\":1}}],[\"即y=fn\",{\"1\":{\"656\":1}}],[\"即y=x\",{\"1\":{\"656\":1}}],[\"即正向传播\",{\"1\":{\"686\":1}}],[\"即需要知道正向传播时的输出值\",{\"1\":{\"660\":1}}],[\"即忽略掉pad部分的损失计算\",{\"1\":{\"581\":2}}],[\"即给定一个前提\",{\"1\":{\"575\":1}}],[\"即给定input\",{\"1\":{\"312\":1}}],[\"即完型填空\",{\"1\":{\"571\":1}}],[\"即随机选择\",{\"1\":{\"780\":1}}],[\"即随机遮盖输入文本的部分单词\",{\"1\":{\"562\":1}}],[\"即随机移除一部分输入点\",{\"1\":{\"96\":1}}],[\"即预处理时固定掩码模式\",{\"1\":{\"560\":1}}],[\"即gpt类模型一次推理只输出一个token\",{\"1\":{\"541\":1}}],[\"即对数方差\",{\"1\":{\"853\":1}}],[\"即对不同用户群体可调节输出风格\",{\"1\":{\"539\":1}}],[\"即对点顺序不敏感\",{\"1\":{\"105\":1}}],[\"即便是只有1\",{\"1\":{\"535\":1}}],[\"即便是那些有大量标注数据的场景\",{\"1\":{\"507\":1}}],[\"即标注者和研究者\",{\"1\":{\"535\":1}}],[\"即验证集损失随着模型规模\",{\"1\":{\"531\":1}}],[\"即模型生成的分布\",{\"1\":{\"871\":1}}],[\"即模型输出的每个\",{\"1\":{\"819\":1}}],[\"即模型在\",{\"1\":{\"531\":1}}],[\"即模型对真实类别的预测概率\",{\"1\":{\"470\":1}}],[\"即通过自然语言描述或示例引导模型生成目标输出\",{\"1\":{\"521\":1}}],[\"即通过无监督学习估计文本序列的概率分布\",{\"1\":{\"521\":1}}],[\"即建模\",{\"1\":{\"521\":1}}],[\"即将文本\",{\"1\":{\"813\":1}}],[\"即将原文本按照空格\",{\"1\":{\"476\":1}}],[\"即将掩码矩阵中值为1处\",{\"1\":{\"463\":1}}],[\"即内存地址偏移\",{\"1\":{\"425\":1}}],[\"即形状为\",{\"1\":{\"425\":1}}],[\"即注意力得分\",{\"1\":{\"407\":1}}],[\"即会被保存和加载\",{\"1\":{\"366\":1}}],[\"即网格大小的乘积\",{\"1\":{\"318\":1}}],[\"即图像在水平和垂直方向上分别可以划分的图像块数量\",{\"1\":{\"318\":1}}],[\"即图像特征作为\",{\"1\":{\"143\":1}}],[\"即图片上相邻的区域具有相似的特征\",{\"1\":{\"314\":1}}],[\"即一种先验知识\",{\"1\":{\"314\":1}}],[\"即文本和图像可能不完全匹配\",{\"1\":{\"305\":1}}],[\"即基于对比学习的方法\",{\"1\":{\"305\":1}}],[\"即基于文本弱监督来提升性能\",{\"1\":{\"305\":1}}],[\"即基于动量的对比学习\",{\"1\":{\"244\":1}}],[\"即真正属于一对的文本和图像\",{\"1\":{\"299\":1}}],[\"即上图中橙色和黄色的向量\",{\"1\":{\"575\":1}}],[\"即上图所示的矩阵\",{\"1\":{\"299\":1}}],[\"即上一层级\",{\"1\":{\"97\":1}}],[\"即这些位置不参与\",{\"1\":{\"274\":1}}],[\"即判断某个样本是否是正样本\",{\"1\":{\"248\":1}}],[\"即可得到\",{\"1\":{\"874\":1}}],[\"即可得到极大似然估计的方程\",{\"1\":{\"826\":1}}],[\"即可在多种语言任务中实现从零样本到少样本的泛化\",{\"1\":{\"532\":1}}],[\"即可\",{\"1\":{\"492\":1,\"575\":1}}],[\"即可生成高质量图像描述\",{\"1\":{\"202\":1}}],[\"即可用于生成图像描述\",{\"1\":{\"143\":1}}],[\"即原始图像面积的比例\",{\"1\":{\"186\":1}}],[\"即字典大小\",{\"1\":{\"169\":1}}],[\"即同一个图像可以有多个\",{\"1\":{\"145\":1}}],[\"即在数据预处理阶段生成掩码模式并固定\",{\"1\":{\"562\":1}}],[\"即在预训练阶段让模型隐式学习多种技能\",{\"1\":{\"527\":1}}],[\"即在\",{\"1\":{\"127\":1}}],[\"即在欧氏空间中\",{\"1\":{\"90\":1}}],[\"即只对真实类别对应的概率取负对数\",{\"1\":{\"832\":1}}],[\"即只使用少量编码\",{\"1\":{\"167\":1}}],[\"即只改变物体的方向而不改变形状和大小\",{\"1\":{\"108\":1}}],[\"即只依赖一小部分关键点就能判断整体形状\",{\"1\":{\"105\":1}}],[\"即使我们假设\",{\"1\":{\"871\":1}}],[\"即使最大似然更大\",{\"1\":{\"866\":1}}],[\"即使它们可能有重叠\",{\"1\":{\"729\":1}}],[\"即使计算图不再被用户访问\",{\"1\":{\"687\":1}}],[\"即使参数量远小于\",{\"1\":{\"536\":1}}],[\"即使参数量远小于原始gpt\",{\"1\":{\"534\":1}}],[\"即使1\",{\"1\":{\"522\":1}}],[\"即使是少样本提示增强的\",{\"1\":{\"538\":1}}],[\"即使是gpt\",{\"1\":{\"529\":1}}],[\"即使是最大的1\",{\"1\":{\"522\":1}}],[\"即使是一维位置编码\",{\"1\":{\"320\":1}}],[\"即使外部函数已经执行完毕\",{\"1\":{\"340\":1}}],[\"即使冻结\",{\"1\":{\"198\":1}}],[\"即使冻结llm解码器也能在多模态对话任务中表现优异\",{\"1\":{\"197\":1}}],[\"即使去掉动量编码器\",{\"1\":{\"175\":1}}],[\"即使其他点都在\",{\"1\":{\"112\":1}}],[\"即使\",{\"1\":{\"105\":1,\"453\":1}}],[\"即使丢失一些点或加入异常点\",{\"1\":{\"105\":1}}],[\"即根据最近的几个邻近点的距离进行加权平均\",{\"1\":{\"98\":1}}],[\"即空间中的任何距离值具有相似的含义\",{\"1\":{\"90\":1}}],[\"即任何方向上的度量都是等价的\",{\"1\":{\"90\":1}}],[\"即任务是找到点云集中的局部区域的中心点\",{\"1\":{\"89\":1}}],[\"即生成一个二值掩码\",{\"1\":{\"70\":1}}],[\"即物体支持的交互可能性\",{\"1\":{\"49\":1}}],[\"即\",{\"1\":{\"8\":1,\"76\":1,\"82\":1,\"109\":1,\"112\":1,\"115\":1,\"234\":1,\"274\":1,\"349\":1,\"350\":1,\"443\":1,\"470\":1,\"535\":1,\"573\":1,\"575\":1,\"590\":1,\"615\":1,\"616\":1,\"726\":2,\"727\":1,\"731\":2,\"737\":1,\"739\":1,\"740\":1,\"745\":1,\"768\":1,\"772\":2,\"798\":1,\"799\":1,\"802\":2,\"803\":1,\"807\":1,\"818\":1,\"853\":1,\"854\":1,\"865\":1,\"866\":1,\"871\":1,\"872\":1,\"885\":1}}],[\"为对角矩阵\",{\"1\":{\"868\":1}}],[\"为对应词向量\",{\"1\":{\"263\":1}}],[\"为真实像素值\",{\"1\":{\"854\":1}}],[\"为预测像素点为\",{\"1\":{\"854\":1}}],[\"为预测目标\",{\"1\":{\"790\":1}}],[\"为代表的对概率直接建模的生成模型没有受到过太多的关注\",{\"1\":{\"847\":1}}],[\"为实际图片\",{\"1\":{\"817\":1}}],[\"为实现这一目标\",{\"1\":{\"26\":1}}],[\"为更大模型\",{\"1\":{\"790\":1}}],[\"为纯视觉模型设计了自监督\",{\"1\":{\"789\":1}}],[\"为单位遮挡\",{\"1\":{\"780\":1}}],[\"为视觉\",{\"1\":{\"766\":1,\"772\":1}}],[\"为视觉transformer的自监督预训练提供了新思路\",{\"1\":{\"765\":1}}],[\"为止\",{\"1\":{\"741\":1}}],[\"为归一化常数\",{\"1\":{\"733\":1}}],[\"为定义概率度量\",{\"1\":{\"728\":1}}],[\"为随机变量\",{\"1\":{\"727\":1}}],[\"为简化记号\",{\"1\":{\"727\":1}}],[\"为开发者带来了全面而强大的功能支持\",{\"1\":{\"714\":1}}],[\"为开源社区提供了可复现的基线\",{\"1\":{\"550\":1}}],[\"为模型提供丰富的上下文信息\",{\"1\":{\"709\":1}}],[\"为variable添加shape等属性\",{\"1\":{\"693\":1}}],[\"为variable类添加grad属性\",{\"1\":{\"659\":1}}],[\"为优化算法和神经网络训练奠定基础\",{\"1\":{\"692\":1}}],[\"为将\",{\"1\":{\"691\":1}}],[\"为避免手动修改config属性\",{\"1\":{\"688\":1}}],[\"为避免模型塌缩\",{\"1\":{\"173\":1}}],[\"为function类添加反向传播方法backward\",{\"1\":{\"660\":1}}],[\"为当前批次中的每个序列样本生成一个位置序列\",{\"1\":{\"597\":1}}],[\"为这些方法提供一个更清晰的性能基准\",{\"1\":{\"568\":1}}],[\"为ai研究的民主化提供了重要范例\",{\"1\":{\"553\":1}}],[\"为ai安全和实用性的发展提供了关键路径\",{\"1\":{\"535\":1}}],[\"为缓解对奖励函数的过度优化\",{\"1\":{\"537\":1}}],[\"为缓解此问题\",{\"1\":{\"167\":1}}],[\"为生成类任务\",{\"1\":{\"537\":1}}],[\"为防止泄露隐私\",{\"1\":{\"537\":1}}],[\"为确保训练集与评估集分离\",{\"1\":{\"537\":1}}],[\"为语言模型行为与用户意图之间架起了桥梁\",{\"1\":{\"535\":1}}],[\"为未来的系统化扩展和安全性提升奠定了坚实基础\",{\"1\":{\"714\":1}}],[\"为未来通用语言智能系统的发展提供了重要方向\",{\"1\":{\"532\":1}}],[\"为未来通用语言智能系统奠定了基础\",{\"1\":{\"528\":1}}],[\"为未来探索更通用的ai系统奠定了基础\",{\"1\":{\"520\":1}}],[\"为保证数据质量\",{\"1\":{\"528\":1}}],[\"为残差层数\",{\"1\":{\"521\":1}}],[\"为构建通用语言处理系统提供了新思路\",{\"1\":{\"519\":1}}],[\"为收集更多的标注数据提供了更多一个有价值的替代方案\",{\"1\":{\"507\":1}}],[\"为例\",{\"0\":{\"415\":1},\"1\":{\"477\":1,\"690\":2,\"703\":1}}],[\"为特定任务动态构建了一个分类器\",{\"1\":{\"300\":1}}],[\"为文本\",{\"1\":{\"272\":1}}],[\"为文本长度\",{\"1\":{\"161\":1}}],[\"为可学习温度参数\",{\"1\":{\"265\":1}}],[\"为分词后的长度\",{\"1\":{\"263\":1}}],[\"为通道数\",{\"1\":{\"263\":1}}],[\"为兼顾双编码器和融合编码器的优势\",{\"1\":{\"260\":1}}],[\"为下一阶段的端到端微调提供了良好的初始化\",{\"1\":{\"234\":1}}],[\"为赋予模型高分辨率处理和ocr能力\",{\"1\":{\"223\":1}}],[\"为提升效率\",{\"1\":{\"208\":1}}],[\"为多模态大模型的发展提供了重要贡献\",{\"1\":{\"188\":1}}],[\"为batch\",{\"1\":{\"178\":1}}],[\"为动量参数\",{\"1\":{\"178\":1}}],[\"为训练图像数据集\",{\"1\":{\"167\":1}}],[\"为hidden\",{\"1\":{\"161\":1}}],[\"为主\",{\"1\":{\"159\":1}}],[\"为何前期要让\",{\"1\":{\"159\":1}}],[\"为解决这一问题\",{\"1\":{\"157\":1,\"223\":1,\"535\":1,\"766\":1}}],[\"为每一个padding\",{\"1\":{\"815\":1}}],[\"为每张图像生成\",{\"1\":{\"138\":1}}],[\"为每个位置生成\",{\"1\":{\"819\":1}}],[\"为每个\",{\"1\":{\"591\":1}}],[\"为每个特定任务\",{\"1\":{\"485\":1}}],[\"为每个图像选择一个负样本文本\",{\"1\":{\"311\":1}}],[\"为每个图像选择一个负文本\",{\"1\":{\"278\":1}}],[\"为每个类别创建一个描述性的文本\",{\"1\":{\"300\":1}}],[\"为每个文本选择一个负样本图像\",{\"1\":{\"311\":1}}],[\"为每个文本选择一个负图像\",{\"1\":{\"278\":1}}],[\"为每个文本选择一个最相似的非匹配图像\",{\"1\":{\"156\":1}}],[\"为每个向量找到最近的码本索引\",{\"1\":{\"170\":1}}],[\"为每个原始点\",{\"1\":{\"100\":1}}],[\"为每个中心点找到其邻域内的点\",{\"1\":{\"98\":1}}],[\"为每个尺度构建一个独立的小型\",{\"1\":{\"96\":1}}],[\"为每个关键点构建局部邻域\",{\"1\":{\"92\":1}}],[\"为每个组合额外生成\",{\"1\":{\"63\":1}}],[\"为后续实现神经网络层和优化算法奠定了基础\",{\"1\":{\"690\":1}}],[\"为后续研究\",{\"1\":{\"521\":1}}],[\"为后续研究提供了灵活的基础\",{\"1\":{\"225\":1}}],[\"为后续三维深度学习奠定了基础\",{\"1\":{\"105\":1}}],[\"为后续的神经网络模块与训练机制打下坚实基础\",{\"1\":{\"695\":1}}],[\"为后续的处理步骤提供信息\",{\"1\":{\"97\":1}}],[\"为后续的跨模态交互提供基础\",{\"1\":{\"59\":1}}],[\"为点云\",{\"1\":{\"74\":1}}],[\"为点云坐标\",{\"1\":{\"54\":1}}],[\"为此引入第三方工具graphviz\",{\"1\":{\"696\":1}}],[\"为此\",{\"1\":{\"71\":1,\"97\":1,\"634\":1,\"688\":1,\"866\":1,\"867\":1}}],[\"为功能类别标签\",{\"1\":{\"54\":1}}],[\"为rgb图像\",{\"1\":{\"54\":1}}],[\"为机器人操作\",{\"1\":{\"49\":1}}],[\"为坐标\",{\"1\":{\"35\":1}}],[\"为什么vq\",{\"1\":{\"878\":1}}],[\"为什么这样可行\",{\"1\":{\"866\":1}}],[\"为什么输出的是\",{\"1\":{\"853\":1}}],[\"为什么它能工作\",{\"1\":{\"816\":1}}],[\"为什么先验分布设置为均匀分布\",{\"0\":{\"800\":1}}],[\"为什么高斯样本集中在壳层上\",{\"0\":{\"755\":1}}],[\"为什么答案来自\",{\"1\":{\"616\":1}}],[\"为什么是\",{\"1\":{\"591\":1}}],[\"为什么相对位置矩阵\",{\"1\":{\"590\":1}}],[\"为什么还要乘上\",{\"1\":{\"853\":1}}],[\"为什么还要使用一个移动平均的编码器呢\",{\"1\":{\"245\":1}}],[\"为什么还需要prompt\",{\"1\":{\"497\":1}}],[\"为什么不也用\",{\"1\":{\"493\":1}}],[\"为什么要先用一次\",{\"1\":{\"845\":1}}],[\"为什么要用js散度而不是kl散度\",{\"0\":{\"835\":1}}],[\"为什么要用第一个位置\",{\"1\":{\"575\":1}}],[\"为什么要特殊处理\",{\"1\":{\"802\":1}}],[\"为什么要归一化\",{\"1\":{\"802\":1}}],[\"为什么要做两张图\",{\"1\":{\"802\":1}}],[\"为什么要对大模型进行微调\",{\"0\":{\"482\":1}}],[\"为什么要把它们结合起来\",{\"1\":{\"468\":1}}],[\"为什么要除以\",{\"0\":{\"418\":1}}],[\"为什么\",{\"0\":{\"417\":1}}],[\"为什么函数复合更高效\",{\"1\":{\"385\":1}}],[\"为什么只在分布式环境下启用\",{\"1\":{\"277\":1}}],[\"为什么需要无干扰数据集\",{\"1\":{\"274\":1}}],[\"为什么需要这个正则化项\",{\"1\":{\"108\":1}}],[\"为什么分开\",{\"1\":{\"272\":1}}],[\"为什么第二个分支不直接不更新\",{\"1\":{\"249\":1}}],[\"为什么呢\",{\"1\":{\"249\":1}}],[\"为什么叫做个体判别呢\",{\"1\":{\"243\":1}}],[\"为什么使用队列这种数据结构存储字典呢\",{\"1\":{\"249\":1}}],[\"为什么使用\",{\"1\":{\"62\":1,\"473\":1}}],[\"为什么我们需要pair\",{\"1\":{\"29\":1}}],[\"为什么壶嘴适合倒水\",{\"1\":{\"6\":1}}],[\"为进一步评估模型的理解与泛化能力\",{\"1\":{\"25\":1}}],[\"为验证所提方法\",{\"1\":{\"21\":1}}],[\"为支撑开放词汇\",{\"1\":{\"16\":1}}],[\"为输出头\",{\"1\":{\"15\":1}}],[\"为全连接层\",{\"1\":{\"14\":1}}],[\"为了优化编码器和解码器\",{\"1\":{\"881\":1}}],[\"为了处理离散的输入单词\",{\"1\":{\"878\":1}}],[\"为了能写成\",{\"1\":{\"868\":1}}],[\"为了能够在不同的局部子集上共享权重\",{\"1\":{\"86\":1}}],[\"为了扩展到\",{\"1\":{\"810\":1}}],[\"为了公平比较\",{\"1\":{\"774\":1}}],[\"为了简化计算\",{\"1\":{\"826\":1}}],[\"为了简洁\",{\"1\":{\"727\":1}}],[\"为了简单\",{\"1\":{\"626\":1}}],[\"为了提高训练稳定性\",{\"1\":{\"704\":1}}],[\"为了提升框架的易用性\",{\"1\":{\"690\":1}}],[\"为了提升数据质量\",{\"1\":{\"234\":1}}],[\"为了提升模型对点云姿态变化的鲁棒性\",{\"1\":{\"108\":1}}],[\"为了探索性能的极限\",{\"1\":{\"703\":1}}],[\"为了确保variable实例在混合运算中优先被处理\",{\"1\":{\"690\":1}}],[\"为了让嵌入和编码器以不同的速度优化\",{\"1\":{\"883\":1}}],[\"为了让梯度从解码器传到编码器\",{\"1\":{\"883\":1}}],[\"为了让神经网络理解离散编码\",{\"1\":{\"883\":1}}],[\"为了让\",{\"1\":{\"868\":1}}],[\"为了让模型能生成接近训练数据的样本\",{\"1\":{\"865\":1}}],[\"为了让variable实例支持自然的乘法表达式\",{\"1\":{\"690\":1}}],[\"为了让llm给出的答案更加靠谱\",{\"1\":{\"500\":1}}],[\"为了便于区分和调试\",{\"1\":{\"689\":1}}],[\"为了解决这个不平衡问题\",{\"1\":{\"815\":1}}],[\"为了解决这个问题\",{\"1\":{\"712\":1,\"814\":1}}],[\"为了解决这些问题\",{\"1\":{\"807\":1}}],[\"为了解决这类反向问题\",{\"1\":{\"759\":1}}],[\"为了解决这一问题\",{\"1\":{\"94\":1,\"534\":1,\"878\":1}}],[\"为了解决大型语言模型在生成文本时面临的一系列挑战\",{\"1\":{\"709\":1}}],[\"为了解决上述的问题\",{\"1\":{\"686\":1}}],[\"为了更好地支持多输入函数\",{\"1\":{\"681\":1}}],[\"为了更精确\",{\"1\":{\"386\":1}}],[\"为了方便讨论\",{\"1\":{\"843\":1}}],[\"为了方便使用\",{\"1\":{\"644\":1,\"690\":1}}],[\"为了方便大家理解\",{\"1\":{\"481\":1}}],[\"为了参数更省\",{\"1\":{\"591\":1}}],[\"为了避免每次训练时看到相同的掩码模式\",{\"1\":{\"562\":1}}],[\"为了避免除以零\",{\"1\":{\"469\":1}}],[\"为了衡量模型的\",{\"1\":{\"537\":1}}],[\"为了保证标注质量\",{\"1\":{\"537\":1}}],[\"为了反映这点\",{\"1\":{\"512\":1}}],[\"为了将一个无信息的样本\",{\"1\":{\"872\":1}}],[\"为了将\",{\"1\":{\"469\":1,\"867\":1}}],[\"为了将其作为损失函数使用\",{\"1\":{\"467\":1}}],[\"为了将几何属性与点云特征更好地对齐融合\",{\"1\":{\"14\":1}}],[\"为了充分利用预训练的权重\",{\"1\":{\"317\":1}}],[\"为了弥补数据规模上的差距\",{\"1\":{\"305\":1}}],[\"为了实现随机图像生成\",{\"1\":{\"883\":1}}],[\"为了实现这一点\",{\"1\":{\"683\":1}}],[\"为了实现文字搜索图像的功能\",{\"1\":{\"303\":1}}],[\"为了实现多任务高效预训练\",{\"1\":{\"126\":1}}],[\"为了训练一个能够泛化到多种任务的语言模型\",{\"1\":{\"521\":1}}],[\"为了训练一个既具理解能力又具生成能力的统一模型\",{\"1\":{\"126\":1}}],[\"为了训练好q\",{\"1\":{\"309\":1}}],[\"为了训练clip模型\",{\"1\":{\"299\":1}}],[\"为了模拟用户提问和模型回答的形式\",{\"1\":{\"234\":1}}],[\"为了模仿传统卷积网络中的权重共享机制以提高学习效率和模型的泛化能力\",{\"1\":{\"86\":1}}],[\"为了同时处理多视角图像输入\",{\"1\":{\"186\":1}}],[\"为了验证\",{\"1\":{\"136\":1}}],[\"为了获得对物体可供性更深入的理解\",{\"1\":{\"10\":1}}],[\"为\",{\"1\":{\"8\":1,\"10\":1,\"14\":1,\"15\":1,\"142\":1,\"147\":1,\"263\":1,\"323\":1,\"415\":1,\"423\":1,\"444\":1,\"450\":2,\"451\":4,\"476\":1,\"512\":1,\"537\":1,\"538\":1,\"539\":1,\"685\":1,\"714\":1,\"715\":1,\"727\":1,\"739\":1,\"743\":1,\"755\":1,\"769\":1,\"781\":1,\"796\":1,\"820\":1}}],[\"为图像生成类任务提供了一种新的思路\",{\"1\":{\"877\":1}}],[\"为图像生成合成文本\",{\"1\":{\"140\":1}}],[\"为图像分辨率\",{\"1\":{\"263\":1}}],[\"为图像中主体和物体的边界框\",{\"1\":{\"54\":1}}],[\"为图像\",{\"1\":{\"8\":1}}],[\"可保留局部+空间结构\",{\"1\":{\"885\":1}}],[\"可问题来了\",{\"1\":{\"847\":1}}],[\"可是\",{\"1\":{\"843\":1}}],[\"可加速\",{\"1\":{\"817\":1}}],[\"可加性\",{\"1\":{\"729\":1}}],[\"可微\",{\"1\":{\"795\":1}}],[\"可微分编程\",{\"1\":{\"690\":1,\"692\":1}}],[\"可由补集规则推出\",{\"1\":{\"729\":1}}],[\"可进一步限制事件空间只包含区间\",{\"1\":{\"728\":1}}],[\"可进一步增强性能\",{\"1\":{\"132\":1}}],[\"可数个区间并集交集\",{\"1\":{\"728\":1}}],[\"可组合性\",{\"1\":{\"714\":1}}],[\"可观察性\",{\"1\":{\"714\":1}}],[\"可解释性相对较低\",{\"1\":{\"711\":1}}],[\"可解释性\",{\"1\":{\"711\":1}}],[\"可规避捷径行为\",{\"1\":{\"704\":1}}],[\"可在\",{\"1\":{\"704\":1}}],[\"可在检索任务中执行独立编码\",{\"1\":{\"261\":1}}],[\"可逐渐接近目标位置\",{\"1\":{\"697\":1}}],[\"可直接将数学表达式转译为代码\",{\"1\":{\"692\":1}}],[\"可直接微调\",{\"1\":{\"527\":1}}],[\"可验证tinypytorch框架处理高阶微分的能力\",{\"1\":{\"692\":1}}],[\"可正常转换3为variable\",{\"1\":{\"690\":1}}],[\"可共用同一实现\",{\"1\":{\"690\":1}}],[\"可继续添加ndarray的其他属性\",{\"1\":{\"689\":1}}],[\"可变参数输入与输出列表\",{\"1\":{\"681\":1}}],[\"可将其比作存放数据的\",{\"1\":{\"636\":1}}],[\"可训练\",{\"1\":{\"590\":1}}],[\"可考虑换成\",{\"1\":{\"578\":1}}],[\"可挪到其他地方实现\",{\"1\":{\"578\":1}}],[\"可输出规范代码\",{\"1\":{\"550\":1}}],[\"可复现性\",{\"1\":{\"549\":1}}],[\"可复用\",{\"1\":{\"690\":1}}],[\"可复用共享参数实现文本编码器\",{\"1\":{\"260\":1}}],[\"可复用已有大模型权重\",{\"1\":{\"239\":1}}],[\"可显著降低对齐带来的性能损失\",{\"1\":{\"539\":1}}],[\"可\",{\"1\":{\"538\":1}}],[\"可基本恢复甚至超越\",{\"1\":{\"538\":1}}],[\"可有效缓解\",{\"1\":{\"537\":1}}],[\"可逆tokenizer等设计\",{\"1\":{\"528\":1}}],[\"可表示任意\",{\"1\":{\"521\":1}}],[\"可调性强\",{\"1\":{\"473\":1}}],[\"可调\",{\"1\":{\"470\":1}}],[\"可处理连续值掩码\",{\"1\":{\"468\":1}}],[\"可处理连续概率值\",{\"1\":{\"467\":1}}],[\"可最大限度地提高\",{\"1\":{\"453\":1}}],[\"可使用\",{\"1\":{\"431\":1,\"435\":1}}],[\"可使用成熟的\",{\"1\":{\"114\":1}}],[\"可用计数法则进行理解\",{\"1\":{\"762\":1}}],[\"可用柱状图表示\",{\"1\":{\"727\":1}}],[\"可用于可视化对比\",{\"1\":{\"821\":1}}],[\"可用于\",{\"1\":{\"821\":1}}],[\"可用于图像生成\",{\"1\":{\"785\":1}}],[\"可用于展示tinypytorch计算图\",{\"1\":{\"696\":1}}],[\"可用于梯度检验\",{\"1\":{\"653\":1}}],[\"可用于多头自注意力的图像\",{\"1\":{\"289\":1}}],[\"可用于多头自注意力的文本\",{\"1\":{\"289\":1}}],[\"可用于多模态任务\",{\"1\":{\"239\":1}}],[\"可用来显式指定训练集大小\",{\"1\":{\"398\":1}}],[\"可通过反向传播高效优化\",{\"1\":{\"864\":1}}],[\"可通过反证法证明\",{\"1\":{\"729\":1}}],[\"可通过contextlib模块实现with语句上下文管理\",{\"1\":{\"688\":1}}],[\"可通过禁用反向传播模式进一步节省内存\",{\"1\":{\"688\":1}}],[\"可通过局部神经元\",{\"1\":{\"385\":1}}],[\"可通过训练动态调整\",{\"1\":{\"385\":1}}],[\"可逼近连续但不可微的函数\",{\"1\":{\"385\":1}}],[\"可认为是模型参数一部分\",{\"1\":{\"309\":1}}],[\"可根据需要在单机环境加入\",{\"1\":{\"277\":1}}],[\"可覆盖默认值\",{\"1\":{\"272\":1}}],[\"可手动设置\",{\"1\":{\"272\":1}}],[\"可捕获深层交互\",{\"1\":{\"261\":1}}],[\"可灵活用作融合编码器或双编码器\",{\"1\":{\"260\":1}}],[\"可作为双编码器\",{\"1\":{\"267\":1}}],[\"可作为双编码器用于图文检索\",{\"1\":{\"260\":1}}],[\"可作为独立视觉编码器或与语言中间件结合\",{\"1\":{\"189\":1}}],[\"可学习位置编码\",{\"1\":{\"771\":1}}],[\"可学习位置嵌入\",{\"1\":{\"263\":1,\"320\":1}}],[\"可学习query\",{\"1\":{\"313\":1}}],[\"可学习缩放因子\",{\"1\":{\"272\":1}}],[\"可学习查询和交叉注意力层\",{\"1\":{\"198\":1}}],[\"可学习\",{\"1\":{\"147\":1,\"822\":1}}],[\"可学习的位置编码\",{\"1\":{\"76\":1,\"588\":1}}],[\"可视为一种结构化的知识蒸馏方式\",{\"1\":{\"123\":1}}],[\"可视化生成图像\",{\"1\":{\"857\":1}}],[\"可视化使用\",{\"1\":{\"804\":1}}],[\"可视化结果显示复杂计算图\",{\"1\":{\"696\":1}}],[\"可视化工具封装\",{\"1\":{\"696\":1}}],[\"可视化计算图\",{\"0\":{\"696\":1}}],[\"可视化出每个头对应的注意力热力图\",{\"1\":{\"463\":1}}],[\"可视化示意\",{\"0\":{\"419\":1}}],[\"可视化\",{\"0\":{\"695\":1},\"1\":{\"276\":1,\"886\":1}}],[\"可视化当前物体点云\",{\"1\":{\"83\":1}}],[\"可视化功能区域预测结果\",{\"1\":{\"83\":1}}],[\"可视化支持\",{\"1\":{\"24\":1}}],[\"可视化分析\",{\"1\":{\"23\":1}}],[\"可为什么vq\",{\"1\":{\"878\":1}}],[\"可为\",{\"1\":{\"100\":1}}],[\"可为空字符串\",{\"1\":{\"820\":1}}],[\"可为空\",{\"1\":{\"98\":1}}],[\"可改进的地方\",{\"1\":{\"90\":1}}],[\"可能只有少数必须要计算图像概率分布的任务才会用到\",{\"1\":{\"847\":1}}],[\"可能跟wasserstein距离没啥关系\",{\"1\":{\"841\":1}}],[\"可能对应多个潜在的隐藏状态\",{\"1\":{\"759\":1}}],[\"可能取值的最新信念状态\",{\"1\":{\"758\":1}}],[\"可能取值的概率分布的公式\",{\"1\":{\"758\":1}}],[\"可能缺乏必要的推理能力\",{\"1\":{\"709\":1}}],[\"可能因无法学习长距离依赖\",{\"1\":{\"562\":1}}],[\"可能提升性能\",{\"1\":{\"560\":1}}],[\"可能限制泛化\",{\"1\":{\"550\":1}}],[\"可能遗漏歧义与分歧点\",{\"1\":{\"539\":1}}],[\"可能遗漏重要细节\",{\"1\":{\"112\":1}}],[\"可能影响输出的一致性与代表性\",{\"1\":{\"539\":1}}],[\"可能需要模型具备多偏好条件控制能力\",{\"1\":{\"539\":1}}],[\"可能需要大量神经元\",{\"1\":{\"385\":1}}],[\"可能会带来问题\",{\"1\":{\"871\":1}}],[\"可能会只偏好极少数几个\",{\"1\":{\"800\":1}}],[\"可能会被掩码不同的单词\",{\"1\":{\"562\":1}}],[\"可能会有人这么问\",{\"1\":{\"497\":1}}],[\"可能会导致读不懂代码实现\",{\"1\":{\"271\":1}}],[\"可能更为合适\",{\"1\":{\"453\":1}}],[\"可能以\",{\"1\":{\"385\":1}}],[\"可能输出\",{\"1\":{\"375\":1,\"376\":1}}],[\"可能是被替换的词\",{\"1\":{\"572\":1}}],[\"可能是多任务训练中给\",{\"1\":{\"276\":1}}],[\"可能是经验设定\",{\"1\":{\"78\":1}}],[\"可能导致大模型训练更难收敛\",{\"1\":{\"588\":1}}],[\"可能导致梯度爆炸或梯度消失\",{\"1\":{\"272\":1}}],[\"可能导致样本在高密度区域内过度集中\",{\"1\":{\"89\":1}}],[\"可能采用一个更好的代理任务会取得更好的效果\",{\"1\":{\"247\":1}}],[\"可能不会质疑\",{\"1\":{\"538\":1}}],[\"可能不同维度\",{\"1\":{\"170\":1}}],[\"可能不足以代表复杂的局部结构\",{\"1\":{\"112\":1}}],[\"可能误导主模型\",{\"1\":{\"159\":1}}],[\"可能存在多个正样本\",{\"1\":{\"145\":1}}],[\"可能存在的问题\",{\"1\":{\"89\":1}}],[\"可能无法捕捉重要的几何细节\",{\"1\":{\"89\":1}}],[\"可选部分\",{\"1\":{\"690\":1}}],[\"可选地分开处理方向\",{\"1\":{\"591\":1}}],[\"可选地拼接\",{\"1\":{\"98\":1}}],[\"可选参数\",{\"1\":{\"468\":1,\"469\":1,\"470\":1}}],[\"可选输出张量\",{\"1\":{\"358\":1}}],[\"可选的\",{\"1\":{\"163\":1}}],[\"可选颜色\",{\"1\":{\"114\":1}}],[\"可选属性\",{\"1\":{\"114\":1}}],[\"可选\",{\"0\":{\"113\":1},\"1\":{\"83\":1,\"92\":1,\"109\":1,\"272\":3,\"276\":2,\"277\":2,\"373\":2,\"377\":2,\"467\":1,\"471\":1,\"473\":1,\"490\":1,\"591\":1,\"794\":1,\"798\":1,\"814\":3,\"817\":2,\"821\":1,\"848\":1,\"885\":1,\"886\":1}}],[\"可以正常地训练编码器和解码器了\",{\"1\":{\"881\":1}}],[\"可以被建模为具有某个均值\",{\"1\":{\"871\":1}}],[\"可以被看作是\",{\"1\":{\"492\":1}}],[\"可以移出期望符号\",{\"1\":{\"867\":1}}],[\"可以进行梯度传播\",{\"1\":{\"853\":1}}],[\"可以进行梯度回传进行更新\",{\"1\":{\"250\":1}}],[\"可以视作\",{\"1\":{\"820\":1}}],[\"可以\",{\"1\":{\"815\":1}}],[\"可以拆成\",{\"1\":{\"807\":1}}],[\"可以模拟硬采样\",{\"1\":{\"795\":1}}],[\"可以使大规模图像预训练具备更强的可扩展性\",{\"1\":{\"790\":1}}],[\"可以使模型从输入中学习更抽象的语义信息\",{\"1\":{\"787\":1}}],[\"可以使用训练过程中的变分下界\",{\"1\":{\"869\":1}}],[\"可以使用\",{\"1\":{\"435\":1,\"438\":1}}],[\"可以使用预训练的\",{\"1\":{\"326\":1}}],[\"可以重写为\",{\"1\":{\"773\":1}}],[\"可以重复采样同一样本\",{\"1\":{\"403\":1}}],[\"可以证明这样的函数确实存在\",{\"1\":{\"871\":1}}],[\"可以证明\",{\"1\":{\"740\":1,\"741\":1,\"744\":1}}],[\"可以推导出贝叶斯法则\",{\"1\":{\"732\":1}}],[\"可以充分发挥大语言模型的强大能力\",{\"1\":{\"717\":1}}],[\"可以基本实现目标的\",{\"1\":{\"717\":1}}],[\"可以追溯到具体的数据来源\",{\"1\":{\"711\":1}}],[\"可以根据特定风格或术语调整\",{\"1\":{\"711\":1}}],[\"可以根据图像描述生成合理的文字解释\",{\"1\":{\"234\":1}}],[\"可以达到数十亿甚至数千亿个参数\",{\"1\":{\"705\":1}}],[\"可以保持效果的情况下\",{\"1\":{\"704\":1}}],[\"可以显示部分思维链\",{\"1\":{\"704\":1}}],[\"可以处理简单的计算图\",{\"1\":{\"678\":1}}],[\"可以处理任意顺序的点集\",{\"1\":{\"105\":1}}],[\"可以通过学习上下文来解决少样本任务\",{\"1\":{\"703\":1}}],[\"可以通过连续使用平方函数和指数函数实现\",{\"1\":{\"646\":1}}],[\"可以通过调整这些超参数来进一步优化损失函数的性能\",{\"1\":{\"474\":1}}],[\"可以高效查表\",{\"1\":{\"591\":1}}],[\"可以让模型\",{\"1\":{\"591\":1}}],[\"可以想象成一个小表格\",{\"1\":{\"591\":1}}],[\"可以映射到同一个桶\",{\"1\":{\"591\":1}}],[\"可以把注意力打分看作\",{\"1\":{\"590\":1}}],[\"可以得到未归一化的联合分布\",{\"1\":{\"758\":1}}],[\"可以得到乘法法则\",{\"1\":{\"730\":1}}],[\"可以得到一个简单的结论\",{\"1\":{\"587\":1}}],[\"可以得到每个类别的预测概率\",{\"1\":{\"300\":1}}],[\"可以自发地学习执行任务\",{\"1\":{\"524\":1}}],[\"可以避免传统tokenization的损失\",{\"1\":{\"522\":1}}],[\"可以避免因为输出缓存导致日志卡在某一行不输出的问题\",{\"1\":{\"83\":1}}],[\"可以实现巨大的收益\",{\"1\":{\"506\":1}}],[\"可以实现按行\",{\"1\":{\"425\":1}}],[\"可以用它们来完成生成\",{\"1\":{\"878\":1}}],[\"可以用任意一种cnn架构\",{\"1\":{\"847\":1}}],[\"可以用于多种语言\",{\"1\":{\"705\":1}}],[\"可以用于编码全局信息\",{\"1\":{\"587\":1}}],[\"可以用于训练大型数据集\",{\"1\":{\"382\":1}}],[\"可以用\",{\"1\":{\"493\":1}}],[\"可以阅读这篇论文\",{\"1\":{\"488\":1}}],[\"可以在更快的时间内响应\",{\"1\":{\"704\":1}}],[\"可以在保持对齐的同时维持甚至提升性能\",{\"1\":{\"539\":1}}],[\"可以在保证模型效果的同时\",{\"1\":{\"488\":1}}],[\"可以在下游任务中获得较好的迁移效果\",{\"1\":{\"314\":1}}],[\"可以媲美全量微调的效果了\",{\"1\":{\"488\":1}}],[\"可以引导大模型有更加出色的表现\",{\"1\":{\"486\":1}}],[\"可以参考之前这篇文章\",{\"1\":{\"821\":1}}],[\"可以参考论文\",{\"1\":{\"301\":1}}],[\"可以参见lora\",{\"1\":{\"487\":1}}],[\"可以参见\",{\"1\":{\"485\":1,\"486\":1,\"488\":1}}],[\"可以多个方案一起\",{\"1\":{\"483\":1}}],[\"可以有效控制词汇表大小\",{\"1\":{\"475\":1}}],[\"可以有效避免坍塌\",{\"1\":{\"178\":1}}],[\"可以考虑使用tversky\",{\"1\":{\"474\":1}}],[\"可以不同\",{\"0\":{\"417\":1}}],[\"可以独立于设计\",{\"1\":{\"413\":1}}],[\"可以直接和\",{\"1\":{\"590\":1}}],[\"可以直接加载预训练模型用于\",{\"1\":{\"395\":1}}],[\"可以直接通过类名调用\",{\"1\":{\"316\":1}}],[\"可以采用\",{\"1\":{\"387\":1}}],[\"可以扩展成\",{\"1\":{\"364\":1}}],[\"可以任意重新排列所有维度\",{\"1\":{\"360\":1}}],[\"可以代替多个冒号\",{\"1\":{\"355\":1}}],[\"可以利用其自注意力机制捕捉特征之间的长距离依赖关系\",{\"1\":{\"326\":1}}],[\"可以看作是用理想编码方式构建给定样本\",{\"1\":{\"872\":1}}],[\"可以看出第\",{\"1\":{\"541\":1}}],[\"可以看这篇文章\",{\"1\":{\"322\":1}}],[\"可以看到当epochs增大时\",{\"1\":{\"326\":1}}],[\"可以看到8个图像\",{\"1\":{\"300\":1}}],[\"可以看到对于要预测的8个图像\",{\"1\":{\"300\":1}}],[\"可以看到\",{\"1\":{\"246\":1,\"320\":2,\"321\":1,\"324\":1,\"325\":1,\"573\":1,\"846\":3}}],[\"可以变成一个\",{\"1\":{\"318\":1}}],[\"可以将梯度操作符移入期望内\",{\"1\":{\"868\":1}}],[\"可以将\",{\"1\":{\"713\":1}}],[\"可以将现在的各种大模型通过轻量微调变成各个不同领域的专业模型\",{\"1\":{\"495\":1}}],[\"可以将低秩矩阵\",{\"1\":{\"490\":1}}],[\"可以将规律总结为\",{\"1\":{\"428\":1}}],[\"可以将搜索范围限制在满足这些性质的模型子空间内\",{\"1\":{\"314\":1}}],[\"可以将其平移到坐标系的中心\",{\"1\":{\"86\":1}}],[\"可以和所有的query\",{\"1\":{\"312\":1}}],[\"可以和所有自己的tokens做attention\",{\"1\":{\"312\":1}}],[\"可以和很多代理任务结合\",{\"1\":{\"246\":1}}],[\"可以学习到如何更好地结合文本提取图片信息\",{\"1\":{\"309\":1}}],[\"可以学习更丰富的词汇表达\",{\"1\":{\"157\":1}}],[\"可以概括为以下两个主要步骤\",{\"1\":{\"300\":1}}],[\"可以mask成\",{\"1\":{\"285\":1}}],[\"可以选择跳过\",{\"1\":{\"821\":1}}],[\"可以选择\",{\"1\":{\"274\":1}}],[\"可以同时支持两种不同的应用方式\",{\"1\":{\"269\":1}}],[\"可以设置为\",{\"1\":{\"249\":1}}],[\"可以取得和之前最优的无监督方法相近甚至更好的结果\",{\"1\":{\"245\":1}}],[\"可以借助语义感知监督进行改进\",{\"1\":{\"165\":1}}],[\"可以先去了解一下python中的高级索引机制\",{\"1\":{\"92\":1}}],[\"可以理解为该向量中隐含了一些局部和全局的位置信息\",{\"1\":{\"587\":1}}],[\"可以理解为对多维张量的各个维度\",{\"1\":{\"426\":1}}],[\"可以理解为\",{\"1\":{\"86\":1}}],[\"可以是类别标签\",{\"1\":{\"858\":1}}],[\"可以是\",{\"1\":{\"82\":1,\"178\":1}}],[\"可以确保语言语义不会丢失\",{\"1\":{\"72\":1}}],[\"可以加微信备注来意\",{\"1\":{\"2\":1}}],[\"可见这两句话就不是连续的\",{\"1\":{\"573\":1}}],[\"可见\",{\"1\":{\"49\":1,\"184\":1,\"880\":1,\"883\":1}}],[\"可操作性\",{\"1\":{\"46\":1}}],[\"可操作性热图\",{\"0\":{\"46\":1},\"1\":{\"40\":1}}],[\"可抓握\",{\"1\":{\"29\":1}}],[\"可供性数据集\",{\"1\":{\"26\":1}}],[\"可供性区域的精准定位\",{\"1\":{\"26\":1}}],[\"可供性类别\",{\"1\":{\"17\":1}}],[\"可供性与交互图像直接联系起来\",{\"1\":{\"15\":1}}],[\"可供性预测质量\",{\"1\":{\"22\":1}}],[\"可供性预测\",{\"1\":{\"15\":1}}],[\"可供性意图知识特征\",{\"1\":{\"13\":1}}],[\"可供性标注\",{\"1\":{\"8\":1}}],[\"是为生成任务设计的\",{\"1\":{\"885\":1}}],[\"是为了后续乘上一个最小值\",{\"1\":{\"814\":2}}],[\"是为了增强模型鲁棒性\",{\"1\":{\"802\":1}}],[\"是为了支持任意参数签名\",{\"1\":{\"344\":1}}],[\"是为了把\",{\"1\":{\"313\":1}}],[\"是为了\",{\"1\":{\"186\":2,\"591\":1,\"814\":1}}],[\"是为了在突出\",{\"1\":{\"162\":1}}],[\"是为了扩大负样本池\",{\"1\":{\"161\":1}}],[\"是为了扩展成\",{\"1\":{\"108\":1}}],[\"是其在嵌入空间的最近邻向量\",{\"1\":{\"882\":1}}],[\"是解码器的输入\",{\"1\":{\"881\":1}}],[\"是怎么生成离散编码的\",{\"1\":{\"880\":1}}],[\"是因为图片被编码成了连续向量\",{\"1\":{\"878\":1}}],[\"是二值变量时\",{\"1\":{\"873\":1}}],[\"是二值变量\",{\"1\":{\"873\":1}}],[\"是二分类\",{\"1\":{\"156\":1}}],[\"是连续变量时\",{\"1\":{\"873\":1}}],[\"是连续变量\",{\"1\":{\"873\":1}}],[\"是连接具身智能体感知与操作的关键\",{\"1\":{\"49\":1}}],[\"是我们人为设定的一个值\",{\"1\":{\"873\":1}}],[\"是我们希望最大化的目标\",{\"1\":{\"867\":1}}],[\"是需要手动设置的\",{\"1\":{\"873\":1}}],[\"是固定的\",{\"1\":{\"871\":1}}],[\"是固定不变的\",{\"1\":{\"492\":1}}],[\"是不学习的随机变量\",{\"1\":{\"868\":1}}],[\"是带参数\",{\"1\":{\"868\":1}}],[\"是欧几里得距离的平方\",{\"1\":{\"866\":1}}],[\"是高斯分布\",{\"1\":{\"866\":1}}],[\"是多层神经网络\",{\"1\":{\"866\":1}}],[\"是多头自注意力中每个头切分到的维度\",{\"1\":{\"544\":1}}],[\"是很擅长同时生成一个和原图像长宽相同的张量的\",{\"1\":{\"843\":1}}],[\"是很灵活的\",{\"1\":{\"243\":1}}],[\"是他们的中间点\",{\"1\":{\"837\":1}}],[\"是kl散度\",{\"1\":{\"836\":1}}],[\"是事件\",{\"1\":{\"828\":1}}],[\"是事件空间\",{\"1\":{\"726\":1}}],[\"是单个样本的概率质量\",{\"1\":{\"826\":1}}],[\"是用温度控制\",{\"1\":{\"819\":1}}],[\"是用于信息表达的维度\",{\"1\":{\"417\":1}}],[\"是用于计算相似度的维度\",{\"1\":{\"417\":1}}],[\"是计算\",{\"1\":{\"815\":1}}],[\"是凹函数\",{\"1\":{\"807\":1}}],[\"是潜变量\",{\"1\":{\"807\":1}}],[\"是标准\",{\"1\":{\"807\":1}}],[\"是正则项\",{\"1\":{\"807\":1}}],[\"是正确的\",{\"1\":{\"502\":1}}],[\"是离散分布\",{\"1\":{\"808\":1,\"868\":1}}],[\"是离散变量\",{\"1\":{\"807\":1}}],[\"是离散的\",{\"1\":{\"770\":1}}],[\"是均匀采样\",{\"1\":{\"801\":1}}],[\"是均值为\",{\"1\":{\"865\":1}}],[\"是均值向量\",{\"1\":{\"752\":1}}],[\"是均值\",{\"1\":{\"748\":1}}],[\"是概率\",{\"1\":{\"799\":1}}],[\"是概率度量\",{\"1\":{\"726\":1}}],[\"是第\",{\"1\":{\"795\":1}}],[\"是第一个真正从\",{\"1\":{\"788\":1}}],[\"是第一个transformer模块的input\",{\"1\":{\"309\":1}}],[\"是非负的\",{\"1\":{\"869\":1}}],[\"是非可微的\",{\"1\":{\"795\":1}}],[\"是非常耗成本的\",{\"1\":{\"571\":1}}],[\"是非常重要的\",{\"1\":{\"487\":1}}],[\"是许多多模态生成模型的关键组成\",{\"1\":{\"789\":1}}],[\"是许多早期vlp模型的标准做法\",{\"1\":{\"280\":1}}],[\"是自然语言处理中最成功的预训练目标之一\",{\"1\":{\"772\":1}}],[\"是设定的遮挡比例\",{\"1\":{\"772\":1}}],[\"是随机选中的掩码位置集合\",{\"1\":{\"772\":1}}],[\"是随机初始化的\",{\"1\":{\"199\":2}}],[\"是分类器的权重矩阵\",{\"1\":{\"776\":1}}],[\"是分类器的参数\",{\"1\":{\"772\":1}}],[\"是分布的均值\",{\"1\":{\"737\":1}}],[\"是损坏后的图像输入\",{\"1\":{\"772\":1}}],[\"是如何产生的\",{\"1\":{\"759\":1}}],[\"是真实数据的概率\",{\"1\":{\"840\":1}}],[\"是真实标签\",{\"1\":{\"470\":1}}],[\"是真的\",{\"1\":{\"758\":1}}],[\"是已知的固定值\",{\"1\":{\"758\":1}}],[\"是相关系数\",{\"1\":{\"752\":1}}],[\"是beta\",{\"1\":{\"748\":1}}],[\"是gamma\",{\"1\":{\"748\":1}}],[\"是尺度参数\",{\"1\":{\"748\":1}}],[\"是归一化常数\",{\"1\":{\"746\":1}}],[\"是实数\",{\"1\":{\"742\":1}}],[\"是该分布的均值\",{\"1\":{\"739\":1}}],[\"是从一个任意分布\",{\"1\":{\"867\":1}}],[\"是从\",{\"1\":{\"737\":1,\"795\":1,\"810\":1}}],[\"是整个贝叶斯推断的核心\",{\"1\":{\"734\":1}}],[\"是独立事件\",{\"1\":{\"730\":1}}],[\"是你允许讨论的事件的全集合\",{\"1\":{\"728\":1}}],[\"是你输入的问题\",{\"1\":{\"414\":1}}],[\"是所有让\",{\"1\":{\"727\":1}}],[\"是前两代\",{\"1\":{\"704\":1}}],[\"是专为复杂推理设计的模型\",{\"1\":{\"704\":1}}],[\"是验证框架能力的理想案例\",{\"1\":{\"692\":1}}],[\"是包含交叉项的二维函数\",{\"1\":{\"692\":1}}],[\"是简单的平方和函数\",{\"1\":{\"692\":1}}],[\"是编码器的输出向量\",{\"1\":{\"882\":1}}],[\"是编码器模型\",{\"1\":{\"616\":1}}],[\"是编码空间的总维度\",{\"1\":{\"587\":1}}],[\"是答案终点的得分\",{\"1\":{\"614\":1}}],[\"是答案起点的得分\",{\"1\":{\"614\":1}}],[\"是模型预测出的答案的起始和结束位置\",{\"1\":{\"616\":1}}],[\"是模型预测的概率\",{\"1\":{\"470\":1}}],[\"是模型最后一层所有\",{\"1\":{\"614\":1}}],[\"是序列实际长度\",{\"1\":{\"594\":1}}],[\"是序列长度\",{\"1\":{\"410\":1}}],[\"是在\",{\"1\":{\"591\":1,\"846\":1}}],[\"是在张量\",{\"1\":{\"427\":1}}],[\"是查询位置到键位置的相对距离\",{\"1\":{\"591\":1}}],[\"是和相对距离\",{\"1\":{\"590\":1}}],[\"是没有任何实际意义的\",{\"1\":{\"575\":1}}],[\"是没有一个单独的编码器\",{\"1\":{\"250\":1}}],[\"是什么\",{\"0\":{\"571\":1},\"1\":{\"853\":1}}],[\"是对bert预训练过程的系统性优化\",{\"1\":{\"563\":1}}],[\"是对称的\",{\"1\":{\"105\":1,\"752\":1}}],[\"是历史缓存\",{\"1\":{\"544\":1}}],[\"是系统性地探索\",{\"1\":{\"531\":1}}],[\"是目前元学习方法的一个重要限制\",{\"1\":{\"530\":1}}],[\"是蕴含\",{\"1\":{\"515\":1}}],[\"是位置嵌入矩阵\",{\"1\":{\"510\":1}}],[\"是字符嵌入矩阵\",{\"1\":{\"510\":1}}],[\"是层数\",{\"1\":{\"510\":1}}],[\"是参数\",{\"1\":{\"510\":1}}],[\"是上下文字符向量\",{\"1\":{\"510\":1}}],[\"是上下文窗口大小\",{\"1\":{\"510\":1}}],[\"是上一个时刻的输出\",{\"1\":{\"244\":1}}],[\"是人类发给各种人工智能模型\",{\"1\":{\"497\":1}}],[\"是训练参数\",{\"1\":{\"492\":1}}],[\"是预训练模型初始化的参数\",{\"1\":{\"492\":1}}],[\"是预测的概率值\",{\"1\":{\"470\":1}}],[\"是预测值与真实值之间的平均绝对误差\",{\"1\":{\"82\":1}}],[\"是低秩的秩\",{\"1\":{\"490\":1}}],[\"是影响大模型生成结果的关键参数\",{\"1\":{\"487\":1}}],[\"是基座模型\",{\"1\":{\"485\":1}}],[\"是基于对话聊天的\",{\"1\":{\"708\":1}}],[\"是基于基座模型开发出来的\",{\"1\":{\"704\":1}}],[\"是基于文本输入来生成图像的模型\",{\"1\":{\"297\":1}}],[\"是基于\",{\"1\":{\"295\":1}}],[\"是能够在可控成本的前提下\",{\"1\":{\"483\":1}}],[\"是交叉熵和\",{\"1\":{\"473\":1}}],[\"是两种主流的方法\",{\"1\":{\"711\":1}}],[\"是两种用于提升预训练语言模型\",{\"1\":{\"239\":1}}],[\"是两个广泛用于语言模型训练和评估的英文维基百科语料数据集\",{\"1\":{\"577\":1}}],[\"是两个可调节的超参数\",{\"1\":{\"471\":1}}],[\"是衡量两个样本集合之间重叠程度的一种指标\",{\"1\":{\"467\":1}}],[\"是它的逆矩阵\",{\"1\":{\"459\":1}}],[\"是样本空间\",{\"1\":{\"726\":1}}],[\"是样本协方差矩阵\",{\"1\":{\"459\":1}}],[\"是样本数\",{\"1\":{\"170\":1}}],[\"是协方差矩阵的逆\",{\"1\":{\"458\":1}}],[\"是比较两个不同模型性能的有效衡量指标\",{\"1\":{\"453\":1}}],[\"是按选定的间隔\",{\"1\":{\"450\":1}}],[\"是数据向量\",{\"1\":{\"752\":1}}],[\"是数据的协方差矩阵\",{\"1\":{\"458\":1}}],[\"是数据库中的内容\",{\"1\":{\"414\":1}}],[\"是数据库中的索引\",{\"1\":{\"414\":1}}],[\"是数学和物理学中用于表示多维数组的一个概念\",{\"1\":{\"421\":1}}],[\"是特征图相对于原图的缩放比例\",{\"1\":{\"386\":1}}],[\"是原张量的一个视图\",{\"1\":{\"361\":1}}],[\"是闭包\",{\"1\":{\"341\":1,\"343\":1}}],[\"是hidden\",{\"1\":{\"324\":1}}],[\"是通道数\",{\"1\":{\"318\":1,\"769\":1}}],[\"是通过\",{\"1\":{\"145\":1}}],[\"是批量大小\",{\"1\":{\"318\":1}}],[\"是卷积核的步长\",{\"1\":{\"318\":1}}],[\"是卷积核的大小\",{\"1\":{\"318\":1}}],[\"是输入一幅图像的前\",{\"1\":{\"843\":1}}],[\"是输入图像尺寸\",{\"1\":{\"769\":1}}],[\"是输入张量\",{\"1\":{\"370\":1}}],[\"是输入通道数\",{\"1\":{\"318\":1}}],[\"是输出通道数\",{\"1\":{\"318\":1}}],[\"是动量超参数\",{\"1\":{\"244\":1}}],[\"是引导模型\",{\"1\":{\"239\":1}}],[\"是教会模型\",{\"1\":{\"239\":1}}],[\"是由深度求索\",{\"1\":{\"704\":1}}],[\"是由单词词缀组成的\",{\"1\":{\"246\":1}}],[\"是由\",{\"1\":{\"232\":1,\"840\":1}}],[\"是主流选择\",{\"1\":{\"220\":1}}],[\"是温度参数\",{\"1\":{\"178\":1,\"795\":1}}],[\"是维度数\",{\"1\":{\"753\":1}}],[\"是维度\",{\"1\":{\"170\":1}}],[\"是当前最简单\",{\"1\":{\"816\":1}}],[\"是当前最具代表性的通用多模态基础模型之一\",{\"1\":{\"205\":1}}],[\"是当前文本对应的类别标签\",{\"1\":{\"594\":1}}],[\"是当前时刻的输入\",{\"1\":{\"244\":1}}],[\"是当前\",{\"1\":{\"145\":1}}],[\"是当前规模最大的同类数据集\",{\"1\":{\"16\":1}}],[\"是严格的一对一\",{\"1\":{\"145\":1}}],[\"是每个图像区域\",{\"1\":{\"885\":1}}],[\"是每个图像对应的索引编号\",{\"1\":{\"145\":1}}],[\"是每个\",{\"1\":{\"769\":1}}],[\"是每个点的高维特征\",{\"1\":{\"105\":1}}],[\"是每个点云局部区域关键点引导下提取的图像信息增强后的点云关键点局部区域特征\",{\"1\":{\"41\":1}}],[\"是指生成过程中的隐藏决策\",{\"1\":{\"865\":1}}],[\"是指示函数\",{\"1\":{\"738\":1}}],[\"是指我们为了让llm能够更好地完成我们给它的任务\",{\"1\":{\"497\":1}}],[\"是指用于训练模型的参数非常多\",{\"1\":{\"481\":1}}],[\"是指被错误地归类为正例的所有实际负例所占的比例\",{\"1\":{\"445\":1}}],[\"是指位置嵌入的参数是可以在模型训练过程中通过反向传播算法进行更新的\",{\"1\":{\"320\":1}}],[\"是指\",{\"1\":{\"116\":1,\"758\":1,\"871\":1}}],[\"是最具挑战也最通用的形式\",{\"1\":{\"528\":1}}],[\"是最大可容忍的点云范围\",{\"1\":{\"105\":1}}],[\"是最终的\",{\"1\":{\"15\":1}}],[\"是关键点集合\",{\"1\":{\"105\":1}}],[\"是后续的全连接网络\",{\"1\":{\"105\":1}}],[\"是类别数\",{\"1\":{\"98\":1,\"776\":1,\"832\":1}}],[\"是无缓存的\",{\"1\":{\"83\":1}}],[\"是有一个先验分布\",{\"1\":{\"773\":1}}],[\"是有局限的\",{\"1\":{\"539\":1}}],[\"是有缓存的\",{\"1\":{\"83\":1}}],[\"是有效的\",{\"1\":{\"43\":1}}],[\"是否存在一种类似于手动控制模型约束程度的机制\",{\"1\":{\"870\":1}}],[\"是否拥有类似于稀疏自编码器中稀疏性惩罚项那样的\",{\"1\":{\"870\":1}}],[\"是否理解它对理解vq\",{\"1\":{\"878\":1}}],[\"是否理解\",{\"1\":{\"820\":1}}],[\"是否真正学会了语言建模部分\",{\"1\":{\"820\":1}}],[\"是否提前中断返回\",{\"1\":{\"815\":1}}],[\"是否输入输出\",{\"1\":{\"814\":1}}],[\"是否采用\",{\"1\":{\"814\":1}}],[\"是否采样\",{\"1\":{\"313\":1}}],[\"是否裁剪梯度\",{\"1\":{\"803\":1}}],[\"是否返回对比损失\",{\"1\":{\"822\":1}}],[\"是否返回损失\",{\"1\":{\"821\":1}}],[\"是否返回重建图像\",{\"1\":{\"794\":1,\"821\":1}}],[\"是否返回\",{\"1\":{\"794\":1,\"821\":1}}],[\"是否返回步长\",{\"1\":{\"332\":1}}],[\"是否启用\",{\"1\":{\"793\":1,\"817\":1}}],[\"是否启用更新\",{\"1\":{\"169\":1}}],[\"是否能生成新文本\",{\"1\":{\"616\":1}}],[\"是否尊重约束\",{\"1\":{\"537\":1}}],[\"是否适合类别不平衡\",{\"1\":{\"473\":1}}],[\"是否直接优化\",{\"1\":{\"469\":1}}],[\"是否一起变化\",{\"1\":{\"455\":1}}],[\"是否有放回采样\",{\"1\":{\"403\":1}}],[\"是否先打乱样本\",{\"1\":{\"398\":1}}],[\"是否重新计算缩放因子\",{\"1\":{\"388\":1}}],[\"是否可调\",{\"1\":{\"473\":1}}],[\"是否可用于改变维度\",{\"1\":{\"364\":1}}],[\"是否可微\",{\"1\":{\"115\":1}}],[\"是否复制数据\",{\"1\":{\"364\":1}}],[\"是否产生新作用域\",{\"1\":{\"336\":1}}],[\"是否包含\",{\"1\":{\"332\":1}}],[\"是否包含法线信息\",{\"1\":{\"93\":1}}],[\"是否对我们想要逼近的所有分布都存在这样一种函数\",{\"1\":{\"871\":1}}],[\"是否对输入\",{\"1\":{\"814\":1}}],[\"是否对类别不平衡敏感\",{\"1\":{\"469\":1}}],[\"是否对\",{\"1\":{\"467\":1,\"468\":1,\"469\":1,\"470\":1}}],[\"是否对图像进行\",{\"1\":{\"277\":1}}],[\"是否对图像做mask\",{\"1\":{\"276\":1}}],[\"是否对文本做mlm掩码\",{\"1\":{\"276\":1}}],[\"是否为连贯的上下句\",{\"1\":{\"579\":1}}],[\"是否为\",{\"1\":{\"272\":1}}],[\"是否为推理模式优化结构\",{\"1\":{\"814\":1}}],[\"是否为推理模式\",{\"1\":{\"40\":1}}],[\"是否更新全部参数\",{\"1\":{\"239\":1}}],[\"是否修改模型结构\",{\"1\":{\"239\":1}}],[\"是否规范化最后一层\",{\"1\":{\"186\":1}}],[\"是否在生成q\",{\"1\":{\"322\":1}}],[\"是否在卷积层中去掉偏置\",{\"1\":{\"272\":1}}],[\"是否在\",{\"1\":{\"186\":1,\"272\":1}}],[\"是否是\",{\"1\":{\"173\":1}}],[\"是否统计码本向量的使用频率\",{\"1\":{\"170\":1}}],[\"是否统计每个码本向量的使用频率\",{\"1\":{\"170\":1}}],[\"是否统计每个\",{\"1\":{\"170\":1}}],[\"是否从文件加载已有的\",{\"1\":{\"170\":1}}],[\"是否用余弦相似度\",{\"1\":{\"170\":1}}],[\"是否用\",{\"1\":{\"170\":1}}],[\"是否使用稀疏\",{\"1\":{\"814\":1}}],[\"是否使用硬采样\",{\"1\":{\"795\":1}}],[\"是否使用核采样\",{\"1\":{\"313\":1}}],[\"是否使用分布式采样\",{\"1\":{\"274\":2}}],[\"是否使用跨模态\",{\"1\":{\"272\":1}}],[\"是否使用偏置\",{\"1\":{\"272\":1}}],[\"是否使用绝对位置编码\",{\"1\":{\"272\":1}}],[\"是否使用相对位置编码\",{\"1\":{\"272\":1}}],[\"是否使用\",{\"1\":{\"169\":1,\"170\":1,\"793\":1,\"814\":3,\"821\":3}}],[\"是否使用梯度检查点\",{\"1\":{\"147\":1}}],[\"是否使用梯度检查点优化vit显存占用\",{\"1\":{\"142\":1}}],[\"是否仅返回\",{\"1\":{\"163\":1,\"794\":1}}],[\"是否被\",{\"1\":{\"163\":1}}],[\"是否被后续模型改进\",{\"1\":{\"112\":1}}],[\"是否跨\",{\"1\":{\"145\":1}}],[\"是否关注区域匹配\",{\"1\":{\"473\":1}}],[\"是否关注像素分类\",{\"1\":{\"473\":1}}],[\"是否关注空间重合度\",{\"1\":{\"82\":1}}],[\"是否关注分布相似性\",{\"1\":{\"82\":1}}],[\"是否依赖\",{\"1\":{\"82\":1}}],[\"是否支持广播\",{\"1\":{\"364\":1}}],[\"是否支持\",{\"1\":{\"82\":1,\"469\":1}}],[\"是语言增强后的点特征\",{\"1\":{\"74\":1}}],[\"是线性变换\",{\"1\":{\"74\":1,\"154\":1}}],[\"是roberta编码后的文本特征\",{\"1\":{\"72\":1}}],[\"是点数\",{\"1\":{\"64\":1}}],[\"是点云\",{\"1\":{\"8\":1}}],[\"是\",{\"1\":{\"64\":1,\"76\":1,\"78\":1,\"82\":9,\"83\":1,\"92\":2,\"100\":1,\"105\":1,\"108\":1,\"115\":7,\"143\":1,\"155\":1,\"163\":1,\"186\":1,\"220\":1,\"235\":1,\"239\":1,\"248\":1,\"312\":1,\"316\":1,\"332\":1,\"341\":2,\"354\":1,\"355\":1,\"358\":1,\"360\":1,\"363\":1,\"364\":3,\"367\":1,\"378\":1,\"387\":2,\"395\":2,\"399\":1,\"401\":1,\"403\":1,\"469\":8,\"473\":1,\"537\":1,\"539\":1,\"562\":1,\"571\":1,\"590\":1,\"614\":1,\"615\":1,\"704\":2,\"752\":1,\"773\":1,\"788\":2,\"797\":1,\"799\":1,\"802\":1,\"810\":1,\"814\":1,\"819\":1,\"837\":1,\"839\":1,\"840\":2,\"857\":1,\"858\":1,\"873\":1,\"881\":1}}],[\"是一张\",{\"1\":{\"756\":1}}],[\"是一款面向消费级应用的轻量级模型\",{\"1\":{\"704\":1}}],[\"是一项针对\",{\"1\":{\"559\":1}}],[\"是一些句子对\",{\"1\":{\"515\":1}}],[\"是一点点地更新的\",{\"1\":{\"246\":1}}],[\"是一种非常流行的方法\",{\"1\":{\"864\":1}}],[\"是一种自回归生成模型\",{\"1\":{\"846\":1}}],[\"是一种连续的可微近似方法\",{\"1\":{\"795\":1}}],[\"是一种令人兴奋的技术\",{\"1\":{\"708\":1}}],[\"是一种像人类一样思考和学习的人工智能\",{\"1\":{\"708\":1}}],[\"是一种旨在理解和生成人类语言的人工智能模型\",{\"1\":{\"703\":1}}],[\"是一种通过梯度下降自动学习位置编码的方法\",{\"1\":{\"588\":1}}],[\"是一种无需训练的位置编码方法\",{\"1\":{\"587\":1}}],[\"是一种低成本高回报的对齐方法\",{\"1\":{\"539\":1}}],[\"是一种在保证模型效果基本不降低的前提下\",{\"1\":{\"488\":1}}],[\"是一种基于自监督学习的视觉transformer预训练模型\",{\"1\":{\"765\":1}}],[\"是一种基于自注意力机制\",{\"1\":{\"622\":1}}],[\"是一种基于均值为\",{\"1\":{\"749\":1}}],[\"是一种基于频率统计的子词分词算法\",{\"1\":{\"475\":1}}],[\"是一种基于直方图交集的相似性指标\",{\"1\":{\"82\":1}}],[\"是一种结合了多个损失函数优点的混合损失函数\",{\"1\":{\"473\":1}}],[\"是一种针对类别不平衡\",{\"1\":{\"470\":1}}],[\"是一种常用的损失函数\",{\"1\":{\"469\":1}}],[\"是一种常用的衡量两个向量相似度的方法\",{\"1\":{\"391\":1}}],[\"是一种常用于语义分割任务的损失函数\",{\"1\":{\"467\":1}}],[\"是一种对输入顺序不敏感的函数\",{\"1\":{\"115\":1}}],[\"是一种表示三维空间中物体或场景的方式\",{\"1\":{\"114\":1}}],[\"是一种单尺度网络\",{\"1\":{\"112\":1}}],[\"是一种\",{\"1\":{\"73\":1}}],[\"是一种残差连接\",{\"1\":{\"72\":1}}],[\"是一种新颖的框架\",{\"1\":{\"5\":1}}],[\"是一个我们可以从数据中学习的确定性函数\",{\"1\":{\"874\":1}}],[\"是一个关于\",{\"1\":{\"868\":1}}],[\"是一个常数\",{\"1\":{\"867\":1,\"873\":1}}],[\"是一个既方便采样\",{\"1\":{\"847\":1}}],[\"是一个极大极小游戏\",{\"1\":{\"840\":1}}],[\"是一个大于\",{\"1\":{\"816\":1}}],[\"是一个大规模的图像数据集\",{\"1\":{\"327\":1}}],[\"是一个融合了\",{\"1\":{\"797\":1}}],[\"是一个从事件\",{\"1\":{\"726\":1}}],[\"是一个完整的系统\",{\"1\":{\"710\":1}}],[\"是一个线性层\",{\"1\":{\"614\":1}}],[\"是一个线性变换\",{\"1\":{\"72\":1}}],[\"是一个可训练的\",{\"1\":{\"590\":1}}],[\"是一个可学习的温度参数\",{\"1\":{\"154\":1}}],[\"是一个包含1亿个词汇的英文词库数据\",{\"1\":{\"577\":1}}],[\"是一个\",{\"1\":{\"459\":1,\"590\":1,\"616\":2,\"728\":1,\"809\":1,\"820\":1}}],[\"是一个字符串\",{\"1\":{\"370\":1}}],[\"是一个来自\",{\"1\":{\"370\":1}}],[\"是一个非常强大且直观的张量操作工具\",{\"1\":{\"367\":1}}],[\"是一个闭包\",{\"1\":{\"340\":1}}],[\"是一个随机初始化的向量\",{\"1\":{\"319\":1}}],[\"是一个分类头\",{\"1\":{\"312\":1}}],[\"是一个列表\",{\"1\":{\"277\":1}}],[\"是一个统一的视觉\",{\"1\":{\"269\":1}}],[\"是一个batch一个batch地去做\",{\"1\":{\"246\":1}}],[\"是一个开源的多模态大语言模型\",{\"1\":{\"215\":1}}],[\"是一个新的视觉\",{\"1\":{\"138\":1}}],[\"是一个新颖的\",{\"1\":{\"120\":1}}],[\"是一个兼顾理解与生成\",{\"1\":{\"129\":1}}],[\"是一个图像引导的文本编码器\",{\"1\":{\"128\":1}}],[\"是一个图像引导的文本解码器\",{\"1\":{\"128\":1}}],[\"是一个小型神经网络\",{\"1\":{\"107\":1}}],[\"是一个跨模态特征投影模块\",{\"1\":{\"59\":1}}],[\"是图像中\",{\"1\":{\"772\":1}}],[\"是图像块的总数\",{\"1\":{\"318\":1}}],[\"是图像宽度\",{\"1\":{\"318\":1}}],[\"是图像高度\",{\"1\":{\"318\":1}}],[\"是图像每个通道的标准差\",{\"1\":{\"317\":1}}],[\"是图像每个通道的均值\",{\"1\":{\"317\":1}}],[\"是图像\",{\"1\":{\"41\":1,\"82\":1}}],[\"关闭\",{\"1\":{\"821\":1}}],[\"关系\",{\"1\":{\"686\":1}}],[\"关注\",{\"1\":{\"589\":1}}],[\"关注学习固定词向量\",{\"1\":{\"531\":1}}],[\"关注每个像素的分类准确性\",{\"1\":{\"473\":1}}],[\"关注每个点的分类误差\",{\"1\":{\"468\":1}}],[\"关注整体区域匹配程度\",{\"1\":{\"473\":1}}],[\"关注整体区域匹配\",{\"1\":{\"469\":1}}],[\"关注整体区域匹配度\",{\"1\":{\"468\":1}}],[\"关注整体掩码匹配度\",{\"1\":{\"78\":1}}],[\"关注图像\",{\"1\":{\"291\":1}}],[\"关注排序能力\",{\"1\":{\"82\":1}}],[\"关键是\",{\"1\":{\"865\":1}}],[\"关键一步\",{\"1\":{\"796\":1}}],[\"关键代表包括\",{\"1\":{\"787\":1}}],[\"关键在于实现类型转换工具函数as\",{\"1\":{\"690\":1}}],[\"关键要点\",{\"0\":{\"639\":1}}],[\"关键里程碑\",{\"1\":{\"552\":1}}],[\"关键性能提升\",{\"1\":{\"550\":1}}],[\"关键发现\",{\"1\":{\"549\":1,\"551\":1}}],[\"关键结论\",{\"1\":{\"539\":1}}],[\"关键参数的作用\",{\"1\":{\"470\":1}}],[\"关键区别\",{\"1\":{\"385\":1}}],[\"关键共同点\",{\"1\":{\"385\":1}}],[\"关键字参数\",{\"1\":{\"337\":2}}],[\"关键优势\",{\"1\":{\"228\":1}}],[\"关键点是\",{\"1\":{\"336\":1}}],[\"关键点可能丢失\",{\"1\":{\"112\":1}}],[\"关键点集\",{\"1\":{\"105\":1}}],[\"关键功能\",{\"1\":{\"59\":1}}],[\"关键问题\",{\"1\":{\"7\":1,\"551\":1}}],[\"关于各参数求偏导并令其为零\",{\"1\":{\"826\":1}}],[\"关于本部分代码细节的详细解释\",{\"1\":{\"821\":1}}],[\"关于数据收集过程的更多细节见附录\",{\"1\":{\"810\":1}}],[\"关于上面部分公式的补充解读\",{\"1\":{\"807\":1}}],[\"关于qlora的具体细节\",{\"1\":{\"488\":1}}],[\"关于lora的具体细节\",{\"1\":{\"487\":1}}],[\"关于计算\",{\"1\":{\"470\":1}}],[\"关于vit模型的不同版本\",{\"1\":{\"324\":1}}],[\"关于多头注意力机制流程不太清楚的\",{\"1\":{\"322\":1}}],[\"关于norm层\",{\"1\":{\"321\":1}}],[\"关于bertmodel的代码解析部分\",{\"1\":{\"311\":1}}],[\"关于这一领域的详细综述\",{\"1\":{\"301\":1}}],[\"关于共享自注意力模块的消融结果\",{\"1\":{\"268\":1}}],[\"关于利用roi\",{\"1\":{\"59\":1}}],[\"关于我们\",{\"0\":{\"1\":1}}],[\"视角\",{\"1\":{\"872\":1}}],[\"视图\",{\"1\":{\"425\":1}}],[\"视觉体验差\",{\"1\":{\"806\":1}}],[\"视觉令牌重建\",{\"1\":{\"773\":1}}],[\"视觉标记通过离散变分自编码器\",{\"1\":{\"766\":1}}],[\"视觉编码阶段\",{\"1\":{\"312\":1}}],[\"视觉编码器提取图像特征\",{\"1\":{\"234\":1}}],[\"视觉编码器规模的影响\",{\"1\":{\"229\":1}}],[\"视觉编码器\",{\"1\":{\"222\":1,\"227\":1,\"234\":1,\"235\":1}}],[\"视觉编码器+注意力池化\",{\"1\":{\"196\":1}}],[\"视觉分支\",{\"1\":{\"307\":1}}],[\"视觉token\",{\"1\":{\"272\":1,\"815\":1}}],[\"视觉transformer模型大小\",{\"1\":{\"142\":1}}],[\"视觉专家\",{\"1\":{\"260\":1,\"264\":1}}],[\"视觉推理任务\",{\"1\":{\"267\":1}}],[\"视觉推理任务中均表现稳定\",{\"1\":{\"203\":1}}],[\"视觉推理等进行微调\",{\"1\":{\"260\":1}}],[\"视觉问答\",{\"1\":{\"260\":1}}],[\"视觉+语言\",{\"1\":{\"239\":1}}],[\"视觉联合推理能力\",{\"1\":{\"228\":1}}],[\"视觉主干设计选择\",{\"1\":{\"204\":1}}],[\"视觉定位等任务\",{\"1\":{\"198\":1}}],[\"视觉感知任务\",{\"1\":{\"197\":1}}],[\"视觉模型的\",{\"1\":{\"395\":1}}],[\"视觉模型的规模不足和对齐低效是阻碍多模态能力提升的主要障碍\",{\"1\":{\"194\":1}}],[\"视觉模型库\",{\"1\":{\"395\":1}}],[\"视觉模型通常基于纯视觉数据或bert系列模型训练\",{\"1\":{\"189\":1}}],[\"视觉基础模型的性能瓶颈仍是制约vllms发展的关键因素\",{\"1\":{\"193\":1}}],[\"视觉基础模型在过去十年中经历了显著发展\",{\"1\":{\"191\":1}}],[\"视觉\",{\"0\":{\"122\":1,\"770\":1},\"1\":{\"126\":1,\"147\":1,\"149\":1,\"157\":1,\"165\":1,\"167\":1,\"198\":2,\"260\":2,\"261\":1,\"267\":2,\"280\":1,\"768\":1,\"770\":2,\"780\":1,\"802\":1}}],[\"视觉的跨模态交互能力\",{\"1\":{\"75\":1}}],[\"视觉与大语言模型\",{\"1\":{\"69\":1}}],[\"视觉语义特征\",{\"1\":{\"40\":1,\"45\":1}}],[\"视觉任务中\",{\"1\":{\"7\":1}}],[\"视频和结构化知识\",{\"1\":{\"269\":1}}],[\"视频检索等任务中达到sota\",{\"1\":{\"189\":1}}],[\"视频分类\",{\"1\":{\"188\":1}}],[\"视频中分割功能区域\",{\"1\":{\"51\":1}}],[\"视频\",{\"1\":{\"7\":1,\"188\":1}}],[\"与正则化参数\",{\"0\":{\"873\":1}}],[\"与正向传播方向相反\",{\"1\":{\"656\":1}}],[\"与从\",{\"1\":{\"872\":1}}],[\"与直接从\",{\"1\":{\"869\":1}}],[\"与生成样本的距离\",{\"1\":{\"866\":1}}],[\"与先验\",{\"1\":{\"854\":1}}],[\"与位置编码\",{\"1\":{\"815\":1}}],[\"与使用\",{\"1\":{\"808\":1}}],[\"与一个先验分布\",{\"1\":{\"798\":1}}],[\"与遮挡机制是\",{\"1\":{\"780\":1}}],[\"与似然函数\",{\"1\":{\"758\":1}}],[\"与原点的距离为\",{\"1\":{\"753\":1}}],[\"与原始\",{\"1\":{\"521\":1}}],[\"与原始步幅一致\",{\"1\":{\"427\":1}}],[\"与原始点\",{\"1\":{\"92\":1}}],[\"与事件空间相关联的概率规律\",{\"1\":{\"729\":1}}],[\"与用户负反馈\",{\"1\":{\"717\":1}}],[\"与合作伙伴包进行有效分离\",{\"1\":{\"714\":1}}],[\"与合成文本\",{\"1\":{\"132\":1}}],[\"与特定应用程序的数据进行交互的接口\",{\"1\":{\"713\":1}}],[\"与语言模型交互的接口\",{\"1\":{\"713\":1}}],[\"与以前的预训练语言模型\",{\"1\":{\"706\":1}}],[\"与以往在合成任务或小型模型上的研究不同\",{\"1\":{\"539\":1}}],[\"与基座模型有本质的区别\",{\"1\":{\"704\":1}}],[\"与训练流程规范\",{\"1\":{\"700\":1}}],[\"与梯度相乘的值设为lr=0\",{\"1\":{\"697\":1}}],[\"与反向传播类似\",{\"1\":{\"696\":1}}],[\"与define\",{\"1\":{\"692\":1}}],[\"与运行结果一致\",{\"1\":{\"692\":1}}],[\"与函数\",{\"1\":{\"680\":1}}],[\"与相对位置\",{\"1\":{\"590\":1}}],[\"与bert结论相反\",{\"1\":{\"567\":1}}],[\"与chinchiila\",{\"1\":{\"551\":1}}],[\"与chinchilla\",{\"1\":{\"547\":1}}],[\"与opt等模型趋势一致\",{\"1\":{\"549\":1}}],[\"与指令微调\",{\"1\":{\"549\":1}}],[\"与triviaqa\",{\"1\":{\"549\":1}}],[\"与毒性\",{\"1\":{\"547\":1}}],[\"与预训练相比\",{\"1\":{\"539\":1}}],[\"与上述方法的不同之处在于其训练数据源真实\",{\"1\":{\"536\":1}}],[\"与人类学习方式不匹配\",{\"1\":{\"527\":1}}],[\"与单向语言模型的互补性\",{\"1\":{\"523\":1}}],[\"与传统指针网络方法形成鲜明对比\",{\"1\":{\"523\":1}}],[\"与传统知识蒸馏不同\",{\"1\":{\"178\":1}}],[\"与常规训练\",{\"1\":{\"522\":1}}],[\"与lstms相比\",{\"1\":{\"516\":1}}],[\"与llama\",{\"1\":{\"189\":1}}],[\"与llms的特征空间存在差异\",{\"1\":{\"189\":1}}],[\"与升维矩阵\",{\"1\":{\"492\":1}}],[\"与负样本\",{\"1\":{\"470\":1}}],[\"与背景的极端不平衡问题\",{\"1\":{\"470\":1}}],[\"与交叉熵损失函数相比\",{\"1\":{\"470\":1}}],[\"与交互意图\",{\"1\":{\"6\":1}}],[\"与对象检测任务不同\",{\"1\":{\"465\":1}}],[\"与输入长度相同\",{\"1\":{\"398\":1}}],[\"与多项式逼近的对比\",{\"1\":{\"385\":1}}],[\"与多项式逼近\",{\"1\":{\"385\":1}}],[\"与多模态嵌入\",{\"1\":{\"43\":1}}],[\"与多模态大模型\",{\"1\":{\"7\":1}}],[\"与所有负样本的相似度\",{\"1\":{\"367\":1}}],[\"与之类似的还有\",{\"1\":{\"324\":1}}],[\"与其训练更大的模型\",{\"1\":{\"539\":1}}],[\"与其正样本的点积\",{\"1\":{\"367\":1}}],[\"与其他\",{\"1\":{\"319\":1,\"469\":1}}],[\"与其在整个数据集上计算损失\",{\"1\":{\"248\":1}}],[\"与计算机视觉\",{\"1\":{\"298\":1}}],[\"与计算效率间取得平衡\",{\"1\":{\"196\":1}}],[\"与此同时\",{\"1\":{\"297\":1,\"442\":1,\"529\":1,\"703\":1}}],[\"与视觉\",{\"1\":{\"294\":1}}],[\"与文本\",{\"1\":{\"268\":1,\"807\":1,\"815\":1}}],[\"与词嵌入拼接输入\",{\"1\":{\"261\":1}}],[\"与过去依赖\",{\"1\":{\"176\":1}}],[\"与锐化\",{\"1\":{\"173\":1}}],[\"与主模型参数不同步\",{\"1\":{\"147\":1}}],[\"与动量队列的相似度\",{\"1\":{\"145\":1}}],[\"与解码\",{\"1\":{\"134\":1}}],[\"与k最近邻\",{\"1\":{\"90\":1}}],[\"与\",{\"0\":{\"396\":1},\"1\":{\"15\":1,\"19\":1,\"29\":1,\"33\":1,\"49\":2,\"55\":1,\"82\":1,\"134\":1,\"161\":1,\"198\":1,\"236\":1,\"268\":2,\"272\":1,\"278\":1,\"310\":2,\"311\":1,\"316\":1,\"377\":1,\"379\":1,\"385\":1,\"388\":1,\"450\":1,\"468\":1,\"492\":3,\"521\":1,\"537\":1,\"538\":2,\"577\":1,\"590\":1,\"690\":1,\"695\":1,\"704\":3,\"728\":1,\"730\":2,\"766\":1,\"794\":1,\"798\":1,\"802\":1,\"807\":1,\"809\":1,\"815\":2,\"821\":1,\"837\":2,\"866\":2,\"867\":1,\"869\":1,\"873\":1,\"874\":1}}],[\"与意图特征\",{\"1\":{\"14\":1}}],[\"与自注意力层\",{\"1\":{\"13\":1}}],[\"利用两类掩码卷积\",{\"1\":{\"845\":1}}],[\"利用额外条件信息\",{\"1\":{\"806\":1}}],[\"利用了恒等式\",{\"1\":{\"742\":1}}],[\"利用包含中间推理步骤的提示机制来解决这些任务\",{\"1\":{\"706\":1}}],[\"利用pytorch从\",{\"1\":{\"570\":1}}],[\"利用cot\",{\"1\":{\"502\":1}}],[\"利用clip编码器实现文本\",{\"1\":{\"7\":1}}],[\"利用nltk库提供的wordpunct\",{\"1\":{\"476\":1}}],[\"利用nltk库提供的sent\",{\"1\":{\"476\":1}}],[\"利用已有的vit\",{\"1\":{\"307\":1}}],[\"利用已有知识进行推理\",{\"1\":{\"239\":1}}],[\"利用大规模图像\",{\"1\":{\"266\":1}}],[\"利用视觉信息辅助\",{\"1\":{\"265\":1}}],[\"利用其对齐的特征空间提升性能\",{\"1\":{\"198\":1}}],[\"利用少量标注\",{\"1\":{\"176\":1}}],[\"利用图文对比损失中的相似度作为度量\",{\"1\":{\"156\":1}}],[\"利用图像和上下文文本共同预测被\",{\"1\":{\"155\":1}}],[\"利用对称函数\",{\"1\":{\"103\":1}}],[\"利用相对坐标与点特征相结合的方式可以捕获局部区域中点与点之间的关系\",{\"1\":{\"91\":1}}],[\"利用上一步得到的中心点将点集划分成若干个区域\",{\"1\":{\"87\":1}}],[\"利用一组问题条件化的\",{\"1\":{\"76\":2}}],[\"利用\",{\"1\":{\"70\":1,\"278\":1,\"309\":1,\"326\":1,\"561\":1,\"712\":1}}],[\"利用1x1卷积完成通道维度上的信息融合\",{\"1\":{\"59\":1}}],[\"利用联合建模特征作为query\",{\"1\":{\"59\":1}}],[\"利用roi\",{\"1\":{\"59\":3}}],[\"利用功能\",{\"1\":{\"52\":1}}],[\"利用物体结构辅助推断更多人类交互意图\",{\"1\":{\"32\":1}}],[\"利用跨模态自适应融合模块\",{\"1\":{\"8\":1}}],[\"利用2d交互语义指导3d功能定位\",{\"1\":{\"7\":1}}],[\"i+64\",{\"1\":{\"886\":1}}],[\"i+1\",{\"1\":{\"476\":1,\"477\":1,\"478\":2,\"541\":2,\"578\":1,\"886\":1}}],[\"i3\",{\"1\":{\"846\":4}}],[\"i==j\",{\"1\":{\"822\":1}}],[\"igpt\",{\"1\":{\"785\":1,\"788\":1}}],[\"ignored\",{\"1\":{\"615\":4}}],[\"ignore\",{\"1\":{\"163\":1,\"169\":1,\"170\":1,\"274\":1,\"276\":2,\"304\":1,\"581\":1,\"612\":1,\"615\":3}}],[\"ibot\",{\"1\":{\"784\":1}}],[\"ibarz\",{\"1\":{\"536\":1}}],[\"ill\",{\"1\":{\"759\":1}}],[\"iloc\",{\"1\":{\"68\":2}}],[\"io\",{\"1\":{\"735\":1,\"821\":4}}],[\"iouloss\",{\"1\":{\"469\":2}}],[\"iou\",{\"0\":{\"469\":1},\"1\":{\"82\":27,\"467\":2,\"469\":21}}],[\"ipython\",{\"1\":{\"696\":1}}],[\"i证明小规模微调即可显著提升任务适应性\",{\"1\":{\"550\":1}}],[\"icmlm和convirt仅在10万级别的数据上训练了几天\",{\"1\":{\"305\":1}}],[\"icmlm基于语言掩码的方法\",{\"1\":{\"305\":1}}],[\"irtr\",{\"1\":{\"275\":2}}],[\"iid\",{\"1\":{\"274\":5}}],[\"iq\",{\"1\":{\"186\":2}}],[\"itg\",{\"0\":{\"312\":1},\"1\":{\"198\":1}}],[\"it\",{\"1\":{\"186\":2,\"202\":1}}],[\"iterate\",{\"1\":{\"808\":1}}],[\"iterable\",{\"1\":{\"401\":3,\"803\":1}}],[\"iter\",{\"1\":{\"697\":9,\"857\":1}}],[\"iters是iterations的缩写\",{\"1\":{\"697\":1}}],[\"iters\",{\"1\":{\"170\":3,\"697\":6}}],[\"items\",{\"1\":{\"274\":1,\"275\":2,\"278\":1,\"316\":1,\"476\":4,\"478\":3,\"578\":2}}],[\"item\",{\"1\":{\"68\":5,\"82\":1,\"145\":2,\"147\":2,\"162\":2,\"272\":1,\"278\":2,\"311\":2,\"316\":5,\"544\":1,\"581\":1,\"596\":1,\"803\":1,\"840\":2,\"848\":1,\"856\":1,\"860\":1,\"885\":2,\"886\":1}}],[\"ita\",{\"1\":{\"145\":4,\"147\":4,\"159\":2,\"161\":1}}],[\"itm分类头\",{\"1\":{\"145\":1}}],[\"itm\",{\"0\":{\"127\":1,\"156\":1,\"162\":1,\"311\":1},\"1\":{\"127\":1,\"128\":2,\"145\":11,\"146\":7,\"147\":12,\"153\":2,\"156\":2,\"159\":2,\"160\":2,\"162\":8,\"198\":1,\"275\":3,\"277\":3,\"278\":26,\"285\":1,\"311\":12}}],[\"itc\",{\"0\":{\"127\":1,\"161\":1,\"310\":1},\"1\":{\"127\":1,\"128\":1,\"145\":1,\"146\":1,\"147\":1,\"149\":1,\"153\":1,\"157\":3,\"161\":1,\"162\":1,\"198\":1,\"275\":6,\"277\":66,\"278\":5,\"310\":1}}],[\"ian\",{\"1\":{\"840\":1}}],[\"ia\",{\"1\":{\"59\":5}}],[\"iag网络输入为四元组\",{\"1\":{\"54\":1}}],[\"iag框架\",{\"1\":{\"49\":1}}],[\"iag\",{\"1\":{\"22\":1,\"23\":1,\"59\":1}}],[\"iagnet\",{\"0\":{\"47\":1},\"1\":{\"7\":1,\"47\":1}}],[\"i2t维度为\",{\"1\":{\"162\":1}}],[\"i2t\",{\"1\":{\"145\":13,\"147\":13,\"161\":9,\"162\":4,\"275\":1,\"277\":10,\"278\":6,\"310\":5,\"311\":4}}],[\"i2\",{\"1\":{\"32\":4,\"45\":4,\"846\":6}}],[\"i1\",{\"1\":{\"32\":4,\"45\":4,\"846\":8}}],[\"idf\",{\"1\":{\"392\":1}}],[\"id为文本\",{\"1\":{\"313\":1}}],[\"id=198\",{\"1\":{\"544\":1}}],[\"id=model\",{\"1\":{\"302\":1,\"304\":1}}],[\"id=self\",{\"1\":{\"143\":4,\"313\":2}}],[\"identity\",{\"1\":{\"170\":2,\"186\":2,\"272\":1,\"318\":3,\"321\":1,\"323\":1}}],[\"identify\",{\"1\":{\"63\":1}}],[\"iden\",{\"1\":{\"107\":4}}],[\"idw\",{\"1\":{\"98\":1,\"100\":2}}],[\"ids作用图解\",{\"1\":{\"594\":1}}],[\"ids=position\",{\"1\":{\"163\":1,\"289\":1,\"295\":1,\"312\":1,\"602\":1,\"603\":1,\"612\":1,\"615\":1,\"617\":1,\"618\":1}}],[\"ids=token\",{\"1\":{\"163\":1,\"594\":1,\"602\":1,\"603\":1,\"612\":1,\"614\":1,\"615\":1,\"617\":1,\"618\":1}}],[\"ids=none\",{\"1\":{\"163\":3,\"289\":2,\"295\":2,\"311\":2,\"312\":2,\"544\":2,\"597\":2,\"602\":2,\"603\":2,\"612\":2,\"615\":2,\"617\":2,\"618\":2}}],[\"ids=input\",{\"1\":{\"143\":2,\"289\":1,\"313\":1,\"544\":1,\"594\":1}}],[\"ids\",{\"1\":{\"40\":1,\"142\":7,\"143\":8,\"145\":16,\"146\":2,\"147\":21,\"161\":2,\"163\":24,\"274\":2,\"276\":7,\"277\":6,\"278\":22,\"289\":2,\"295\":2,\"309\":1,\"311\":21,\"312\":9,\"313\":2,\"477\":11,\"478\":11,\"544\":13,\"578\":7,\"579\":11,\"581\":4,\"594\":36,\"596\":8,\"597\":14,\"602\":4,\"603\":4,\"612\":4,\"614\":2,\"615\":4,\"616\":4,\"617\":4,\"618\":17,\"803\":2,\"814\":6}}],[\"id\",{\"1\":{\"29\":2,\"40\":2,\"58\":2,\"68\":6,\"83\":1,\"142\":5,\"143\":5,\"145\":1,\"147\":3,\"163\":4,\"274\":1,\"276\":4,\"277\":5,\"312\":3,\"313\":3,\"477\":6,\"478\":7,\"537\":1,\"544\":1,\"578\":1,\"580\":1,\"594\":9,\"616\":3,\"696\":6,\"793\":1,\"814\":4,\"815\":2,\"817\":2,\"820\":1,\"821\":1}}],[\"idx说明\",{\"1\":{\"544\":1}}],[\"idx2word\",{\"1\":{\"578\":7}}],[\"idx2\",{\"1\":{\"463\":2}}],[\"idx=none\",{\"1\":{\"544\":1}}],[\"idx=image\",{\"1\":{\"276\":1}}],[\"idx=idx\",{\"1\":{\"145\":1}}],[\"idx=0\",{\"1\":{\"276\":1,\"584\":1,\"597\":1}}],[\"idx=1\",{\"1\":{\"276\":1,\"277\":2}}],[\"idxs\",{\"1\":{\"145\":3,\"477\":2,\"478\":2}}],[\"idx\",{\"1\":{\"29\":10,\"58\":2,\"92\":21,\"96\":3,\"100\":5,\"145\":32,\"147\":5,\"162\":5,\"186\":8,\"255\":2,\"273\":6,\"275\":1,\"276\":2,\"277\":1,\"278\":5,\"302\":5,\"304\":5,\"311\":5,\"375\":1,\"463\":2,\"476\":14,\"477\":3,\"478\":34,\"544\":1,\"578\":8,\"579\":4,\"581\":2,\"584\":1,\"848\":1,\"856\":1}}],[\"i\",{\"1\":{\"29\":4,\"30\":7,\"32\":8,\"34\":7,\"35\":10,\"41\":17,\"43\":10,\"45\":18,\"46\":2,\"58\":2,\"59\":62,\"68\":4,\"81\":1,\"82\":12,\"83\":10,\"92\":4,\"96\":7,\"100\":2,\"108\":5,\"142\":1,\"145\":2,\"147\":1,\"159\":2,\"186\":2,\"252\":1,\"263\":1,\"265\":1,\"272\":3,\"276\":2,\"277\":6,\"290\":4,\"299\":12,\"302\":2,\"304\":2,\"312\":3,\"316\":4,\"323\":2,\"336\":1,\"363\":1,\"377\":2,\"379\":7,\"423\":2,\"427\":2,\"476\":7,\"477\":4,\"478\":10,\"538\":1,\"541\":5,\"544\":1,\"549\":1,\"550\":1,\"578\":2,\"579\":8,\"581\":5,\"587\":2,\"589\":2,\"590\":10,\"591\":14,\"600\":2,\"682\":2,\"697\":3,\"713\":1,\"801\":3,\"822\":2,\"831\":2,\"840\":3,\"843\":15,\"846\":4,\"848\":4,\"857\":13,\"861\":4,\"886\":7}}],[\"imbalance\",{\"1\":{\"467\":1,\"470\":1}}],[\"imsave\",{\"1\":{\"463\":1}}],[\"imshow\",{\"1\":{\"303\":1,\"304\":1,\"857\":3,\"861\":1,\"886\":1}}],[\"imags\",{\"1\":{\"278\":2}}],[\"imag\",{\"1\":{\"272\":11,\"276\":1,\"277\":3}}],[\"imagetext\",{\"1\":{\"285\":1}}],[\"image→text\",{\"1\":{\"277\":2}}],[\"image=none\",{\"1\":{\"815\":1}}],[\"image=false\",{\"1\":{\"276\":3,\"277\":2,\"278\":3}}],[\"image=1\",{\"1\":{\"274\":1,\"277\":1}}],[\"image=0\",{\"1\":{\"274\":4}}],[\"image=self\",{\"1\":{\"274\":3}}],[\"imagefolder\",{\"1\":{\"186\":3,\"252\":1,\"802\":1}}],[\"imagenet\",{\"1\":{\"131\":1,\"173\":3,\"179\":1,\"186\":2,\"201\":1,\"202\":1,\"245\":1,\"247\":1,\"248\":1,\"250\":1,\"317\":1,\"327\":3,\"395\":2,\"774\":1,\"778\":1,\"780\":1,\"802\":1}}],[\"images=images\",{\"1\":{\"302\":1,\"304\":1}}],[\"images\",{\"1\":{\"47\":1,\"114\":1,\"186\":3,\"252\":1,\"255\":2,\"278\":5,\"299\":1,\"300\":1,\"302\":3,\"303\":2,\"304\":5,\"312\":2,\"316\":40,\"317\":12,\"323\":3,\"803\":3,\"817\":5,\"821\":4,\"840\":3,\"857\":1,\"886\":1}}],[\"image\",{\"0\":{\"154\":1,\"156\":1,\"278\":1,\"310\":1,\"311\":1,\"312\":1,\"772\":1,\"776\":1},\"1\":{\"16\":1,\"28\":9,\"29\":2,\"40\":2,\"43\":6,\"58\":1,\"119\":2,\"120\":1,\"126\":2,\"127\":4,\"134\":1,\"142\":25,\"143\":13,\"145\":50,\"146\":14,\"147\":47,\"156\":1,\"159\":4,\"160\":5,\"161\":30,\"162\":19,\"163\":5,\"164\":2,\"167\":1,\"171\":2,\"186\":5,\"201\":1,\"202\":3,\"252\":3,\"260\":2,\"262\":2,\"265\":2,\"269\":1,\"272\":4,\"274\":35,\"275\":1,\"276\":20,\"277\":43,\"278\":15,\"294\":1,\"298\":1,\"299\":5,\"300\":10,\"302\":31,\"303\":21,\"304\":51,\"305\":1,\"307\":2,\"309\":14,\"310\":11,\"311\":20,\"312\":7,\"313\":15,\"316\":9,\"318\":1,\"327\":1,\"395\":1,\"463\":1,\"696\":3,\"764\":2,\"765\":1,\"767\":1,\"772\":1,\"773\":3,\"790\":1,\"793\":3,\"794\":2,\"802\":2,\"803\":1,\"804\":2,\"805\":1,\"812\":1,\"814\":31,\"815\":31,\"817\":28,\"820\":1,\"821\":17,\"822\":29,\"840\":5,\"843\":1,\"848\":7,\"859\":1}}],[\"im\",{\"1\":{\"181\":2,\"252\":2,\"255\":8}}],[\"impacts\",{\"1\":{\"539\":1}}],[\"improving\",{\"1\":{\"505\":1,\"843\":1}}],[\"improves\",{\"1\":{\"502\":1}}],[\"implements\",{\"1\":{\"632\":1}}],[\"implementation\",{\"0\":{\"139\":1,\"158\":1,\"251\":1,\"253\":1},\"1\":{\"277\":1}}],[\"impl\",{\"1\":{\"327\":1}}],[\"import\",{\"1\":{\"78\":3,\"83\":7,\"304\":9,\"316\":3,\"332\":1,\"333\":1,\"346\":1,\"353\":1,\"355\":1,\"363\":1,\"370\":1,\"372\":1,\"373\":1,\"374\":1,\"395\":1,\"398\":2,\"399\":2,\"401\":2,\"421\":1,\"423\":4,\"425\":1,\"426\":2,\"478\":5,\"541\":2,\"544\":3,\"590\":3,\"591\":2,\"638\":1,\"675\":1,\"687\":1,\"688\":1,\"691\":7,\"696\":6,\"697\":5,\"814\":1,\"840\":9,\"848\":9,\"852\":7,\"886\":1}}],[\"imgs\",{\"1\":{\"278\":2,\"840\":11,\"861\":2}}],[\"imgkey\",{\"1\":{\"276\":2,\"277\":2}}],[\"img\",{\"1\":{\"29\":28,\"30\":5,\"34\":1,\"40\":8,\"41\":7,\"58\":25,\"59\":14,\"142\":2,\"160\":2,\"272\":16,\"276\":3,\"277\":2,\"303\":2,\"304\":2,\"316\":9,\"318\":10,\"319\":3,\"320\":2,\"323\":2,\"327\":1,\"463\":11,\"794\":4,\"804\":9,\"814\":1,\"815\":12,\"817\":12,\"821\":10,\"840\":18,\"886\":2}}],[\"isfinite\",{\"1\":{\"803\":1}}],[\"isotropic\",{\"1\":{\"752\":1}}],[\"isscalar\",{\"1\":{\"690\":1}}],[\"issues\",{\"1\":{\"140\":1}}],[\"isn\",{\"1\":{\"316\":1}}],[\"isdir\",{\"1\":{\"302\":1,\"304\":1,\"316\":1}}],[\"isinstance\",{\"1\":{\"186\":2,\"295\":1,\"544\":1,\"578\":2,\"599\":2,\"609\":2,\"673\":1,\"681\":1,\"682\":1,\"684\":1,\"686\":3,\"688\":2,\"689\":1,\"690\":1,\"801\":1}}],[\"is\",{\"0\":{\"242\":1},\"1\":{\"28\":1,\"43\":1,\"72\":2,\"74\":2,\"75\":1,\"83\":2,\"92\":3,\"96\":2,\"100\":1,\"107\":1,\"108\":1,\"142\":1,\"145\":1,\"147\":1,\"162\":3,\"163\":8,\"170\":3,\"252\":1,\"254\":1,\"255\":1,\"272\":9,\"274\":2,\"289\":2,\"293\":4,\"295\":3,\"300\":1,\"302\":2,\"303\":2,\"304\":4,\"311\":4,\"312\":12,\"316\":1,\"353\":1,\"362\":1,\"426\":2,\"463\":1,\"477\":1,\"478\":1,\"541\":32,\"544\":6,\"572\":7,\"578\":1,\"579\":4,\"581\":2,\"584\":1,\"591\":2,\"594\":4,\"597\":2,\"603\":1,\"605\":4,\"610\":1,\"612\":2,\"615\":2,\"616\":2,\"617\":2,\"618\":4,\"628\":1,\"630\":1,\"632\":3,\"665\":1,\"668\":1,\"672\":1,\"673\":2,\"682\":2,\"684\":3,\"686\":5,\"688\":3,\"689\":3,\"696\":5,\"794\":1,\"801\":1,\"803\":1,\"804\":2,\"815\":3,\"817\":2,\"820\":1,\"821\":1,\"840\":1,\"848\":2,\"856\":1,\"860\":1}}],[\"if\",{\"1\":{\"28\":1,\"29\":6,\"40\":2,\"43\":1,\"58\":5,\"68\":3,\"72\":2,\"74\":2,\"75\":1,\"80\":2,\"82\":2,\"83\":7,\"92\":5,\"93\":2,\"96\":4,\"100\":2,\"107\":1,\"108\":1,\"109\":3,\"143\":2,\"145\":2,\"146\":1,\"159\":1,\"162\":1,\"163\":8,\"169\":3,\"170\":8,\"186\":4,\"272\":16,\"274\":9,\"275\":10,\"276\":2,\"277\":3,\"278\":2,\"289\":1,\"291\":1,\"293\":2,\"295\":4,\"302\":9,\"303\":3,\"304\":12,\"311\":5,\"312\":11,\"313\":1,\"316\":6,\"318\":1,\"321\":1,\"323\":1,\"327\":2,\"336\":3,\"353\":1,\"463\":1,\"476\":1,\"477\":6,\"478\":9,\"541\":1,\"544\":12,\"577\":4,\"578\":8,\"579\":6,\"581\":3,\"591\":5,\"594\":7,\"596\":1,\"597\":2,\"599\":1,\"603\":3,\"605\":1,\"609\":1,\"612\":1,\"615\":1,\"617\":2,\"618\":4,\"632\":3,\"665\":1,\"668\":1,\"672\":1,\"673\":2,\"681\":2,\"682\":3,\"684\":4,\"686\":9,\"688\":9,\"689\":3,\"690\":2,\"692\":1,\"696\":6,\"793\":1,\"794\":4,\"801\":7,\"802\":1,\"803\":1,\"804\":3,\"814\":3,\"815\":10,\"816\":2,\"817\":4,\"820\":2,\"821\":7,\"822\":2,\"840\":5,\"848\":2,\"856\":1,\"860\":1,\"885\":1,\"886\":2}}],[\"in2\",{\"1\":{\"821\":1}}],[\"in21k模型权重文件\",{\"1\":{\"327\":1}}],[\"in21k\",{\"1\":{\"327\":4}}],[\"in21k这个模型\",{\"1\":{\"327\":1}}],[\"in1\",{\"1\":{\"821\":1}}],[\"inception\",{\"1\":{\"802\":4}}],[\"including\",{\"1\":{\"28\":2}}],[\"in=hidden\",{\"1\":{\"793\":2}}],[\"invalid\",{\"1\":{\"815\":1}}],[\"invariance\",{\"1\":{\"104\":1,\"115\":1}}],[\"invariant\",{\"1\":{\"104\":1}}],[\"invertible\",{\"1\":{\"522\":1}}],[\"inverse=true\",{\"1\":{\"372\":1}}],[\"inverse=false\",{\"1\":{\"372\":1}}],[\"inverse\",{\"0\":{\"759\":1},\"1\":{\"372\":3}}],[\"infiniband\",{\"1\":{\"561\":1}}],[\"infile\",{\"1\":{\"478\":6}}],[\"information\",{\"1\":{\"870\":1}}],[\"info\",{\"1\":{\"434\":1,\"436\":1,\"599\":1,\"609\":1}}],[\"infonce\",{\"1\":{\"145\":1,\"147\":4,\"248\":7,\"249\":1,\"250\":1}}],[\"infer\",{\"1\":{\"275\":1,\"276\":8,\"277\":10,\"278\":12}}],[\"inference\",{\"1\":{\"4\":1,\"5\":1,\"40\":3,\"492\":1,\"703\":1,\"758\":5,\"814\":3}}],[\"inf\",{\"1\":{\"272\":1,\"581\":1,\"803\":1,\"815\":2,\"818\":4,\"820\":1}}],[\"inp\",{\"1\":{\"186\":2}}],[\"inplace\",{\"1\":{\"170\":3}}],[\"inplace=true\",{\"1\":{\"101\":1,\"840\":3}}],[\"input=outputs\",{\"1\":{\"803\":1}}],[\"input=x\",{\"1\":{\"272\":1}}],[\"inputfeatures\",{\"1\":{\"594\":1}}],[\"inputfeatures组成图解\",{\"1\":{\"594\":1}}],[\"inputs和self\",{\"1\":{\"687\":1}}],[\"inputs\",{\"1\":{\"40\":6,\"43\":6,\"163\":2,\"186\":1,\"302\":4,\"304\":4,\"467\":9,\"468\":14,\"469\":9,\"470\":8,\"471\":10,\"473\":12,\"544\":4,\"594\":8,\"615\":1,\"681\":4,\"682\":2,\"684\":1,\"686\":6,\"687\":1,\"688\":6,\"690\":9,\"696\":2}}],[\"input\",{\"1\":{\"40\":7,\"43\":19,\"92\":11,\"95\":1,\"96\":3,\"98\":1,\"99\":1,\"142\":5,\"143\":8,\"145\":9,\"146\":2,\"147\":14,\"159\":2,\"161\":2,\"163\":23,\"255\":1,\"272\":1,\"274\":1,\"289\":2,\"292\":2,\"295\":2,\"300\":2,\"309\":6,\"311\":10,\"312\":8,\"313\":3,\"372\":2,\"373\":3,\"377\":4,\"388\":2,\"469\":1,\"541\":19,\"544\":6,\"578\":4,\"579\":6,\"581\":4,\"594\":13,\"596\":4,\"597\":6,\"599\":2,\"602\":2,\"603\":2,\"606\":2,\"607\":3,\"610\":1,\"612\":2,\"614\":1,\"615\":2,\"616\":4,\"617\":2,\"618\":7,\"628\":1,\"643\":2,\"660\":4,\"661\":1,\"664\":1,\"665\":1,\"668\":1,\"682\":1,\"689\":2,\"799\":2,\"801\":5,\"802\":2,\"803\":3,\"814\":2,\"817\":1,\"821\":1,\"840\":2,\"853\":3,\"859\":5,\"886\":3}}],[\"ind\",{\"1\":{\"818\":3}}],[\"independent\",{\"1\":{\"730\":2}}],[\"indent=4\",{\"1\":{\"316\":1,\"476\":3,\"478\":3,\"577\":2,\"578\":1}}],[\"index=5\",{\"1\":{\"616\":2}}],[\"index=ignored\",{\"1\":{\"615\":1}}],[\"index=0\",{\"1\":{\"581\":3}}],[\"index=masked\",{\"1\":{\"580\":2}}],[\"index=\",{\"1\":{\"276\":2,\"612\":1}}],[\"index=10\",{\"1\":{\"272\":1}}],[\"indexed\",{\"1\":{\"92\":1}}],[\"index\",{\"1\":{\"29\":14,\"58\":13,\"68\":3,\"92\":8,\"96\":3,\"100\":2,\"142\":2,\"163\":1,\"272\":4,\"274\":8,\"276\":1,\"277\":14,\"302\":2,\"303\":2,\"304\":4,\"379\":6,\"438\":1,\"469\":2,\"471\":1,\"478\":3,\"581\":2,\"584\":1,\"590\":2,\"614\":4,\"615\":6,\"616\":5,\"796\":2,\"886\":1}}],[\"inductive\",{\"1\":{\"314\":1}}],[\"indicating\",{\"1\":{\"478\":1}}],[\"indicators\",{\"1\":{\"255\":1}}],[\"indices=none\",{\"1\":{\"163\":1}}],[\"indices\",{\"1\":{\"92\":5,\"107\":1,\"109\":1,\"163\":12,\"170\":6,\"302\":2,\"304\":2,\"311\":6,\"316\":4,\"478\":6,\"579\":3,\"803\":1,\"815\":2,\"817\":5,\"821\":4,\"885\":7,\"886\":10}}],[\"inner\",{\"1\":{\"72\":2,\"74\":2,\"339\":2,\"340\":4}}],[\"inherent\",{\"1\":{\"59\":3}}],[\"inspect\",{\"1\":{\"346\":1}}],[\"insert\",{\"1\":{\"59\":2,\"821\":2}}],[\"install命令安装即可\",{\"1\":{\"438\":1}}],[\"install\",{\"1\":{\"438\":4,\"620\":1,\"696\":2}}],[\"instance\",{\"0\":{\"243\":1},\"1\":{\"175\":1,\"243\":1}}],[\"instances\",{\"1\":{\"25\":1,\"478\":2}}],[\"instruct\",{\"1\":{\"235\":2}}],[\"instructgpt没能直接回答\",{\"1\":{\"538\":1}}],[\"instructgpt在输出真实性\",{\"1\":{\"534\":1}}],[\"instructgpt\",{\"0\":{\"533\":1},\"1\":{\"232\":5,\"239\":1,\"533\":1,\"536\":10,\"537\":7,\"538\":18,\"539\":5}}],[\"instructblip\",{\"1\":{\"203\":1}}],[\"instruction+qa\",{\"1\":{\"538\":1}}],[\"instruction\",{\"0\":{\"239\":1},\"1\":{\"40\":1,\"232\":6,\"239\":7,\"536\":1,\"704\":1}}],[\"instructional\",{\"1\":{\"40\":3,\"45\":3}}],[\"instructions\",{\"1\":{\"37\":1,\"533\":1,\"536\":1}}],[\"int32\",{\"1\":{\"814\":1}}],[\"into\",{\"1\":{\"614\":1}}],[\"intrinsic\",{\"1\":{\"491\":2,\"492\":1}}],[\"introduction\",{\"0\":{\"120\":1,\"149\":1,\"241\":1,\"246\":1,\"260\":1,\"280\":1},\"1\":{\"875\":1}}],[\"intuitive\",{\"1\":{\"255\":1}}],[\"int64\",{\"1\":{\"68\":2,\"689\":1}}],[\"int\",{\"1\":{\"59\":8,\"73\":2,\"82\":2,\"142\":2,\"163\":1,\"254\":2,\"257\":1,\"272\":1,\"274\":1,\"319\":5,\"321\":1,\"327\":1,\"354\":1,\"398\":1,\"476\":21,\"477\":4,\"478\":37,\"578\":1,\"579\":1,\"605\":1,\"801\":3,\"803\":1,\"814\":4,\"817\":1,\"818\":1,\"821\":1,\"840\":2}}],[\"integer\",{\"1\":{\"821\":1}}],[\"integration\",{\"0\":{\"13\":1}}],[\"intensity\",{\"1\":{\"114\":1}}],[\"intention\",{\"1\":{\"4\":1,\"5\":1}}],[\"interval\",{\"1\":{\"840\":3}}],[\"intermediate\",{\"0\":{\"778\":1},\"1\":{\"599\":9}}],[\"interface\",{\"1\":{\"544\":1}}],[\"inter\",{\"1\":{\"537\":1}}],[\"interest\",{\"1\":{\"387\":1}}],[\"interpolate\",{\"1\":{\"388\":1,\"463\":2}}],[\"interpolated\",{\"1\":{\"98\":1,\"100\":4}}],[\"interpolation=args\",{\"1\":{\"802\":2}}],[\"interpolation=image\",{\"1\":{\"186\":3}}],[\"interpolation\",{\"1\":{\"179\":1,\"387\":1,\"802\":2}}],[\"interleave\",{\"1\":{\"143\":1,\"313\":1}}],[\"intersect\",{\"1\":{\"82\":3}}],[\"intersection\",{\"0\":{\"469\":1},\"1\":{\"22\":1,\"78\":4,\"82\":3,\"467\":2,\"468\":3,\"469\":6,\"473\":2}}],[\"internlm2\",{\"1\":{\"222\":1,\"227\":1}}],[\"internlm\",{\"1\":{\"198\":1}}],[\"internvit\",{\"1\":{\"189\":1,\"196\":1,\"197\":2,\"198\":4,\"199\":4,\"201\":2,\"204\":2,\"205\":1,\"206\":1,\"208\":1,\"209\":1,\"215\":1,\"216\":1,\"220\":1,\"222\":1,\"223\":3,\"227\":1}}],[\"internvl通过组合视觉编码器和语言中间件\",{\"1\":{\"197\":1}}],[\"internvl通过规模化视觉编码器和渐进式跨模态对齐\",{\"1\":{\"194\":1}}],[\"internvl可灵活切换为四种模式\",{\"1\":{\"196\":1}}],[\"internvl的架构设计显著区别于\",{\"1\":{\"196\":1}}],[\"internvl的整体架构\",{\"1\":{\"196\":1}}],[\"internvl在32个通用视觉\",{\"1\":{\"188\":1}}],[\"internvl是一个大规模视觉\",{\"1\":{\"188\":1}}],[\"internvl\",{\"0\":{\"187\":1,\"214\":1},\"1\":{\"10\":1,\"28\":1,\"187\":2,\"189\":1,\"196\":3,\"197\":2,\"198\":1,\"199\":1,\"202\":5,\"203\":3,\"205\":1,\"206\":2,\"210\":2,\"215\":2,\"216\":1,\"220\":1,\"222\":1,\"223\":1,\"225\":1,\"227\":1,\"230\":1}}],[\"internet\",{\"1\":{\"28\":1}}],[\"interact\",{\"1\":{\"28\":4}}],[\"interacts\",{\"1\":{\"28\":2}}],[\"interactive\",{\"1\":{\"12\":1,\"28\":2,\"59\":2}}],[\"interaction的简写\",{\"1\":{\"282\":1}}],[\"interactions\",{\"1\":{\"28\":4,\"37\":1,\"47\":1}}],[\"interaction\",{\"0\":{\"283\":1},\"1\":{\"11\":1,\"12\":1,\"28\":12,\"48\":1,\"104\":1,\"282\":1}}],[\"initialize\",{\"1\":{\"254\":1,\"478\":1,\"840\":1}}],[\"initialized\",{\"1\":{\"170\":1,\"274\":1}}],[\"init=false\",{\"1\":{\"170\":2}}],[\"init=true\",{\"1\":{\"169\":1}}],[\"initted\",{\"1\":{\"169\":4,\"170\":3}}],[\"init\",{\"0\":{\"160\":1,\"254\":1},\"1\":{\"29\":2,\"34\":4,\"35\":4,\"36\":4,\"41\":2,\"45\":4,\"46\":2,\"58\":2,\"59\":12,\"68\":1,\"73\":2,\"78\":2,\"92\":2,\"93\":2,\"96\":4,\"100\":2,\"101\":2,\"107\":2,\"109\":2,\"110\":2,\"111\":2,\"142\":4,\"145\":4,\"146\":2,\"147\":5,\"160\":3,\"163\":1,\"169\":14,\"170\":17,\"186\":5,\"252\":2,\"254\":2,\"272\":18,\"274\":8,\"289\":2,\"290\":1,\"292\":2,\"295\":4,\"316\":1,\"318\":2,\"319\":3,\"320\":4,\"321\":4,\"322\":2,\"323\":5,\"351\":1,\"439\":2,\"467\":2,\"468\":2,\"469\":2,\"470\":2,\"471\":2,\"473\":2,\"478\":1,\"544\":1,\"578\":1,\"580\":2,\"590\":2,\"591\":2,\"597\":2,\"599\":6,\"600\":2,\"601\":2,\"602\":3,\"603\":3,\"605\":2,\"606\":2,\"607\":2,\"609\":2,\"610\":2,\"611\":2,\"612\":2,\"615\":2,\"617\":2,\"618\":2,\"623\":2,\"624\":2,\"626\":2,\"627\":2,\"628\":2,\"630\":2,\"631\":2,\"632\":2,\"637\":1,\"659\":1,\"673\":1,\"686\":1,\"689\":1,\"690\":1,\"691\":3,\"793\":4,\"801\":1,\"802\":1,\"804\":2,\"814\":1,\"817\":2,\"821\":4,\"822\":2,\"840\":4,\"848\":4,\"853\":2,\"859\":2,\"885\":8,\"886\":4}}],[\"in\",{\"1\":{\"28\":7,\"29\":3,\"35\":3,\"43\":1,\"46\":3,\"47\":1,\"58\":2,\"59\":5,\"68\":4,\"80\":4,\"81\":2,\"82\":5,\"83\":1,\"92\":6,\"93\":4,\"96\":8,\"100\":5,\"101\":8,\"142\":2,\"143\":1,\"145\":4,\"147\":5,\"157\":1,\"159\":1,\"162\":2,\"170\":1,\"172\":2,\"186\":12,\"201\":3,\"252\":2,\"254\":1,\"256\":1,\"272\":9,\"273\":2,\"274\":9,\"275\":10,\"276\":1,\"277\":4,\"278\":7,\"290\":2,\"300\":2,\"301\":1,\"302\":7,\"304\":7,\"310\":2,\"311\":2,\"312\":1,\"316\":10,\"318\":4,\"319\":3,\"320\":2,\"321\":8,\"323\":4,\"327\":3,\"336\":4,\"374\":2,\"389\":2,\"390\":2,\"403\":1,\"463\":2,\"476\":18,\"477\":7,\"478\":33,\"488\":1,\"501\":1,\"502\":1,\"503\":1,\"527\":1,\"531\":1,\"541\":9,\"544\":2,\"577\":5,\"578\":9,\"579\":8,\"580\":2,\"581\":4,\"584\":1,\"594\":1,\"600\":2,\"605\":1,\"623\":1,\"628\":2,\"631\":1,\"632\":4,\"681\":3,\"682\":2,\"684\":2,\"686\":7,\"687\":2,\"688\":9,\"690\":2,\"696\":5,\"697\":2,\"793\":9,\"801\":3,\"803\":2,\"804\":4,\"815\":1,\"817\":1,\"820\":2,\"821\":6,\"840\":4,\"848\":6,\"856\":2,\"857\":2,\"860\":2,\"861\":1,\"885\":6,\"886\":10}}],[\"提交的\",{\"1\":{\"537\":1}}],[\"提前做好的假设\",{\"1\":{\"314\":1}}],[\"提示仍可能触发毒性响应\",{\"1\":{\"551\":1}}],[\"提示下\",{\"1\":{\"538\":1}}],[\"提示下生成翻译\",{\"1\":{\"521\":1}}],[\"提示时\",{\"1\":{\"536\":1,\"538\":1}}],[\"提示未来需在结构理解与逻辑泛化方面进一步改进\",{\"1\":{\"529\":1}}],[\"提示+top\",{\"1\":{\"522\":1}}],[\"提示生成答案\",{\"1\":{\"522\":1}}],[\"提示词列表的\",{\"1\":{\"544\":1}}],[\"提示词列表\",{\"1\":{\"544\":1}}],[\"提示词工程\",{\"1\":{\"497\":1}}],[\"提示词\",{\"1\":{\"497\":1}}],[\"提示\",{\"1\":{\"301\":1}}],[\"提示调优\",{\"1\":{\"239\":2}}],[\"提出掩码图像建模\",{\"1\":{\"765\":1}}],[\"提出并开源\",{\"1\":{\"577\":1}}],[\"提出数据\",{\"1\":{\"552\":1}}],[\"提出了\",{\"1\":{\"787\":1}}],[\"提出了一种基于\",{\"1\":{\"766\":1}}],[\"提出了一种通过人类偏好比较训练代理的强化学习方法\",{\"1\":{\"536\":1}}],[\"提出了更先进的方法\",{\"1\":{\"386\":1}}],[\"提出全局\",{\"1\":{\"265\":1}}],[\"提出统一视觉\",{\"1\":{\"260\":1}}],[\"提出使用\",{\"1\":{\"157\":1}}],[\"提出动量蒸馏\",{\"1\":{\"149\":1}}],[\"提出\",{\"1\":{\"122\":2,\"165\":1,\"176\":1,\"264\":1,\"766\":1}}],[\"提出的辅助文本\",{\"1\":{\"811\":1}}],[\"提出的一种通过\",{\"1\":{\"232\":1}}],[\"提出的\",{\"1\":{\"49\":1,\"127\":1,\"150\":1,\"537\":1,\"704\":1}}],[\"提高效率\",{\"1\":{\"821\":1}}],[\"提高推理效率\",{\"1\":{\"820\":1}}],[\"提高开发效率\",{\"1\":{\"715\":1}}],[\"提高了与外部系统集成的能力\",{\"1\":{\"704\":1}}],[\"提高了大型模型的推理效率\",{\"1\":{\"704\":2}}],[\"提高了灵活性\",{\"1\":{\"681\":1}}],[\"提高了框架的易用性和健壮性\",{\"1\":{\"678\":1}}],[\"提高了模型的性能和效率\",{\"1\":{\"704\":1}}],[\"提高了模型的泛化性和稳健性\",{\"1\":{\"96\":1}}],[\"提高了模型在空间上的泛化能力\",{\"1\":{\"90\":1}}],[\"提高代码健壮性\",{\"1\":{\"673\":1}}],[\"提高执行效率\",{\"1\":{\"669\":1}}],[\"提高逐点判别能力\",{\"1\":{\"468\":1}}],[\"提高其中一个会降低另一个\",{\"1\":{\"446\":1}}],[\"提高分类阈值往往会减少假正例的数量并增加假负例的数量\",{\"1\":{\"446\":1}}],[\"提高多项式阶数\",{\"1\":{\"385\":1}}],[\"提高精度\",{\"1\":{\"385\":2}}],[\"提高训练的稳定性\",{\"1\":{\"317\":1}}],[\"提高判别能力\",{\"1\":{\"274\":1}}],[\"提高深层网络可训练性\",{\"1\":{\"272\":1}}],[\"提高至\",{\"1\":{\"204\":1}}],[\"提高稳定性\",{\"1\":{\"170\":1}}],[\"提高泛化\",{\"1\":{\"159\":1}}],[\"提高泛化能力\",{\"1\":{\"149\":1}}],[\"提高预训练模型在下游任务中的表现\",{\"1\":{\"157\":1}}],[\"提高算法鲁棒性\",{\"1\":{\"96\":1}}],[\"提高模型的性能和输出质量\",{\"1\":{\"709\":1}}],[\"提高模型的收敛速度和性能\",{\"1\":{\"704\":1}}],[\"提高模型的泛化能力\",{\"1\":{\"317\":1}}],[\"提高模型的泛化性能\",{\"1\":{\"96\":1}}],[\"提高模型对语言指令下功能区域的理解能力\",{\"1\":{\"78\":1}}],[\"提升代码可读性\",{\"1\":{\"693\":1}}],[\"提升代码可读性和鲁棒性\",{\"1\":{\"688\":1}}],[\"提升调试效率\",{\"1\":{\"689\":1}}],[\"提升效率的同时改善泛化能力\",{\"1\":{\"567\":1}}],[\"提升显著\",{\"1\":{\"550\":1}}],[\"提升训练稳定性\",{\"1\":{\"548\":1}}],[\"提升训练难度\",{\"1\":{\"161\":1}}],[\"提升\",{\"1\":{\"538\":1}}],[\"提升至52\",{\"1\":{\"522\":1}}],[\"提升监督模型的泛化能力\",{\"1\":{\"511\":1}}],[\"提升边缘识别精度\",{\"1\":{\"468\":1}}],[\"提升边界识别能力\",{\"1\":{\"78\":1}}],[\"提升精度\",{\"1\":{\"385\":1}}],[\"提升依然不明显\",{\"1\":{\"247\":1}}],[\"提升多语言支持\",{\"1\":{\"225\":1}}],[\"提升计算效率\",{\"1\":{\"222\":1}}],[\"提升模型的表达多样性\",{\"1\":{\"800\":1}}],[\"提升模型的少样本学习能力\",{\"1\":{\"527\":1}}],[\"提升模型的泛化性\",{\"1\":{\"220\":1}}],[\"提升模型在各种任务上的泛化能力\",{\"1\":{\"239\":1}}],[\"提升模型鲁棒性\",{\"1\":{\"107\":2}}],[\"提升视觉表征能力\",{\"1\":{\"220\":1}}],[\"提升其视觉理解能力\",{\"1\":{\"215\":1}}],[\"提升检索精度\",{\"1\":{\"196\":1}}],[\"提升表示稳定性和泛化能力\",{\"1\":{\"150\":1}}],[\"提升表示的准确性\",{\"1\":{\"149\":1}}],[\"提升预训练及下游表现\",{\"1\":{\"149\":1}}],[\"提升了多语言能力\",{\"1\":{\"704\":1}}],[\"提升了多模态学习效果\",{\"1\":{\"124\":1}}],[\"提升了准确率\",{\"1\":{\"184\":1}}],[\"提升了模型的泛化能力和稳定性\",{\"1\":{\"105\":1}}],[\"提升泛化能力\",{\"1\":{\"7\":1,\"66\":1,\"122\":1,\"562\":1}}],[\"提炼问题本质\",{\"1\":{\"63\":1}}],[\"提供理论解释\",{\"1\":{\"766\":1}}],[\"提供可视化界面和性能分析工具\",{\"1\":{\"715\":1}}],[\"提供可扩展\",{\"1\":{\"715\":1}}],[\"提供基础架构和工具\",{\"1\":{\"715\":1}}],[\"提供个性化体验\",{\"1\":{\"704\":1}}],[\"提供20b参数开源基线\",{\"1\":{\"552\":1}}],[\"提供现实路径\",{\"1\":{\"539\":1}}],[\"提供高质量示范\",{\"1\":{\"537\":1}}],[\"提供一条示例和任务描述\",{\"1\":{\"528\":1}}],[\"提供一个又大又一致的字典\",{\"1\":{\"246\":1}}],[\"提供的预训练好的\",{\"1\":{\"792\":1}}],[\"提供的视觉\",{\"1\":{\"787\":1}}],[\"提供的\",{\"1\":{\"712\":1}}],[\"提供的一个采样器\",{\"1\":{\"403\":1}}],[\"提供的一个计数器类\",{\"1\":{\"401\":1}}],[\"提供的一个函数\",{\"1\":{\"399\":1}}],[\"提供的统一入口\",{\"1\":{\"396\":1}}],[\"提供的相似度矩阵完成\",{\"1\":{\"278\":1}}],[\"提供的点云和功能区域标注构建\",{\"1\":{\"62\":1}}],[\"提供了稳定基础\",{\"1\":{\"790\":1}}],[\"提供了新方向\",{\"1\":{\"786\":1}}],[\"提供了基础抽象和\",{\"1\":{\"715\":1}}],[\"提供了丰富的智能体和工具集合\",{\"1\":{\"714\":1}}],[\"提供了业界领先的调试和观测功能\",{\"1\":{\"714\":1}}],[\"提供了一系列强大的输出解析工具\",{\"1\":{\"714\":1}}],[\"提供了一个用于测试模型生成信息真实性的基准数据集\",{\"1\":{\"536\":1}}],[\"提供了一种更可行的替代方法\",{\"1\":{\"248\":1}}],[\"提供了重要基准\",{\"1\":{\"522\":1}}],[\"提供了这些输入的简洁描述\",{\"1\":{\"512\":1}}],[\"提供了大量在\",{\"1\":{\"395\":1}}],[\"提供了\",{\"1\":{\"274\":1,\"346\":1,\"717\":1,\"795\":1}}],[\"提供强大的语言理解能力\",{\"1\":{\"222\":1}}],[\"提供两种配置\",{\"1\":{\"210\":1}}],[\"提供更多额外信息\",{\"1\":{\"133\":1}}],[\"提供新描述\",{\"1\":{\"132\":1}}],[\"提供三种标准划分方式\",{\"1\":{\"20\":1}}],[\"提取训练集中每个图像对应的离散\",{\"1\":{\"886\":1}}],[\"提取上下文特征\",{\"1\":{\"804\":1}}],[\"提取被遮挡位置上的目标\",{\"1\":{\"803\":1}}],[\"提取并去重后用于训练\",{\"1\":{\"537\":1}}],[\"提取输入图像的特征\",{\"1\":{\"319\":1,\"320\":1,\"323\":1}}],[\"提取语言模型损失\",{\"1\":{\"312\":1}}],[\"提取语言建模损失\",{\"1\":{\"142\":1}}],[\"提取文本特征\",{\"1\":{\"300\":1}}],[\"提取速度相对更快\",{\"1\":{\"280\":1}}],[\"提取每条\",{\"1\":{\"234\":1}}],[\"提取每一点的特征向量\",{\"1\":{\"107\":1}}],[\"提取的特征\",{\"1\":{\"804\":1}}],[\"提取的特征图转换为序列形式\",{\"1\":{\"326\":1}}],[\"提取的特征不具备独特优势\",{\"1\":{\"173\":1}}],[\"提取的图像特征则是分类器的输入数据\",{\"1\":{\"300\":1}}],[\"提取的关键点集合\",{\"1\":{\"112\":1}}],[\"提取样本维度\",{\"1\":{\"170\":1}}],[\"提取视觉特征\",{\"1\":{\"147\":1}}],[\"提取图像特征\",{\"1\":{\"235\":1,\"300\":1,\"313\":1}}],[\"提取图像特征表示\",{\"1\":{\"142\":1}}],[\"提取图像和文本特征\",{\"1\":{\"145\":1}}],[\"提取图像和点云的特征\",{\"1\":{\"40\":1}}],[\"提取全局特征\",{\"1\":{\"110\":2}}],[\"提取更高维的特征\",{\"1\":{\"109\":1}}],[\"提取更高级的特征表示\",{\"1\":{\"73\":1}}],[\"提取邻近点的特征\",{\"1\":{\"100\":1}}],[\"提取局部特征\",{\"1\":{\"99\":1}}],[\"提取点云的层次化特征\",{\"1\":{\"93\":1}}],[\"提取这些区域的高维特征\",{\"1\":{\"92\":1}}],[\"提取这些局部区域中的点及其特征\",{\"1\":{\"92\":1}}],[\"提取\",{\"1\":{\"40\":2,\"147\":1,\"162\":1,\"277\":3,\"580\":1}}],[\"提取特征值\",{\"1\":{\"387\":1}}],[\"提取特征\",{\"1\":{\"8\":1,\"98\":1,\"105\":1,\"111\":1,\"112\":2}}],[\"提取几何属性\",{\"1\":{\"6\":1}}],[\"的运算\",{\"1\":{\"881\":1}}],[\"的运算符重载中\",{\"1\":{\"690\":1}}],[\"的技术来完成梯度复制\",{\"1\":{\"881\":1}}],[\"的技巧\",{\"1\":{\"796\":1}}],[\"的离散编码\",{\"1\":{\"880\":1,\"881\":1}}],[\"的离散编码器中\",{\"1\":{\"796\":1}}],[\"的某种平均值\",{\"1\":{\"874\":1}}],[\"的某个概率分布\",{\"1\":{\"826\":1}}],[\"的情况完全一致\",{\"1\":{\"873\":1}}],[\"的情况下生成的\",{\"1\":{\"811\":1}}],[\"的情况下优于之前专门训练的模型\",{\"1\":{\"806\":1}}],[\"的情况下\",{\"1\":{\"759\":1,\"868\":1,\"872\":1}}],[\"的情况下表现优异\",{\"1\":{\"467\":1}}],[\"的情况下会将随机垃圾邮件的垃圾邮件概率设为高于随机合法邮件的垃圾邮件概率\",{\"1\":{\"451\":1}}],[\"的调节参数\",{\"1\":{\"873\":1}}],[\"的额外信息\",{\"1\":{\"872\":1}}],[\"的曲率来说足够小\",{\"1\":{\"871\":1}}],[\"的那个函数\",{\"1\":{\"871\":1}}],[\"的角度说也行\",{\"1\":{\"881\":1}}],[\"的角度看\",{\"1\":{\"873\":1}}],[\"的角度描述\",{\"1\":{\"870\":1}}],[\"的角色进行分类\",{\"1\":{\"616\":1}}],[\"的同时\",{\"1\":{\"870\":1}}],[\"的同时保持训练的稳定性和多样性\",{\"1\":{\"162\":1}}],[\"的学习过程是可行的\",{\"1\":{\"870\":1}}],[\"的学习包含两个模块\",{\"1\":{\"770\":1}}],[\"的工作流程是这样的\",{\"1\":{\"869\":1}}],[\"的工作属于对上述方法的泛化\",{\"1\":{\"536\":1}}],[\"的下界\",{\"1\":{\"869\":1}}],[\"的右侧是\",{\"1\":{\"869\":1}}],[\"的似然概率\",{\"1\":{\"869\":1}}],[\"的似然使用\",{\"1\":{\"808\":1}}],[\"的连续函数\",{\"1\":{\"868\":1}}],[\"的连续梯度\",{\"1\":{\"796\":1}}],[\"的近似误差可以为零\",{\"1\":{\"871\":1}}],[\"的近似\",{\"1\":{\"868\":1}}],[\"的潜变量\",{\"1\":{\"867\":1}}],[\"的估计几乎没有贡献\",{\"1\":{\"867\":1}}],[\"的欧式距离为\",{\"1\":{\"866\":2}}],[\"的欧几里得范数\",{\"1\":{\"391\":1}}],[\"的积分\",{\"1\":{\"866\":1}}],[\"的积分为\",{\"1\":{\"752\":1}}],[\"的高斯分布\",{\"1\":{\"865\":1,\"871\":1}}],[\"的高质量数据\",{\"1\":{\"521\":1}}],[\"的顺序\",{\"1\":{\"846\":1}}],[\"的顺序排序\",{\"1\":{\"476\":1}}],[\"的顺序排列\",{\"1\":{\"428\":2}}],[\"的约束\",{\"1\":{\"845\":2}}],[\"的确\",{\"1\":{\"843\":1}}],[\"的任意可学习的确定性函数\",{\"1\":{\"868\":1}}],[\"的任意假设\",{\"1\":{\"825\":1}}],[\"的任务分布\",{\"1\":{\"537\":1}}],[\"的展平维度\",{\"1\":{\"822\":1}}],[\"的动机来源\",{\"1\":{\"872\":1}}],[\"的动效\",{\"1\":{\"821\":1}}],[\"的动量蒸馏损失为\",{\"1\":{\"157\":1}}],[\"的幂\",{\"1\":{\"821\":1}}],[\"的集合\",{\"1\":{\"820\":1}}],[\"的采样也是很方便的\",{\"1\":{\"847\":1}}],[\"的采样\",{\"1\":{\"820\":1}}],[\"的嵌入向量\",{\"1\":{\"820\":1}}],[\"的嵌入维度\",{\"1\":{\"793\":1}}],[\"的回溯性验证\",{\"0\":{\"820\":1}}],[\"的回答\",{\"1\":{\"28\":2}}],[\"的打分\",{\"1\":{\"819\":1}}],[\"的起始\",{\"1\":{\"817\":1}}],[\"的起始图像\",{\"1\":{\"817\":1}}],[\"的放大系数\",{\"1\":{\"816\":1}}],[\"的比例来融合\",{\"1\":{\"815\":1}}],[\"的二维\",{\"1\":{\"814\":1}}],[\"的二维结构形状\",{\"1\":{\"804\":1}}],[\"的扩展版本\",{\"1\":{\"810\":1}}],[\"的初步实验中\",{\"1\":{\"809\":1}}],[\"的初始化函数\",{\"1\":{\"848\":1}}],[\"的初始化方法\",{\"1\":{\"821\":1}}],[\"的初始化方法随机初始化\",{\"1\":{\"208\":1}}],[\"的初始维度对结果的影响\",{\"0\":{\"406\":1}}],[\"的先验分布是均匀分布\",{\"1\":{\"881\":1}}],[\"的先验分布\",{\"1\":{\"809\":1}}],[\"的先验信念\",{\"1\":{\"758\":1}}],[\"的联合概率\",{\"1\":{\"807\":1}}],[\"的联合先验\",{\"1\":{\"807\":1}}],[\"的联合分布\",{\"1\":{\"807\":3}}],[\"的上下文长度减少了\",{\"1\":{\"807\":1}}],[\"的卷积操作来提取\",{\"1\":{\"804\":1}}],[\"的误差\",{\"1\":{\"803\":1,\"881\":1}}],[\"的典型问题\",{\"1\":{\"800\":1}}],[\"的鲁棒性的损失函数\",{\"1\":{\"797\":1}}],[\"的平滑性与\",{\"1\":{\"797\":1}}],[\"的差异\",{\"1\":{\"794\":1,\"798\":1,\"837\":2}}],[\"的差距已显著缩小\",{\"1\":{\"522\":1}}],[\"的种类数\",{\"1\":{\"793\":1}}],[\"的像素\",{\"1\":{\"788\":1,\"846\":1}}],[\"的后续工作之一\",{\"1\":{\"788\":1}}],[\"的微调方式\",{\"1\":{\"775\":1}}],[\"的微调方法\",{\"1\":{\"488\":1}}],[\"的稳定训练非常关键\",{\"1\":{\"774\":1}}],[\"的配置\",{\"1\":{\"774\":1}}],[\"的思路\",{\"1\":{\"773\":1}}],[\"的思想与之有相通之处\",{\"1\":{\"495\":1}}],[\"的思想很简单\",{\"1\":{\"492\":1}}],[\"的思想有深刻的相似性\",{\"1\":{\"385\":1}}],[\"的思想\",{\"1\":{\"175\":1,\"788\":1}}],[\"的证据下界\",{\"1\":{\"773\":1}}],[\"的原因\",{\"1\":{\"885\":1}}],[\"的原则\",{\"1\":{\"872\":1}}],[\"的原始像素\",{\"1\":{\"772\":1}}],[\"的原像\",{\"1\":{\"727\":1}}],[\"的启发\",{\"1\":{\"772\":1}}],[\"的启发下\",{\"1\":{\"175\":1}}],[\"的总数进行归一化\",{\"1\":{\"809\":1}}],[\"的总数量\",{\"1\":{\"804\":1}}],[\"的总数\",{\"1\":{\"772\":1}}],[\"的总概率\",{\"1\":{\"727\":1}}],[\"的总概率是多少\",{\"1\":{\"727\":1}}],[\"的解决方案是\",{\"1\":{\"766\":1}}],[\"的薄壳层上\",{\"1\":{\"755\":1}}],[\"的速率快速增长\",{\"1\":{\"754\":1}}],[\"的马氏距离\",{\"1\":{\"752\":1}}],[\"的版本\",{\"1\":{\"749\":1}}],[\"的柯西分布进行\",{\"1\":{\"749\":1}}],[\"的泊松分布\",{\"1\":{\"739\":1}}],[\"的条件概率\",{\"1\":{\"865\":1}}],[\"的条件下是条件独立的\",{\"1\":{\"730\":1}}],[\"的条件输入\",{\"1\":{\"143\":1}}],[\"的补集\",{\"1\":{\"729\":1}}],[\"的事件时的平均信息量\",{\"1\":{\"830\":1}}],[\"的事件\",{\"1\":{\"729\":1,\"732\":1}}],[\"的区间生成的最小\",{\"1\":{\"728\":1}}],[\"的区域\",{\"1\":{\"178\":1,\"386\":1,\"468\":1,\"616\":1}}],[\"的要求\",{\"1\":{\"728\":1}}],[\"的次数\",{\"1\":{\"727\":1}}],[\"的生态系统\",{\"1\":{\"715\":1}}],[\"的生成逻辑\",{\"1\":{\"29\":1}}],[\"的持续优化和功能迭代\",{\"1\":{\"714\":1}}],[\"的巨大成功激发了越来越多的开发者兴趣\",{\"1\":{\"712\":1}}],[\"的战略\",{\"1\":{\"708\":1}}],[\"的概念\",{\"1\":{\"707\":1}}],[\"的概率模型\",{\"1\":{\"847\":1}}],[\"的概率水平翻转\",{\"1\":{\"802\":1}}],[\"的概率是\",{\"1\":{\"731\":1}}],[\"的概率是多少\",{\"1\":{\"727\":1}}],[\"的概率\",{\"1\":{\"729\":1,\"738\":1,\"795\":1,\"843\":1,\"847\":1,\"854\":1}}],[\"的概率都是\",{\"1\":{\"727\":1}}],[\"的概率最大\",{\"1\":{\"575\":1}}],[\"的概率随机水平翻转图像\",{\"1\":{\"317\":1}}],[\"的概率随机将输入文本中的\",{\"1\":{\"155\":1}}],[\"的概率分布\",{\"1\":{\"155\":1,\"727\":1,\"759\":1,\"820\":1}}],[\"的概率值\",{\"1\":{\"46\":1,\"78\":1,\"469\":1,\"470\":1}}],[\"的支持\",{\"1\":{\"704\":1,\"714\":1}}],[\"的卓越能力\",{\"1\":{\"704\":1}}],[\"的基础上允许通道看到自己当前值\",{\"1\":{\"846\":1}}],[\"的基础上将双向\",{\"1\":{\"126\":1}}],[\"的基础语言模型\",{\"1\":{\"704\":1}}],[\"的会话应用\",{\"1\":{\"704\":1}}],[\"的推出\",{\"1\":{\"703\":1}}],[\"的推理过程实际执行过程中\",{\"1\":{\"817\":1}}],[\"的推理水平\",{\"1\":{\"704\":1}}],[\"的推理机制\",{\"0\":{\"236\":1}}],[\"的推理能力\",{\"1\":{\"5\":1}}],[\"的深度集成\",{\"1\":{\"714\":1}}],[\"的深度学习训练系统\",{\"1\":{\"700\":1}}],[\"的深度融合\",{\"1\":{\"69\":1}}],[\"的等高线\",{\"1\":{\"697\":1}}],[\"的内存管理与执行流程\",{\"1\":{\"695\":1}}],[\"的内容向量\",{\"1\":{\"590\":2}}],[\"的完整优化目标中\",{\"1\":{\"873\":1}}],[\"的完整实现\",{\"1\":{\"690\":1}}],[\"的完整计算流程\",{\"1\":{\"311\":1}}],[\"的梯度直接原封不动地复制到\",{\"1\":{\"881\":1}}],[\"的梯度来自两个路径\",{\"1\":{\"684\":1}}],[\"的梯度就始终为\",{\"1\":{\"493\":1}}],[\"的导数值对应于gxs\",{\"1\":{\"682\":1}}],[\"的导数\",{\"1\":{\"660\":1}}],[\"的神经网络\",{\"1\":{\"871\":1}}],[\"的神经网络架构\",{\"1\":{\"622\":1}}],[\"的神经网络模型\",{\"1\":{\"510\":1}}],[\"的隐藏状态\",{\"1\":{\"614\":1}}],[\"的隐藏维度\",{\"1\":{\"321\":1,\"814\":1}}],[\"的问答任务中\",{\"1\":{\"614\":1}}],[\"的问题\",{\"1\":{\"188\":1,\"470\":2,\"538\":1,\"878\":2,\"883\":1}}],[\"的桶号\",{\"1\":{\"591\":1}}],[\"的桶索引\",{\"1\":{\"591\":1}}],[\"的做法\",{\"1\":{\"591\":2,\"846\":1}}],[\"的做法是\",{\"1\":{\"590\":1}}],[\"的序列\",{\"1\":{\"591\":1,\"614\":1}}],[\"的序列挤占了下游任务的输入序列空间\",{\"1\":{\"491\":1}}],[\"的轴\",{\"1\":{\"590\":1}}],[\"的轴扩展至目标大小\",{\"1\":{\"427\":1}}],[\"的词表大小\",{\"1\":{\"814\":1}}],[\"的词表大小为\",{\"1\":{\"774\":1}}],[\"的词\",{\"1\":{\"802\":1}}],[\"的词嵌入向量上\",{\"1\":{\"587\":1}}],[\"的词执行掩码策略\",{\"1\":{\"579\":1}}],[\"的编码表示\",{\"1\":{\"772\":1}}],[\"的编码和对应位置的可学习位置编码向量相加\",{\"1\":{\"588\":1}}],[\"的编码向量中的\",{\"1\":{\"587\":1}}],[\"的编码向量为\",{\"1\":{\"587\":1}}],[\"的编码器和解码器\",{\"1\":{\"880\":1}}],[\"的编码器其实不会显式地输出离散编码\",{\"1\":{\"880\":1}}],[\"的编码器\",{\"1\":{\"250\":1}}],[\"的编码器被用作\",{\"1\":{\"165\":1}}],[\"的子集\",{\"1\":{\"577\":1}}],[\"的几率原封不动\",{\"1\":{\"572\":1}}],[\"的几率被替换成任意一个其它的\",{\"1\":{\"572\":1}}],[\"的几率被替换成\",{\"1\":{\"572\":1}}],[\"的时候也只计算被遮盖部分的\",{\"1\":{\"572\":1}}],[\"的时间复杂度虽然是\",{\"1\":{\"112\":1}}],[\"的单词进行掩码\",{\"1\":{\"562\":1}}],[\"的固定学习率\",{\"1\":{\"561\":1}}],[\"的固定大小特征图\",{\"1\":{\"386\":1}}],[\"的竞争力\",{\"1\":{\"547\":1}}],[\"的缓存\",{\"1\":{\"544\":1}}],[\"的出发点就在这里\",{\"1\":{\"541\":1}}],[\"的出现让人们重新思考了\",{\"1\":{\"708\":1}}],[\"的出现也掀起了新一轮的研究热潮\",{\"1\":{\"297\":1}}],[\"的出现\",{\"1\":{\"7\":1}}],[\"的模型战略形成了\",{\"1\":{\"704\":1}}],[\"的模型\",{\"1\":{\"539\":1,\"616\":1,\"864\":1}}],[\"的模块\",{\"1\":{\"107\":1}}],[\"的通用方法\",{\"1\":{\"539\":1}}],[\"的通用性\",{\"1\":{\"521\":1}}],[\"的答案\",{\"1\":{\"538\":1}}],[\"的残差\",{\"1\":{\"537\":1}}],[\"的监督信号\",{\"1\":{\"537\":1}}],[\"的三步训练流程\",{\"1\":{\"537\":1}}],[\"的详细总结\",{\"1\":{\"536\":1}}],[\"的控制\",{\"1\":{\"536\":1}}],[\"的偏移量\",{\"1\":{\"815\":1}}],[\"的偏置值\",{\"1\":{\"591\":1}}],[\"的偏置\",{\"1\":{\"591\":1}}],[\"的偏置矩阵\",{\"1\":{\"591\":1}}],[\"的偏好比为\",{\"1\":{\"538\":1}}],[\"的偏好\",{\"1\":{\"535\":1}}],[\"的偏离平均值的乘积\",{\"1\":{\"455\":1}}],[\"的新判断\",{\"1\":{\"758\":1}}],[\"的新范式\",{\"1\":{\"531\":1}}],[\"的新视图\",{\"1\":{\"425\":1}}],[\"的新视角\",{\"1\":{\"123\":1}}],[\"的理念\",{\"1\":{\"531\":1}}],[\"的假设\",{\"1\":{\"531\":1}}],[\"的提取\",{\"1\":{\"814\":1}}],[\"的提取并非依赖微调\",{\"1\":{\"529\":1}}],[\"的提出\",{\"1\":{\"260\":1}}],[\"的准确率\",{\"1\":{\"529\":1}}],[\"的准确率超越前sota\",{\"1\":{\"522\":1}}],[\"的元学习方法\",{\"1\":{\"528\":1}}],[\"的设定\",{\"1\":{\"528\":1}}],[\"的设计初衷之一就是在潜在空间中学习一个接近于标准正态分布\",{\"1\":{\"857\":1}}],[\"的设计\",{\"1\":{\"239\":1,\"521\":1,\"788\":1}}],[\"的成果表明\",{\"1\":{\"527\":1}}],[\"的成功很大程度上得益于\",{\"1\":{\"173\":1}}],[\"的少样本学习\",{\"1\":{\"521\":1}}],[\"的规模化改进\",{\"1\":{\"521\":1}}],[\"的规模相匹配\",{\"1\":{\"197\":1}}],[\"的零样本能力依赖于任务提示\",{\"1\":{\"521\":1}}],[\"的零样本图像描述结果\",{\"1\":{\"198\":1}}],[\"的外链网页\",{\"1\":{\"521\":1}}],[\"的mqan\",{\"1\":{\"521\":1}}],[\"的mlp层\",{\"1\":{\"100\":1}}],[\"的引入是为了加速自回归模型的推理速度\",{\"1\":{\"544\":1}}],[\"的引入显著提升了语言模型的表达能力\",{\"1\":{\"521\":1}}],[\"的引用\",{\"1\":{\"343\":1}}],[\"的绝对提升\",{\"1\":{\"515\":1}}],[\"的正余弦曲线\",{\"1\":{\"514\":1}}],[\"的正方形\",{\"1\":{\"451\":1}}],[\"的添加的线性输出层来预测\",{\"1\":{\"511\":1}}],[\"的激活状态\",{\"1\":{\"511\":1}}],[\"的变化不敏感\",{\"1\":{\"882\":1}}],[\"的变化较慢\",{\"1\":{\"587\":1}}],[\"的变化较快\",{\"1\":{\"587\":1}}],[\"的变换是一个从数组里取值的操作\",{\"1\":{\"880\":1}}],[\"的变换矩阵\",{\"1\":{\"107\":2}}],[\"的变量\",{\"0\":{\"635\":1}}],[\"的变种\",{\"1\":{\"510\":1}}],[\"的本质是对训练数据的有效压缩\",{\"1\":{\"495\":1}}],[\"的影响\",{\"1\":{\"493\":1}}],[\"的影响就越大\",{\"1\":{\"471\":2}}],[\"的过程\",{\"1\":{\"492\":1,\"847\":1}}],[\"的这种思想有点类似于残差连接\",{\"1\":{\"492\":1}}],[\"的发现\",{\"1\":{\"491\":1}}],[\"的极端值\",{\"1\":{\"473\":1}}],[\"的惩罚比例\",{\"1\":{\"473\":1}}],[\"的惩罚权重\",{\"1\":{\"471\":2}}],[\"的敏感度控制\",{\"1\":{\"471\":1}}],[\"的优化变得困难\",{\"1\":{\"808\":1}}],[\"的优点\",{\"1\":{\"468\":1,\"797\":1}}],[\"的优势\",{\"1\":{\"112\":1,\"326\":1,\"467\":1}}],[\"的替代指标\",{\"1\":{\"467\":1}}],[\"的替代方案\",{\"1\":{\"173\":1}}],[\"的注意力图\",{\"1\":{\"781\":1}}],[\"的注意力权重\",{\"1\":{\"463\":2}}],[\"的注意力模块和视觉专家\",{\"1\":{\"266\":1}}],[\"的距离度量\",{\"1\":{\"459\":1}}],[\"的距离是\",{\"1\":{\"387\":4}}],[\"的协方差矩阵\",{\"1\":{\"459\":1,\"752\":1}}],[\"的期望项\",{\"1\":{\"869\":1}}],[\"的期望替换为对\",{\"1\":{\"808\":1}}],[\"的期望\",{\"1\":{\"455\":1,\"808\":1}}],[\"的度量\",{\"1\":{\"455\":1}}],[\"的阈值\",{\"1\":{\"453\":1}}],[\"的垃圾邮件分类器仅在\",{\"1\":{\"451\":1}}],[\"的垃圾邮件分类器始终会为随机垃圾邮件分配比随机合规电子邮件更高的垃圾邮件概率\",{\"1\":{\"451\":1}}],[\"的满分\",{\"1\":{\"448\":1}}],[\"的满分时\",{\"1\":{\"448\":1}}],[\"的不平衡数据集中\",{\"1\":{\"445\":1,\"446\":1}}],[\"的代码实现展开讲解\",{\"1\":{\"793\":1}}],[\"的代码实现对应的类是\",{\"1\":{\"272\":1}}],[\"的代码组织为可复用的包\",{\"1\":{\"691\":1}}],[\"的代价很高\",{\"1\":{\"453\":1}}],[\"的代价高于另一种错误\",{\"1\":{\"443\":1}}],[\"的列优先\",{\"1\":{\"423\":1}}],[\"的列表\",{\"1\":{\"43\":1}}],[\"的步长是\",{\"1\":{\"423\":4}}],[\"的数量\",{\"1\":{\"818\":1,\"822\":1}}],[\"的数量差别很大\",{\"1\":{\"815\":1}}],[\"的数量相同\",{\"1\":{\"770\":1}}],[\"的数量与图像\",{\"1\":{\"770\":1}}],[\"的数组\",{\"1\":{\"426\":1}}],[\"的数值会很大\",{\"1\":{\"418\":1}}],[\"的数据上进行预训练\",{\"1\":{\"704\":1}}],[\"的数据\",{\"1\":{\"186\":1,\"274\":1}}],[\"的值为\",{\"1\":{\"697\":1}}],[\"的值设置为父函数的\",{\"1\":{\"686\":1}}],[\"的值\",{\"1\":{\"387\":1,\"686\":1,\"818\":2}}],[\"的边界坐标再取整\",{\"1\":{\"387\":1}}],[\"的划分方式中涉及到了取整\",{\"1\":{\"386\":1}}],[\"的小格子做最大池化\",{\"1\":{\"386\":1}}],[\"的网络结构遵循\",{\"1\":{\"774\":1}}],[\"的网络结构可视化理解\",{\"1\":{\"75\":1}}],[\"的网格\",{\"1\":{\"386\":1}}],[\"的函数\",{\"1\":{\"385\":1,\"727\":1,\"758\":1}}],[\"的relu网络可以构造具有\",{\"1\":{\"385\":1}}],[\"的全零张量\",{\"1\":{\"378\":2}}],[\"的全局特征来自于\",{\"1\":{\"112\":1}}],[\"的整体优化目标\",{\"1\":{\"881\":1}}],[\"的整体结构是一个典型的\",{\"1\":{\"99\":1}}],[\"的整数\",{\"1\":{\"375\":1,\"591\":1}}],[\"的简写\",{\"1\":{\"367\":1}}],[\"的泛化\",{\"1\":{\"360\":1,\"808\":1}}],[\"的意思是\",{\"1\":{\"341\":1}}],[\"的形式衰减\",{\"1\":{\"754\":1}}],[\"的形式明确指定的参数\",{\"1\":{\"337\":1}}],[\"的形式\",{\"1\":{\"318\":1,\"854\":1,\"868\":1}}],[\"的形状和位置\",{\"1\":{\"385\":1}}],[\"的形状是\",{\"1\":{\"257\":1,\"590\":1}}],[\"的形状为\",{\"1\":{\"45\":1}}],[\"的张量转置为\",{\"1\":{\"426\":1}}],[\"的张量视图\",{\"1\":{\"361\":1}}],[\"的张量\",{\"1\":{\"317\":2,\"318\":2,\"421\":1,\"425\":1,\"802\":1}}],[\"的generate方法负责完成图像描述生成\",{\"1\":{\"313\":1}}],[\"的text\",{\"1\":{\"313\":1}}],[\"的真实梯度\",{\"1\":{\"868\":1}}],[\"的真实验证\",{\"1\":{\"808\":1}}],[\"的真实导数就会被低估一半\",{\"1\":{\"684\":1}}],[\"的真实值\",{\"1\":{\"312\":1}}],[\"的真正例率\",{\"1\":{\"450\":1}}],[\"的真正价值\",{\"1\":{\"136\":1}}],[\"的向量应该能概括所有\",{\"1\":{\"882\":1}}],[\"的向量数据库\",{\"1\":{\"717\":1}}],[\"的向量映射到词汇表空间\",{\"1\":{\"312\":1}}],[\"的向量量化器\",{\"1\":{\"170\":1}}],[\"的能力相结合\",{\"1\":{\"714\":1}}],[\"的能力\",{\"1\":{\"312\":1,\"704\":1,\"854\":1}}],[\"的相似程度\",{\"1\":{\"869\":1}}],[\"的相似度\",{\"1\":{\"310\":1,\"407\":1,\"822\":1}}],[\"的相对距离找到对应的桶\",{\"1\":{\"591\":1}}],[\"的相对距离\",{\"1\":{\"590\":1,\"591\":1}}],[\"的相对位置\",{\"1\":{\"589\":1,\"591\":1}}],[\"的相同通道进行混合\",{\"1\":{\"73\":1}}],[\"的zero\",{\"1\":{\"305\":1,\"531\":1}}],[\"的架构设计变得更加条理清晰和稳固\",{\"1\":{\"714\":1}}],[\"的架构和训练方法\",{\"1\":{\"560\":1}}],[\"的架构中融入卷积操作\",{\"1\":{\"326\":1}}],[\"的架构\",{\"1\":{\"302\":1}}],[\"的vit\",{\"1\":{\"299\":1}}],[\"的挖掘\",{\"1\":{\"278\":1}}],[\"的日志记录\",{\"1\":{\"277\":1}}],[\"的缩放因子\",{\"1\":{\"277\":1}}],[\"的缩写\",{\"1\":{\"83\":1,\"324\":2,\"395\":1}}],[\"的标签\",{\"1\":{\"277\":1}}],[\"的标签平滑\",{\"1\":{\"127\":1}}],[\"的对数似然\",{\"1\":{\"772\":1}}],[\"的对角线\",{\"1\":{\"451\":1}}],[\"的对齐\",{\"1\":{\"294\":1}}],[\"的对应指标\",{\"1\":{\"276\":1}}],[\"的对比如下\",{\"1\":{\"692\":1}}],[\"的对比\",{\"1\":{\"132\":1,\"469\":1}}],[\"的池化特征\",{\"1\":{\"276\":1}}],[\"的构建\",{\"1\":{\"272\":1}}],[\"的维度复制多次\",{\"1\":{\"873\":1}}],[\"的维度决定\",{\"1\":{\"409\":1}}],[\"的维度对最终注意力输出的结果维度有直接影响\",{\"1\":{\"404\":1}}],[\"的维度命名\",{\"1\":{\"367\":1}}],[\"的维度数相同\",{\"1\":{\"363\":1}}],[\"的维度\",{\"1\":{\"272\":1,\"405\":2,\"590\":2,\"814\":1}}],[\"的维数\",{\"1\":{\"170\":1}}],[\"的共享骨干能够自然融合文本与图像表示\",{\"1\":{\"269\":1}}],[\"的共享自注意力效果更好\",{\"1\":{\"268\":1}}],[\"的共享结构特征\",{\"1\":{\"29\":1}}],[\"的图片\",{\"1\":{\"756\":1}}],[\"的图像时\",{\"1\":{\"811\":1}}],[\"的图像输入\",{\"1\":{\"803\":1}}],[\"的图像变换\",{\"1\":{\"802\":1}}],[\"的图像模型\",{\"1\":{\"788\":1}}],[\"的图像分辨率输入\",{\"1\":{\"774\":1}}],[\"的图像\",{\"1\":{\"772\":1,\"773\":1,\"807\":1,\"845\":1,\"869\":1}}],[\"的图像划分为\",{\"1\":{\"769\":1}}],[\"的图像块\",{\"1\":{\"766\":1}}],[\"的图像块矩阵添加二维\",{\"1\":{\"320\":1}}],[\"的图像内容\",{\"1\":{\"186\":1}}],[\"的图文匹配任务\",{\"1\":{\"268\":1}}],[\"的消融实验\",{\"1\":{\"268\":1}}],[\"的训练阶段分为五个阶段\",{\"1\":{\"885\":1}}],[\"的训练中\",{\"1\":{\"815\":1}}],[\"的训练目标\",{\"1\":{\"802\":1,\"803\":1}}],[\"的训练集上进行预训练\",{\"1\":{\"774\":1}}],[\"的训练\",{\"1\":{\"773\":1}}],[\"的训练存在显著不足\",{\"1\":{\"559\":1}}],[\"的训练数据主要来自以下两个来源\",{\"1\":{\"537\":1}}],[\"的训练过程中\",{\"1\":{\"492\":1}}],[\"的训练样本中采样困难负样本\",{\"1\":{\"268\":2}}],[\"的训练样本中采样\",{\"1\":{\"265\":1}}],[\"的训练流程\",{\"1\":{\"142\":1}}],[\"的局部特征提取能力快速捕捉图像的底层特征\",{\"1\":{\"326\":1}}],[\"的局部采样\",{\"1\":{\"265\":1}}],[\"的局限\",{\"1\":{\"196\":1}}],[\"的和\",{\"1\":{\"263\":1}}],[\"的特例\",{\"1\":{\"492\":1}}],[\"的特点与能力\",{\"0\":{\"705\":1}}],[\"的特点\",{\"1\":{\"261\":1}}],[\"的特征图\",{\"1\":{\"318\":1,\"386\":1,\"387\":1}}],[\"的特征表示\",{\"1\":{\"255\":1}}],[\"的特征从队列中抽离\",{\"1\":{\"246\":1}}],[\"的特征进行汇总\",{\"1\":{\"97\":1}}],[\"的特征进行对齐\",{\"1\":{\"29\":1}}],[\"的特征\",{\"1\":{\"86\":1}}],[\"的特征映射到一个统一的公共特征空间\",{\"1\":{\"59\":1}}],[\"的空间维度为序列维度\",{\"1\":{\"804\":1}}],[\"的空间一致性\",{\"1\":{\"469\":1}}],[\"的空间\",{\"1\":{\"250\":1}}],[\"的信念的机制\",{\"1\":{\"734\":1}}],[\"的信号空间不一致\",{\"1\":{\"247\":1}}],[\"的信息让模型分开上下句\",{\"1\":{\"573\":1}}],[\"的信息\",{\"1\":{\"76\":1}}],[\"的操作流程可以分为三个步骤\",{\"1\":{\"386\":1}}],[\"的操作\",{\"1\":{\"247\":1}}],[\"的改变会非常缓慢\",{\"1\":{\"244\":1}}],[\"的改进\",{\"1\":{\"122\":1,\"470\":1,\"521\":1}}],[\"的改进版\",{\"1\":{\"78\":1,\"470\":1}}],[\"的一种有用指标\",{\"1\":{\"869\":1}}],[\"的一种变体\",{\"1\":{\"797\":1}}],[\"的一种早期形式\",{\"1\":{\"708\":1}}],[\"的一种泛化形式\",{\"1\":{\"471\":1}}],[\"的一种改进或变体\",{\"1\":{\"248\":1}}],[\"的一致性\",{\"1\":{\"468\":1}}],[\"的一个变种\",{\"1\":{\"858\":1}}],[\"的一个下界\",{\"1\":{\"847\":1}}],[\"的一个划分\",{\"1\":{\"731\":1}}],[\"的一个模块\",{\"1\":{\"712\":1}}],[\"的一个杰出应用就是\",{\"1\":{\"703\":1}}],[\"的一个标量偏置\",{\"1\":{\"591\":1}}],[\"的一个\",{\"1\":{\"378\":1}}],[\"的一个参数\",{\"1\":{\"244\":1}}],[\"的一维张量\",{\"1\":{\"375\":1}}],[\"的一系列二分类问题又转为了多分类问题\",{\"1\":{\"248\":1}}],[\"的一部分\",{\"1\":{\"199\":1}}],[\"的研究表明\",{\"1\":{\"547\":1}}],[\"的研究如潮水般涌来\",{\"1\":{\"297\":1}}],[\"的研究\",{\"1\":{\"236\":1}}],[\"的参数是连续且可导的\",{\"1\":{\"868\":1}}],[\"的参数是需要从头开始学习的\",{\"1\":{\"575\":1}}],[\"的参数会发生更新\",{\"1\":{\"493\":1}}],[\"的参数叠加\",{\"1\":{\"492\":1}}],[\"的参数不变\",{\"1\":{\"485\":1}}],[\"的参数初始化\",{\"1\":{\"268\":1}}],[\"的参数初始化自注意力模块和所有模态专家\",{\"1\":{\"268\":1}}],[\"的参数\",{\"1\":{\"235\":1,\"272\":1,\"490\":1,\"492\":1,\"868\":2}}],[\"的关键思想是\",{\"1\":{\"867\":1}}],[\"的关键一步\",{\"1\":{\"235\":1}}],[\"的关注程度\",{\"1\":{\"590\":1}}],[\"的关注信息\",{\"1\":{\"76\":1}}],[\"的指令模型\",{\"1\":{\"704\":1}}],[\"的指令调优版本\",{\"1\":{\"234\":1,\"235\":1}}],[\"的指代准确率\",{\"1\":{\"549\":1}}],[\"的指导\",{\"1\":{\"159\":1}}],[\"的短语\",{\"1\":{\"234\":2}}],[\"的互联网爬取图像\",{\"1\":{\"223\":1}}],[\"的多元高斯分布\",{\"1\":{\"866\":1}}],[\"的多样性\",{\"1\":{\"817\":1}}],[\"的多输入实现\",{\"0\":{\"682\":1}}],[\"的多头注意力里\",{\"1\":{\"591\":1}}],[\"的多种呈现方式\",{\"1\":{\"428\":1}}],[\"的多模态对话能力还体现在\",{\"1\":{\"203\":1}}],[\"的多视图增强策略\",{\"1\":{\"186\":1}}],[\"的每一层\",{\"1\":{\"199\":1}}],[\"的每个元素都是一一对应的\",{\"1\":{\"682\":1}}],[\"的每个\",{\"1\":{\"126\":1}}],[\"的预训练后\",{\"1\":{\"775\":1}}],[\"的预训练可以看作是变分自编码器\",{\"1\":{\"773\":1}}],[\"的预训练\",{\"0\":{\"772\":1}}],[\"的预训练效率和下游任务表现\",{\"1\":{\"560\":1}}],[\"的预训练权重\",{\"1\":{\"198\":1,\"208\":1}}],[\"的预测损失\",{\"1\":{\"815\":1}}],[\"的预测能力\",{\"1\":{\"522\":1}}],[\"的预测\",{\"1\":{\"312\":1}}],[\"的预测分布\",{\"1\":{\"163\":1}}],[\"的预测结果\",{\"1\":{\"123\":1,\"236\":1,\"804\":1}}],[\"的视觉\",{\"1\":{\"770\":1}}],[\"的视觉专家和自注意力模块\",{\"1\":{\"268\":1}}],[\"的视觉编码器\",{\"1\":{\"197\":1}}],[\"的视觉模型架构\",{\"1\":{\"73\":1}}],[\"的涌现进一步加速了多模态研究的进程\",{\"1\":{\"192\":1}}],[\"的快速发展推动了通用人工智能\",{\"1\":{\"189\":1}}],[\"的教师温度\",{\"1\":{\"186\":1}}],[\"的教师模型在训练过程中是\",{\"1\":{\"176\":1}}],[\"的温度系数\",{\"1\":{\"820\":1}}],[\"的温度参数\",{\"1\":{\"793\":1,\"817\":1}}],[\"的温度\",{\"1\":{\"186\":1}}],[\"的宽度\",{\"1\":{\"186\":1}}],[\"的场景可能传进来的是多个张量\",{\"1\":{\"186\":1}}],[\"的吞吐率为\",{\"1\":{\"181\":1}}],[\"的吞吐率仅\",{\"1\":{\"181\":1}}],[\"的增强方式\",{\"1\":{\"179\":1}}],[\"的机制\",{\"1\":{\"179\":1,\"877\":1}}],[\"的方向进化\",{\"1\":{\"695\":1}}],[\"的方法主要基于\",{\"1\":{\"537\":1}}],[\"的方法论\",{\"1\":{\"531\":1}}],[\"的方法可能行不通\",{\"1\":{\"247\":1}}],[\"的方法\",{\"1\":{\"232\":1,\"269\":1,\"457\":1,\"562\":1,\"771\":1,\"878\":1}}],[\"的方法不同\",{\"1\":{\"176\":1}}],[\"的方式也没变\",{\"1\":{\"873\":1}}],[\"的方式克服了这一问题\",{\"1\":{\"772\":1}}],[\"的方式进行视觉预训练\",{\"1\":{\"772\":1}}],[\"的方式不仅降低了学习成本\",{\"1\":{\"690\":1}}],[\"的方式会把prompt搞得很长\",{\"1\":{\"482\":1}}],[\"的方式去读这个数组\",{\"1\":{\"426\":1}}],[\"的方式优化数据质量\",{\"1\":{\"122\":1}}],[\"的方式\",{\"1\":{\"107\":1,\"425\":1,\"500\":1,\"591\":1}}],[\"的方式重构图像\",{\"1\":{\"41\":1}}],[\"的观点\",{\"1\":{\"175\":1}}],[\"的自注意力机制可以自动学会区分图像中的语义区域\",{\"1\":{\"781\":1}}],[\"的自注意力模块中读取\",{\"1\":{\"173\":1}}],[\"的自监督预训练方法\",{\"1\":{\"766\":1,\"790\":1}}],[\"的自监督系统\",{\"1\":{\"173\":1}}],[\"的重合部分\",{\"1\":{\"467\":1}}],[\"的重合度\",{\"1\":{\"78\":1}}],[\"的重要性验证\",{\"1\":{\"204\":1}}],[\"的重要性\",{\"1\":{\"173\":1}}],[\"的语言结构\",{\"1\":{\"820\":1}}],[\"的语言模型\",{\"1\":{\"571\":1}}],[\"的语言建模\",{\"1\":{\"173\":1}}],[\"的语义而不是\",{\"1\":{\"572\":1}}],[\"的语义特征\",{\"1\":{\"167\":1}}],[\"的语义视觉分词器\",{\"1\":{\"165\":1}}],[\"的语义\",{\"1\":{\"41\":2,\"572\":1}}],[\"的掩码语言模型目标在优化后仍具竞争力\",{\"1\":{\"559\":1}}],[\"的掩码预测\",{\"1\":{\"173\":1}}],[\"的掩码图像建模方法\",{\"1\":{\"260\":1}}],[\"的掩码图像建模\",{\"1\":{\"167\":1}}],[\"的码本使用统计\",{\"1\":{\"170\":1}}],[\"的可能取值的了解\",{\"1\":{\"758\":1}}],[\"的可能性最大\",{\"1\":{\"825\":1}}],[\"的可能性\",{\"1\":{\"708\":1}}],[\"的可学习嵌入表\",{\"1\":{\"170\":1}}],[\"的可操作性特征\",{\"1\":{\"46\":1}}],[\"的更新量与原始参数\",{\"1\":{\"490\":1}}],[\"的更新\",{\"1\":{\"170\":1}}],[\"的迭代次数\",{\"1\":{\"170\":1}}],[\"的计算中增加一个旁路\",{\"1\":{\"492\":1}}],[\"的计算步骤可以总结为以下几个核心环节\",{\"1\":{\"170\":1}}],[\"的计算流程如下\",{\"1\":{\"82\":1}}],[\"的使用率\",{\"1\":{\"800\":1}}],[\"的使用计数\",{\"1\":{\"170\":1}}],[\"的使用频率\",{\"1\":{\"170\":1}}],[\"的使用更具计算效率\",{\"1\":{\"126\":1}}],[\"的均值\",{\"1\":{\"169\":1}}],[\"的衰减系数\",{\"1\":{\"169\":1}}],[\"的最大值\",{\"1\":{\"826\":1}}],[\"的最大值处即对应\",{\"1\":{\"826\":1}}],[\"的最大序列长度\",{\"1\":{\"815\":1}}],[\"的最大缺陷在于它\",{\"1\":{\"112\":1}}],[\"的最后一个非思维链模型\",{\"1\":{\"704\":1}}],[\"的最终编码表示\",{\"1\":{\"771\":1}}],[\"的最终编码向量表示图文对\",{\"1\":{\"267\":1}}],[\"的最终输出为这些采样点值的聚合结果\",{\"1\":{\"387\":1}}],[\"的最终隐藏向量作为表示输入分类器\",{\"1\":{\"265\":1}}],[\"的最近邻进行量化\",{\"1\":{\"167\":1}}],[\"的位置为\",{\"1\":{\"818\":1}}],[\"的位置编号\",{\"1\":{\"814\":1}}],[\"的位置预测结果\",{\"1\":{\"804\":1}}],[\"的位置进行预测\",{\"1\":{\"803\":1}}],[\"的位置的预测结果\",{\"1\":{\"803\":1}}],[\"的位置有效\",{\"1\":{\"163\":1}}],[\"的位置计算\",{\"1\":{\"163\":1}}],[\"的位置\",{\"1\":{\"163\":3,\"276\":1,\"364\":1,\"425\":1,\"590\":1,\"614\":1,\"803\":1,\"804\":1,\"822\":1}}],[\"的权重降低\",{\"1\":{\"470\":1}}],[\"的权重系数\",{\"1\":{\"170\":1}}],[\"的权重\",{\"1\":{\"163\":1,\"471\":2}}],[\"的交并比\",{\"1\":{\"468\":1}}],[\"的交互\",{\"1\":{\"319\":1}}],[\"的交叉熵损失分别按批次中该类型\",{\"1\":{\"809\":1}}],[\"的交叉熵损失\",{\"1\":{\"156\":1,\"162\":1,\"276\":1}}],[\"的交集\",{\"1\":{\"78\":1,\"469\":1}}],[\"的文本对\",{\"1\":{\"614\":1}}],[\"的文本生成能力\",{\"1\":{\"313\":1}}],[\"的文本化表示\",{\"1\":{\"234\":1}}],[\"的文本\",{\"1\":{\"155\":1,\"157\":1}}],[\"的前辈模型\",{\"1\":{\"872\":1}}],[\"的前向传播方法通过将输入图像切分为\",{\"1\":{\"804\":1}}],[\"的前提下\",{\"1\":{\"758\":1,\"759\":2}}],[\"的前馈网络替换为\",{\"1\":{\"264\":1}}],[\"的前馈网络为模态专家池\",{\"1\":{\"260\":1}}],[\"的前\",{\"1\":{\"152\":1}}],[\"的前缀\",{\"1\":{\"143\":1}}],[\"的样本\",{\"1\":{\"874\":1}}],[\"的样本索引\",{\"1\":{\"145\":1}}],[\"的样本数量与\",{\"1\":{\"136\":1}}],[\"的样本数\",{\"1\":{\"82\":1}}],[\"的效果会好于其它几种方法\",{\"1\":{\"491\":1}}],[\"的效果最好\",{\"1\":{\"179\":1}}],[\"的效果\",{\"1\":{\"138\":1,\"301\":1}}],[\"的性能提升\",{\"1\":{\"301\":1}}],[\"的性能提升并非源于更长的训练时间\",{\"0\":{\"136\":1}}],[\"的性能会显著下降\",{\"1\":{\"112\":1}}],[\"的大规模网页数据集\",{\"1\":{\"131\":1}}],[\"的大小\",{\"1\":{\"107\":1,\"169\":1,\"170\":2,\"769\":1,\"804\":1,\"814\":1,\"857\":1}}],[\"的贡献包括\",{\"1\":{\"766\":1}}],[\"的贡献\",{\"1\":{\"124\":1,\"268\":1}}],[\"的主要缺陷\",{\"1\":{\"112\":1}}],[\"的主要局限在于其多步推理机制带来了较高的计算复杂度\",{\"1\":{\"26\":1}}],[\"的实验表明移除\",{\"1\":{\"560\":1}}],[\"的实验结果充分证明了其设计策略的有效性\",{\"1\":{\"205\":1}}],[\"的实验仅需1张gpu即可运行\",{\"1\":{\"185\":1}}],[\"的实验\",{\"1\":{\"112\":1}}],[\"的实现逻辑\",{\"1\":{\"685\":1}}],[\"的实现逻辑总是将函数追加到待处理列表的末尾\",{\"1\":{\"685\":1}}],[\"的实现里\",{\"1\":{\"274\":1}}],[\"的实现\",{\"1\":{\"72\":1,\"73\":1,\"690\":4}}],[\"的输出比\",{\"1\":{\"539\":1}}],[\"的输出用于捕获整个句子的全局语义信息\",{\"1\":{\"383\":1}}],[\"的输出向量能够很好地表示图像的全局特征\",{\"1\":{\"319\":2}}],[\"的输出向量被输入到分类头中\",{\"1\":{\"319\":1}}],[\"的输出向量作为图像和文本的聚合表示\",{\"1\":{\"265\":1}}],[\"的输出蕴含了视觉信息\",{\"1\":{\"313\":1}}],[\"的输出\",{\"1\":{\"173\":1,\"178\":1,\"277\":1,\"290\":1,\"313\":1,\"319\":1,\"614\":1,\"804\":1}}],[\"的输出仅由一个不超过\",{\"1\":{\"112\":1}}],[\"的输入格式\",{\"1\":{\"815\":1}}],[\"的输入是一系列图像\",{\"1\":{\"771\":1}}],[\"的输入特征\",{\"1\":{\"769\":1}}],[\"的输入方式是\",{\"1\":{\"618\":1}}],[\"的输入组织形式与普通分类或问答任务略有不同\",{\"1\":{\"618\":1}}],[\"的输入序列\",{\"1\":{\"588\":1,\"618\":1}}],[\"的输入\",{\"1\":{\"277\":1,\"312\":1,\"560\":1,\"802\":1,\"815\":1}}],[\"的输入嵌入\",{\"1\":{\"167\":1}}],[\"的输入和标签副本\",{\"1\":{\"163\":1}}],[\"的输入起点\",{\"1\":{\"143\":1}}],[\"的输入为\",{\"1\":{\"8\":1}}],[\"的限制\",{\"1\":{\"112\":1}}],[\"的表达式为\",{\"1\":{\"748\":1}}],[\"的表达能力\",{\"1\":{\"413\":1}}],[\"的表达能力受\",{\"1\":{\"112\":1}}],[\"的表示能力\",{\"1\":{\"800\":1}}],[\"的表示当前激活的环境\",{\"1\":{\"434\":1}}],[\"的表示\",{\"1\":{\"179\":1,\"580\":1,\"614\":1,\"776\":1}}],[\"的表现优于\",{\"1\":{\"202\":1}}],[\"的表现与最新的自监督系统相当\",{\"1\":{\"173\":1}}],[\"的表现不如基于图结构的模型\",{\"1\":{\"112\":1}}],[\"的分布规律\",{\"1\":{\"886\":1}}],[\"的分布假设\",{\"1\":{\"873\":1}}],[\"的分布参数\",{\"1\":{\"869\":1}}],[\"的分布\",{\"1\":{\"758\":1,\"759\":1,\"807\":1,\"857\":1,\"886\":2}}],[\"的分布被称为半正态分布\",{\"1\":{\"747\":1}}],[\"的分工模式\",{\"1\":{\"587\":1}}],[\"的分辨率\",{\"1\":{\"186\":1}}],[\"的分类任务\",{\"1\":{\"399\":1}}],[\"的分类准确率略低于\",{\"1\":{\"112\":1}}],[\"的分类模块\",{\"1\":{\"110\":1}}],[\"的分割网络将全局特征复制\",{\"1\":{\"112\":1}}],[\"的分割模块通过拼接全局特征\",{\"1\":{\"112\":1}}],[\"的分割模块\",{\"1\":{\"111\":1}}],[\"的作用就像是一个正则化参数\",{\"1\":{\"873\":1}}],[\"的作用是用\",{\"1\":{\"573\":1}}],[\"的作用是通过训练过程中损失值的降低\",{\"1\":{\"319\":1}}],[\"的作用域遵循\",{\"1\":{\"336\":1}}],[\"的作用\",{\"1\":{\"108\":1,\"157\":1,\"277\":1,\"458\":1,\"538\":1,\"873\":1}}],[\"的创新点在于动态分辨率\",{\"1\":{\"220\":1}}],[\"的创新点\",{\"1\":{\"103\":1}}],[\"的核心部分\",{\"1\":{\"700\":1}}],[\"的核心能力\",{\"1\":{\"680\":1}}],[\"的核心\",{\"1\":{\"622\":1}}],[\"的核心实验基于真实用户提交的指令性\",{\"1\":{\"538\":1}}],[\"的核心技术基础是\",{\"1\":{\"536\":1}}],[\"的核心思想\",{\"1\":{\"475\":1}}],[\"的核心思想是\",{\"1\":{\"73\":1,\"232\":1,\"501\":1}}],[\"的核心是\",{\"1\":{\"471\":1}}],[\"的核心组件\",{\"1\":{\"220\":1}}],[\"的核心特征提取模块\",{\"1\":{\"109\":1}}],[\"的核心模块\",{\"1\":{\"100\":1}}],[\"的核心就是逐层提取局部特征\",{\"1\":{\"93\":1}}],[\"的第一个卷积层使用\",{\"1\":{\"845\":1}}],[\"的第一阶段中\",{\"1\":{\"773\":1}}],[\"的第\",{\"1\":{\"92\":1}}],[\"的结合也很简单\",{\"1\":{\"492\":1}}],[\"的结束索引\",{\"1\":{\"186\":1}}],[\"的结构过于简单\",{\"1\":{\"112\":1}}],[\"的结构\",{\"1\":{\"92\":1,\"867\":1}}],[\"的结果相加\",{\"1\":{\"590\":1}}],[\"的结果证明了\",{\"1\":{\"538\":1}}],[\"的结果\",{\"1\":{\"82\":1}}],[\"的点表示给定模型效果最佳的阈值范围\",{\"1\":{\"453\":1}}],[\"的点缺失\",{\"1\":{\"105\":1}}],[\"的点集群都将独立地送入对应的pointnet网络进行特征提取\",{\"1\":{\"95\":1}}],[\"的点及其特征\",{\"1\":{\"92\":1}}],[\"的点全部替换为\",{\"1\":{\"92\":1}}],[\"的点\",{\"1\":{\"92\":1}}],[\"的点云和功能标注\",{\"1\":{\"69\":1}}],[\"的索引整体加偏移\",{\"1\":{\"815\":1}}],[\"的索引必须是\",{\"1\":{\"590\":1}}],[\"的索引数组\",{\"1\":{\"92\":1}}],[\"的索引\",{\"1\":{\"92\":1,\"580\":1,\"770\":1}}],[\"的所有子集的集合\",{\"1\":{\"726\":1}}],[\"的所有单词\",{\"1\":{\"476\":1}}],[\"的所有\",{\"1\":{\"277\":1}}],[\"的所有邻近点\",{\"1\":{\"92\":1}}],[\"的所有通道进行处理\",{\"1\":{\"73\":1}}],[\"的组合形式\",{\"1\":{\"78\":1}}],[\"的加入使得采样变为\",{\"1\":{\"819\":1}}],[\"的加入是为了让\",{\"1\":{\"78\":1}}],[\"的加权组合\",{\"1\":{\"473\":1}}],[\"的加权信息\",{\"1\":{\"410\":1}}],[\"的加权比固定\",{\"1\":{\"159\":1}}],[\"的加权和逼近目标函数\",{\"1\":{\"385\":1}}],[\"的加权和\",{\"1\":{\"78\":1,\"468\":1}}],[\"的得分结果\",{\"1\":{\"76\":1}}],[\"的有效性是否真正来自其机制本身\",{\"1\":{\"136\":1}}],[\"的有效性\",{\"1\":{\"75\":1,\"538\":1}}],[\"的有效性与泛化能力\",{\"1\":{\"21\":1}}],[\"的堆叠结构\",{\"1\":{\"73\":1}}],[\"的行\",{\"1\":{\"68\":1}}],[\"的目标不是只会\",{\"1\":{\"815\":1}}],[\"的目标与贡献\",{\"1\":{\"527\":1}}],[\"的目标就是\",{\"1\":{\"386\":1}}],[\"的目标是近似最大化训练样本的概率\",{\"1\":{\"866\":1}}],[\"的目标是基于编码向量还原被遮挡的图像\",{\"1\":{\"767\":1}}],[\"的目标是抽取有利于当前学习任务的图像重要特征信息汇总\",{\"1\":{\"463\":1}}],[\"的目标是\",{\"1\":{\"71\":1,\"176\":1}}],[\"的目标是预测出与该问题相关的点云区域\",{\"1\":{\"70\":1}}],[\"的目标\",{\"1\":{\"62\":1,\"800\":1}}],[\"的框架\",{\"1\":{\"48\":1}}],[\"的拼接特征\",{\"1\":{\"46\":1}}],[\"的损失函数\",{\"1\":{\"469\":1}}],[\"的损失函数的时候\",{\"1\":{\"248\":1}}],[\"的损失\",{\"1\":{\"40\":1,\"885\":1}}],[\"的\",{\"0\":{\"374\":1},\"1\":{\"24\":2,\"40\":2,\"45\":5,\"76\":1,\"83\":1,\"93\":1,\"96\":1,\"143\":1,\"147\":1,\"161\":1,\"162\":1,\"163\":5,\"170\":1,\"179\":1,\"202\":1,\"203\":1,\"204\":1,\"232\":2,\"248\":2,\"265\":1,\"272\":1,\"274\":3,\"275\":1,\"276\":1,\"277\":3,\"278\":2,\"312\":9,\"372\":1,\"423\":1,\"491\":1,\"514\":2,\"538\":1,\"539\":1,\"542\":1,\"544\":5,\"561\":2,\"572\":1,\"575\":5,\"578\":1,\"590\":3,\"594\":1,\"614\":1,\"616\":1,\"704\":8,\"716\":1,\"762\":1,\"769\":1,\"773\":2,\"774\":1,\"780\":2,\"781\":2,\"795\":2,\"801\":2,\"802\":3,\"807\":1,\"808\":1,\"809\":2,\"814\":3,\"817\":1,\"818\":3,\"819\":1,\"820\":2,\"821\":2,\"837\":1,\"857\":1,\"867\":4,\"881\":1}}],[\"的矩阵\",{\"1\":{\"18\":1,\"108\":1,\"318\":1,\"426\":1}}],[\"6次正面\",{\"1\":{\"825\":1}}],[\"6×3\",{\"1\":{\"801\":1}}],[\"6f\",{\"1\":{\"581\":2}}],[\"6→8\",{\"1\":{\"522\":1}}],[\"66\",{\"1\":{\"522\":1,\"549\":1,\"550\":1}}],[\"665k\",{\"1\":{\"210\":1}}],[\"6平均分数\",{\"1\":{\"516\":1}}],[\"671b\",{\"1\":{\"704\":1}}],[\"67b\",{\"1\":{\"704\":1}}],[\"67b7e751e6b5931a9f45274653f4f653a4e6cdf6\",{\"1\":{\"316\":1}}],[\"67\",{\"1\":{\"399\":1,\"547\":1,\"548\":1,\"549\":1}}],[\"62b\",{\"1\":{\"549\":4,\"550\":1}}],[\"62\",{\"1\":{\"302\":1}}],[\"629\",{\"1\":{\"75\":1,\"82\":1}}],[\"683712\",{\"1\":{\"697\":1}}],[\"683492\",{\"1\":{\"697\":1}}],[\"683271\",{\"1\":{\"697\":1}}],[\"683051\",{\"1\":{\"697\":1}}],[\"682830\",{\"1\":{\"697\":1}}],[\"682609\",{\"1\":{\"697\":1}}],[\"682388\",{\"1\":{\"697\":1}}],[\"682166\",{\"1\":{\"697\":1}}],[\"681\",{\"1\":{\"234\":1}}],[\"6883\",{\"1\":{\"65\":1}}],[\"600m\",{\"1\":{\"250\":1}}],[\"60\",{\"1\":{\"206\":1,\"539\":1,\"809\":1}}],[\"632209862\",{\"1\":{\"849\":1}}],[\"63\",{\"1\":{\"203\":1}}],[\"638\",{\"1\":{\"65\":1}}],[\"6b在mllm预训练阶段学习到的视觉特征具有广泛适用性\",{\"1\":{\"223\":1}}],[\"6b模型进行了持续预训练\",{\"1\":{\"223\":1}}],[\"6b的兼容性\",{\"1\":{\"225\":1}}],[\"6b的大参数规模使其视觉表征能力媲美200亿参数的llms\",{\"1\":{\"216\":1}}],[\"6b的持续学习策略\",{\"1\":{\"216\":1}}],[\"6b提取特征\",{\"1\":{\"197\":1}}],[\"6b是一个基于vision\",{\"1\":{\"197\":1}}],[\"6b处理图像分类\",{\"1\":{\"196\":1}}],[\"6b\",{\"1\":{\"189\":1,\"196\":1,\"197\":1,\"198\":3,\"199\":4,\"201\":2,\"204\":2,\"205\":1,\"206\":1,\"208\":1,\"209\":1,\"215\":1,\"220\":2,\"222\":1,\"223\":3,\"227\":1,\"230\":1,\"537\":1,\"704\":1}}],[\"6章\",{\"1\":{\"134\":1}}],[\"648721270700128\",{\"1\":{\"647\":1}}],[\"64头注意力\",{\"1\":{\"548\":1}}],[\"64×64\",{\"1\":{\"105\":1}}],[\"640\",{\"1\":{\"96\":1,\"208\":1}}],[\"64\",{\"1\":{\"35\":3,\"36\":12,\"46\":1,\"59\":10,\"93\":2,\"96\":7,\"100\":1,\"101\":6,\"107\":4,\"109\":3,\"514\":1,\"549\":3,\"793\":1,\"809\":1,\"814\":1,\"821\":1,\"848\":1,\"886\":4}}],[\"696\",{\"1\":{\"234\":1}}],[\"694\",{\"1\":{\"234\":1}}],[\"69\",{\"1\":{\"23\":1,\"51\":1,\"549\":2}}],[\"65b毒性分0\",{\"1\":{\"551\":1}}],[\"65b平均偏见得分66\",{\"1\":{\"549\":1}}],[\"65b平均得分63\",{\"1\":{\"549\":1}}],[\"65b\",{\"1\":{\"549\":1,\"550\":1}}],[\"65b在humaneval\",{\"1\":{\"549\":1}}],[\"65b在8个常识推理基准\",{\"1\":{\"549\":1}}],[\"65b模型真实答案率仅57\",{\"1\":{\"551\":1}}],[\"65b模型\",{\"1\":{\"549\":1}}],[\"65b模型未经数学微调即达50\",{\"1\":{\"549\":1}}],[\"65b模型以60\",{\"1\":{\"549\":1}}],[\"65b模型在mmlu上提升至68\",{\"1\":{\"549\":1}}],[\"65b模型在零样本和少样本\",{\"1\":{\"549\":1}}],[\"65b模型在2048块a100\",{\"1\":{\"548\":1}}],[\"65b模型在常识推理\",{\"1\":{\"547\":1}}],[\"65b得分57\",{\"1\":{\"549\":1}}],[\"65b则与chinchilla\",{\"1\":{\"546\":1}}],[\"65b的llama的微调要780gb的gpu内存\",{\"1\":{\"488\":1}}],[\"65536\",{\"1\":{\"160\":1,\"186\":1,\"249\":1,\"254\":2}}],[\"65\",{\"1\":{\"22\":1,\"455\":1}}],[\"6\",{\"0\":{\"43\":1,\"67\":1,\"294\":1,\"322\":1,\"857\":1,\"861\":1},\"1\":{\"7\":1,\"17\":1,\"28\":1,\"30\":1,\"36\":1,\"40\":1,\"52\":1,\"58\":1,\"59\":1,\"78\":7,\"80\":1,\"81\":1,\"82\":1,\"83\":1,\"93\":1,\"147\":1,\"152\":3,\"160\":2,\"161\":1,\"163\":1,\"184\":1,\"186\":2,\"202\":1,\"255\":1,\"272\":2,\"273\":1,\"276\":2,\"277\":1,\"313\":1,\"323\":2,\"333\":3,\"364\":3,\"373\":2,\"374\":3,\"385\":1,\"387\":7,\"421\":2,\"422\":2,\"423\":3,\"425\":2,\"426\":7,\"476\":1,\"507\":1,\"521\":1,\"522\":3,\"529\":1,\"530\":1,\"536\":1,\"538\":1,\"541\":1,\"544\":1,\"549\":3,\"551\":1,\"559\":1,\"564\":1,\"580\":2,\"587\":1,\"590\":1,\"591\":6,\"675\":1,\"689\":2,\"692\":1,\"696\":1,\"697\":1,\"704\":5,\"713\":1,\"762\":1,\"809\":1,\"811\":1,\"822\":2,\"825\":1,\"848\":6,\"878\":1}}],[\"但作者认为\",{\"1\":{\"882\":1}}],[\"但作者明确指出\",{\"1\":{\"530\":1}}],[\"但直接拿这个误差来训练是不行的\",{\"1\":{\"881\":1}}],[\"但直接在像素上建模\",{\"1\":{\"788\":1}}],[\"但现在又多出了一个问题\",{\"1\":{\"880\":1}}],[\"但略过了不少实现细节\",{\"1\":{\"879\":1}}],[\"但还有另一种方式可以引入\",{\"1\":{\"873\":1}}],[\"但至少我们知道\",{\"1\":{\"871\":1}}],[\"但幸运的是\",{\"1\":{\"871\":1}}],[\"但模型输出的是\",{\"1\":{\"853\":1}}],[\"但神经网络输出的是无约束的实数\",{\"1\":{\"853\":1}}],[\"但神经网络的自适应基函数和分层结构使其\",{\"1\":{\"385\":1}}],[\"但神经网络的非线性基函数组合比传统多项式逼近更灵活\",{\"1\":{\"385\":1}}],[\"但神经网络的通用近似性质也被证明对于其他类型的激活函数\",{\"1\":{\"385\":1}}],[\"但参数未知\",{\"1\":{\"825\":1}}],[\"但留出空间继续生成图像后续内容\",{\"1\":{\"817\":1}}],[\"但问题来了\",{\"1\":{\"867\":1}}],[\"但问题就在于属于某个文本token位置处的预测结果向量中\",{\"1\":{\"814\":1}}],[\"但问题是\",{\"1\":{\"175\":1}}],[\"但包含\",{\"1\":{\"810\":1}}],[\"但包含大量噪声文本\",{\"1\":{\"122\":1}}],[\"但我们还需要将误差反向传播到一个从\",{\"1\":{\"868\":1}}],[\"但我们选择为每个\",{\"1\":{\"809\":1}}],[\"但我们发现以下几点对稳定训练尤其重要\",{\"1\":{\"808\":1}}],[\"但我们则使用\",{\"1\":{\"808\":1}}],[\"但我们更关注的是其通用能力\",{\"1\":{\"706\":1}}],[\"但生成图像中仍常见严重问题\",{\"1\":{\"806\":1}}],[\"但保持语义一致\",{\"1\":{\"802\":1}}],[\"但保留作为接口兼容\",{\"1\":{\"473\":1}}],[\"但保留它们作为接口兼容\",{\"1\":{\"471\":1}}],[\"但保留接口以备后续扩展\",{\"1\":{\"467\":1}}],[\"但同时又希望这个采样过程能反向传播梯度\",{\"1\":{\"796\":1}}],[\"但同一物体的不同实例可能有几何差异\",{\"1\":{\"29\":1}}],[\"但梯度仍由软样本近似\",{\"1\":{\"795\":1}}],[\"但有效性有限\",{\"1\":{\"786\":1}}],[\"但有短板\",{\"1\":{\"529\":1}}],[\"但视觉\",{\"1\":{\"766\":1}}],[\"但视觉和视觉\",{\"1\":{\"189\":1}}],[\"但视觉和文本的token未对齐\",{\"1\":{\"149\":1}}],[\"但却是高维高斯的真实现象\",{\"1\":{\"756\":1}}],[\"但事实恰恰相反\",{\"1\":{\"756\":1}}],[\"但体积增加更快\",{\"1\":{\"754\":1}}],[\"但一般通过调用\",{\"1\":{\"716\":1}}],[\"但一般人还是玩不起\",{\"1\":{\"286\":1}}],[\"但面对未见过的输入时仍可能出现幻觉\",{\"1\":{\"711\":1}}],[\"但单一模型可能难以全面适应所有场景\",{\"1\":{\"709\":1}}],[\"但大型语言模型的出现再次让聊天机器人这种交互模式可以重新涌现\",{\"1\":{\"708\":1}}],[\"但大多数方法仅在低层像素上操作\",{\"1\":{\"165\":1}}],[\"但尚未到达\",{\"1\":{\"697\":1}}],[\"但从局部看\",{\"1\":{\"697\":1}}],[\"但需直观呈现计算图全貌以辅助调试与理解\",{\"1\":{\"696\":1}}],[\"但需要付出计算速度代价\",{\"1\":{\"181\":1}}],[\"但无法表达空间结构\",{\"1\":{\"885\":1}}],[\"但无法直接穿过一个采样操作的节点反向传播梯度\",{\"1\":{\"868\":1}}],[\"但无法替代弱引用在框架设计中的针对性优化\",{\"1\":{\"687\":1}}],[\"但无法定位具体交互部位\",{\"1\":{\"51\":1}}],[\"但实验表明去除nsp后性能反而提升\",{\"1\":{\"564\":1}}],[\"但实际只用了极少数\",{\"1\":{\"800\":1}}],[\"但实际训练所需的计算资源与较小模型相当\",{\"1\":{\"528\":1}}],[\"但实际上总体阳性概率只有\",{\"1\":{\"731\":1}}],[\"但实际上这行代码的意图是计算\",{\"1\":{\"470\":1}}],[\"但实际上\",{\"1\":{\"301\":1}}],[\"但因循环引用\",{\"1\":{\"687\":1}}],[\"但因批次大小可变\",{\"1\":{\"562\":1}}],[\"但因为\",{\"1\":{\"423\":1}}],[\"但每次掩码不同\",{\"1\":{\"562\":1}}],[\"但每个输出向量的维度由\",{\"1\":{\"409\":1}}],[\"但透明性与可靠性仍需优化\",{\"1\":{\"550\":1}}],[\"但低于gpt\",{\"1\":{\"550\":1}}],[\"但书籍\",{\"1\":{\"549\":1}}],[\"但宗教类别偏差显著\",{\"1\":{\"549\":1}}],[\"但远低于minerva\",{\"1\":{\"549\":1}}],[\"但远低于人类\",{\"1\":{\"522\":1}}],[\"但小模型在长期训练后推理效率更高\",{\"1\":{\"547\":1}}],[\"但hoffmann等人\",{\"1\":{\"547\":1}}],[\"但通用性更强\",{\"1\":{\"564\":1}}],[\"但通过优化关键设计选择提升性能\",{\"1\":{\"560\":1}}],[\"但通过高效训练仍实现sota\",{\"1\":{\"547\":1}}],[\"但通过引入预训练梯度混合\",{\"1\":{\"539\":1}}],[\"但通过在\",{\"1\":{\"538\":1}}],[\"但通常不开源\",{\"1\":{\"218\":1}}],[\"但未具内置限制\",{\"1\":{\"538\":1}}],[\"但强调这种对齐是相对于特定人群\",{\"1\":{\"535\":1}}],[\"但gpt\",{\"1\":{\"531\":1}}],[\"但依赖大量任务标注数据\",{\"1\":{\"531\":1}}],[\"但依赖于大量标注数据和监督学习\",{\"1\":{\"520\":1}}],[\"但采用稀疏注意力机制\",{\"1\":{\"528\":1}}],[\"但采用图文检索和图文匹配作为训练目标\",{\"1\":{\"145\":1}}],[\"但泛化能力弱\",{\"1\":{\"528\":1}}],[\"但泛化性受限\",{\"1\":{\"49\":1}}],[\"但某些任务仍存在挑战\",{\"1\":{\"526\":1}}],[\"但数据重叠对结果影响有限\",{\"1\":{\"522\":1}}],[\"但数目固定\",{\"1\":{\"386\":1}}],[\"但对于rgb\",{\"1\":{\"846\":1}}],[\"但对于如wic\",{\"1\":{\"529\":1}}],[\"但对于对外提供服务的企业来说\",{\"1\":{\"482\":1}}],[\"但对高置信度预测\",{\"1\":{\"522\":1}}],[\"但定性分析显示生成内容类似摘要\",{\"1\":{\"522\":1}}],[\"但层数\",{\"1\":{\"522\":1}}],[\"但进行了以下优化\",{\"1\":{\"521\":1}}],[\"但结果表明\",{\"1\":{\"532\":1}}],[\"但结果表明语言模型在无监督条件下已具备初步的多任务处理能力\",{\"1\":{\"520\":1}}],[\"但结果与人类表现\",{\"1\":{\"522\":1}}],[\"但结果会更加靠谱\",{\"1\":{\"500\":1}}],[\"但并不能保证结果的正确性\",{\"1\":{\"500\":1}}],[\"但并不是所有的参数都是发挥同样作用的\",{\"1\":{\"487\":1}}],[\"但起核心作用的参数是低秩的\",{\"1\":{\"495\":1}}],[\"但也可能会把原来表现好的别的领域的能力变差\",{\"1\":{\"483\":1}}],[\"但也不能写成\",{\"1\":{\"364\":1}}],[\"但fft也会带来一些问题\",{\"1\":{\"483\":1}}],[\"但真实是正类的样本数\",{\"1\":{\"471\":1}}],[\"但真实是负类的样本数\",{\"1\":{\"471\":1}}],[\"但更易梯度下降\",{\"1\":{\"467\":1}}],[\"但考虑变量相关性\",{\"1\":{\"455\":1}}],[\"但物理内存中数据不复制\",{\"1\":{\"427\":1}}],[\"但要获得准确的估计\",{\"1\":{\"868\":1}}],[\"但要创建完整的应用程序\",{\"1\":{\"712\":1}}],[\"但要注意的是\",{\"1\":{\"426\":1}}],[\"但要想在\",{\"1\":{\"173\":1}}],[\"但此时并没有复制任何数据\",{\"1\":{\"425\":1}}],[\"但长度固定为\",{\"1\":{\"393\":1}}],[\"但缩放到总和为\",{\"1\":{\"392\":1}}],[\"但带来了\",{\"1\":{\"385\":1}}],[\"但当\",{\"1\":{\"873\":1}}],[\"但当维度\",{\"1\":{\"755\":1}}],[\"但当张量的内存布局不连续\",{\"1\":{\"362\":1}}],[\"但当前实现未使用\",{\"1\":{\"277\":1}}],[\"但如果\",{\"1\":{\"873\":1}}],[\"但如果我们在内部函数中引用了外部函数的变量\",{\"1\":{\"340\":1}}],[\"但如果训练时没有加入扰动\",{\"1\":{\"112\":1}}],[\"但默认的组合方式可能不满足所有需求\",{\"1\":{\"316\":1}}],[\"但发现这种方法的训练效率\",{\"1\":{\"305\":1}}],[\"但存在词汇表限制或效率问题\",{\"1\":{\"521\":1}}],[\"但存在两大局限\",{\"1\":{\"385\":1}}],[\"但存在一定的噪声\",{\"1\":{\"305\":1}}],[\"但存在以下局限性\",{\"1\":{\"6\":1}}],[\"但仍有限制\",{\"1\":{\"839\":1}}],[\"但仍在胡说\",{\"1\":{\"538\":1}}],[\"但仍依赖卷积架构\",{\"1\":{\"280\":1}}],[\"但仍能达到较高水平\",{\"1\":{\"185\":1}}],[\"但计算复杂且处理速度较慢\",{\"1\":{\"280\":1}}],[\"但其通用性优势使其成为最终选择\",{\"1\":{\"562\":1}}],[\"但其本质仍是一个\",{\"1\":{\"530\":1}}],[\"但其在自然语言处理\",{\"1\":{\"520\":1}}],[\"但其主要目的是训练可迁移的视觉模型\",{\"1\":{\"299\":1}}],[\"但其主要负责将输入的\",{\"1\":{\"274\":1}}],[\"但其核心思想借鉴了\",{\"1\":{\"178\":1}}],[\"但下游任务的准确率较低\",{\"1\":{\"268\":1}}],[\"但提升幅度不大\",{\"1\":{\"247\":1}}],[\"但已经可以处理基本的图文问答任务\",{\"1\":{\"234\":1}}],[\"但较gpt\",{\"1\":{\"228\":1}}],[\"但internvit仍展现出与新语言模型的优秀兼容性和可移植性\",{\"1\":{\"223\":1}}],[\"但开源模型通过高分辨率优化\",{\"1\":{\"220\":1}}],[\"但开源模型在文档\",{\"1\":{\"219\":1}}],[\"但受限于视觉模型的规模和对齐效率\",{\"1\":{\"193\":1}}],[\"但受限于预定义类别\",{\"1\":{\"7\":1}}],[\"但不知道具体哪个潜变量设置产生了它\",{\"1\":{\"865\":1}}],[\"但不允许看到未来像素\",{\"1\":{\"848\":1}}],[\"但不包括其标题\",{\"1\":{\"810\":1}}],[\"但不适合表征学习\",{\"1\":{\"785\":1}}],[\"但不会跑出系统之外\",{\"1\":{\"728\":1}}],[\"但不会被视为可训练参数\",{\"1\":{\"366\":1}}],[\"但不一定更公正\",{\"1\":{\"538\":1}}],[\"但不占用额外内存\",{\"1\":{\"364\":1}}],[\"但不监督与其索引相同的学生视图\",{\"1\":{\"186\":1}}],[\"但不同于它们使用结构明确的元任务\",{\"1\":{\"531\":1}}],[\"但不同的是\",{\"1\":{\"176\":1}}],[\"但不同点在于\",{\"1\":{\"175\":1}}],[\"但\",{\"1\":{\"186\":1,\"469\":1,\"537\":1,\"560\":1,\"766\":1}}],[\"但会推动输出趋向均匀\",{\"1\":{\"183\":1}}],[\"但会牺牲吞吐率\",{\"1\":{\"181\":1}}],[\"但会随模型一起保存\",{\"1\":{\"170\":1}}],[\"但为了与前人工作保持一致\",{\"1\":{\"179\":1}}],[\"但风险是过度集中\",{\"1\":{\"178\":1}}],[\"但容易导致均匀分布坍塌\",{\"1\":{\"178\":1}}],[\"但性能远低于微调方法\",{\"1\":{\"527\":1}}],[\"但性能下降\",{\"1\":{\"175\":1}}],[\"但性能全面超越\",{\"1\":{\"133\":1}}],[\"但与此同时\",{\"1\":{\"754\":1}}],[\"但与\",{\"1\":{\"173\":1}}],[\"但标准\",{\"1\":{\"157\":1}}],[\"但难以处理复杂语义交互\",{\"1\":{\"150\":1}}],[\"但文本\",{\"1\":{\"127\":1}}],[\"但多用于低资源语言场景\",{\"1\":{\"124\":1}}],[\"但语言任务的数据增强较困难\",{\"1\":{\"124\":1}}],[\"但普遍存在两个问题\",{\"1\":{\"120\":1}}],[\"但可以作为判断模型是否捕捉到了某个特定数据点\",{\"1\":{\"869\":1}}],[\"但可以通过对\",{\"1\":{\"869\":1}}],[\"但可能无法充分定制模型行为或写作风格\",{\"1\":{\"711\":1}}],[\"但可能会出错\",{\"1\":{\"500\":1}}],[\"但可能效果受限\",{\"1\":{\"277\":1}}],[\"但可用于特定任务\",{\"1\":{\"115\":1}}],[\"但可供性类别相同\",{\"1\":{\"20\":1}}],[\"但这部分工作尚留待未来完成\",{\"1\":{\"871\":1}}],[\"但这样也会排除相似的好样本\",{\"1\":{\"866\":1}}],[\"但这会导致图3\",{\"1\":{\"866\":1}}],[\"但这仍然限制了few\",{\"1\":{\"530\":1}}],[\"但这一方向为减少对人工标注数据的依赖提供了新思路\",{\"1\":{\"524\":1}}],[\"但这时\",{\"1\":{\"403\":1}}],[\"但这些信息不需要训练\",{\"1\":{\"366\":1}}],[\"但这些模型仍然采用固定类别的softmax分类器进行预训练\",{\"1\":{\"305\":1}}],[\"但这次切换成\",{\"1\":{\"277\":1}}],[\"但这里保留\",{\"1\":{\"276\":1}}],[\"但这两种方法对超参数较为敏感\",{\"1\":{\"179\":1}}],[\"但这种方法存在三个主要限制\",{\"1\":{\"189\":1}}],[\"但这种方法要求一次性比较大量样本\",{\"1\":{\"175\":1}}],[\"但这种方式表达能力有限\",{\"1\":{\"112\":1}}],[\"但这可能导致所选邻域的实际尺寸随点的密度变化而变化\",{\"1\":{\"90\":1}}],[\"但遇到遮挡严重或点分布不均匀时性能下降明显\",{\"1\":{\"112\":1}}],[\"但由于\",{\"1\":{\"807\":1}}],[\"但由于它是固定的\",{\"1\":{\"587\":1}}],[\"但由于它们是神经网络直接预测出来的\",{\"1\":{\"108\":1}}],[\"但由于其无序性和非规则性\",{\"1\":{\"103\":1}}],[\"但在某些模型中\",{\"1\":{\"873\":1}}],[\"但在公式\",{\"1\":{\"868\":1}}],[\"但在复杂视觉任务中\",{\"1\":{\"866\":1}}],[\"但在高维空间中\",{\"1\":{\"866\":1}}],[\"但在分布外的标题上表现更好\",{\"1\":{\"809\":1}}],[\"但在最后一个文本\",{\"1\":{\"809\":1}}],[\"但在大型模型中特别突出\",{\"1\":{\"706\":1}}],[\"但在理解复杂语言规则方面存在一定局限性\",{\"1\":{\"703\":1}}],[\"但在实际应用中\",{\"1\":{\"688\":1}}],[\"但在对内存敏感的场景下依然存在问题\",{\"1\":{\"687\":1}}],[\"但在训练中\",{\"1\":{\"587\":1}}],[\"但在强化学习微调中加入\",{\"1\":{\"536\":1}}],[\"但在\",{\"1\":{\"530\":1,\"773\":1}}],[\"但在其他任务\",{\"1\":{\"530\":1}}],[\"但在如wic\",{\"1\":{\"529\":1}}],[\"但在结构化或需要多步推理的任务中\",{\"1\":{\"529\":1}}],[\"但在摘要\",{\"1\":{\"523\":1}}],[\"但在前景远少于背景时容易偏向负样本\",{\"1\":{\"468\":1}}],[\"但在处理超大规模点云时\",{\"1\":{\"112\":1}}],[\"但在精度上仍略逊一筹\",{\"1\":{\"112\":1}}],[\"但在一些复杂区域\",{\"1\":{\"112\":1}}],[\"但在点云这种非结构化数据中\",{\"1\":{\"100\":1}}],[\"但在计算上可能非常昂贵\",{\"1\":{\"97\":1}}],[\"但在测试集中保留\",{\"1\":{\"65\":1}}],[\"但是问题是\",{\"1\":{\"728\":1}}],[\"但是越清晰\",{\"1\":{\"717\":1}}],[\"但是发展速度相当惊人\",{\"1\":{\"704\":1}}],[\"但是这里为了方便理解\",{\"1\":{\"686\":1}}],[\"但是这一改动也引发了另一个问题\",{\"1\":{\"685\":1}}],[\"但是这样造成的一个后果是计算量太庞大\",{\"1\":{\"318\":1}}],[\"但是这样做的逻辑不太清晰\",{\"1\":{\"248\":1}}],[\"但是这样做\",{\"1\":{\"248\":1}}],[\"但是和rnn相比\",{\"1\":{\"621\":1}}],[\"但是和transformer原始的encoder还是有所区别\",{\"1\":{\"321\":1}}],[\"但是也存在一些不足之处\",{\"1\":{\"588\":1}}],[\"但是反馈的来源是ai\",{\"1\":{\"483\":1}}],[\"但是它的缺点也非常明显\",{\"1\":{\"482\":1}}],[\"但是\",{\"1\":{\"366\":1,\"449\":1,\"497\":1,\"575\":2,\"727\":1,\"843\":1,\"878\":1,\"880\":1}}],[\"但是训练速度还是挺快的\",{\"1\":{\"327\":1}}],[\"但是训练速度很慢\",{\"1\":{\"286\":1}}],[\"但是当数据量逐渐增大时\",{\"1\":{\"324\":1}}],[\"但是当训练数据集不够大的时候\",{\"1\":{\"314\":1}}],[\"但是迁移到其它数据集训练时\",{\"1\":{\"323\":1}}],[\"但是实际的代码实现中\",{\"1\":{\"318\":1}}],[\"但是对于一般的小公司或者个人来说\",{\"1\":{\"491\":1}}],[\"但是对于vit这个结构而言\",{\"1\":{\"317\":1}}],[\"但是对于cv领域来讲\",{\"1\":{\"246\":1}}],[\"但是visual\",{\"1\":{\"283\":1}}],[\"但是由于ve仍然使用重的卷积网络进行特征抽取\",{\"1\":{\"282\":1}}],[\"但是由于这两张图片是从同一个图片经过某种变化得到的\",{\"1\":{\"243\":1}}],[\"但是其本质还是借助\",{\"1\":{\"273\":1}}],[\"但是表现都会比有监督要差\",{\"1\":{\"246\":1}}],[\"但是在cv领域\",{\"1\":{\"246\":1}}],[\"但是在一个场景中有多个物体时则不好办\",{\"1\":{\"86\":1}}],[\"但是我们在计算损失时指定了ignore\",{\"1\":{\"581\":1}}],[\"但是我们每次更新这个队列\",{\"1\":{\"246\":1}}],[\"但是我们用到了另外一种信息\",{\"1\":{\"242\":1}}],[\"但是我们需要知道前两张图片是一个类别\",{\"1\":{\"242\":1}}],[\"但是官方仓库的issue给出了明确答复\",{\"1\":{\"140\":1}}],[\"但是尺度不同\",{\"1\":{\"96\":1}}],[\"但它的数学基础与稀疏自编码器或去噪自编码器并不相同\",{\"1\":{\"866\":1}}],[\"但它能为后续许多针对转置数据的操作带来更好的内存局部性\",{\"1\":{\"426\":1}}],[\"但它只去掉\",{\"1\":{\"372\":1}}],[\"但它会让数据本身有\",{\"1\":{\"274\":1}}],[\"但它们也引发了伦理和风险问题\",{\"1\":{\"705\":1}}],[\"但它们展现出截然不同的能力\",{\"1\":{\"703\":1}}],[\"但它们常常偏离用户意图\",{\"1\":{\"535\":1}}],[\"但它们的\",{\"1\":{\"360\":1}}],[\"但它们的目标\",{\"1\":{\"239\":1}}],[\"但它们在非互联网图像\",{\"1\":{\"220\":1}}],[\"但它也为后续模型奠定了基础\",{\"1\":{\"112\":1}}],[\"但它是为了统一接口设计的一个占位符\",{\"1\":{\"92\":1}}],[\"但它本质上是\",{\"1\":{\"78\":1}}],[\"但完全不使用注意力机制\",{\"1\":{\"73\":1}}],[\"但测试时要求\",{\"1\":{\"65\":1}}],[\"但效率低\",{\"1\":{\"51\":1}}],[\"但搜索空间大\",{\"1\":{\"49\":1}}],[\"但动态功能特性使得mllms难以直接从交互图像推理3d功能\",{\"1\":{\"7\":1}}],[\"但机器人操作需要3d信息\",{\"1\":{\"7\":1}}],[\"2中间的一种状态\",{\"1\":{\"878\":1}}],[\"2这些数字\",{\"1\":{\"878\":1}}],[\"2^l\",{\"1\":{\"821\":3}}],[\"2^层数\",{\"1\":{\"814\":1}}],[\"2m\",{\"1\":{\"704\":1}}],[\"27\",{\"1\":{\"692\":1,\"696\":1}}],[\"2+1\",{\"1\":{\"690\":1}}],[\"2+n\",{\"1\":{\"186\":1}}],[\"2l\",{\"1\":{\"590\":1}}],[\"2和wikitext\",{\"1\":{\"577\":1}}],[\"2任务上表现略优\",{\"1\":{\"564\":1}}],[\"2论文\",{\"0\":{\"554\":1}}],[\"2tb\",{\"1\":{\"547\":1}}],[\"2tuple\",{\"1\":{\"272\":2,\"804\":2}}],[\"2分\",{\"1\":{\"529\":1}}],[\"2通过示例提示\",{\"1\":{\"522\":1}}],[\"2通过训练一个包含45百万网页链接的webtext数据集\",{\"1\":{\"519\":1}}],[\"2仅通过文档+历史对话+\",{\"1\":{\"522\":1}}],[\"2以70\",{\"1\":{\"522\":1}}],[\"2将\",{\"1\":{\"522\":1}}],[\"2使用字节级bpe\",{\"1\":{\"522\":1}}],[\"2在非分布数据\",{\"1\":{\"522\":1}}],[\"2在验证集\",{\"1\":{\"522\":1}}],[\"2在7\",{\"1\":{\"522\":1}}],[\"2在8个标准语言建模数据集上进行了测试\",{\"1\":{\"522\":1}}],[\"2在零样本设置下能完成多种任务\",{\"1\":{\"520\":1}}],[\"2在生成连贯文本方面的能力\",{\"1\":{\"519\":1}}],[\"2模型证明了大规模语言模型在无监督多任务学习中的强大潜力\",{\"1\":{\"524\":1}}],[\"2模型\",{\"1\":{\"519\":1,\"522\":1}}],[\"2取得91\",{\"1\":{\"515\":1}}],[\"2是二分类\",{\"1\":{\"515\":1}}],[\"2相比prompt\",{\"1\":{\"499\":1}}],[\"2x3\",{\"1\":{\"425\":1}}],[\"2x5\",{\"1\":{\"378\":1}}],[\"2×2\",{\"1\":{\"386\":2,\"387\":2,\"390\":1}}],[\"2×224²+10×96²\",{\"1\":{\"184\":1}}],[\"2×224²\",{\"1\":{\"184\":1}}],[\"2×1000000000\",{\"1\":{\"324\":1}}],[\"2的微调潜力\",{\"1\":{\"523\":1}}],[\"2的完全抽象式输出\",{\"1\":{\"523\":1}}],[\"2的局限性\",{\"1\":{\"523\":1}}],[\"2的困惑度\",{\"1\":{\"522\":1}}],[\"2的起因\",{\"1\":{\"307\":1}}],[\"2的强健基础进一步预训练\",{\"1\":{\"223\":1}}],[\"2f\",{\"1\":{\"302\":2,\"304\":2}}],[\"2训练时使用的webtext数据集相似\",{\"1\":{\"299\":1}}],[\"2版本中对internvit\",{\"1\":{\"223\":1}}],[\"2k\",{\"1\":{\"209\":1}}],[\"2n\",{\"1\":{\"162\":3}}],[\"2b\",{\"1\":{\"145\":4,\"147\":4,\"324\":1}}],[\"2节中使用的prompt\",{\"1\":{\"142\":1}}],[\"2>\",{\"1\":{\"83\":1}}],[\"2️⃣\",{\"0\":{\"73\":1},\"1\":{\"100\":1,\"885\":1}}],[\"235b\",{\"1\":{\"704\":1}}],[\"2301\",{\"1\":{\"306\":1}}],[\"2304\",{\"1\":{\"231\":1,\"821\":1}}],[\"2303\",{\"1\":{\"47\":1}}],[\"2312\",{\"1\":{\"187\":1}}],[\"23\",{\"1\":{\"65\":1,\"67\":1,\"83\":1,\"235\":1,\"261\":1,\"268\":1,\"423\":3,\"537\":1,\"549\":1}}],[\"22的实现\",{\"1\":{\"690\":1}}],[\"22b\",{\"1\":{\"201\":1}}],[\"22b除外\",{\"1\":{\"191\":1}}],[\"225\",{\"1\":{\"186\":1,\"252\":1,\"463\":1}}],[\"229\",{\"1\":{\"186\":1,\"252\":1,\"463\":1}}],[\"22\",{\"0\":{\"690\":1},\"1\":{\"49\":1,\"423\":1,\"593\":1,\"620\":1}}],[\"224×224\",{\"1\":{\"198\":1,\"208\":1,\"209\":1,\"327\":1}}],[\"224x224\",{\"1\":{\"186\":2,\"317\":3,\"318\":1,\"327\":1}}],[\"224\",{\"1\":{\"29\":2,\"58\":2,\"167\":2,\"186\":6,\"252\":2,\"317\":2,\"318\":2,\"327\":6,\"395\":2,\"463\":1,\"774\":2,\"804\":3}}],[\"2c\",{\"1\":{\"45\":1,\"59\":1}}],[\"200k\",{\"1\":{\"704\":5}}],[\"2003\",{\"1\":{\"703\":1}}],[\"200\",{\"1\":{\"690\":1,\"806\":1}}],[\"2000\",{\"1\":{\"514\":1,\"774\":1}}],[\"20b\",{\"1\":{\"222\":1,\"223\":1,\"227\":1}}],[\"20k\",{\"1\":{\"209\":1}}],[\"2015\",{\"1\":{\"537\":1}}],[\"2018将人类偏好学习应用于模仿学习\",{\"1\":{\"536\":1}}],[\"2018\",{\"0\":{\"590\":1},\"1\":{\"521\":2,\"522\":1,\"536\":2,\"552\":2,\"591\":1,\"593\":1,\"703\":1,\"704\":1,\"811\":1}}],[\"2016\",{\"1\":{\"385\":2,\"536\":1,\"708\":1}}],[\"2016年的工作\",{\"1\":{\"305\":1}}],[\"2010\",{\"1\":{\"327\":1}}],[\"2017年的工作\",{\"1\":{\"305\":1}}],[\"2017\",{\"1\":{\"131\":1,\"521\":1,\"536\":1,\"552\":1}}],[\"2019b\",{\"1\":{\"539\":1}}],[\"2019\",{\"1\":{\"126\":1,\"131\":1,\"536\":3,\"537\":1,\"552\":1,\"704\":2}}],[\"2014\",{\"1\":{\"49\":1}}],[\"20\",{\"1\":{\"75\":1,\"82\":3,\"131\":1,\"145\":2,\"186\":2,\"261\":1,\"389\":5,\"423\":1,\"470\":1,\"529\":1,\"579\":4,\"703\":1,\"857\":2,\"861\":1,\"872\":1}}],[\"2025\",{\"1\":{\"704\":9}}],[\"2022的协议\",{\"1\":{\"550\":1}}],[\"2022\",{\"1\":{\"547\":1,\"548\":1,\"552\":5,\"704\":2,\"712\":1}}],[\"2022年清华提出的\",{\"1\":{\"491\":1}}],[\"2020\",{\"1\":{\"126\":1,\"131\":1,\"536\":4,\"537\":1,\"552\":3}}],[\"2021年微软提出的\",{\"1\":{\"491\":1}}],[\"2021a\",{\"1\":{\"126\":1,\"127\":2}}],[\"2021\",{\"1\":{\"73\":1,\"126\":2,\"131\":2,\"297\":2,\"536\":8,\"539\":1,\"548\":1,\"704\":1,\"707\":1}}],[\"2024年\",{\"1\":{\"704\":1}}],[\"2024\",{\"1\":{\"22\":1,\"60\":1,\"703\":1,\"704\":19,\"714\":1}}],[\"2023\",{\"1\":{\"22\":1,\"704\":17}}],[\"2048\",{\"1\":{\"18\":1,\"29\":2,\"30\":1,\"35\":7,\"40\":3,\"46\":2,\"59\":4,\"67\":1,\"68\":2,\"70\":1,\"81\":2,\"83\":1}}],[\"290\",{\"1\":{\"23\":1}}],[\"29\",{\"1\":{\"22\":1,\"24\":1,\"83\":1,\"537\":1,\"538\":1,\"539\":1,\"704\":1}}],[\"2501\",{\"1\":{\"594\":2}}],[\"2504\",{\"1\":{\"37\":1}}],[\"25e\",{\"1\":{\"514\":1}}],[\"25~0\",{\"1\":{\"470\":1}}],[\"2578\",{\"1\":{\"594\":2}}],[\"257\",{\"1\":{\"313\":3,\"521\":1}}],[\"255\",{\"1\":{\"83\":2,\"317\":2,\"848\":4}}],[\"256×256\",{\"1\":{\"807\":1}}],[\"256x256\",{\"1\":{\"793\":1,\"814\":1}}],[\"256维\",{\"1\":{\"154\":1}}],[\"256\",{\"1\":{\"36\":3,\"93\":5,\"96\":6,\"100\":1,\"101\":11,\"107\":3,\"110\":3,\"111\":3,\"146\":1,\"186\":1,\"249\":2,\"317\":2,\"560\":1,\"793\":1,\"807\":1,\"809\":3,\"814\":1,\"821\":1,\"822\":2,\"840\":4,\"843\":2,\"847\":2,\"848\":9}}],[\"25\",{\"1\":{\"22\":1,\"78\":1,\"133\":1,\"134\":1,\"196\":1,\"276\":2,\"332\":1,\"398\":1,\"470\":1,\"840\":1,\"885\":1}}],[\"2d功能检测\",{\"1\":{\"51\":1}}],[\"2d演示与3d物体来自不同实例\",{\"1\":{\"49\":1}}],[\"2d\",{\"1\":{\"16\":1,\"22\":2,\"29\":1,\"40\":1,\"42\":1,\"47\":1,\"114\":2,\"318\":1,\"359\":1,\"388\":1,\"463\":2}}],[\"2d方法难以直接迁移\",{\"1\":{\"7\":1}}],[\"2693\",{\"1\":{\"866\":1}}],[\"260亿参数\",{\"1\":{\"227\":1}}],[\"26\",{\"1\":{\"15\":1,\"549\":1,\"692\":2}}],[\"28x28\",{\"1\":{\"885\":2}}],[\"287\",{\"1\":{\"208\":1}}],[\"2880\",{\"1\":{\"131\":1}}],[\"28\",{\"1\":{\"8\":1,\"848\":5,\"857\":4,\"861\":2}}],[\"2\",{\"0\":{\"9\":1,\"23\":1,\"41\":1,\"63\":1,\"290\":1,\"311\":1,\"313\":1,\"318\":1,\"408\":1,\"413\":1,\"518\":1,\"719\":1,\"785\":1,\"829\":1,\"835\":1,\"853\":1,\"859\":1},\"1\":{\"7\":1,\"8\":1,\"28\":4,\"29\":5,\"30\":2,\"32\":6,\"34\":3,\"35\":10,\"36\":8,\"40\":1,\"41\":5,\"45\":9,\"46\":4,\"58\":1,\"59\":30,\"65\":1,\"70\":17,\"73\":2,\"76\":3,\"78\":5,\"80\":1,\"82\":4,\"83\":4,\"92\":8,\"93\":1,\"96\":7,\"99\":2,\"100\":6,\"101\":2,\"105\":1,\"107\":2,\"108\":2,\"109\":6,\"111\":4,\"112\":2,\"145\":6,\"146\":1,\"147\":9,\"157\":1,\"160\":2,\"161\":2,\"162\":3,\"163\":3,\"167\":1,\"170\":5,\"173\":1,\"185\":1,\"186\":18,\"193\":1,\"198\":3,\"199\":2,\"202\":2,\"204\":1,\"208\":1,\"212\":1,\"223\":3,\"227\":1,\"228\":1,\"229\":1,\"252\":5,\"254\":1,\"255\":1,\"257\":1,\"266\":1,\"272\":15,\"273\":1,\"275\":1,\"276\":2,\"277\":5,\"286\":1,\"289\":2,\"291\":1,\"293\":3,\"295\":3,\"299\":1,\"300\":1,\"307\":1,\"308\":2,\"310\":2,\"311\":5,\"312\":5,\"313\":2,\"316\":2,\"318\":3,\"320\":1,\"322\":4,\"333\":5,\"336\":1,\"354\":2,\"355\":2,\"360\":1,\"361\":3,\"363\":9,\"364\":10,\"369\":16,\"370\":2,\"372\":15,\"373\":3,\"374\":4,\"375\":1,\"376\":1,\"377\":3,\"378\":1,\"385\":2,\"387\":5,\"399\":10,\"401\":12,\"421\":2,\"422\":2,\"423\":13,\"425\":11,\"426\":10,\"427\":3,\"428\":1,\"445\":1,\"446\":1,\"451\":1,\"463\":7,\"467\":1,\"468\":2,\"470\":4,\"473\":1,\"476\":8,\"477\":9,\"494\":1,\"512\":2,\"514\":1,\"515\":2,\"516\":1,\"518\":1,\"521\":8,\"522\":5,\"527\":2,\"528\":12,\"529\":3,\"530\":1,\"531\":3,\"536\":1,\"537\":5,\"538\":1,\"541\":1,\"544\":10,\"548\":3,\"549\":5,\"550\":1,\"551\":1,\"554\":2,\"559\":3,\"560\":1,\"561\":2,\"562\":1,\"564\":1,\"565\":2,\"566\":3,\"571\":1,\"577\":10,\"578\":1,\"579\":2,\"580\":6,\"581\":1,\"584\":1,\"587\":3,\"590\":28,\"591\":41,\"597\":1,\"599\":1,\"602\":1,\"603\":1,\"605\":4,\"609\":1,\"611\":1,\"612\":2,\"614\":2,\"615\":3,\"627\":1,\"630\":1,\"632\":5,\"638\":2,\"643\":1,\"652\":1,\"661\":1,\"675\":1,\"685\":1,\"688\":2,\"689\":11,\"690\":7,\"692\":18,\"696\":12,\"697\":18,\"703\":3,\"704\":19,\"728\":4,\"752\":2,\"756\":1,\"758\":1,\"759\":1,\"762\":2,\"766\":1,\"773\":2,\"787\":1,\"801\":1,\"803\":1,\"804\":2,\"807\":1,\"808\":1,\"809\":1,\"810\":1,\"811\":1,\"814\":3,\"821\":5,\"822\":4,\"839\":2,\"840\":4,\"848\":22,\"854\":2,\"857\":2,\"861\":1,\"866\":1,\"885\":6,\"886\":5}}],[\"21843\",{\"1\":{\"327\":1}}],[\"21000\",{\"1\":{\"327\":1}}],[\"21k\",{\"1\":{\"327\":3,\"395\":1}}],[\"215\",{\"1\":{\"65\":1}}],[\"213\",{\"1\":{\"17\":1}}],[\"21\",{\"1\":{\"7\":1,\"423\":1,\"549\":1,\"872\":1}}],[\"244\",{\"1\":{\"318\":1}}],[\"242\",{\"1\":{\"234\":1}}],[\"2400\",{\"1\":{\"131\":1}}],[\"24\",{\"1\":{\"29\":1,\"34\":3,\"423\":6,\"522\":1}}],[\"24类\",{\"1\":{\"17\":1}}],[\"24类功能\",{\"1\":{\"6\":1}}],[\"2411\",{\"1\":{\"4\":1}}],[\"3~4\",{\"1\":{\"591\":1}}],[\"31\",{\"1\":{\"704\":1}}],[\"3167\",{\"1\":{\"582\":1}}],[\"31gb\",{\"1\":{\"561\":1}}],[\"3提升至87\",{\"1\":{\"565\":1}}],[\"3但可靠性仍不足\",{\"1\":{\"551\":1}}],[\"36\",{\"1\":{\"549\":1,\"692\":1,\"696\":1}}],[\"3640\",{\"1\":{\"539\":1}}],[\"364×364\",{\"1\":{\"211\":1}}],[\"3小10倍却性能更优\",{\"1\":{\"547\":1}}],[\"3更受人类偏好\",{\"1\":{\"535\":1}}],[\"3更像是一个巨大的\",{\"1\":{\"530\":1}}],[\"3模型\",{\"1\":{\"535\":1}}],[\"3模型架构基本沿用gpt\",{\"1\":{\"528\":1}}],[\"3进行监督学习微调\",{\"1\":{\"534\":1}}],[\"3站在了词向量\",{\"1\":{\"531\":1}}],[\"3是首次系统性\",{\"1\":{\"531\":1}}],[\"3并未对每个任务建立单独的模型\",{\"1\":{\"531\":1}}],[\"3验证了一个关键假设\",{\"1\":{\"531\":1}}],[\"3以175b参数扩展至前代模型的10倍以上\",{\"1\":{\"531\":1}}],[\"3完全通过文本学习并表达任务结构\",{\"1\":{\"531\":1}}],[\"3完全不依赖梯度更新\",{\"1\":{\"530\":1}}],[\"3通过扩展模型容量\",{\"1\":{\"531\":1}}],[\"3之前\",{\"1\":{\"531\":1}}],[\"3继承了这一发展路线\",{\"1\":{\"531\":1}}],[\"3及其衍生模型时\",{\"1\":{\"530\":1}}],[\"3虽然能完成基础算术和简单逻辑题\",{\"1\":{\"530\":1}}],[\"3虽然模型更大\",{\"1\":{\"528\":1}}],[\"3对提示\",{\"1\":{\"530\":1}}],[\"3对复杂语义结构的掌握仍有提升空间\",{\"1\":{\"529\":1}}],[\"3展示了推理能力的不足\",{\"1\":{\"529\":1}}],[\"3展现出更强的语言建模优势\",{\"1\":{\"529\":1}}],[\"3表现较差\",{\"1\":{\"529\":1}}],[\"3也表现出明显的few\",{\"1\":{\"529\":1}}],[\"3比较不同答案的语言模型概率\",{\"1\":{\"528\":1}}],[\"3主要研究后三种方法\",{\"1\":{\"528\":1}}],[\"3在设计的算术\",{\"1\":{\"529\":1}}],[\"3在识别细粒度语义差异上仍有明显不足\",{\"1\":{\"529\":1}}],[\"3在少样本\",{\"1\":{\"529\":1}}],[\"3在few\",{\"1\":{\"529\":1,\"530\":1}}],[\"3在winograd\",{\"1\":{\"529\":1}}],[\"3在英法\",{\"1\":{\"529\":1}}],[\"3在triviaqa\",{\"1\":{\"529\":1}}],[\"3在传统语言建模任务\",{\"1\":{\"529\":1}}],[\"3在语言建模和完形填空任务中的表现\",{\"1\":{\"529\":1}}],[\"3在多个任务上取得了令人印象深刻的成绩\",{\"1\":{\"530\":1}}],[\"3在多个任务上展现出超越以往fine\",{\"1\":{\"528\":1}}],[\"3在多数nlp任务中\",{\"1\":{\"529\":1}}],[\"3在多种自然语言处理任务中表现出色\",{\"1\":{\"526\":1}}],[\"3在通用语言系统发展中的潜力及其可能带来的广泛社会影响\",{\"1\":{\"526\":1}}],[\"3等更大规模模型的开发奠定了基础\",{\"1\":{\"523\":1}}],[\"3的175b参数\",{\"1\":{\"547\":1}}],[\"3的核心创新之一\",{\"1\":{\"531\":1}}],[\"3的推理过程完全由大量参数和非线性变换组成\",{\"1\":{\"530\":1}}],[\"3的表现明显弱于专门微调过的模型\",{\"1\":{\"530\":1}}],[\"3的上下文窗口扩大到2048\",{\"1\":{\"530\":1}}],[\"3的few\",{\"1\":{\"529\":1,\"530\":1}}],[\"3的研究方法基于\",{\"1\":{\"528\":1}}],[\"3的训练数据主要来自以下五个来源\",{\"1\":{\"528\":1}}],[\"3的少样本学习\",{\"1\":{\"522\":1}}],[\"3的准确率\",{\"1\":{\"515\":1}}],[\"3的维度\",{\"1\":{\"322\":1}}],[\"3×4\",{\"1\":{\"425\":1}}],[\"3×3\",{\"1\":{\"105\":1,\"107\":1,\"108\":1}}],[\"3x4\",{\"1\":{\"425\":1}}],[\"3x3\",{\"1\":{\"107\":2,\"845\":2}}],[\"3层即可\",{\"1\":{\"385\":1}}],[\"330\",{\"1\":{\"810\":1}}],[\"33\",{\"1\":{\"549\":1}}],[\"333\",{\"1\":{\"354\":1}}],[\"336\",{\"1\":{\"299\":1}}],[\"396\",{\"1\":{\"302\":1}}],[\"3508\",{\"1\":{\"582\":1}}],[\"35\",{\"1\":{\"261\":1,\"529\":1,\"882\":1}}],[\"3m\",{\"1\":{\"234\":1}}],[\"3v\",{\"1\":{\"218\":1}}],[\"3天内达到了\",{\"1\":{\"184\":1}}],[\"3g\",{\"1\":{\"184\":1}}],[\"3n\",{\"1\":{\"162\":1}}],[\"3b参数的instructgpt模型\",{\"1\":{\"535\":1}}],[\"3b对比175b\",{\"1\":{\"534\":1}}],[\"3b\",{\"1\":{\"145\":3,\"147\":2,\"536\":1,\"537\":1,\"538\":1,\"539\":1}}],[\"30b\",{\"1\":{\"704\":1}}],[\"3072\",{\"1\":{\"514\":1,\"599\":2,\"774\":1}}],[\"300m\",{\"1\":{\"810\":1}}],[\"300m数据集\",{\"1\":{\"324\":1}}],[\"300m数据集的规模达到了上亿级别\",{\"1\":{\"305\":1}}],[\"300m数据集取得了较好的结果\",{\"1\":{\"305\":1}}],[\"300m数据集是谷歌从互联网上收集的\",{\"1\":{\"305\":1}}],[\"300m数据集来预训练模型在imagenet上取得sota\",{\"1\":{\"305\":1}}],[\"300m数据集还要多出1亿对\",{\"1\":{\"299\":1}}],[\"300\",{\"1\":{\"234\":1,\"780\":1}}],[\"30\",{\"1\":{\"145\":2,\"179\":1,\"389\":5,\"692\":1,\"696\":1,\"697\":1,\"728\":2}}],[\"3节中的条件生成任务\",{\"1\":{\"142\":1}}],[\"3+d\",{\"1\":{\"92\":3}}],[\"3️⃣\",{\"0\":{\"74\":1},\"1\":{\"100\":1,\"885\":1}}],[\"345m\",{\"1\":{\"521\":1,\"522\":1}}],[\"34b更换为internlm2\",{\"1\":{\"223\":1}}],[\"34b结合\",{\"1\":{\"223\":1}}],[\"34\",{\"1\":{\"23\":1,\"537\":1,\"538\":1,\"539\":1}}],[\"38gb\",{\"1\":{\"561\":1}}],[\"384\",{\"1\":{\"142\":1,\"146\":1,\"234\":1,\"809\":1}}],[\"38\",{\"1\":{\"17\":1,\"24\":1}}],[\"32×32\",{\"1\":{\"807\":4,\"808\":1,\"809\":1}}],[\"32gb\",{\"1\":{\"774\":1}}],[\"32b\",{\"1\":{\"704\":6,\"718\":1}}],[\"32k\",{\"1\":{\"704\":2}}],[\"32个示例\",{\"1\":{\"529\":1}}],[\"32768\",{\"1\":{\"299\":1}}],[\"328\",{\"1\":{\"224\":1}}],[\"32的预训练权重进行初始化\",{\"1\":{\"199\":1}}],[\"320\",{\"1\":{\"35\":1,\"59\":1,\"96\":1}}],[\"32\",{\"1\":{\"17\":1,\"96\":4,\"99\":2,\"101\":2,\"167\":1,\"225\":1,\"299\":1,\"387\":1,\"495\":1,\"514\":1,\"591\":1,\"692\":1,\"696\":1,\"762\":1,\"817\":1,\"822\":1}}],[\"37b\",{\"1\":{\"704\":1}}],[\"37\",{\"1\":{\"15\":1,\"261\":1,\"549\":1,\"780\":1}}],[\"3\",{\"0\":{\"9\":1,\"14\":2,\"15\":1,\"24\":1,\"42\":1,\"64\":1,\"291\":1,\"312\":1,\"319\":1,\"409\":1,\"414\":1,\"525\":1,\"786\":1,\"830\":1,\"836\":1,\"854\":1},\"1\":{\"7\":2,\"8\":4,\"26\":1,\"28\":4,\"29\":3,\"30\":4,\"34\":6,\"35\":7,\"36\":1,\"40\":3,\"46\":2,\"58\":2,\"59\":12,\"68\":2,\"70\":9,\"75\":1,\"76\":8,\"78\":1,\"80\":1,\"82\":5,\"83\":12,\"92\":14,\"93\":5,\"96\":6,\"98\":2,\"99\":2,\"100\":16,\"101\":1,\"105\":2,\"107\":9,\"109\":1,\"110\":1,\"142\":1,\"145\":2,\"147\":2,\"161\":1,\"163\":2,\"173\":2,\"186\":3,\"192\":1,\"198\":2,\"199\":1,\"201\":1,\"203\":1,\"204\":2,\"208\":1,\"211\":1,\"224\":1,\"228\":1,\"232\":4,\"234\":1,\"250\":2,\"252\":1,\"254\":1,\"255\":1,\"267\":1,\"272\":8,\"273\":1,\"276\":2,\"277\":2,\"289\":1,\"293\":1,\"295\":1,\"300\":1,\"301\":1,\"304\":1,\"305\":1,\"311\":10,\"312\":2,\"313\":1,\"316\":1,\"318\":3,\"322\":7,\"333\":5,\"336\":2,\"344\":1,\"354\":2,\"355\":3,\"361\":1,\"363\":8,\"364\":16,\"369\":7,\"370\":1,\"372\":13,\"373\":4,\"374\":3,\"375\":1,\"376\":2,\"377\":3,\"378\":1,\"385\":3,\"387\":5,\"395\":1,\"398\":2,\"399\":2,\"401\":1,\"421\":5,\"422\":2,\"423\":12,\"425\":4,\"426\":11,\"427\":8,\"428\":2,\"452\":1,\"463\":2,\"470\":1,\"471\":2,\"476\":7,\"477\":1,\"492\":2,\"514\":1,\"521\":2,\"522\":12,\"525\":1,\"526\":1,\"527\":5,\"528\":1,\"529\":14,\"530\":2,\"531\":1,\"532\":1,\"534\":1,\"535\":1,\"536\":5,\"537\":2,\"538\":17,\"539\":2,\"541\":1,\"544\":6,\"546\":1,\"548\":2,\"549\":6,\"550\":1,\"551\":1,\"559\":1,\"561\":4,\"564\":4,\"580\":2,\"590\":19,\"591\":22,\"597\":1,\"605\":2,\"630\":1,\"632\":1,\"675\":1,\"684\":1,\"689\":8,\"690\":10,\"692\":3,\"696\":4,\"697\":2,\"703\":5,\"704\":24,\"706\":1,\"714\":1,\"728\":1,\"762\":1,\"772\":2,\"774\":1,\"793\":5,\"801\":2,\"803\":1,\"808\":1,\"810\":1,\"817\":1,\"821\":5,\"822\":1,\"846\":2,\"848\":9,\"854\":1,\"856\":1,\"860\":1,\"885\":3,\"886\":3}}],[\"3d`\",{\"1\":{\"82\":1}}],[\"3d对象功能区域分割\",{\"1\":{\"60\":1}}],[\"3d对象功能定位\",{\"1\":{\"6\":1}}],[\"3d功能热图\",{\"1\":{\"54\":1}}],[\"3d功能定位\",{\"1\":{\"51\":1}}],[\"3d数据学习功能\",{\"1\":{\"51\":1}}],[\"3daffordance\",{\"1\":{\"30\":2,\"35\":4,\"59\":8,\"70\":6,\"76\":12}}],[\"3d点云样本\",{\"1\":{\"29\":1}}],[\"3dir\",{\"1\":{\"17\":1}}],[\"3d实例\",{\"1\":{\"6\":1}}],[\"3d\",{\"0\":{\"46\":1,\"84\":1},\"1\":{\"2\":1,\"4\":1,\"7\":1,\"8\":2,\"15\":2,\"16\":2,\"17\":1,\"22\":2,\"25\":1,\"26\":4,\"29\":1,\"37\":1,\"40\":2,\"42\":1,\"46\":2,\"47\":1,\"48\":1,\"60\":3,\"62\":2,\"63\":1,\"67\":1,\"69\":3,\"70\":4,\"81\":2,\"82\":6,\"107\":1,\"109\":1,\"112\":1,\"114\":4,\"359\":1,\"388\":1}}],[\"图解transformer\",{\"0\":{\"619\":1},\"1\":{\"619\":1}}],[\"图解bert\",{\"1\":{\"592\":1}}],[\"图解\",{\"0\":{\"592\":1}}],[\"图7\",{\"1\":{\"494\":1}}],[\"图6\",{\"1\":{\"492\":1}}],[\"图示\",{\"1\":{\"387\":1}}],[\"图生文\",{\"1\":{\"312\":1}}],[\"图中有什么\",{\"1\":{\"234\":1}}],[\"图中展示的是\",{\"1\":{\"159\":1}}],[\"图表解析\",{\"1\":{\"228\":1}}],[\"图表和场景文本理解方面仍显著落后于商业模型\",{\"1\":{\"219\":1}}],[\"图5\",{\"1\":{\"225\":1,\"492\":1}}],[\"图块数量为1至12个\",{\"1\":{\"223\":1}}],[\"图\",{\"1\":{\"147\":1,\"198\":1,\"266\":1,\"267\":1,\"450\":1,\"451\":1,\"452\":1,\"453\":2,\"536\":1,\"537\":2,\"752\":1,\"756\":1,\"766\":1,\"772\":1,\"811\":2}}],[\"图文联合生成图像\",{\"0\":{\"817\":1}}],[\"图文到文本\",{\"1\":{\"313\":1}}],[\"图文生成等多模态任务\",{\"1\":{\"294\":1}}],[\"图文融合\",{\"1\":{\"163\":1,\"260\":1}}],[\"图文共享表示的嵌入维度\",{\"1\":{\"147\":1}}],[\"图文对比\",{\"1\":{\"310\":1}}],[\"图文对比损失\",{\"1\":{\"161\":1}}],[\"图文对比损失定义为交叉熵\",{\"1\":{\"154\":1}}],[\"图文对比目标\",{\"1\":{\"145\":1}}],[\"图文对比学习后的共同嵌入维度\",{\"1\":{\"160\":1}}],[\"图文对比学习旨在融合之前学习更好的单模态表示\",{\"1\":{\"154\":1}}],[\"图文对比学习\",{\"1\":{\"120\":1,\"260\":2,\"265\":1}}],[\"图文数据的自举式清洗机制\",{\"0\":{\"128\":1}}],[\"图文检索\",{\"1\":{\"120\":1,\"206\":1,\"294\":1}}],[\"图文匹配任务\",{\"1\":{\"145\":1}}],[\"图文匹配目标\",{\"1\":{\"145\":1}}],[\"图文匹配\",{\"1\":{\"120\":1,\"147\":2,\"260\":1,\"265\":1}}],[\"图卷积\",{\"1\":{\"112\":1}}],[\"图4显示\",{\"1\":{\"522\":1}}],[\"图4c\",{\"1\":{\"196\":1,\"197\":1}}],[\"图4b\",{\"1\":{\"196\":2}}],[\"图4a\",{\"1\":{\"196\":1,\"197\":1}}],[\"图4\",{\"1\":{\"49\":1,\"132\":1,\"196\":1,\"197\":1,\"490\":1}}],[\"图2显示模型性能与训练token量强相关\",{\"1\":{\"549\":1}}],[\"图2\",{\"1\":{\"49\":2,\"490\":1,\"522\":1}}],[\"图片切割\",{\"0\":{\"318\":1}}],[\"图片预处理\",{\"0\":{\"317\":1}}],[\"图片库中的图片\",{\"1\":{\"303\":1}}],[\"图片分类\",{\"1\":{\"302\":1,\"304\":1}}],[\"图片分类实战\",{\"1\":{\"302\":1}}],[\"图片取至\",{\"1\":{\"273\":1}}],[\"图片x1经过数据增强t2得到图片x12\",{\"1\":{\"246\":1}}],[\"图片\",{\"1\":{\"29\":1,\"58\":1}}],[\"图片索引文件路径\",{\"1\":{\"29\":1}}],[\"图像像素级别\",{\"1\":{\"885\":1}}],[\"图像去模糊等\",{\"1\":{\"883\":1}}],[\"图像修复\",{\"1\":{\"883\":1}}],[\"图像压缩成离散向量时主要借助了嵌入空间\",{\"1\":{\"883\":1}}],[\"图像压缩成一个\",{\"1\":{\"807\":1}}],[\"图像整体建模为像素独立\",{\"1\":{\"854\":1}}],[\"图像已生成并保存为\",{\"1\":{\"848\":1}}],[\"图像嵌入维度\",{\"1\":{\"822\":1}}],[\"图像尺寸检查\",{\"1\":{\"821\":1}}],[\"图像标准化\",{\"1\":{\"821\":1}}],[\"图像标准化参数\",{\"1\":{\"821\":1}}],[\"图像通道数\",{\"1\":{\"821\":1,\"822\":1}}],[\"图像通过视觉编码器\",{\"1\":{\"312\":1}}],[\"图像联合建模\",{\"1\":{\"820\":1}}],[\"图像补全\",{\"1\":{\"817\":1}}],[\"图像引导生成\",{\"1\":{\"817\":1}}],[\"图像引导的文本解码器\",{\"1\":{\"126\":1}}],[\"图像引导的文本编码器\",{\"1\":{\"126\":1}}],[\"图像先验\",{\"1\":{\"816\":1}}],[\"图像损失在总损失中的相对重要性系数\",{\"1\":{\"815\":1}}],[\"图像损失在最终\",{\"1\":{\"814\":1}}],[\"图像损失权重self\",{\"1\":{\"815\":1}}],[\"图像损失通常占更大比例\",{\"1\":{\"815\":1}}],[\"图像位置编码\",{\"1\":{\"815\":1}}],[\"图像使用二维\",{\"1\":{\"814\":1}}],[\"图像输入经过\",{\"1\":{\"814\":1}}],[\"图像经过\",{\"1\":{\"814\":1}}],[\"图像生成\",{\"1\":{\"813\":1}}],[\"图像匹配的训练方法\",{\"1\":{\"811\":1}}],[\"图像起始\",{\"1\":{\"809\":1}}],[\"图像到图像部分则使用行\",{\"1\":{\"809\":1}}],[\"图像到文本的桥梁\",{\"1\":{\"328\":1}}],[\"图像到文本的相似度权重\",{\"1\":{\"162\":1}}],[\"图像则用\",{\"1\":{\"809\":1}}],[\"图像转换为\",{\"1\":{\"802\":1}}],[\"图像转为\",{\"1\":{\"802\":1}}],[\"图像增强是对比学习或自监督学习的基础\",{\"1\":{\"802\":1}}],[\"图像视觉\",{\"1\":{\"790\":1}}],[\"图像做可视化\",{\"1\":{\"781\":1}}],[\"图像空间的含义\",{\"0\":{\"756\":1}}],[\"图像三种模态的深度理解能力\",{\"1\":{\"704\":1}}],[\"图像中\",{\"1\":{\"822\":1}}],[\"图像中各个类别的像素数量通常不均衡\",{\"1\":{\"465\":1}}],[\"图像中也可能存在未被文本描述的实体\",{\"1\":{\"157\":1}}],[\"图像直观理解\",{\"1\":{\"455\":1}}],[\"图像块没有现成的词汇表\",{\"1\":{\"766\":1}}],[\"图像块\",{\"1\":{\"765\":1,\"766\":1}}],[\"图像块嵌入层\",{\"1\":{\"319\":1}}],[\"图像块的尺寸\",{\"1\":{\"319\":1}}],[\"图像块聚合策略\",{\"1\":{\"165\":1}}],[\"图像或\",{\"1\":{\"317\":2}}],[\"图像预处理\",{\"1\":{\"463\":1}}],[\"图像预处理的转换操作\",{\"1\":{\"316\":1}}],[\"图像预训练\",{\"1\":{\"268\":3}}],[\"图像预训练分辨率为\",{\"1\":{\"131\":1}}],[\"图像注意力掩码\",{\"1\":{\"313\":1}}],[\"图像对是从互联网收集的\",{\"1\":{\"305\":1}}],[\"图像对为负样本\",{\"1\":{\"299\":1}}],[\"图像对的相似度\",{\"1\":{\"299\":1}}],[\"图像对的训练batch\",{\"1\":{\"299\":1}}],[\"图像对的预训练方法\",{\"1\":{\"298\":1}}],[\"图像对\",{\"1\":{\"298\":1,\"810\":1}}],[\"图像掩码\",{\"1\":{\"289\":1}}],[\"图像推理\",{\"1\":{\"277\":1}}],[\"图像模态特征\",{\"1\":{\"289\":1}}],[\"图像模态的\",{\"1\":{\"272\":1}}],[\"图像模式\",{\"1\":{\"277\":1}}],[\"图像类型\",{\"1\":{\"276\":1}}],[\"图像的交叉熵损失乘以\",{\"1\":{\"809\":1}}],[\"图像的分布\",{\"1\":{\"807\":1}}],[\"图像的索引\",{\"1\":{\"316\":1}}],[\"图像的更重\",{\"1\":{\"282\":1}}],[\"图像的特征\",{\"1\":{\"276\":1}}],[\"图像的序列特征\",{\"1\":{\"276\":1}}],[\"图像的\",{\"1\":{\"276\":2}}],[\"图像的文字描述\",{\"1\":{\"234\":1}}],[\"图像张量\",{\"1\":{\"276\":1}}],[\"图像为空\",{\"1\":{\"277\":1}}],[\"图像为\",{\"1\":{\"272\":1}}],[\"图像语料\",{\"1\":{\"269\":1}}],[\"图像表示\",{\"0\":{\"768\":1},\"1\":{\"263\":1}}],[\"图像表示部分\",{\"1\":{\"167\":1}}],[\"图像调整至目标分辨率\",{\"1\":{\"224\":1}}],[\"图像字幕\",{\"1\":{\"203\":1}}],[\"图像→文本检索任务中达到\",{\"1\":{\"202\":1}}],[\"图像监督学习往往把丰富的视觉信息压缩为一个类别标签\",{\"1\":{\"173\":1}}],[\"图像被划分为\",{\"1\":{\"167\":1}}],[\"图像部分的平均交叉熵损失\",{\"1\":{\"815\":1}}],[\"图像部分的\",{\"1\":{\"163\":1,\"815\":1}}],[\"图像部分主要来源于\",{\"1\":{\"17\":1}}],[\"图像全局语义\",{\"1\":{\"161\":1}}],[\"图像动量编码器\",{\"1\":{\"147\":1}}],[\"图像编码阶段\",{\"1\":{\"313\":1}}],[\"图像编码\",{\"1\":{\"147\":1,\"260\":1,\"277\":1,\"807\":1,\"822\":1}}],[\"图像编码器采用了\",{\"1\":{\"302\":1}}],[\"图像编码器采用了预训练的\",{\"1\":{\"152\":1}}],[\"图像编码器和图文融合编码器\",{\"1\":{\"260\":1}}],[\"图像编码器初始\",{\"1\":{\"208\":1}}],[\"图像编码器输出\",{\"1\":{\"163\":1}}],[\"图像编码器基于在\",{\"1\":{\"131\":1}}],[\"图像编码器\",{\"1\":{\"40\":1,\"152\":1,\"199\":1,\"208\":1,\"822\":1}}],[\"图像与文本特征提取\",{\"1\":{\"147\":1}}],[\"图像与点云之间不需要一一对应\",{\"1\":{\"19\":1}}],[\"图像队列\",{\"1\":{\"147\":1}}],[\"图像和声音\",{\"1\":{\"705\":1}}],[\"图像和音频领域取得显著成果\",{\"1\":{\"806\":1}}],[\"图像和音频\",{\"1\":{\"218\":1}}],[\"图像和文本的联合概率\",{\"1\":{\"807\":1}}],[\"图像和文本特征可预计算\",{\"1\":{\"261\":1}}],[\"图像和文本特征空间不一致\",{\"1\":{\"149\":1}}],[\"图像和文本分别编码\",{\"1\":{\"126\":1,\"260\":1,\"261\":1}}],[\"图像和点云\",{\"1\":{\"59\":1}}],[\"图像任务中数据增强广泛应用\",{\"1\":{\"124\":1}}],[\"图像描述生成的引导提示词\",{\"1\":{\"142\":1}}],[\"图像描述\",{\"1\":{\"120\":1,\"206\":1,\"225\":1,\"234\":2}}],[\"图像条件语言建模\",{\"1\":{\"120\":1}}],[\"图像条件解码器三种模式\",{\"1\":{\"120\":1}}],[\"图像条件编码器\",{\"1\":{\"120\":1}}],[\"图像处理或其他数据集中用于抽样的算法\",{\"1\":{\"89\":1}}],[\"图像分块尺寸\",{\"1\":{\"802\":1}}],[\"图像分割为\",{\"1\":{\"227\":1}}],[\"图像分割等任务\",{\"1\":{\"82\":1}}],[\"图像分辨率\",{\"1\":{\"216\":1}}],[\"图像分类\",{\"0\":{\"776\":1},\"1\":{\"201\":1,\"385\":1}}],[\"图像分支依赖目标检测器\",{\"1\":{\"307\":1}}],[\"图像分支\",{\"1\":{\"54\":1,\"307\":1}}],[\"图像网格特征\",{\"1\":{\"59\":1}}],[\"图像交互信息与点云特征做融合\",{\"1\":{\"35\":1}}],[\"图像样本\",{\"1\":{\"29\":1}}],[\"图像所属的物体名\",{\"1\":{\"28\":1}}],[\"图像\",{\"0\":{\"769\":1,\"771\":1},\"1\":{\"22\":1,\"114\":1,\"145\":1,\"162\":1,\"163\":1,\"188\":1,\"198\":4,\"208\":1,\"235\":1,\"263\":1,\"276\":1,\"277\":6,\"309\":1,\"318\":1,\"768\":1,\"769\":2,\"770\":1,\"786\":1,\"789\":1,\"802\":4,\"803\":1,\"807\":4,\"809\":1,\"814\":3,\"815\":1,\"817\":2,\"821\":1,\"822\":6,\"846\":1,\"878\":1}}],[\"图像融合两阶段3d检测框架\",{\"1\":{\"22\":1}}],[\"图像按可供性类别进行分类\",{\"1\":{\"18\":1}}],[\"图像数据\",{\"1\":{\"809\":1,\"810\":1}}],[\"图像数\",{\"1\":{\"17\":1}}],[\"图像特征和掩码\",{\"1\":{\"313\":1}}],[\"图像特征提取和模态融合都很重\",{\"1\":{\"307\":1}}],[\"图像特征提取和投影\",{\"1\":{\"145\":1}}],[\"图像特征提取与分类\",{\"1\":{\"300\":1}}],[\"图像特征输入部分\",{\"1\":{\"284\":1}}],[\"图像特征序列\",{\"1\":{\"277\":1}}],[\"图像特征作为cross\",{\"1\":{\"313\":1}}],[\"图像特征作为\",{\"1\":{\"162\":1,\"294\":1}}],[\"图像特征与所有文本特征做内积\",{\"1\":{\"161\":1}}],[\"图像特征队列\",{\"1\":{\"160\":1}}],[\"图像特征\",{\"1\":{\"14\":1,\"160\":1,\"277\":2}}],[\"图3c\",{\"1\":{\"866\":1}}],[\"图3b\",{\"1\":{\"866\":1}}],[\"图3\",{\"1\":{\"6\":1,\"17\":1,\"19\":1,\"197\":1,\"490\":1,\"866\":6}}],[\"图1中显示的不同模型在人类偏好评估中的胜率清晰反映了该方法的有效性\",{\"1\":{\"535\":1}}],[\"图1\",{\"1\":{\"6\":2,\"283\":1,\"490\":1}}],[\"×\",{\"1\":{\"63\":1,\"76\":3,\"167\":3,\"186\":1,\"386\":1,\"390\":2,\"470\":2,\"473\":4,\"731\":1,\"754\":1,\"774\":2,\"807\":1,\"814\":1,\"817\":1,\"821\":1,\"846\":3}}],[\"×5\",{\"1\":{\"6\":1}}],[\"×3\",{\"1\":{\"6\":1}}],[\"对右侧进行对数展开\",{\"1\":{\"867\":1}}],[\"对抗\",{\"1\":{\"840\":1}}],[\"对抗性脆弱\",{\"1\":{\"539\":1}}],[\"对编码器和解码器残差块的输出激活乘以一个较小的常数\",{\"1\":{\"808\":1}}],[\"对单个样本\",{\"1\":{\"832\":1}}],[\"对单个像素偏差较大的情况更加宽容\",{\"1\":{\"797\":1}}],[\"对单个点的分类精度不够敏感\",{\"1\":{\"468\":1}}],[\"对异常值特别敏感的问题\",{\"1\":{\"797\":1}}],[\"对异常点鲁棒性差\",{\"1\":{\"112\":1}}],[\"对异常点也有一定容忍能力\",{\"1\":{\"105\":1}}],[\"对加噪声后的\",{\"1\":{\"795\":1}}],[\"对加一个与相对位置有关的标量偏置\",{\"1\":{\"591\":1}}],[\"对某个\",{\"1\":{\"781\":1}}],[\"对p\",{\"1\":{\"762\":1}}],[\"对各种可能世界状态\",{\"1\":{\"759\":1}}],[\"对任意\",{\"1\":{\"839\":1}}],[\"对任意事件\",{\"1\":{\"729\":1}}],[\"对任意行\",{\"1\":{\"427\":1}}],[\"对三面骰子设\",{\"1\":{\"727\":1}}],[\"对大模型能力具有极大影响\",{\"1\":{\"717\":1}}],[\"对大模型进行微调\",{\"1\":{\"483\":1}}],[\"对大模型进行训练\",{\"1\":{\"483\":1}}],[\"对流式处理进行了深度优化\",{\"1\":{\"714\":1}}],[\"对检索到的信息进行处理和增强\",{\"1\":{\"710\":1}}],[\"对检索任务效果好\",{\"1\":{\"261\":1}}],[\"对原始图像进行统一的图像增强\",{\"1\":{\"802\":1}}],[\"对原始数据进行清洗和处理\",{\"1\":{\"710\":1}}],[\"对原始点云做刚性变换\",{\"1\":{\"108\":1}}],[\"对语言有了更深刻的理解\",{\"1\":{\"703\":1}}],[\"对语言指令进行分词\",{\"1\":{\"40\":1}}],[\"对长距离做对数映射\",{\"1\":{\"591\":1}}],[\"对长距离用对数分桶\",{\"1\":{\"591\":1}}],[\"对长距离粗略处理\",{\"1\":{\"591\":1}}],[\"对短距离用线性分桶\",{\"1\":{\"591\":1}}],[\"对短距离敏感\",{\"1\":{\"591\":1}}],[\"对的偏置\",{\"1\":{\"591\":1}}],[\"对序列\",{\"1\":{\"591\":1}}],[\"对别人\",{\"1\":{\"590\":1}}],[\"对它们做向量点积\",{\"1\":{\"590\":1}}],[\"对外提供的编码和解码两个方法实现如下\",{\"1\":{\"578\":1}}],[\"对列表数据进行解析\",{\"1\":{\"578\":1}}],[\"对下游任务\",{\"1\":{\"560\":1}}],[\"对非二元代词\",{\"1\":{\"551\":1}}],[\"对非平滑函数的适应性\",{\"1\":{\"385\":1}}],[\"对荒谬命令未进行识别\",{\"1\":{\"538\":1}}],[\"对指令遵循度高\",{\"1\":{\"538\":1}}],[\"对最终模型进行评估\",{\"1\":{\"537\":1}}],[\"对最后一维做\",{\"1\":{\"272\":1}}],[\"对模型输出进行偏好排序\",{\"1\":{\"537\":1}}],[\"对模型已经分类正确的样本\",{\"1\":{\"470\":1}}],[\"对训练数据进行了\",{\"1\":{\"537\":1}}],[\"对性能影响有限\",{\"1\":{\"559\":1}}],[\"对性能影响\",{\"1\":{\"522\":1}}],[\"对同一个大模型的微调\",{\"1\":{\"483\":1}}],[\"对当前词的子词进行合并\",{\"1\":{\"477\":1}}],[\"对当前句子中每个词进行子词合并加词id映射\",{\"1\":{\"477\":1}}],[\"对经过预处理的vocab中的每个词按空格进行切分\",{\"1\":{\"476\":1}}],[\"对经过注意力层的输出进行归一化处理\",{\"1\":{\"321\":1}}],[\"对损失求均值\",{\"1\":{\"473\":1}}],[\"对假阴性\",{\"1\":{\"473\":1}}],[\"对假阳性\",{\"1\":{\"473\":1}}],[\"对类别不平衡问题鲁棒\",{\"1\":{\"473\":1}}],[\"对类别不平衡不敏感\",{\"1\":{\"467\":1,\"469\":1}}],[\"对噪声标签敏感\",{\"1\":{\"470\":1}}],[\"对噪声点敏感\",{\"1\":{\"112\":2}}],[\"对分类错误的样本\",{\"1\":{\"470\":1}}],[\"对细节更敏感\",{\"1\":{\"468\":1}}],[\"对前景响应弱\",{\"1\":{\"468\":1}}],[\"对其他\",{\"1\":{\"463\":1}}],[\"对其进行加工\",{\"1\":{\"342\":1}}],[\"对不同方向的偏差做缩放和正交旋转\",{\"1\":{\"459\":1}}],[\"对不同阈值计算\",{\"1\":{\"82\":1}}],[\"对两个张量\",{\"1\":{\"427\":1}}],[\"对两个特征进行线性投射\",{\"1\":{\"299\":1}}],[\"对一个张量\",{\"1\":{\"425\":1}}],[\"对热力图\",{\"1\":{\"390\":1}}],[\"对双线性或双三次插值是否对齐角点\",{\"1\":{\"388\":1}}],[\"对采样点的值进行聚合\",{\"1\":{\"387\":1}}],[\"对高维和非平滑函数更鲁棒\",{\"1\":{\"385\":1}}],[\"对张量沿指定维度做\",{\"1\":{\"373\":1}}],[\"对二维数组沿不同轴拼接\",{\"1\":{\"333\":1}}],[\"对特征进行更深入的建模\",{\"1\":{\"326\":1}}],[\"对特征空间进行变换\",{\"1\":{\"109\":1}}],[\"对特征空间做变换\",{\"1\":{\"105\":1,\"108\":1}}],[\"对投影后的结果应用丢弃层\",{\"1\":{\"322\":1}}],[\"对输出做归一化\",{\"1\":{\"815\":1}}],[\"对输出有了更加明确具体的要求\",{\"1\":{\"499\":1}}],[\"对输出应用\",{\"1\":{\"471\":1}}],[\"对输出图像中的每个像素\",{\"1\":{\"390\":1}}],[\"对输出像素使用周围四个输入像素的加权平均\",{\"1\":{\"390\":1}}],[\"对输出进行维度交换和形状调整\",{\"1\":{\"322\":1}}],[\"对输入图像的数据分布非常敏感\",{\"1\":{\"802\":1}}],[\"对输入图像做通用增强\",{\"1\":{\"802\":1}}],[\"对输入图像进行预处理\",{\"1\":{\"463\":1}}],[\"对输入的每个\",{\"1\":{\"802\":1}}],[\"对输入的文本进行断句加分词\",{\"1\":{\"477\":1}}],[\"对输入的点云做刚性变换\",{\"1\":{\"107\":1}}],[\"对输入数据进行初步的特征提取\",{\"1\":{\"326\":1}}],[\"对输入进行归一化处理\",{\"1\":{\"321\":1}}],[\"对输入进行非线性变换\",{\"1\":{\"295\":1}}],[\"对输入点云做刚性变换\",{\"1\":{\"105\":1}}],[\"对输入点云中的每个点进行分类\",{\"1\":{\"101\":1}}],[\"对输入点进行采样\",{\"1\":{\"87\":1}}],[\"对输入特征进行非线性映射\",{\"1\":{\"59\":1}}],[\"对注意力权重矩阵应用丢弃层\",{\"1\":{\"322\":1}}],[\"对注意力权重做\",{\"1\":{\"272\":1}}],[\"对注意力分数矩阵应用softmax函数\",{\"1\":{\"322\":1}}],[\"对处理后的张量进行归一化操作\",{\"1\":{\"318\":1}}],[\"对验证集的处理方式是先resize成256x256的图片\",{\"1\":{\"317\":1}}],[\"对数空间中操作更稳定\",{\"1\":{\"853\":1}}],[\"对数底的选择\",{\"1\":{\"828\":1}}],[\"对数似然展开为\",{\"1\":{\"826\":1}}],[\"对数拉普拉斯分布\",{\"1\":{\"808\":1}}],[\"对数据的处理和操作要求极低\",{\"1\":{\"711\":1}}],[\"对数据集和验证集划分之后\",{\"1\":{\"317\":1}}],[\"对数映射\",{\"1\":{\"591\":1}}],[\"对数映射可以把大范围的距离压缩到少量桶\",{\"1\":{\"591\":1}}],[\"对数分母\",{\"1\":{\"591\":1}}],[\"对数分桶\",{\"1\":{\"591\":1}}],[\"对数值变化敏感\",{\"1\":{\"115\":1}}],[\"对整张图像进行处理\",{\"1\":{\"280\":1}}],[\"对整个词表进行分类训练\",{\"1\":{\"265\":1}}],[\"对负样本依赖大\",{\"1\":{\"277\":1}}],[\"对称地反映了两人距离\",{\"1\":{\"837\":1}}],[\"对称改进版\",{\"1\":{\"834\":1}}],[\"对称处理\",{\"1\":{\"801\":1}}],[\"对称结构\",{\"1\":{\"793\":1}}],[\"对称的\",{\"1\":{\"455\":1}}],[\"对称的对比学习损失\",{\"1\":{\"299\":1}}],[\"对称\",{\"1\":{\"277\":1}}],[\"对称函数\",{\"0\":{\"115\":1},\"1\":{\"115\":2}}],[\"对深层\",{\"1\":{\"272\":1}}],[\"对上式取对数\",{\"1\":{\"854\":1}}],[\"对上一层输出\",{\"1\":{\"264\":1}}],[\"对上述得到的每个区域进行编码\",{\"1\":{\"87\":1}}],[\"对复杂视觉\",{\"1\":{\"260\":1}}],[\"对这个图片做随机裁剪\",{\"1\":{\"243\":1}}],[\"对微调模型\",{\"1\":{\"239\":1}}],[\"对话即平台\",{\"1\":{\"708\":1}}],[\"对话模型\",{\"1\":{\"704\":1,\"713\":1}}],[\"对话模式\",{\"1\":{\"196\":1}}],[\"对话系统中的候选回复选择\",{\"1\":{\"618\":1}}],[\"对话\",{\"1\":{\"537\":1}}],[\"对话型问答为多轮对话\",{\"1\":{\"235\":1}}],[\"对话型\",{\"1\":{\"235\":1}}],[\"对教师输出进行温度锐化\",{\"1\":{\"186\":1}}],[\"对参数进行分组\",{\"1\":{\"186\":1}}],[\"对参数选择依赖性高\",{\"1\":{\"90\":1}}],[\"对未使用的码本向量保持原值\",{\"1\":{\"170\":1}}],[\"对码本进行初始化\",{\"1\":{\"169\":1}}],[\"对被\",{\"1\":{\"163\":1}}],[\"对角协方差矩阵\",{\"1\":{\"752\":1}}],[\"对角线\",{\"1\":{\"455\":1}}],[\"对角线上的元素\",{\"1\":{\"455\":1}}],[\"对角线元素的labels\",{\"1\":{\"299\":1}}],[\"对角线为正例\",{\"1\":{\"147\":1}}],[\"对角为1\",{\"1\":{\"161\":1}}],[\"对角为正样本\",{\"1\":{\"161\":1}}],[\"对主编码器做\",{\"1\":{\"161\":1}}],[\"对文本进行编码\",{\"1\":{\"161\":1}}],[\"对多个大规模噪声网页图文数据集\",{\"1\":{\"140\":1}}],[\"对少量异常点有一定鲁棒性\",{\"1\":{\"112\":1}}],[\"对稀疏点云敏感\",{\"1\":{\"112\":1}}],[\"对局部形状变化敏感\",{\"1\":{\"112\":1}}],[\"对局部点云组做最大池化或平均池化\",{\"1\":{\"98\":1}}],[\"对局部点云进行变换\",{\"1\":{\"98\":1}}],[\"对几何变换的不变性\",{\"1\":{\"104\":1,\"105\":1}}],[\"对所有历史\",{\"1\":{\"544\":1}}],[\"对所有图文对进行联合编码\",{\"1\":{\"261\":1}}],[\"对所有损失求平均\",{\"1\":{\"186\":1}}],[\"对所有\",{\"1\":{\"82\":1,\"871\":1}}],[\"对所有点\",{\"1\":{\"73\":1}}],[\"对边界敏感\",{\"1\":{\"82\":1}}],[\"对边界模糊区域友好\",{\"1\":{\"82\":1}}],[\"对边界模糊区域不敏感\",{\"1\":{\"82\":1}}],[\"对affordance\",{\"1\":{\"76\":1}}],[\"对无效\",{\"1\":{\"76\":1}}],[\"对象可被立即回收\",{\"1\":{\"687\":1}}],[\"对象方法工厂\",{\"1\":{\"352\":1}}],[\"对象方法装饰器\",{\"1\":{\"352\":1}}],[\"对象功能区域分割\",{\"1\":{\"70\":1}}],[\"对象的交互区域\",{\"1\":{\"28\":1}}],[\"对每一个选项\",{\"1\":{\"618\":1}}],[\"对每一行做\",{\"1\":{\"408\":1}}],[\"对每种组合手工编写\",{\"1\":{\"63\":1}}],[\"对每个类别的\",{\"1\":{\"795\":1}}],[\"对每个选项分别进行编码\",{\"1\":{\"618\":1}}],[\"对每个句对构建用于mlm任务的样本\",{\"1\":{\"579\":1}}],[\"对每个句对构建用于nsp任务的样本\",{\"1\":{\"579\":1}}],[\"对每个句子随机选择15\",{\"1\":{\"562\":1}}],[\"对每个句子进行分词\",{\"1\":{\"477\":1}}],[\"对每个句子独立进行编码\",{\"1\":{\"31\":1}}],[\"对每个词进行子词合并\",{\"1\":{\"477\":2}}],[\"对每个维度根据尺度差异进行惩罚调整\",{\"1\":{\"459\":1}}],[\"对每个小块区域做\",{\"1\":{\"386\":1}}],[\"对每个簇\",{\"1\":{\"170\":1}}],[\"对每个样本计算它与所有簇中心的距离\",{\"1\":{\"170\":1}}],[\"对每个样本单独处理\",{\"1\":{\"43\":1}}],[\"对每个原始点\",{\"1\":{\"100\":1}}],[\"对每个尺度的局部点集应用对应的\",{\"1\":{\"96\":1}}],[\"对每个半径\",{\"1\":{\"96\":1}}],[\"对每个局部区域内所有点的最大响应值进行池化\",{\"1\":{\"92\":1}}],[\"对每个查询点的邻近点按索引排序\",{\"1\":{\"92\":1}}],[\"对每个点单独计算分类误差\",{\"1\":{\"468\":1}}],[\"对每个点独立处理\",{\"1\":{\"112\":1}}],[\"对每个点进行特征提取\",{\"1\":{\"109\":1}}],[\"对每个点取预测值和真实值中的较小者\",{\"1\":{\"82\":1}}],[\"对每个点的3个权重求和\",{\"1\":{\"100\":1}}],[\"对每个点的特征做一个简单的分类器\",{\"1\":{\"98\":1}}],[\"对每个点的响应值\",{\"1\":{\"76\":1}}],[\"对每个点的关注程度\",{\"1\":{\"76\":1}}],[\"对每个点的关注响应\",{\"1\":{\"76\":1}}],[\"对每个\",{\"1\":{\"73\":1,\"367\":1,\"386\":1,\"387\":1,\"591\":1,\"616\":1,\"704\":1,\"880\":1}}],[\"对交互主体框位置进行精细调整\",{\"1\":{\"59\":1}}],[\"对交互文本和几何结构文本进行编码这块\",{\"1\":{\"31\":1}}],[\"对交互文本和几何结构文本进行编码\",{\"1\":{\"30\":1}}],[\"对图像每个\",{\"1\":{\"798\":1}}],[\"对图像中哪些\",{\"1\":{\"463\":1}}],[\"对图像进行离散\",{\"1\":{\"796\":1}}],[\"对图像进行归一化处理\",{\"1\":{\"317\":2}}],[\"对图像进行编码\",{\"1\":{\"161\":1}}],[\"对图像和文本独立使用encoder\",{\"1\":{\"282\":1}}],[\"对图像和点云特征进行\",{\"1\":{\"41\":2}}],[\"对图像\",{\"1\":{\"262\":2}}],[\"对图片进行缩放\",{\"1\":{\"58\":1}}],[\"对齐本身可被滥用\",{\"1\":{\"539\":1}}],[\"对齐方法以处理价值多样性\",{\"1\":{\"539\":1}}],[\"对齐语言模型所需的计算成本极低\",{\"1\":{\"539\":1}}],[\"对齐程度\",{\"1\":{\"537\":1}}],[\"对齐损失\",{\"1\":{\"536\":1}}],[\"对齐问题\",{\"1\":{\"535\":1}}],[\"对齐视觉和语言内容\",{\"1\":{\"264\":1}}],[\"对齐图文特征空间\",{\"1\":{\"149\":1}}],[\"对齐\",{\"1\":{\"107\":1,\"539\":1}}],[\"对齐区域\",{\"1\":{\"49\":1}}],[\"对齐模糊性\",{\"1\":{\"49\":1}}],[\"对齐二者\",{\"1\":{\"13\":1}}],[\"对\",{\"1\":{\"46\":1,\"54\":1,\"67\":1,\"76\":1,\"82\":1,\"143\":1,\"163\":1,\"170\":1,\"186\":1,\"239\":1,\"271\":1,\"495\":1,\"521\":1,\"537\":1,\"538\":2,\"575\":1,\"591\":3,\"758\":2,\"794\":1,\"822\":1,\"826\":2,\"866\":1}}],[\"对点数维度做\",{\"1\":{\"46\":1}}],[\"对点积结果进行缩放\",{\"1\":{\"41\":1}}],[\"对点云的旋转\",{\"1\":{\"105\":1}}],[\"对点云进行下采样\",{\"1\":{\"98\":1}}],[\"对点云进行编码\",{\"1\":{\"30\":1}}],[\"对点云密度变换较为敏感\",{\"1\":{\"90\":1}}],[\"对点云数据做平移操作后\",{\"1\":{\"86\":1}}],[\"对点云数据进行转置操作\",{\"1\":{\"68\":1}}],[\"对点云数据进行归一化处理\",{\"1\":{\"68\":1}}],[\"对点云特征\",{\"1\":{\"14\":1}}],[\"对自然语言指令进行\",{\"1\":{\"40\":1}}],[\"对应到\",{\"1\":{\"854\":1}}],[\"对应相同数量的视觉\",{\"1\":{\"774\":1}}],[\"对应于头两个实验的每一种实验结果\",{\"1\":{\"761\":1}}],[\"对应于第一个实验的每一种实验结果\",{\"1\":{\"761\":1}}],[\"对应代码如下\",{\"1\":{\"593\":1}}],[\"对应每个\",{\"1\":{\"591\":1}}],[\"对应着标签\",{\"1\":{\"511\":1}}],[\"对应所有\",{\"1\":{\"407\":1}}],[\"对应位置为\",{\"1\":{\"368\":2}}],[\"对应维度为\",{\"1\":{\"319\":1}}],[\"对应分布式环境\",{\"1\":{\"277\":1}}],[\"对应\",{\"1\":{\"186\":1,\"318\":1,\"846\":3}}],[\"对应图像中的一个\",{\"1\":{\"167\":1}}],[\"对应论文图1中的视觉transformer\",{\"1\":{\"142\":1}}],[\"对应论文3\",{\"1\":{\"142\":2}}],[\"对应一个离散\",{\"1\":{\"885\":1}}],[\"对应一个形状为\",{\"1\":{\"426\":1}}],[\"对应一个\",{\"1\":{\"107\":1}}],[\"对应一组相关的点特征\",{\"1\":{\"72\":1}}],[\"对应半径下最多取多少邻近点\",{\"1\":{\"96\":1}}],[\"对应指标\",{\"1\":{\"82\":1}}],[\"对应的id为\",{\"1\":{\"594\":1}}],[\"对应的参数为\",{\"1\":{\"593\":1}}],[\"对应的相对位置编码向量\",{\"1\":{\"590\":1}}],[\"对应的向量\",{\"1\":{\"590\":2}}],[\"对应的位置编码\",{\"1\":{\"587\":1}}],[\"对应的输出概率最大\",{\"1\":{\"575\":1}}],[\"对应的内存布局为一维数组\",{\"1\":{\"425\":1}}],[\"对应的像素值分别为\",{\"1\":{\"390\":1}}],[\"对应的伪代码实现如下所示\",{\"1\":{\"299\":1}}],[\"对应的蒸馏损失定义为\",{\"1\":{\"157\":1}}],[\"对应的\",{\"1\":{\"76\":1,\"142\":1}}],[\"对应的注意力掩码\",{\"1\":{\"43\":1}}],[\"对应的几何属性\",{\"1\":{\"28\":1}}],[\"对应多少个\",{\"1\":{\"29\":1}}],[\"对比度\",{\"1\":{\"802\":1}}],[\"对比度变化\",{\"1\":{\"186\":1}}],[\"对比优势\",{\"1\":{\"801\":1}}],[\"对比不同输入格式\",{\"1\":{\"559\":1,\"560\":1}}],[\"对比静态掩码\",{\"1\":{\"559\":1}}],[\"对比原始架构\",{\"1\":{\"548\":1}}],[\"对比之前的方法\",{\"1\":{\"506\":1}}],[\"对比其他损失函数\",{\"1\":{\"473\":1}}],[\"对比维度\",{\"1\":{\"239\":1}}],[\"对比\",{\"1\":{\"205\":1,\"206\":1,\"616\":1}}],[\"对比任务\",{\"1\":{\"197\":1}}],[\"对比模式\",{\"1\":{\"196\":2}}],[\"对比空间\",{\"1\":{\"186\":1}}],[\"对比学习通过拉近相似图像\",{\"1\":{\"784\":1}}],[\"对比学习\",{\"0\":{\"784\":1}}],[\"对比学习和自蒸馏等方法已被探索\",{\"1\":{\"766\":1}}],[\"对比学习的过程就是想要在特征空间里\",{\"1\":{\"246\":1}}],[\"对比学习从2019年开始到现在一直都比较火\",{\"1\":{\"241\":1}}],[\"对比学习损失\",{\"1\":{\"147\":1}}],[\"对比学习中的队列长度\",{\"1\":{\"160\":1}}],[\"对比学习中的动量蒸馏\",{\"1\":{\"157\":1}}],[\"对比学习中的负样本缓存\",{\"1\":{\"147\":1}}],[\"对比学习中图文特征队列长度\",{\"1\":{\"147\":1}}],[\"对比学习温度参数\",{\"1\":{\"145\":1}}],[\"对比损失\",{\"1\":{\"145\":1}}],[\"对比方法\",{\"1\":{\"22\":1}}],[\"对比见表1\",{\"1\":{\"6\":1}}],[\"对于编码器的每个输出向量\",{\"1\":{\"880\":1}}],[\"对于连续型数据\",{\"1\":{\"873\":1}}],[\"对于连续型随机变量\",{\"1\":{\"750\":1}}],[\"对于大多数\",{\"1\":{\"867\":1}}],[\"对于单通道灰度图像\",{\"1\":{\"846\":1}}],[\"对于单个的物体还好\",{\"1\":{\"86\":1}}],[\"对于标签\",{\"1\":{\"832\":1}}],[\"对于参数\",{\"1\":{\"825\":1}}],[\"对于文本token\",{\"1\":{\"814\":1}}],[\"对于高斯分布\",{\"1\":{\"854\":1}}],[\"对于高分辨率图像将需要大量的内存\",{\"1\":{\"807\":1}}],[\"对于高纬向量部分而言\",{\"1\":{\"587\":1}}],[\"对于预测值\",{\"1\":{\"797\":1}}],[\"对于语义分割任务\",{\"1\":{\"777\":1}}],[\"对于第\",{\"1\":{\"774\":1}}],[\"对于下游任务\",{\"1\":{\"767\":1}}],[\"对于任意两个满足\",{\"1\":{\"732\":1}}],[\"对于任意两个事件\",{\"1\":{\"729\":1}}],[\"对于任意一列两两互不相交\",{\"1\":{\"729\":1}}],[\"对于事件\",{\"1\":{\"728\":1}}],[\"对于个体开发者或小型开发团队来说\",{\"1\":{\"717\":1}}],[\"对于个体开发者或小型开发团队而言\",{\"1\":{\"717\":1}}],[\"对于个人使用者而言\",{\"1\":{\"482\":1}}],[\"对于形状复杂的函数\",{\"1\":{\"697\":1}}],[\"对于不满足交换律的运算符\",{\"1\":{\"690\":1}}],[\"对于共享变量\",{\"1\":{\"685\":1}}],[\"对于函数\",{\"1\":{\"660\":2}}],[\"对于y=f2\",{\"1\":{\"656\":1}}],[\"对于复合函数\",{\"1\":{\"655\":1}}],[\"对于这样的多选问题\",{\"1\":{\"618\":1}}],[\"对于这些任务\",{\"1\":{\"512\":1}}],[\"对于分类任务来说\",{\"1\":{\"603\":1}}],[\"对于字典中不存在的词\",{\"1\":{\"594\":1}}],[\"对于mlm任务损失计算来说\",{\"1\":{\"581\":2}}],[\"对于所有掩码候选位置执行掩码策略\",{\"1\":{\"578\":1}}],[\"对于生成类任务\",{\"1\":{\"528\":1}}],[\"对于没有训练集的数据集\",{\"1\":{\"528\":1}}],[\"对于dprd\",{\"1\":{\"516\":1}}],[\"对于race\",{\"1\":{\"516\":1}}],[\"对于sst\",{\"1\":{\"516\":1}}],[\"对于cola\",{\"1\":{\"516\":1}}],[\"对于相似任务\",{\"1\":{\"512\":1}}],[\"对于作者的模型架构\",{\"1\":{\"507\":1}}],[\"对于将这些学习到的表征迁移到目标任务的最有效方法\",{\"1\":{\"507\":1}}],[\"对于llm越友好\",{\"1\":{\"499\":1}}],[\"对于一张图像\",{\"1\":{\"770\":1}}],[\"对于一些复杂的问题\",{\"1\":{\"497\":1}}],[\"对于一般的任务\",{\"1\":{\"494\":1}}],[\"对于一个二元变量\",{\"1\":{\"854\":1}}],[\"对于一个二维矩阵\",{\"1\":{\"426\":1}}],[\"对于一个\",{\"1\":{\"845\":1}}],[\"对于一个连续型随机变量\",{\"1\":{\"734\":1}}],[\"对于一个具有\",{\"1\":{\"733\":1}}],[\"对于一个长度为\",{\"1\":{\"588\":1}}],[\"对于一个基于正弦余弦编码的位置向量\",{\"1\":{\"587\":1}}],[\"对于一个样本\",{\"1\":{\"470\":1}}],[\"对于一个包含个文本\",{\"1\":{\"299\":1}}],[\"对于需要微调的密集层\",{\"1\":{\"490\":1}}],[\"对于二元分类器\",{\"1\":{\"451\":1}}],[\"对于二维的图像\",{\"1\":{\"318\":1}}],[\"对于类别不平衡的数据集\",{\"1\":{\"448\":1,\"474\":1}}],[\"对于模型效果\",{\"1\":{\"447\":1}}],[\"对于疾病预测等应用\",{\"1\":{\"444\":1}}],[\"对于严重不均衡的数据集\",{\"1\":{\"443\":1}}],[\"对于更高维的张量\",{\"1\":{\"426\":1}}],[\"对于上述代码中的矩阵\",{\"1\":{\"422\":2}}],[\"对于要插值的每个输出像素点\",{\"1\":{\"389\":1}}],[\"对于具有线性输出层和至少一个使用\",{\"1\":{\"385\":1}}],[\"对于q\",{\"1\":{\"309\":1}}],[\"对于自监督模型\",{\"1\":{\"305\":1}}],[\"对于有监督模型\",{\"1\":{\"305\":1}}],[\"对于vit\",{\"1\":{\"299\":1}}],[\"对于输入的图像\",{\"1\":{\"272\":1}}],[\"对于输入图片\",{\"1\":{\"179\":1}}],[\"对于输入图像\",{\"1\":{\"178\":1}}],[\"对于\",{\"1\":{\"250\":2,\"493\":1,\"843\":1,\"846\":2,\"848\":2}}],[\"对于nlp领域来说\",{\"1\":{\"246\":1}}],[\"对于imagenet这个数据集来说\",{\"1\":{\"243\":1}}],[\"对于频率大于\",{\"1\":{\"234\":1}}],[\"对于同一个指令\",{\"1\":{\"232\":1}}],[\"对于学生模型来说\",{\"1\":{\"186\":1}}],[\"对于非刚性变形\",{\"1\":{\"112\":1}}],[\"对于多选题\",{\"1\":{\"528\":1}}],[\"对于多标签\",{\"1\":{\"98\":1}}],[\"对于多分类\",{\"1\":{\"98\":1}}],[\"对于某个形心\",{\"1\":{\"90\":1}}],[\"对于每个token来说\",{\"1\":{\"814\":1}}],[\"对于每个遮挡块\",{\"1\":{\"772\":1}}],[\"对于每个位置\",{\"1\":{\"587\":1}}],[\"对于每个图像和文本\",{\"1\":{\"154\":1}}],[\"对于每个局部区域\",{\"1\":{\"96\":1}}],[\"对于每个质心点\",{\"1\":{\"95\":1}}],[\"对于每个选中的关键点\",{\"1\":{\"92\":1}}],[\"对于每个问题\",{\"1\":{\"64\":1}}],[\"对于每一个被遮挡的位置\",{\"1\":{\"772\":1}}],[\"对于每一个子业务训练优化模型\",{\"1\":{\"716\":1}}],[\"对于每一个子业务构造训练数据与验证数据\",{\"1\":{\"716\":1}}],[\"对于每一个输出位置\",{\"1\":{\"581\":2}}],[\"对于每一个\",{\"1\":{\"76\":1}}],[\"对于点云中的每一个点\",{\"1\":{\"41\":1}}],[\"对于点云实例\",{\"1\":{\"18\":1}}],[\"对于图像数据\",{\"1\":{\"843\":1}}],[\"对于图像token\",{\"1\":{\"814\":1}}],[\"对于图像分类任务\",{\"1\":{\"776\":1}}],[\"对于图像中的每一个位置\",{\"1\":{\"41\":1}}],[\"对于图像\",{\"1\":{\"18\":1}}],[\"对机器人感知与操作至关重要\",{\"1\":{\"6\":1}}],[\"和原图像\",{\"1\":{\"878\":1}}],[\"和输出\",{\"1\":{\"874\":1}}],[\"和玻尔兹曼机\",{\"1\":{\"872\":1}}],[\"和方差\",{\"1\":{\"869\":1,\"871\":1}}],[\"和随机梯度下降中常用的做法一样\",{\"1\":{\"868\":1}}],[\"和后验分布\",{\"1\":{\"867\":1,\"881\":1}}],[\"和模型参数无关\",{\"1\":{\"853\":1}}],[\"和模块化设计\",{\"1\":{\"385\":1}}],[\"和真实标签分布\",{\"1\":{\"832\":1}}],[\"和训练时保持一致\",{\"1\":{\"821\":1}}],[\"和目标\",{\"1\":{\"803\":1}}],[\"和平均绝对误差\",{\"1\":{\"797\":1}}],[\"和重建图像\",{\"1\":{\"794\":1}}],[\"和音频建模\",{\"1\":{\"787\":1}}],[\"和对比学习\",{\"1\":{\"784\":1}}],[\"和对应的图像\",{\"1\":{\"807\":1}}],[\"和对应的数据模块实例\",{\"1\":{\"274\":1}}],[\"和对应的\",{\"1\":{\"232\":1}}],[\"和离散视觉标记\",{\"1\":{\"765\":1}}],[\"和长文本推理\",{\"1\":{\"704\":1}}],[\"和长程依赖任务\",{\"1\":{\"522\":1}}],[\"和指令微调版\",{\"1\":{\"704\":1}}],[\"和在线推理阶段的\",{\"1\":{\"703\":1}}],[\"和funcs\",{\"1\":{\"696\":1}}],[\"和函数节点\",{\"1\":{\"696\":1}}],[\"和variable\",{\"1\":{\"690\":1}}],[\"和头维度\",{\"1\":{\"590\":1}}],[\"和每个维度\",{\"1\":{\"587\":1}}],[\"和每个查询点上\",{\"1\":{\"92\":1}}],[\"和一个解码器\",{\"1\":{\"878\":1}}],[\"和一个从\",{\"1\":{\"868\":1}}],[\"和一个问题\",{\"1\":{\"575\":1}}],[\"和一个可能答案集\",{\"1\":{\"512\":1}}],[\"和xlnet\",{\"1\":{\"566\":1}}],[\"和下游任务准确率\",{\"1\":{\"564\":1}}],[\"和衰减策略\",{\"1\":{\"560\":1}}],[\"和bloom\",{\"1\":{\"552\":1}}],[\"和bert\",{\"1\":{\"522\":1}}],[\"和人文任务\",{\"1\":{\"550\":1}}],[\"和palm\",{\"1\":{\"549\":1}}],[\"和mbpp\",{\"1\":{\"549\":1}}],[\"和mlp比率\",{\"1\":{\"196\":1}}],[\"和工程创新\",{\"1\":{\"548\":1}}],[\"和书籍\",{\"1\":{\"548\":1}}],[\"和质量过滤\",{\"1\":{\"548\":1}}],[\"和数学推理\",{\"1\":{\"547\":1}}],[\"和数据集\",{\"1\":{\"186\":1}}],[\"和位于词序列的索引\",{\"1\":{\"544\":1}}],[\"和聊天合计约\",{\"1\":{\"537\":1}}],[\"和少样本\",{\"1\":{\"527\":1}}],[\"和假设\",{\"1\":{\"512\":1}}],[\"和假阴性\",{\"1\":{\"471\":1}}],[\"和假正例率\",{\"1\":{\"450\":1}}],[\"和负类\",{\"1\":{\"470\":1}}],[\"和特征间的协方差\",{\"1\":{\"459\":1}}],[\"和这些曲线下的面积可以更好地直观比较模型性能\",{\"1\":{\"452\":1}}],[\"和所有真实负例\",{\"1\":{\"442\":1}}],[\"和所有预测负例\",{\"1\":{\"442\":1}}],[\"和步长\",{\"1\":{\"421\":1}}],[\"和保存\",{\"1\":{\"366\":1}}],[\"和transformer中的一样\",{\"1\":{\"321\":1}}],[\"和text都能和所有的tokens\",{\"1\":{\"311\":1}}],[\"和冻结参数的\",{\"1\":{\"313\":1}}],[\"和基于图像掩码的方法\",{\"1\":{\"305\":1}}],[\"和缩放因子\",{\"1\":{\"277\":1}}],[\"和视觉标记\",{\"1\":{\"766\":1}}],[\"和视觉\",{\"1\":{\"264\":1}}],[\"和掩码语言建模\",{\"1\":{\"262\":1}}],[\"和文本分类\",{\"1\":{\"507\":1}}],[\"和文本\",{\"1\":{\"261\":1,\"262\":1,\"266\":1,\"268\":1,\"312\":1}}],[\"和文本编码器\",{\"1\":{\"198\":1}}],[\"和我真实输出做一个损失\",{\"1\":{\"248\":1}}],[\"和当前时刻的\",{\"1\":{\"246\":1}}],[\"和当前输出的\",{\"1\":{\"163\":1}}],[\"和队列大小分离开\",{\"1\":{\"246\":1}}],[\"和语言模型\",{\"1\":{\"235\":1}}],[\"和中文理解方面表现突出\",{\"1\":{\"230\":1}}],[\"和中文相关任务中的表现\",{\"1\":{\"215\":1}}],[\"和高质量双语数据集\",{\"1\":{\"230\":1}}],[\"和类别频率成反比\",{\"1\":{\"399\":1}}],[\"和类别\",{\"1\":{\"212\":1}}],[\"和其他生成网络的对比情况\",{\"1\":{\"847\":1}}],[\"和其他参数\",{\"1\":{\"274\":1}}],[\"和其他多语言模型\",{\"1\":{\"202\":1}}],[\"和其对应的\",{\"1\":{\"8\":1}}],[\"和跨注意力层\",{\"1\":{\"199\":1}}],[\"和生成任务\",{\"1\":{\"196\":1}}],[\"和双塔模型\",{\"1\":{\"196\":1}}],[\"和80亿参数的语言中间件\",{\"1\":{\"189\":1}}],[\"和多分类任务一样\",{\"1\":{\"843\":1}}],[\"和多分辨率分组\",{\"1\":{\"94\":1}}],[\"和多视图\",{\"1\":{\"186\":1}}],[\"和若干张局部裁剪图像\",{\"1\":{\"186\":1}}],[\"和被\",{\"1\":{\"157\":1}}],[\"和图\",{\"1\":{\"529\":3}}],[\"和图像编码器\",{\"1\":{\"299\":1}}],[\"和图像\",{\"1\":{\"264\":1,\"813\":1,\"815\":1}}],[\"和图像类型嵌入\",{\"1\":{\"263\":1}}],[\"和图像分类任务\",{\"1\":{\"197\":1}}],[\"和图像特征\",{\"1\":{\"6\":1}}],[\"和图文匹配\",{\"1\":{\"153\":1}}],[\"和第\",{\"1\":{\"134\":1}}],[\"和稀疏采样的区域\",{\"1\":{\"95\":1}}],[\"和点维度的平均\",{\"1\":{\"78\":1}}],[\"和点云特征\",{\"1\":{\"15\":1}}],[\"和通道混合\",{\"1\":{\"73\":1}}],[\"和通道维度\",{\"1\":{\"45\":1}}],[\"和值\",{\"1\":{\"72\":1,\"322\":2,\"704\":2}}],[\"和物体\",{\"1\":{\"56\":1}}],[\"和联合注意力\",{\"1\":{\"56\":1}}],[\"和arm模块\",{\"1\":{\"49\":1}}],[\"和自然语言视觉推理\",{\"1\":{\"260\":1}}],[\"和自然语言理解出发\",{\"1\":{\"7\":1}}],[\"和自注意力机制融合图像与点云特征\",{\"1\":{\"40\":1}}],[\"和知识特征\",{\"1\":{\"14\":1}}],[\"和可供性意图特征\",{\"1\":{\"8\":1}}],[\"和\",{\"0\":{\"239\":1,\"417\":1,\"453\":1,\"850\":1},\"1\":{\"7\":1,\"8\":2,\"32\":1,\"40\":3,\"42\":1,\"45\":5,\"46\":1,\"54\":1,\"68\":1,\"70\":1,\"82\":3,\"88\":1,\"107\":1,\"108\":1,\"126\":3,\"128\":1,\"131\":4,\"138\":1,\"140\":2,\"142\":1,\"146\":1,\"147\":1,\"154\":2,\"157\":1,\"162\":1,\"163\":5,\"167\":1,\"170\":1,\"173\":2,\"178\":2,\"179\":1,\"183\":1,\"186\":2,\"198\":1,\"199\":2,\"202\":1,\"203\":1,\"204\":1,\"209\":1,\"211\":2,\"220\":2,\"225\":1,\"227\":1,\"236\":1,\"239\":1,\"247\":2,\"250\":1,\"263\":1,\"265\":2,\"269\":1,\"272\":4,\"273\":1,\"274\":4,\"278\":1,\"291\":1,\"295\":1,\"297\":3,\"307\":3,\"310\":3,\"312\":2,\"318\":1,\"326\":2,\"344\":1,\"360\":1,\"391\":1,\"405\":1,\"427\":1,\"450\":1,\"451\":1,\"452\":1,\"453\":3,\"455\":2,\"467\":1,\"468\":1,\"469\":1,\"470\":1,\"471\":2,\"473\":2,\"475\":1,\"476\":1,\"490\":5,\"492\":1,\"500\":1,\"529\":1,\"536\":1,\"537\":4,\"538\":4,\"544\":3,\"559\":2,\"560\":1,\"561\":1,\"573\":1,\"575\":1,\"577\":2,\"580\":2,\"584\":1,\"587\":2,\"590\":1,\"612\":1,\"614\":2,\"615\":2,\"616\":1,\"627\":1,\"682\":1,\"690\":3,\"703\":4,\"704\":11,\"711\":2,\"714\":1,\"729\":1,\"730\":2,\"732\":1,\"768\":1,\"770\":1,\"773\":1,\"780\":2,\"787\":1,\"792\":1,\"793\":1,\"802\":1,\"807\":1,\"808\":1,\"809\":1,\"815\":1,\"821\":1,\"822\":1,\"834\":1,\"836\":1,\"837\":3,\"845\":1,\"846\":5,\"847\":2,\"850\":1,\"853\":2,\"859\":2,\"867\":1,\"868\":6,\"871\":1,\"873\":2}}],[\"和38k\",{\"1\":{\"6\":1}}],[\"和同一物体的多交互意图关联\",{\"1\":{\"6\":1}}],[\"注册掩码张量为\",{\"1\":{\"848\":1}}],[\"注册为\",{\"1\":{\"170\":1}}],[\"注重解题中间步骤的正确性\",{\"1\":{\"704\":1}}],[\"注\",{\"1\":{\"434\":1,\"831\":1}}],[\"注解\",{\"1\":{\"248\":1,\"346\":1}}],[\"注释和计算开销大\",{\"1\":{\"149\":1}}],[\"注入\",{\"1\":{\"274\":1}}],[\"注入多样的合成描述\",{\"1\":{\"138\":1}}],[\"注入点云\",{\"1\":{\"6\":1}}],[\"注意有\",{\"1\":{\"817\":1}}],[\"注意到\",{\"1\":{\"807\":1}}],[\"注意事项\",{\"1\":{\"616\":1}}],[\"注意点\",{\"1\":{\"398\":1}}],[\"注意是通过一个线性层来同时计算qkv三个矩阵\",{\"1\":{\"322\":1}}],[\"注意下面的embed\",{\"1\":{\"318\":1}}],[\"注意力分数\",{\"1\":{\"591\":1}}],[\"注意力分数不仅取决于它们的内容\",{\"1\":{\"589\":1}}],[\"注意力打分是\",{\"1\":{\"591\":1}}],[\"注意力头\",{\"1\":{\"591\":1}}],[\"注意力头的偏置\",{\"1\":{\"591\":1}}],[\"注意力头的数量\",{\"1\":{\"322\":1}}],[\"注意力头数为\",{\"1\":{\"774\":1}}],[\"注意力头数\",{\"1\":{\"590\":1,\"591\":1}}],[\"注意力头数量\",{\"1\":{\"463\":1}}],[\"注意力权重\",{\"1\":{\"409\":1,\"412\":1}}],[\"注意力权重的\",{\"1\":{\"272\":3}}],[\"注意力图可视化\",{\"0\":{\"461\":1,\"462\":1},\"1\":{\"461\":1}}],[\"注意力图\",{\"1\":{\"390\":1}}],[\"注意力可视化\",{\"0\":{\"325\":1}}],[\"注意力矩阵的丢弃率\",{\"1\":{\"322\":1}}],[\"注意力汇聚\",{\"1\":{\"319\":1}}],[\"注意力加权\",{\"1\":{\"272\":1}}],[\"注意力结果的输出投影层\",{\"1\":{\"272\":1}}],[\"注意力子层\",{\"1\":{\"272\":1}}],[\"注意力掩码矩阵\",{\"1\":{\"463\":1}}],[\"注意力掩码矩阵生成逻辑如下所示\",{\"1\":{\"463\":1}}],[\"注意力掩码\",{\"1\":{\"272\":2}}],[\"注意力机制的基本流程\",{\"0\":{\"405\":1}}],[\"注意力机制的特性\",{\"1\":{\"319\":1}}],[\"注意力机制让每个点从融合特征中提取相关信息\",{\"1\":{\"74\":1}}],[\"注意力机制使得每个文本\",{\"1\":{\"72\":1}}],[\"注意力后\",{\"1\":{\"36\":1}}],[\"注意\",{\"0\":{\"495\":1},\"1\":{\"29\":1,\"64\":1,\"163\":2,\"272\":1,\"322\":1,\"358\":1,\"455\":1,\"467\":1,\"468\":1,\"473\":1,\"748\":1,\"774\":1,\"799\":1,\"821\":1,\"867\":1,\"868\":1,\"874\":1}}],[\"注水\",{\"1\":{\"6\":2}}],[\"并能重建图像\",{\"1\":{\"886\":1}}],[\"并能生成全局或局部视觉特征\",{\"1\":{\"197\":1}}],[\"并从中采样\",{\"1\":{\"874\":1}}],[\"并从多个选项中选择正确答案\",{\"1\":{\"235\":1}}],[\"并输入解码器就能生成图像\",{\"1\":{\"869\":1}}],[\"并让其尽可能逼近\",{\"1\":{\"867\":1}}],[\"并让模型基于上下文预测原始视觉标记\",{\"1\":{\"766\":1}}],[\"并让模型预测这些被遮盖的单词\",{\"1\":{\"562\":1}}],[\"并写出其对数形式\",{\"1\":{\"854\":1}}],[\"并注意两点\",{\"1\":{\"847\":1}}],[\"并展平每个\",{\"1\":{\"822\":1}}],[\"并作为单一的数据流进行自回归建模\",{\"1\":{\"809\":1}}],[\"并作为下一轮的输入tokens\",{\"1\":{\"541\":1}}],[\"并转换为\",{\"1\":{\"804\":1}}],[\"并转为布尔类型\",{\"1\":{\"803\":1}}],[\"并投影为\",{\"1\":{\"804\":1}}],[\"并投影到对比学习空间\",{\"1\":{\"277\":1}}],[\"并编码为\",{\"1\":{\"804\":1}}],[\"并编码为一系列嵌入表示\",{\"1\":{\"126\":1}}],[\"并预测相应的视觉\",{\"1\":{\"790\":1}}],[\"并预测它\",{\"1\":{\"788\":1}}],[\"并依赖于数据增强的设计\",{\"1\":{\"784\":1}}],[\"并拉远其他图像\",{\"1\":{\"784\":1}}],[\"并假设先验为均匀分布\",{\"1\":{\"773\":1}}],[\"并定义随机变量为恒等函数\",{\"1\":{\"728\":1}}],[\"并针对性分析\",{\"1\":{\"717\":1}}],[\"并针对性改进\",{\"1\":{\"717\":1}}],[\"并带有监控和日志功能\",{\"1\":{\"715\":1}}],[\"并带有跳跃连接\",{\"1\":{\"179\":1}}],[\"并以此为基础\",{\"1\":{\"709\":1}}],[\"并于\",{\"1\":{\"704\":1}}],[\"并进一步提升了代码质量和多轮对话一致性\",{\"1\":{\"704\":1}}],[\"并进行l2归一化\",{\"1\":{\"299\":1}}],[\"并进行推理\",{\"1\":{\"278\":1}}],[\"并进行相似度计算\",{\"1\":{\"269\":1}}],[\"并进行视觉对话的\",{\"1\":{\"235\":1}}],[\"并改进了工具调用和多模态能力\",{\"1\":{\"704\":1}}],[\"并改造为a\",{\"1\":{\"302\":1}}],[\"并充当通用任务求解器\",{\"1\":{\"704\":1}}],[\"并支持在jupyter\",{\"1\":{\"696\":1}}],[\"并保存为文件\",{\"1\":{\"696\":1}}],[\"并标注\",{\"1\":{\"689\":1}}],[\"并为后续的功能扩展奠定了坚实基础\",{\"1\":{\"678\":1}}],[\"并为后续阶段提供稳健的视觉表示\",{\"1\":{\"198\":1}}],[\"并重新命名为\",{\"1\":{\"593\":1}}],[\"并没有专门针对局部依赖关系进行优化\",{\"1\":{\"587\":1}}],[\"并解压到当前目录下\",{\"1\":{\"577\":1}}],[\"并调整学习率\",{\"1\":{\"562\":1,\"564\":1}}],[\"并调整维度顺序\",{\"1\":{\"272\":1}}],[\"并调整维度\",{\"1\":{\"272\":1}}],[\"并优化了训练细节\",{\"1\":{\"561\":1}}],[\"并添加\",{\"1\":{\"820\":1}}],[\"并添加特殊标记\",{\"1\":{\"560\":1}}],[\"并添加缩略图以保留全局上下文\",{\"1\":{\"216\":1}}],[\"并验证了数据规模对预训练的关键作用\",{\"1\":{\"559\":1}}],[\"并提供了定义工具的简便方法\",{\"1\":{\"714\":1}}],[\"并提升了整体的处理效率\",{\"1\":{\"709\":1}}],[\"并提出了一系列改进措施\",{\"1\":{\"558\":1}}],[\"并提取每个区域的特征\",{\"1\":{\"280\":1}}],[\"并提取更高级别的局部特征\",{\"1\":{\"101\":1}}],[\"并未直接采用这些方法\",{\"1\":{\"536\":1}}],[\"并未带来额外收益\",{\"1\":{\"173\":1}}],[\"并未带来性能提升\",{\"1\":{\"136\":1}}],[\"并指出\",{\"1\":{\"536\":1}}],[\"并指出gpt\",{\"1\":{\"519\":1}}],[\"并非\",{\"1\":{\"539\":1}}],[\"并非普遍\",{\"1\":{\"539\":1}}],[\"并非广义上的\",{\"1\":{\"535\":1}}],[\"并非通用智能\",{\"1\":{\"530\":1}}],[\"并探索更强的系统性泛化能力和稳健性\",{\"1\":{\"530\":1}}],[\"并探讨了数据污染和社会影响等问题\",{\"1\":{\"527\":1}}],[\"并按f1\",{\"1\":{\"528\":1}}],[\"并按行优先排序来实现\",{\"1\":{\"328\":1}}],[\"并系统评估其在零样本\",{\"1\":{\"527\":1}}],[\"并采用指数加权迭代平均\",{\"1\":{\"809\":1}}],[\"并采用指数加权的迭代平均\",{\"1\":{\"808\":1}}],[\"并采用\",{\"1\":{\"774\":1}}],[\"并采用更灵活的任务无关\",{\"1\":{\"527\":1}}],[\"并采用两段式训练流程\",{\"1\":{\"507\":1}}],[\"并表明在极限情况下\",{\"1\":{\"523\":1}}],[\"并给出了提示transformer类模型和长距离依赖的文本数据集最好用这种方法来训练\",{\"1\":{\"517\":1}}],[\"并独立地处理\",{\"1\":{\"512\":1}}],[\"并最终在训练结束时得到更小的重构误差\",{\"1\":{\"808\":1}}],[\"并最终引导出示例问题的正确结果\",{\"1\":{\"501\":1}}],[\"并最终输出分类结果\",{\"1\":{\"93\":1}}],[\"并评估它们在验证集或测试集上的性能\",{\"1\":{\"474\":1}}],[\"并使用\",{\"1\":{\"857\":1}}],[\"并使用了统计学里的变分推理\",{\"1\":{\"847\":1}}],[\"并使用指定的均值和方差进行归一化处理\",{\"1\":{\"802\":1}}],[\"并使用其周围的\",{\"1\":{\"390\":1}}],[\"并使其能够适配不同的语言模型\",{\"1\":{\"215\":1}}],[\"并行化操作和备选方案等高级功能\",{\"1\":{\"714\":1}}],[\"并行化要求更高\",{\"1\":{\"385\":1}}],[\"并行策略\",{\"1\":{\"548\":1}}],[\"并行优化\",{\"1\":{\"112\":1,\"548\":1}}],[\"并累加到累计正确样本数中\",{\"1\":{\"323\":1}}],[\"并获得该批次图像列表对应的图像嵌入向量列表\",{\"1\":{\"302\":1}}],[\"并计算与文本特征的余弦相似度\",{\"1\":{\"300\":1}}],[\"并放到图像所在的设备上\",{\"1\":{\"277\":1}}],[\"并映射到\",{\"1\":{\"272\":3}}],[\"并对其进行了一些修改\",{\"1\":{\"849\":1}}],[\"并对图像和文本特征进行对齐\",{\"1\":{\"263\":1}}],[\"并对潜在交互方式进行类比推理\",{\"1\":{\"26\":1}}],[\"并迁移到标注数据较少的任务上\",{\"1\":{\"245\":1}}],[\"并用该\",{\"1\":{\"868\":1}}],[\"并用温度参数控制\",{\"1\":{\"795\":1}}],[\"并用\",{\"1\":{\"616\":1}}],[\"并用它的返回值替换\",{\"1\":{\"349\":1}}],[\"并用这些数据训练一个端到端的视觉语言模型\",{\"1\":{\"232\":1}}],[\"并用其产生的软标签作为训练目标\",{\"1\":{\"127\":1}}],[\"并适配不同llms\",{\"1\":{\"220\":1}}],[\"并扩展至100万tokens的上下文窗口\",{\"1\":{\"218\":1}}],[\"并与文本token一同输入transformer处理\",{\"1\":{\"280\":1}}],[\"并与\",{\"1\":{\"272\":1}}],[\"并与一个由\",{\"1\":{\"206\":1}}],[\"并与图像特征联合用于预测\",{\"1\":{\"14\":1}}],[\"并应用\",{\"1\":{\"198\":1,\"802\":1}}],[\"并利用这些\",{\"1\":{\"867\":1}}],[\"并利用这些数据集对多模态模型进行知识蒸馏\",{\"1\":{\"26\":1}}],[\"并利用\",{\"1\":{\"758\":1}}],[\"并利用多源网络图像\",{\"1\":{\"188\":1}}],[\"并拆分为\",{\"1\":{\"186\":1}}],[\"并维护一个移动中心\",{\"1\":{\"186\":1}}],[\"并返回一个新的函数或类对象\",{\"1\":{\"342\":1}}],[\"并返回对应的\",{\"1\":{\"277\":1}}],[\"并返回\",{\"1\":{\"186\":1,\"341\":1}}],[\"并附加\",{\"1\":{\"186\":2}}],[\"并结合论文图表\",{\"1\":{\"536\":1}}],[\"并结合强化学习进一步优化模型\",{\"1\":{\"534\":1}}],[\"并结合\",{\"1\":{\"179\":1,\"704\":1}}],[\"并结合正则化损失\",{\"1\":{\"107\":1}}],[\"并不代表图像的生成质量就很优秀\",{\"1\":{\"847\":1}}],[\"并不对每个相对位置都单独存一个偏置\",{\"1\":{\"591\":1}}],[\"并不对应标签或监督\",{\"1\":{\"179\":1}}],[\"并不知道\",{\"1\":{\"572\":1}}],[\"并不能直接学会如何根据文本或其他条件信息来生成对应图像\",{\"1\":{\"869\":1}}],[\"并不能帮助我们生成新的\",{\"1\":{\"864\":1}}],[\"并不能显著提升其对用户意图的理解与遵循能力\",{\"1\":{\"534\":1}}],[\"并不能保证这些矩阵是正交矩阵\",{\"1\":{\"108\":1}}],[\"并不会限制在这个代码块内部\",{\"1\":{\"336\":1}}],[\"并不依赖于特定的语言模型\",{\"1\":{\"223\":1}}],[\"并不显式包含这些特征\",{\"1\":{\"173\":1}}],[\"并做\",{\"1\":{\"169\":1}}],[\"并将期望中的部分转换为另一个\",{\"1\":{\"867\":1}}],[\"并将标准的\",{\"1\":{\"771\":1}}],[\"并将\",{\"1\":{\"716\":1,\"808\":1}}],[\"并将结果传递给前一层变量\",{\"1\":{\"657\":1}}],[\"并将它们组合成一个批次进行处理\",{\"1\":{\"618\":1}}],[\"并将它们组织称为局部区域集\",{\"1\":{\"90\":1}}],[\"并将参数规模推至前所未有的高度\",{\"1\":{\"531\":1}}],[\"并将元素按照转置后的位置写入新内存\",{\"1\":{\"426\":1}}],[\"并将这些图像块嵌入到一个低维向量空间中\",{\"1\":{\"318\":1}}],[\"并将图片展示出来\",{\"1\":{\"303\":1}}],[\"并将其与基于最小描述长度\",{\"1\":{\"870\":1}}],[\"并将其与nous\",{\"1\":{\"223\":1}}],[\"并将其编码为\",{\"1\":{\"772\":1}}],[\"并将其绑定到\",{\"1\":{\"690\":1}}],[\"并将其标记为vit\",{\"1\":{\"299\":1}}],[\"并将维度降至\",{\"1\":{\"167\":1}}],[\"并引入高质量参考语料\",{\"1\":{\"528\":1}}],[\"并引入一个可调节的权重参数\",{\"1\":{\"473\":1}}],[\"并引入缩略图保留全局信息\",{\"1\":{\"222\":1}}],[\"并引入\",{\"1\":{\"163\":1,\"873\":1}}],[\"并且会生成一张和原向量对应图片差不多的图片\",{\"1\":{\"878\":1}}],[\"并且它确实在对整个数据集上的\",{\"1\":{\"870\":1}}],[\"并且它不是一个概率分布\",{\"1\":{\"758\":1}}],[\"并且通常会约束\",{\"1\":{\"868\":1}}],[\"并且相互独立\",{\"1\":{\"854\":1}}],[\"并且我们只拼接一部分\",{\"1\":{\"817\":1}}],[\"并且都采用了用\",{\"1\":{\"811\":1}}],[\"并且允许语言模型与其所处的环境进行互动\",{\"1\":{\"712\":1}}],[\"并且是首个开源的推理型大模型\",{\"1\":{\"704\":1}}],[\"并且具有更好的泛化能力\",{\"1\":{\"704\":1}}],[\"并且一定程度上也表达了位置的局部的相对信息\",{\"1\":{\"587\":1}}],[\"并且使用预测结果计算nsp任务损失值\",{\"1\":{\"581\":1}}],[\"并且该优势在训练标注者和\",{\"1\":{\"538\":1}}],[\"并且不会对额外的架构组件使用迁移学习\",{\"1\":{\"512\":1}}],[\"并且不需要低秩适应\",{\"1\":{\"495\":1}}],[\"并且可以避免梯度消失问题\",{\"1\":{\"382\":1}}],[\"并且默认继承原张量的数据类型\",{\"1\":{\"378\":1}}],[\"并且取得了与卷积神经网络\",{\"1\":{\"328\":1}}],[\"并且与clip模型的训练数据不完全一致\",{\"1\":{\"301\":1}}],[\"并且缓解了对大规模图文对数据的依赖\",{\"1\":{\"269\":1}}],[\"并且性能优于其他融合编码器模型\",{\"1\":{\"260\":1}}],[\"并且\",{\"1\":{\"175\":1,\"476\":1,\"492\":1,\"544\":1}}],[\"并且albef\",{\"1\":{\"149\":1}}],[\"并且在所有重载运算符函数实现中\",{\"1\":{\"690\":1}}],[\"并且在训练过程中采用了一个相对较大的批次大小\",{\"1\":{\"299\":1}}],[\"并且在\",{\"1\":{\"82\":1}}],[\"并替换开头\",{\"1\":{\"142\":1}}],[\"并剔除低质量描述\",{\"1\":{\"138\":1}}],[\"并有利于多任务学习\",{\"1\":{\"126\":1}}],[\"并有望应用于机器人操作\",{\"1\":{\"48\":1}}],[\"并在下游任务上微调所有参数\",{\"1\":{\"775\":1}}],[\"并在特定数据集上对参数进行微调\",{\"1\":{\"767\":1}}],[\"并在\",{\"1\":{\"660\":1,\"850\":1}}],[\"并在多数任务上击败palm\",{\"1\":{\"549\":1}}],[\"并在多种任务上表现良好\",{\"1\":{\"232\":1}}],[\"并在推理时通过上下文\",{\"1\":{\"527\":1}}],[\"并在7\",{\"1\":{\"524\":1}}],[\"并在最终自注意力块后增加额外层归一化\",{\"1\":{\"521\":1}}],[\"并在结尾加上特殊标记\",{\"1\":{\"476\":1}}],[\"并在被调用时依然保留这个引用\",{\"1\":{\"341\":1}}],[\"并在底层融合图像与文本\",{\"1\":{\"268\":1}}],[\"并在序列前后添加\",{\"1\":{\"263\":1}}],[\"并在序列前添加可学习的特殊\",{\"1\":{\"263\":1}}],[\"并在训练过程中更新参数\",{\"1\":{\"179\":1}}],[\"并在训练中相互蒸馏\",{\"1\":{\"176\":1}}],[\"并在其输出位置接上投影头\",{\"1\":{\"179\":1}}],[\"并在每个局部区域提取特征\",{\"1\":{\"98\":1}}],[\"并在此基础上强化自身的语义表达\",{\"1\":{\"72\":1}}],[\"并集\",{\"1\":{\"78\":1,\"82\":1}}],[\"并取得不错的成效\",{\"1\":{\"314\":1}}],[\"并取指数保证其\",{\"1\":{\"277\":1}}],[\"并取消掩码\",{\"1\":{\"208\":1}}],[\"并取\",{\"1\":{\"78\":1}}],[\"并仅保留\",{\"1\":{\"68\":1}}],[\"并生成两张不同的图像\",{\"1\":{\"802\":1}}],[\"并生成连贯的文本描述\",{\"1\":{\"198\":1}}],[\"并生成\",{\"1\":{\"40\":1,\"272\":1}}],[\"并推广至未见场景\",{\"1\":{\"26\":1}}],[\"并通过一个卷积操作将每个\",{\"1\":{\"804\":1}}],[\"并通过一个小型\",{\"1\":{\"92\":1}}],[\"并通过variable\",{\"1\":{\"690\":1}}],[\"并通过链式法则自动推导了导数\",{\"1\":{\"680\":1}}],[\"并通过模型进行前向传播\",{\"1\":{\"323\":1}}],[\"并通过线性变换映射到嵌入空间\",{\"1\":{\"319\":1}}],[\"并通过在各个模版节点预留钩子函数的方式\",{\"1\":{\"273\":1}}],[\"并通过卷积映射到指定的\",{\"1\":{\"272\":1}}],[\"并通过共享的自注意力模块实现不同模态的对齐\",{\"1\":{\"269\":1}}],[\"并通过共享自注意力实现跨模态对齐\",{\"1\":{\"260\":1}}],[\"并通过多头自注意力\",{\"1\":{\"264\":1}}],[\"并通过多尺度上采样与融合\",{\"1\":{\"46\":1}}],[\"并通过对大规模嘈杂图文数据进行\",{\"1\":{\"138\":1}}],[\"并通过局部+全局特征融合机制实现强大的点云建模能力\",{\"1\":{\"105\":1}}],[\"并通过功能揭示模块\",{\"1\":{\"48\":1}}],[\"并通过复合损失优化整个流程\",{\"1\":{\"8\":1}}],[\"并通过跨模态自适应融合模块\",{\"1\":{\"5\":1}}],[\"并联想潜在意图\",{\"1\":{\"6\":1}}],[\"dgx\",{\"1\":{\"561\":1}}],[\"dgcnn\",{\"1\":{\"112\":2,\"115\":1}}],[\"d0\",{\"1\":{\"426\":2}}],[\"dvae\",{\"0\":{\"792\":1},\"1\":{\"766\":1,\"770\":2,\"787\":2,\"789\":1,\"790\":1,\"803\":2,\"807\":10,\"808\":1,\"809\":1}}],[\"dv\",{\"1\":{\"419\":3}}],[\"dk\",{\"1\":{\"419\":2}}],[\"d2\",{\"1\":{\"350\":3,\"426\":2}}],[\"d1\",{\"1\":{\"350\":3,\"426\":2}}],[\"d1+d2\",{\"1\":{\"100\":1}}],[\"during\",{\"1\":{\"815\":1,\"840\":1}}],[\"dump\",{\"1\":{\"476\":3,\"478\":3,\"577\":2,\"578\":1,\"593\":1}}],[\"dumps\",{\"1\":{\"316\":1}}],[\"dual\",{\"1\":{\"260\":1,\"261\":1,\"262\":1,\"269\":1}}],[\"dae\",{\"1\":{\"786\":1}}],[\"da\",{\"1\":{\"593\":1}}],[\"days\",{\"1\":{\"539\":3}}],[\"dathathri\",{\"1\":{\"536\":1}}],[\"dataaugmentationforbeit\",{\"1\":{\"802\":2}}],[\"dataaugmentationdino\",{\"1\":{\"186\":3}}],[\"data方法实现\",{\"1\":{\"579\":1}}],[\"data为列表形式的情况\",{\"1\":{\"578\":1}}],[\"data文件所提供代码对原始数据格式进行解析\",{\"1\":{\"577\":1}}],[\"datacollatorforlanguagemodeling\",{\"1\":{\"274\":1}}],[\"datacollatorforwholewordmask\",{\"1\":{\"274\":1}}],[\"datamodules\",{\"1\":{\"274\":3}}],[\"datamodule\",{\"1\":{\"274\":7}}],[\"dataloader\",{\"0\":{\"596\":1},\"1\":{\"80\":3,\"186\":3,\"252\":1,\"273\":7,\"274\":21,\"316\":1,\"317\":2,\"403\":1,\"581\":4,\"596\":3,\"803\":1,\"840\":5,\"848\":2,\"852\":1,\"855\":1,\"885\":1}}],[\"dataframe\",{\"1\":{\"68\":1}}],[\"data\",{\"0\":{\"20\":1,\"124\":1},\"1\":{\"28\":1,\"68\":9,\"83\":7,\"92\":14,\"96\":4,\"142\":2,\"145\":3,\"147\":6,\"159\":3,\"169\":6,\"170\":6,\"186\":11,\"232\":2,\"252\":2,\"254\":2,\"256\":3,\"273\":1,\"274\":13,\"303\":9,\"304\":9,\"305\":2,\"316\":3,\"317\":6,\"323\":4,\"395\":1,\"403\":1,\"425\":1,\"427\":1,\"537\":1,\"578\":9,\"579\":5,\"581\":3,\"584\":1,\"593\":1,\"637\":3,\"638\":5,\"643\":1,\"647\":1,\"652\":4,\"659\":3,\"660\":1,\"661\":1,\"672\":1,\"673\":6,\"675\":1,\"681\":1,\"682\":1,\"684\":1,\"686\":8,\"688\":2,\"689\":15,\"690\":7,\"696\":1,\"697\":8,\"713\":1,\"802\":1,\"803\":5,\"840\":5,\"848\":9,\"852\":1,\"855\":1,\"856\":5,\"885\":2,\"886\":1}}],[\"datasets\",{\"1\":{\"147\":2,\"186\":1,\"252\":1,\"274\":1,\"840\":2,\"848\":2,\"852\":1,\"855\":1,\"885\":1}}],[\"dataset\",{\"1\":{\"16\":1,\"29\":1,\"58\":1,\"68\":2,\"80\":6,\"81\":2,\"83\":1,\"140\":1,\"142\":9,\"145\":9,\"147\":2,\"186\":3,\"252\":2,\"274\":51,\"316\":5,\"317\":6,\"403\":1,\"537\":1,\"577\":1,\"578\":1,\"581\":3,\"594\":1,\"596\":3,\"802\":1,\"803\":3,\"848\":2,\"855\":2,\"856\":1,\"860\":1,\"885\":2}}],[\"daily\",{\"1\":{\"522\":1}}],[\"dalle\",{\"1\":{\"792\":2}}],[\"dall\",{\"0\":{\"805\":1,\"812\":1},\"1\":{\"297\":3,\"789\":1,\"792\":1,\"794\":1,\"802\":5,\"803\":1,\"805\":2,\"812\":2,\"813\":2,\"814\":1,\"815\":4,\"816\":1,\"817\":1,\"820\":2,\"821\":3}}],[\"dandelin\",{\"1\":{\"279\":1}}],[\"dset\",{\"1\":{\"274\":4}}],[\"dms\",{\"1\":{\"274\":12}}],[\"dm\",{\"1\":{\"274\":13}}],[\"dpr\",{\"1\":{\"272\":1}}],[\"ddp\",{\"1\":{\"170\":2,\"255\":2}}],[\"dtype属性\",{\"1\":{\"689\":1}}],[\"dtype\",{\"1\":{\"170\":5,\"373\":2,\"378\":1,\"602\":1,\"689\":3,\"696\":1,\"815\":1,\"820\":1}}],[\"dtype=np\",{\"1\":{\"801\":1}}],[\"dtype=next\",{\"1\":{\"602\":1}}],[\"dtype=none\",{\"1\":{\"373\":1,\"378\":1}}],[\"dtype=bool\",{\"1\":{\"83\":1}}],[\"dtype=torch\",{\"1\":{\"28\":1,\"43\":1,\"92\":5,\"142\":1,\"143\":1,\"145\":4,\"146\":1,\"147\":4,\"160\":1,\"161\":1,\"162\":2,\"163\":1,\"254\":1,\"255\":1,\"309\":1,\"311\":4,\"312\":1,\"313\":1,\"597\":1,\"814\":1}}],[\"d为投影后的embedding维度\",{\"1\":{\"161\":1}}],[\"dr\",{\"1\":{\"521\":1,\"522\":1}}],[\"draw\",{\"1\":{\"83\":1,\"274\":26,\"806\":1}}],[\"dropping\",{\"1\":{\"605\":1}}],[\"dropped\",{\"1\":{\"293\":2,\"312\":2}}],[\"droppath\",{\"1\":{\"186\":1,\"208\":1,\"211\":1,\"272\":3,\"321\":2}}],[\"drop=0\",{\"1\":{\"272\":4,\"321\":1}}],[\"drop=attn\",{\"1\":{\"272\":2}}],[\"drop=drop\",{\"1\":{\"272\":5,\"321\":1}}],[\"drop2\",{\"1\":{\"93\":2,\"96\":2}}],[\"drop1\",{\"1\":{\"93\":2,\"96\":2,\"101\":2}}],[\"dropout=none\",{\"1\":{\"632\":1}}],[\"dropout=0\",{\"1\":{\"632\":1}}],[\"dropout=self\",{\"1\":{\"544\":1,\"632\":1}}],[\"dropout防止过拟合\",{\"1\":{\"312\":1}}],[\"dropout3\",{\"1\":{\"76\":1}}],[\"dropout2\",{\"1\":{\"76\":1}}],[\"dropout1\",{\"1\":{\"76\":1}}],[\"dropout\",{\"1\":{\"73\":4,\"76\":1,\"93\":2,\"95\":1,\"96\":2,\"98\":1,\"101\":1,\"110\":3,\"272\":16,\"292\":4,\"293\":2,\"311\":1,\"312\":1,\"320\":1,\"321\":4,\"322\":2,\"323\":1,\"514\":2,\"537\":1,\"544\":2,\"597\":4,\"599\":4,\"603\":4,\"605\":4,\"606\":4,\"617\":4,\"618\":4,\"626\":6,\"627\":2,\"630\":2,\"632\":5,\"774\":1,\"804\":1,\"814\":8,\"815\":2,\"817\":1,\"820\":1,\"821\":1,\"868\":1}}],[\"drop\",{\"1\":{\"72\":1,\"73\":5,\"74\":1,\"75\":1,\"80\":1,\"186\":3,\"252\":1,\"272\":30,\"320\":5,\"321\":16,\"322\":8,\"323\":9,\"463\":2,\"529\":1,\"537\":1,\"538\":1,\"539\":1,\"803\":1,\"804\":1}}],[\"driven\",{\"1\":{\"48\":1}}],[\"drive\",{\"1\":{\"4\":2,\"47\":2}}],[\"dynamiccache\",{\"1\":{\"544\":2}}],[\"dynamic\",{\"1\":{\"70\":1,\"76\":4,\"559\":1,\"562\":2,\"564\":1}}],[\"df\",{\"1\":{\"68\":7}}],[\"done\",{\"1\":{\"840\":3}}],[\"doing\",{\"1\":{\"603\":1}}],[\"doc\",{\"1\":{\"346\":4,\"562\":1}}],[\"docvqa\",{\"1\":{\"225\":1,\"228\":1,\"230\":1}}],[\"dog\",{\"1\":{\"312\":1,\"521\":2,\"572\":7}}],[\"does\",{\"1\":{\"303\":1,\"304\":1,\"316\":1}}],[\"doesn\",{\"1\":{\"272\":1}}],[\"dot语言基础语法\",{\"1\":{\"696\":1}}],[\"dot\",{\"1\":{\"299\":3,\"302\":1,\"304\":1,\"405\":1,\"575\":2,\"605\":1,\"632\":1,\"696\":29}}],[\"do\",{\"1\":{\"143\":1,\"252\":1,\"276\":3,\"277\":3,\"313\":1,\"593\":3,\"632\":1}}],[\"dosovitskiy\",{\"1\":{\"126\":1,\"131\":1}}],[\"download=true\",{\"1\":{\"840\":1,\"848\":1,\"855\":1,\"885\":1}}],[\"downloaded\",{\"1\":{\"302\":1,\"304\":1}}],[\"downloading\",{\"1\":{\"302\":2,\"304\":2}}],[\"download\",{\"1\":{\"302\":3,\"304\":4,\"327\":1}}],[\"down\",{\"1\":{\"40\":1,\"44\":1,\"488\":1}}],[\"door\",{\"1\":{\"29\":1,\"58\":1,\"63\":1,\"67\":1,\"68\":1}}],[\"digraph\",{\"1\":{\"696\":5}}],[\"dinan\",{\"1\":{\"539\":1}}],[\"dinoloss\",{\"1\":{\"186\":4}}],[\"dinohead\",{\"1\":{\"186\":3}}],[\"dino同样可以在小batch下训练\",{\"1\":{\"185\":1}}],[\"dino最终在两台8\",{\"1\":{\"184\":1}}],[\"dino模型时\",{\"1\":{\"184\":1}}],[\"dino通过\",{\"1\":{\"183\":1}}],[\"dino训练中可能出现两种形式的崩溃\",{\"1\":{\"183\":1}}],[\"dino采用以下机制来避免\",{\"1\":{\"178\":1}}],[\"dino不使用预测器\",{\"1\":{\"178\":1}}],[\"dino的教师网络不是固定的\",{\"1\":{\"178\":1}}],[\"dino在此基础上引入\",{\"1\":{\"178\":1}}],[\"dino\",{\"0\":{\"172\":1},\"1\":{\"167\":1,\"172\":1,\"173\":5,\"175\":2,\"176\":4,\"178\":1,\"186\":19,\"463\":2,\"784\":1,\"802\":1}}],[\"diag\",{\"1\":{\"311\":6}}],[\"diagonal\",{\"1\":{\"147\":3,\"161\":1,\"162\":2,\"278\":2,\"752\":1}}],[\"dir=\",{\"1\":{\"593\":3}}],[\"dir=save\",{\"1\":{\"302\":1,\"304\":1}}],[\"directional\",{\"1\":{\"311\":2}}],[\"directory\",{\"1\":{\"302\":5,\"303\":1,\"304\":6}}],[\"dirname\",{\"1\":{\"302\":1,\"304\":1,\"577\":2}}],[\"dir\",{\"1\":{\"274\":7,\"302\":16,\"303\":7,\"304\":23,\"463\":1,\"593\":4,\"696\":4}}],[\"diffusion\",{\"1\":{\"847\":1,\"877\":1,\"883\":1}}],[\"diff\",{\"1\":{\"652\":1,\"676\":2}}],[\"diffs\",{\"1\":{\"170\":3}}],[\"different\",{\"1\":{\"28\":1}}],[\"divergence\",{\"0\":{\"833\":1}}],[\"diversity\",{\"1\":{\"63\":1}}],[\"divisible\",{\"1\":{\"822\":1}}],[\"division\",{\"1\":{\"354\":1}}],[\"divide\",{\"1\":{\"385\":1}}],[\"div\",{\"1\":{\"41\":2,\"59\":2,\"690\":5,\"793\":3,\"794\":6,\"798\":2,\"799\":3,\"821\":9}}],[\"dim1\",{\"1\":{\"359\":1}}],[\"dim0\",{\"1\":{\"359\":1}}],[\"dim代表的是卷积核的数量\",{\"1\":{\"318\":1}}],[\"dims\",{\"1\":{\"73\":13,\"360\":1}}],[\"dimensionality\",{\"1\":{\"840\":1}}],[\"dimensional\",{\"1\":{\"314\":1}}],[\"dimension\",{\"1\":{\"45\":1,\"46\":1,\"112\":1,\"254\":2,\"272\":1,\"491\":2,\"840\":1}}],[\"dimensions\",{\"1\":{\"40\":1,\"815\":1,\"822\":1}}],[\"dim=400\",{\"1\":{\"853\":1,\"859\":1}}],[\"dim=784\",{\"1\":{\"853\":1,\"859\":1}}],[\"dim=768\",{\"1\":{\"160\":2,\"272\":2,\"318\":1,\"319\":1,\"320\":1,\"323\":1,\"327\":1,\"804\":1}}],[\"dim=dim\",{\"1\":{\"819\":2}}],[\"dim=dict\",{\"1\":{\"80\":2,\"83\":2}}],[\"dim=3\",{\"1\":{\"423\":1}}],[\"dim=none\",{\"1\":{\"372\":1}}],[\"dim=embed\",{\"1\":{\"272\":2,\"319\":1,\"320\":1,\"323\":2}}],[\"dim=20\",{\"1\":{\"853\":1,\"859\":1}}],[\"dim=256\",{\"1\":{\"145\":1,\"147\":1}}],[\"dim=2\",{\"1\":{\"100\":2,\"312\":2,\"423\":1,\"544\":1}}],[\"dim=0\",{\"1\":{\"78\":1,\"143\":1,\"145\":11,\"147\":11,\"160\":2,\"162\":9,\"186\":1,\"254\":1,\"278\":4,\"311\":7,\"313\":1,\"316\":1,\"358\":1,\"372\":1,\"373\":2,\"374\":4,\"379\":1,\"423\":1,\"581\":1,\"886\":1}}],[\"dim=\",{\"1\":{\"32\":2,\"41\":1,\"45\":2,\"59\":1,\"78\":1,\"92\":3,\"96\":1,\"100\":2,\"108\":1,\"111\":1,\"145\":4,\"146\":2,\"147\":4,\"161\":4,\"163\":3,\"186\":4,\"272\":1,\"277\":4,\"293\":1,\"300\":4,\"309\":2,\"312\":1,\"322\":1,\"463\":1,\"541\":1,\"544\":2,\"584\":1,\"590\":1,\"605\":1,\"614\":3,\"615\":1,\"624\":1,\"632\":1,\"794\":1,\"798\":1,\"817\":2,\"819\":1,\"820\":2,\"848\":1,\"886\":1}}],[\"dim=10\",{\"1\":{\"859\":1}}],[\"dim=1\",{\"1\":{\"32\":4,\"34\":1,\"35\":1,\"40\":1,\"41\":2,\"45\":1,\"46\":2,\"59\":6,\"78\":4,\"96\":1,\"101\":1,\"110\":1,\"145\":11,\"147\":10,\"161\":8,\"162\":2,\"170\":3,\"255\":3,\"272\":2,\"276\":2,\"278\":2,\"311\":5,\"312\":1,\"319\":1,\"320\":1,\"323\":2,\"367\":1,\"379\":1,\"423\":1,\"463\":2,\"541\":1,\"580\":2,\"581\":1,\"794\":1,\"795\":2,\"796\":1,\"804\":1,\"815\":2,\"821\":1,\"859\":2,\"885\":3}}],[\"dim\",{\"1\":{\"30\":1,\"34\":9,\"35\":16,\"36\":22,\"41\":14,\"42\":4,\"43\":2,\"44\":2,\"45\":42,\"46\":14,\"59\":46,\"70\":3,\"80\":2,\"83\":2,\"145\":6,\"146\":3,\"147\":6,\"160\":12,\"161\":2,\"169\":6,\"170\":18,\"186\":10,\"252\":1,\"254\":3,\"272\":45,\"318\":8,\"319\":6,\"320\":6,\"321\":7,\"322\":17,\"323\":9,\"358\":1,\"364\":1,\"372\":1,\"373\":3,\"374\":1,\"379\":2,\"544\":11,\"793\":17,\"794\":1,\"804\":7,\"814\":12,\"817\":1,\"821\":15,\"822\":21,\"840\":3,\"853\":10,\"857\":1,\"859\":16,\"885\":5}}],[\"discovery\",{\"1\":{\"816\":1}}],[\"discretized\",{\"1\":{\"843\":1}}],[\"discretevae\",{\"0\":{\"793\":1,\"794\":1,\"821\":1},\"1\":{\"792\":1,\"793\":3,\"794\":1,\"821\":5}}],[\"discrete\",{\"0\":{\"787\":1},\"1\":{\"773\":1,\"802\":2,\"803\":2}}],[\"discriminator\",{\"1\":{\"840\":14}}],[\"discrimination\",{\"0\":{\"243\":1},\"1\":{\"243\":1}}],[\"discussions\",{\"0\":{\"130\":1},\"1\":{\"129\":1}}],[\"disables\",{\"1\":{\"186\":1}}],[\"distributions\",{\"0\":{\"737\":1,\"738\":1,\"750\":1}}],[\"distribution\",{\"0\":{\"739\":1,\"740\":1,\"748\":1,\"749\":1},\"1\":{\"316\":1,\"735\":1,\"737\":2,\"738\":2,\"741\":1,\"744\":1,\"746\":2,\"747\":1,\"748\":1,\"749\":3,\"752\":1,\"758\":3,\"795\":1}}],[\"distributedsampler\",{\"1\":{\"274\":3,\"596\":1}}],[\"distributed\",{\"1\":{\"170\":3,\"274\":1}}],[\"dist=false\",{\"1\":{\"274\":1}}],[\"distill\",{\"1\":{\"163\":4,\"704\":1}}],[\"distillation\",{\"0\":{\"123\":1,\"157\":1},\"1\":{\"148\":2,\"149\":1,\"150\":2,\"173\":1,\"175\":1,\"176\":1,\"178\":2}}],[\"dists\",{\"1\":{\"100\":6,\"170\":3}}],[\"dist\",{\"1\":{\"92\":3,\"100\":3,\"274\":4,\"278\":5,\"885\":2}}],[\"distance=128\",{\"1\":{\"591\":1}}],[\"distance\",{\"0\":{\"457\":1,\"458\":1},\"1\":{\"92\":7,\"100\":1,\"591\":6,\"752\":1}}],[\"dishwasher\",{\"1\":{\"29\":1,\"58\":1,\"68\":1}}],[\"displayed\",{\"1\":{\"696\":1}}],[\"display\",{\"1\":{\"29\":2,\"58\":2,\"68\":2,\"696\":2}}],[\"dict=return\",{\"1\":{\"163\":1,\"312\":1}}],[\"dict=none\",{\"1\":{\"163\":1,\"312\":1}}],[\"dict=true\",{\"1\":{\"142\":1,\"145\":4,\"147\":5,\"161\":2,\"309\":2,\"311\":1,\"312\":3}}],[\"dict=false\",{\"1\":{\"40\":1}}],[\"dicts\",{\"1\":{\"80\":2,\"274\":2}}],[\"dictionary\",{\"1\":{\"30\":1,\"33\":1,\"254\":1,\"478\":16}}],[\"dict\",{\"1\":{\"29\":7,\"58\":6,\"80\":2,\"81\":1,\"82\":2,\"83\":5,\"146\":2,\"162\":2,\"163\":6,\"186\":4,\"252\":1,\"274\":1,\"275\":1,\"312\":1,\"316\":2,\"327\":3,\"337\":2,\"366\":3,\"399\":2,\"476\":13,\"478\":23,\"578\":8,\"581\":2,\"885\":2,\"886\":2}}],[\"dicebceloss\",{\"1\":{\"468\":2}}],[\"diceloss\",{\"1\":{\"78\":4,\"467\":2}}],[\"dice\",{\"0\":{\"467\":1,\"468\":1},\"1\":{\"15\":1,\"40\":1,\"55\":1,\"78\":14,\"467\":17,\"468\":21,\"469\":2,\"471\":2,\"473\":14}}],[\"dezero\",{\"1\":{\"696\":1}}],[\"dependency\",{\"1\":{\"577\":2}}],[\"depth\",{\"1\":{\"272\":6,\"323\":1,\"385\":1,\"774\":1,\"814\":3,\"822\":6,\"848\":1}}],[\"depth=12\",{\"1\":{\"160\":2,\"272\":1,\"320\":1,\"323\":1,\"327\":1}}],[\"density\",{\"1\":{\"728\":1}}],[\"densenet\",{\"1\":{\"395\":1}}],[\"dense\",{\"1\":{\"289\":2,\"292\":2,\"295\":2,\"470\":1,\"599\":4,\"601\":2,\"606\":2,\"609\":2,\"626\":1,\"704\":2}}],[\"dennison\",{\"1\":{\"536\":1}}],[\"delta\",{\"1\":{\"801\":7}}],[\"del\",{\"1\":{\"476\":1,\"478\":1,\"632\":3}}],[\"detokenize\",{\"1\":{\"578\":2}}],[\"detokenizers\",{\"1\":{\"522\":1}}],[\"detection\",{\"1\":{\"470\":1}}],[\"details\",{\"0\":{\"583\":1},\"1\":{\"536\":1}}],[\"detail\",{\"0\":{\"249\":1}}],[\"detailed\",{\"1\":{\"12\":1,\"28\":2,\"235\":1}}],[\"detach\",{\"1\":{\"83\":1,\"145\":3,\"147\":2,\"161\":2,\"170\":2,\"186\":2,\"255\":1,\"796\":6,\"815\":1,\"821\":3,\"840\":1,\"881\":2,\"885\":3}}],[\"deactivate\",{\"1\":{\"433\":1}}],[\"dead\",{\"1\":{\"170\":1}}],[\"deit\",{\"1\":{\"160\":1,\"395\":1}}],[\"dequeue\",{\"0\":{\"257\":1},\"1\":{\"145\":1,\"147\":1,\"161\":1,\"255\":2,\"257\":2}}],[\"devlin\",{\"1\":{\"126\":1,\"131\":1,\"552\":1}}],[\"device=device\",{\"1\":{\"794\":1,\"798\":1,\"803\":1,\"815\":3,\"820\":1,\"848\":1}}],[\"device=x\",{\"1\":{\"590\":4}}],[\"device=input\",{\"1\":{\"597\":1}}],[\"device=inputs\",{\"1\":{\"544\":1}}],[\"device=image\",{\"1\":{\"310\":1}}],[\"device=img\",{\"1\":{\"277\":1}}],[\"device=\",{\"1\":{\"378\":1}}],[\"device=none\",{\"1\":{\"378\":1,\"848\":1}}],[\"device=sim\",{\"1\":{\"311\":1}}],[\"device=logits\",{\"1\":{\"277\":1}}],[\"device=multi\",{\"1\":{\"43\":1}}],[\"device\",{\"1\":{\"28\":1,\"40\":3,\"43\":1,\"59\":5,\"70\":1,\"82\":1,\"92\":15,\"142\":4,\"143\":2,\"145\":5,\"146\":2,\"147\":6,\"159\":3,\"161\":2,\"162\":1,\"163\":3,\"170\":2,\"186\":2,\"277\":2,\"278\":1,\"302\":5,\"304\":5,\"309\":2,\"310\":1,\"311\":4,\"312\":1,\"313\":2,\"323\":4,\"327\":1,\"378\":1,\"463\":1,\"544\":2,\"581\":2,\"590\":4,\"597\":1,\"794\":2,\"803\":3,\"815\":6,\"820\":2,\"821\":4,\"822\":8,\"848\":14,\"856\":4,\"857\":2,\"860\":5,\"861\":2,\"885\":2,\"886\":4}}],[\"deeplearning\",{\"1\":{\"252\":2}}],[\"deepseekr1\",{\"1\":{\"704\":1}}],[\"deepseekmoe\",{\"1\":{\"704\":1}}],[\"deepseek\",{\"1\":{\"219\":1,\"703\":1,\"704\":17}}],[\"deep\",{\"1\":{\"115\":1}}],[\"descent\",{\"1\":{\"697\":2}}],[\"desc=\",{\"1\":{\"476\":4,\"478\":2}}],[\"desc\",{\"1\":{\"300\":2}}],[\"describe\",{\"1\":{\"28\":4}}],[\"description\",{\"1\":{\"12\":1,\"28\":2,\"40\":3,\"235\":1,\"870\":1,\"872\":1}}],[\"destroy\",{\"1\":{\"83\":1}}],[\"debug\",{\"1\":{\"82\":1,\"345\":2}}],[\"dec\",{\"1\":{\"793\":8,\"821\":22}}],[\"deconvolution\",{\"1\":{\"777\":1}}],[\"decorate\",{\"1\":{\"348\":2}}],[\"decorator\",{\"1\":{\"341\":3,\"343\":4,\"344\":2,\"345\":4,\"346\":5,\"349\":3,\"352\":2,\"817\":1,\"820\":1,\"821\":1}}],[\"decode\",{\"1\":{\"126\":1,\"143\":1,\"313\":1,\"541\":2,\"544\":2,\"578\":1,\"616\":1,\"623\":2,\"817\":1,\"820\":1,\"821\":2,\"853\":2,\"857\":3,\"859\":2,\"861\":1}}],[\"decoders\",{\"1\":{\"843\":1}}],[\"decoder模型结构图\",{\"1\":{\"630\":1,\"631\":1}}],[\"decoderlayer\",{\"0\":{\"630\":1},\"1\":{\"630\":2}}],[\"decoder=true时\",{\"1\":{\"312\":1}}],[\"decoder=true\",{\"1\":{\"295\":1,\"312\":1}}],[\"decoder=is\",{\"1\":{\"163\":1,\"295\":1,\"312\":1}}],[\"decoder=false\",{\"1\":{\"163\":1,\"289\":1}}],[\"decoder\",{\"0\":{\"15\":1,\"126\":1,\"623\":1,\"629\":1,\"631\":1},\"1\":{\"30\":1,\"35\":1,\"40\":1,\"45\":1,\"46\":1,\"59\":2,\"70\":2,\"76\":3,\"99\":1,\"120\":1,\"126\":2,\"127\":1,\"138\":1,\"142\":8,\"143\":5,\"147\":10,\"163\":2,\"167\":3,\"199\":1,\"295\":3,\"307\":1,\"312\":9,\"313\":2,\"510\":1,\"514\":1,\"610\":2,\"616\":1,\"622\":2,\"623\":4,\"630\":1,\"631\":3,\"704\":5,\"773\":1,\"792\":1,\"793\":2,\"794\":1,\"809\":1,\"821\":5,\"854\":1,\"867\":1,\"871\":2,\"881\":1,\"885\":7,\"886\":2}}],[\"decoding过程\",{\"1\":{\"70\":2,\"76\":1}}],[\"decoding\",{\"1\":{\"70\":1}}],[\"decay=args\",{\"1\":{\"252\":1}}],[\"decay=0\",{\"1\":{\"169\":1,\"170\":2,\"581\":1}}],[\"decay=config\",{\"1\":{\"142\":1,\"145\":1,\"147\":1}}],[\"decay=opt\",{\"1\":{\"80\":1}}],[\"decay\",{\"1\":{\"80\":1,\"142\":1,\"145\":1,\"147\":1,\"169\":3,\"170\":11,\"186\":4,\"252\":1,\"840\":2}}],[\"definition\",{\"0\":{\"752\":1}}],[\"defined\",{\"1\":{\"630\":1}}],[\"define\",{\"1\":{\"252\":1,\"692\":2}}],[\"defaultdict\",{\"1\":{\"476\":5,\"478\":5}}],[\"default=400\",{\"1\":{\"840\":1}}],[\"default=1\",{\"1\":{\"840\":1}}],[\"default=100\",{\"1\":{\"840\":1}}],[\"default=28\",{\"1\":{\"840\":1}}],[\"default=200\",{\"1\":{\"840\":1}}],[\"default=0\",{\"1\":{\"840\":3}}],[\"default=64\",{\"1\":{\"840\":1}}],[\"default=8\",{\"1\":{\"186\":1,\"840\":1}}],[\"default=\",{\"1\":{\"186\":2}}],[\"default\",{\"1\":{\"83\":1,\"254\":4,\"274\":2,\"817\":1,\"821\":1}}],[\"def\",{\"1\":{\"29\":2,\"30\":1,\"32\":1,\"33\":1,\"34\":4,\"35\":4,\"36\":4,\"40\":1,\"41\":2,\"43\":1,\"45\":4,\"46\":2,\"58\":2,\"59\":14,\"68\":3,\"70\":1,\"72\":2,\"73\":2,\"74\":2,\"75\":1,\"76\":2,\"78\":2,\"80\":1,\"83\":4,\"92\":7,\"93\":2,\"96\":4,\"98\":1,\"100\":2,\"101\":2,\"107\":2,\"108\":1,\"109\":2,\"110\":2,\"111\":2,\"142\":5,\"143\":1,\"145\":4,\"146\":2,\"147\":4,\"159\":1,\"160\":1,\"161\":1,\"162\":1,\"163\":3,\"169\":2,\"170\":5,\"186\":8,\"252\":4,\"254\":1,\"255\":1,\"256\":1,\"257\":1,\"272\":8,\"274\":25,\"275\":3,\"276\":2,\"277\":3,\"278\":1,\"289\":3,\"290\":2,\"291\":1,\"292\":3,\"293\":1,\"295\":6,\"302\":8,\"303\":3,\"304\":11,\"309\":1,\"311\":1,\"312\":4,\"313\":1,\"316\":5,\"318\":2,\"319\":3,\"320\":3,\"321\":4,\"322\":2,\"323\":4,\"327\":1,\"336\":2,\"339\":2,\"340\":2,\"341\":3,\"343\":3,\"344\":3,\"345\":4,\"346\":6,\"347\":3,\"348\":1,\"349\":1,\"350\":1,\"351\":3,\"353\":6,\"396\":1,\"398\":1,\"463\":1,\"467\":2,\"468\":2,\"469\":2,\"470\":2,\"471\":2,\"473\":2,\"476\":9,\"477\":6,\"478\":23,\"541\":1,\"544\":6,\"577\":2,\"578\":6,\"579\":3,\"580\":2,\"584\":2,\"590\":2,\"591\":3,\"594\":3,\"596\":1,\"597\":2,\"599\":6,\"600\":2,\"601\":2,\"602\":2,\"603\":2,\"605\":3,\"606\":2,\"607\":2,\"609\":2,\"610\":2,\"611\":2,\"612\":2,\"615\":2,\"617\":2,\"618\":2,\"623\":4,\"624\":2,\"626\":2,\"627\":2,\"628\":2,\"630\":2,\"631\":2,\"632\":3,\"637\":1,\"643\":3,\"644\":1,\"647\":2,\"652\":1,\"659\":1,\"660\":2,\"661\":1,\"664\":2,\"665\":1,\"668\":1,\"671\":2,\"672\":1,\"673\":1,\"675\":2,\"676\":2,\"681\":3,\"682\":1,\"683\":1,\"684\":1,\"686\":5,\"687\":2,\"688\":5,\"689\":7,\"690\":24,\"691\":1,\"692\":3,\"696\":6,\"697\":2,\"793\":3,\"794\":1,\"801\":3,\"802\":3,\"803\":2,\"804\":4,\"814\":1,\"815\":2,\"816\":1,\"817\":1,\"818\":1,\"819\":1,\"820\":1,\"821\":4,\"822\":2,\"840\":5,\"848\":4,\"853\":5,\"854\":1,\"859\":5,\"885\":8,\"886\":5}}],[\"d\",{\"1\":{\"6\":1,\"19\":1,\"40\":1,\"70\":1,\"92\":4,\"96\":4,\"100\":17,\"108\":4,\"145\":11,\"147\":16,\"161\":8,\"162\":1,\"163\":1,\"169\":1,\"170\":19,\"196\":2,\"197\":1,\"198\":1,\"199\":1,\"282\":1,\"299\":6,\"307\":2,\"313\":4,\"320\":2,\"370\":4,\"388\":1,\"423\":1,\"580\":10,\"584\":2,\"590\":33,\"591\":1,\"605\":2,\"618\":1,\"624\":3,\"632\":15,\"697\":1,\"752\":1,\"794\":2,\"803\":6,\"804\":7,\"814\":2,\"821\":11,\"822\":4,\"840\":13}}],[\"方程\",{\"1\":{\"773\":1}}],[\"方式提供了对照方案\",{\"1\":{\"536\":1}}],[\"方案退火到\",{\"1\":{\"514\":1}}],[\"方面发挥了重要作用\",{\"1\":{\"216\":1}}],[\"方差必须\",{\"1\":{\"853\":1}}],[\"方差为\",{\"1\":{\"755\":1}}],[\"方差差异大且可能相关的情况\",{\"1\":{\"460\":1}}],[\"方差是\",{\"1\":{\"459\":1}}],[\"方差大\",{\"1\":{\"457\":1}}],[\"方差\",{\"1\":{\"186\":1,\"366\":1}}],[\"方便后续处理\",{\"1\":{\"821\":1}}],[\"方便后续的计算和比较\",{\"1\":{\"302\":1}}],[\"方便离散索引的推断\",{\"1\":{\"795\":1}}],[\"方便加到\",{\"1\":{\"591\":1}}],[\"方便加到注意力分数\",{\"1\":{\"591\":1}}],[\"方便和下游任务对接\",{\"1\":{\"284\":1}}],[\"方便\",{\"1\":{\"170\":1,\"276\":1}}],[\"方向信息保留\",{\"1\":{\"591\":1}}],[\"方向信息已在上一步编码\",{\"1\":{\"591\":1}}],[\"方向分桶\",{\"1\":{\"591\":1}}],[\"方向为主\",{\"1\":{\"393\":1}}],[\"方向差异\",{\"1\":{\"170\":1}}],[\"方向\",{\"1\":{\"40\":1,\"455\":1,\"796\":1}}],[\"方向研究\",{\"1\":{\"2\":1}}],[\"方法获取输入图像对应的离散视觉\",{\"1\":{\"821\":1}}],[\"方法就是在\",{\"1\":{\"820\":1}}],[\"方法负责将图像裁剪为一系列固定大小的\",{\"1\":{\"804\":1}}],[\"方法求导\",{\"1\":{\"697\":1}}],[\"方法会被优先调用\",{\"1\":{\"690\":1}}],[\"方法以支持数组索引\",{\"1\":{\"689\":1}}],[\"方法被调用时\",{\"1\":{\"686\":1}}],[\"方法与目标\",{\"1\":{\"550\":1}}],[\"方法的实例\",{\"1\":{\"690\":3}}],[\"方法的核心概括图\",{\"1\":{\"537\":1}}],[\"方法的特定任务的输入改写\",{\"1\":{\"507\":1}}],[\"方法处理variable\",{\"1\":{\"690\":1}}],[\"方法处理输入输出的变量封装\",{\"1\":{\"642\":1}}],[\"方法处理\",{\"1\":{\"514\":1}}],[\"方法来模拟函数行为\",{\"1\":{\"351\":1}}],[\"方法来完成与\",{\"1\":{\"272\":1}}],[\"方法中保存输入输出变量\",{\"1\":{\"660\":1}}],[\"方法中\",{\"1\":{\"312\":1,\"664\":1,\"690\":1}}],[\"方法中已开始尝试\",{\"1\":{\"123\":1}}],[\"方法可知\",{\"1\":{\"278\":1}}],[\"方法进行下游迁移学习\",{\"1\":{\"527\":1}}],[\"方法进行分析\",{\"1\":{\"272\":1}}],[\"方法进行训练的代码实现\",{\"1\":{\"142\":1}}],[\"方法和应用场景有显著区别\",{\"1\":{\"239\":1}}],[\"方法二\",{\"1\":{\"236\":1}}],[\"方法一\",{\"1\":{\"236\":1}}],[\"方法代码实现\",{\"1\":{\"163\":1}}],[\"方法实现从离散视觉token索引到图像的重建过程\",{\"1\":{\"821\":1}}],[\"方法实现\",{\"1\":{\"145\":1,\"272\":1,\"794\":1}}],[\"方法参考\",{\"1\":{\"127\":1}}],[\"方法部分主要分为三个内容\",{\"1\":{\"125\":1}}],[\"方法依赖从网络抓取的图文对数据\",{\"1\":{\"122\":1}}],[\"方法虽然在多模态任务上取得进展\",{\"1\":{\"120\":1}}],[\"方法\",{\"0\":{\"8\":1,\"53\":1,\"166\":1,\"177\":1,\"195\":1,\"221\":1,\"233\":1,\"374\":1,\"521\":1,\"528\":1,\"537\":1,\"548\":1,\"767\":1,\"807\":1},\"1\":{\"82\":1,\"112\":1,\"114\":1,\"175\":1,\"198\":3,\"263\":2,\"274\":2,\"275\":1,\"276\":1,\"491\":1,\"682\":1,\"688\":1,\"689\":1,\"690\":8,\"765\":1,\"793\":1,\"821\":1,\"857\":1}}],[\"方法创新\",{\"1\":{\"6\":1}}],[\"倒水\",{\"1\":{\"6\":1,\"32\":1}}],[\"壶嘴的形状\",{\"1\":{\"32\":1}}],[\"壶嘴上开口狭窄\",{\"1\":{\"28\":1}}],[\"壶嘴\",{\"1\":{\"6\":1,\"32\":1}}],[\"h^2\",{\"1\":{\"801\":1}}],[\"html\",{\"1\":{\"717\":1}}],[\"https\",{\"1\":{\"4\":3,\"37\":2,\"47\":3,\"60\":2,\"85\":3,\"102\":3,\"119\":1,\"140\":1,\"148\":1,\"164\":1,\"171\":1,\"172\":1,\"187\":2,\"231\":2,\"240\":1,\"259\":1,\"270\":1,\"277\":1,\"279\":1,\"306\":2,\"316\":2,\"327\":4,\"463\":1,\"472\":1,\"544\":1,\"570\":1,\"577\":2,\"593\":2,\"620\":1,\"633\":1,\"679\":1,\"694\":1,\"699\":1,\"735\":1,\"764\":1,\"816\":1,\"821\":1,\"849\":1}}],[\"hh\",{\"1\":{\"476\":1}}],[\"h`和\",{\"1\":{\"318\":1}}],[\"hparams\",{\"1\":{\"275\":1,\"276\":1}}],[\"hpt\",{\"1\":{\"218\":1}}],[\"hyperparameter\",{\"1\":{\"248\":1}}],[\"hybrid\",{\"0\":{\"78\":1},\"1\":{\"78\":1,\"326\":1}}],[\"hr\",{\"1\":{\"219\":1}}],[\"hoffmann\",{\"1\":{\"552\":1}}],[\"honest\",{\"1\":{\"535\":1,\"537\":1}}],[\"houlsby\",{\"1\":{\"491\":1}}],[\"home\",{\"1\":{\"434\":3}}],[\"hook\",{\"1\":{\"312\":1}}],[\"horse\",{\"1\":{\"300\":1}}],[\"how\",{\"1\":{\"214\":2}}],[\"hog\",{\"1\":{\"165\":1}}],[\"hot向量\",{\"1\":{\"248\":1,\"795\":1}}],[\"hot\",{\"1\":{\"145\":3,\"154\":1,\"155\":1,\"156\":1,\"157\":3,\"159\":3,\"170\":2,\"738\":1,\"794\":4,\"795\":6,\"796\":7,\"821\":11,\"832\":1,\"860\":1,\"861\":1,\"881\":1}}],[\"hold\",{\"1\":{\"83\":2,\"578\":2}}],[\"holyoak\",{\"1\":{\"6\":1}}],[\"huber\",{\"1\":{\"797\":1}}],[\"hub\",{\"1\":{\"304\":1}}],[\"hugging\",{\"1\":{\"274\":1}}],[\"huggingface\",{\"0\":{\"544\":1},\"1\":{\"163\":2,\"304\":1,\"544\":3,\"578\":1}}],[\"hue=0\",{\"1\":{\"186\":1}}],[\"hutter\",{\"1\":{\"131\":1}}],[\"human\",{\"1\":{\"28\":1,\"29\":2,\"30\":2,\"32\":1,\"33\":2,\"232\":1,\"234\":1,\"235\":2,\"483\":1,\"533\":1,\"535\":1,\"536\":1,\"537\":1}}],[\"hw\",{\"1\":{\"41\":1,\"45\":3,\"59\":1,\"821\":1}}],[\"hm\",{\"0\":{\"78\":1},\"1\":{\"40\":6,\"78\":3,\"80\":2,\"81\":3}}],[\"he\",{\"1\":{\"476\":1}}],[\"hey\",{\"1\":{\"476\":1}}],[\"helmholtz\",{\"1\":{\"872\":1}}],[\"hellaswag\",{\"1\":{\"537\":1}}],[\"hello\",{\"1\":{\"341\":1,\"343\":7,\"346\":5,\"347\":2,\"476\":1,\"477\":1}}],[\"held\",{\"1\":{\"521\":1,\"537\":2,\"538\":1}}],[\"helpful\",{\"1\":{\"535\":1,\"537\":1}}],[\"help\",{\"1\":{\"346\":1,\"435\":2}}],[\"help=\",{\"1\":{\"186\":3,\"840\":10}}],[\"hermes\",{\"1\":{\"223\":2}}],[\"here\",{\"1\":{\"73\":1,\"603\":1}}],[\"heavy\",{\"1\":{\"749\":1}}],[\"heatmap\",{\"1\":{\"40\":1,\"46\":2}}],[\"head2\",{\"1\":{\"591\":1}}],[\"head2根据体重计算相似度\",{\"1\":{\"463\":1}}],[\"head1\",{\"1\":{\"591\":1}}],[\"head1根据身高计算相似度\",{\"1\":{\"463\":1}}],[\"head0\",{\"1\":{\"591\":1}}],[\"head3根据年龄计算相似度\",{\"1\":{\"463\":1}}],[\"head结构由linear+tanh激活函数+linear组成\",{\"1\":{\"323\":1}}],[\"head进行分类\",{\"1\":{\"323\":1}}],[\"head的位置是和这个\",{\"1\":{\"319\":1}}],[\"head之中再输出分类结果\",{\"1\":{\"319\":1}}],[\"head将输出feature映射成一个二值logits\",{\"1\":{\"285\":1}}],[\"header\",{\"1\":{\"159\":1,\"803\":1}}],[\"head==\",{\"1\":{\"146\":2}}],[\"head=\",{\"1\":{\"146\":1}}],[\"heads代表transformer中multi\",{\"1\":{\"324\":1}}],[\"heads=8\",{\"1\":{\"272\":1,\"322\":1}}],[\"heads=num\",{\"1\":{\"272\":2,\"321\":1,\"323\":1}}],[\"heads=12\",{\"1\":{\"160\":2,\"272\":1,\"320\":1,\"323\":1,\"327\":1,\"591\":1}}],[\"heads=dict\",{\"1\":{\"80\":1,\"83\":1}}],[\"heads\",{\"1\":{\"41\":6,\"59\":6,\"80\":1,\"83\":1,\"272\":11,\"312\":1,\"321\":2,\"322\":12,\"323\":1,\"463\":2,\"544\":1,\"584\":2,\"590\":7,\"591\":15,\"605\":7,\"632\":3,\"814\":3,\"822\":6}}],[\"head\",{\"0\":{\"9\":1,\"11\":1,\"12\":1,\"28\":1,\"323\":1},\"1\":{\"6\":2,\"13\":2,\"26\":1,\"35\":2,\"40\":1,\"46\":6,\"59\":4,\"98\":1,\"99\":1,\"145\":2,\"146\":2,\"147\":2,\"160\":1,\"162\":2,\"163\":2,\"186\":15,\"201\":1,\"213\":1,\"272\":5,\"293\":2,\"295\":1,\"311\":1,\"312\":10,\"319\":1,\"320\":1,\"321\":1,\"322\":8,\"323\":3,\"324\":1,\"327\":1,\"413\":1,\"415\":1,\"463\":5,\"544\":6,\"590\":1,\"591\":4,\"600\":2,\"602\":1,\"603\":2,\"605\":10,\"612\":2,\"615\":1,\"617\":2,\"618\":2,\"622\":1,\"704\":1,\"781\":1,\"804\":4,\"814\":4}}],[\"height=3\",{\"1\":{\"423\":1}}],[\"height=600\",{\"1\":{\"83\":1}}],[\"height\",{\"1\":{\"40\":1,\"170\":1,\"272\":1,\"316\":1,\"423\":1,\"428\":1,\"801\":5,\"804\":1,\"848\":8}}],[\"hezhu\",{\"1\":{\"37\":1}}],[\"him\",{\"1\":{\"549\":1,\"551\":1}}],[\"his\",{\"1\":{\"549\":1,\"551\":1}}],[\"history=\",{\"1\":{\"28\":2}}],[\"history=history\",{\"1\":{\"28\":3}}],[\"history=true\",{\"1\":{\"28\":4}}],[\"history=none\",{\"1\":{\"28\":1}}],[\"history\",{\"1\":{\"28\":2}}],[\"hinge\",{\"0\":{\"472\":1},\"1\":{\"472\":1}}],[\"high\",{\"1\":{\"376\":2,\"871\":1}}],[\"higher\",{\"1\":{\"339\":1}}],[\"hi\",{\"1\":{\"351\":1}}],[\"hiddens\",{\"1\":{\"277\":22}}],[\"hidden\",{\"1\":{\"40\":4,\"42\":2,\"43\":3,\"44\":3,\"45\":1,\"142\":1,\"143\":1,\"145\":7,\"146\":3,\"147\":7,\"160\":3,\"161\":4,\"162\":13,\"163\":10,\"272\":7,\"277\":11,\"289\":8,\"290\":9,\"291\":4,\"292\":17,\"293\":8,\"294\":1,\"295\":25,\"309\":8,\"310\":7,\"311\":7,\"312\":34,\"313\":1,\"321\":9,\"324\":1,\"544\":26,\"580\":2,\"597\":5,\"599\":24,\"600\":5,\"601\":5,\"603\":4,\"605\":8,\"606\":12,\"609\":15,\"610\":7,\"611\":1,\"612\":1,\"614\":6,\"615\":2,\"617\":3,\"618\":4,\"793\":14,\"821\":3,\"853\":6,\"859\":6,\"885\":6,\"886\":5}}],[\"hierarchy\",{\"1\":{\"35\":1,\"59\":1}}],[\"hv\",{\"1\":{\"32\":1}}],[\"hq\",{\"1\":{\"32\":1}}],[\"h进行交互融合\",{\"1\":{\"30\":1}}],[\"h=\",{\"1\":{\"30\":1}}],[\"h\",{\"1\":{\"30\":9,\"33\":5,\"34\":6,\"35\":5,\"40\":3,\"41\":2,\"43\":1,\"59\":4,\"105\":5,\"145\":1,\"161\":3,\"170\":7,\"252\":1,\"272\":6,\"276\":1,\"299\":1,\"309\":1,\"318\":4,\"319\":1,\"320\":1,\"323\":1,\"370\":2,\"388\":3,\"389\":2,\"390\":2,\"463\":6,\"471\":2,\"473\":1,\"476\":5,\"541\":1,\"544\":1,\"580\":5,\"590\":8,\"591\":18,\"593\":3,\"632\":9,\"727\":1,\"758\":3,\"794\":9,\"798\":4,\"801\":9,\"802\":1,\"803\":1,\"804\":2,\"815\":1,\"821\":22,\"822\":3,\"831\":4,\"846\":3,\"848\":2,\"853\":5,\"859\":5,\"885\":6,\"886\":7}}],[\"hdim\",{\"1\":{\"821\":1}}],[\"hdf5\",{\"1\":{\"438\":1}}],[\"hd\",{\"1\":{\"29\":3}}],[\"half\",{\"0\":{\"747\":1},\"1\":{\"747\":1,\"749\":1}}],[\"hallucination\",{\"1\":{\"538\":1}}],[\"hallucinate\",{\"1\":{\"537\":1}}],[\"hallusionbench分数最高\",{\"1\":{\"228\":1}}],[\"haiku\",{\"1\":{\"704\":2}}],[\"hairy\",{\"1\":{\"572\":2}}],[\"hairy→my\",{\"1\":{\"572\":3}}],[\"have\",{\"1\":{\"538\":1,\"817\":1,\"821\":1}}],[\"harvardnlp\",{\"1\":{\"620\":1}}],[\"harmless\",{\"1\":{\"535\":1,\"537\":1}}],[\"hard=true时\",{\"0\":{\"796\":1}}],[\"hard=true\",{\"1\":{\"795\":2,\"796\":1}}],[\"hard=false\",{\"1\":{\"795\":1}}],[\"hard=self\",{\"1\":{\"794\":1,\"795\":1,\"796\":1}}],[\"hardneg\",{\"1\":{\"275\":1,\"278\":2}}],[\"hard\",{\"1\":{\"78\":1,\"82\":1,\"147\":1,\"156\":1,\"159\":1,\"161\":1,\"162\":2,\"163\":2,\"176\":1,\"265\":4,\"268\":2,\"275\":1,\"278\":2,\"470\":2,\"795\":1,\"796\":4,\"821\":1}}],[\"happy\",{\"1\":{\"322\":1}}],[\"ha=\",{\"1\":{\"316\":1}}],[\"haotian\",{\"1\":{\"231\":1}}],[\"hasattr\",{\"1\":{\"274\":1}}],[\"has\",{\"1\":{\"40\":1,\"312\":1,\"327\":3,\"594\":2,\"821\":2}}],[\"hammer\",{\"1\":{\"29\":1}}],[\"hat\",{\"1\":{\"29\":1,\"58\":1,\"68\":1}}],[\"hands\",{\"1\":{\"83\":2}}],[\"handle\",{\"1\":{\"28\":1,\"31\":2,\"32\":1}}],[\"hand\",{\"1\":{\"28\":4,\"31\":4}}],[\"hk\",{\"1\":{\"29\":4,\"32\":20,\"33\":2}}],[\"研究不断融合新的方法\",{\"1\":{\"806\":1}}],[\"研究和应用\",{\"1\":{\"705\":1}}],[\"研究人员提出了一种新的模型架构\",{\"1\":{\"709\":1}}],[\"研究人员还在努力让计算机理解图像和文字\",{\"1\":{\"708\":1}}],[\"研究人员发现\",{\"1\":{\"703\":1}}],[\"研究人员不断尝试改进\",{\"1\":{\"703\":1}}],[\"研究揭示了模型性能提升的关键因素并非复杂结构改动\",{\"1\":{\"569\":1}}],[\"研究强调了预训练中设计选择和数据规模的重要性\",{\"1\":{\"558\":1}}],[\"研究团队定义了标注规则\",{\"1\":{\"539\":1}}],[\"研究团队开源模型权重\",{\"1\":{\"216\":1}}],[\"研究还探讨了数据污染问题\",{\"1\":{\"526\":1}}],[\"研究还提出了目前最大的3d功能数据集piadv2\",{\"1\":{\"5\":1}}],[\"研究结果对构建通用语言系统具有重要意义\",{\"1\":{\"524\":1}}],[\"研究意义\",{\"1\":{\"520\":1,\"527\":1}}],[\"研究视觉与语言预训练在多大程度上能够互相促进\",{\"1\":{\"269\":1}}],[\"研究背景与问题\",{\"1\":{\"189\":1,\"216\":1}}],[\"研究发现\",{\"1\":{\"181\":1,\"519\":1,\"559\":1}}],[\"研究者尝试用不同生成模型改善文本到图像的转换\",{\"1\":{\"806\":1}}],[\"研究者的设计意图\",{\"1\":{\"539\":1}}],[\"研究者将\",{\"1\":{\"268\":1}}],[\"研究者探索\",{\"1\":{\"173\":1}}],[\"研究者提出一个问题\",{\"1\":{\"173\":1}}],[\"研究表明\",{\"1\":{\"6\":1,\"269\":1,\"523\":1,\"534\":1}}],[\"bhw\",{\"1\":{\"885\":4}}],[\"bhld\",{\"1\":{\"590\":3}}],[\"b类\",{\"1\":{\"845\":1}}],[\"b1\",{\"1\":{\"840\":3}}],[\"b中\",{\"1\":{\"690\":3}}],[\"b时\",{\"1\":{\"690\":1}}],[\"b上有1个点的绝对提升\",{\"1\":{\"515\":1}}],[\"b为例\",{\"1\":{\"690\":1}}],[\"b为r\",{\"1\":{\"487\":1}}],[\"b为批量大小\",{\"1\":{\"322\":1}}],[\"bpe\",{\"1\":{\"475\":2,\"476\":8,\"478\":7,\"514\":1,\"521\":4,\"559\":1,\"564\":1,\"807\":1,\"809\":1}}],[\"b2\",{\"1\":{\"333\":3,\"840\":3}}],[\"b=批大小\",{\"1\":{\"272\":1}}],[\"b=3\",{\"1\":{\"145\":1,\"401\":1}}],[\"b同样表现出这种趋势\",{\"1\":{\"181\":1}}],[\"bd\",{\"1\":{\"170\":1}}],[\"b+k\",{\"1\":{\"161\":3,\"162\":1}}],[\"b+q\",{\"1\":{\"147\":6}}],[\"bubble\",{\"1\":{\"754\":1}}],[\"but\",{\"1\":{\"605\":1,\"610\":1}}],[\"build\",{\"1\":{\"541\":15,\"594\":1,\"802\":1,\"803\":1}}],[\"builder\",{\"1\":{\"252\":1}}],[\"built\",{\"1\":{\"336\":2}}],[\"buffer的作用和意义\",{\"1\":{\"366\":1}}],[\"buffer\",{\"0\":{\"366\":1},\"1\":{\"145\":4,\"147\":3,\"160\":3,\"169\":2,\"170\":4,\"186\":1,\"254\":2,\"366\":1,\"814\":2,\"848\":2,\"886\":1}}],[\"buckets=32\",{\"1\":{\"591\":2}}],[\"buckets\",{\"1\":{\"170\":6,\"591\":29}}],[\"bucket\",{\"1\":{\"29\":1,\"591\":18}}],[\"bceloss\",{\"1\":{\"840\":1}}],[\"bce\",{\"0\":{\"468\":1},\"1\":{\"78\":3,\"467\":1,\"468\":17,\"469\":2,\"470\":2,\"854\":3,\"885\":1}}],[\"bcn\",{\"1\":{\"70\":1,\"76\":3}}],[\"bleu或精确匹配评估\",{\"1\":{\"528\":1}}],[\"bleu\",{\"1\":{\"522\":2}}],[\"blob\",{\"1\":{\"316\":1,\"544\":1}}],[\"blockwise\",{\"0\":{\"801\":1},\"1\":{\"772\":1,\"780\":3}}],[\"block第一个全连接的节点个数\",{\"1\":{\"324\":1}}],[\"block的次数\",{\"1\":{\"324\":1}}],[\"block块序列\",{\"1\":{\"323\":2}}],[\"blocking=true\",{\"1\":{\"159\":1}}],[\"block\",{\"1\":{\"126\":1,\"173\":1,\"199\":1,\"272\":5,\"276\":1,\"277\":5,\"321\":3,\"323\":1,\"511\":1,\"544\":2,\"771\":1,\"780\":1,\"802\":3,\"804\":2,\"814\":1,\"840\":5,\"885\":1}}],[\"blocks\",{\"1\":{\"96\":7,\"272\":1,\"276\":1,\"277\":7,\"323\":2,\"804\":1,\"821\":4}}],[\"blk\",{\"1\":{\"276\":2,\"277\":4,\"804\":2}}],[\"black\",{\"1\":{\"234\":1,\"300\":1,\"552\":1}}],[\"blip2qformer\",{\"1\":{\"309\":1,\"313\":2}}],[\"blip2qformer核心代码实现如下\",{\"1\":{\"309\":1}}],[\"blip2\",{\"1\":{\"306\":1}}],[\"blip2base\",{\"1\":{\"40\":1,\"309\":1,\"313\":1}}],[\"blip\",{\"0\":{\"119\":1,\"147\":1},\"1\":{\"119\":3,\"120\":2,\"122\":1,\"123\":1,\"124\":1,\"125\":1,\"127\":1,\"129\":2,\"131\":1,\"134\":1,\"138\":3,\"140\":3,\"142\":4,\"145\":4,\"146\":1,\"147\":7,\"199\":1,\"202\":1,\"287\":1,\"295\":1,\"307\":2,\"308\":1}}],[\"blc\",{\"1\":{\"70\":1,\"76\":3}}],[\"bytenet和convs2s等网络模型\",{\"1\":{\"621\":1}}],[\"bytepairs\",{\"1\":{\"478\":1}}],[\"bytepairtokenizer\",{\"1\":{\"476\":2,\"477\":2,\"478\":5}}],[\"bytes\",{\"1\":{\"476\":2,\"477\":20,\"478\":35}}],[\"byte\",{\"1\":{\"421\":1,\"475\":1,\"476\":4,\"477\":7,\"478\":35,\"521\":1,\"564\":1}}],[\"byol等框架接近\",{\"1\":{\"182\":1}}],[\"byol等\",{\"1\":{\"178\":1}}],[\"byol\",{\"1\":{\"175\":5,\"179\":1,\"784\":1,\"802\":1}}],[\"by\",{\"1\":{\"68\":1,\"254\":1,\"478\":1,\"500\":1,\"505\":1,\"601\":1,\"692\":2,\"815\":1,\"816\":1,\"820\":1,\"822\":1}}],[\"bn=args\",{\"1\":{\"186\":1}}],[\"bn5\",{\"1\":{\"107\":2}}],[\"bn4\",{\"1\":{\"107\":2}}],[\"bn3\",{\"1\":{\"107\":2,\"109\":2,\"111\":2}}],[\"bn2\",{\"1\":{\"93\":2,\"96\":2,\"107\":2,\"109\":2,\"110\":2,\"111\":2}}],[\"bn1\",{\"1\":{\"93\":2,\"96\":2,\"101\":2,\"107\":2,\"109\":2,\"110\":2,\"111\":2}}],[\"bns\",{\"1\":{\"92\":3,\"96\":3,\"100\":3}}],[\"bn\",{\"1\":{\"46\":1,\"92\":2,\"96\":7,\"100\":4,\"107\":1,\"186\":4,\"255\":1}}],[\"bsz\",{\"1\":{\"278\":5}}],[\"bs\",{\"1\":{\"43\":2,\"83\":1,\"145\":5,\"147\":7,\"162\":7,\"311\":19}}],[\"bmm\",{\"1\":{\"32\":4,\"41\":3,\"45\":4,\"59\":3,\"107\":1,\"108\":1,\"109\":2,\"367\":1}}],[\"brew\",{\"1\":{\"696\":1}}],[\"break\",{\"1\":{\"29\":1,\"478\":1,\"541\":1,\"544\":1,\"801\":2}}],[\"broader\",{\"1\":{\"539\":1}}],[\"broadcast\",{\"0\":{\"427\":1},\"1\":{\"427\":1}}],[\"broadcasting\",{\"1\":{\"364\":1}}],[\"broom\",{\"1\":{\"29\":1}}],[\"brightness=0\",{\"1\":{\"186\":1}}],[\"borel\",{\"1\":{\"728\":6}}],[\"bos\",{\"1\":{\"142\":2,\"143\":2,\"147\":2,\"312\":3,\"313\":3,\"820\":1}}],[\"bookcorpus\",{\"1\":{\"560\":1,\"561\":1,\"565\":1}}],[\"book\",{\"1\":{\"522\":1,\"529\":1,\"549\":1}}],[\"books3\",{\"1\":{\"548\":1}}],[\"books2\",{\"1\":{\"528\":1}}],[\"books1\",{\"1\":{\"528\":1}}],[\"bookscorpus\",{\"1\":{\"514\":1}}],[\"books\",{\"1\":{\"514\":1,\"547\":1,\"704\":1}}],[\"bool\",{\"1\":{\"142\":1,\"163\":3,\"254\":1,\"272\":1,\"327\":1,\"366\":2,\"467\":1,\"468\":1,\"469\":1,\"470\":1,\"477\":1,\"478\":2,\"544\":1,\"803\":8,\"804\":6}}],[\"bootstrapped\",{\"0\":{\"137\":1},\"1\":{\"136\":1,\"137\":1,\"138\":1,\"140\":1}}],[\"bootstrapping\",{\"1\":{\"119\":2,\"120\":1,\"134\":1,\"138\":2}}],[\"bounding\",{\"1\":{\"59\":2,\"234\":2}}],[\"box框文件路径\",{\"1\":{\"58\":1}}],[\"box\",{\"1\":{\"58\":17,\"59\":44,\"234\":2}}],[\"bottleneck\",{\"1\":{\"71\":1,\"105\":1,\"112\":1}}],[\"bottle\",{\"1\":{\"29\":1,\"40\":1,\"58\":1,\"68\":1}}],[\"bowl\",{\"1\":{\"29\":1,\"58\":1,\"68\":1}}],[\"body\",{\"1\":{\"28\":1}}],[\"biggan\",{\"1\":{\"785\":1}}],[\"bigram\",{\"1\":{\"476\":2,\"478\":2}}],[\"bivariate\",{\"1\":{\"752\":1}}],[\"bits\",{\"1\":{\"872\":1}}],[\"bit\",{\"1\":{\"605\":1,\"828\":3,\"829\":2}}],[\"bidirectional\",{\"1\":{\"571\":1,\"765\":1,\"790\":1}}],[\"bid\",{\"1\":{\"478\":2}}],[\"bilstm\",{\"1\":{\"515\":1}}],[\"bilinear\",{\"0\":{\"390\":1},\"1\":{\"387\":1,\"388\":1}}],[\"billion\",{\"1\":{\"324\":1,\"522\":1}}],[\"bi\",{\"1\":{\"311\":2}}],[\"bias\",{\"0\":{\"551\":1,\"591\":1},\"1\":{\"186\":1,\"272\":20,\"276\":3,\"277\":9,\"314\":1,\"321\":1,\"322\":1,\"323\":1,\"591\":17,\"610\":3,\"804\":4,\"822\":2}}],[\"bias=rel\",{\"1\":{\"804\":1}}],[\"bias=relative\",{\"1\":{\"272\":1,\"276\":1,\"277\":4}}],[\"bias=none\",{\"1\":{\"272\":2}}],[\"bias=qkv\",{\"1\":{\"272\":3,\"321\":1,\"322\":1,\"323\":1}}],[\"bias=true\",{\"1\":{\"160\":2,\"272\":1,\"320\":1,\"323\":1}}],[\"bias=false\",{\"1\":{\"73\":2,\"272\":5,\"295\":1,\"321\":1,\"322\":1,\"580\":1,\"610\":1,\"848\":8}}],[\"bicubic\",{\"1\":{\"179\":1,\"186\":3,\"388\":1}}],[\"bicycle\",{\"1\":{\"29\":1}}],[\"binomial\",{\"0\":{\"737\":1,\"740\":1},\"1\":{\"737\":1,\"741\":1}}],[\"bin\",{\"1\":{\"387\":7,\"593\":1}}],[\"bincount\",{\"0\":{\"377\":1},\"1\":{\"170\":1,\"377\":4,\"398\":2}}],[\"bins\",{\"1\":{\"170\":13}}],[\"binary\",{\"0\":{\"2\":1},\"1\":{\"0\":1,\"64\":1,\"78\":1,\"82\":11,\"468\":6,\"470\":2,\"473\":1,\"854\":4}}],[\"binaryoracle\",{\"1\":{\"0\":1,\"570\":1,\"633\":1,\"679\":1,\"694\":1,\"699\":1}}],[\"bfloat16\",{\"1\":{\"28\":2}}],[\"below\",{\"1\":{\"630\":1}}],[\"ben18785\",{\"1\":{\"735\":1}}],[\"bengio\",{\"1\":{\"703\":1}}],[\"bender\",{\"1\":{\"536\":1}}],[\"benchmarks\",{\"1\":{\"514\":1}}],[\"benchmark\",{\"0\":{\"22\":1},\"1\":{\"515\":1,\"522\":1}}],[\"be\",{\"1\":{\"478\":1,\"578\":1,\"594\":1,\"696\":1,\"815\":1,\"821\":2,\"822\":1}}],[\"begin\",{\"1\":{\"312\":1}}],[\"beginning\",{\"1\":{\"143\":1}}],[\"beit主模型预训练\",{\"0\":{\"803\":1}}],[\"beit在图像分类和语义分割等下游任务中表现优异\",{\"1\":{\"765\":1}}],[\"beit将图像表示为两种视图\",{\"1\":{\"765\":1}}],[\"beit3\",{\"0\":{\"171\":1},\"1\":{\"171\":1}}],[\"beit\",{\"0\":{\"764\":1,\"772\":1,\"775\":1,\"791\":1},\"1\":{\"164\":2,\"165\":2,\"167\":3,\"171\":2,\"208\":1,\"260\":1,\"266\":1,\"268\":2,\"764\":3,\"765\":1,\"766\":5,\"767\":3,\"769\":1,\"772\":1,\"773\":4,\"774\":2,\"775\":1,\"776\":1,\"777\":1,\"778\":2,\"780\":2,\"781\":3,\"786\":1,\"787\":1,\"788\":4,\"789\":1,\"790\":4,\"791\":2,\"792\":1,\"796\":1,\"802\":5,\"803\":4,\"821\":1}}],[\"beit2\",{\"0\":{\"164\":1},\"1\":{\"164\":1}}],[\"bermanmaxim\",{\"1\":{\"472\":1}}],[\"bernoulli\",{\"0\":{\"737\":1},\"1\":{\"163\":3,\"737\":1,\"873\":1}}],[\"bert支持的下游任务图\",{\"1\":{\"613\":1}}],[\"bertformultiplechoice\",{\"1\":{\"618\":2}}],[\"bertformaskedlm\",{\"1\":{\"160\":2}}],[\"bertfortokenclassification\",{\"1\":{\"617\":2}}],[\"bertforquestionanswering\",{\"1\":{\"614\":1,\"615\":2}}],[\"bertforpretraining结构图\",{\"1\":{\"612\":1}}],[\"bertforpretraining\",{\"0\":{\"612\":1},\"1\":{\"612\":2}}],[\"bertforsequenceclassification模型结构图\",{\"1\":{\"603\":1}}],[\"bertforsequenceclassification\",{\"0\":{\"603\":1},\"1\":{\"603\":2}}],[\"bertoutput\",{\"1\":{\"599\":3}}],[\"bertonlymlmhead\",{\"1\":{\"312\":1}}],[\"bertintermediate\",{\"1\":{\"599\":3}}],[\"bert文本分类实战\",{\"1\":{\"592\":1}}],[\"bertdataset\",{\"1\":{\"581\":1}}],[\"berttokenizer中的特殊token\",{\"1\":{\"594\":1}}],[\"berttokenizer\",{\"1\":{\"578\":1,\"594\":3,\"614\":1}}],[\"bert的mlm目标本身足够强大\",{\"1\":{\"567\":1}}],[\"bert原始设计未充分优化\",{\"1\":{\"567\":1}}],[\"bert原始设计存在优化空间\",{\"1\":{\"562\":1}}],[\"bert训练1m步\",{\"1\":{\"565\":1}}],[\"bert训练数据\",{\"1\":{\"565\":1}}],[\"bert使用256的批次大小\",{\"1\":{\"564\":1}}],[\"bert使用nsp任务\",{\"1\":{\"564\":1}}],[\"bert采用\",{\"1\":{\"562\":1}}],[\"bertembeddings\",{\"0\":{\"597\":1},\"1\":{\"311\":1,\"597\":2,\"602\":1}}],[\"bertembeddings会将text\",{\"1\":{\"311\":1}}],[\"bertencoder模型结构图\",{\"1\":{\"600\":1}}],[\"bertencoder\",{\"0\":{\"290\":1,\"598\":1,\"600\":1},\"1\":{\"290\":1,\"312\":2,\"600\":2,\"602\":1}}],[\"bertselfoutput计算流程图\",{\"1\":{\"606\":1}}],[\"bertselfoutput\",{\"0\":{\"606\":1},\"1\":{\"292\":1,\"606\":2,\"607\":1}}],[\"bertselfattention\",{\"0\":{\"293\":1,\"605\":1},\"1\":{\"162\":1,\"293\":1,\"312\":2,\"605\":2,\"607\":1}}],[\"bertattention计算流程图\",{\"1\":{\"607\":1}}],[\"bertattention\",{\"0\":{\"292\":1,\"604\":1,\"607\":1},\"1\":{\"292\":1,\"599\":1,\"607\":2}}],[\"bertlmpredictionhead结构图\",{\"1\":{\"610\":1}}],[\"bertlmpredictionhead\",{\"0\":{\"610\":1},\"1\":{\"295\":2,\"610\":2,\"611\":1}}],[\"bertlmheadmodel自回归语言建模实现\",{\"1\":{\"142\":1}}],[\"bertlmheadmodel\",{\"1\":{\"142\":1,\"147\":1,\"295\":2,\"312\":2}}],[\"bertlayer模型结构图\",{\"1\":{\"599\":1}}],[\"bertlayernorm\",{\"1\":{\"597\":1,\"599\":1,\"606\":1,\"609\":1}}],[\"bertlayer\",{\"0\":{\"291\":1,\"599\":1},\"1\":{\"290\":1,\"291\":1,\"312\":3,\"599\":2,\"600\":1}}],[\"bertpretrainingheads结构图\",{\"1\":{\"611\":1}}],[\"bertpretrainingheads\",{\"0\":{\"611\":1},\"1\":{\"611\":2,\"612\":1}}],[\"bertpretrainedmodel\",{\"1\":{\"289\":1,\"295\":1,\"312\":1,\"602\":1,\"603\":1,\"612\":1,\"615\":1,\"617\":1,\"618\":1}}],[\"bertpredictionheadtransform结构图\",{\"1\":{\"609\":1}}],[\"bertpredictionheadtransform\",{\"0\":{\"609\":1},\"1\":{\"295\":2,\"609\":2,\"610\":1}}],[\"bertpooler模型结构图\",{\"1\":{\"601\":1}}],[\"bertpooler\",{\"0\":{\"601\":1},\"1\":{\"289\":1,\"601\":2,\"602\":1}}],[\"bert属于\",{\"1\":{\"282\":1}}],[\"bertmodel模型结构图\",{\"1\":{\"602\":1}}],[\"bertmodel\",{\"0\":{\"289\":1,\"602\":1},\"1\":{\"145\":2,\"146\":1,\"147\":2,\"289\":1,\"295\":1,\"312\":2,\"602\":2,\"603\":1,\"605\":1,\"612\":1,\"615\":1,\"617\":1,\"618\":1}}],[\"bertconfig\",{\"1\":{\"142\":1,\"160\":2}}],[\"bertbase\",{\"1\":{\"131\":1,\"152\":1}}],[\"bert\",{\"0\":{\"288\":1,\"383\":1,\"570\":1,\"571\":1,\"592\":1,\"788\":2},\"1\":{\"126\":2,\"147\":5,\"160\":3,\"161\":3,\"162\":2,\"163\":3,\"173\":1,\"239\":1,\"247\":2,\"248\":1,\"261\":2,\"263\":1,\"268\":1,\"295\":3,\"309\":2,\"311\":1,\"312\":2,\"475\":1,\"521\":1,\"531\":1,\"552\":1,\"557\":1,\"559\":3,\"560\":7,\"561\":4,\"563\":1,\"571\":4,\"572\":2,\"574\":1,\"575\":4,\"578\":1,\"580\":4,\"581\":1,\"593\":16,\"594\":1,\"603\":2,\"612\":2,\"614\":5,\"615\":2,\"616\":9,\"617\":2,\"618\":7,\"703\":1,\"764\":2,\"766\":1,\"769\":1,\"772\":1,\"775\":1,\"788\":4,\"790\":3,\"802\":1}}],[\"before\",{\"1\":{\"148\":2,\"257\":1,\"273\":2,\"341\":1,\"346\":2,\"439\":1}}],[\"bear\",{\"1\":{\"157\":1}}],[\"beam数量\",{\"1\":{\"313\":1}}],[\"beams=num\",{\"1\":{\"143\":1,\"313\":1}}],[\"beams=3\",{\"1\":{\"143\":1,\"313\":1}}],[\"beams\",{\"1\":{\"143\":3,\"313\":4}}],[\"beam\",{\"1\":{\"133\":3,\"143\":4,\"313\":1}}],[\"beat\",{\"1\":{\"29\":1}}],[\"best\",{\"1\":{\"82\":6,\"83\":1,\"476\":18,\"478\":8,\"581\":7}}],[\"betwen\",{\"1\":{\"840\":1}}],[\"between\",{\"1\":{\"28\":2,\"605\":1}}],[\"beta=beta\",{\"1\":{\"471\":1,\"473\":1}}],[\"beta得分\",{\"1\":{\"471\":1}}],[\"beta\",{\"1\":{\"170\":8,\"471\":4,\"885\":2}}],[\"betas=\",{\"1\":{\"80\":1,\"840\":2}}],[\"bed\",{\"1\":{\"29\":1,\"58\":1,\"68\":1}}],[\"bayesian\",{\"1\":{\"758\":3}}],[\"bayes\",{\"0\":{\"758\":1},\"1\":{\"732\":2,\"758\":2}}],[\"bad\",{\"1\":{\"716\":2,\"717\":3}}],[\"bahdanau\",{\"1\":{\"536\":1}}],[\"ba\",{\"1\":{\"492\":1}}],[\"basicvae\",{\"1\":{\"793\":1}}],[\"bashrc\",{\"1\":{\"439\":1}}],[\"bash\",{\"1\":{\"439\":2}}],[\"basemodeloutputwithpastandcrossattentions\",{\"1\":{\"312\":1,\"544\":1}}],[\"basemodeloutputwithpoolingandcrossattentions\",{\"1\":{\"289\":1}}],[\"basename\",{\"1\":{\"302\":1,\"304\":1}}],[\"base作为默认视觉编码器\",{\"1\":{\"142\":1}}],[\"base\",{\"1\":{\"142\":1,\"145\":1,\"146\":1,\"147\":4,\"173\":1,\"186\":2,\"252\":5,\"254\":3,\"268\":3,\"317\":1,\"327\":7,\"425\":1,\"433\":1,\"434\":1,\"593\":6,\"704\":2,\"774\":1}}],[\"basedataset\",{\"1\":{\"274\":3}}],[\"basedatamodule\",{\"1\":{\"274\":4}}],[\"based\",{\"1\":{\"112\":2,\"115\":1,\"313\":1,\"478\":1,\"537\":1,\"816\":1}}],[\"baseballbat\",{\"1\":{\"29\":1}}],[\"baseline\",{\"1\":{\"22\":1}}],[\"balanced\",{\"1\":{\"399\":3}}],[\"ball\",{\"1\":{\"90\":4,\"92\":6,\"96\":2,\"98\":1}}],[\"barlow\",{\"1\":{\"784\":1}}],[\"bart\",{\"1\":{\"616\":1}}],[\"bar\",{\"1\":{\"316\":1}}],[\"baidu\",{\"1\":{\"316\":1,\"327\":1}}],[\"bank\",{\"1\":{\"175\":1,\"250\":4}}],[\"batchmean\",{\"1\":{\"794\":1,\"798\":1,\"821\":1}}],[\"batch数据准备\",{\"0\":{\"579\":1}}],[\"batch=1\",{\"1\":{\"423\":2}}],[\"batch和text\",{\"1\":{\"309\":1}}],[\"batch中只有一条数据\",{\"1\":{\"274\":1}}],[\"batchsize\",{\"1\":{\"107\":2,\"108\":1,\"111\":2,\"246\":1,\"274\":1}}],[\"batches\",{\"1\":{\"81\":1,\"302\":2,\"304\":2,\"581\":3,\"632\":1,\"840\":4}}],[\"batched\",{\"1\":{\"43\":1}}],[\"batchnorm2d\",{\"1\":{\"92\":1,\"96\":1,\"848\":24}}],[\"batchnorm\",{\"1\":{\"46\":1,\"92\":1,\"109\":1,\"212\":1,\"821\":1}}],[\"batchnorm1d\",{\"1\":{\"34\":2,\"35\":3,\"36\":3,\"41\":2,\"45\":1,\"46\":1,\"59\":6,\"93\":2,\"96\":2,\"98\":1,\"100\":2,\"101\":1,\"107\":5,\"109\":3,\"110\":2,\"111\":3,\"840\":1}}],[\"batch\",{\"1\":{\"30\":8,\"34\":11,\"35\":3,\"40\":2,\"43\":7,\"45\":1,\"59\":4,\"70\":1,\"76\":2,\"78\":1,\"80\":3,\"82\":1,\"92\":13,\"107\":6,\"108\":2,\"127\":1,\"142\":2,\"145\":6,\"147\":2,\"156\":1,\"162\":1,\"170\":1,\"175\":1,\"178\":1,\"185\":4,\"186\":13,\"246\":4,\"249\":3,\"250\":4,\"252\":6,\"255\":4,\"257\":6,\"265\":1,\"272\":2,\"273\":16,\"274\":25,\"275\":12,\"276\":10,\"277\":13,\"278\":34,\"302\":9,\"304\":9,\"309\":1,\"310\":2,\"311\":1,\"312\":1,\"313\":3,\"316\":4,\"317\":2,\"322\":10,\"358\":1,\"369\":1,\"415\":1,\"423\":3,\"428\":1,\"467\":2,\"468\":1,\"469\":1,\"470\":3,\"537\":1,\"544\":4,\"562\":2,\"564\":1,\"579\":4,\"580\":14,\"581\":10,\"584\":7,\"590\":3,\"591\":6,\"593\":2,\"596\":4,\"605\":2,\"614\":6,\"615\":3,\"617\":2,\"618\":7,\"632\":2,\"774\":1,\"803\":5,\"804\":3,\"814\":1,\"815\":3,\"820\":1,\"840\":6,\"848\":4,\"855\":1,\"856\":3,\"885\":1,\"886\":3}}],[\"backends\",{\"1\":{\"848\":1}}],[\"backprop为true时\",{\"1\":{\"688\":1}}],[\"backprop\",{\"1\":{\"688\":4}}],[\"backpack\",{\"1\":{\"29\":1,\"234\":1}}],[\"background\",{\"1\":{\"83\":1}}],[\"back\",{\"1\":{\"83\":3,\"872\":1}}],[\"backward方法\",{\"1\":{\"688\":1}}],[\"backward\",{\"0\":{\"682\":1},\"1\":{\"81\":1,\"142\":1,\"145\":1,\"147\":1,\"159\":1,\"186\":1,\"252\":1,\"273\":2,\"323\":1,\"581\":1,\"660\":1,\"661\":1,\"662\":3,\"665\":3,\"668\":2,\"672\":1,\"675\":2,\"676\":1,\"681\":1,\"682\":4,\"684\":2,\"685\":2,\"686\":2,\"687\":1,\"688\":3,\"690\":6,\"692\":3,\"696\":1,\"697\":3,\"796\":1,\"840\":2,\"848\":1,\"856\":1,\"860\":1,\"885\":1,\"886\":1}}],[\"backbone\",{\"1\":{\"22\":2,\"70\":3,\"160\":1,\"178\":1,\"186\":16,\"777\":1}}],[\"bag\",{\"1\":{\"29\":1,\"58\":1,\"68\":1,\"305\":3}}],[\"b\",{\"1\":{\"6\":1,\"17\":1,\"24\":1,\"30\":4,\"32\":2,\"35\":2,\"40\":15,\"41\":11,\"43\":1,\"45\":28,\"46\":10,\"49\":2,\"58\":2,\"59\":72,\"70\":9,\"72\":2,\"73\":2,\"74\":2,\"75\":2,\"76\":17,\"78\":2,\"82\":3,\"92\":56,\"93\":2,\"96\":11,\"98\":4,\"100\":33,\"101\":7,\"107\":3,\"109\":4,\"111\":7,\"131\":4,\"145\":39,\"147\":15,\"152\":1,\"160\":7,\"161\":15,\"162\":6,\"163\":2,\"170\":7,\"196\":1,\"197\":1,\"220\":1,\"272\":19,\"276\":1,\"278\":4,\"282\":1,\"299\":2,\"307\":2,\"309\":8,\"310\":17,\"311\":4,\"313\":3,\"317\":3,\"318\":8,\"319\":7,\"320\":5,\"322\":3,\"323\":5,\"324\":1,\"327\":2,\"333\":2,\"344\":2,\"345\":2,\"370\":8,\"427\":6,\"453\":2,\"455\":1,\"463\":4,\"467\":4,\"468\":4,\"469\":4,\"470\":4,\"473\":1,\"492\":3,\"511\":1,\"515\":1,\"537\":1,\"541\":2,\"566\":1,\"578\":5,\"579\":20,\"580\":1,\"584\":1,\"590\":13,\"591\":9,\"594\":1,\"618\":1,\"647\":4,\"662\":3,\"685\":2,\"687\":6,\"690\":14,\"727\":2,\"794\":9,\"798\":4,\"803\":1,\"804\":13,\"809\":2,\"815\":7,\"821\":23,\"822\":6,\"845\":8,\"846\":12,\"848\":17,\"866\":3,\"885\":6,\"886\":6}}],[\"如普通\",{\"1\":{\"885\":1}}],[\"如均值和方差的加权\",{\"1\":{\"869\":1}}],[\"如马尔可夫链蒙特卡洛\",{\"1\":{\"864\":1}}],[\"如前\",{\"1\":{\"817\":1}}],[\"如关闭\",{\"1\":{\"817\":1}}],[\"如除文本外的其他标签\",{\"1\":{\"806\":1}}],[\"如物体部分标签\",{\"1\":{\"806\":1}}],[\"如颜色抖动\",{\"1\":{\"802\":1}}],[\"如不同数据增强后的同一图像\",{\"1\":{\"784\":1}}],[\"如分类\",{\"1\":{\"766\":1}}],[\"如分割\",{\"1\":{\"245\":1}}],[\"如多层嵌套\",{\"1\":{\"692\":1}}],[\"如z\",{\"1\":{\"692\":1}}],[\"如sub\",{\"1\":{\"692\":1}}],[\"如simclr\",{\"1\":{\"178\":1}}],[\"如y\",{\"1\":{\"690\":1}}],[\"如减法\",{\"1\":{\"690\":1}}],[\"如模型预测\",{\"1\":{\"688\":2}}],[\"如模型深度\",{\"1\":{\"197\":1}}],[\"如平方函数\",{\"1\":{\"660\":1}}],[\"如自注意力层和前馈层\",{\"1\":{\"622\":1}}],[\"如自然语言推理\",{\"1\":{\"530\":1,\"560\":1}}],[\"如句子\",{\"1\":{\"622\":1}}],[\"如句子长度\",{\"1\":{\"405\":1}}],[\"如判断哪个是答案的开始\",{\"1\":{\"616\":1}}],[\"如正弦\",{\"1\":{\"588\":1}}],[\"如正样本少则增大\",{\"1\":{\"470\":1}}],[\"如上图所示\",{\"1\":{\"686\":1}}],[\"如上图\",{\"1\":{\"575\":1}}],[\"如上描述是我们通常认知的gpt推理过程\",{\"1\":{\"541\":1}}],[\"如xlnet使用10倍于bert的数据\",{\"1\":{\"568\":1}}],[\"如xlnet\",{\"1\":{\"568\":1}}],[\"如8k\",{\"1\":{\"562\":1}}],[\"如800×1300\",{\"1\":{\"224\":1}}],[\"如对比\",{\"1\":{\"561\":1}}],[\"如对抗性推理\",{\"1\":{\"529\":1}}],[\"如动态掩码\",{\"1\":{\"560\":1}}],[\"如动量率\",{\"1\":{\"185\":1}}],[\"如延长训练时间\",{\"1\":{\"559\":1}}],[\"如gradscaler\",{\"1\":{\"803\":1}}],[\"如glue\",{\"1\":{\"558\":1}}],[\"如gpt\",{\"1\":{\"192\":1,\"216\":1,\"228\":1,\"522\":1,\"527\":1,\"535\":1,\"547\":1}}],[\"如wikipedia引用过滤\",{\"1\":{\"551\":1}}],[\"如word2vec\",{\"1\":{\"248\":1,\"520\":1}}],[\"如后续alpaca\",{\"1\":{\"550\":1}}],[\"如象棋开局策略分析\",{\"1\":{\"550\":1}}],[\"如html标签清理的正则表达式\",{\"1\":{\"550\":1}}],[\"如a\",{\"1\":{\"687\":1,\"690\":1}}],[\"如astronomy\",{\"1\":{\"550\":1}}],[\"如and\",{\"1\":{\"385\":1}}],[\"如boolq\",{\"1\":{\"549\":1}}],[\"如bert\",{\"1\":{\"520\":1,\"523\":1,\"531\":1}}],[\"如bert和uniter\",{\"1\":{\"283\":1}}],[\"如bed\",{\"1\":{\"68\":1}}],[\"如小模型长期训练\",{\"1\":{\"548\":1}}],[\"如标点缺失\",{\"1\":{\"548\":1}}],[\"如针对少数群体敏感任务\",{\"1\":{\"539\":1}}],[\"如非英语任务\",{\"1\":{\"539\":1}}],[\"如法语\",{\"1\":{\"538\":1}}],[\"如法线\",{\"1\":{\"92\":1}}],[\"如选择\",{\"1\":{\"538\":1}}],[\"如是否\",{\"1\":{\"537\":1}}],[\"如创作\",{\"1\":{\"537\":1}}],[\"如摘要\",{\"1\":{\"536\":1}}],[\"如医疗\",{\"1\":{\"530\":1}}],[\"如医学图像\",{\"1\":{\"473\":1}}],[\"如ner\",{\"1\":{\"530\":1}}],[\"如roberta训练500k步\",{\"1\":{\"562\":1}}],[\"如rte和anli\",{\"1\":{\"529\":1}}],[\"如rag\",{\"1\":{\"529\":1}}],[\"如retinanet\",{\"1\":{\"470\":1}}],[\"如relu\",{\"1\":{\"385\":2}}],[\"如resnet\",{\"1\":{\"191\":1,\"196\":1}}],[\"如结合双向架构或多模态训练\",{\"1\":{\"527\":1}}],[\"如结合clip和dinov2\",{\"1\":{\"220\":1}}],[\"如计算成本\",{\"1\":{\"527\":1}}],[\"如词向量\",{\"1\":{\"527\":1}}],[\"如词汇蕴含\",{\"1\":{\"515\":1}}],[\"如偏见和能源消耗\",{\"1\":{\"526\":1}}],[\"如在glue等基准上的表现\",{\"1\":{\"523\":1}}],[\"如用文档中的人名回答\",{\"1\":{\"522\":1}}],[\"如perspectiveapi过滤\",{\"1\":{\"551\":1}}],[\"如ptb\",{\"1\":{\"522\":1,\"529\":1}}],[\"如pos\",{\"1\":{\"508\":1}}],[\"如翻译后的句子\",{\"1\":{\"622\":1}}],[\"如翻译对\",{\"1\":{\"521\":1,\"523\":1}}],[\"如翻译\",{\"1\":{\"521\":1}}],[\"如elmo\",{\"1\":{\"520\":1}}],[\"如问答时生成而非抽取答案\",{\"1\":{\"523\":1}}],[\"如问答对\",{\"1\":{\"521\":1}}],[\"如问答\",{\"1\":{\"517\":1,\"519\":1,\"520\":1}}],[\"如有序句子对\",{\"1\":{\"512\":1}}],[\"如作者在实验中证明的\",{\"1\":{\"507\":1}}],[\"如机翻\",{\"1\":{\"507\":1}}],[\"如语言建模\",{\"1\":{\"568\":1}}],[\"如语言模型\",{\"1\":{\"507\":1}}],[\"如语义分割\",{\"1\":{\"197\":1}}],[\"如tensorboard\",{\"1\":{\"803\":1}}],[\"如tensorflow\",{\"1\":{\"692\":1}}],[\"如textvqa\",{\"1\":{\"216\":1}}],[\"如t转置\",{\"1\":{\"689\":1}}],[\"如tinypytorch中每一步运算都会动态创建计算图链接\",{\"1\":{\"692\":1}}],[\"如tinypytorch框架\",{\"1\":{\"691\":1}}],[\"如tinypytorch\",{\"1\":{\"687\":1}}],[\"如triviaqa\",{\"1\":{\"549\":1}}],[\"如transformer\",{\"1\":{\"527\":1}}],[\"如tversky\",{\"1\":{\"474\":1}}],[\"如欺诈检测\",{\"1\":{\"470\":1}}],[\"如功能区域边缘不确定性较高\",{\"1\":{\"469\":1}}],[\"如经过\",{\"1\":{\"467\":1}}],[\"如经过下采样后的点\",{\"1\":{\"100\":1}}],[\"如身高标准化后波动在\",{\"1\":{\"459\":1}}],[\"如年龄\",{\"1\":{\"459\":1}}],[\"如需进一步帮助\",{\"1\":{\"435\":1}}],[\"如需了解各类优化手段\",{\"1\":{\"288\":1}}],[\"如此往复循环\",{\"1\":{\"428\":1}}],[\"如此反复\",{\"1\":{\"326\":1}}],[\"如加法\",{\"1\":{\"427\":1}}],[\"如下面的公式所示\",{\"1\":{\"882\":1}}],[\"如下\",{\"1\":{\"748\":1}}],[\"如下表2\",{\"1\":{\"516\":1}}],[\"如下例所示\",{\"1\":{\"423\":2}}],[\"如下所示\",{\"1\":{\"421\":1,\"425\":1,\"762\":1}}],[\"如下图所示\",{\"1\":{\"321\":1,\"427\":1,\"490\":1,\"686\":1,\"697\":1,\"845\":1,\"878\":1}}],[\"如池化\",{\"1\":{\"385\":1}}],[\"如边缘→纹理→物体\",{\"1\":{\"385\":1}}],[\"如残差块\",{\"1\":{\"385\":1}}],[\"如卷积核\",{\"1\":{\"385\":1}}],[\"如大数相减损失精度\",{\"1\":{\"385\":1}}],[\"如使用relu\",{\"1\":{\"385\":1}}],[\"如泰勒展开\",{\"1\":{\"385\":2}}],[\"如构造重复输入\",{\"1\":{\"364\":1}}],[\"如列表\",{\"1\":{\"358\":1}}],[\"如交叉熵损失\",{\"1\":{\"319\":1}}],[\"如局部性和平移不变性\",{\"1\":{\"314\":1}}],[\"如variable与数值\",{\"1\":{\"690\":1}}],[\"如vse++\",{\"1\":{\"307\":1}}],[\"如vilt\",{\"1\":{\"307\":1}}],[\"如vilbert和lxmert\",{\"1\":{\"283\":1}}],[\"如vicuna\",{\"1\":{\"196\":1}}],[\"如vit\",{\"1\":{\"191\":2,\"196\":1,\"313\":1}}],[\"如function和临时variable\",{\"1\":{\"687\":1}}],[\"如f\",{\"1\":{\"687\":1}}],[\"如faster\",{\"1\":{\"281\":1}}],[\"如flamingo\",{\"1\":{\"193\":1}}],[\"如基于\",{\"1\":{\"280\":1}}],[\"如准确率\",{\"1\":{\"274\":1}}],[\"如解码器中的自回归屏蔽\",{\"1\":{\"272\":1}}],[\"如从词级别信息到更高的\",{\"1\":{\"508\":1}}],[\"如从\",{\"1\":{\"272\":1}}],[\"如视觉问答\",{\"1\":{\"267\":1}}],[\"如视觉问答或视觉推理\",{\"1\":{\"261\":1}}],[\"如检测\",{\"1\":{\"241\":1}}],[\"如检索\",{\"1\":{\"196\":1,\"197\":1}}],[\"如mae和beit\",{\"1\":{\"305\":1}}],[\"如mmmu\",{\"1\":{\"229\":1}}],[\"如moco和simclr\",{\"1\":{\"305\":1}}],[\"如moco\",{\"1\":{\"182\":1,\"248\":1}}],[\"如dot\",{\"1\":{\"696\":1}}],[\"如docvqa\",{\"1\":{\"229\":1}}],[\"如drop\",{\"1\":{\"529\":1}}],[\"如dropout\",{\"1\":{\"385\":1}}],[\"如deepseek\",{\"1\":{\"220\":1}}],[\"如224×224\",{\"1\":{\"223\":1}}],[\"如256\",{\"1\":{\"161\":1}}],[\"如40个epoch\",{\"1\":{\"562\":1}}],[\"如448×448图像对应256个token\",{\"1\":{\"222\":1}}],[\"如48\",{\"1\":{\"51\":1}}],[\"如文本与生成图像的紧密契合度\",{\"1\":{\"816\":1}}],[\"如文本描述\",{\"1\":{\"816\":1}}],[\"如文本生成\",{\"1\":{\"312\":1}}],[\"如文本或图像\",{\"1\":{\"7\":1}}],[\"如文档图像\",{\"1\":{\"223\":1}}],[\"如文档\",{\"1\":{\"220\":1}}],[\"如ureader\",{\"1\":{\"219\":1}}],[\"如lambada\",{\"1\":{\"522\":1}}],[\"如lay\",{\"1\":{\"68\":1}}],[\"如llava\",{\"1\":{\"219\":1}}],[\"如低分辨率用于场景描述\",{\"1\":{\"216\":1}}],[\"如ocr和中文场景理解\",{\"1\":{\"216\":1}}],[\"如3通道rgb\",{\"1\":{\"804\":1}}],[\"如33b模型在1\",{\"1\":{\"549\":1}}],[\"如336×336或448×448\",{\"1\":{\"216\":1,\"219\":1}}],[\"如34b参数\",{\"1\":{\"229\":1}}],[\"如36\",{\"1\":{\"51\":1}}],[\"如重复文本\",{\"1\":{\"198\":1}}],[\"如零样本图像分类和检索\",{\"1\":{\"197\":1}}],[\"如描述\",{\"1\":{\"196\":1}}],[\"如core\",{\"1\":{\"691\":1}}],[\"如coqa\",{\"1\":{\"529\":1}}],[\"如clip\",{\"1\":{\"196\":2,\"307\":1}}],[\"如chatglm\",{\"1\":{\"192\":1}}],[\"如kosmos\",{\"1\":{\"193\":1}}],[\"如qformer\",{\"1\":{\"193\":1}}],[\"如qformer或线性投影\",{\"1\":{\"189\":1,\"197\":1}}],[\"如65b毒性最高\",{\"1\":{\"551\":1}}],[\"如6b参数\",{\"1\":{\"229\":1}}],[\"如6×\",{\"1\":{\"184\":1}}],[\"如68\",{\"1\":{\"52\":1}}],[\"如原始像素\",{\"1\":{\"165\":1}}],[\"如知识蒸馏\",{\"1\":{\"163\":1}}],[\"如论文中的图\",{\"1\":{\"157\":1}}],[\"如方差\",{\"1\":{\"115\":1}}],[\"如时间序列点云\",{\"1\":{\"112\":1}}],[\"如只有几十个点\",{\"1\":{\"112\":1}}],[\"如弯曲\",{\"1\":{\"112\":1}}],[\"如人体姿态变化\",{\"1\":{\"112\":1}}],[\"如椅子腿和桌面连接处\",{\"1\":{\"112\":1}}],[\"如旋转\",{\"1\":{\"104\":1,\"107\":1,\"108\":1}}],[\"如最大池化\",{\"1\":{\"103\":1}}],[\"如桌子边缘\",{\"1\":{\"112\":1}}],[\"如桌子\",{\"1\":{\"98\":1,\"101\":1}}],[\"如何计算\",{\"1\":{\"866\":1}}],[\"如何计算loss的\",{\"1\":{\"310\":1}}],[\"如何定义潜变量\",{\"1\":{\"866\":1}}],[\"如何控制同一个像素内部的\",{\"1\":{\"846\":1}}],[\"如何仅靠图像生成图像\",{\"1\":{\"815\":1}}],[\"如何实现的\",{\"0\":{\"796\":1}}],[\"如何获取答案\",{\"1\":{\"616\":1}}],[\"如何利用\",{\"1\":{\"614\":1}}],[\"如何去理解这个位置编码\",{\"1\":{\"587\":1}}],[\"如何生成并起作用的\",{\"0\":{\"584\":1}}],[\"如何生成点集的划分\",{\"1\":{\"86\":1}}],[\"如何建立更强的\",{\"1\":{\"539\":1}}],[\"如何应对多价值体系的冲突\",{\"1\":{\"539\":1}}],[\"如何更有效缓解毒性与偏见\",{\"1\":{\"539\":1}}],[\"如何写好prompt\",{\"0\":{\"498\":1}}],[\"如何对大模型进行微调\",{\"0\":{\"483\":1}}],[\"如何选择\",{\"0\":{\"474\":1}}],[\"如何通过调整步幅\",{\"1\":{\"427\":1}}],[\"如何理解这个过程\",{\"0\":{\"411\":1}}],[\"如何降低模型训练成本\",{\"1\":{\"307\":1}}],[\"如何将不同尺寸的roi特征\",{\"1\":{\"386\":1}}],[\"如何将二维图像转换为一维时间序列\",{\"1\":{\"328\":1}}],[\"如何将这个预训练的视觉模型应用到新的任务中呢\",{\"1\":{\"300\":1}}],[\"如何将其与视觉模态结合成为关键挑战\",{\"1\":{\"192\":1}}],[\"如何设计一个能够从这些局部分区中学习有用特征的机制\",{\"1\":{\"86\":1}}],[\"如何有效地对点云进行分区\",{\"1\":{\"86\":1}}],[\"如16×16像素的局部区域\",{\"1\":{\"765\":1}}],[\"如1e\",{\"1\":{\"564\":1}}],[\"如13b\",{\"1\":{\"549\":1}}],[\"如13b模型比gpt\",{\"1\":{\"547\":1}}],[\"如130\",{\"1\":{\"521\":1}}],[\"如10\",{\"1\":{\"520\":1}}],[\"如1\",{\"1\":{\"52\":1,\"470\":1,\"696\":1}}],[\"如12\",{\"1\":{\"51\":1}}],[\"如11\",{\"1\":{\"49\":1,\"51\":1}}],[\"如表4所示\",{\"1\":{\"562\":1}}],[\"如表3所示\",{\"1\":{\"562\":1}}],[\"如表20所示\",{\"1\":{\"208\":1}}],[\"如表2所示\",{\"1\":{\"7\":1,\"23\":1,\"562\":1}}],[\"如表9所示\",{\"1\":{\"185\":1}}],[\"如表5所示\",{\"1\":{\"181\":1}}],[\"如表\",{\"1\":{\"136\":1,\"198\":1,\"559\":3,\"560\":2}}],[\"如表1所示\",{\"1\":{\"51\":1,\"562\":1}}],[\"如果仍然希望引入一个调节项\",{\"1\":{\"873\":1}}],[\"如果这样的函数存在\",{\"1\":{\"871\":1}}],[\"如果这些关键点缺失或被遮挡\",{\"1\":{\"112\":1}}],[\"如果第一层就使用\",{\"1\":{\"845\":1}}],[\"如果第二个分支一直不变\",{\"1\":{\"249\":1}}],[\"如果很不一样\",{\"1\":{\"837\":1}}],[\"如果真实是负类\",{\"1\":{\"832\":1}}],[\"如果真实是正类\",{\"1\":{\"832\":1}}],[\"如果一个事件概率是\",{\"1\":{\"829\":1}}],[\"如果一个变量变大时另一个变小\",{\"1\":{\"455\":1}}],[\"如果事件概率全一样\",{\"1\":{\"829\":1}}],[\"如果条件本身模糊\",{\"1\":{\"816\":1}}],[\"如果启用了稳定策略\",{\"1\":{\"815\":1}}],[\"如果启用了稳定训练策略\",{\"1\":{\"815\":1}}],[\"如果启用权重共享\",{\"1\":{\"814\":1}}],[\"如果输入了图像\",{\"1\":{\"815\":1}}],[\"如果输入是整数\",{\"1\":{\"801\":1}}],[\"如果概率最高的那个token是图像token\",{\"1\":{\"814\":1}}],[\"如果位置在文本段\",{\"1\":{\"814\":1}}],[\"如果位置在图像段\",{\"1\":{\"814\":1}}],[\"如果用\",{\"1\":{\"814\":1}}],[\"如果用余弦相似度\",{\"1\":{\"170\":1}}],[\"如果定义了\",{\"1\":{\"804\":1}}],[\"如果定义了图像预处理转换操作\",{\"1\":{\"316\":1}}],[\"如果最后一个batch数量不足\",{\"1\":{\"803\":1}}],[\"如果本次成功新增了遮挡patch\",{\"1\":{\"801\":1}}],[\"如果本地不存在\",{\"1\":{\"593\":1}}],[\"如果其中\",{\"1\":{\"762\":1}}],[\"如果变量是多值离散型的\",{\"1\":{\"738\":1}}],[\"如果没传入\",{\"1\":{\"821\":1}}],[\"如果没病\",{\"1\":{\"731\":1}}],[\"如果没有输入文本\",{\"1\":{\"820\":1}}],[\"如果没有新增遮挡\",{\"1\":{\"801\":1}}],[\"如果没有function作用于x上\",{\"1\":{\"656\":1}}],[\"如果没有任何归纳偏置\",{\"1\":{\"314\":1}}],[\"如果没有则下载\",{\"1\":{\"302\":1,\"304\":1}}],[\"如果没有这个字典\",{\"1\":{\"246\":1}}],[\"如果没有\",{\"1\":{\"107\":1}}],[\"如果没有提供激活函数层\",{\"1\":{\"323\":1}}],[\"如果没有提供归一化层\",{\"1\":{\"323\":1}}],[\"如果没有提供预训练的\",{\"1\":{\"169\":1}}],[\"如果没有提供\",{\"1\":{\"43\":1}}],[\"如果每个\",{\"1\":{\"727\":1}}],[\"如果左操作数未实现\",{\"1\":{\"690\":1}}],[\"如果正确答案没有出现在上下文中\",{\"1\":{\"616\":1}}],[\"如果值大于\",{\"1\":{\"615\":1}}],[\"如果值小于\",{\"1\":{\"615\":1}}],[\"如果两个事件是无关的\",{\"1\":{\"730\":1}}],[\"如果两个位置的相对距离相同\",{\"1\":{\"589\":1}}],[\"如果两个变量\",{\"1\":{\"455\":2}}],[\"如果训练时\",{\"1\":{\"588\":1}}],[\"如果训练过程中加入了噪声\",{\"1\":{\"112\":1}}],[\"如果遇到不存在于字典中的word\",{\"1\":{\"578\":1}}],[\"如果任一句子长度超过50\",{\"1\":{\"578\":1}}],[\"如果现在的任务是\",{\"1\":{\"575\":4}}],[\"如果现在有这么一句话\",{\"1\":{\"573\":1}}],[\"如果给的例子是比较简单的问题\",{\"1\":{\"503\":1}}],[\"如果给定随机选择的正例和负例\",{\"1\":{\"451\":1}}],[\"如果给定路径\",{\"1\":{\"169\":1}}],[\"如果矩阵\",{\"1\":{\"493\":1}}],[\"如果要用lora适配不同的场景\",{\"1\":{\"487\":1}}],[\"如果将大模型比做一个函数\",{\"1\":{\"485\":1}}],[\"如果数据是不能传递给第三方大模型服务的\",{\"1\":{\"482\":1}}],[\"如果数据集在类别之间大致平衡\",{\"1\":{\"452\":1}}],[\"如果数据集不平衡\",{\"1\":{\"443\":1}}],[\"如果已经包含\",{\"1\":{\"468\":1,\"469\":1}}],[\"如果费用大致相当\",{\"1\":{\"453\":1}}],[\"如果假正例成本较低\",{\"1\":{\"453\":1}}],[\"如果假正例\",{\"1\":{\"453\":1}}],[\"如果忽略所有其他阈值\",{\"1\":{\"450\":1}}],[\"如果您想评估模型在所有可能阈值下的质量\",{\"1\":{\"449\":1}}],[\"如果模型预测\",{\"1\":{\"616\":1}}],[\"如果模型最后一层没有\",{\"1\":{\"471\":1}}],[\"如果模型最后没有\",{\"1\":{\"468\":1,\"469\":1,\"470\":1}}],[\"如果模型的效果与随机猜测或抛硬币的效果完全一样\",{\"1\":{\"451\":1}}],[\"如果模型\",{\"1\":{\"443\":1}}],[\"如果模型过度关注这个困难的负样本\",{\"1\":{\"248\":1}}],[\"如果实际正例的总数与实际负例的总数不接近\",{\"1\":{\"442\":1}}],[\"如果原始数据是按行优先方式存储的\",{\"1\":{\"426\":1}}],[\"如果原始点有自己的特征\",{\"1\":{\"100\":1}}],[\"如果原始点有特征\",{\"1\":{\"100\":1}}],[\"如果提供了\",{\"1\":{\"398\":1}}],[\"如果指定\",{\"1\":{\"377\":1}}],[\"如果统计结果长度小于\",{\"1\":{\"377\":1}}],[\"如果张量不能整除块数\",{\"1\":{\"374\":1}}],[\"如果张量来源于\",{\"1\":{\"362\":1}}],[\"如果为\",{\"1\":{\"366\":2,\"372\":3,\"471\":1,\"473\":1}}],[\"如果类别数大于\",{\"1\":{\"323\":1}}],[\"如果该路径在采样的验证集样本中则存入验证集\",{\"1\":{\"316\":1}}],[\"如果该簇是空簇\",{\"1\":{\"170\":1}}],[\"如果未激活任何环境时使用\",{\"1\":{\"438\":1}}],[\"如果未指定最大宽高比\",{\"1\":{\"801\":1}}],[\"如果未指定\",{\"1\":{\"321\":2}}],[\"如果未指定则使用\",{\"1\":{\"272\":1}}],[\"如果未提供位置id\",{\"1\":{\"311\":1}}],[\"如果进一步采用convirt\",{\"1\":{\"305\":1}}],[\"如果在读取图片过程中出现错误\",{\"1\":{\"302\":1}}],[\"如果开启了\",{\"1\":{\"277\":1,\"820\":1}}],[\"如果存在一个常数\",{\"1\":{\"839\":1}}],[\"如果存在多个function先后作用在x上\",{\"1\":{\"656\":1}}],[\"如果存在function作用在x上\",{\"1\":{\"656\":1}}],[\"如果存在记录出现次数\",{\"1\":{\"477\":1}}],[\"如果存在\",{\"1\":{\"274\":1,\"804\":1}}],[\"如果传入了归一化层类\",{\"1\":{\"318\":1}}],[\"如果传入的是整数\",{\"1\":{\"318\":1}}],[\"如果传入一个归一化层类\",{\"1\":{\"318\":1}}],[\"如果传入一个整数\",{\"1\":{\"318\":2}}],[\"如果传入\",{\"1\":{\"272\":1}}],[\"如果有残差块\",{\"1\":{\"821\":1}}],[\"如果有病\",{\"1\":{\"731\":1}}],[\"如果有第i个元素\",{\"1\":{\"682\":1}}],[\"如果有一个能直接处理各式\",{\"1\":{\"571\":1}}],[\"如果有缓存\",{\"1\":{\"312\":1}}],[\"如果有缓存的key\",{\"1\":{\"312\":1}}],[\"如果有个类别\",{\"1\":{\"300\":1}}],[\"如果有\",{\"1\":{\"272\":1,\"821\":1}}],[\"如果有相对位置偏置\",{\"1\":{\"272\":1}}],[\"如果有位置编码\",{\"1\":{\"272\":1}}],[\"如果有额外特征\",{\"1\":{\"92\":1,\"96\":1}}],[\"如果有额外的点特征\",{\"1\":{\"92\":1}}],[\"如果你当年看完vq\",{\"1\":{\"883\":1}}],[\"如果你直接输入0\",{\"1\":{\"878\":1}}],[\"如果你把自己随机生成出来的向量输入给解码器\",{\"1\":{\"878\":1}}],[\"如果你在其他图像生成文献中见到了\",{\"1\":{\"847\":1}}],[\"如果你在多\",{\"1\":{\"257\":1}}],[\"如果你用\",{\"1\":{\"831\":1}}],[\"如果你能谈一堆事件\",{\"1\":{\"728\":1}}],[\"如果你能谈某个事件\",{\"1\":{\"728\":1}}],[\"如果你希望模型能\",{\"1\":{\"616\":1}}],[\"如果你希望装饰器\",{\"1\":{\"345\":1}}],[\"如果你设置\",{\"1\":{\"471\":2}}],[\"如果你的模型最后没有\",{\"1\":{\"467\":1}}],[\"如果你有\",{\"1\":{\"455\":1}}],[\"如果你有一张人脸的点云\",{\"1\":{\"112\":1}}],[\"如果你想删除某个环境\",{\"1\":{\"435\":1}}],[\"如果你想把一个\",{\"1\":{\"358\":1}}],[\"如果你接下来要对它们执行\",{\"1\":{\"360\":1}}],[\"如果选取的抽样部分过少\",{\"1\":{\"248\":1}}],[\"如果把向量的某一维稍微改动0\",{\"1\":{\"878\":1}}],[\"如果把\",{\"1\":{\"807\":1}}],[\"如果把这个损失函数\",{\"1\":{\"248\":1}}],[\"如果把对比学习的过程看成一个动态字典的过程\",{\"1\":{\"246\":1}}],[\"如果字典很小\",{\"1\":{\"246\":1}}],[\"如果采用\",{\"1\":{\"245\":1}}],[\"如果是原始图像\",{\"1\":{\"815\":1}}],[\"如果是自定义\",{\"1\":{\"802\":1}}],[\"如果是全参数微调\",{\"1\":{\"492\":1}}],[\"如果是解决自己日常生活\",{\"1\":{\"482\":1}}],[\"如果是\",{\"1\":{\"439\":2,\"492\":1,\"817\":1,\"839\":2}}],[\"如果是beam\",{\"1\":{\"313\":1}}],[\"如果是个体判别任务\",{\"1\":{\"243\":1}}],[\"如果是分割任务\",{\"1\":{\"109\":2}}],[\"如果是分类任务\",{\"1\":{\"109\":2}}],[\"如果我们能让\",{\"1\":{\"867\":1}}],[\"如果我们希望图3\",{\"1\":{\"866\":1}}],[\"如果我们希望强化高注意力权重区域\",{\"1\":{\"463\":1}}],[\"如果我们直接\",{\"1\":{\"853\":1}}],[\"如果我们直接使用类别标签作为文本描述\",{\"1\":{\"301\":1}}],[\"如果我们抛硬币100次均出现正面\",{\"1\":{\"825\":1}}],[\"如果我们从\",{\"1\":{\"753\":1}}],[\"如果我们不对这两个梯度求和\",{\"1\":{\"684\":1}}],[\"如果我们不进行累加\",{\"1\":{\"684\":1}}],[\"如果我们用多种不同的方法去求解\",{\"1\":{\"502\":1}}],[\"如果我们画出一个二维正态分布\",{\"1\":{\"455\":1}}],[\"如果我们将标准答案作为列\",{\"1\":{\"442\":1}}],[\"如果我们做如下切片操作\",{\"1\":{\"425\":1}}],[\"如果我们有一个没有标注的数据集\",{\"1\":{\"243\":1}}],[\"如果我本来就有特征\",{\"1\":{\"100\":1}}],[\"如果所有样本映射到相同的表示\",{\"1\":{\"178\":1}}],[\"如果需要\",{\"1\":{\"170\":1,\"272\":1,\"490\":1}}],[\"如果向量的范数变化剧烈\",{\"1\":{\"170\":1}}],[\"如果直接把它们的交叉熵损失简单相加\",{\"1\":{\"815\":1}}],[\"如果直接把残差相加\",{\"1\":{\"272\":1}}],[\"如果直接采用像素级自编码\",{\"1\":{\"772\":1}}],[\"如果直接给每个位置都分配一个独立参数\",{\"1\":{\"591\":1}}],[\"如果直接为每个距离学习偏置\",{\"1\":{\"591\":1}}],[\"如果直接计算欧氏距离\",{\"1\":{\"170\":1}}],[\"如果直接作为变换矩阵\",{\"1\":{\"107\":1}}],[\"如果二者参数共享\",{\"1\":{\"134\":1}}],[\"如果共享\",{\"1\":{\"134\":1}}],[\"如果完全不共享参数\",{\"1\":{\"134\":1}}],[\"如果对于任意排列\",{\"1\":{\"115\":1}}],[\"如果点太少\",{\"1\":{\"112\":1}}],[\"如果不要求计算损失\",{\"1\":{\"815\":1}}],[\"如果不需要返回\",{\"1\":{\"821\":1}}],[\"如果不需要重建图像\",{\"1\":{\"794\":1,\"821\":1}}],[\"如果不需要\",{\"1\":{\"794\":1}}],[\"如果不指定就保持输入\",{\"1\":{\"373\":1}}],[\"如果不是则抛出异常\",{\"1\":{\"316\":1}}],[\"如果不提前了解一下库的基本用法\",{\"1\":{\"271\":1}}],[\"如果不加处理\",{\"1\":{\"107\":1}}],[\"如果不够就重复最近的点来填充\",{\"1\":{\"92\":1}}],[\"如果只有1个下采样点\",{\"1\":{\"100\":1}}],[\"如果只用\",{\"1\":{\"76\":1}}],[\"如果\",{\"1\":{\"92\":1,\"112\":2,\"186\":1,\"244\":1,\"248\":2,\"272\":1,\"379\":2,\"473\":2,\"581\":2,\"590\":1,\"591\":1,\"614\":1,\"730\":1,\"737\":1,\"738\":1,\"742\":1,\"746\":1,\"758\":2,\"803\":1,\"815\":2,\"830\":2,\"835\":1,\"837\":1,\"867\":1,\"868\":1,\"871\":3,\"873\":1}}],[\"如果某个维度的数值范围很大\",{\"1\":{\"459\":1}}],[\"如果某个查询点附近的点太少\",{\"1\":{\"92\":1}}],[\"如果某个点到新中心点的距离比之前记录的\",{\"1\":{\"92\":1}}],[\"如果包含强度值\",{\"1\":{\"83\":1}}],[\"如果当前待预测token位置属于离散视觉词\",{\"1\":{\"814\":1}}],[\"如果当前待预测token位置属于文本词\",{\"1\":{\"814\":1}}],[\"如果当前环境支持分布式训练并已初始化\",{\"1\":{\"170\":1}}],[\"如果当前\",{\"1\":{\"82\":1}}],[\"如果当前样本没有正类\",{\"1\":{\"82\":1}}],[\"如果当前是训练模式\",{\"1\":{\"68\":1}}],[\"如果当前物体类别在排序后的字典中\",{\"1\":{\"68\":1}}],[\"如果当前物体类别不在排序后的字典中\",{\"1\":{\"68\":1}}],[\"如果使用确定映射\",{\"1\":{\"865\":1}}],[\"如果使用了\",{\"1\":{\"815\":1}}],[\"如果使用多头注意力\",{\"1\":{\"415\":1}}],[\"如果使用余弦相似度\",{\"1\":{\"170\":1}}],[\"如果使用\",{\"1\":{\"40\":1,\"143\":1,\"802\":2,\"821\":1}}],[\"如54\",{\"1\":{\"49\":1,\"51\":1}}],[\"如5\",{\"1\":{\"7\":1}}],[\"如图7所示\",{\"1\":{\"183\":1}}],[\"如图6所示\",{\"1\":{\"182\":1}}],[\"如图\",{\"1\":{\"167\":1,\"199\":2,\"262\":1,\"528\":2,\"536\":1,\"759\":1,\"766\":1,\"767\":1}}],[\"如图2\",{\"1\":{\"49\":1,\"52\":1}}],[\"如图2所示\",{\"1\":{\"8\":1,\"189\":1,\"866\":1}}],[\"如图4所示\",{\"1\":{\"23\":1}}],[\"如图3所示\",{\"1\":{\"54\":1,\"196\":1,\"866\":1}}],[\"如图3\",{\"1\":{\"17\":1,\"19\":1}}],[\"如图像分类与语义分割\",{\"1\":{\"790\":1}}],[\"如图像分类\",{\"1\":{\"767\":1}}],[\"如图像转置\",{\"1\":{\"359\":1}}],[\"如图像重建\",{\"1\":{\"248\":1}}],[\"如图像描述\",{\"1\":{\"197\":1}}],[\"如图像或点云特征\",{\"1\":{\"43\":1}}],[\"如图像\",{\"1\":{\"7\":1,\"43\":1}}],[\"如图1c所示\",{\"1\":{\"189\":1}}],[\"如图15所示\",{\"1\":{\"56\":1}}],[\"如图1所示\",{\"1\":{\"7\":1,\"196\":1,\"548\":1}}],[\"如图1\",{\"1\":{\"6\":1,\"49\":1}}],[\"如\",{\"1\":{\"6\":3,\"23\":1,\"24\":1,\"28\":5,\"29\":1,\"32\":4,\"45\":1,\"46\":3,\"49\":1,\"63\":1,\"67\":2,\"71\":1,\"78\":1,\"82\":1,\"100\":2,\"112\":3,\"115\":1,\"126\":1,\"128\":1,\"132\":1,\"147\":1,\"157\":1,\"159\":1,\"160\":2,\"163\":1,\"165\":1,\"167\":1,\"170\":1,\"173\":2,\"186\":1,\"198\":2,\"199\":1,\"201\":1,\"203\":1,\"204\":1,\"215\":2,\"232\":5,\"234\":3,\"235\":2,\"239\":1,\"260\":2,\"261\":3,\"280\":1,\"290\":1,\"312\":2,\"317\":1,\"321\":1,\"361\":1,\"364\":1,\"385\":5,\"387\":1,\"398\":2,\"399\":3,\"427\":1,\"438\":2,\"455\":1,\"470\":5,\"476\":1,\"492\":1,\"495\":2,\"506\":1,\"521\":3,\"522\":1,\"531\":4,\"536\":1,\"538\":1,\"539\":5,\"547\":1,\"559\":1,\"560\":2,\"561\":1,\"591\":1,\"690\":1,\"696\":1,\"700\":1,\"778\":1,\"785\":1,\"789\":1,\"790\":1,\"793\":1,\"801\":3,\"802\":2,\"803\":1,\"806\":1,\"811\":1,\"816\":1,\"820\":1,\"846\":1,\"872\":1}}],[\"如int\",{\"1\":{\"690\":1}}],[\"如internvit\",{\"1\":{\"220\":1,\"225\":1}}],[\"如internvl\",{\"1\":{\"6\":1,\"7\":1}}],[\"如imagenet\",{\"1\":{\"191\":1,\"305\":1,\"382\":1}}],[\"如iagnet\",{\"1\":{\"6\":1}}],[\"如手柄的抓握属性\",{\"1\":{\"6\":1}}],[\"如将\",{\"1\":{\"6\":1,\"7\":1}}],[\"现存问题\",{\"1\":{\"806\":1,\"866\":1}}],[\"现已更新到\",{\"1\":{\"704\":1}}],[\"现实中的神经网络操作往往不仅仅接受一个输入\",{\"1\":{\"681\":1}}],[\"现在维度一致了\",{\"1\":{\"885\":1}}],[\"现在倒好\",{\"1\":{\"878\":1}}],[\"现在所有的期望都关于不依赖模型参数的分布\",{\"1\":{\"868\":1}}],[\"现在来看公式\",{\"1\":{\"868\":1}}],[\"现在就变成了两个多元高斯分布之间的\",{\"1\":{\"868\":1}}],[\"现在剩下的问题是如何优化上述积分\",{\"1\":{\"866\":1}}],[\"现在采样的是\",{\"1\":{\"853\":1}}],[\"现在\",{\"1\":{\"846\":1,\"882\":1}}],[\"现在我们重新定义抽红球为\",{\"1\":{\"741\":1}}],[\"现在我们问\",{\"1\":{\"727\":1}}],[\"现在我们按\",{\"1\":{\"426\":1}}],[\"现在假设使用\",{\"1\":{\"575\":1}}],[\"现在的大模型要解决的问题\",{\"1\":{\"481\":1}}],[\"现在看一个典型的装饰器例子\",{\"1\":{\"341\":1}}],[\"现代深度学习的延伸\",{\"1\":{\"385\":1}}],[\"现状问题\",{\"1\":{\"122\":1}}],[\"现有的vlp模型的text\",{\"1\":{\"283\":1}}],[\"现有的视觉语言模型的三种结构类别\",{\"1\":{\"282\":1}}],[\"现有的视觉\",{\"1\":{\"189\":1}}],[\"现有两类主流架构各有优缺点\",{\"1\":{\"260\":1}}],[\"现有模型通常通过图文匹配\",{\"1\":{\"260\":1}}],[\"现有\",{\"1\":{\"223\":1}}],[\"现有工作表明\",{\"1\":{\"194\":1}}],[\"现有重建目标可以分为三类\",{\"1\":{\"165\":1}}],[\"现有做法\",{\"1\":{\"123\":1,\"124\":1}}],[\"现有研究通常仅联合训练少量任务\",{\"1\":{\"520\":1}}],[\"现有研究可分为三类\",{\"1\":{\"51\":1}}],[\"现有研究主要分为两类\",{\"1\":{\"49\":1}}],[\"现有研究主要从2d数据\",{\"1\":{\"7\":1}}],[\"现有方法的局限性\",{\"1\":{\"527\":1}}],[\"现有方法仍需要针对每个任务进行大规模监督数据微调\",{\"1\":{\"527\":1}}],[\"现有方法依赖两类对齐策略\",{\"1\":{\"52\":1}}],[\"现有方法依赖数据对齐\",{\"1\":{\"7\":1}}],[\"现有方法\",{\"1\":{\"6\":1}}],[\"现就读于电子科技大学\",{\"1\":{\"3\":1}}],[\"现就读于四川大学\",{\"1\":{\"2\":1}}],[\"实时对话\",{\"1\":{\"704\":1}}],[\"实时语音和视频对话\",{\"1\":{\"704\":1}}],[\"实体嵌入\",{\"1\":{\"568\":1}}],[\"实质是一种\",{\"1\":{\"531\":1}}],[\"实用工具\",{\"1\":{\"395\":1}}],[\"实线为\",{\"1\":{\"387\":1}}],[\"实例说明\",{\"1\":{\"385\":1}}],[\"实例化数据增强类\",{\"1\":{\"802\":1}}],[\"实例化验证数据集\",{\"1\":{\"317\":1}}],[\"实例化训练数据集\",{\"1\":{\"317\":1}}],[\"实例分类\",{\"1\":{\"175\":1}}],[\"实际应用中\",{\"1\":{\"864\":1}}],[\"实际效果\",{\"1\":{\"816\":1}}],[\"实际中用更大值鼓励更均匀的码本利用\",{\"1\":{\"807\":1}}],[\"实际任务训练\",{\"1\":{\"700\":1}}],[\"实际此处的函数放缩因子也称为函数的导数\",{\"1\":{\"656\":1}}],[\"实际实现过程中\",{\"1\":{\"578\":1}}],[\"实际操作如下\",{\"1\":{\"572\":1}}],[\"实际对齐的是训练流程中的多重人为偏好叠加\",{\"1\":{\"539\":1}}],[\"实际负例\",{\"1\":{\"442\":1}}],[\"实际正例\",{\"1\":{\"442\":1}}],[\"实际创建一个新的数据缓冲区\",{\"1\":{\"426\":1}}],[\"实际携带信息\",{\"1\":{\"410\":1}}],[\"实际复制\",{\"1\":{\"364\":1}}],[\"实际采集的点云常有遮挡\",{\"1\":{\"104\":1}}],[\"实际上梯度下降法并不擅长处理rosenbrock这种类型的函数\",{\"1\":{\"697\":1}}],[\"实际上也体现了对\",{\"1\":{\"536\":1}}],[\"实际上并没有复制内存中的任何数据值\",{\"1\":{\"425\":1}}],[\"实际上没用\",{\"1\":{\"423\":1}}],[\"实际上没有局部的概念\",{\"1\":{\"86\":1}}],[\"实际上变成了\",{\"1\":{\"346\":1}}],[\"实际上\",{\"1\":{\"305\":1,\"775\":1,\"867\":1,\"883\":1}}],[\"实际上是一个很薄的壳层或环带\",{\"1\":{\"753\":1}}],[\"实际上是一个动态生成的卷积核\",{\"1\":{\"76\":1}}],[\"实际上是用一个固定大小的全局特征去\",{\"1\":{\"112\":1}}],[\"实验中我们使用\",{\"1\":{\"774\":1}}],[\"实验中统一设为\",{\"1\":{\"157\":1}}],[\"实验在三大基准任务上进行\",{\"1\":{\"561\":1}}],[\"实验步骤\",{\"0\":{\"561\":1}}],[\"实验覆盖了翻译\",{\"1\":{\"527\":1}}],[\"实验表明\",{\"1\":{\"526\":1,\"559\":1,\"562\":2,\"765\":1,\"766\":1}}],[\"实验结论\",{\"1\":{\"522\":1}}],[\"实验结果如下表所示\",{\"1\":{\"320\":1}}],[\"实验结果显示\",{\"1\":{\"268\":1}}],[\"实验结果\",{\"1\":{\"268\":3}}],[\"实验结果与贡献\",{\"1\":{\"260\":1}}],[\"实验结果与表现\",{\"1\":{\"120\":1}}],[\"实验结果表明\",{\"1\":{\"48\":1,\"182\":1,\"215\":1,\"268\":1,\"546\":1,\"558\":1,\"562\":1}}],[\"实验的关键发现是\",{\"1\":{\"522\":1}}],[\"实验设计与模型配置\",{\"1\":{\"522\":1}}],[\"实验设置与模型规模\",{\"1\":{\"521\":1}}],[\"实验评估\",{\"1\":{\"474\":1}}],[\"实验采用的是花蕊数据集\",{\"1\":{\"316\":1}}],[\"实验采用以下评估指标评估\",{\"1\":{\"22\":1}}],[\"实验全流程管理框架\",{\"1\":{\"273\":1}}],[\"实验管理框架\",{\"1\":{\"271\":1}}],[\"实验发现\",{\"1\":{\"179\":1,\"197\":1}}],[\"实验观察\",{\"1\":{\"112\":1}}],[\"实验验证\",{\"1\":{\"105\":1,\"112\":1}}],[\"实验证明动态掩码效果更优\",{\"1\":{\"560\":1}}],[\"实验证明\",{\"1\":{\"105\":1,\"120\":1,\"229\":1}}],[\"实验证明了great在开放词汇场景下的有效性和优越性\",{\"1\":{\"5\":1}}],[\"实验\",{\"0\":{\"21\":1,\"200\":1,\"226\":1,\"513\":1,\"522\":1,\"779\":1},\"1\":{\"183\":1,\"237\":1,\"727\":1}}],[\"实现如下所示\",{\"1\":{\"881\":1}}],[\"实现如前所述\",{\"1\":{\"676\":1}}],[\"实现vae\",{\"0\":{\"851\":1}}],[\"实现pixelcnn时\",{\"1\":{\"847\":1}}],[\"实现端到端的梯度传播\",{\"1\":{\"795\":1}}],[\"实现从用户输入到数据库再到大模型最后输出的整体架构连接\",{\"1\":{\"717\":1}}],[\"实现从用户输入到应用输出的全流程贯通\",{\"1\":{\"717\":1}}],[\"实现更多样化的应用\",{\"1\":{\"705\":1}}],[\"实现全面的多模态交互\",{\"1\":{\"704\":1}}],[\"实现网页浏览\",{\"1\":{\"704\":1}}],[\"实现可复用的层\",{\"1\":{\"700\":1}}],[\"实现后序遍历\",{\"1\":{\"696\":1}}],[\"实现计算图的可视化渲染\",{\"1\":{\"695\":1}}],[\"实现a\",{\"1\":{\"690\":1}}],[\"实现using\",{\"1\":{\"688\":1}}],[\"实现变分自编码器\",{\"1\":{\"850\":1}}],[\"实现变量导数的重置\",{\"1\":{\"683\":1}}],[\"实现变换不变性\",{\"1\":{\"105\":1}}],[\"实现真正意义上的自动反向传播\",{\"1\":{\"680\":1}}],[\"实现bert\",{\"1\":{\"570\":1}}],[\"实现高效训练\",{\"1\":{\"548\":1}}],[\"实现讲解\",{\"1\":{\"544\":1}}],[\"实现任务统一与跨任务迁移\",{\"1\":{\"531\":1}}],[\"实现显著的性能提升确实是可能的\",{\"1\":{\"517\":1}}],[\"实现虚拟复制\",{\"1\":{\"427\":1}}],[\"实现虚拟扩展\",{\"1\":{\"427\":1}}],[\"实现数据虚拟扩展\",{\"1\":{\"427\":1}}],[\"实现步骤如下\",{\"1\":{\"387\":1}}],[\"实现精确的像素级对齐\",{\"1\":{\"387\":1}}],[\"实现精准的3d功能定位\",{\"1\":{\"5\":1}}],[\"实现复杂功能\",{\"1\":{\"385\":1}}],[\"实现分段逼近\",{\"1\":{\"385\":1}}],[\"实现zero\",{\"1\":{\"300\":1,\"308\":1}}],[\"实现信息融合\",{\"1\":{\"291\":1}}],[\"实现类\",{\"1\":{\"274\":1}}],[\"实现类似人类的类比推理能力\",{\"1\":{\"32\":1}}],[\"实现了基础的计算图结构与反向传播流程\",{\"1\":{\"680\":1}}],[\"实现了数值微分作为梯度检验工具\",{\"1\":{\"678\":1}}],[\"实现了变量和函数的基本结构\",{\"1\":{\"678\":1}}],[\"实现了比多项式逼近更高效的函数近似\",{\"1\":{\"385\":1}}],[\"实现了比基于区域特征的模型快数十倍\",{\"1\":{\"280\":1}}],[\"实现了图像与语言之间的初步语义对齐\",{\"1\":{\"234\":1}}],[\"实现了在图像分类\",{\"1\":{\"206\":1}}],[\"实现主要包括以下三个关键阶段\",{\"1\":{\"232\":1}}],[\"实现多元函数反向传播\",{\"1\":{\"693\":1}}],[\"实现多模态能力的协同提升\",{\"1\":{\"216\":1}}],[\"实现多任务预训练与灵活迁移\",{\"1\":{\"120\":1}}],[\"实现向量量化\",{\"1\":{\"170\":1}}],[\"实现图文信息的深层交互\",{\"1\":{\"152\":1}}],[\"实现论文3\",{\"1\":{\"142\":1}}],[\"实现论文中提出的图像\",{\"1\":{\"142\":1}}],[\"实现点集顺序不变性\",{\"1\":{\"103\":1}}],[\"实现方程\",{\"1\":{\"773\":1}}],[\"实现方式\",{\"1\":{\"98\":1}}],[\"实现方法\",{\"1\":{\"91\":1}}],[\"实现跨模态信息的充分交互\",{\"1\":{\"73\":1}}],[\"实现语言引导下的跨模态融合\",{\"1\":{\"70\":1}}],[\"实现无先验对齐\",{\"1\":{\"56\":1}}],[\"实现\",{\"0\":{\"570\":1,\"850\":1,\"858\":1},\"1\":{\"46\":1,\"78\":1,\"131\":1,\"152\":1,\"292\":1,\"578\":1,\"689\":1,\"695\":1,\"792\":1}}],[\"实现对图像语义信息的高效编码与预训练\",{\"1\":{\"167\":1}}],[\"实现对称性\",{\"1\":{\"105\":1}}],[\"实现对\",{\"1\":{\"26\":1}}],[\"实现细节\",{\"0\":{\"179\":1,\"199\":1,\"879\":1},\"1\":{\"22\":1,\"179\":1}}],[\"实现开放词汇功能定位\",{\"1\":{\"7\":1}}],[\"策略与稳定的训练流程\",{\"1\":{\"790\":1}}],[\"策略在\",{\"1\":{\"778\":1}}],[\"策略预训练轻量级查询\",{\"1\":{\"308\":1}}],[\"策略对交互图像进行推理\",{\"1\":{\"8\":1}}],[\"策略\",{\"0\":{\"801\":1},\"1\":{\"5\":1,\"96\":1,\"149\":1,\"163\":1,\"178\":1,\"772\":1,\"814\":1}}],[\"mdl\",{\"1\":{\"870\":1,\"872\":1}}],[\"mps\",{\"1\":{\"848\":2}}],[\"mvn\",{\"1\":{\"750\":1,\"751\":1}}],[\"mvp\",{\"1\":{\"717\":1}}],[\"mvcnn\",{\"1\":{\"112\":3}}],[\"mcmc\",{\"1\":{\"864\":1,\"866\":1}}],[\"mcp\",{\"1\":{\"704\":1}}],[\"mccann\",{\"1\":{\"521\":1}}],[\"mnist\",{\"1\":{\"700\":1,\"840\":3,\"847\":1,\"848\":1,\"850\":1,\"855\":1,\"858\":1,\"885\":1}}],[\"mnli\",{\"1\":{\"561\":1,\"564\":1,\"566\":2}}],[\"mkdir\",{\"1\":{\"696\":1}}],[\"mkl\",{\"1\":{\"438\":1}}],[\"mrpc\",{\"1\":{\"515\":1}}],[\"mrg策略在处理每个局部区域时\",{\"1\":{\"97\":1}}],[\"mrg通过结合来自不同分辨率的特征来实现效率和适应性的平衡\",{\"1\":{\"97\":1}}],[\"mrg为一种低成本的替代方案\",{\"1\":{\"97\":1}}],[\"mrg\",{\"1\":{\"94\":1}}],[\"mmlu\",{\"1\":{\"549\":2,\"550\":1}}],[\"mm1\",{\"1\":{\"218\":1}}],[\"mme\",{\"1\":{\"198\":1,\"203\":2,\"204\":2}}],[\"ms\",{\"1\":{\"806\":2,\"810\":4}}],[\"msqrt\",{\"1\":{\"584\":1}}],[\"msa\",{\"1\":{\"264\":1}}],[\"mseloss\",{\"1\":{\"603\":1,\"797\":1}}],[\"mse\",{\"1\":{\"170\":1,\"793\":3,\"797\":4,\"821\":4,\"885\":4}}],[\"msg方法虽然有效\",{\"1\":{\"97\":1}}],[\"msg相当于并联了多个hierarchical\",{\"1\":{\"96\":1}}],[\"msg的关键优点在于它通过在训练期间的随机输入丢弃\",{\"1\":{\"96\":1}}],[\"msg通过应用不同尺度的分组层\",{\"1\":{\"95\":1}}],[\"msg\",{\"1\":{\"94\":1,\"96\":3}}],[\"msmvpam\",{\"1\":{\"4\":1}}],[\"myenv\",{\"1\":{\"431\":3,\"432\":1,\"434\":2,\"435\":1}}],[\"mymodel\",{\"1\":{\"396\":1}}],[\"mydecorator\",{\"1\":{\"351\":2}}],[\"mydataset\",{\"1\":{\"316\":1,\"317\":2}}],[\"myservice\",{\"1\":{\"348\":2}}],[\"myclass\",{\"1\":{\"347\":1}}],[\"my\",{\"1\":{\"83\":2,\"341\":3,\"343\":4,\"344\":2,\"346\":5,\"396\":1,\"572\":4}}],[\"m\",{\"1\":{\"74\":1,\"83\":2,\"145\":34,\"147\":29,\"160\":8,\"161\":26,\"163\":4,\"186\":3,\"246\":1,\"252\":1,\"254\":4,\"256\":2,\"324\":1,\"419\":5,\"426\":4,\"564\":1,\"566\":1,\"590\":3,\"630\":3,\"837\":1}}],[\"mtdatamodule\",{\"1\":{\"274\":2}}],[\"mt\",{\"1\":{\"41\":2,\"45\":6,\"46\":3,\"59\":12}}],[\"mle\",{\"0\":{\"825\":1},\"1\":{\"825\":2,\"826\":3}}],[\"mla\",{\"1\":{\"704\":1}}],[\"mlfoundations\",{\"1\":{\"277\":1}}],[\"mlm任务掩码策略的方法\",{\"1\":{\"578\":1}}],[\"mlm的目标是通过文本的上下文信息去预测masked的文本tokens\",{\"1\":{\"285\":1}}],[\"mlm=true\",{\"1\":{\"274\":1}}],[\"mlm\",{\"0\":{\"155\":1,\"163\":1},\"1\":{\"127\":1,\"153\":1,\"155\":1,\"157\":3,\"159\":2,\"160\":3,\"163\":12,\"247\":1,\"268\":1,\"274\":12,\"275\":4,\"276\":40,\"277\":9,\"285\":1,\"560\":1,\"562\":1,\"579\":1,\"580\":6,\"581\":2,\"582\":1,\"772\":1}}],[\"mlp投影层\",{\"1\":{\"222\":1}}],[\"mlp比率12800的稳定配置\",{\"1\":{\"197\":1}}],[\"mlp映射\",{\"1\":{\"74\":1}}],[\"mlpmixerlayer\",{\"1\":{\"73\":1}}],[\"mlp₂\",{\"1\":{\"73\":1}}],[\"mlp₁\",{\"1\":{\"73\":1}}],[\"mlp\",{\"0\":{\"73\":1,\"323\":1},\"1\":{\"40\":1,\"41\":3,\"46\":2,\"73\":10,\"75\":1,\"76\":1,\"92\":8,\"96\":3,\"98\":5,\"100\":9,\"101\":1,\"105\":1,\"110\":2,\"160\":2,\"178\":1,\"198\":2,\"204\":3,\"210\":2,\"222\":1,\"252\":1,\"254\":1,\"272\":30,\"292\":2,\"320\":1,\"321\":14,\"323\":4,\"324\":1,\"544\":2}}],[\"mlp=\",{\"1\":{\"35\":3,\"46\":3,\"59\":3,\"93\":3,\"101\":8}}],[\"mllm\",{\"0\":{\"10\":1},\"1\":{\"24\":1,\"28\":1,\"215\":1,\"223\":1}}],[\"mllms\",{\"1\":{\"5\":1,\"7\":2,\"216\":1,\"220\":1}}],[\"mu\",{\"1\":{\"853\":9,\"854\":2,\"856\":2,\"859\":7,\"860\":2}}],[\"must\",{\"1\":{\"275\":1,\"278\":1,\"578\":1,\"815\":1,\"817\":1,\"821\":3,\"822\":1}}],[\"mul等运算符函数\",{\"1\":{\"691\":1}}],[\"mul等\",{\"1\":{\"691\":1}}],[\"mul\",{\"1\":{\"78\":4,\"186\":1,\"690\":12,\"691\":3,\"692\":3,\"696\":1}}],[\"multivariate\",{\"0\":{\"751\":1},\"1\":{\"750\":2}}],[\"multirc等任务上显著低于fine\",{\"1\":{\"529\":1}}],[\"multitask\",{\"1\":{\"518\":1,\"519\":1,\"520\":1}}],[\"multinli\",{\"1\":{\"506\":1,\"507\":1}}],[\"multinomial\",{\"0\":{\"738\":1},\"1\":{\"145\":2,\"147\":2,\"162\":2,\"278\":2,\"311\":2,\"738\":2,\"819\":1,\"848\":1,\"886\":1}}],[\"multiplication\",{\"1\":{\"730\":1}}],[\"multiply\",{\"1\":{\"322\":2,\"345\":2}}],[\"multiple\",{\"1\":{\"25\":3,\"98\":1,\"618\":1}}],[\"multiwaytransformer\",{\"1\":{\"272\":7}}],[\"multicropwrapper\",{\"1\":{\"186\":5}}],[\"multimodal\",{\"0\":{\"126\":1,\"272\":1,\"789\":1},\"1\":{\"120\":1,\"138\":1,\"214\":2,\"235\":2,\"289\":1,\"290\":1,\"291\":1,\"295\":1,\"312\":2}}],[\"multiheadedattention\",{\"1\":{\"632\":2}}],[\"multihead\",{\"1\":{\"76\":1}}],[\"multi\",{\"0\":{\"9\":1,\"28\":1,\"95\":1,\"97\":1,\"574\":1},\"1\":{\"26\":1,\"40\":2,\"41\":2,\"43\":5,\"46\":5,\"62\":1,\"94\":2,\"96\":1,\"103\":1,\"114\":1,\"145\":1,\"163\":1,\"173\":1,\"178\":1,\"179\":1,\"184\":3,\"186\":5,\"198\":1,\"321\":1,\"415\":1,\"521\":1,\"622\":1,\"704\":1}}],[\"mug\",{\"1\":{\"29\":1,\"58\":1,\"63\":1,\"67\":1,\"68\":1,\"70\":1}}],[\"might\",{\"1\":{\"605\":1}}],[\"mit\",{\"1\":{\"548\":1}}],[\"misinformation\",{\"0\":{\"551\":1}}],[\"mishra\",{\"1\":{\"536\":1}}],[\"misalignment\",{\"1\":{\"387\":1}}],[\"missing\",{\"1\":{\"104\":1}}],[\"million\",{\"1\":{\"324\":1}}],[\"mi\",{\"1\":{\"282\":1}}],[\"mim\",{\"1\":{\"165\":4,\"765\":1,\"766\":2,\"767\":2,\"772\":2,\"773\":1,\"784\":1}}],[\"mincount\",{\"1\":{\"476\":4,\"478\":5}}],[\"min=a\",{\"1\":{\"473\":1}}],[\"min=1e\",{\"1\":{\"80\":1}}],[\"minlength=5\",{\"1\":{\"377\":1}}],[\"minlength=0\",{\"1\":{\"377\":1}}],[\"minlength\",{\"1\":{\"170\":1,\"377\":2}}],[\"min\",{\"1\":{\"115\":1,\"143\":3,\"145\":1,\"147\":2,\"159\":1,\"170\":2,\"186\":2,\"302\":1,\"304\":1,\"313\":2,\"579\":5,\"591\":1,\"615\":4,\"801\":11,\"802\":2}}],[\"minist\",{\"0\":{\"848\":1},\"1\":{\"848\":1}}],[\"minimum\",{\"1\":{\"478\":2,\"697\":1,\"870\":1,\"872\":1}}],[\"mining\",{\"1\":{\"268\":2}}],[\"minibatch\",{\"1\":{\"249\":1,\"299\":2}}],[\"minigpt\",{\"1\":{\"193\":1,\"219\":1,\"295\":1}}],[\"mini\",{\"1\":{\"92\":1,\"93\":3,\"156\":1,\"704\":8}}],[\"miou\",{\"1\":{\"75\":1,\"82\":11,\"201\":1}}],[\"mixup\",{\"1\":{\"395\":1}}],[\"mixed\",{\"1\":{\"162\":2,\"293\":2,\"312\":2,\"605\":6}}],[\"mixer\",{\"0\":{\"73\":1},\"1\":{\"73\":11,\"75\":2,\"321\":1}}],[\"mixture\",{\"0\":{\"126\":1,\"272\":1},\"1\":{\"120\":1,\"138\":1,\"259\":2,\"260\":1,\"264\":2,\"270\":1,\"843\":1}}],[\"mix\",{\"1\":{\"73\":6,\"210\":1}}],[\"mixing阶段\",{\"1\":{\"75\":1}}],[\"mixing\",{\"0\":{\"73\":1},\"1\":{\"71\":1,\"73\":4,\"75\":3}}],[\"microsoft\",{\"1\":{\"164\":1,\"171\":1,\"259\":1,\"270\":1,\"515\":1,\"764\":1}}],[\"microwave\",{\"1\":{\"29\":1,\"58\":1,\"67\":1,\"68\":1}}],[\"microphone\",{\"1\":{\"29\":1}}],[\"middle\",{\"1\":{\"28\":1}}],[\"monte\",{\"1\":{\"866\":1}}],[\"moe\",{\"1\":{\"704\":2}}],[\"mobilenet\",{\"1\":{\"395\":1}}],[\"most\",{\"0\":{\"503\":1},\"1\":{\"303\":10,\"304\":10,\"401\":2,\"503\":2}}],[\"mome\",{\"0\":{\"264\":1,\"272\":1},\"1\":{\"260\":3,\"261\":1,\"262\":2,\"263\":1,\"264\":4,\"266\":1,\"268\":8,\"269\":3,\"272\":1}}],[\"momentum=args\",{\"1\":{\"252\":1}}],[\"momentum=0\",{\"1\":{\"145\":1,\"147\":1,\"186\":1}}],[\"momentum\",{\"0\":{\"157\":1,\"244\":1,\"256\":1},\"1\":{\"145\":4,\"147\":4,\"148\":2,\"149\":1,\"150\":1,\"157\":1,\"160\":2,\"161\":2,\"163\":3,\"173\":1,\"175\":1,\"186\":12,\"240\":2,\"252\":1,\"254\":1,\"255\":1,\"256\":2,\"700\":1,\"840\":2}}],[\"more\",{\"1\":{\"255\":1,\"541\":19}}],[\"moving\",{\"1\":{\"157\":1,\"170\":1}}],[\"move\",{\"1\":{\"29\":1,\"58\":1,\"62\":1,\"67\":1,\"68\":1,\"83\":2,\"257\":1}}],[\"moco证明了一点\",{\"1\":{\"241\":1}}],[\"moco作为一个无监督的表征学习工作\",{\"1\":{\"241\":1}}],[\"moco是视觉领域使用对比学习一个里程碑的工作\",{\"1\":{\"241\":1}}],[\"moco\",{\"0\":{\"240\":1},\"1\":{\"145\":2,\"154\":1,\"240\":1,\"244\":2,\"245\":4,\"246\":1,\"247\":2,\"248\":1,\"249\":1,\"252\":9,\"254\":3,\"784\":2}}],[\"motivation\",{\"0\":{\"281\":1}}],[\"motions\",{\"1\":{\"116\":1}}],[\"motorcycle\",{\"1\":{\"29\":1,\"300\":1}}],[\"mop\",{\"1\":{\"29\":1}}],[\"modifications\",{\"1\":{\"843\":1}}],[\"mod\",{\"1\":{\"149\":1}}],[\"mode=none\",{\"1\":{\"291\":1}}],[\"mode=mode\",{\"1\":{\"163\":1,\"289\":1,\"290\":1,\"295\":1}}],[\"mode=\",{\"1\":{\"145\":2,\"147\":2,\"161\":2,\"163\":1,\"289\":1,\"290\":1,\"295\":1,\"388\":1,\"463\":2}}],[\"mode=false\",{\"1\":{\"40\":1}}],[\"mode\",{\"1\":{\"40\":2,\"146\":1,\"162\":2,\"291\":1,\"316\":2,\"388\":1,\"746\":1}}],[\"model是decoder输出的大小\",{\"1\":{\"624\":1}}],[\"models\",{\"1\":{\"187\":1,\"214\":2,\"252\":1,\"287\":1,\"327\":1,\"395\":1,\"487\":1,\"489\":1,\"501\":1,\"502\":1,\"503\":1,\"518\":1,\"519\":1,\"525\":1,\"528\":1,\"533\":1,\"536\":1,\"537\":1,\"544\":1,\"545\":1,\"554\":1,\"593\":1,\"718\":2}}],[\"modeling\",{\"0\":{\"155\":1,\"276\":1,\"772\":1},\"1\":{\"127\":1,\"155\":1,\"163\":1,\"164\":2,\"167\":1,\"247\":1,\"260\":1,\"262\":1,\"265\":1,\"274\":1,\"275\":2,\"276\":1,\"277\":1,\"285\":2,\"295\":2,\"521\":1,\"544\":2,\"562\":1,\"577\":1,\"767\":1,\"772\":2,\"773\":2,\"790\":1,\"804\":1,\"820\":1}}],[\"modelnet40\",{\"1\":{\"112\":2}}],[\"model\",{\"0\":{\"152\":1,\"160\":1,\"253\":1,\"254\":1,\"255\":1,\"284\":1,\"396\":2,\"572\":1},\"1\":{\"28\":5,\"40\":3,\"42\":2,\"43\":1,\"44\":3,\"46\":1,\"70\":1,\"80\":3,\"81\":3,\"82\":8,\"83\":10,\"93\":2,\"96\":2,\"101\":2,\"142\":5,\"143\":3,\"145\":6,\"147\":6,\"157\":1,\"159\":2,\"160\":1,\"232\":2,\"236\":1,\"252\":6,\"272\":1,\"273\":4,\"274\":1,\"300\":2,\"302\":16,\"304\":16,\"305\":1,\"313\":2,\"323\":2,\"327\":6,\"366\":2,\"395\":3,\"396\":7,\"398\":2,\"463\":1,\"485\":1,\"492\":1,\"516\":1,\"537\":1,\"541\":2,\"544\":5,\"571\":1,\"572\":1,\"580\":10,\"581\":11,\"588\":1,\"590\":10,\"593\":6,\"601\":1,\"615\":1,\"624\":2,\"632\":7,\"700\":2,\"703\":2,\"707\":1,\"713\":1,\"803\":5,\"840\":4,\"848\":8,\"856\":4,\"857\":3,\"860\":4,\"861\":2,\"885\":9,\"886\":5}}],[\"modulelist\",{\"1\":{\"92\":2,\"96\":4,\"100\":2,\"272\":1,\"290\":1,\"580\":1,\"600\":1}}],[\"module\",{\"0\":{\"14\":1},\"1\":{\"30\":1,\"32\":1,\"33\":1,\"34\":2,\"35\":2,\"36\":2,\"41\":1,\"45\":3,\"46\":1,\"59\":8,\"70\":2,\"72\":1,\"73\":1,\"74\":1,\"75\":1,\"76\":2,\"78\":1,\"92\":1,\"93\":1,\"96\":2,\"100\":1,\"101\":1,\"107\":1,\"109\":1,\"110\":1,\"111\":1,\"142\":1,\"145\":1,\"146\":1,\"147\":1,\"162\":1,\"169\":1,\"170\":2,\"186\":2,\"254\":1,\"272\":5,\"275\":3,\"276\":11,\"277\":20,\"278\":11,\"289\":1,\"290\":3,\"291\":1,\"292\":2,\"293\":1,\"295\":2,\"311\":1,\"312\":5,\"318\":1,\"319\":2,\"320\":1,\"321\":2,\"322\":1,\"323\":1,\"336\":1,\"346\":1,\"366\":1,\"463\":1,\"467\":1,\"468\":1,\"469\":1,\"470\":1,\"471\":1,\"473\":1,\"544\":1,\"580\":1,\"584\":1,\"590\":1,\"591\":1,\"597\":1,\"599\":3,\"600\":3,\"601\":1,\"605\":1,\"606\":1,\"607\":1,\"609\":1,\"610\":1,\"611\":1,\"623\":1,\"624\":1,\"626\":1,\"627\":1,\"628\":1,\"630\":1,\"631\":1,\"632\":1,\"691\":1,\"793\":1,\"803\":2,\"804\":2,\"821\":1,\"822\":1,\"840\":2,\"848\":1,\"853\":1,\"859\":1,\"885\":4,\"886\":1}}],[\"modality\",{\"0\":{\"283\":1},\"1\":{\"259\":2,\"260\":1,\"264\":1,\"269\":1,\"270\":1,\"272\":4,\"276\":1,\"277\":4,\"282\":1}}],[\"modal\",{\"0\":{\"14\":1},\"1\":{\"35\":1,\"36\":1,\"163\":1,\"289\":1,\"310\":2}}],[\"mansimov\",{\"1\":{\"806\":1}}],[\"marginal\",{\"1\":{\"733\":1,\"758\":1}}],[\"markdown\",{\"1\":{\"717\":1}}],[\"markersize=12\",{\"1\":{\"697\":1}}],[\"markersize=2\",{\"1\":{\"697\":1}}],[\"marker=\",{\"1\":{\"697\":1}}],[\"made\",{\"1\":{\"630\":1}}],[\"mail\",{\"1\":{\"522\":1}}],[\"main\",{\"1\":{\"28\":2,\"80\":1,\"83\":1,\"142\":1,\"145\":1,\"147\":1,\"252\":1,\"306\":1,\"541\":3,\"544\":4,\"577\":3,\"803\":1}}],[\"mahalanobis\",{\"0\":{\"458\":1},\"1\":{\"752\":1}}],[\"macos安装\",{\"1\":{\"696\":1}}],[\"macos\",{\"1\":{\"620\":1}}],[\"macos系统某些包的加载和依赖关系上存在问题\",{\"1\":{\"38\":1}}],[\"machine\",{\"1\":{\"432\":1}}],[\"major\",{\"1\":{\"422\":2,\"423\":3}}],[\"makedirs\",{\"1\":{\"577\":2,\"840\":2}}],[\"make\",{\"1\":{\"274\":4,\"322\":1,\"579\":1,\"581\":1}}],[\"making\",{\"1\":{\"255\":1}}],[\"mass\",{\"1\":{\"727\":1}}],[\"master\",{\"1\":{\"164\":1,\"171\":1,\"259\":1,\"270\":1,\"764\":1}}],[\"mask作用图解\",{\"1\":{\"594\":2}}],[\"mask模样为\",{\"1\":{\"584\":1}}],[\"mask矩阵将注意力得分矩阵中对应位置的得分设置为一个非常小的值\",{\"1\":{\"584\":1}}],[\"mask矩阵\",{\"1\":{\"584\":1}}],[\"mask部分相关的掩码逻辑\",{\"1\":{\"322\":1}}],[\"mask和casual\",{\"1\":{\"322\":1}}],[\"mask方法中\",{\"1\":{\"312\":1}}],[\"mask标注哪些image\",{\"1\":{\"309\":1}}],[\"mask标签\",{\"1\":{\"274\":1}}],[\"masks\",{\"1\":{\"276\":14,\"277\":21,\"278\":19}}],[\"masks=none\",{\"1\":{\"276\":1,\"277\":1}}],[\"maskinggenerator\",{\"1\":{\"801\":1,\"802\":2}}],[\"masking是将连续的子词tokens进行mask的技巧\",{\"1\":{\"285\":1}}],[\"masking技巧\",{\"1\":{\"285\":1}}],[\"masking\",{\"0\":{\"801\":1},\"1\":{\"274\":1,\"285\":1,\"364\":1,\"559\":1,\"562\":4,\"564\":1,\"578\":1,\"579\":1,\"622\":1,\"631\":1,\"772\":1,\"780\":3,\"790\":1,\"801\":9,\"802\":1}}],[\"maskedconv2d\",{\"1\":{\"886\":3}}],[\"maskedcnn\",{\"1\":{\"848\":12}}],[\"maskedlmoutput\",{\"1\":{\"163\":2}}],[\"masked\",{\"0\":{\"155\":1,\"276\":1,\"572\":1,\"772\":1},\"1\":{\"142\":1,\"145\":2,\"147\":1,\"155\":1,\"163\":15,\"164\":2,\"167\":1,\"170\":2,\"247\":1,\"260\":1,\"262\":1,\"265\":1,\"272\":1,\"274\":1,\"275\":2,\"277\":1,\"285\":1,\"312\":1,\"562\":1,\"571\":1,\"572\":2,\"578\":8,\"579\":6,\"580\":12,\"581\":4,\"584\":1,\"612\":5,\"623\":1,\"632\":1,\"767\":1,\"772\":2,\"773\":3,\"790\":1,\"801\":2,\"802\":2,\"803\":8,\"804\":10,\"815\":1,\"820\":1,\"822\":2}}],[\"mask=extended\",{\"1\":{\"289\":1}}],[\"mask=encoder\",{\"1\":{\"163\":1,\"289\":1,\"295\":1,\"312\":1}}],[\"mask=co\",{\"1\":{\"276\":1,\"277\":4}}],[\"mask=mask\",{\"1\":{\"272\":1,\"632\":1}}],[\"mask=memory\",{\"1\":{\"76\":2}}],[\"mask=head\",{\"1\":{\"163\":1,\"312\":1,\"603\":1,\"612\":1,\"617\":1,\"618\":1}}],[\"mask=attention\",{\"1\":{\"163\":1,\"295\":1,\"311\":1,\"312\":2,\"544\":1,\"594\":1,\"603\":1,\"612\":1,\"614\":1,\"615\":1,\"617\":1,\"618\":1}}],[\"mask=image\",{\"1\":{\"142\":1,\"145\":2,\"147\":3,\"309\":1,\"311\":1,\"312\":1}}],[\"mask=q\",{\"1\":{\"75\":1}}],[\"mask=none\",{\"1\":{\"72\":1,\"74\":1,\"75\":1,\"83\":1,\"162\":3,\"163\":3,\"272\":2,\"289\":2,\"290\":2,\"291\":2,\"292\":2,\"293\":2,\"295\":2,\"312\":12,\"544\":2,\"599\":1,\"600\":2,\"602\":2,\"603\":2,\"605\":2,\"607\":1,\"612\":2,\"615\":2,\"617\":2,\"618\":2,\"632\":2}}],[\"mask=true\",{\"1\":{\"170\":1,\"815\":1}}],[\"mask=text\",{\"1\":{\"142\":1,\"145\":4,\"147\":5,\"161\":2,\"309\":1}}],[\"mask=tgt\",{\"1\":{\"76\":2}}],[\"mask=t\",{\"1\":{\"70\":1,\"76\":1}}],[\"mask=llm\",{\"1\":{\"40\":1}}],[\"mask\",{\"0\":{\"64\":2,\"78\":1,\"584\":1},\"1\":{\"40\":5,\"43\":13,\"59\":12,\"64\":3,\"68\":6,\"70\":4,\"72\":1,\"74\":3,\"75\":3,\"76\":12,\"78\":4,\"81\":2,\"82\":19,\"83\":9,\"92\":6,\"142\":1,\"143\":3,\"145\":8,\"146\":5,\"147\":6,\"155\":4,\"157\":3,\"160\":1,\"161\":3,\"162\":11,\"163\":26,\"170\":6,\"247\":1,\"265\":1,\"272\":10,\"274\":1,\"276\":13,\"277\":18,\"278\":6,\"285\":1,\"289\":4,\"290\":2,\"291\":3,\"292\":2,\"293\":5,\"295\":2,\"309\":2,\"310\":2,\"311\":10,\"312\":29,\"313\":1,\"322\":2,\"386\":1,\"387\":1,\"467\":2,\"468\":3,\"469\":1,\"544\":6,\"560\":1,\"562\":1,\"572\":3,\"578\":6,\"579\":1,\"580\":5,\"584\":7,\"594\":14,\"596\":4,\"599\":1,\"600\":2,\"602\":8,\"603\":3,\"605\":3,\"607\":1,\"612\":2,\"614\":1,\"615\":1,\"617\":4,\"618\":6,\"622\":1,\"623\":11,\"627\":2,\"628\":3,\"630\":4,\"631\":4,\"632\":6,\"780\":1,\"788\":2,\"801\":23,\"802\":4,\"803\":4,\"804\":13,\"814\":13,\"815\":11,\"820\":3,\"822\":5,\"846\":10,\"848\":19,\"886\":10}}],[\"matyas\",{\"1\":{\"692\":2}}],[\"matyas函数求导\",{\"1\":{\"692\":1}}],[\"matplotlib\",{\"1\":{\"304\":1,\"697\":1,\"852\":1,\"886\":1}}],[\"math\",{\"1\":{\"293\":1,\"312\":1,\"549\":1,\"590\":2,\"605\":1,\"632\":1,\"704\":1,\"801\":5,\"803\":1}}],[\"mathvista基准\",{\"1\":{\"228\":1}}],[\"matmul\",{\"1\":{\"293\":2,\"310\":2,\"312\":2,\"367\":3,\"584\":2,\"590\":2,\"591\":1,\"605\":2,\"632\":2,\"885\":1}}],[\"match\",{\"1\":{\"146\":3,\"272\":1}}],[\"matching\",{\"0\":{\"156\":1,\"278\":1,\"311\":1},\"1\":{\"127\":1,\"156\":1,\"260\":1,\"262\":1,\"265\":1,\"275\":1,\"278\":1,\"285\":2,\"303\":11,\"304\":11,\"311\":4,\"531\":1}}],[\"matrix转化成word\",{\"1\":{\"284\":1}}],[\"matrix=none\",{\"1\":{\"163\":1}}],[\"matrix\",{\"0\":{\"442\":1},\"1\":{\"82\":3,\"108\":1,\"163\":4,\"752\":4}}],[\"maybe\",{\"1\":{\"40\":1}}],[\"maximum\",{\"0\":{\"825\":1},\"1\":{\"478\":3}}],[\"max=b\",{\"1\":{\"473\":1}}],[\"max=dict\",{\"1\":{\"80\":1}}],[\"maxvit\",{\"1\":{\"395\":1}}],[\"max\",{\"1\":{\"28\":1,\"40\":2,\"83\":1,\"92\":4,\"96\":1,\"105\":6,\"107\":2,\"109\":1,\"112\":7,\"115\":1,\"142\":3,\"143\":3,\"145\":3,\"146\":2,\"147\":3,\"159\":1,\"170\":2,\"186\":1,\"216\":1,\"218\":1,\"272\":8,\"273\":1,\"274\":14,\"309\":3,\"310\":2,\"313\":2,\"323\":1,\"386\":2,\"387\":1,\"476\":3,\"477\":12,\"478\":19,\"544\":2,\"578\":1,\"579\":7,\"580\":10,\"581\":2,\"588\":2,\"590\":11,\"591\":18,\"593\":1,\"594\":6,\"596\":7,\"597\":1,\"615\":4,\"686\":1,\"688\":1,\"801\":18,\"802\":2,\"803\":1,\"815\":4,\"818\":1,\"819\":1,\"820\":4}}],[\"maps\",{\"1\":{\"476\":2,\"478\":2}}],[\"mapping\",{\"1\":{\"401\":1,\"478\":6}}],[\"mapper\",{\"1\":{\"274\":1}}],[\"map\",{\"1\":{\"28\":1,\"83\":1,\"169\":1,\"312\":1,\"327\":1,\"339\":1,\"387\":2,\"478\":3,\"581\":1,\"596\":1,\"802\":3,\"814\":2,\"821\":2,\"822\":1,\"885\":1,\"886\":1}}],[\"map=device\",{\"1\":{\"28\":1}}],[\"mae\",{\"1\":{\"22\":1,\"23\":1,\"75\":1,\"82\":16,\"247\":2,\"786\":1,\"788\":1,\"797\":1}}],[\"measure\",{\"1\":{\"840\":1}}],[\"measures\",{\"1\":{\"840\":1}}],[\"mean=imagenet\",{\"1\":{\"802\":1}}],[\"mean=torch\",{\"1\":{\"802\":1}}],[\"mean=\",{\"1\":{\"252\":1}}],[\"means++\",{\"1\":{\"170\":1}}],[\"means\",{\"1\":{\"169\":4,\"170\":21}}],[\"mean\",{\"1\":{\"22\":1,\"78\":2,\"82\":11,\"83\":1,\"108\":1,\"145\":2,\"147\":2,\"161\":2,\"163\":2,\"175\":1,\"178\":1,\"186\":3,\"277\":2,\"295\":1,\"311\":1,\"312\":1,\"468\":1,\"470\":2,\"473\":1,\"581\":1,\"746\":1,\"758\":1,\"802\":3,\"821\":1,\"822\":3}}],[\"merged\",{\"1\":{\"476\":6,\"477\":6,\"478\":13}}],[\"merge\",{\"1\":{\"476\":4,\"477\":5,\"478\":12}}],[\"merges\",{\"1\":{\"476\":4,\"478\":3}}],[\"merging\",{\"1\":{\"476\":3,\"478\":1}}],[\"message\",{\"1\":{\"235\":2}}],[\"meshgrid\",{\"1\":{\"697\":1}}],[\"mesh\",{\"1\":{\"114\":1}}],[\"med\",{\"0\":{\"126\":1},\"1\":{\"120\":2,\"122\":1,\"125\":1,\"126\":1,\"129\":1,\"138\":1,\"142\":6,\"145\":2,\"146\":2,\"147\":1,\"287\":1}}],[\"meta\",{\"1\":{\"527\":1,\"531\":1,\"704\":1}}],[\"metamind\",{\"1\":{\"0\":1}}],[\"methods\",{\"1\":{\"301\":1,\"488\":1,\"536\":1}}],[\"method\",{\"0\":{\"125\":1,\"262\":1,\"282\":1},\"1\":{\"347\":3,\"352\":4}}],[\"metrics\",{\"1\":{\"82\":7}}],[\"metric\",{\"1\":{\"82\":1,\"159\":1,\"803\":1}}],[\"members\",{\"1\":{\"478\":1}}],[\"memory=true\",{\"1\":{\"186\":1,\"252\":1,\"274\":3}}],[\"memory\",{\"1\":{\"76\":5,\"175\":1,\"250\":4,\"426\":1,\"516\":1,\"591\":6,\"623\":2,\"630\":2,\"631\":2,\"713\":1}}],[\"mem\",{\"1\":{\"28\":1}}],[\"mhacot是一种类人推理方式\",{\"1\":{\"28\":1}}],[\"mhacot推理链\",{\"1\":{\"6\":1}}],[\"mhacot\",{\"1\":{\"5\":1,\"8\":1,\"28\":1}}],[\"lucidrains\",{\"1\":{\"792\":1}}],[\"luggage\",{\"1\":{\"234\":1}}],[\"lcel\",{\"1\":{\"714\":2,\"715\":1}}],[\"l=4\",{\"1\":{\"591\":1}}],[\"lk\",{\"1\":{\"591\":15}}],[\"lq\",{\"1\":{\"591\":15}}],[\"lpe\",{\"1\":{\"588\":1}}],[\"lstm\",{\"1\":{\"552\":1}}],[\"lstm会掉5\",{\"1\":{\"516\":1}}],[\"lstm表现高方差\",{\"1\":{\"516\":1}}],[\"ltm的过程包含两个阶段\",{\"1\":{\"503\":1}}],[\"ltm的核心思想是\",{\"1\":{\"503\":1}}],[\"ltm\",{\"1\":{\"503\":1}}],[\"l为灰度图片\",{\"1\":{\"316\":1}}],[\"ln\",{\"1\":{\"309\":1,\"313\":1,\"544\":3}}],[\"lffn\",{\"1\":{\"277\":5}}],[\"l+1\",{\"1\":{\"272\":3}}],[\"lgs\",{\"1\":{\"210\":1}}],[\"llama3\",{\"1\":{\"704\":4}}],[\"llama2\",{\"1\":{\"704\":3}}],[\"llama呈现出与同类模型相似的偏见\",{\"1\":{\"551\":1}}],[\"llama通过轻量级指令微调\",{\"1\":{\"550\":1}}],[\"llama的核心成果\",{\"1\":{\"549\":1}}],[\"llama的方法论核心是通过数据质量优化\",{\"1\":{\"548\":1}}],[\"llama采用纯公开数据混合\",{\"1\":{\"548\":1}}],[\"llama仅使用公开数据\",{\"1\":{\"547\":1}}],[\"llama强调推理成本优化而非单纯训练速度\",{\"1\":{\"547\":1}}],[\"llama是一系列高效的基础语言模型\",{\"1\":{\"546\":1}}],[\"llama\",{\"0\":{\"545\":1,\"554\":1},\"1\":{\"198\":1,\"199\":4,\"206\":1,\"208\":2,\"232\":1,\"234\":1,\"235\":1,\"475\":1,\"545\":2,\"546\":1,\"547\":1,\"549\":7,\"550\":1,\"554\":2,\"703\":1,\"704\":16}}],[\"llama系列模型通过高效架构设计和纯公开数据训练\",{\"1\":{\"553\":1}}],[\"llama系列\",{\"1\":{\"192\":1}}],[\"llava模型结构\",{\"1\":{\"234\":1}}],[\"llava\",{\"0\":{\"231\":1},\"1\":{\"193\":1,\"198\":1,\"203\":2,\"210\":2,\"219\":1,\"227\":1,\"231\":2,\"232\":1,\"234\":1,\"235\":4,\"236\":4,\"239\":1}}],[\"llm就像是一个快思考的系统\",{\"1\":{\"500\":1}}],[\"llm是一个概率模型\",{\"1\":{\"497\":1}}],[\"llm已经这么强了\",{\"1\":{\"497\":1}}],[\"llm友好性\",{\"1\":{\"189\":1}}],[\"llms本身缺乏视觉理解能力\",{\"1\":{\"192\":1}}],[\"llms的参数规模已达千亿级\",{\"1\":{\"189\":1}}],[\"llms\",{\"1\":{\"188\":1,\"189\":1,\"192\":1,\"215\":1,\"216\":1,\"488\":1}}],[\"llm\",{\"0\":{\"705\":1},\"1\":{\"3\":1,\"40\":12,\"42\":3,\"43\":14,\"44\":4,\"45\":1,\"69\":1,\"197\":1,\"198\":4,\"210\":2,\"222\":1,\"239\":1,\"307\":1,\"313\":4,\"703\":7,\"704\":2,\"705\":9,\"706\":6,\"708\":4,\"709\":10,\"711\":2,\"713\":2,\"714\":9,\"715\":1,\"718\":1,\"719\":1}}],[\"lmd\",{\"1\":{\"590\":3}}],[\"lm中同样含有pad部分\",{\"1\":{\"581\":1}}],[\"lm也只包含被掩码的token对应的模型预测真实词\",{\"1\":{\"581\":1}}],[\"lm三个目标进行训练\",{\"1\":{\"147\":1}}],[\"lm\",{\"0\":{\"127\":1},\"1\":{\"127\":2,\"128\":1,\"142\":2,\"147\":6,\"163\":7,\"295\":4,\"312\":7,\"521\":1,\"572\":1,\"580\":3,\"581\":6,\"612\":5,\"804\":4}}],[\"lmaffordance3d\",{\"0\":{\"37\":1,\"40\":1},\"1\":{\"37\":1,\"40\":1,\"432\":1}}],[\"l0\",{\"1\":{\"101\":8}}],[\"l4\",{\"1\":{\"101\":6}}],[\"l3\",{\"1\":{\"93\":4,\"96\":4,\"101\":9}}],[\"l2norm\",{\"1\":{\"169\":1,\"170\":5}}],[\"l2\",{\"0\":{\"393\":2},\"1\":{\"93\":4,\"96\":4,\"101\":9,\"169\":1,\"170\":5,\"255\":1,\"277\":2,\"299\":2,\"393\":2,\"514\":1,\"822\":1}}],[\"l1loss\",{\"1\":{\"797\":1}}],[\"l1\",{\"0\":{\"392\":2,\"797\":1},\"1\":{\"93\":4,\"96\":4,\"101\":9,\"392\":1,\"393\":1,\"793\":5,\"797\":4,\"821\":6}}],[\"lr是learning\",{\"1\":{\"697\":1}}],[\"lr=opt\",{\"1\":{\"840\":2}}],[\"lr=1e\",{\"1\":{\"581\":1,\"848\":1,\"856\":1,\"860\":1,\"885\":1,\"886\":1}}],[\"lr=6\",{\"1\":{\"514\":1}}],[\"lr=2\",{\"1\":{\"514\":1}}],[\"lr=config\",{\"1\":{\"142\":1,\"145\":1,\"147\":1}}],[\"lr=dict\",{\"1\":{\"80\":1}}],[\"lr\",{\"1\":{\"80\":4,\"83\":1,\"142\":1,\"145\":1,\"147\":1,\"186\":7,\"252\":1,\"514\":1,\"581\":1,\"697\":6,\"803\":3,\"840\":3}}],[\"l×d\",{\"1\":{\"72\":1,\"73\":1}}],[\"legend\",{\"1\":{\"697\":1}}],[\"legacy\",{\"1\":{\"544\":8}}],[\"legb\",{\"1\":{\"336\":1}}],[\"le\",{\"1\":{\"522\":1}}],[\"leakyrelu\",{\"1\":{\"840\":3}}],[\"least\",{\"0\":{\"503\":1},\"1\":{\"503\":2}}],[\"learn\",{\"0\":{\"397\":1},\"1\":{\"399\":1}}],[\"learned\",{\"1\":{\"299\":3,\"309\":2}}],[\"learners\",{\"1\":{\"518\":1,\"519\":1,\"525\":1}}],[\"learner\",{\"1\":{\"86\":2}}],[\"learning领域中如maml\",{\"1\":{\"531\":1}}],[\"learning的核心思想是通过设计合适的prompt\",{\"1\":{\"301\":1}}],[\"learning或prompt\",{\"1\":{\"301\":1}}],[\"learning\",{\"0\":{\"154\":1,\"242\":1,\"309\":1,\"310\":1,\"313\":1,\"574\":1,\"784\":1,\"787\":1},\"1\":{\"148\":2,\"150\":1,\"232\":1,\"240\":2,\"260\":1,\"262\":1,\"265\":1,\"305\":2,\"309\":1,\"313\":1,\"483\":2,\"520\":1,\"527\":2,\"528\":3,\"531\":2,\"532\":1,\"535\":1,\"593\":1,\"840\":1}}],[\"learnable\",{\"1\":{\"76\":2,\"199\":2,\"239\":1,\"320\":1,\"588\":1}}],[\"let\",{\"1\":{\"500\":1}}],[\"leibler\",{\"1\":{\"157\":1,\"798\":1,\"867\":1}}],[\"levels=np\",{\"1\":{\"697\":1}}],[\"level\",{\"1\":{\"97\":1,\"564\":1,\"772\":1}}],[\"len之前\",{\"1\":{\"814\":1}}],[\"len之后\",{\"1\":{\"814\":1}}],[\"lens\",{\"1\":{\"594\":1,\"596\":2}}],[\"len×d\",{\"1\":{\"588\":1}}],[\"len的维度拼接起来\",{\"1\":{\"312\":1}}],[\"len维度上拼接起来\",{\"1\":{\"311\":2}}],[\"len和hidden\",{\"1\":{\"309\":1}}],[\"len=input\",{\"1\":{\"594\":1}}],[\"len=4\",{\"1\":{\"590\":1}}],[\"len=40\",{\"1\":{\"272\":1}}],[\"len=512\",{\"1\":{\"588\":1}}],[\"len=self\",{\"1\":{\"274\":6}}],[\"len=config\",{\"1\":{\"272\":1}}],[\"length长度\",{\"1\":{\"594\":1}}],[\"length=128\",{\"1\":{\"593\":1}}],[\"length=10\",{\"1\":{\"143\":1,\"313\":1}}],[\"length=0\",{\"1\":{\"311\":1,\"312\":2}}],[\"length=25\",{\"1\":{\"159\":1}}],[\"length=35\",{\"1\":{\"145\":1,\"146\":1}}],[\"length=30\",{\"1\":{\"143\":1,\"147\":1,\"313\":1}}],[\"length=min\",{\"1\":{\"143\":2,\"313\":1}}],[\"length=max\",{\"1\":{\"143\":2,\"313\":1}}],[\"length=40\",{\"1\":{\"142\":1}}],[\"length=self\",{\"1\":{\"40\":1,\"309\":1}}],[\"length\",{\"1\":{\"43\":4,\"45\":1,\"142\":2,\"143\":4,\"145\":1,\"146\":1,\"147\":1,\"309\":1,\"311\":5,\"312\":3,\"313\":2,\"544\":1,\"591\":8,\"594\":11,\"596\":1,\"597\":2,\"614\":4,\"618\":4,\"870\":1,\"872\":1}}],[\"len\",{\"1\":{\"40\":1,\"70\":1,\"81\":3,\"83\":2,\"92\":1,\"96\":2,\"142\":1,\"143\":1,\"145\":1,\"147\":2,\"159\":1,\"186\":6,\"272\":6,\"274\":12,\"275\":1,\"276\":3,\"277\":1,\"278\":5,\"295\":1,\"302\":1,\"304\":1,\"309\":7,\"310\":5,\"311\":10,\"312\":1,\"316\":8,\"369\":1,\"403\":2,\"476\":2,\"477\":3,\"478\":4,\"541\":1,\"544\":4,\"577\":2,\"578\":9,\"579\":18,\"580\":9,\"581\":2,\"584\":10,\"590\":11,\"591\":2,\"594\":13,\"596\":5,\"605\":2,\"615\":4,\"617\":2,\"632\":1,\"681\":1,\"686\":1,\"688\":1,\"689\":5,\"804\":2,\"814\":31,\"815\":18,\"817\":21,\"820\":7,\"822\":5,\"840\":2,\"848\":1,\"856\":1,\"860\":1}}],[\"left\",{\"1\":{\"40\":1,\"369\":1,\"627\":1,\"801\":5}}],[\"langserve\",{\"1\":{\"715\":1}}],[\"langsmith\",{\"1\":{\"714\":1,\"715\":1}}],[\"langchian\",{\"1\":{\"713\":1}}],[\"langchain\",{\"0\":{\"712\":1},\"1\":{\"712\":6,\"713\":1,\"714\":13,\"715\":10,\"717\":3}}],[\"language生成学习\",{\"1\":{\"308\":1}}],[\"language表征学习\",{\"1\":{\"308\":1}}],[\"language\",{\"0\":{\"84\":1,\"155\":1,\"231\":1,\"276\":1,\"572\":1},\"1\":{\"37\":1,\"40\":1,\"43\":1,\"46\":1,\"60\":3,\"70\":1,\"82\":1,\"119\":4,\"120\":1,\"127\":1,\"134\":2,\"148\":2,\"150\":1,\"155\":1,\"163\":1,\"171\":4,\"198\":2,\"231\":1,\"247\":1,\"259\":2,\"260\":1,\"262\":1,\"265\":1,\"270\":1,\"272\":1,\"274\":2,\"275\":3,\"276\":1,\"277\":3,\"279\":2,\"285\":2,\"295\":2,\"298\":1,\"301\":1,\"305\":1,\"487\":1,\"488\":1,\"489\":1,\"492\":1,\"501\":1,\"502\":1,\"503\":1,\"505\":1,\"518\":1,\"519\":1,\"521\":1,\"525\":1,\"528\":1,\"533\":1,\"536\":1,\"545\":1,\"562\":1,\"571\":1,\"572\":1,\"577\":1,\"703\":2,\"718\":2,\"772\":1,\"790\":1}}],[\"latents\",{\"1\":{\"822\":15}}],[\"latent\",{\"1\":{\"704\":1,\"773\":2,\"821\":2,\"822\":14,\"840\":4,\"853\":4,\"857\":1,\"859\":4,\"885\":4,\"886\":14}}],[\"latency\",{\"1\":{\"492\":1}}],[\"law的未来\",{\"1\":{\"718\":1}}],[\"law\",{\"0\":{\"731\":1},\"1\":{\"703\":7,\"718\":1}}],[\"lawrence\",{\"1\":{\"536\":1}}],[\"laws\",{\"1\":{\"527\":1,\"528\":1,\"531\":2}}],[\"lambada去除重叠样本后\",{\"1\":{\"522\":1}}],[\"lambada\",{\"1\":{\"522\":1}}],[\"lambada等\",{\"1\":{\"522\":1}}],[\"lambda\",{\"1\":{\"336\":1,\"627\":1,\"630\":2,\"821\":2,\"822\":1,\"848\":2}}],[\"lavis\",{\"1\":{\"306\":1,\"439\":1}}],[\"launchpad\",{\"1\":{\"300\":1}}],[\"large\",{\"0\":{\"231\":1},\"1\":{\"147\":1,\"231\":1,\"302\":2,\"304\":1,\"305\":1,\"487\":1,\"489\":1,\"501\":1,\"503\":1,\"521\":1,\"562\":1,\"564\":1,\"591\":5,\"703\":1,\"718\":2}}],[\"laion\",{\"1\":{\"131\":1,\"198\":2,\"225\":1}}],[\"last\",{\"1\":{\"92\":3,\"96\":3,\"100\":3,\"145\":5,\"146\":2,\"147\":4,\"161\":4,\"162\":2,\"186\":4,\"289\":1,\"309\":2,\"311\":1,\"312\":1,\"395\":1,\"463\":1,\"544\":1}}],[\"last=true\",{\"1\":{\"80\":1,\"186\":1,\"252\":1,\"803\":1}}],[\"laso\",{\"0\":{\"60\":1},\"1\":{\"6\":1,\"7\":1,\"22\":1,\"23\":1,\"60\":4,\"62\":1,\"68\":1,\"69\":1,\"70\":1,\"71\":1,\"76\":1,\"78\":2,\"82\":3,\"83\":2}}],[\"laptop\",{\"1\":{\"29\":1,\"58\":1,\"68\":1}}],[\"layer=act\",{\"1\":{\"272\":3,\"321\":1,\"323\":1}}],[\"layer=args\",{\"1\":{\"186\":1}}],[\"layer=nn\",{\"1\":{\"272\":2,\"321\":3}}],[\"layer=norm\",{\"1\":{\"272\":1,\"323\":1}}],[\"layer=none\",{\"1\":{\"272\":1,\"318\":1,\"319\":1,\"320\":3,\"323\":3}}],[\"layer=partial\",{\"1\":{\"160\":2}}],[\"layer=false\",{\"1\":{\"145\":2,\"146\":1,\"147\":2,\"295\":1}}],[\"layer=0\",{\"1\":{\"145\":1,\"147\":1}}],[\"layer=config\",{\"1\":{\"142\":1,\"145\":1,\"147\":1}}],[\"layer的任务是通过中心点找到邻居点\",{\"1\":{\"90\":1}}],[\"layers=7\",{\"1\":{\"886\":1}}],[\"layers=8\",{\"1\":{\"848\":2}}],[\"layerscale\",{\"1\":{\"272\":6}}],[\"layers\",{\"1\":{\"88\":1,\"98\":2,\"199\":1,\"277\":2,\"290\":2,\"312\":1,\"580\":3,\"581\":1,\"600\":1,\"605\":1,\"628\":3,\"631\":2,\"777\":1,\"793\":14,\"814\":2,\"821\":17,\"840\":4,\"848\":3,\"886\":6}}],[\"layers组成\",{\"1\":{\"88\":1}}],[\"layers主要包括3个部分\",{\"1\":{\"87\":1}}],[\"layer\",{\"0\":{\"89\":1,\"90\":1,\"91\":1},\"1\":{\"72\":1,\"75\":2,\"87\":3,\"88\":6,\"99\":6,\"142\":4,\"145\":2,\"146\":2,\"147\":2,\"162\":7,\"186\":3,\"272\":23,\"277\":6,\"290\":5,\"292\":1,\"293\":17,\"295\":1,\"312\":36,\"318\":3,\"319\":2,\"320\":1,\"321\":4,\"323\":8,\"544\":3,\"580\":3,\"597\":1,\"599\":3,\"600\":4,\"605\":21,\"606\":1,\"609\":1,\"622\":1,\"628\":6,\"631\":6,\"700\":1,\"793\":1}}],[\"layer指的是pointnet++中提供的pointnetfeaturepropagation特征传播类\",{\"1\":{\"70\":1}}],[\"layer指的是pointnet++中提供的pointnetsetabstractionmsg多尺度分组点集特征抽取类\",{\"1\":{\"70\":1}}],[\"layernorm\",{\"1\":{\"32\":2,\"36\":2,\"45\":6,\"73\":2,\"160\":2,\"179\":1,\"272\":5,\"276\":1,\"277\":1,\"292\":3,\"294\":1,\"295\":3,\"311\":1,\"321\":1,\"323\":2,\"514\":1,\"597\":2,\"599\":2,\"606\":2,\"609\":2,\"626\":2,\"628\":1,\"631\":1,\"814\":2}}],[\"lay\",{\"1\":{\"29\":1,\"58\":1,\"68\":1}}],[\"label=\",{\"1\":{\"696\":12,\"697\":2}}],[\"label=none\",{\"1\":{\"612\":1}}],[\"label=label\",{\"1\":{\"594\":1}}],[\"labels=labels\",{\"1\":{\"312\":1}}],[\"labels=none\",{\"1\":{\"163\":2,\"295\":1,\"312\":1,\"603\":1,\"612\":1,\"617\":1,\"618\":1}}],[\"labels=decoder\",{\"1\":{\"142\":1,\"147\":1}}],[\"labels\",{\"1\":{\"62\":1,\"98\":2,\"99\":1,\"145\":2,\"147\":2,\"162\":2,\"163\":15,\"173\":1,\"178\":1,\"255\":3,\"274\":1,\"276\":11,\"277\":10,\"278\":9,\"295\":4,\"299\":3,\"300\":1,\"311\":2,\"312\":8,\"316\":4,\"323\":3,\"401\":2,\"403\":4,\"594\":1,\"596\":2,\"603\":8,\"612\":2,\"615\":3,\"617\":11,\"618\":2,\"803\":1,\"815\":3,\"822\":3,\"861\":2}}],[\"label\",{\"1\":{\"29\":9,\"40\":3,\"58\":10,\"64\":1,\"81\":1,\"82\":4,\"159\":6,\"161\":3,\"162\":1,\"163\":8,\"186\":1,\"295\":1,\"300\":1,\"301\":2,\"310\":2,\"312\":1,\"316\":8,\"317\":4,\"395\":1,\"401\":5,\"403\":4,\"470\":1,\"581\":2,\"594\":2,\"612\":2,\"859\":5}}],[\"lipschitz\",{\"0\":{\"839\":1},\"1\":{\"839\":4}}],[\"lite\",{\"1\":{\"704\":2}}],[\"library\",{\"1\":{\"691\":1}}],[\"limitations\",{\"1\":{\"539\":1}}],[\"liang\",{\"1\":{\"536\":1}}],[\"lightningdatamodule\",{\"1\":{\"273\":10,\"274\":3}}],[\"lightningmodule\",{\"1\":{\"273\":25,\"275\":1}}],[\"lightning\",{\"1\":{\"271\":1,\"272\":1,\"273\":2}}],[\"lightgroupattnblock\",{\"1\":{\"72\":1}}],[\"liu\",{\"1\":{\"231\":1}}],[\"lin\",{\"1\":{\"536\":1,\"632\":2}}],[\"lineids\",{\"1\":{\"477\":5}}],[\"line\",{\"1\":{\"477\":9,\"541\":1,\"577\":8,\"696\":1}}],[\"lines\",{\"1\":{\"477\":2}}],[\"line>\",{\"1\":{\"476\":1,\"477\":1,\"478\":2}}],[\"linears\",{\"1\":{\"632\":3}}],[\"linear1\",{\"1\":{\"76\":1}}],[\"linear2\",{\"1\":{\"76\":1}}],[\"linear\",{\"1\":{\"34\":2,\"35\":4,\"36\":2,\"42\":2,\"44\":2,\"45\":5,\"46\":2,\"59\":4,\"73\":4,\"93\":3,\"96\":3,\"107\":3,\"110\":3,\"145\":5,\"146\":3,\"147\":5,\"160\":7,\"213\":1,\"245\":1,\"272\":3,\"289\":1,\"292\":1,\"295\":2,\"321\":2,\"322\":2,\"323\":2,\"575\":3,\"580\":3,\"590\":4,\"599\":2,\"601\":1,\"603\":1,\"605\":3,\"606\":1,\"609\":1,\"610\":1,\"611\":1,\"614\":1,\"615\":1,\"617\":1,\"618\":1,\"624\":1,\"632\":3,\"700\":1,\"804\":1,\"814\":2,\"822\":3,\"840\":5,\"853\":5,\"859\":5}}],[\"linalg\",{\"1\":{\"302\":2,\"304\":2}}],[\"linguistic\",{\"1\":{\"187\":1,\"515\":1}}],[\"linspace\",{\"0\":{\"332\":1},\"1\":{\"82\":2,\"186\":1,\"272\":1,\"332\":2,\"697\":2}}],[\"li\",{\"1\":{\"60\":1,\"126\":1,\"127\":2}}],[\"likert\",{\"1\":{\"537\":1}}],[\"likelihood\",{\"0\":{\"825\":1},\"1\":{\"537\":1,\"733\":2,\"758\":2,\"807\":1,\"843\":1,\"854\":1}}],[\"like\",{\"0\":{\"310\":1,\"312\":1},\"1\":{\"59\":1,\"272\":1,\"276\":2,\"277\":2,\"278\":3,\"591\":1,\"597\":1,\"672\":1,\"682\":1,\"684\":1,\"686\":1,\"688\":1,\"815\":2,\"818\":1,\"853\":1,\"859\":1,\"886\":1}}],[\"lift\",{\"1\":{\"29\":1,\"58\":1,\"62\":1,\"67\":1,\"68\":1}}],[\"lid\",{\"1\":{\"28\":2,\"31\":2}}],[\"lidar\",{\"1\":{\"22\":1}}],[\"liquid\",{\"1\":{\"28\":2,\"31\":2}}],[\"list列表组装起来得到需要的dataset\",{\"1\":{\"594\":1}}],[\"listdir\",{\"1\":{\"302\":1,\"304\":1,\"316\":2}}],[\"listen\",{\"1\":{\"29\":1,\"58\":1,\"68\":1}}],[\"list\",{\"1\":{\"28\":2,\"29\":13,\"43\":1,\"58\":13,\"70\":1,\"83\":2,\"92\":2,\"96\":15,\"186\":2,\"276\":2,\"277\":6,\"316\":2,\"337\":1,\"374\":1,\"401\":1,\"434\":1,\"437\":1,\"476\":4,\"477\":7,\"478\":27,\"544\":3,\"578\":6,\"697\":6,\"821\":2}}],[\"lorentz\",{\"1\":{\"749\":1}}],[\"lora微调\",{\"1\":{\"490\":1}}],[\"lora的基本思路\",{\"1\":{\"487\":1}}],[\"lora背后有一个假设\",{\"1\":{\"487\":1}}],[\"lora是跟prompt\",{\"1\":{\"487\":1}}],[\"lora\",{\"0\":{\"487\":1,\"492\":1},\"1\":{\"10\":1,\"488\":1,\"489\":1,\"491\":5,\"492\":9,\"495\":7}}],[\"lovaszsoftmax\",{\"1\":{\"472\":1}}],[\"lovasz\",{\"0\":{\"472\":1},\"1\":{\"472\":1}}],[\"lookahead\",{\"1\":{\"395\":1}}],[\"looking\",{\"1\":{\"300\":1}}],[\"loshchilov\",{\"1\":{\"131\":1}}],[\"loss中的alpha和beta\",{\"1\":{\"474\":1}}],[\"loss等能够处理不平衡情况的损失函数\",{\"1\":{\"474\":1}}],[\"loss或combo\",{\"1\":{\"474\":1}}],[\"loss的设计思想是\",{\"1\":{\"472\":1}}],[\"loss的设计灵感来自tversky指数\",{\"1\":{\"471\":1}}],[\"loss引入了一个衰减因子\",{\"1\":{\"470\":1}}],[\"loss和标准的二元交叉熵\",{\"1\":{\"468\":1}}],[\"loss是将dice\",{\"1\":{\"468\":1}}],[\"loss=false\",{\"1\":{\"815\":1,\"817\":1}}],[\"loss=lm\",{\"1\":{\"295\":1,\"312\":1}}],[\"loss=masked\",{\"1\":{\"163\":1}}],[\"loss监督\",{\"1\":{\"55\":1}}],[\"loss\",{\"0\":{\"15\":1,\"78\":2,\"277\":1,\"310\":1,\"311\":1,\"312\":1,\"467\":1,\"468\":1,\"469\":1,\"470\":1,\"471\":1,\"472\":1,\"473\":1,\"797\":1,\"832\":1},\"1\":{\"15\":2,\"40\":8,\"55\":1,\"78\":25,\"80\":1,\"81\":8,\"82\":1,\"108\":2,\"127\":3,\"142\":5,\"145\":15,\"147\":20,\"159\":8,\"161\":7,\"162\":1,\"163\":20,\"170\":5,\"186\":13,\"252\":3,\"265\":1,\"272\":2,\"273\":1,\"274\":1,\"275\":6,\"276\":10,\"277\":20,\"278\":10,\"295\":7,\"299\":8,\"310\":2,\"311\":1,\"312\":10,\"323\":3,\"395\":1,\"467\":10,\"468\":21,\"469\":21,\"470\":38,\"471\":5,\"473\":22,\"537\":3,\"572\":2,\"574\":1,\"581\":23,\"603\":8,\"612\":10,\"615\":10,\"617\":11,\"618\":5,\"793\":8,\"794\":15,\"797\":4,\"803\":10,\"804\":1,\"814\":2,\"815\":28,\"821\":21,\"822\":4,\"840\":19,\"848\":7,\"854\":2,\"856\":8,\"860\":8,\"881\":1,\"885\":29,\"886\":9}}],[\"loal\",{\"1\":{\"86\":1}}],[\"loaded\",{\"1\":{\"581\":1,\"885\":3,\"886\":3}}],[\"loader\",{\"1\":{\"80\":3,\"81\":2,\"82\":2,\"142\":7,\"145\":8,\"147\":7,\"159\":3,\"186\":6,\"252\":6,\"274\":12,\"317\":2,\"323\":2,\"803\":4,\"840\":1,\"848\":3,\"855\":1,\"856\":2,\"857\":1,\"860\":2,\"885\":2,\"886\":1}}],[\"loading\",{\"1\":{\"252\":1,\"302\":1,\"304\":1}}],[\"load\",{\"1\":{\"28\":2,\"68\":2,\"83\":4,\"169\":2,\"186\":1,\"327\":2,\"366\":1,\"478\":4,\"578\":2,\"581\":2,\"885\":2,\"886\":2}}],[\"logvar\",{\"1\":{\"853\":13,\"854\":3,\"856\":2,\"859\":7,\"860\":2}}],[\"logistic\",{\"1\":{\"843\":1}}],[\"logit\",{\"1\":{\"78\":1,\"277\":19,\"469\":1,\"470\":1,\"817\":1}}],[\"logits外\",{\"1\":{\"327\":1}}],[\"logits=prediction\",{\"1\":{\"163\":1,\"295\":1,\"312\":1}}],[\"logits=false\",{\"1\":{\"163\":1,\"312\":1,\"327\":1}}],[\"logits\",{\"1\":{\"59\":6,\"81\":1,\"98\":1,\"163\":7,\"248\":1,\"255\":9,\"275\":2,\"276\":8,\"277\":17,\"278\":8,\"295\":1,\"299\":3,\"311\":2,\"312\":2,\"323\":3,\"327\":3,\"467\":2,\"468\":1,\"471\":2,\"541\":4,\"544\":5,\"580\":6,\"581\":4,\"603\":5,\"614\":12,\"615\":15,\"617\":6,\"618\":6,\"793\":1,\"794\":12,\"795\":7,\"796\":2,\"798\":3,\"808\":1,\"809\":2,\"814\":24,\"815\":21,\"816\":5,\"817\":8,\"818\":12,\"819\":4,\"820\":18,\"821\":22,\"848\":2,\"886\":5}}],[\"log2\",{\"1\":{\"821\":1}}],[\"logspace\",{\"1\":{\"697\":1}}],[\"logging\",{\"1\":{\"593\":1}}],[\"logger\",{\"1\":{\"82\":2,\"159\":1,\"273\":1,\"803\":1}}],[\"logp\",{\"1\":{\"537\":1}}],[\"log\",{\"0\":{\"799\":1},\"1\":{\"78\":3,\"83\":2,\"93\":1,\"96\":1,\"101\":1,\"110\":2,\"111\":3,\"145\":2,\"147\":2,\"159\":1,\"161\":2,\"163\":1,\"186\":1,\"276\":2,\"277\":7,\"278\":2,\"345\":3,\"347\":2,\"353\":1,\"473\":4,\"537\":2,\"591\":2,\"624\":1,\"794\":8,\"798\":8,\"799\":11,\"801\":5,\"803\":3,\"821\":8,\"831\":1,\"853\":4,\"854\":2}}],[\"locality\",{\"1\":{\"314\":1,\"426\":1}}],[\"local\",{\"1\":{\"86\":3,\"92\":2,\"186\":15,\"265\":1,\"302\":2,\"304\":2,\"336\":3,\"596\":1}}],[\"location=device\",{\"1\":{\"327\":1,\"581\":1,\"885\":1,\"886\":1}}],[\"location=\",{\"1\":{\"83\":1,\"169\":1}}],[\"loc\",{\"1\":{\"68\":1}}],[\"longterm\",{\"1\":{\"577\":1}}],[\"longtensor\",{\"1\":{\"313\":1,\"544\":2,\"581\":1,\"591\":1}}],[\"long\",{\"1\":{\"43\":1,\"92\":5,\"142\":1,\"143\":1,\"145\":4,\"146\":1,\"147\":4,\"160\":1,\"161\":1,\"162\":2,\"163\":1,\"254\":1,\"255\":1,\"276\":2,\"277\":3,\"278\":1,\"309\":1,\"311\":4,\"312\":1,\"313\":1,\"577\":1,\"591\":2,\"597\":1,\"848\":2,\"861\":1,\"886\":2}}],[\"longest\",{\"1\":{\"40\":1,\"142\":1,\"159\":1}}],[\"lower\",{\"1\":{\"68\":1,\"302\":1,\"304\":1,\"478\":1,\"593\":1}}],[\"low\",{\"1\":{\"28\":1,\"376\":2,\"487\":1,\"489\":1,\"491\":2}}],[\"l\",{\"1\":{\"4\":1,\"45\":5,\"70\":2,\"72\":1,\"73\":2,\"74\":1,\"75\":1,\"76\":12,\"105\":1,\"131\":3,\"132\":1,\"145\":7,\"147\":2,\"160\":1,\"161\":3,\"163\":2,\"234\":1,\"235\":1,\"255\":4,\"264\":1,\"272\":4,\"299\":5,\"302\":1,\"537\":1,\"590\":32,\"591\":33,\"593\":3,\"790\":1,\"881\":1}}],[\"1~2\",{\"1\":{\"882\":1}}],[\"1~12个448×448图块\",{\"1\":{\"227\":1}}],[\"1~12个448×448区块\",{\"1\":{\"222\":1}}],[\"1×1\",{\"1\":{\"808\":1}}],[\"1×3虚拟扩展为\",{\"1\":{\"427\":1}}],[\"1×3\",{\"1\":{\"427\":1}}],[\"1表示遮挡\",{\"1\":{\"801\":1}}],[\"1=none\",{\"1\":{\"594\":3}}],[\"1m\",{\"1\":{\"560\":1,\"704\":5}}],[\"1分\",{\"1\":{\"551\":1}}],[\"1论文\",{\"0\":{\"545\":1}}],[\"1bw\",{\"1\":{\"522\":1}}],[\"1b\",{\"1\":{\"514\":1}}],[\"1b参数\",{\"1\":{\"196\":1}}],[\"1x4\",{\"1\":{\"425\":1}}],[\"1x1\",{\"1\":{\"73\":1,\"848\":1}}],[\"1rkdjdlr37o7gsr9j1mhjbg\",{\"1\":{\"327\":1}}],[\"1标志位表示visual\",{\"1\":{\"284\":1}}],[\"1+k\",{\"1\":{\"255\":1}}],[\"1个0\",{\"1\":{\"248\":1}}],[\"1个1\",{\"1\":{\"248\":1}}],[\"1个图片经过编码器2得到的表征都是负样本\",{\"1\":{\"248\":1}}],[\"1v\",{\"1\":{\"218\":1}}],[\"1k\",{\"1\":{\"201\":1,\"395\":1,\"774\":1,\"778\":1}}],[\"1亿参数\",{\"1\":{\"197\":1}}],[\"1准确率\",{\"1\":{\"184\":1}}],[\"14×32\",{\"1\":{\"817\":1}}],[\"14×14\",{\"1\":{\"386\":2}}],[\"1478093658716966912\",{\"1\":{\"816\":1}}],[\"14x14\",{\"1\":{\"801\":2,\"885\":4}}],[\"14b\",{\"1\":{\"704\":1}}],[\"141\",{\"1\":{\"549\":1,\"551\":1}}],[\"14模型\",{\"1\":{\"299\":1}}],[\"14则需要在256个v100\",{\"1\":{\"299\":1}}],[\"14238\",{\"1\":{\"187\":1}}],[\"14\",{\"1\":{\"161\":1,\"167\":2,\"234\":1,\"235\":1,\"277\":1,\"299\":2,\"302\":1,\"318\":2,\"320\":2,\"374\":1,\"423\":1,\"522\":1,\"541\":1,\"680\":1,\"692\":2,\"696\":2,\"700\":1,\"774\":2,\"801\":1,\"804\":2,\"817\":1,\"882\":1}}],[\"1400\",{\"1\":{\"131\":1}}],[\"1节中的跨模态解码器\",{\"1\":{\"142\":1}}],[\"1节中提到的多模态融合模块配置\",{\"1\":{\"142\":1}}],[\"1节实验设置中使用384x384\",{\"1\":{\"142\":1}}],[\"137mo\",{\"1\":{\"316\":1}}],[\"1317\",{\"1\":{\"204\":1}}],[\"13b模型在单v100\",{\"1\":{\"549\":1}}],[\"13b性能优于gpt\",{\"1\":{\"549\":1}}],[\"13b在多数基准测试中优于gpt\",{\"1\":{\"546\":1}}],[\"13b\",{\"1\":{\"203\":2,\"204\":1}}],[\"13\",{\"1\":{\"137\":1,\"145\":4,\"161\":1,\"276\":1,\"277\":1,\"374\":1,\"423\":1,\"541\":1,\"547\":1}}],[\"1d\",{\"1\":{\"107\":1,\"372\":1,\"771\":1,\"803\":1}}],[\"1️⃣\",{\"0\":{\"72\":1},\"1\":{\"100\":1,\"885\":1}}],[\"1750\",{\"1\":{\"703\":1,\"704\":1}}],[\"1750亿参数\",{\"1\":{\"527\":1}}],[\"175b的69\",{\"1\":{\"551\":1}}],[\"175b\",{\"1\":{\"536\":1,\"537\":1,\"538\":2,\"539\":2,\"546\":1,\"549\":2,\"703\":1}}],[\"175b也只能在few\",{\"1\":{\"529\":1}}],[\"175k\",{\"1\":{\"208\":1}}],[\"17个任务\",{\"1\":{\"520\":1}}],[\"170\",{\"1\":{\"455\":1}}],[\"1706\",{\"1\":{\"85\":1}}],[\"174\",{\"1\":{\"65\":1}}],[\"17\",{\"1\":{\"65\":1,\"67\":1,\"75\":1,\"161\":1,\"423\":1,\"872\":1}}],[\"1f242tsdxjrzkkqotibsin2u6rjagrz2w\",{\"1\":{\"47\":1}}],[\"119\",{\"1\":{\"704\":1}}],[\"11929\",{\"1\":{\"327\":1}}],[\"117m\",{\"1\":{\"521\":1,\"522\":1}}],[\"110\",{\"1\":{\"75\":1}}],[\"11\",{\"1\":{\"40\":1,\"82\":1,\"161\":1,\"237\":1,\"269\":1,\"276\":1,\"277\":2,\"374\":1,\"423\":1,\"522\":1,\"541\":1,\"593\":1,\"620\":2,\"704\":4}}],[\"12597\",{\"1\":{\"306\":1}}],[\"12m\",{\"1\":{\"131\":1}}],[\"1200000000\",{\"1\":{\"324\":1}}],[\"120\",{\"1\":{\"65\":1,\"774\":1,\"809\":1,\"810\":1}}],[\"128k\",{\"1\":{\"704\":9}}],[\"128\",{\"1\":{\"35\":2,\"59\":1,\"70\":1,\"73\":1,\"93\":5,\"96\":10,\"98\":4,\"99\":4,\"100\":1,\"101\":12,\"107\":4,\"109\":3,\"111\":3,\"185\":2,\"202\":1,\"250\":2,\"254\":2,\"255\":1,\"587\":1,\"614\":1,\"840\":2}}],[\"127\",{\"1\":{\"23\":1}}],[\"12\",{\"1\":{\"23\":1,\"24\":1,\"82\":1,\"136\":1,\"152\":1,\"161\":1,\"276\":1,\"277\":2,\"370\":1,\"374\":1,\"387\":1,\"423\":4,\"514\":2,\"541\":1,\"587\":1,\"593\":6,\"692\":1,\"696\":1,\"704\":3,\"774\":2,\"810\":1}}],[\"1e9\",{\"1\":{\"584\":1,\"632\":1}}],[\"1e10\",{\"1\":{\"92\":2}}],[\"1e\",{\"1\":{\"22\":1,\"78\":7,\"83\":1,\"100\":1,\"147\":2,\"208\":2,\"323\":1,\"561\":1,\"581\":1,\"794\":1,\"798\":1}}],[\"15的概率mask掉tokens\",{\"1\":{\"285\":1}}],[\"158\",{\"1\":{\"235\":1}}],[\"158k\",{\"1\":{\"235\":2}}],[\"1586\",{\"1\":{\"203\":1}}],[\"15\",{\"1\":{\"17\":1,\"63\":1,\"68\":1,\"83\":1,\"131\":1,\"155\":1,\"161\":1,\"163\":1,\"237\":1,\"265\":1,\"277\":1,\"374\":1,\"423\":1,\"541\":1,\"547\":1,\"548\":1,\"549\":1,\"560\":1,\"572\":1,\"703\":1,\"704\":3,\"857\":2,\"861\":1}}],[\"15k交互图像\",{\"1\":{\"6\":1}}],[\"180\",{\"1\":{\"181\":1,\"455\":1}}],[\"18\",{\"1\":{\"17\":1,\"215\":1,\"261\":1,\"423\":1,\"514\":1,\"692\":1,\"696\":1,\"872\":1}}],[\"16k\",{\"1\":{\"704\":1}}],[\"16gb\",{\"1\":{\"560\":1,\"561\":2,\"565\":1}}],[\"16×16\",{\"1\":{\"327\":1,\"774\":1}}],[\"16这个模型进行微调\",{\"1\":{\"327\":1}}],[\"16x16\",{\"1\":{\"317\":1}}],[\"16为例\",{\"1\":{\"317\":1,\"318\":1}}],[\"16和vit\",{\"1\":{\"299\":1}}],[\"16倍和64倍得到的\",{\"1\":{\"299\":1}}],[\"160gb\",{\"1\":{\"560\":1,\"561\":2}}],[\"160\",{\"1\":{\"209\":1,\"455\":1}}],[\"164k\",{\"1\":{\"208\":1}}],[\"1612\",{\"1\":{\"102\":1}}],[\"162张图像\",{\"1\":{\"49\":1}}],[\"16\",{\"1\":{\"10\":1,\"22\":1,\"59\":8,\"65\":1,\"73\":1,\"83\":1,\"96\":1,\"101\":1,\"131\":2,\"152\":1,\"161\":1,\"167\":2,\"179\":2,\"181\":1,\"184\":1,\"261\":1,\"317\":2,\"318\":3,\"327\":1,\"374\":1,\"386\":1,\"387\":3,\"423\":1,\"537\":1,\"541\":1,\"549\":1,\"714\":1,\"772\":1,\"774\":1,\"809\":1,\"872\":1}}],[\"101\",{\"1\":{\"594\":2}}],[\"104\",{\"1\":{\"594\":1}}],[\"10437\",{\"1\":{\"47\":1}}],[\"10份\",{\"1\":{\"562\":1}}],[\"103是超过\",{\"1\":{\"577\":1}}],[\"103两个版本\",{\"1\":{\"577\":1}}],[\"103\",{\"1\":{\"577\":5,\"578\":1,\"594\":1}}],[\"103测试集1\",{\"1\":{\"522\":1}}],[\"1035\",{\"1\":{\"65\":1}}],[\"102\",{\"1\":{\"594\":2}}],[\"1022\",{\"1\":{\"204\":1}}],[\"1024+64\",{\"1\":{\"109\":1}}],[\"1024维\",{\"1\":{\"107\":1,\"109\":1,\"110\":2}}],[\"1024\",{\"1\":{\"34\":1,\"36\":1,\"93\":3,\"96\":3,\"99\":2,\"100\":1,\"101\":3,\"107\":9,\"109\":7,\"110\":1,\"111\":2,\"179\":1,\"185\":1,\"211\":1,\"212\":1,\"588\":1,\"807\":1,\"809\":1,\"840\":2}}],[\"10×96²\",{\"1\":{\"184\":1}}],[\"100个任务示例作为上下文\",{\"1\":{\"528\":1}}],[\"1000\",{\"1\":{\"470\":1,\"697\":1}}],[\"10000\",{\"1\":{\"311\":3,\"602\":1,\"814\":1,\"822\":1}}],[\"100占位\",{\"1\":{\"276\":1}}],[\"100万\",{\"1\":{\"248\":1}}],[\"100万个图片\",{\"1\":{\"248\":1}}],[\"100\",{\"1\":{\"142\":2,\"145\":1,\"147\":1,\"159\":1,\"163\":8,\"186\":2,\"234\":2,\"247\":1,\"274\":1,\"276\":4,\"277\":2,\"300\":1,\"302\":1,\"304\":1,\"312\":2,\"443\":2,\"444\":1,\"451\":1,\"455\":2,\"459\":1,\"470\":1,\"514\":1,\"528\":1,\"581\":1,\"594\":2,\"688\":6,\"697\":3,\"704\":2,\"857\":1}}],[\"1088\",{\"1\":{\"109\":2,\"111\":1}}],[\"10\",{\"0\":{\"46\":1},\"1\":{\"10\":2,\"40\":1,\"63\":1,\"82\":2,\"161\":1,\"163\":2,\"169\":1,\"170\":2,\"179\":1,\"186\":1,\"198\":1,\"199\":1,\"202\":1,\"211\":1,\"212\":1,\"224\":1,\"247\":1,\"276\":2,\"277\":2,\"340\":2,\"373\":1,\"374\":1,\"376\":1,\"389\":5,\"398\":3,\"423\":1,\"541\":1,\"549\":1,\"560\":3,\"562\":3,\"572\":2,\"578\":4,\"579\":2,\"632\":3,\"695\":1,\"704\":9,\"774\":1,\"794\":1,\"798\":1,\"800\":1,\"801\":1,\"848\":2,\"856\":1,\"860\":1,\"861\":4,\"873\":1,\"885\":1,\"886\":1}}],[\"1\",{\"0\":{\"22\":1,\"62\":1,\"187\":1,\"214\":1,\"231\":1,\"289\":1,\"309\":1,\"310\":1,\"317\":1,\"407\":1,\"412\":1,\"505\":1,\"702\":1,\"784\":1,\"828\":1,\"834\":1,\"839\":1,\"852\":1},\"1\":{\"7\":1,\"22\":1,\"24\":1,\"26\":1,\"28\":5,\"29\":6,\"30\":5,\"32\":8,\"34\":4,\"35\":37,\"36\":28,\"40\":4,\"41\":10,\"43\":3,\"45\":14,\"46\":16,\"58\":2,\"59\":47,\"64\":1,\"65\":1,\"68\":1,\"70\":29,\"73\":2,\"75\":2,\"76\":14,\"78\":13,\"80\":1,\"81\":2,\"82\":12,\"83\":10,\"92\":34,\"93\":3,\"96\":9,\"98\":2,\"99\":2,\"100\":17,\"101\":4,\"105\":1,\"107\":12,\"108\":4,\"109\":13,\"111\":8,\"112\":1,\"127\":1,\"131\":2,\"142\":2,\"143\":4,\"145\":30,\"146\":3,\"147\":14,\"154\":1,\"155\":1,\"159\":1,\"160\":2,\"161\":10,\"162\":5,\"163\":8,\"169\":1,\"170\":10,\"173\":5,\"178\":1,\"184\":1,\"186\":21,\"187\":1,\"198\":2,\"199\":1,\"202\":1,\"203\":1,\"208\":1,\"210\":2,\"212\":1,\"215\":3,\"216\":2,\"218\":1,\"220\":1,\"222\":1,\"223\":2,\"225\":1,\"227\":3,\"228\":1,\"229\":1,\"230\":1,\"231\":1,\"237\":2,\"248\":1,\"252\":5,\"254\":2,\"255\":2,\"256\":1,\"257\":1,\"262\":1,\"272\":32,\"273\":1,\"274\":1,\"275\":1,\"276\":6,\"277\":13,\"278\":6,\"286\":1,\"289\":2,\"291\":1,\"293\":3,\"295\":12,\"297\":1,\"300\":5,\"302\":4,\"304\":4,\"308\":1,\"309\":7,\"310\":13,\"311\":15,\"312\":20,\"313\":7,\"316\":2,\"317\":2,\"318\":5,\"319\":10,\"320\":10,\"322\":16,\"323\":10,\"324\":2,\"327\":2,\"332\":3,\"333\":5,\"336\":1,\"348\":2,\"355\":4,\"361\":2,\"363\":8,\"364\":19,\"366\":1,\"369\":20,\"370\":2,\"371\":1,\"372\":20,\"373\":4,\"374\":3,\"375\":2,\"376\":1,\"377\":12,\"379\":1,\"385\":3,\"386\":1,\"387\":2,\"391\":2,\"392\":2,\"393\":4,\"395\":1,\"398\":10,\"399\":10,\"401\":6,\"403\":1,\"421\":2,\"422\":4,\"423\":14,\"425\":9,\"426\":17,\"427\":12,\"443\":2,\"444\":1,\"445\":1,\"446\":2,\"448\":2,\"450\":3,\"451\":5,\"453\":1,\"459\":2,\"463\":14,\"467\":7,\"468\":7,\"469\":10,\"470\":11,\"471\":7,\"473\":12,\"476\":18,\"477\":11,\"478\":12,\"499\":1,\"505\":1,\"511\":1,\"512\":1,\"514\":2,\"521\":5,\"522\":8,\"527\":1,\"528\":5,\"529\":2,\"530\":1,\"531\":1,\"536\":3,\"537\":4,\"538\":3,\"539\":3,\"541\":7,\"544\":19,\"545\":1,\"548\":3,\"549\":4,\"550\":2,\"551\":2,\"559\":1,\"560\":1,\"561\":4,\"562\":1,\"566\":1,\"571\":1,\"572\":1,\"573\":9,\"575\":1,\"577\":2,\"578\":1,\"579\":9,\"580\":5,\"581\":8,\"584\":4,\"587\":1,\"590\":36,\"591\":61,\"594\":26,\"596\":1,\"597\":2,\"602\":2,\"603\":6,\"605\":5,\"612\":5,\"614\":6,\"615\":5,\"616\":2,\"617\":6,\"618\":15,\"620\":1,\"624\":1,\"627\":2,\"630\":2,\"632\":15,\"633\":1,\"638\":2,\"647\":1,\"656\":4,\"662\":1,\"676\":1,\"679\":1,\"681\":1,\"686\":2,\"688\":4,\"689\":8,\"690\":9,\"692\":10,\"694\":1,\"696\":12,\"697\":13,\"704\":18,\"728\":4,\"729\":1,\"731\":1,\"738\":1,\"746\":1,\"752\":1,\"758\":2,\"762\":3,\"766\":1,\"767\":1,\"772\":2,\"774\":2,\"793\":1,\"794\":2,\"795\":1,\"798\":2,\"801\":5,\"802\":6,\"803\":4,\"804\":14,\"807\":2,\"809\":1,\"814\":41,\"815\":21,\"816\":4,\"817\":9,\"818\":4,\"819\":2,\"820\":7,\"821\":20,\"822\":7,\"826\":1,\"829\":1,\"839\":5,\"840\":6,\"843\":3,\"845\":1,\"847\":3,\"848\":32,\"854\":3,\"856\":1,\"857\":9,\"860\":1,\"861\":3,\"867\":1,\"868\":1,\"878\":1,\"881\":1,\"885\":6,\"886\":11}}],[\"192\",{\"1\":{\"807\":1}}],[\"198\",{\"1\":{\"541\":1}}],[\"1980\",{\"1\":{\"6\":1}}],[\"1930\",{\"1\":{\"539\":1}}],[\"197\",{\"1\":{\"319\":1,\"320\":1,\"323\":1}}],[\"196+1\",{\"1\":{\"320\":1}}],[\"196\",{\"1\":{\"318\":2,\"319\":1,\"320\":1,\"323\":1}}],[\"196×196\",{\"1\":{\"198\":1,\"208\":1}}],[\"19626\",{\"1\":{\"4\":1}}],[\"190\",{\"1\":{\"83\":3}}],[\"19\",{\"1\":{\"65\":1,\"67\":1,\"69\":1,\"133\":1,\"423\":1,\"692\":1,\"696\":1,\"872\":1}}],[\"1asow2t2mltykaia\",{\"1\":{\"4\":1}}],[\"1n\",{\"1\":{\"4\":1}}],[\"sg\",{\"1\":{\"881\":2}}],[\"sgd\",{\"1\":{\"212\":1,\"252\":2,\"700\":1}}],[\"sleep\",{\"1\":{\"872\":1}}],[\"slice\",{\"0\":{\"425\":1}}],[\"slight\",{\"1\":{\"28\":2}}],[\"s型智能增长曲线\",{\"1\":{\"718\":1}}],[\"srl\",{\"1\":{\"617\":1}}],[\"src\",{\"1\":{\"379\":5,\"544\":1,\"623\":16,\"630\":7,\"631\":2}}],[\"s3\",{\"1\":{\"577\":2}}],[\"s>e\",{\"1\":{\"575\":1}}],[\"s=2\",{\"1\":{\"575\":2}}],[\"s=str\",{\"1\":{\"316\":1}}],[\"sørensen\",{\"1\":{\"467\":1}}],[\"swav\",{\"1\":{\"784\":1}}],[\"swapaxes\",{\"1\":{\"34\":3,\"35\":5,\"36\":5,\"59\":5}}],[\"swiglu\",{\"1\":{\"548\":1,\"704\":4}}],[\"swin\",{\"1\":{\"395\":1}}],[\"snapshot\",{\"1\":{\"302\":1,\"304\":2}}],[\"sst\",{\"1\":{\"515\":4,\"559\":1,\"561\":1}}],[\"ssl\",{\"1\":{\"252\":2}}],[\"ssg\",{\"1\":{\"93\":3}}],[\"sft\",{\"1\":{\"198\":1,\"210\":1,\"535\":1,\"537\":6,\"538\":1,\"539\":1,\"704\":1}}],[\"s的k\",{\"1\":{\"181\":1}}],[\"smooth\",{\"0\":{\"797\":1},\"1\":{\"467\":4,\"468\":3,\"469\":3,\"470\":1,\"471\":3,\"473\":3,\"793\":5,\"797\":3,\"821\":6}}],[\"smooth=1\",{\"1\":{\"467\":1,\"468\":1,\"469\":1,\"470\":1,\"471\":1,\"473\":1}}],[\"smoothing=0\",{\"1\":{\"295\":1,\"310\":2,\"312\":1,\"581\":2}}],[\"smoothing\",{\"1\":{\"163\":1,\"395\":1}}],[\"small\",{\"1\":{\"82\":1,\"591\":2}}],[\"sbucaptiondatamodule\",{\"1\":{\"274\":1}}],[\"sbu\",{\"1\":{\"131\":1,\"140\":1,\"274\":1}}],[\"symb\",{\"1\":{\"578\":2}}],[\"symbol\",{\"1\":{\"541\":1}}],[\"symbols\",{\"1\":{\"476\":4,\"478\":4}}],[\"symlinks=false\",{\"1\":{\"302\":1,\"304\":1}}],[\"symmetric\",{\"1\":{\"105\":1,\"115\":1}}],[\"sync\",{\"1\":{\"170\":1}}],[\"systematic\",{\"1\":{\"301\":1,\"488\":1}}],[\"sys\",{\"1\":{\"83\":3,\"599\":1,\"609\":1,\"803\":1}}],[\"squad和race任务上实现了sota性能\",{\"1\":{\"569\":1}}],[\"squad和race等任务上达到了新的\",{\"1\":{\"562\":1}}],[\"squad\",{\"1\":{\"537\":1,\"538\":1,\"539\":1,\"559\":2,\"561\":1,\"565\":2,\"566\":1,\"616\":1}}],[\"squadv2\",{\"1\":{\"529\":1}}],[\"squaretest\",{\"1\":{\"675\":1,\"676\":1}}],[\"square\",{\"1\":{\"92\":1,\"100\":1,\"643\":1,\"644\":2,\"647\":2,\"661\":1,\"671\":2,\"675\":2,\"676\":2,\"685\":3,\"688\":7}}],[\"squeeze\",{\"1\":{\"70\":1,\"83\":1,\"310\":2,\"614\":2,\"615\":2,\"848\":2,\"857\":3,\"861\":1,\"886\":2}}],[\"sqrdists\",{\"1\":{\"92\":2}}],[\"sqrt\",{\"1\":{\"83\":1,\"272\":1,\"293\":1,\"312\":1,\"590\":1,\"605\":1,\"632\":1,\"801\":2,\"821\":1}}],[\"soap\",{\"1\":{\"754\":1}}],[\"sonnet\",{\"1\":{\"704\":4}}],[\"sometimes\",{\"1\":{\"615\":1}}],[\"someone\",{\"1\":{\"346\":3}}],[\"southampton\",{\"1\":{\"593\":1}}],[\"source\",{\"1\":{\"214\":2,\"327\":1,\"439\":1}}],[\"source=chatgpt\",{\"1\":{\"140\":1}}],[\"solaiman\",{\"1\":{\"536\":1}}],[\"solarization\",{\"1\":{\"179\":1,\"186\":1}}],[\"sol\",{\"1\":{\"477\":2,\"478\":3}}],[\"solely\",{\"1\":{\"78\":1}}],[\"so\",{\"1\":{\"170\":1}}],[\"sota\",{\"1\":{\"112\":1,\"138\":1,\"198\":1,\"202\":1,\"203\":1,\"235\":1,\"236\":1,\"522\":1,\"559\":1}}],[\"sorted\",{\"1\":{\"68\":1,\"339\":1,\"476\":1,\"478\":1}}],[\"sort\",{\"1\":{\"68\":5,\"92\":1,\"100\":1,\"316\":1,\"463\":1,\"686\":1,\"688\":1,\"696\":1}}],[\"softtarget\",{\"1\":{\"395\":1}}],[\"soft\",{\"1\":{\"64\":1,\"78\":2,\"82\":10,\"145\":1,\"147\":3,\"157\":1,\"159\":4,\"161\":3,\"162\":1,\"163\":13,\"176\":1,\"467\":1,\"468\":2,\"469\":1,\"470\":1,\"794\":4,\"795\":2,\"796\":10,\"821\":2}}],[\"softmax的采样过程分为两步\",{\"1\":{\"795\":1}}],[\"softmax归一化得到注意力概率\",{\"1\":{\"312\":1}}],[\"softmax\",{\"0\":{\"795\":1},\"1\":{\"32\":2,\"41\":5,\"45\":3,\"59\":2,\"93\":1,\"96\":1,\"98\":2,\"101\":2,\"110\":2,\"111\":2,\"115\":2,\"145\":6,\"147\":6,\"154\":1,\"156\":1,\"157\":1,\"160\":1,\"161\":4,\"162\":2,\"163\":3,\"178\":1,\"186\":3,\"248\":7,\"254\":1,\"272\":2,\"278\":2,\"293\":2,\"300\":1,\"311\":2,\"312\":1,\"322\":1,\"408\":1,\"418\":1,\"419\":1,\"463\":1,\"470\":2,\"512\":1,\"575\":1,\"584\":1,\"590\":1,\"591\":1,\"605\":1,\"614\":3,\"622\":1,\"624\":1,\"632\":1,\"766\":1,\"770\":1,\"772\":1,\"776\":2,\"793\":1,\"794\":3,\"795\":7,\"796\":7,\"798\":2,\"808\":1,\"817\":2,\"819\":1,\"820\":2,\"821\":12,\"843\":1,\"848\":3,\"886\":1}}],[\"sandwich\",{\"1\":{\"814\":4}}],[\"sanh\",{\"1\":{\"536\":1}}],[\"say\",{\"1\":{\"343\":5,\"346\":3}}],[\"saucer\",{\"1\":{\"300\":1}}],[\"sacred\",{\"1\":{\"271\":1}}],[\"saturation=0\",{\"1\":{\"186\":1}}],[\"sam\",{\"1\":{\"220\":1}}],[\"same\",{\"1\":{\"145\":2,\"610\":1,\"632\":1}}],[\"sampling=false\",{\"1\":{\"313\":1}}],[\"sampling\",{\"0\":{\"89\":1,\"819\":1},\"1\":{\"59\":2,\"88\":2,\"89\":1,\"92\":1,\"98\":1,\"133\":2,\"143\":1,\"248\":1,\"313\":2,\"819\":1}}],[\"sampler=sampler\",{\"1\":{\"803\":1}}],[\"sampler=self\",{\"1\":{\"274\":3}}],[\"sampler=train\",{\"1\":{\"252\":1,\"596\":1}}],[\"sampler\",{\"1\":{\"252\":2,\"274\":9,\"403\":1,\"596\":2}}],[\"samplers\",{\"1\":{\"142\":1,\"145\":1,\"147\":1}}],[\"sample=use\",{\"1\":{\"313\":1}}],[\"sample=true\",{\"1\":{\"143\":1}}],[\"sample=false\",{\"1\":{\"143\":1}}],[\"sampled\",{\"1\":{\"92\":6,\"96\":1,\"794\":2,\"821\":2,\"848\":2,\"886\":2}}],[\"samples=len\",{\"1\":{\"403\":1}}],[\"samples\",{\"1\":{\"82\":1,\"92\":1,\"170\":9,\"309\":3,\"313\":2,\"403\":3,\"803\":4,\"840\":2,\"848\":6}}],[\"sample\",{\"1\":{\"28\":1,\"29\":6,\"35\":6,\"46\":6,\"58\":3,\"59\":6,\"70\":11,\"76\":7,\"87\":1,\"92\":14,\"96\":2,\"143\":2,\"170\":1,\"316\":1,\"323\":1,\"403\":2,\"579\":7,\"696\":3,\"817\":4,\"819\":1,\"820\":3,\"840\":3,\"857\":5,\"886\":7}}],[\"salesforce\",{\"1\":{\"119\":1,\"140\":1,\"148\":1,\"306\":1,\"577\":1}}],[\"sa4\",{\"1\":{\"101\":2}}],[\"sa3\",{\"1\":{\"93\":2,\"96\":2,\"101\":2}}],[\"sa\",{\"1\":{\"93\":1,\"99\":3,\"101\":1,\"126\":4,\"134\":2}}],[\"saved\",{\"1\":{\"578\":3,\"581\":1}}],[\"save\",{\"1\":{\"82\":2,\"302\":3,\"304\":3,\"312\":3,\"366\":1,\"476\":1,\"478\":1,\"581\":1,\"593\":1,\"840\":2,\"848\":2,\"885\":1,\"886\":1}}],[\"sa1\",{\"1\":{\"46\":1,\"59\":1,\"70\":1,\"93\":2,\"96\":2,\"101\":2}}],[\"sa2\",{\"1\":{\"46\":1,\"59\":1,\"70\":1,\"93\":2,\"96\":2,\"101\":2}}],[\"sv\",{\"1\":{\"45\":2}}],[\"sklearn\",{\"1\":{\"398\":2,\"399\":2}}],[\"skip\",{\"1\":{\"98\":1,\"100\":1,\"143\":1,\"313\":1,\"616\":2}}],[\"sk\",{\"1\":{\"45\":2}}],[\"skateboard\",{\"1\":{\"29\":1}}],[\"scikit\",{\"0\":{\"397\":1},\"1\":{\"399\":1}}],[\"science\",{\"1\":{\"235\":1}}],[\"scienceqa\",{\"1\":{\"235\":2,\"236\":1}}],[\"scissors\",{\"1\":{\"29\":1,\"58\":1,\"63\":2,\"68\":1}}],[\"scao\",{\"1\":{\"552\":1}}],[\"scalar\",{\"1\":{\"470\":1}}],[\"scaling\",{\"1\":{\"187\":1,\"488\":1,\"527\":1,\"528\":1,\"531\":2,\"539\":1,\"703\":7}}],[\"scaler\",{\"1\":{\"803\":3}}],[\"scaleai\",{\"1\":{\"537\":1}}],[\"scaleddotproductattention\",{\"1\":{\"584\":1}}],[\"scaled\",{\"1\":{\"405\":1,\"632\":1}}],[\"scale未指定\",{\"1\":{\"322\":1}}],[\"scale=cond\",{\"1\":{\"817\":1}}],[\"scale=qk\",{\"1\":{\"272\":2,\"321\":1,\"323\":1}}],[\"scale=none\",{\"1\":{\"272\":3,\"320\":1,\"321\":1,\"322\":1,\"323\":1}}],[\"scale=\",{\"1\":{\"252\":1}}],[\"scale=local\",{\"1\":{\"186\":1}}],[\"scale=global\",{\"1\":{\"186\":2}}],[\"scale=0\",{\"1\":{\"147\":1}}],[\"scales\",{\"1\":{\"98\":1}}],[\"scale\",{\"0\":{\"95\":1},\"1\":{\"32\":2,\"41\":2,\"45\":3,\"59\":5,\"83\":2,\"93\":1,\"94\":1,\"96\":1,\"186\":18,\"272\":13,\"277\":21,\"321\":1,\"322\":3,\"323\":1,\"388\":5,\"463\":3,\"485\":1,\"488\":1,\"815\":1,\"816\":5,\"817\":3}}],[\"scatter\",{\"0\":{\"379\":1},\"1\":{\"170\":2,\"379\":1,\"818\":2}}],[\"schema\",{\"0\":{\"283\":1},\"1\":{\"522\":1,\"529\":1}}],[\"schedule\",{\"1\":{\"186\":8,\"803\":6}}],[\"scheduler=none\",{\"1\":{\"803\":1}}],[\"scheduler\",{\"1\":{\"80\":4,\"159\":1,\"186\":3,\"395\":1}}],[\"schuhmann\",{\"1\":{\"131\":1}}],[\"scores\",{\"1\":{\"162\":5,\"163\":6,\"293\":11,\"295\":7,\"312\":20,\"584\":4,\"590\":2,\"591\":7,\"605\":12,\"611\":2,\"612\":4,\"614\":4,\"617\":1,\"632\":4,\"817\":2}}],[\"score\",{\"1\":{\"46\":3,\"78\":1,\"82\":5,\"232\":1,\"276\":2,\"278\":1,\"310\":2,\"311\":2,\"459\":1,\"467\":2,\"468\":2,\"469\":4,\"473\":4,\"590\":5,\"611\":2,\"612\":4}}],[\"scene\",{\"1\":{\"45\":8,\"59\":7}}],[\"sudo\",{\"1\":{\"696\":1}}],[\"sunflowers\",{\"1\":{\"303\":1,\"304\":1}}],[\"survey\",{\"1\":{\"301\":1,\"488\":1,\"718\":2}}],[\"surfboard\",{\"1\":{\"29\":1}}],[\"suite\",{\"1\":{\"274\":4}}],[\"suites\",{\"1\":{\"214\":2}}],[\"suitcase\",{\"1\":{\"29\":1}}],[\"successfully\",{\"1\":{\"302\":1,\"304\":1}}],[\"successful\",{\"1\":{\"63\":1}}],[\"subplot\",{\"1\":{\"886\":1}}],[\"subplots\",{\"1\":{\"857\":2,\"861\":1}}],[\"subprocess\",{\"1\":{\"696\":1}}],[\"sublayer是传入的参数\",{\"1\":{\"626\":1}}],[\"sublayer\",{\"1\":{\"626\":3,\"627\":3,\"630\":4}}],[\"sublayerconnection模型结构图\",{\"1\":{\"626\":1}}],[\"sublayerconnection\",{\"0\":{\"626\":1},\"1\":{\"626\":2,\"627\":1,\"630\":1}}],[\"subword\",{\"1\":{\"476\":4,\"478\":2}}],[\"subtract\",{\"1\":{\"401\":1}}],[\"subset的对齐分数\",{\"1\":{\"285\":1}}],[\"subset和visual\",{\"1\":{\"285\":1}}],[\"subject\",{\"1\":{\"58\":2,\"59\":1}}],[\"sub\",{\"1\":{\"45\":8,\"58\":5,\"59\":24,\"302\":5,\"304\":5,\"425\":1,\"476\":1,\"478\":1,\"690\":9}}],[\"summation\",{\"1\":{\"76\":1,\"115\":1,\"367\":1}}],[\"sum\",{\"1\":{\"43\":1,\"70\":2,\"76\":4,\"78\":6,\"81\":1,\"82\":3,\"83\":1,\"92\":1,\"100\":2,\"115\":1,\"145\":3,\"147\":2,\"161\":2,\"163\":1,\"170\":8,\"186\":1,\"255\":1,\"275\":1,\"295\":1,\"312\":1,\"316\":1,\"323\":1,\"367\":1,\"373\":1,\"463\":1,\"467\":3,\"468\":9,\"469\":2,\"471\":3,\"473\":3,\"799\":1,\"801\":1,\"854\":3,\"885\":2}}],[\"suptitle\",{\"1\":{\"857\":1,\"886\":1}}],[\"supplied\",{\"1\":{\"815\":1}}],[\"suppose\",{\"1\":{\"584\":1}}],[\"supported\",{\"1\":{\"316\":2,\"673\":1,\"686\":1,\"689\":1}}],[\"support\",{\"1\":{\"29\":1,\"58\":1,\"68\":1}}],[\"superglue整体表现良好\",{\"1\":{\"529\":1}}],[\"supervision\",{\"1\":{\"279\":2}}],[\"supervised\",{\"1\":{\"172\":2,\"198\":1,\"232\":1,\"305\":1,\"483\":1,\"537\":1}}],[\"super\",{\"1\":{\"29\":1,\"34\":2,\"35\":2,\"36\":2,\"41\":1,\"45\":2,\"46\":1,\"58\":1,\"59\":6,\"73\":1,\"78\":1,\"92\":1,\"93\":1,\"96\":2,\"100\":1,\"101\":1,\"107\":1,\"109\":1,\"110\":1,\"111\":1,\"142\":1,\"147\":1,\"160\":1,\"169\":1,\"170\":2,\"186\":2,\"254\":1,\"272\":4,\"274\":4,\"289\":1,\"292\":1,\"295\":1,\"318\":1,\"319\":1,\"320\":1,\"321\":2,\"322\":1,\"323\":1,\"467\":1,\"468\":1,\"469\":1,\"470\":1,\"471\":1,\"473\":1,\"580\":1,\"590\":1,\"591\":1,\"597\":1,\"599\":3,\"600\":1,\"601\":1,\"602\":1,\"603\":1,\"605\":1,\"606\":1,\"607\":1,\"609\":1,\"610\":1,\"611\":1,\"612\":1,\"615\":1,\"617\":1,\"618\":1,\"623\":1,\"624\":1,\"626\":1,\"627\":1,\"628\":1,\"630\":1,\"631\":1,\"632\":1,\"793\":1,\"804\":1,\"821\":1,\"822\":1,\"840\":2,\"848\":3,\"853\":1,\"859\":1,\"885\":4,\"886\":3}}],[\"s\",{\"1\":{\"28\":8,\"31\":6,\"45\":4,\"59\":8,\"92\":16,\"96\":8,\"100\":11,\"105\":1,\"145\":1,\"179\":1,\"181\":5,\"184\":1,\"316\":1,\"327\":1,\"353\":1,\"476\":2,\"478\":2,\"500\":1,\"521\":3,\"522\":1,\"539\":3,\"541\":2,\"575\":2,\"594\":1,\"758\":1,\"771\":1,\"840\":2}}],[\"shells\",{\"0\":{\"753\":1}}],[\"shell=true\",{\"1\":{\"696\":1}}],[\"shinyapps\",{\"1\":{\"735\":1}}],[\"shift\",{\"1\":{\"814\":4}}],[\"shift到\",{\"1\":{\"590\":1}}],[\"shifted\",{\"1\":{\"295\":2,\"312\":3}}],[\"shuffle\",{\"1\":{\"222\":1,\"255\":3,\"398\":1,\"579\":3}}],[\"shuffle=\",{\"1\":{\"252\":1}}],[\"shuffle=false\",{\"1\":{\"80\":2,\"274\":3,\"317\":1,\"398\":1}}],[\"shuffle=true\",{\"1\":{\"80\":1,\"186\":1,\"274\":3,\"317\":1,\"398\":3,\"581\":1,\"840\":1,\"848\":1,\"855\":1,\"885\":1}}],[\"show\",{\"1\":{\"303\":1,\"304\":1,\"316\":1,\"697\":1,\"857\":2,\"861\":1,\"886\":1}}],[\"shown\",{\"1\":{\"28\":2}}],[\"shot条件下进行全面评估的工作\",{\"1\":{\"531\":1}}],[\"shot模型\",{\"1\":{\"531\":1}}],[\"shot能力会随着模型规模的增加而显著增强\",{\"1\":{\"531\":1}}],[\"shot能力主要依赖于识别任务格式和输出模式\",{\"1\":{\"530\":1}}],[\"shot效果难以稳定复现\",{\"1\":{\"530\":1}}],[\"shot情境下\",{\"1\":{\"529\":1}}],[\"shot元学习能力\",{\"1\":{\"529\":1}}],[\"shot得分\",{\"1\":{\"529\":1}}],[\"shot得分达到77\",{\"1\":{\"529\":1}}],[\"shot得分达到71\",{\"1\":{\"529\":1}}],[\"shot翻译任务中\",{\"1\":{\"529\":1}}],[\"shot优势\",{\"1\":{\"529\":1}}],[\"shot设定就达到了与微调sota模型相当甚至更优的水平\",{\"1\":{\"529\":1}}],[\"shot设定下均展示了强大的任务适应能力\",{\"1\":{\"529\":1}}],[\"shot设定下稍高于随机水平\",{\"1\":{\"529\":1}}],[\"shot设定下表现优异\",{\"1\":{\"529\":1}}],[\"shot设定下\",{\"1\":{\"528\":1}}],[\"shot设定下的表现令人惊喜\",{\"1\":{\"528\":1}}],[\"shot设置下准确率达到86\",{\"1\":{\"529\":1}}],[\"shot图文生成\",{\"1\":{\"308\":1}}],[\"shot图像分类\",{\"1\":{\"300\":1}}],[\"shot性能评估\",{\"1\":{\"305\":1}}],[\"shot性能\",{\"1\":{\"305\":1}}],[\"shot迁移到下游任务\",{\"1\":{\"305\":1}}],[\"shot学习方面展现出极强的能力\",{\"1\":{\"530\":1}}],[\"shot学习的启发\",{\"1\":{\"531\":1}}],[\"shot学习的\",{\"1\":{\"530\":1}}],[\"shot学习中可用的示例数量\",{\"1\":{\"530\":1}}],[\"shot学习\",{\"1\":{\"305\":1,\"531\":1}}],[\"shot推理\",{\"1\":{\"302\":1}}],[\"shot分类时\",{\"1\":{\"301\":1}}],[\"shot分类的过程相当直接\",{\"1\":{\"300\":1}}],[\"shot\",{\"1\":{\"202\":2,\"232\":1,\"307\":1,\"507\":1,\"519\":1,\"522\":1,\"525\":1,\"527\":3,\"528\":3,\"531\":2,\"537\":2,\"538\":2,\"549\":3,\"550\":1,\"805\":1,\"812\":1}}],[\"should\",{\"1\":{\"83\":3}}],[\"shannon\",{\"0\":{\"833\":1}}],[\"shaw\",{\"0\":{\"590\":1},\"1\":{\"590\":3,\"591\":3}}],[\"shamir\",{\"1\":{\"385\":1}}],[\"share\",{\"1\":{\"814\":2}}],[\"sharedembedding\",{\"1\":{\"814\":2}}],[\"shared\",{\"1\":{\"268\":1,\"580\":4,\"814\":6}}],[\"sharegpt4v\",{\"1\":{\"225\":1}}],[\"sharpening\",{\"1\":{\"173\":1,\"178\":1,\"183\":1,\"186\":1}}],[\"shape=\",{\"1\":{\"814\":1,\"886\":1}}],[\"shape=self\",{\"1\":{\"801\":1}}],[\"shape=box\",{\"1\":{\"696\":4}}],[\"shape=box可将节点设为矩形\",{\"1\":{\"696\":1}}],[\"shape为\",{\"1\":{\"318\":1,\"428\":1}}],[\"shape的形状从\",{\"1\":{\"92\":1}}],[\"shape\",{\"1\":{\"35\":1,\"40\":8,\"68\":6,\"82\":11,\"83\":2,\"92\":15,\"93\":1,\"96\":2,\"98\":1,\"100\":2,\"107\":3,\"109\":3,\"111\":4,\"145\":3,\"162\":1,\"163\":4,\"170\":6,\"186\":1,\"255\":1,\"257\":1,\"272\":12,\"276\":2,\"293\":2,\"309\":1,\"311\":1,\"312\":2,\"313\":1,\"318\":1,\"319\":1,\"320\":1,\"322\":1,\"323\":2,\"355\":2,\"358\":1,\"361\":2,\"362\":1,\"364\":4,\"370\":1,\"398\":2,\"415\":1,\"421\":1,\"423\":2,\"425\":2,\"427\":3,\"463\":8,\"470\":1,\"544\":10,\"580\":7,\"590\":3,\"591\":9,\"605\":4,\"618\":1,\"689\":3,\"696\":1,\"794\":4,\"801\":1,\"803\":1,\"804\":2,\"814\":2,\"815\":11,\"817\":2,\"818\":1,\"820\":3,\"821\":4,\"822\":5,\"840\":5,\"848\":2,\"885\":4,\"886\":2}}],[\"shao\",{\"1\":{\"4\":1}}],[\"spherical\",{\"1\":{\"752\":1}}],[\"sphere\",{\"1\":{\"692\":2}}],[\"sphere函数求导\",{\"1\":{\"692\":1}}],[\"spurious\",{\"1\":{\"527\":1}}],[\"span\",{\"1\":{\"614\":1,\"616\":2}}],[\"sparse\",{\"1\":{\"528\":1,\"814\":3,\"873\":1}}],[\"space\",{\"1\":{\"478\":1,\"840\":1,\"878\":1}}],[\"spacy\",{\"1\":{\"234\":1,\"514\":1}}],[\"spatial\",{\"1\":{\"40\":5,\"45\":3,\"107\":1,\"846\":2}}],[\"special\",{\"1\":{\"143\":1,\"313\":1,\"594\":6,\"616\":2}}],[\"speak\",{\"1\":{\"29\":1}}],[\"spidercnn\",{\"1\":{\"112\":2}}],[\"spoon\",{\"1\":{\"29\":1}}],[\"spout\",{\"1\":{\"24\":1,\"28\":6,\"31\":2}}],[\"splitext\",{\"1\":{\"302\":1,\"304\":1,\"316\":1,\"696\":1}}],[\"split=\",{\"1\":{\"68\":1,\"274\":7}}],[\"split\",{\"0\":{\"398\":1},\"1\":{\"28\":1,\"29\":8,\"40\":2,\"46\":4,\"58\":6,\"59\":4,\"68\":5,\"274\":9,\"302\":1,\"304\":1,\"316\":1,\"317\":1,\"398\":4,\"476\":2,\"478\":2,\"544\":2,\"577\":1,\"614\":2,\"615\":1}}],[\"spring\",{\"1\":{\"2\":1}}],[\"siri\",{\"1\":{\"708\":1}}],[\"sin\",{\"1\":{\"587\":1,\"695\":1}}],[\"sinusoidal\",{\"0\":{\"587\":1},\"1\":{\"587\":1}}],[\"single\",{\"1\":{\"93\":1}}],[\"silhouette\",{\"1\":{\"300\":1}}],[\"sig\",{\"1\":{\"476\":1,\"477\":1,\"478\":1}}],[\"sigma\",{\"1\":{\"385\":1,\"728\":3}}],[\"sigmoid\",{\"1\":{\"15\":1,\"35\":3,\"46\":3,\"59\":3,\"70\":1,\"76\":3,\"78\":1,\"98\":1,\"467\":3,\"468\":4,\"469\":4,\"470\":3,\"471\":3,\"473\":1,\"840\":1,\"853\":1,\"859\":1,\"885\":1}}],[\"siglip\",{\"1\":{\"220\":2}}],[\"sign\",{\"1\":{\"82\":1}}],[\"side\",{\"1\":{\"40\":2}}],[\"size和较小的学习率\",{\"1\":{\"528\":1}}],[\"size的四倍\",{\"1\":{\"324\":1}}],[\"size是transformer\",{\"1\":{\"324\":1}}],[\"size就是对应通过embedding层后每个token的dim\",{\"1\":{\"324\":1}}],[\"size也是同样处理手段\",{\"1\":{\"309\":1}}],[\"size\",{\"1\":{\"29\":4,\"30\":1,\"36\":1,\"40\":6,\"41\":1,\"42\":2,\"43\":12,\"44\":3,\"45\":4,\"46\":3,\"58\":4,\"59\":13,\"70\":1,\"80\":3,\"83\":2,\"107\":3,\"108\":2,\"109\":1,\"111\":2,\"142\":6,\"143\":2,\"145\":14,\"146\":3,\"147\":12,\"160\":9,\"161\":3,\"162\":2,\"163\":6,\"169\":5,\"170\":13,\"175\":1,\"178\":1,\"185\":4,\"186\":8,\"246\":2,\"252\":2,\"254\":1,\"257\":4,\"272\":33,\"274\":27,\"276\":6,\"278\":9,\"289\":2,\"292\":3,\"293\":3,\"295\":8,\"302\":4,\"304\":4,\"309\":6,\"310\":8,\"311\":10,\"312\":7,\"313\":4,\"316\":1,\"317\":2,\"318\":24,\"319\":4,\"320\":2,\"322\":10,\"323\":4,\"355\":1,\"364\":3,\"369\":1,\"376\":2,\"378\":2,\"388\":1,\"398\":4,\"421\":1,\"423\":1,\"463\":8,\"467\":4,\"468\":3,\"469\":3,\"470\":4,\"471\":5,\"473\":5,\"541\":1,\"544\":1,\"578\":3,\"580\":19,\"581\":2,\"584\":1,\"590\":1,\"591\":1,\"596\":1,\"597\":7,\"599\":5,\"601\":2,\"603\":1,\"605\":15,\"606\":3,\"609\":3,\"610\":3,\"611\":1,\"612\":1,\"614\":12,\"615\":3,\"617\":2,\"618\":13,\"626\":2,\"627\":4,\"628\":1,\"630\":4,\"631\":1,\"632\":3,\"689\":4,\"774\":1,\"793\":8,\"794\":2,\"801\":5,\"802\":3,\"803\":2,\"804\":26,\"814\":11,\"815\":5,\"817\":6,\"821\":11,\"822\":11,\"840\":12,\"848\":8,\"886\":2}}],[\"size=7\",{\"1\":{\"886\":1}}],[\"size=768\",{\"1\":{\"327\":1}}],[\"size=opt\",{\"1\":{\"840\":1}}],[\"size=hidden\",{\"1\":{\"793\":2}}],[\"size=4\",{\"1\":{\"793\":2,\"821\":2}}],[\"size=32\",{\"1\":{\"581\":1}}],[\"size=384\",{\"1\":{\"145\":1}}],[\"size=0\",{\"1\":{\"398\":2}}],[\"size=64\",{\"1\":{\"302\":2,\"304\":2,\"848\":1}}],[\"size=none\",{\"1\":{\"274\":1,\"320\":1,\"323\":1,\"388\":1,\"398\":2}}],[\"size=self\",{\"1\":{\"274\":11}}],[\"size=img\",{\"1\":{\"272\":1,\"319\":1,\"320\":1,\"323\":1}}],[\"size=patch\",{\"1\":{\"272\":2,\"318\":1,\"319\":1,\"320\":1,\"323\":1,\"804\":1}}],[\"size=args\",{\"1\":{\"186\":3,\"252\":1,\"596\":1,\"802\":2,\"803\":2}}],[\"size=224\",{\"1\":{\"147\":1,\"272\":2,\"318\":1,\"319\":1,\"320\":1,\"323\":1,\"327\":1,\"804\":1}}],[\"size=57600\",{\"1\":{\"145\":1,\"147\":1}}],[\"size=config\",{\"1\":{\"142\":1,\"145\":2,\"147\":2,\"160\":2}}],[\"size=128\",{\"1\":{\"855\":1,\"885\":1}}],[\"size=16\",{\"1\":{\"160\":2,\"272\":2,\"318\":1,\"319\":1,\"320\":1,\"323\":1,\"327\":1,\"593\":2,\"804\":1}}],[\"size=1\",{\"1\":{\"107\":1,\"793\":2,\"821\":3,\"848\":1}}],[\"size=10\",{\"1\":{\"80\":1}}],[\"size=batch\",{\"1\":{\"80\":3,\"274\":1,\"317\":2}}],[\"size=\",{\"1\":{\"29\":1,\"58\":1,\"59\":3,\"142\":1,\"145\":1,\"147\":1}}],[\"site\",{\"1\":{\"438\":1}}],[\"sit\",{\"1\":{\"29\":1,\"58\":1,\"68\":1,\"83\":2}}],[\"simply\",{\"1\":{\"601\":1}}],[\"simplicity\",{\"1\":{\"257\":1}}],[\"similarities\",{\"1\":{\"302\":2,\"303\":2,\"304\":4}}],[\"similarity\",{\"1\":{\"22\":1,\"82\":3,\"299\":1,\"300\":1,\"302\":2,\"303\":1,\"304\":3,\"310\":4,\"391\":1,\"515\":1}}],[\"simclr\",{\"1\":{\"248\":1,\"250\":2,\"784\":1,\"802\":1}}],[\"sim\",{\"1\":{\"22\":1,\"23\":1,\"75\":1,\"82\":16,\"145\":20,\"146\":2,\"147\":20,\"161\":18,\"162\":3,\"169\":1,\"170\":5,\"278\":4,\"310\":13,\"311\":4,\"822\":5}}],[\"segments\",{\"1\":{\"580\":3}}],[\"segment\",{\"1\":{\"560\":1,\"562\":1,\"573\":1,\"579\":3,\"580\":1,\"581\":2,\"594\":1}}],[\"segmentation\",{\"0\":{\"777\":1},\"1\":{\"60\":3,\"78\":1,\"82\":1,\"201\":1,\"300\":1,\"597\":1}}],[\"sense\",{\"1\":{\"549\":1}}],[\"sentiment\",{\"1\":{\"515\":1}}],[\"sent\",{\"1\":{\"476\":1,\"477\":1,\"478\":2,\"577\":1,\"578\":4}}],[\"sentences格式\",{\"1\":{\"562\":1}}],[\"sentences\",{\"1\":{\"476\":2,\"478\":2,\"562\":3,\"564\":3,\"577\":7,\"578\":4,\"579\":11}}],[\"sentence\",{\"0\":{\"573\":1},\"1\":{\"28\":1,\"143\":1,\"312\":1,\"476\":2,\"478\":2,\"521\":3,\"562\":1,\"564\":1,\"571\":1,\"594\":1,\"612\":5}}],[\"seem\",{\"1\":{\"605\":1}}],[\"seed\",{\"1\":{\"316\":1}}],[\"seen\",{\"1\":{\"20\":1,\"23\":2,\"29\":2,\"58\":2,\"65\":1,\"544\":3,\"686\":3,\"688\":3,\"696\":3}}],[\"separation\",{\"1\":{\"385\":1}}],[\"separated\",{\"1\":{\"478\":1}}],[\"separate\",{\"1\":{\"268\":1}}],[\"sep\",{\"1\":{\"143\":3,\"263\":1,\"313\":1,\"560\":1,\"573\":7,\"575\":1,\"578\":2,\"579\":9,\"580\":1,\"594\":11,\"614\":2,\"616\":2,\"618\":2}}],[\"search输出\",{\"1\":{\"528\":1}}],[\"search扩展\",{\"1\":{\"313\":1}}],[\"search的beam数量\",{\"1\":{\"313\":1}}],[\"searchpicbytext\",{\"1\":{\"303\":1,\"304\":1}}],[\"search\",{\"1\":{\"133\":3,\"143\":2,\"313\":1}}],[\"setr\",{\"1\":{\"777\":1}}],[\"set避免重复处理节点\",{\"1\":{\"696\":1}}],[\"setitem\",{\"1\":{\"689\":1}}],[\"setattr\",{\"1\":{\"688\":2}}],[\"setup\",{\"0\":{\"774\":1},\"1\":{\"273\":1,\"274\":13,\"691\":4}}],[\"sets\",{\"1\":{\"115\":1}}],[\"set\",{\"1\":{\"68\":6,\"88\":1,\"93\":1,\"97\":1,\"98\":4,\"99\":1,\"101\":2,\"105\":1,\"112\":2,\"115\":1,\"274\":7,\"275\":2,\"578\":1,\"664\":2,\"681\":1,\"686\":7,\"688\":5,\"696\":4,\"753\":1,\"814\":1,\"820\":1,\"857\":2}}],[\"setting\",{\"0\":{\"22\":1},\"1\":{\"23\":2,\"29\":2,\"58\":2}}],[\"seq\",{\"1\":{\"45\":1,\"276\":3,\"295\":1,\"309\":6,\"310\":5,\"311\":13,\"312\":1,\"369\":1,\"463\":2,\"541\":1,\"544\":5,\"579\":3,\"580\":6,\"584\":10,\"593\":1,\"597\":2,\"605\":2,\"611\":4,\"612\":4,\"614\":4,\"615\":4,\"617\":2,\"618\":4,\"632\":1,\"804\":2,\"814\":40,\"815\":15,\"817\":20,\"820\":7,\"821\":2,\"822\":5}}],[\"sequences\",{\"1\":{\"415\":1,\"594\":2,\"623\":1}}],[\"sequences=1\",{\"1\":{\"143\":1}}],[\"sequence\",{\"1\":{\"43\":2,\"163\":2,\"289\":2,\"295\":2,\"312\":2,\"594\":4,\"602\":3,\"611\":2,\"612\":2,\"614\":3,\"615\":2,\"617\":4}}],[\"sequential\",{\"1\":{\"34\":2,\"35\":3,\"36\":2,\"41\":1,\"42\":1,\"44\":1,\"45\":1,\"46\":1,\"59\":4,\"73\":2,\"98\":1,\"323\":2,\"793\":5,\"814\":1,\"821\":5,\"840\":2,\"886\":1}}],[\"semantic\",{\"0\":{\"777\":1},\"1\":{\"40\":4,\"45\":3,\"98\":1,\"201\":1,\"515\":1}}],[\"selection\",{\"1\":{\"398\":2}}],[\"select\",{\"1\":{\"29\":1,\"145\":2,\"147\":2}}],[\"sele\",{\"1\":{\"29\":2}}],[\"self指代右操作数b\",{\"1\":{\"690\":1}}],[\"self指代左操作数a\",{\"1\":{\"690\":1}}],[\"self和other是两个关键入参\",{\"1\":{\"690\":2}}],[\"selfattention\",{\"1\":{\"463\":1}}],[\"self\",{\"0\":{\"502\":1,\"542\":1,\"543\":1},\"1\":{\"29\":49,\"30\":8,\"32\":11,\"33\":5,\"34\":13,\"35\":29,\"36\":30,\"40\":18,\"41\":32,\"42\":7,\"43\":1,\"44\":6,\"45\":40,\"46\":20,\"58\":45,\"59\":90,\"68\":21,\"70\":10,\"72\":8,\"73\":10,\"74\":10,\"75\":5,\"76\":17,\"78\":9,\"92\":17,\"93\":25,\"96\":41,\"100\":9,\"101\":27,\"107\":26,\"109\":24,\"110\":19,\"111\":24,\"126\":2,\"142\":23,\"143\":9,\"145\":59,\"146\":15,\"147\":57,\"160\":35,\"161\":17,\"162\":14,\"163\":14,\"169\":17,\"170\":50,\"172\":2,\"173\":1,\"175\":1,\"176\":1,\"186\":34,\"252\":5,\"254\":13,\"255\":9,\"256\":5,\"257\":6,\"268\":2,\"272\":104,\"274\":122,\"275\":20,\"276\":10,\"277\":28,\"278\":2,\"289\":11,\"290\":5,\"291\":4,\"292\":14,\"293\":14,\"294\":1,\"295\":22,\"309\":9,\"310\":4,\"311\":12,\"312\":49,\"313\":7,\"316\":12,\"318\":12,\"319\":16,\"320\":22,\"321\":25,\"322\":16,\"323\":33,\"347\":1,\"351\":4,\"463\":8,\"467\":5,\"468\":3,\"469\":3,\"470\":3,\"471\":5,\"473\":5,\"476\":4,\"477\":13,\"478\":45,\"502\":3,\"544\":31,\"575\":2,\"578\":34,\"580\":24,\"584\":1,\"590\":30,\"591\":14,\"594\":9,\"597\":13,\"599\":26,\"600\":5,\"601\":7,\"602\":11,\"603\":14,\"605\":28,\"606\":9,\"607\":11,\"609\":10,\"610\":9,\"611\":7,\"612\":8,\"614\":3,\"615\":8,\"617\":12,\"618\":9,\"622\":2,\"623\":16,\"624\":5,\"626\":8,\"627\":15,\"628\":7,\"630\":19,\"631\":7,\"632\":15,\"637\":2,\"643\":4,\"647\":1,\"659\":3,\"660\":5,\"661\":2,\"664\":4,\"665\":3,\"668\":2,\"672\":4,\"673\":2,\"675\":4,\"676\":2,\"681\":7,\"682\":5,\"683\":2,\"684\":5,\"686\":19,\"687\":4,\"688\":11,\"689\":19,\"690\":25,\"781\":1,\"793\":15,\"794\":9,\"801\":22,\"802\":11,\"804\":24,\"814\":21,\"815\":32,\"816\":4,\"817\":6,\"820\":12,\"821\":33,\"822\":22,\"840\":10,\"848\":72,\"853\":19,\"859\":21,\"885\":32,\"886\":15}}],[\"second\",{\"1\":{\"594\":1,\"802\":4,\"803\":1}}],[\"seconds\",{\"1\":{\"302\":2,\"304\":1}}],[\"section\",{\"1\":{\"78\":2,\"561\":3}}],[\"sections\",{\"1\":{\"59\":1}}],[\"sections=self\",{\"1\":{\"46\":2,\"59\":1}}],[\"sections=spatial\",{\"1\":{\"40\":1}}],[\"sec\",{\"1\":{\"8\":3,\"548\":1}}],[\"ste\",{\"1\":{\"885\":2}}],[\"stem\",{\"1\":{\"550\":1}}],[\"steps=none\",{\"1\":{\"803\":1}}],[\"steps=epoch\",{\"1\":{\"803\":1}}],[\"steps=100\",{\"1\":{\"593\":2}}],[\"steps\",{\"1\":{\"159\":1,\"803\":1}}],[\"steplr\",{\"1\":{\"80\":1}}],[\"step\",{\"0\":{\"41\":1,\"42\":1,\"43\":1,\"44\":1,\"45\":1,\"46\":1},\"1\":{\"40\":11,\"78\":5,\"80\":1,\"81\":1,\"142\":1,\"145\":1,\"147\":1,\"159\":1,\"163\":12,\"186\":1,\"218\":1,\"252\":2,\"273\":9,\"275\":2,\"277\":12,\"312\":5,\"323\":1,\"332\":1,\"425\":1,\"470\":5,\"500\":2,\"541\":19,\"544\":3,\"579\":2,\"581\":1,\"591\":6,\"593\":4,\"803\":1,\"840\":2,\"848\":1,\"854\":4,\"856\":1,\"860\":1,\"885\":1,\"886\":1}}],[\"stiennon\",{\"1\":{\"536\":1,\"537\":1}}],[\"sts\",{\"1\":{\"515\":1,\"566\":1}}],[\"studies\",{\"0\":{\"268\":1,\"780\":1}}],[\"student\",{\"0\":{\"748\":1},\"1\":{\"186\":26,\"748\":1,\"749\":1}}],[\"study\",{\"0\":{\"24\":1,\"135\":1,\"237\":1},\"1\":{\"134\":1}}],[\"storage\",{\"1\":{\"593\":1}}],[\"storagefurniture\",{\"1\":{\"29\":1,\"58\":1,\"68\":1}}],[\"stories\",{\"1\":{\"506\":1,\"507\":1,\"561\":1}}],[\"stochastic\",{\"1\":{\"272\":3,\"774\":1}}],[\"stopping\",{\"1\":{\"803\":1}}],[\"stop\",{\"1\":{\"167\":1,\"332\":2,\"425\":1,\"881\":1,\"885\":1}}],[\"style=filled\",{\"1\":{\"696\":12}}],[\"style\",{\"0\":{\"788\":1},\"1\":{\"163\":1,\"507\":1}}],[\"stn\",{\"1\":{\"109\":3}}],[\"stnkd\",{\"1\":{\"105\":1,\"108\":1,\"109\":1}}],[\"stn3d\",{\"1\":{\"105\":1,\"107\":5,\"108\":1,\"109\":2}}],[\"std=imagenet\",{\"1\":{\"802\":1}}],[\"std=torch\",{\"1\":{\"802\":1}}],[\"std=0\",{\"1\":{\"272\":2,\"319\":1,\"320\":2,\"323\":2}}],[\"std=\",{\"1\":{\"252\":1}}],[\"std\",{\"1\":{\"186\":1,\"802\":3,\"821\":1,\"853\":5,\"859\":3}}],[\"stderr\",{\"1\":{\"83\":2}}],[\"stdout\",{\"1\":{\"83\":1}}],[\"straight\",{\"1\":{\"793\":4,\"794\":1,\"795\":2,\"796\":4,\"821\":8,\"881\":1,\"885\":2}}],[\"stratify=y\",{\"1\":{\"398\":1}}],[\"stratify=none\",{\"1\":{\"398\":1}}],[\"stratify\",{\"1\":{\"398\":3}}],[\"string\",{\"1\":{\"577\":1}}],[\"strip\",{\"1\":{\"577\":4}}],[\"strict=false\",{\"1\":{\"327\":1}}],[\"stride=1\",{\"1\":{\"848\":1}}],[\"stride=2\",{\"1\":{\"793\":2,\"814\":1,\"821\":2,\"885\":4}}],[\"stride=patch\",{\"1\":{\"272\":1,\"318\":1,\"804\":1}}],[\"strides=\",{\"1\":{\"427\":3}}],[\"strides\",{\"1\":{\"360\":1,\"421\":1,\"423\":4,\"425\":2,\"426\":4,\"427\":2}}],[\"stride\",{\"1\":{\"272\":1,\"318\":1,\"361\":1,\"386\":1,\"423\":4,\"426\":3}}],[\"stream会引入额外的计算量\",{\"1\":{\"283\":1}}],[\"stream的交互方式\",{\"1\":{\"283\":1}}],[\"stream是不对图像和文本concate然后进行交互操作\",{\"1\":{\"283\":1}}],[\"stream是对图像和文本concate然后进行交互操作\",{\"1\":{\"283\":1}}],[\"stream\",{\"1\":{\"283\":2}}],[\"str\",{\"1\":{\"68\":2,\"142\":3,\"163\":1,\"295\":1,\"316\":3,\"366\":2,\"476\":19,\"477\":6,\"478\":44,\"599\":1,\"609\":1,\"689\":3,\"696\":2}}],[\"structural\",{\"1\":{\"63\":1}}],[\"structure\",{\"0\":{\"152\":1,\"284\":1},\"1\":{\"11\":1,\"28\":4,\"96\":1,\"314\":1}}],[\"staats\",{\"1\":{\"548\":1}}],[\"stanford\",{\"1\":{\"515\":1}}],[\"standing\",{\"1\":{\"234\":1,\"300\":2}}],[\"standard\",{\"1\":{\"163\":1}}],[\"stage流程\",{\"1\":{\"308\":1}}],[\"stagewise\",{\"0\":{\"266\":1},\"1\":{\"268\":1}}],[\"stage\",{\"0\":{\"309\":1,\"313\":1},\"1\":{\"199\":3,\"273\":2,\"274\":4,\"308\":3,\"309\":1,\"313\":1}}],[\"stack\",{\"0\":{\"358\":1},\"1\":{\"43\":2,\"145\":3,\"147\":3,\"162\":3,\"278\":3,\"300\":1,\"311\":3,\"316\":1,\"358\":3,\"548\":1,\"596\":1,\"628\":1}}],[\"status\",{\"1\":{\"816\":1}}],[\"static\",{\"1\":{\"562\":2}}],[\"staticmethod\",{\"1\":{\"316\":2,\"478\":2}}],[\"statistic\",{\"1\":{\"170\":10}}],[\"statistical\",{\"0\":{\"19\":1}}],[\"stats\",{\"1\":{\"142\":1,\"476\":4,\"478\":2,\"803\":1}}],[\"state=42\",{\"1\":{\"398\":1}}],[\"state=none\",{\"1\":{\"398\":1}}],[\"state=hidden\",{\"1\":{\"312\":1,\"544\":1}}],[\"state=sequence\",{\"1\":{\"289\":1}}],[\"state\",{\"1\":{\"82\":2,\"83\":1,\"145\":5,\"146\":2,\"147\":4,\"161\":4,\"162\":3,\"186\":2,\"309\":2,\"311\":1,\"327\":1,\"366\":3,\"398\":2,\"562\":1,\"581\":2,\"601\":1,\"885\":2,\"886\":2}}],[\"states=all\",{\"1\":{\"312\":1,\"544\":1}}],[\"states=false\",{\"1\":{\"312\":1}}],[\"states=outputs\",{\"1\":{\"163\":1,\"312\":1}}],[\"states=output\",{\"1\":{\"163\":1,\"312\":1}}],[\"states=encoder\",{\"1\":{\"163\":1,\"289\":1,\"295\":1,\"312\":1}}],[\"states=none\",{\"1\":{\"162\":1,\"163\":2,\"289\":1,\"290\":1,\"291\":1,\"292\":1,\"293\":1,\"295\":1,\"312\":5}}],[\"states=image\",{\"1\":{\"142\":1,\"145\":2,\"147\":3,\"309\":1,\"311\":1,\"312\":1}}],[\"states\",{\"1\":{\"40\":4,\"143\":1,\"146\":1,\"162\":9,\"163\":5,\"277\":11,\"289\":3,\"290\":6,\"291\":3,\"292\":12,\"293\":7,\"294\":1,\"295\":15,\"312\":21,\"313\":1,\"544\":43,\"599\":16,\"600\":4,\"601\":2,\"603\":2,\"605\":4,\"606\":8,\"609\":8,\"610\":6,\"612\":1,\"618\":1}}],[\"startswith\",{\"1\":{\"577\":1}}],[\"start\",{\"1\":{\"29\":4,\"58\":4,\"81\":1,\"147\":1,\"186\":3,\"252\":1,\"272\":5,\"273\":7,\"277\":6,\"302\":5,\"304\":5,\"332\":1,\"353\":2,\"425\":1,\"614\":12,\"615\":15,\"616\":5,\"803\":3}}],[\"stabilization\",{\"1\":{\"815\":1}}],[\"stable\",{\"1\":{\"814\":4,\"815\":2,\"820\":2}}],[\"stab\",{\"1\":{\"29\":1,\"58\":1,\"68\":1}}],[\"ae离图像生成只差一步了\",{\"1\":{\"878\":1}}],[\"ae不能够随机生成图片\",{\"1\":{\"878\":1}}],[\"ae的编码器编码出来的向量空间是不规整的\",{\"1\":{\"878\":1}}],[\"ae可不可以用来做图像生成呢\",{\"1\":{\"878\":1}}],[\"ae包含一个编码器\",{\"1\":{\"878\":1}}],[\"ae是一类能够把图片压缩成较短的向量的神经网络模型\",{\"1\":{\"878\":1}}],[\"ae\",{\"0\":{\"878\":1},\"1\":{\"878\":1,\"881\":2,\"885\":1}}],[\"axs\",{\"1\":{\"857\":10,\"861\":3}}],[\"axial\",{\"1\":{\"814\":2}}],[\"axialpositionalembedding\",{\"1\":{\"814\":1}}],[\"axis\",{\"1\":{\"303\":1,\"304\":1,\"857\":3,\"861\":1,\"886\":1}}],[\"axis=1\",{\"1\":{\"83\":1,\"299\":3,\"302\":3,\"304\":3,\"333\":2}}],[\"axis=0\",{\"1\":{\"83\":1,\"299\":1,\"333\":3}}],[\"a型和b型掩码\",{\"1\":{\"848\":1}}],[\"a类\",{\"1\":{\"845\":1}}],[\"a3b\",{\"1\":{\"704\":1}}],[\"a为m\",{\"1\":{\"487\":1}}],[\"a13\",{\"1\":{\"425\":2}}],[\"a12\",{\"1\":{\"425\":3}}],[\"a11\",{\"1\":{\"425\":4}}],[\"a10\",{\"1\":{\"425\":2}}],[\"a100\",{\"1\":{\"208\":1,\"209\":1}}],[\"a03\",{\"1\":{\"425\":2}}],[\"a02\",{\"1\":{\"425\":2}}],[\"a01\",{\"1\":{\"425\":2}}],[\"a00\",{\"1\":{\"425\":3}}],[\"a=2\",{\"1\":{\"401\":1}}],[\"a23\",{\"1\":{\"425\":2}}],[\"a22b\",{\"1\":{\"704\":1}}],[\"a22\",{\"1\":{\"425\":3}}],[\"a21\",{\"1\":{\"425\":3}}],[\"a20\",{\"1\":{\"425\":2}}],[\"a2\",{\"1\":{\"333\":3}}],[\"amp\",{\"1\":{\"803\":1}}],[\"amazonaws\",{\"1\":{\"577\":2}}],[\"american\",{\"1\":{\"300\":1}}],[\"among\",{\"1\":{\"104\":1}}],[\"across\",{\"1\":{\"310\":2}}],[\"acceptability语言可接受性语料库\",{\"1\":{\"515\":1}}],[\"accelerator\",{\"1\":{\"273\":1}}],[\"accu\",{\"1\":{\"323\":1}}],[\"accuracy\",{\"0\":{\"443\":1},\"1\":{\"276\":2,\"277\":8,\"278\":3,\"302\":8,\"304\":6,\"582\":2}}],[\"acc\",{\"1\":{\"276\":2,\"277\":8,\"278\":2,\"302\":2,\"304\":2}}],[\"active\",{\"1\":{\"617\":8}}],[\"activate\",{\"1\":{\"432\":2,\"435\":1,\"438\":1,\"439\":2,\"593\":1,\"620\":1}}],[\"activation\",{\"1\":{\"76\":1,\"289\":2,\"601\":2}}],[\"actually\",{\"1\":{\"605\":1}}],[\"actual\",{\"1\":{\"302\":2,\"304\":2}}],[\"act2fn\",{\"1\":{\"295\":1,\"599\":1,\"609\":1}}],[\"act\",{\"1\":{\"272\":4,\"295\":6,\"320\":1,\"321\":6,\"323\":5,\"599\":7,\"609\":7}}],[\"apt\",{\"1\":{\"696\":1}}],[\"ape\",{\"0\":{\"586\":1}}],[\"apache许可项目\",{\"1\":{\"548\":1}}],[\"applied\",{\"1\":{\"632\":1}}],[\"apple\",{\"1\":{\"572\":5}}],[\"apply\",{\"1\":{\"255\":1,\"272\":1,\"323\":1,\"605\":1,\"632\":2}}],[\"approach\",{\"1\":{\"557\":1,\"563\":1}}],[\"append\",{\"1\":{\"29\":3,\"43\":3,\"58\":3,\"59\":2,\"68\":1,\"82\":1,\"92\":2,\"96\":5,\"100\":2,\"143\":1,\"145\":3,\"147\":3,\"162\":3,\"186\":1,\"277\":2,\"278\":3,\"302\":3,\"304\":3,\"311\":3,\"316\":5,\"477\":2,\"478\":3,\"578\":6,\"579\":4,\"594\":1,\"668\":1,\"682\":1,\"684\":1,\"686\":1,\"688\":1,\"696\":2,\"697\":2,\"793\":6,\"821\":5,\"840\":2,\"886\":4}}],[\"api的调用\",{\"1\":{\"719\":1}}],[\"api记录之框架篇\",{\"0\":{\"394\":1},\"1\":{\"394\":1}}],[\"api记录之杂类篇\",{\"0\":{\"380\":1},\"1\":{\"380\":1}}],[\"api记录之pytorch篇\",{\"0\":{\"356\":1},\"1\":{\"356\":1}}],[\"api记录之python篇\",{\"0\":{\"334\":1},\"1\":{\"334\":1}}],[\"api记录之numpy篇\",{\"0\":{\"330\":1},\"1\":{\"330\":1}}],[\"api\",{\"1\":{\"232\":1,\"367\":1,\"395\":1,\"536\":1,\"537\":3,\"538\":2,\"539\":4,\"704\":1,\"712\":2,\"716\":1}}],[\"ai\",{\"0\":{\"721\":1},\"1\":{\"235\":1,\"483\":1,\"539\":3,\"541\":38,\"577\":2,\"704\":4,\"707\":2,\"716\":4}}],[\"ai2d科学图表任务表现接近商业模型\",{\"1\":{\"228\":1}}],[\"aiou\",{\"1\":{\"22\":1,\"23\":1,\"24\":2,\"82\":3}}],[\"agents\",{\"1\":{\"713\":1}}],[\"agent\",{\"0\":{\"721\":1},\"1\":{\"704\":1,\"708\":1,\"714\":1}}],[\"agreement\",{\"1\":{\"537\":1}}],[\"agnostic\",{\"1\":{\"527\":1}}],[\"agnostic模型优于那些为每个任务精心设计的模型\",{\"1\":{\"506\":1,\"507\":1}}],[\"aggregate=false\",{\"1\":{\"277\":1}}],[\"aggregate=true\",{\"1\":{\"277\":3}}],[\"aggregate\",{\"1\":{\"277\":1,\"310\":2}}],[\"agi\",{\"1\":{\"189\":1,\"216\":1,\"708\":3}}],[\"agd20k\",{\"1\":{\"17\":1}}],[\"averaging\",{\"1\":{\"808\":1}}],[\"average=true\",{\"1\":{\"467\":1,\"468\":1,\"469\":1,\"470\":1,\"471\":1,\"473\":1}}],[\"average=none\",{\"1\":{\"163\":1}}],[\"average\",{\"1\":{\"22\":1,\"82\":1,\"105\":1,\"115\":1,\"157\":1,\"170\":1,\"387\":2,\"467\":3,\"468\":2,\"469\":2,\"470\":2,\"471\":4,\"473\":4,\"776\":1,\"822\":1}}],[\"available\",{\"1\":{\"170\":1,\"302\":1,\"304\":1,\"840\":1,\"848\":2,\"856\":1,\"860\":1}}],[\"avg\",{\"1\":{\"169\":1,\"581\":5}}],[\"a^t||\",{\"1\":{\"105\":1}}],[\"always\",{\"1\":{\"632\":1,\"814\":2}}],[\"already\",{\"1\":{\"594\":1}}],[\"alice\",{\"1\":{\"351\":1}}],[\"align=\",{\"1\":{\"316\":1}}],[\"aligned\",{\"1\":{\"299\":2}}],[\"aligning\",{\"1\":{\"187\":1,\"539\":1}}],[\"alignment\",{\"1\":{\"59\":1,\"233\":1,\"285\":1,\"535\":1,\"536\":2,\"537\":1,\"538\":2,\"539\":1}}],[\"align进行映射\",{\"1\":{\"59\":1}}],[\"align对齐方法需要\",{\"1\":{\"59\":1}}],[\"align映射为4\",{\"1\":{\"59\":1}}],[\"align技术\",{\"1\":{\"59\":4}}],[\"align获取物体\",{\"1\":{\"54\":1}}],[\"align\",{\"0\":{\"387\":1},\"1\":{\"46\":2,\"59\":7,\"148\":2,\"260\":1,\"261\":1,\"386\":1,\"388\":2}}],[\"alexnet\",{\"1\":{\"302\":1}}],[\"albef\",{\"0\":{\"148\":1,\"151\":1},\"1\":{\"148\":1,\"149\":2,\"150\":2,\"152\":1,\"153\":1,\"156\":1,\"157\":2,\"159\":1,\"160\":1,\"161\":1,\"162\":3,\"163\":1,\"261\":2,\"265\":1,\"268\":1}}],[\"al\",{\"0\":{\"590\":1},\"1\":{\"126\":5,\"127\":2,\"131\":4,\"521\":3,\"536\":17,\"537\":2,\"539\":2,\"548\":1,\"550\":1,\"552\":10}}],[\"alpha+beta=1\",{\"1\":{\"471\":1}}],[\"alpha=beta=1\",{\"1\":{\"471\":1}}],[\"alpha=beta=0\",{\"1\":{\"471\":1}}],[\"alpha=0\",{\"1\":{\"161\":1,\"163\":1}}],[\"alpha=alpha\",{\"1\":{\"145\":1,\"470\":1,\"471\":1,\"473\":1}}],[\"alpha\",{\"1\":{\"78\":3,\"145\":9,\"147\":10,\"159\":13,\"161\":6,\"163\":4,\"470\":8,\"471\":4,\"473\":7,\"815\":3}}],[\"allclose\",{\"1\":{\"676\":1}}],[\"all=false\",{\"1\":{\"93\":2,\"101\":4}}],[\"all=true\",{\"1\":{\"92\":1,\"93\":1}}],[\"all流程图\",{\"1\":{\"92\":1}}],[\"all\",{\"1\":{\"73\":1,\"92\":8,\"145\":26,\"147\":14,\"161\":8,\"162\":8,\"170\":7,\"171\":2,\"257\":1,\"277\":9,\"278\":11,\"293\":1,\"302\":3,\"303\":1,\"304\":3,\"310\":2,\"311\":12,\"312\":1,\"401\":2,\"478\":4,\"577\":4,\"578\":2,\"594\":5,\"596\":16,\"605\":6,\"632\":3,\"803\":2,\"804\":2,\"886\":6}}],[\"after\",{\"1\":{\"273\":1,\"341\":1,\"426\":2,\"815\":1}}],[\"afm\",{\"0\":{\"71\":1,\"75\":1},\"1\":{\"70\":1,\"71\":3,\"74\":1,\"75\":5,\"76\":1}}],[\"aff\",{\"1\":{\"81\":1,\"82\":1,\"83\":2}}],[\"aff2idx\",{\"1\":{\"68\":2}}],[\"afford\",{\"1\":{\"68\":2}}],[\"affordq\",{\"1\":{\"68\":1,\"80\":3}}],[\"affordance=dict\",{\"1\":{\"83\":1}}],[\"affordances\",{\"1\":{\"25\":1}}],[\"affordancenet\",{\"1\":{\"17\":1,\"62\":2,\"63\":1,\"67\":1,\"69\":1}}],[\"affordance\",{\"0\":{\"9\":1,\"12\":1,\"28\":1},\"1\":{\"4\":1,\"5\":1,\"6\":1,\"7\":2,\"13\":1,\"16\":1,\"19\":1,\"20\":1,\"23\":4,\"24\":3,\"25\":2,\"26\":1,\"28\":1,\"29\":18,\"30\":1,\"33\":1,\"37\":1,\"40\":4,\"45\":5,\"46\":12,\"47\":1,\"48\":2,\"49\":1,\"58\":15,\"59\":15,\"60\":3,\"62\":1,\"63\":1,\"67\":1,\"68\":15,\"70\":1,\"76\":6,\"80\":2,\"82\":3,\"83\":14}}],[\"affcot\",{\"1\":{\"24\":2}}],[\"aspect\",{\"1\":{\"801\":15}}],[\"aspect=none\",{\"1\":{\"801\":1}}],[\"aspect=0\",{\"1\":{\"801\":1}}],[\"ascii=false\",{\"1\":{\"476\":3,\"478\":3,\"577\":2}}],[\"astronaut\",{\"1\":{\"300\":1}}],[\"astype\",{\"1\":{\"68\":2,\"82\":2,\"83\":4,\"107\":1}}],[\"assume\",{\"1\":{\"632\":1}}],[\"asserttrue\",{\"1\":{\"676\":1}}],[\"assertequal\",{\"1\":{\"675\":2}}],[\"assert\",{\"1\":{\"257\":1,\"272\":1,\"274\":2,\"316\":1,\"578\":1,\"590\":1,\"632\":1,\"815\":2,\"817\":2,\"821\":3,\"822\":1,\"848\":1,\"886\":1}}],[\"assistant\",{\"0\":{\"231\":1},\"1\":{\"231\":1,\"234\":1,\"235\":2}}],[\"assignments\",{\"1\":{\"176\":2}}],[\"as\",{\"1\":{\"68\":2,\"78\":2,\"83\":4,\"171\":2,\"252\":1,\"272\":1,\"274\":1,\"302\":2,\"303\":1,\"304\":5,\"316\":2,\"321\":1,\"322\":1,\"332\":1,\"333\":1,\"336\":1,\"398\":1,\"399\":1,\"423\":1,\"476\":3,\"478\":6,\"577\":3,\"578\":3,\"590\":1,\"591\":1,\"597\":1,\"610\":1,\"638\":1,\"681\":1,\"686\":1,\"688\":1,\"690\":6,\"691\":4,\"696\":5,\"697\":3,\"708\":1,\"804\":1,\"840\":4,\"848\":3,\"852\":4,\"886\":1}}],[\"attempt\",{\"1\":{\"801\":1}}],[\"attenion\",{\"1\":{\"626\":1}}],[\"attend\",{\"1\":{\"605\":1,\"621\":1}}],[\"atten1\",{\"1\":{\"36\":2}}],[\"atten\",{\"1\":{\"32\":8,\"33\":3,\"45\":10,\"59\":8}}],[\"attention可以用矩阵乘法一次计算所有的时刻\",{\"1\":{\"621\":1}}],[\"attention机制\",{\"1\":{\"621\":1}}],[\"attention=false\",{\"1\":{\"544\":1}}],[\"attentional\",{\"1\":{\"516\":1}}],[\"attention运算过程中维度变换的理解\",{\"0\":{\"404\":1},\"1\":{\"404\":1}}],[\"attention的heads数\",{\"1\":{\"324\":1}}],[\"attention的输入\",{\"1\":{\"313\":1}}],[\"attention计算\",{\"1\":{\"311\":1}}],[\"attention模块\",{\"1\":{\"309\":1}}],[\"attentions=all\",{\"1\":{\"312\":2,\"544\":2}}],[\"attentions=outputs\",{\"1\":{\"163\":1,\"312\":2}}],[\"attentions=output\",{\"1\":{\"163\":1,\"312\":3}}],[\"attentions=none\",{\"1\":{\"163\":1,\"312\":1}}],[\"attentions=false\",{\"1\":{\"162\":1,\"312\":3}}],[\"attentions\",{\"1\":{\"76\":1,\"163\":2,\"312\":9,\"463\":10,\"544\":2,\"603\":1,\"605\":2,\"612\":1,\"618\":1}}],[\"attention\",{\"0\":{\"292\":1,\"542\":1,\"543\":1},\"1\":{\"32\":1,\"33\":2,\"36\":1,\"40\":7,\"41\":9,\"43\":12,\"45\":14,\"46\":1,\"59\":1,\"75\":2,\"112\":3,\"115\":1,\"126\":3,\"142\":3,\"143\":3,\"145\":11,\"146\":5,\"147\":15,\"152\":1,\"161\":5,\"162\":17,\"163\":14,\"179\":1,\"199\":2,\"268\":2,\"272\":7,\"276\":3,\"277\":2,\"289\":7,\"290\":5,\"291\":12,\"292\":5,\"293\":21,\"294\":4,\"295\":5,\"309\":3,\"310\":3,\"311\":10,\"312\":68,\"313\":1,\"321\":2,\"322\":2,\"364\":1,\"405\":1,\"410\":1,\"414\":1,\"415\":1,\"463\":2,\"492\":1,\"542\":1,\"544\":7,\"575\":2,\"591\":9,\"594\":6,\"596\":4,\"599\":7,\"600\":2,\"602\":8,\"603\":3,\"605\":26,\"607\":4,\"612\":2,\"614\":1,\"615\":2,\"617\":4,\"618\":6,\"622\":2,\"632\":4,\"704\":3,\"781\":2,\"814\":6}}],[\"attn有4\",{\"1\":{\"515\":1}}],[\"attn\",{\"1\":{\"72\":1,\"74\":1,\"76\":4,\"163\":1,\"272\":20,\"312\":3,\"320\":1,\"321\":4,\"322\":10,\"323\":2,\"463\":17,\"544\":18,\"584\":4,\"590\":2,\"591\":3,\"627\":4,\"630\":10,\"632\":7,\"814\":12}}],[\"atts=none\",{\"1\":{\"43\":1}}],[\"atts\",{\"1\":{\"40\":2,\"43\":12,\"142\":2,\"143\":2,\"145\":13,\"146\":2,\"147\":14,\"161\":2,\"162\":12,\"163\":2,\"309\":2,\"311\":11,\"312\":4,\"313\":2}}],[\"at\",{\"1\":{\"28\":2,\"83\":1,\"98\":2,\"257\":1,\"300\":1}}],[\"augmented\",{\"0\":{\"709\":1},\"1\":{\"709\":1,\"718\":1}}],[\"augmentations\",{\"1\":{\"186\":1}}],[\"augmentation\",{\"0\":{\"124\":1},\"1\":{\"173\":1,\"252\":2}}],[\"autograd\",{\"1\":{\"840\":1}}],[\"autoencoders\",{\"0\":{\"863\":1},\"1\":{\"863\":2,\"873\":1}}],[\"autoencoder\",{\"1\":{\"773\":1,\"878\":1}}],[\"auto\",{\"1\":{\"708\":1,\"772\":1,\"875\":1}}],[\"autocast\",{\"1\":{\"40\":1,\"803\":1}}],[\"autotokenizer\",{\"1\":{\"28\":1}}],[\"automodel\",{\"1\":{\"28\":1}}],[\"auc\",{\"0\":{\"449\":1,\"451\":1,\"453\":1},\"1\":{\"22\":1,\"23\":1,\"75\":1,\"82\":23,\"450\":1,\"451\":6,\"452\":1,\"453\":3}}],[\"adjacent\",{\"1\":{\"579\":14}}],[\"adversarial\",{\"1\":{\"539\":2,\"840\":6}}],[\"admin\",{\"1\":{\"353\":2}}],[\"ade20k\",{\"1\":{\"201\":1,\"780\":1}}],[\"ade20k分割\",{\"1\":{\"189\":1}}],[\"addition\",{\"1\":{\"729\":1}}],[\"additional\",{\"1\":{\"28\":2,\"35\":1,\"46\":2,\"59\":1,\"134\":1}}],[\"additivity\",{\"1\":{\"729\":1}}],[\"add等操作节点\",{\"1\":{\"696\":1}}],[\"added\",{\"1\":{\"478\":1}}],[\"add\",{\"0\":{\"379\":1},\"1\":{\"83\":1,\"145\":2,\"146\":1,\"147\":2,\"170\":2,\"186\":4,\"295\":1,\"344\":2,\"379\":1,\"603\":1,\"684\":1,\"685\":1,\"686\":4,\"688\":6,\"690\":16,\"691\":4,\"692\":1,\"696\":6,\"840\":10}}],[\"adamp\",{\"1\":{\"395\":1}}],[\"adamw\",{\"1\":{\"131\":1,\"142\":2,\"145\":1,\"147\":1,\"179\":1,\"186\":1,\"208\":1,\"209\":1,\"211\":1,\"548\":1,\"581\":1}}],[\"adam\",{\"1\":{\"22\":1,\"80\":1,\"514\":1,\"560\":1,\"561\":2,\"774\":1,\"808\":1,\"809\":1,\"840\":5,\"848\":1,\"856\":1,\"860\":1,\"885\":1,\"886\":1}}],[\"adaptation\",{\"1\":{\"487\":1,\"489\":1}}],[\"adaptiveavgpool1d\",{\"1\":{\"36\":1,\"46\":1,\"59\":1}}],[\"adaptive\",{\"0\":{\"14\":1},\"1\":{\"70\":1}}],[\"adapter\",{\"1\":{\"10\":2,\"40\":2,\"42\":1,\"44\":1,\"491\":2}}],[\"ability\",{\"1\":{\"840\":2}}],[\"about\",{\"1\":{\"300\":1}}],[\"ablation\",{\"0\":{\"24\":1,\"135\":1,\"237\":1,\"268\":1,\"780\":1},\"1\":{\"134\":1,\"237\":1}}],[\"abstract\",{\"0\":{\"245\":1}}],[\"abstraction\",{\"1\":{\"87\":1,\"88\":2,\"93\":1,\"97\":1,\"98\":4,\"99\":1,\"101\":2}}],[\"absolute\",{\"0\":{\"586\":1},\"1\":{\"22\":1,\"82\":4,\"311\":1}}],[\"abs\",{\"1\":{\"4\":1,\"37\":1,\"47\":1,\"59\":1,\"78\":4,\"85\":1,\"102\":1,\"187\":1,\"231\":1,\"272\":4,\"306\":1,\"327\":1,\"579\":1,\"591\":1,\"821\":1}}],[\"art\",{\"1\":{\"562\":1}}],[\"arc挑战集\",{\"1\":{\"549\":1}}],[\"arc等\",{\"1\":{\"549\":1}}],[\"arch=\",{\"1\":{\"186\":1}}],[\"arch\",{\"1\":{\"186\":3,\"252\":1}}],[\"architecture\",{\"1\":{\"71\":1,\"73\":1}}],[\"arr=attentions\",{\"1\":{\"463\":1}}],[\"arr\",{\"1\":{\"332\":2}}],[\"arrays\",{\"1\":{\"398\":2}}],[\"array\",{\"1\":{\"68\":2,\"82\":1,\"83\":3,\"107\":1,\"302\":2,\"304\":2,\"332\":1,\"333\":4,\"398\":1,\"399\":1,\"423\":1,\"638\":2,\"647\":1,\"662\":1,\"675\":4,\"681\":1,\"684\":1,\"685\":1,\"686\":1,\"688\":4,\"689\":7,\"690\":12,\"691\":2,\"692\":6,\"696\":4,\"697\":6}}],[\"are\",{\"1\":{\"214\":2,\"478\":1,\"518\":1,\"519\":1,\"525\":1,\"539\":1,\"603\":2,\"610\":1,\"615\":1}}],[\"area\",{\"1\":{\"22\":1,\"78\":2,\"82\":3,\"388\":1,\"470\":1,\"801\":6}}],[\"argparse\",{\"1\":{\"840\":2}}],[\"argumentparser\",{\"1\":{\"840\":1}}],[\"argument\",{\"1\":{\"186\":3,\"337\":2,\"840\":10}}],[\"argmin\",{\"1\":{\"170\":1,\"880\":1,\"885\":1}}],[\"argmax\",{\"1\":{\"162\":1,\"302\":1,\"303\":1,\"304\":2,\"541\":1,\"544\":1,\"614\":2,\"796\":1,\"809\":1,\"819\":4,\"821\":2}}],[\"argsort\",{\"1\":{\"463\":1}}],[\"args\",{\"1\":{\"43\":1,\"45\":2,\"46\":2,\"83\":4,\"142\":2,\"145\":1,\"147\":1,\"186\":29,\"252\":13,\"272\":2,\"274\":7,\"319\":1,\"327\":1,\"341\":2,\"344\":3,\"345\":2,\"346\":4,\"347\":2,\"351\":2,\"352\":2,\"353\":7,\"463\":8,\"478\":11,\"596\":1,\"681\":1,\"802\":7,\"803\":6,\"816\":4,\"840\":1,\"848\":2,\"886\":2}}],[\"arange\",{\"1\":{\"92\":3,\"277\":1,\"299\":1,\"310\":1,\"311\":1,\"374\":2,\"398\":1,\"423\":2,\"544\":1,\"590\":5,\"591\":4,\"597\":1,\"814\":4,\"815\":2,\"820\":2,\"822\":3,\"861\":1}}],[\"ar\",{\"1\":{\"49\":1,\"202\":1}}],[\"arm模块\",{\"1\":{\"54\":1,\"56\":1}}],[\"arm\",{\"1\":{\"48\":1,\"59\":1}}],[\"around\",{\"1\":{\"28\":2,\"31\":2}}],[\"arxiv\",{\"1\":{\"4\":1,\"37\":1,\"47\":1,\"85\":1,\"102\":1,\"187\":1,\"231\":1,\"306\":1,\"327\":1,\"548\":1,\"821\":1}}],[\"a\",{\"1\":{\"17\":1,\"24\":1,\"28\":4,\"49\":1,\"52\":1,\"59\":1,\"105\":1,\"142\":2,\"143\":2,\"145\":3,\"147\":2,\"171\":2,\"196\":1,\"201\":1,\"234\":2,\"255\":2,\"268\":1,\"282\":1,\"300\":16,\"301\":3,\"302\":1,\"303\":2,\"304\":3,\"307\":2,\"333\":2,\"336\":1,\"344\":2,\"345\":2,\"423\":2,\"427\":4,\"453\":2,\"455\":1,\"473\":1,\"478\":4,\"488\":2,\"492\":3,\"511\":1,\"521\":1,\"522\":1,\"537\":1,\"541\":20,\"544\":1,\"557\":1,\"578\":6,\"579\":18,\"580\":1,\"584\":1,\"591\":1,\"593\":3,\"594\":4,\"605\":1,\"618\":1,\"628\":1,\"632\":2,\"647\":4,\"662\":3,\"685\":3,\"687\":6,\"690\":10,\"696\":1,\"703\":1,\"708\":1,\"718\":2,\"727\":2,\"808\":2,\"821\":1,\"840\":1,\"845\":7,\"846\":5,\"848\":6,\"866\":1,\"871\":2,\"886\":3}}],[\"anthropic\",{\"1\":{\"704\":3}}],[\"answer\",{\"1\":{\"616\":3}}],[\"answering\",{\"1\":{\"275\":1,\"521\":1}}],[\"anaconda\",{\"1\":{\"438\":1}}],[\"anaconda3\",{\"1\":{\"434\":3}}],[\"analysis\",{\"0\":{\"19\":1,\"25\":1}}],[\"analogical\",{\"1\":{\"12\":1,\"28\":2}}],[\"anchor\",{\"1\":{\"246\":1}}],[\"ann\",{\"1\":{\"142\":5}}],[\"annotated\",{\"1\":{\"620\":5}}],[\"annotator\",{\"1\":{\"537\":1}}],[\"annotation\",{\"0\":{\"18\":1},\"1\":{\"142\":1}}],[\"anno\",{\"1\":{\"68\":9,\"83\":5}}],[\"an\",{\"1\":{\"73\":1,\"300\":1,\"610\":1}}],[\"and\",{\"0\":{\"13\":1,\"15\":1,\"130\":1,\"231\":1,\"257\":1,\"551\":1,\"737\":1,\"738\":1},\"1\":{\"28\":6,\"37\":1,\"68\":1,\"78\":1,\"80\":2,\"92\":8,\"119\":2,\"120\":1,\"128\":1,\"129\":1,\"134\":1,\"145\":1,\"147\":1,\"148\":2,\"161\":1,\"170\":2,\"171\":2,\"186\":4,\"187\":1,\"231\":1,\"252\":3,\"254\":1,\"255\":2,\"257\":2,\"272\":1,\"274\":1,\"279\":2,\"300\":1,\"301\":1,\"312\":1,\"321\":1,\"327\":1,\"385\":1,\"426\":1,\"478\":2,\"488\":1,\"536\":5,\"541\":9,\"544\":1,\"545\":1,\"554\":1,\"577\":2,\"579\":1,\"594\":1,\"599\":1,\"603\":1,\"605\":1,\"609\":1,\"612\":1,\"614\":1,\"615\":1,\"623\":2,\"628\":1,\"630\":1,\"632\":2,\"692\":2,\"696\":1,\"801\":1,\"815\":3,\"821\":2,\"840\":1,\"843\":1,\"859\":1}}],[\"论文面向对生成模型感兴趣但不熟悉变分贝叶斯方法的读者\",{\"1\":{\"864\":1}}],[\"论文算法2实现\",{\"1\":{\"821\":1}}],[\"论文的主要改进包括\",{\"1\":{\"559\":1}}],[\"论文的核心方法是基于语言建模\",{\"1\":{\"521\":1}}],[\"论文的核心假设与目标\",{\"1\":{\"520\":1}}],[\"论文第5章重点讨论\",{\"1\":{\"549\":1}}],[\"论文最终强调\",{\"1\":{\"527\":1}}],[\"论文也分析了模型在自然语言推理\",{\"1\":{\"527\":1}}],[\"论文假设\",{\"1\":{\"527\":1}}],[\"论文系统评估了不同规模的gpt\",{\"1\":{\"522\":1}}],[\"论文训练了gpt\",{\"1\":{\"527\":1}}],[\"论文训练了\",{\"1\":{\"521\":1}}],[\"论文构建了一个新的数据集\",{\"1\":{\"521\":1}}],[\"论文强调了gpt\",{\"1\":{\"526\":1}}],[\"论文强调\",{\"1\":{\"520\":1}}],[\"论文实验结果显示\",{\"1\":{\"494\":1}}],[\"论文实现进行区分\",{\"1\":{\"145\":1}}],[\"论文开源的代码实现进行讲解\",{\"1\":{\"463\":1}}],[\"论文推荐\",{\"1\":{\"387\":1}}],[\"论文里提出了一种掩码卷积机制\",{\"1\":{\"845\":1}}],[\"论文里也做了说明\",{\"1\":{\"324\":1}}],[\"论文里没有做解释\",{\"1\":{\"321\":1}}],[\"论文作者也对其做了实验\",{\"1\":{\"320\":1}}],[\"论文还进行了一组\",{\"1\":{\"537\":1}}],[\"论文还探讨了模型泛化与记忆的关系\",{\"1\":{\"519\":1}}],[\"论文还实验了使用80个不同的prompt进行集成\",{\"1\":{\"301\":1}}],[\"论文还引入了\",{\"1\":{\"179\":1}}],[\"论文指出传统观点认为模型参数越多性能越优\",{\"1\":{\"547\":1}}],[\"论文指出这仅是通向更通用ai系统的初步探索\",{\"1\":{\"524\":1}}],[\"论文指出\",{\"1\":{\"301\":1,\"547\":1}}],[\"论文发现这个模型的效果最佳\",{\"1\":{\"299\":1}}],[\"论文采用\",{\"1\":{\"255\":1}}],[\"论文在\",{\"1\":{\"247\":1,\"772\":1}}],[\"论文核心创新点\",{\"1\":{\"232\":1}}],[\"论文提出通过元学习\",{\"1\":{\"527\":1}}],[\"论文提出了\",{\"1\":{\"260\":1}}],[\"论文提出了一个全新的模型\",{\"1\":{\"70\":1}}],[\"论文提出internvl\",{\"1\":{\"216\":1}}],[\"论文提出\",{\"1\":{\"189\":1}}],[\"论文通过研究自监督预训练对\",{\"1\":{\"173\":1}}],[\"论文简析\",{\"1\":{\"148\":1,\"187\":1,\"214\":1,\"231\":1,\"240\":1,\"259\":1,\"279\":1}}],[\"论文附录a中提到的训练优化策略\",{\"1\":{\"142\":1}}],[\"论文4\",{\"1\":{\"142\":1}}],[\"论文链接\",{\"1\":{\"119\":1,\"148\":1,\"164\":1,\"171\":1,\"172\":1,\"187\":1,\"214\":1,\"231\":1,\"240\":1,\"259\":1,\"270\":1,\"279\":1,\"489\":1,\"518\":1,\"525\":1,\"533\":1,\"545\":1,\"554\":1,\"557\":1,\"764\":1,\"805\":1,\"812\":1,\"863\":1}}],[\"论文中第\",{\"1\":{\"536\":1}}],[\"论文中\",{\"1\":{\"492\":1}}],[\"论文中举的例子\",{\"1\":{\"488\":1}}],[\"论文中进行对比实验的clip模型也采用了这一配置\",{\"1\":{\"299\":1}}],[\"论文中所提到的\",{\"1\":{\"272\":1}}],[\"论文中所给的模型架构图中的decoder\",{\"1\":{\"70\":1}}],[\"论文中所给的模型架构图中的encoder\",{\"1\":{\"70\":1}}],[\"论文中还进行了多项\",{\"1\":{\"237\":1}}],[\"论文中重点测试了以下两个应用场景\",{\"1\":{\"235\":1}}],[\"论文中采用vit\",{\"1\":{\"142\":1}}],[\"论文中做了\",{\"1\":{\"112\":1}}],[\"论文中的验证\",{\"1\":{\"112\":1}}],[\"论文中也进行了大量消融实验来验证\",{\"1\":{\"75\":1}}],[\"论文代码解读与复现\",{\"1\":{\"37\":1,\"60\":1}}],[\"论文\",{\"0\":{\"119\":1,\"148\":1,\"164\":1,\"171\":1,\"172\":1,\"240\":1,\"259\":1,\"279\":1,\"505\":1,\"518\":1,\"525\":1,\"533\":1,\"557\":1,\"764\":1,\"863\":1},\"1\":{\"4\":1,\"37\":1,\"47\":1,\"60\":1,\"85\":1,\"102\":1,\"306\":1,\"505\":2,\"518\":1,\"525\":1,\"533\":1,\"545\":1,\"554\":1,\"557\":1,\"863\":1}}],[\"论文解读与代码实现\",{\"0\":{\"876\":1},\"1\":{\"876\":1}}],[\"论文解读\",{\"0\":{\"4\":1,\"47\":1,\"805\":1},\"1\":{\"4\":1,\"47\":1,\"119\":1,\"164\":1,\"171\":1,\"172\":1,\"791\":2,\"805\":1}}],[\"v3\",{\"1\":{\"704\":1,\"784\":1,\"843\":2}}],[\"v0\",{\"1\":{\"327\":1,\"714\":1}}],[\"v计算来源相同\",{\"1\":{\"322\":1}}],[\"v矩阵\",{\"1\":{\"322\":1}}],[\"v时使用偏置\",{\"1\":{\"322\":1}}],[\"vffn\",{\"1\":{\"277\":5}}],[\"vfms\",{\"1\":{\"220\":1}}],[\"vfm\",{\"1\":{\"216\":1}}],[\"vgg进行实现\",{\"1\":{\"302\":1}}],[\"vg\",{\"1\":{\"274\":1}}],[\"verbose=true\",{\"1\":{\"696\":2}}],[\"verbose=false\",{\"1\":{\"696\":2}}],[\"verbose\",{\"1\":{\"696\":4}}],[\"verbose参数控制是否显示详细信息\",{\"1\":{\"696\":1}}],[\"very\",{\"1\":{\"516\":1}}],[\"versa\",{\"1\":{\"478\":1}}],[\"version\",{\"1\":{\"348\":2,\"599\":1,\"609\":1,\"696\":1}}],[\"vec2\",{\"1\":{\"302\":5,\"304\":5}}],[\"vec1\",{\"1\":{\"302\":5,\"304\":5}}],[\"vectorquantizer\",{\"1\":{\"885\":2}}],[\"vector\",{\"1\":{\"164\":2,\"170\":2,\"575\":1,\"787\":1,\"882\":1,\"885\":1}}],[\"vectors\",{\"1\":{\"98\":1,\"170\":2,\"632\":1,\"885\":1}}],[\"vector3dvector\",{\"1\":{\"83\":4}}],[\"ve\",{\"1\":{\"282\":2}}],[\"vehicle\",{\"1\":{\"234\":1}}],[\"v100\",{\"1\":{\"561\":1,\"774\":1}}],[\"v1\",{\"1\":{\"223\":3,\"561\":1,\"843\":1}}],[\"vqvae\",{\"1\":{\"885\":4,\"886\":2}}],[\"vq\",{\"0\":{\"876\":1,\"878\":1,\"879\":1},\"1\":{\"165\":3,\"167\":4,\"170\":1,\"773\":3,\"787\":3,\"789\":1,\"792\":1,\"800\":1,\"802\":1,\"817\":1,\"876\":1,\"877\":2,\"878\":10,\"879\":3,\"880\":6,\"881\":6,\"882\":4,\"883\":6,\"885\":17,\"886\":6,\"887\":1}}],[\"vqav2datamodule\",{\"1\":{\"274\":1}}],[\"vqa\",{\"1\":{\"120\":1,\"198\":1,\"203\":1,\"205\":1,\"206\":1,\"260\":2,\"274\":1,\"275\":2,\"277\":2,\"294\":1}}],[\"vocab是词典大小\",{\"1\":{\"624\":1}}],[\"vocab\",{\"1\":{\"163\":5,\"274\":4,\"276\":3,\"295\":2,\"312\":1,\"476\":58,\"477\":3,\"478\":76,\"541\":1,\"578\":16,\"580\":6,\"581\":2,\"597\":2,\"610\":2,\"612\":1,\"624\":2,\"804\":3,\"814\":1,\"817\":2}}],[\"vocabulary\",{\"1\":{\"4\":1,\"6\":1,\"7\":1,\"475\":1,\"476\":1,\"478\":18}}],[\"voxnet\",{\"1\":{\"112\":1}}],[\"voxel\",{\"1\":{\"103\":1,\"114\":1}}],[\"v\",{\"0\":{\"406\":1},\"1\":{\"72\":2,\"74\":2,\"147\":4,\"163\":1,\"186\":3,\"264\":1,\"272\":15,\"274\":2,\"275\":4,\"278\":2,\"309\":1,\"316\":4,\"322\":4,\"404\":1,\"410\":1,\"419\":2,\"463\":2,\"476\":6,\"478\":7,\"542\":1,\"544\":2,\"578\":2,\"584\":3,\"590\":4,\"632\":2,\"696\":10}}],[\"vse++和scan属于\",{\"1\":{\"282\":1}}],[\"vse\",{\"1\":{\"282\":1}}],[\"vs\",{\"0\":{\"711\":1},\"1\":{\"59\":1,\"111\":1,\"112\":2,\"385\":2,\"465\":1,\"490\":1,\"536\":1,\"549\":3,\"551\":1,\"561\":1,\"562\":1,\"564\":3,\"566\":1,\"616\":1,\"885\":1}}],[\"vr等应用提供了更通用的功能理解范式\",{\"1\":{\"49\":1}}],[\"via\",{\"1\":{\"536\":1}}],[\"vice\",{\"1\":{\"478\":1}}],[\"vicuna工作\",{\"1\":{\"550\":1}}],[\"vicuna\",{\"1\":{\"198\":1,\"204\":1,\"234\":1,\"235\":2}}],[\"vicuna等\",{\"1\":{\"192\":1}}],[\"vicuna等llms无缝集成\",{\"1\":{\"189\":1}}],[\"virtex\",{\"1\":{\"305\":1}}],[\"vilbert\",{\"1\":{\"282\":1}}],[\"vilt预训练的优化目标有两个\",{\"1\":{\"285\":1}}],[\"vilt是首个使用patch\",{\"1\":{\"283\":1}}],[\"vilt是首个将ve设计的如te一样轻量的方法\",{\"1\":{\"282\":1}}],[\"vilt延用single\",{\"1\":{\"283\":1}}],[\"vilt使用预训练的vit来初始化交互的transformer\",{\"1\":{\"281\":1,\"284\":1}}],[\"vilt首次引入了全词掩码和图像增强技术于视觉\",{\"1\":{\"280\":1}}],[\"vilt不仅极大降低了模型参数和计算负担\",{\"1\":{\"280\":1}}],[\"vilt模型提出了一种极简化的视觉嵌入方案\",{\"1\":{\"280\":1}}],[\"vilt\",{\"0\":{\"279\":1},\"1\":{\"261\":2,\"268\":1,\"271\":2,\"279\":3,\"789\":1}}],[\"vit核心\",{\"1\":{\"328\":1}}],[\"vitjx\",{\"1\":{\"327\":1}}],[\"vit这篇论文长达二十多页\",{\"1\":{\"325\":1}}],[\"vit才会慢慢超越resnet\",{\"1\":{\"324\":1}}],[\"vit的效果表现不如resnet\",{\"1\":{\"324\":1}}],[\"vit的表现通常比同等大小的resnets要差一些\",{\"1\":{\"314\":1}}],[\"vit的表现就会超过cnn\",{\"1\":{\"314\":1}}],[\"vit仍是采用transformer中用到layer\",{\"1\":{\"321\":1}}],[\"vit虽然采用的是transformer\",{\"1\":{\"321\":1}}],[\"vit中的多头自注意力模块实现逻辑和transformer基本一致\",{\"1\":{\"322\":1}}],[\"vit中\",{\"1\":{\"320\":1}}],[\"vit原论文中最核心的结论是\",{\"1\":{\"314\":1}}],[\"vit及其衍生模型\",{\"1\":{\"191\":1}}],[\"vits\",{\"1\":{\"186\":2}}],[\"vit没有使用bn\",{\"1\":{\"178\":1}}],[\"vit=\",{\"1\":{\"145\":1,\"147\":1}}],[\"vit=config\",{\"1\":{\"142\":1,\"145\":1,\"147\":1}}],[\"vit梯度检查点层数\",{\"1\":{\"142\":1}}],[\"vit\",{\"0\":{\"463\":1},\"1\":{\"126\":2,\"131\":8,\"132\":1,\"142\":15,\"145\":13,\"146\":7,\"147\":15,\"152\":1,\"160\":2,\"161\":1,\"173\":11,\"178\":1,\"179\":3,\"181\":4,\"186\":1,\"191\":1,\"197\":1,\"201\":1,\"220\":1,\"222\":1,\"223\":2,\"234\":1,\"235\":1,\"268\":2,\"272\":2,\"290\":1,\"297\":2,\"299\":2,\"302\":4,\"304\":1,\"309\":1,\"312\":1,\"317\":3,\"323\":1,\"327\":6,\"395\":1,\"771\":1,\"774\":1,\"785\":1,\"802\":1,\"804\":1}}],[\"vis\",{\"1\":{\"83\":6}}],[\"visiontransformerformaskedimagemodeling\",{\"1\":{\"804\":2}}],[\"visiontransformer\",{\"1\":{\"160\":2,\"319\":2,\"320\":2,\"323\":2,\"327\":1}}],[\"vision\",{\"0\":{\"84\":1,\"231\":1},\"1\":{\"40\":1,\"43\":1,\"46\":1,\"73\":1,\"119\":2,\"134\":1,\"142\":2,\"145\":10,\"146\":4,\"147\":9,\"148\":2,\"150\":1,\"160\":9,\"161\":2,\"171\":4,\"172\":2,\"173\":1,\"179\":1,\"187\":1,\"198\":2,\"231\":1,\"259\":2,\"270\":1,\"272\":2,\"277\":2,\"279\":2,\"282\":1,\"297\":1,\"299\":1,\"302\":1,\"309\":2,\"313\":1,\"314\":3,\"321\":1,\"327\":2,\"328\":1,\"802\":2,\"803\":2}}],[\"visualgenomecaptiondatamodule\",{\"1\":{\"274\":1}}],[\"visualization\",{\"1\":{\"83\":3}}],[\"visualizer\",{\"1\":{\"83\":1}}],[\"visualize\",{\"1\":{\"83\":4,\"463\":1}}],[\"visual\",{\"0\":{\"808\":1},\"1\":{\"37\":1,\"131\":1,\"140\":1,\"142\":2,\"143\":1,\"145\":6,\"146\":2,\"147\":6,\"160\":4,\"161\":2,\"164\":2,\"187\":1,\"232\":1,\"240\":2,\"272\":2,\"275\":2,\"276\":1,\"277\":2,\"280\":1,\"283\":2,\"305\":2,\"309\":1,\"313\":2,\"773\":2,\"802\":10,\"822\":23}}],[\"view\",{\"0\":{\"361\":1},\"1\":{\"30\":1,\"41\":1,\"45\":2,\"59\":4,\"92\":11,\"93\":1,\"96\":2,\"100\":2,\"103\":1,\"107\":3,\"109\":2,\"111\":2,\"114\":1,\"145\":1,\"163\":2,\"170\":1,\"276\":2,\"293\":1,\"295\":3,\"312\":4,\"360\":2,\"361\":7,\"362\":1,\"374\":1,\"425\":1,\"426\":1,\"467\":2,\"468\":2,\"469\":2,\"470\":2,\"471\":2,\"473\":2,\"544\":4,\"581\":2,\"590\":4,\"603\":4,\"605\":3,\"612\":4,\"617\":5,\"618\":6,\"632\":3,\"814\":2,\"840\":2,\"848\":1,\"856\":1,\"857\":3,\"860\":1,\"861\":1,\"885\":3,\"886\":2}}],[\"var\",{\"1\":{\"696\":5}}],[\"var函数\",{\"1\":{\"696\":1}}],[\"various\",{\"1\":{\"234\":1}}],[\"variational\",{\"0\":{\"863\":1},\"1\":{\"773\":1,\"863\":2,\"875\":1}}],[\"variance\",{\"1\":{\"746\":1}}],[\"variant\",{\"1\":{\"204\":1}}],[\"variable等工具函数\",{\"1\":{\"691\":1}}],[\"variable通过creator引用function\",{\"1\":{\"687\":1}}],[\"variable实例通过creator属性引用创建它的function实例\",{\"1\":{\"687\":1}}],[\"variable类封装了numpy的多维数组\",{\"1\":{\"639\":1}}],[\"variable\",{\"0\":{\"689\":1},\"1\":{\"107\":1,\"637\":1,\"638\":1,\"643\":1,\"647\":1,\"652\":2,\"659\":1,\"660\":1,\"664\":1,\"665\":1,\"668\":1,\"672\":1,\"673\":1,\"675\":2,\"676\":1,\"680\":1,\"681\":1,\"682\":2,\"683\":2,\"684\":2,\"685\":1,\"686\":4,\"687\":1,\"688\":7,\"689\":16,\"690\":21,\"691\":11,\"692\":6,\"695\":1,\"696\":6,\"697\":8,\"727\":1,\"840\":5}}],[\"vaswani\",{\"1\":{\"521\":1,\"552\":1}}],[\"vase\",{\"1\":{\"29\":1,\"58\":1,\"68\":1}}],[\"vae模型\",{\"1\":{\"886\":1}}],[\"vae最大的贡献是提供了一种图像压缩思路\",{\"1\":{\"883\":1}}],[\"vae后立刻把pixelcnn换成了diffusion模型\",{\"1\":{\"883\":1}}],[\"vae论文使用了pixelcnn来采样离散分布\",{\"1\":{\"883\":1}}],[\"vae论文中提出的\",{\"1\":{\"877\":1}}],[\"vae编码器的输出是若干个\",{\"1\":{\"883\":1}}],[\"vae编码出来的向量是连续向量\",{\"1\":{\"878\":1}}],[\"vae借鉴了nlp的思想\",{\"1\":{\"883\":1}}],[\"vae是一个把图像编码成离散向量的图像压缩模型\",{\"1\":{\"883\":1}}],[\"vae怎么优化嵌入空间\",{\"1\":{\"879\":1}}],[\"vae怎么优化编码器和解码器\",{\"1\":{\"879\":1}}],[\"vae生成图片的最后一片空缺\",{\"1\":{\"878\":1}}],[\"vae生成出来的图片都不是很好看\",{\"1\":{\"878\":1}}],[\"vae不是一个vae\",{\"1\":{\"878\":1}}],[\"vae不是面临着和ae一样的问题嘛\",{\"1\":{\"878\":1}}],[\"vae把\",{\"1\":{\"878\":1}}],[\"vae把图片编码了一个离散向量\",{\"1\":{\"878\":1}}],[\"vae也是把图像编码成离散向量\",{\"1\":{\"878\":1}}],[\"vae能把图像变成\",{\"1\":{\"878\":1}}],[\"vae能把图像映射成一个\",{\"1\":{\"878\":1}}],[\"vae能编码离散向量的特性\",{\"1\":{\"878\":1}}],[\"vae能利用codebook机制把图像编码成离散向量\",{\"1\":{\"877\":1}}],[\"vae会被归类到图像生成模型中呢\",{\"1\":{\"878\":1}}],[\"vae会编码出离散向量\",{\"1\":{\"878\":1}}],[\"vae会把图片编码成离散向量\",{\"1\":{\"878\":1}}],[\"vae和ae的唯一区别\",{\"1\":{\"878\":1}}],[\"vae根本不是一个图像生成模型\",{\"1\":{\"878\":1}}],[\"vae之所以把图片编码成符合正态分布的连续向量\",{\"1\":{\"878\":1}}],[\"vae里叫做\",{\"1\":{\"878\":1}}],[\"vae没有影响\",{\"1\":{\"878\":1}}],[\"vae就是这样一种改进版的ae\",{\"1\":{\"878\":1}}],[\"vae想要把图像编码成离散向量\",{\"1\":{\"878\":1}}],[\"vae中的核心机制活学活用\",{\"1\":{\"877\":1}}],[\"vae中关键算法的具体形式\",{\"1\":{\"877\":1}}],[\"vae本身的原理\",{\"1\":{\"877\":1}}],[\"vae的离散分布采样\",{\"1\":{\"883\":1}}],[\"vae的离散编码空间采样\",{\"1\":{\"878\":1}}],[\"vae的优化目标由两部分组成\",{\"1\":{\"883\":1}}],[\"vae的编码器怎么输出离散向量\",{\"1\":{\"879\":1}}],[\"vae的编码器和解码器\",{\"1\":{\"878\":1}}],[\"vae的工作过程\",{\"1\":{\"878\":1}}],[\"vae的解码器把离散编码变成图像\",{\"1\":{\"878\":1}}],[\"vae的解码器前\",{\"1\":{\"878\":1}}],[\"vae的作者之前设计了一种图像生成网络\",{\"1\":{\"878\":1}}],[\"vae的作者利用vq\",{\"1\":{\"878\":1}}],[\"vae的作者认为\",{\"1\":{\"878\":1}}],[\"vae的生成图片之所以质量不高\",{\"1\":{\"878\":1}}],[\"vae的实现细节就不在这里赘述了\",{\"1\":{\"878\":1}}],[\"vae的贡献及其对其他工作的影响做一个总结\",{\"1\":{\"877\":1}}],[\"vae的核心思想\",{\"1\":{\"877\":1,\"878\":1,\"879\":1}}],[\"vae的这种建模方法启发了无数的后续工作\",{\"1\":{\"877\":1}}],[\"vae\",{\"0\":{\"850\":1,\"853\":1,\"873\":1,\"876\":1,\"878\":1,\"879\":1},\"1\":{\"170\":1,\"773\":7,\"787\":2,\"792\":3,\"796\":1,\"797\":1,\"800\":1,\"802\":6,\"803\":10,\"807\":1,\"814\":13,\"815\":4,\"817\":5,\"847\":2,\"850\":1,\"853\":2,\"854\":3,\"856\":2,\"857\":4,\"858\":2,\"864\":2,\"866\":7,\"867\":1,\"868\":1,\"869\":3,\"870\":3,\"871\":2,\"872\":1,\"873\":2,\"876\":1,\"880\":6,\"881\":7,\"882\":2,\"885\":7,\"886\":4,\"887\":1}}],[\"vae预训练\",{\"0\":{\"167\":1}}],[\"validity\",{\"1\":{\"840\":2}}],[\"valid\",{\"1\":{\"579\":3,\"840\":3}}],[\"validation\",{\"1\":{\"273\":5,\"316\":1}}],[\"validate\",{\"1\":{\"273\":1,\"274\":4}}],[\"val\",{\"1\":{\"29\":1,\"58\":2,\"65\":1,\"80\":4,\"81\":2,\"82\":1,\"83\":2,\"142\":3,\"145\":3,\"273\":2,\"274\":34,\"276\":2,\"277\":1,\"278\":1,\"316\":13,\"317\":7,\"463\":4,\"544\":1,\"591\":5,\"818\":3}}],[\"value的数量\",{\"1\":{\"405\":1}}],[\"valueerror\",{\"1\":{\"316\":1,\"578\":1}}],[\"value都会进行缓存\",{\"1\":{\"312\":1}}],[\"value在seq\",{\"1\":{\"312\":1}}],[\"value传入\",{\"1\":{\"312\":1}}],[\"value=tokenizer\",{\"1\":{\"579\":1}}],[\"value=tgt\",{\"1\":{\"76\":1}}],[\"value=past\",{\"1\":{\"544\":1}}],[\"value=\",{\"1\":{\"369\":1}}],[\"value=9\",{\"1\":{\"369\":1}}],[\"value=0\",{\"1\":{\"369\":3,\"815\":1}}],[\"value=self\",{\"1\":{\"312\":1}}],[\"value=none\",{\"1\":{\"162\":1,\"312\":2}}],[\"value=memory\",{\"1\":{\"76\":1}}],[\"value=gt\",{\"1\":{\"75\":1}}],[\"value=x\",{\"1\":{\"75\":1}}],[\"values=wd\",{\"1\":{\"803\":1}}],[\"values=lr\",{\"1\":{\"803\":1}}],[\"values=layer\",{\"1\":{\"272\":1}}],[\"values=outputs\",{\"1\":{\"312\":1}}],[\"values=past\",{\"1\":{\"312\":1,\"544\":2}}],[\"values=query\",{\"1\":{\"312\":1}}],[\"values=next\",{\"1\":{\"312\":1}}],[\"values=none\",{\"1\":{\"312\":2,\"544\":1,\"803\":2}}],[\"values=0\",{\"1\":{\"272\":2}}],[\"values\",{\"1\":{\"28\":5,\"92\":1,\"107\":1,\"109\":1,\"272\":5,\"311\":3,\"312\":8,\"544\":19,\"591\":7,\"803\":2}}],[\"value\",{\"1\":{\"14\":1,\"32\":8,\"45\":19,\"68\":3,\"72\":7,\"74\":6,\"162\":5,\"291\":1,\"293\":5,\"294\":2,\"312\":30,\"404\":1,\"405\":1,\"409\":2,\"410\":2,\"412\":1,\"414\":1,\"544\":20,\"579\":1,\"605\":6,\"632\":7,\"688\":4,\"704\":2,\"803\":3,\"815\":2,\"820\":2}}],[\"v2\",{\"1\":{\"16\":1,\"164\":2,\"165\":2,\"167\":2,\"182\":1,\"201\":1,\"395\":1,\"491\":2,\"561\":1,\"704\":2,\"843\":2}}],[\"vlbert\",{\"1\":{\"295\":1}}],[\"vlffn=true\",{\"1\":{\"272\":1}}],[\"vlffn=false\",{\"1\":{\"272\":1}}],[\"vlffn=\",{\"1\":{\"272\":1}}],[\"vlffn\",{\"1\":{\"272\":6,\"277\":46}}],[\"vllms\",{\"1\":{\"189\":1}}],[\"vlp\",{\"0\":{\"122\":1},\"1\":{\"120\":2,\"122\":1,\"123\":1,\"280\":1}}],[\"vlmo\",{\"0\":{\"259\":1,\"270\":1,\"273\":1},\"1\":{\"259\":3,\"260\":6,\"261\":1,\"262\":1,\"265\":2,\"267\":2,\"268\":1,\"269\":5,\"270\":3,\"271\":3,\"272\":2,\"273\":2,\"274\":6,\"275\":5,\"278\":1}}],[\"vlmevalkit\",{\"1\":{\"227\":1}}],[\"vlm\",{\"1\":{\"43\":1}}],[\"vl\",{\"1\":{\"2\":1,\"145\":4,\"147\":4,\"162\":4,\"193\":1,\"202\":1,\"216\":1,\"218\":1,\"219\":2,\"220\":1,\"260\":1,\"261\":1,\"264\":1,\"268\":1,\"272\":10,\"276\":1,\"277\":40,\"311\":4}}],[\"o2\",{\"1\":{\"846\":4}}],[\"omni\",{\"1\":{\"704\":1}}],[\"o3\",{\"1\":{\"704\":3,\"846\":4}}],[\"o3d\",{\"1\":{\"83\":9}}],[\"o1\",{\"1\":{\"703\":1,\"704\":12,\"846\":4}}],[\"o指定输出文件名\",{\"1\":{\"696\":1}}],[\"other指代左操作数a\",{\"1\":{\"690\":1}}],[\"other指代右操作数b\",{\"1\":{\"690\":1}}],[\"other\",{\"1\":{\"690\":7,\"843\":1}}],[\"old\",{\"1\":{\"688\":2}}],[\"our\",{\"1\":{\"615\":1}}],[\"out2\",{\"1\":{\"821\":1}}],[\"out1\",{\"1\":{\"821\":1}}],[\"out=hidden\",{\"1\":{\"793\":2}}],[\"out=none\",{\"1\":{\"358\":1,\"373\":1}}],[\"outfile\",{\"1\":{\"476\":6,\"478\":6}}],[\"outer\",{\"1\":{\"339\":1,\"340\":4}}],[\"outside\",{\"1\":{\"234\":1,\"615\":1}}],[\"output=pooled\",{\"1\":{\"289\":1}}],[\"outputs\",{\"1\":{\"143\":3,\"163\":3,\"273\":7,\"292\":2,\"295\":2,\"312\":26,\"313\":2,\"541\":2,\"544\":3,\"593\":1,\"602\":2,\"603\":7,\"607\":2,\"612\":6,\"614\":4,\"615\":8,\"617\":6,\"618\":6,\"681\":7,\"682\":1,\"684\":1,\"686\":8,\"687\":4,\"688\":9,\"696\":1,\"803\":1}}],[\"output\",{\"1\":{\"28\":1,\"36\":2,\"59\":3,\"76\":1,\"99\":1,\"142\":2,\"143\":2,\"145\":10,\"146\":6,\"147\":12,\"161\":6,\"162\":7,\"163\":11,\"186\":17,\"252\":3,\"254\":1,\"255\":1,\"273\":4,\"275\":2,\"289\":11,\"291\":4,\"292\":1,\"294\":1,\"295\":2,\"309\":5,\"311\":4,\"312\":24,\"363\":1,\"369\":1,\"370\":1,\"383\":1,\"410\":1,\"419\":1,\"421\":1,\"463\":1,\"467\":1,\"470\":1,\"541\":2,\"544\":20,\"575\":10,\"577\":8,\"580\":9,\"593\":3,\"599\":9,\"601\":4,\"602\":7,\"603\":4,\"605\":2,\"607\":4,\"610\":2,\"611\":4,\"612\":4,\"614\":5,\"615\":2,\"617\":4,\"618\":4,\"643\":2,\"660\":4,\"664\":1,\"668\":1,\"681\":2,\"682\":2,\"684\":2,\"686\":4,\"687\":4,\"688\":6,\"696\":5,\"814\":2,\"820\":4,\"848\":8}}],[\"out\",{\"1\":{\"28\":3,\"35\":2,\"40\":5,\"46\":5,\"59\":2,\"73\":5,\"92\":7,\"96\":4,\"100\":4,\"186\":19,\"321\":5,\"358\":1,\"372\":8,\"373\":1,\"388\":2,\"389\":2,\"390\":2,\"475\":1,\"476\":5,\"478\":5,\"521\":1,\"537\":2,\"538\":1,\"541\":6,\"590\":4,\"605\":1,\"793\":2,\"794\":4,\"815\":4,\"817\":10,\"821\":8,\"840\":3,\"848\":3,\"885\":2}}],[\"occurred\",{\"1\":{\"478\":1}}],[\"occurrences\",{\"1\":{\"478\":1}}],[\"ocr任务\",{\"1\":{\"229\":1}}],[\"ocr相关任务\",{\"1\":{\"228\":1}}],[\"ocr数据\",{\"1\":{\"225\":1}}],[\"ocr能力和高分辨率处理能力\",{\"1\":{\"223\":1}}],[\"ocr\",{\"1\":{\"198\":1,\"203\":1,\"215\":2,\"225\":1}}],[\"oov\",{\"1\":{\"475\":1,\"564\":1}}],[\"os\",{\"1\":{\"68\":3,\"83\":3,\"142\":1,\"302\":11,\"303\":2,\"304\":14,\"316\":8,\"463\":1,\"577\":4,\"578\":1,\"581\":1,\"696\":6,\"840\":3}}],[\"opus\",{\"1\":{\"704\":3}}],[\"op\",{\"1\":{\"690\":3}}],[\"operations\",{\"1\":{\"370\":1}}],[\"operating\",{\"0\":{\"450\":1},\"1\":{\"82\":1}}],[\"openwebtext2\",{\"1\":{\"704\":1}}],[\"openwebtext等\",{\"1\":{\"565\":1}}],[\"openwebtext\",{\"1\":{\"560\":1,\"561\":1}}],[\"openbookqa\",{\"1\":{\"549\":1}}],[\"openclip\",{\"1\":{\"201\":1,\"202\":1}}],[\"opengvlab\",{\"1\":{\"187\":1}}],[\"open3d\",{\"1\":{\"83\":1}}],[\"openai首先尝试了virtex模型\",{\"1\":{\"305\":1}}],[\"openai从网络上收集了4亿条数据进行实验\",{\"1\":{\"305\":1}}],[\"openai从网络上收集了总计4亿对文本和图像\",{\"1\":{\"299\":1}}],[\"openai\",{\"1\":{\"218\":1,\"232\":2,\"297\":1,\"302\":2,\"304\":1,\"495\":1,\"537\":3,\"539\":4,\"703\":1,\"704\":10,\"712\":1,\"792\":1}}],[\"openaccess\",{\"1\":{\"60\":1}}],[\"openad\",{\"1\":{\"7\":1}}],[\"opening\",{\"1\":{\"28\":2,\"78\":1,\"303\":1,\"304\":1}}],[\"openimage\",{\"1\":{\"17\":1}}],[\"openkd\",{\"1\":{\"7\":1}}],[\"open\",{\"1\":{\"4\":1,\"6\":1,\"7\":1,\"28\":2,\"29\":2,\"31\":2,\"58\":2,\"62\":1,\"63\":1,\"67\":1,\"68\":3,\"83\":2,\"142\":1,\"214\":2,\"277\":2,\"302\":1,\"303\":1,\"304\":2,\"316\":2,\"336\":1,\"476\":4,\"477\":1,\"478\":7,\"539\":1,\"541\":20,\"545\":1,\"554\":1,\"577\":3,\"578\":3,\"696\":2}}],[\"option\",{\"1\":{\"83\":1}}],[\"optional\",{\"1\":{\"43\":1,\"76\":6,\"163\":1,\"366\":1,\"372\":2,\"544\":10,\"817\":1}}],[\"optimize\",{\"1\":{\"814\":3}}],[\"optimized\",{\"1\":{\"557\":1,\"563\":1}}],[\"optimizers\",{\"1\":{\"273\":1,\"840\":1}}],[\"optimizer\",{\"1\":{\"80\":3,\"81\":2,\"82\":2,\"142\":5,\"145\":5,\"147\":5,\"159\":3,\"186\":4,\"252\":6,\"273\":5,\"323\":1,\"581\":2,\"700\":1,\"803\":4,\"840\":6,\"848\":3,\"856\":3,\"860\":3,\"885\":3,\"886\":3}}],[\"optimizing\",{\"1\":{\"486\":1}}],[\"optimization算法进一步优化模型行为\",{\"1\":{\"535\":1}}],[\"optimization\",{\"1\":{\"232\":2,\"537\":1}}],[\"optim\",{\"1\":{\"80\":3,\"142\":1,\"145\":1,\"147\":1,\"186\":1,\"252\":1,\"395\":1,\"803\":1,\"840\":2,\"848\":3,\"852\":2,\"856\":1,\"860\":1,\"885\":1,\"886\":1}}],[\"opt\",{\"1\":{\"80\":2,\"81\":1,\"83\":3,\"552\":1,\"840\":15}}],[\"observation\",{\"1\":{\"758\":1}}],[\"observations\",{\"1\":{\"37\":1}}],[\"obj\",{\"1\":{\"29\":4,\"45\":7,\"58\":9,\"59\":28,\"352\":4,\"687\":4,\"690\":4}}],[\"objcot\",{\"1\":{\"24\":2}}],[\"objaverse\",{\"1\":{\"17\":1}}],[\"objective\",{\"1\":{\"537\":1}}],[\"objectives\",{\"0\":{\"153\":1,\"285\":1},\"1\":{\"275\":7,\"278\":1}}],[\"objects\",{\"1\":{\"25\":1,\"68\":3,\"83\":3}}],[\"object\",{\"0\":{\"11\":1},\"1\":{\"4\":1,\"6\":1,\"11\":1,\"13\":1,\"19\":2,\"20\":1,\"23\":1,\"28\":16,\"29\":9,\"30\":2,\"32\":1,\"33\":2,\"37\":1,\"47\":1,\"58\":9,\"59\":1,\"60\":3,\"67\":1,\"68\":4,\"82\":2,\"186\":1,\"470\":1,\"696\":1,\"802\":1}}],[\"oq\",{\"1\":{\"32\":1}}],[\"o\",{\"1\":{\"30\":5,\"33\":5,\"35\":3,\"74\":2,\"75\":1,\"112\":2,\"590\":2,\"696\":2,\"697\":1,\"704\":1,\"713\":1,\"846\":4}}],[\"od\",{\"1\":{\"29\":3}}],[\"ok=true\",{\"1\":{\"577\":2,\"840\":2}}],[\"okvqa\",{\"1\":{\"204\":1}}],[\"ok\",{\"1\":{\"29\":4,\"32\":20,\"33\":2}}],[\"once\",{\"1\":{\"544\":1}}],[\"onnx\",{\"1\":{\"426\":1}}],[\"only=true\",{\"1\":{\"274\":1,\"581\":1}}],[\"only=image\",{\"1\":{\"274\":2}}],[\"only=false\",{\"1\":{\"274\":2}}],[\"only=self\",{\"1\":{\"274\":4}}],[\"only\",{\"1\":{\"262\":2,\"264\":4,\"266\":5,\"272\":1,\"274\":10,\"277\":1,\"289\":1,\"313\":1,\"594\":1,\"610\":1,\"616\":2,\"617\":1,\"704\":5,\"809\":1}}],[\"on\",{\"0\":{\"863\":1},\"1\":{\"28\":2,\"31\":2,\"60\":3,\"63\":1,\"82\":1,\"83\":2,\"273\":16,\"300\":3,\"478\":1,\"632\":1,\"697\":1,\"863\":2}}],[\"onecycle\",{\"1\":{\"395\":1}}],[\"ones\",{\"1\":{\"43\":8,\"92\":1,\"142\":1,\"143\":1,\"145\":3,\"146\":1,\"147\":3,\"160\":1,\"161\":1,\"162\":1,\"186\":1,\"272\":3,\"278\":1,\"309\":1,\"311\":3,\"312\":1,\"313\":1,\"672\":1,\"682\":1,\"684\":1,\"686\":1,\"688\":3,\"886\":1}}],[\"one\",{\"1\":{\"28\":1,\"145\":2,\"154\":1,\"155\":1,\"156\":1,\"157\":3,\"159\":3,\"170\":2,\"252\":2,\"323\":1,\"527\":1,\"528\":1,\"529\":1,\"531\":1,\"581\":2,\"738\":1,\"758\":1,\"794\":4,\"795\":7,\"796\":6,\"803\":3,\"821\":11,\"832\":1,\"860\":1,\"861\":1,\"881\":1}}],[\"ov\",{\"1\":{\"32\":1}}],[\"overwrite\",{\"1\":{\"593\":1}}],[\"overall\",{\"1\":{\"82\":2}}],[\"over\",{\"0\":{\"469\":1},\"1\":{\"22\":1,\"82\":3,\"469\":2,\"747\":1}}],[\"ovag旨在通过额外指令\",{\"1\":{\"7\":1}}],[\"ovag\",{\"1\":{\"6\":1,\"7\":1}}],[\"offsetted\",{\"1\":{\"815\":2}}],[\"offset\",{\"1\":{\"425\":2,\"815\":4}}],[\"official\",{\"1\":{\"327\":1}}],[\"off\",{\"1\":{\"303\":1,\"304\":1,\"857\":3,\"861\":1,\"886\":1}}],[\"of\",{\"0\":{\"9\":1,\"28\":1,\"126\":1,\"272\":1,\"501\":1,\"731\":1},\"1\":{\"7\":1,\"26\":1,\"28\":16,\"31\":2,\"59\":2,\"83\":3,\"92\":1,\"120\":1,\"138\":1,\"142\":2,\"143\":3,\"145\":1,\"186\":1,\"234\":2,\"252\":1,\"254\":2,\"255\":3,\"256\":1,\"259\":2,\"260\":1,\"264\":2,\"270\":1,\"274\":2,\"277\":1,\"299\":4,\"300\":6,\"301\":3,\"302\":2,\"303\":1,\"304\":2,\"305\":3,\"312\":1,\"316\":1,\"387\":1,\"415\":1,\"475\":1,\"478\":23,\"485\":1,\"487\":1,\"488\":2,\"489\":1,\"501\":2,\"502\":1,\"515\":1,\"562\":1,\"571\":1,\"584\":1,\"594\":1,\"616\":2,\"617\":1,\"628\":1,\"630\":1,\"632\":1,\"706\":1,\"718\":1,\"758\":1,\"764\":2,\"815\":1,\"821\":2,\"840\":12}}],[\"or门组合\",{\"1\":{\"385\":1}}],[\"ordered\",{\"1\":{\"476\":3,\"478\":3}}],[\"ordereddict\",{\"1\":{\"323\":1}}],[\"order=\",{\"1\":{\"423\":1}}],[\"order\",{\"1\":{\"273\":1,\"339\":1,\"422\":2,\"423\":1,\"478\":1,\"840\":2}}],[\"orthogonal\",{\"1\":{\"108\":1}}],[\"original\",{\"1\":{\"98\":1,\"327\":1,\"369\":2,\"426\":1,\"605\":1,\"857\":1}}],[\"or\",{\"1\":{\"40\":1,\"46\":2,\"59\":2,\"104\":1,\"162\":1,\"272\":2,\"279\":2,\"299\":2,\"321\":2,\"322\":1,\"323\":2,\"578\":1,\"593\":1,\"599\":1,\"609\":1,\"801\":1,\"820\":1,\"821\":1}}],[\"org\",{\"1\":{\"4\":1,\"37\":1,\"47\":1,\"85\":1,\"102\":1,\"187\":1,\"231\":1,\"306\":1,\"327\":1,\"821\":1}}],[\"oracle\",{\"0\":{\"2\":1},\"1\":{\"0\":1}}],[\"gc可处理开发者未显式解决的循环引用\",{\"1\":{\"687\":1}}],[\"gc可能无法及时释放内存\",{\"1\":{\"687\":1}}],[\"gc作为兜底机制\",{\"1\":{\"687\":1}}],[\"gc与弱引用的互补关系\",{\"1\":{\"687\":1}}],[\"gc需要扫描整个对象图来检测循环引用\",{\"1\":{\"687\":1}}],[\"gc是一种后台机制\",{\"1\":{\"687\":1}}],[\"gc\",{\"1\":{\"687\":2}}],[\"gcc\",{\"1\":{\"274\":1}}],[\"gx1\",{\"1\":{\"690\":2}}],[\"gx0\",{\"1\":{\"690\":2}}],[\"gxs\",{\"1\":{\"682\":6,\"684\":5,\"686\":5,\"688\":5}}],[\"gx\",{\"1\":{\"661\":2,\"682\":2,\"684\":3,\"686\":3,\"688\":3,\"690\":2}}],[\"gys\",{\"1\":{\"681\":1,\"682\":2,\"684\":2,\"686\":2,\"687\":1,\"688\":2}}],[\"gy\",{\"1\":{\"660\":1,\"661\":2,\"690\":14}}],[\"gsm8k\",{\"1\":{\"549\":1}}],[\"gumbelnoise\",{\"1\":{\"796\":1}}],[\"gumbel\",{\"0\":{\"795\":1,\"819\":1},\"1\":{\"770\":1,\"793\":1,\"794\":2,\"795\":7,\"796\":4,\"808\":1,\"809\":1,\"817\":3,\"819\":9,\"820\":3,\"821\":5}}],[\"gutenberg\",{\"1\":{\"548\":1}}],[\"guidance\",{\"0\":{\"816\":1},\"1\":{\"816\":1}}],[\"guid\",{\"1\":{\"594\":1}}],[\"guide\",{\"1\":{\"78\":1,\"488\":1}}],[\"guided\",{\"1\":{\"60\":3,\"82\":1}}],[\"guitar\",{\"1\":{\"29\":1}}],[\"gmm\",{\"1\":{\"455\":2}}],[\"gqa\",{\"1\":{\"203\":1,\"204\":1,\"704\":3}}],[\"gan＝\",{\"1\":{\"841\":1}}],[\"gan\",{\"0\":{\"823\":1,\"840\":1},\"1\":{\"787\":1,\"789\":1,\"823\":1,\"840\":3,\"847\":2}}],[\"gans\",{\"1\":{\"785\":1}}],[\"gaussian\",{\"0\":{\"750\":1,\"753\":1},\"1\":{\"746\":1,\"750\":1,\"752\":1,\"754\":1}}],[\"gaussianblur\",{\"1\":{\"186\":3}}],[\"garage\",{\"1\":{\"300\":1}}],[\"gap\",{\"1\":{\"214\":2}}],[\"gather函数比较灵活\",{\"1\":{\"581\":1}}],[\"gathered\",{\"1\":{\"278\":12}}],[\"gather\",{\"1\":{\"145\":2,\"257\":2,\"277\":1,\"278\":3,\"580\":4}}],[\"gamma=gamma\",{\"1\":{\"470\":1}}],[\"gamma=0\",{\"1\":{\"80\":1}}],[\"gamma\",{\"1\":{\"78\":3,\"272\":10,\"470\":3}}],[\"glm4\",{\"1\":{\"704\":1}}],[\"glm系列模型是\",{\"1\":{\"704\":1}}],[\"glm\",{\"1\":{\"703\":1,\"704\":5}}],[\"gleu\",{\"1\":{\"599\":2}}],[\"glove\",{\"1\":{\"531\":1}}],[\"global\",{\"1\":{\"107\":1,\"109\":8,\"110\":1,\"111\":1,\"112\":1,\"186\":10,\"265\":1,\"268\":1,\"273\":1,\"275\":1,\"278\":1,\"336\":2}}],[\"glue基准\",{\"1\":{\"566\":1}}],[\"glue多任务提升5\",{\"1\":{\"507\":1}}],[\"glue\",{\"1\":{\"204\":1,\"559\":1,\"561\":1}}],[\"glasses\",{\"1\":{\"29\":1}}],[\"gt\",{\"0\":{\"64\":1},\"1\":{\"64\":2,\"68\":2,\"75\":5,\"78\":1,\"81\":2,\"82\":2,\"467\":1,\"468\":2,\"469\":2}}],[\"gp\",{\"1\":{\"455\":1,\"841\":1}}],[\"gpblock\",{\"1\":{\"75\":1}}],[\"gpb\",{\"1\":{\"70\":3}}],[\"gpt系列\",{\"1\":{\"552\":1}}],[\"gpt2pretrainedmodel\",{\"1\":{\"544\":1}}],[\"gpt2model\",{\"1\":{\"544\":1}}],[\"gpt2attention\",{\"1\":{\"544\":3}}],[\"gpt2block\",{\"1\":{\"544\":3}}],[\"gpt2config\",{\"1\":{\"544\":2}}],[\"gpt2\",{\"1\":{\"541\":2,\"544\":5}}],[\"gpt2tokenizer\",{\"1\":{\"541\":2,\"544\":2}}],[\"gpt2lmheadmodel\",{\"1\":{\"541\":2,\"544\":2}}],[\"gpt和bert通过不同训练目标\",{\"1\":{\"568\":1}}],[\"gpt和bert\",{\"1\":{\"246\":1}}],[\"gpt\",{\"0\":{\"236\":2,\"312\":1,\"505\":1,\"518\":1,\"525\":1},\"1\":{\"63\":3,\"173\":1,\"214\":2,\"215\":2,\"218\":1,\"232\":5,\"235\":2,\"236\":6,\"475\":1,\"492\":2,\"495\":2,\"505\":1,\"518\":1,\"519\":1,\"520\":1,\"521\":10,\"522\":8,\"523\":1,\"525\":1,\"526\":1,\"527\":3,\"528\":6,\"529\":13,\"530\":7,\"531\":11,\"532\":1,\"536\":2,\"537\":2,\"538\":14,\"539\":2,\"548\":1,\"549\":2,\"552\":1,\"616\":2,\"703\":8,\"704\":21,\"706\":1,\"708\":1}}],[\"gpu上的矩阵运算都是充分优化和高度并行的\",{\"1\":{\"621\":1}}],[\"gpu上推理时\",{\"1\":{\"549\":1}}],[\"gpu上训练12天\",{\"1\":{\"299\":1}}],[\"gpu上训练18天\",{\"1\":{\"299\":1}}],[\"gpu服务器上训练vit\",{\"1\":{\"184\":1}}],[\"gpu节点\",{\"1\":{\"131\":1}}],[\"gpu\",{\"1\":{\"40\":1,\"112\":1,\"145\":3,\"170\":3,\"173\":1,\"179\":1,\"184\":1,\"208\":1,\"209\":1,\"246\":1,\"252\":1,\"257\":3,\"265\":1,\"268\":2,\"274\":1,\"278\":5,\"378\":3,\"495\":1,\"548\":1,\"561\":1,\"593\":2,\"621\":1,\"705\":1,\"774\":1,\"803\":1}}],[\"g\",{\"1\":{\"40\":1,\"72\":1,\"73\":1,\"105\":1,\"191\":1,\"196\":1,\"197\":1,\"201\":2,\"202\":3,\"696\":6,\"840\":8,\"846\":9}}],[\"gehman\",{\"1\":{\"536\":1}}],[\"gemini系列\",{\"1\":{\"228\":1}}],[\"gemini系列和qwen\",{\"1\":{\"216\":1}}],[\"gemini\",{\"1\":{\"215\":1,\"218\":1,\"703\":1,\"704\":14}}],[\"gen\",{\"1\":{\"840\":4,\"861\":2}}],[\"generic\",{\"1\":{\"187\":1,\"631\":1}}],[\"generator模型结构图\",{\"1\":{\"624\":1}}],[\"generator\",{\"0\":{\"624\":1},\"1\":{\"623\":3,\"624\":2,\"802\":2,\"840\":12}}],[\"generative\",{\"0\":{\"313\":1,\"785\":1},\"1\":{\"198\":1,\"313\":1,\"505\":1,\"516\":1,\"704\":1}}],[\"generation能力\",{\"1\":{\"307\":1}}],[\"generation\",{\"0\":{\"312\":1,\"709\":1},\"1\":{\"28\":4,\"119\":2,\"134\":1,\"312\":1,\"478\":1,\"486\":1,\"686\":11,\"688\":3,\"689\":1,\"696\":1,\"709\":1,\"718\":1,\"805\":1,\"812\":1,\"817\":1,\"840\":1,\"843\":1}}],[\"generated\",{\"1\":{\"840\":1,\"848\":2,\"857\":3,\"886\":1}}],[\"generate\",{\"1\":{\"143\":3,\"313\":2,\"544\":2,\"817\":1,\"820\":2,\"840\":1}}],[\"genome\",{\"1\":{\"131\":1,\"140\":1,\"280\":1}}],[\"gelu\",{\"1\":{\"73\":2,\"272\":1,\"321\":4,\"323\":2,\"514\":1,\"580\":5}}],[\"getcwd\",{\"1\":{\"302\":1,\"304\":1}}],[\"getattr\",{\"1\":{\"276\":2,\"277\":7,\"278\":2,\"688\":1}}],[\"get\",{\"1\":{\"29\":1,\"40\":1,\"58\":3,\"59\":3,\"80\":1,\"83\":3,\"93\":2,\"96\":2,\"101\":2,\"186\":1,\"274\":2,\"276\":1,\"277\":4,\"278\":2,\"302\":10,\"303\":4,\"304\":12,\"463\":1,\"476\":5,\"477\":10,\"478\":16,\"544\":1,\"580\":1,\"584\":1,\"594\":1,\"605\":1,\"696\":4,\"801\":1,\"803\":2,\"815\":4,\"817\":1,\"821\":2}}],[\"getitem\",{\"1\":{\"29\":2,\"58\":1,\"68\":1,\"142\":1,\"274\":2,\"316\":1,\"689\":1}}],[\"geometries\",{\"1\":{\"83\":1}}],[\"geometric\",{\"1\":{\"11\":1,\"28\":4,\"744\":1}}],[\"geometry\",{\"1\":{\"4\":1,\"5\":1,\"83\":3}}],[\"gibbs\",{\"1\":{\"831\":1}}],[\"gibson\",{\"1\":{\"49\":1}}],[\"git\",{\"1\":{\"593\":2,\"620\":1}}],[\"github\",{\"1\":{\"4\":1,\"37\":1,\"47\":1,\"60\":1,\"85\":2,\"102\":2,\"119\":1,\"140\":1,\"148\":1,\"164\":1,\"171\":1,\"172\":1,\"187\":1,\"231\":1,\"240\":1,\"259\":1,\"270\":1,\"277\":1,\"279\":1,\"306\":1,\"316\":1,\"327\":2,\"463\":1,\"472\":1,\"544\":1,\"547\":1,\"548\":1,\"570\":1,\"593\":1,\"620\":1,\"633\":1,\"679\":1,\"694\":1,\"699\":1,\"764\":1}}],[\"gi\",{\"1\":{\"285\":3}}],[\"giraffe\",{\"1\":{\"285\":1}}],[\"gid\",{\"1\":{\"186\":4}}],[\"given\",{\"1\":{\"478\":4}}],[\"give\",{\"1\":{\"28\":1}}],[\"gick\",{\"1\":{\"6\":1}}],[\"goldstein\",{\"1\":{\"692\":3,\"696\":3}}],[\"golang\",{\"1\":{\"2\":1}}],[\"goodfellow\",{\"1\":{\"840\":1}}],[\"good\",{\"1\":{\"577\":1}}],[\"googleapis\",{\"1\":{\"593\":1}}],[\"google\",{\"1\":{\"4\":1,\"47\":1,\"73\":1,\"218\":1,\"327\":2,\"571\":2,\"704\":3}}],[\"gotcha\",{\"1\":{\"551\":1}}],[\"greet\",{\"1\":{\"341\":1,\"346\":10,\"351\":2}}],[\"greater\",{\"1\":{\"821\":1}}],[\"great通过模拟人类多步推理\",{\"1\":{\"7\":1}}],[\"great通过微调mllms并设计mhacot策略解决这一问题\",{\"1\":{\"7\":1}}],[\"great框架通过以下设计模拟这一过程\",{\"1\":{\"6\":1}}],[\"great\",{\"0\":{\"4\":1},\"1\":{\"4\":2,\"5\":1,\"8\":2,\"21\":1,\"23\":3,\"26\":2,\"29\":2,\"30\":1}}],[\"grit\",{\"1\":{\"225\":1}}],[\"grids\",{\"1\":{\"114\":1}}],[\"grid\",{\"1\":{\"103\":1,\"280\":1,\"283\":1,\"318\":3,\"697\":1}}],[\"grok\",{\"1\":{\"218\":1,\"703\":1}}],[\"group流程图\",{\"1\":{\"92\":1}}],[\"grouped\",{\"1\":{\"92\":12,\"96\":13,\"704\":2}}],[\"groups=40\",{\"1\":{\"83\":1}}],[\"groups=opt\",{\"1\":{\"80\":1}}],[\"groups\",{\"1\":{\"80\":1,\"186\":4}}],[\"group\",{\"1\":{\"72\":1,\"75\":2,\"92\":23,\"93\":3,\"96\":3,\"101\":4,\"234\":1}}],[\"grouping阶段\",{\"1\":{\"75\":1}}],[\"grouping\",{\"0\":{\"72\":1,\"90\":1,\"95\":1,\"97\":1},\"1\":{\"71\":1,\"75\":3,\"87\":1,\"88\":2,\"90\":1,\"93\":4,\"94\":2,\"98\":1}}],[\"grounded\",{\"0\":{\"312\":1},\"1\":{\"126\":2,\"127\":2,\"312\":1}}],[\"ground\",{\"0\":{\"64\":1},\"1\":{\"78\":2,\"82\":2,\"162\":1,\"248\":1,\"277\":7,\"467\":2,\"468\":1,\"469\":2,\"470\":1,\"471\":1,\"840\":1}}],[\"grounding\",{\"1\":{\"4\":1,\"7\":2,\"37\":1,\"47\":1,\"48\":1}}],[\"gray\",{\"1\":{\"857\":3,\"861\":1,\"886\":1}}],[\"graph函数\",{\"1\":{\"696\":1}}],[\"graph\",{\"1\":{\"696\":14}}],[\"graph=true\",{\"1\":{\"695\":1}}],[\"graphviz\",{\"1\":{\"695\":1,\"696\":3}}],[\"gram\",{\"1\":{\"552\":1,\"772\":1}}],[\"gram重叠率\",{\"1\":{\"522\":1}}],[\"grams\",{\"1\":{\"305\":2}}],[\"grad模式优化内存管理\",{\"1\":{\"693\":1}}],[\"grad函数\",{\"1\":{\"688\":1}}],[\"grad默认false\",{\"1\":{\"688\":1}}],[\"grad参数及时清除中间变量导数\",{\"1\":{\"688\":1}}],[\"grad参数\",{\"1\":{\"688\":1}}],[\"grad=false\",{\"1\":{\"272\":1,\"688\":1,\"840\":2}}],[\"grad=true\",{\"1\":{\"272\":2}}],[\"gradientcheckpointinglayer\",{\"1\":{\"544\":1}}],[\"gradients\",{\"1\":{\"186\":1,\"312\":1}}],[\"gradient\",{\"1\":{\"167\":1,\"252\":1,\"254\":1,\"255\":1,\"544\":1,\"676\":1,\"697\":2,\"840\":2,\"881\":1,\"885\":1}}],[\"grad\",{\"0\":{\"365\":1},\"1\":{\"80\":2,\"81\":1,\"142\":6,\"145\":7,\"146\":2,\"147\":7,\"159\":1,\"161\":1,\"162\":1,\"163\":1,\"169\":3,\"170\":1,\"186\":4,\"252\":1,\"254\":1,\"255\":1,\"256\":1,\"257\":1,\"273\":5,\"278\":2,\"300\":2,\"302\":2,\"304\":2,\"311\":1,\"327\":1,\"541\":1,\"544\":1,\"581\":1,\"659\":1,\"662\":7,\"665\":2,\"668\":2,\"672\":2,\"675\":1,\"676\":3,\"682\":4,\"683\":1,\"684\":7,\"686\":8,\"687\":1,\"688\":16,\"689\":1,\"690\":3,\"691\":2,\"692\":6,\"697\":6,\"803\":3,\"814\":1,\"817\":1,\"820\":1,\"821\":1,\"840\":2,\"848\":2,\"856\":1,\"857\":2,\"860\":1,\"861\":1,\"885\":1,\"886\":4}}],[\"grasping\",{\"1\":{\"63\":2,\"78\":1,\"470\":1}}],[\"grasp\",{\"1\":{\"6\":1,\"7\":1,\"23\":1,\"28\":2,\"29\":1,\"31\":2,\"40\":1,\"58\":1,\"62\":1,\"63\":1,\"67\":1,\"68\":2,\"70\":1,\"71\":1}}],[\"转化为更有信息的样本\",{\"1\":{\"872\":1}}],[\"转化为一系列\",{\"1\":{\"248\":1}}],[\"转化成功之后\",{\"1\":{\"593\":1}}],[\"转向\",{\"1\":{\"535\":1}}],[\"转换视角\",{\"0\":{\"741\":1}}],[\"转换后的图像展示x0\",{\"1\":{\"696\":1}}],[\"转换成样本\",{\"1\":{\"840\":1}}],[\"转换成y序列的权重参数组成的矩阵\",{\"1\":{\"481\":1}}],[\"转换成一个固定大小的特征图\",{\"1\":{\"386\":1}}],[\"转换成\",{\"1\":{\"386\":1}}],[\"转换为图像\",{\"1\":{\"886\":1}}],[\"转换为向量\",{\"1\":{\"821\":1}}],[\"转换为一系列高维向量表示\",{\"1\":{\"622\":1}}],[\"转换为一组离散的视觉\",{\"1\":{\"167\":1}}],[\"转换为概率\",{\"1\":{\"471\":1}}],[\"转换为可优化的损失函数\",{\"1\":{\"469\":1}}],[\"转换为张量\",{\"1\":{\"463\":1}}],[\"转换为固定大小\",{\"1\":{\"387\":1}}],[\"转换为元组形式\",{\"1\":{\"318\":1}}],[\"转换为视觉\",{\"1\":{\"272\":1}}],[\"转换为语言嵌入\",{\"1\":{\"235\":1}}],[\"转换为语言模型可用的\",{\"1\":{\"234\":1}}],[\"转换为同构表示\",{\"1\":{\"59\":1}}],[\"转换为嵌入向量\",{\"1\":{\"40\":1}}],[\"转换为\",{\"1\":{\"40\":1,\"43\":1,\"82\":1,\"100\":1,\"170\":1,\"186\":1,\"272\":1,\"277\":1,\"821\":1}}],[\"转折点\",{\"1\":{\"385\":2}}],[\"转为整数像素值\",{\"1\":{\"848\":1}}],[\"转为连续张量\",{\"1\":{\"362\":1}}],[\"转为\",{\"1\":{\"277\":1,\"814\":1,\"848\":1}}],[\"转为numpy数组\",{\"1\":{\"83\":1}}],[\"转成\",{\"1\":{\"276\":1}}],[\"转成嵌入向量\",{\"1\":{\"276\":1}}],[\"转置卷积等\",{\"1\":{\"821\":1}}],[\"转置卷积\",{\"1\":{\"821\":1}}],[\"转置前\",{\"1\":{\"426\":1}}],[\"转置包括逻辑转置和物理转置\",{\"1\":{\"426\":1}}],[\"转置\",{\"0\":{\"426\":1},\"1\":{\"370\":1,\"426\":2}}],[\"转置为\",{\"1\":{\"83\":1}}],[\"转置后的步长是\",{\"1\":{\"426\":1}}],[\"转置后的矩阵步长是\",{\"1\":{\"426\":1}}],[\"转置后\",{\"1\":{\"34\":1,\"73\":1,\"426\":1}}],[\"转\",{\"1\":{\"3\":1}}],[\"转型\",{\"1\":{\"2\":1}}],[\"cfg\",{\"1\":{\"816\":2,\"817\":2}}],[\"c为常数指数\",{\"1\":{\"690\":1}}],[\"c为输入token的总维度\",{\"1\":{\"322\":1}}],[\"c中\",{\"1\":{\"690\":1}}],[\"c并求导\",{\"1\":{\"690\":1}}],[\"c的引用计数仍为1\",{\"1\":{\"687\":1}}],[\"cdf\",{\"1\":{\"728\":2,\"746\":1,\"871\":1}}],[\"cd\",{\"1\":{\"593\":1,\"620\":1}}],[\"c4\",{\"1\":{\"547\":1,\"548\":1}}],[\"ctrl\",{\"1\":{\"531\":1}}],[\"cb\",{\"1\":{\"529\":1}}],[\"cbt测试模型对不同词类\",{\"1\":{\"522\":1}}],[\"cbt\",{\"1\":{\"522\":1}}],[\"cbow\",{\"1\":{\"299\":1}}],[\"c++\",{\"1\":{\"336\":1}}],[\"c+d\",{\"1\":{\"92\":3}}],[\"c3\",{\"1\":{\"333\":1}}],[\"c2\",{\"1\":{\"333\":1}}],[\"c=in\",{\"1\":{\"319\":1,\"320\":1,\"323\":1}}],[\"c=3\",{\"1\":{\"318\":1,\"319\":1,\"320\":1,\"323\":1,\"370\":1}}],[\"c=通道数\",{\"1\":{\"272\":1}}],[\"ck\",{\"1\":{\"255\":1,\"367\":1}}],[\"ckpt=false\",{\"1\":{\"145\":1,\"147\":1}}],[\"ckpt=config\",{\"1\":{\"142\":1,\"145\":1,\"147\":1}}],[\"ckpt\",{\"1\":{\"142\":9,\"145\":6,\"146\":4,\"147\":6,\"169\":2,\"593\":1}}],[\"c或internvl\",{\"1\":{\"197\":1}}],[\"cc\",{\"1\":{\"559\":1,\"560\":1,\"561\":1}}],[\"ccbench等中文基准上大幅领先\",{\"1\":{\"228\":1}}],[\"cc3m\",{\"1\":{\"140\":1,\"234\":1}}],[\"cc12m\",{\"1\":{\"140\":1}}],[\"ceil\",{\"1\":{\"386\":1}}],[\"centercrop\",{\"1\":{\"317\":1}}],[\"center\",{\"1\":{\"186\":20,\"316\":2}}],[\"centering\",{\"1\":{\"173\":1,\"178\":1,\"183\":1}}],[\"centroids\",{\"1\":{\"92\":4}}],[\"centroid\",{\"1\":{\"83\":2,\"92\":2}}],[\"ce\",{\"1\":{\"80\":1,\"81\":3,\"277\":1,\"470\":15,\"473\":10}}],[\"celoss\",{\"1\":{\"78\":4}}],[\"chroma\",{\"1\":{\"717\":1}}],[\"christiano\",{\"1\":{\"536\":1}}],[\"chinesegluedatasets\",{\"1\":{\"593\":2}}],[\"chinese\",{\"1\":{\"593\":5}}],[\"chinchilla\",{\"1\":{\"549\":1,\"552\":1}}],[\"children\",{\"1\":{\"522\":1}}],[\"chunks\",{\"1\":{\"374\":5}}],[\"chunk\",{\"0\":{\"374\":1},\"1\":{\"186\":2,\"374\":2}}],[\"chunking\",{\"1\":{\"112\":1}}],[\"check\",{\"1\":{\"676\":1}}],[\"checkpointing\",{\"1\":{\"544\":1,\"548\":1}}],[\"checkpoint\",{\"1\":{\"82\":2,\"83\":2,\"147\":1,\"169\":1,\"581\":5,\"593\":2}}],[\"chen\",{\"1\":{\"126\":1}}],[\"choices\",{\"1\":{\"618\":9}}],[\"choice\",{\"1\":{\"63\":1,\"579\":1,\"618\":1}}],[\"chapter3\",{\"1\":{\"696\":3,\"697\":2}}],[\"chapter2\",{\"1\":{\"691\":7}}],[\"challenge中零样本即可取得88\",{\"1\":{\"529\":1}}],[\"challenge\",{\"1\":{\"522\":1}}],[\"chan\",{\"1\":{\"793\":8,\"821\":2}}],[\"chans=in\",{\"1\":{\"272\":1}}],[\"chans=3\",{\"1\":{\"272\":2,\"804\":1}}],[\"chans\",{\"1\":{\"272\":2,\"804\":2,\"821\":19}}],[\"channels=z\",{\"1\":{\"885\":1}}],[\"channels=128\",{\"1\":{\"885\":2}}],[\"channels=1\",{\"1\":{\"885\":3,\"886\":1}}],[\"channels=64\",{\"1\":{\"848\":2,\"885\":3,\"886\":1}}],[\"channels\",{\"1\":{\"40\":1,\"316\":1,\"395\":1,\"793\":3,\"815\":3,\"821\":6,\"822\":2,\"840\":3,\"848\":32,\"885\":12,\"886\":5}}],[\"channel=2\",{\"1\":{\"423\":1}}],[\"channel=256+3\",{\"1\":{\"101\":1}}],[\"channel=256\",{\"1\":{\"93\":1}}],[\"channel=320\",{\"1\":{\"101\":1}}],[\"channel=384\",{\"1\":{\"101\":1}}],[\"channel=768\",{\"1\":{\"101\":1}}],[\"channel=64+3\",{\"1\":{\"101\":1}}],[\"channel=9+3\",{\"1\":{\"101\":1}}],[\"channel=128+3\",{\"1\":{\"101\":1}}],[\"channel=128\",{\"1\":{\"93\":1,\"101\":1}}],[\"channel=in\",{\"1\":{\"93\":1}}],[\"channel=true\",{\"1\":{\"93\":1,\"96\":1}}],[\"channel=518+additional\",{\"1\":{\"35\":1,\"46\":1,\"59\":1}}],[\"channel=512+self\",{\"1\":{\"35\":1,\"46\":1,\"59\":1}}],[\"channel=832\",{\"1\":{\"35\":1,\"46\":1,\"59\":1}}],[\"channel\",{\"1\":{\"30\":2,\"34\":1,\"35\":2,\"46\":3,\"59\":2,\"73\":11,\"92\":12,\"93\":7,\"96\":15,\"100\":11,\"170\":1,\"423\":1,\"846\":2}}],[\"character\",{\"1\":{\"478\":1}}],[\"characteristic\",{\"0\":{\"450\":1},\"1\":{\"82\":1}}],[\"chartqa\",{\"1\":{\"216\":1,\"225\":1,\"228\":1,\"230\":1}}],[\"charlesq34\",{\"1\":{\"85\":1,\"102\":1}}],[\"chair\",{\"1\":{\"29\":1,\"58\":1,\"67\":1,\"68\":1,\"83\":6}}],[\"chains\",{\"1\":{\"713\":1}}],[\"chain\",{\"0\":{\"9\":1,\"28\":1,\"501\":1},\"1\":{\"7\":1,\"26\":1,\"501\":2,\"502\":1,\"706\":1,\"714\":2,\"717\":1}}],[\"chatglm\",{\"1\":{\"704\":2}}],[\"chatgpt\",{\"1\":{\"232\":1,\"235\":1,\"239\":1,\"491\":1,\"703\":1,\"704\":7,\"708\":1,\"712\":1}}],[\"chatbot\",{\"1\":{\"235\":1}}],[\"chat\",{\"1\":{\"28\":4,\"197\":1,\"203\":2,\"210\":2,\"227\":1,\"235\":1,\"554\":1,\"704\":4}}],[\"creator\",{\"1\":{\"664\":3,\"665\":1,\"668\":3,\"681\":1,\"682\":3,\"684\":3,\"686\":8,\"688\":4,\"689\":1,\"696\":3}}],[\"creating\",{\"1\":{\"476\":1,\"478\":1}}],[\"creates\",{\"1\":{\"594\":1}}],[\"create\",{\"0\":{\"396\":1},\"1\":{\"83\":1,\"142\":3,\"145\":4,\"146\":1,\"147\":4,\"254\":2,\"395\":1,\"396\":3,\"431\":4,\"435\":1,\"476\":4,\"478\":6,\"593\":1,\"594\":1,\"620\":1,\"695\":1,\"803\":1}}],[\"crawl这类数据在整个训练中只被读取一次左右\",{\"1\":{\"528\":1}}],[\"crawl执行了质量过滤和模糊去重\",{\"1\":{\"528\":1}}],[\"crawl\",{\"1\":{\"225\":1,\"521\":1,\"528\":1,\"704\":1}}],[\"crafting\",{\"0\":{\"63\":1}}],[\"critical\",{\"1\":{\"105\":1,\"112\":2}}],[\"criterion2\",{\"1\":{\"581\":2}}],[\"criterion1\",{\"1\":{\"581\":2}}],[\"criterion\",{\"1\":{\"80\":2,\"81\":2,\"252\":5,\"848\":2}}],[\"crowson\",{\"1\":{\"816\":1}}],[\"crows\",{\"1\":{\"536\":1,\"537\":1,\"538\":1,\"549\":1,\"551\":1}}],[\"crops\",{\"1\":{\"186\":29,\"252\":1}}],[\"crop策略\",{\"1\":{\"184\":1}}],[\"crop\",{\"1\":{\"58\":1,\"173\":1,\"178\":1,\"179\":1,\"184\":3,\"186\":14}}],[\"crossentropy\",{\"1\":{\"395\":1,\"473\":3}}],[\"crossentropyloss\",{\"1\":{\"80\":1,\"163\":3,\"252\":1,\"274\":1,\"295\":1,\"312\":2,\"581\":2,\"603\":1,\"612\":1,\"615\":1,\"617\":1,\"618\":1,\"803\":1,\"848\":1,\"886\":1}}],[\"crossattention\",{\"1\":{\"162\":1,\"291\":2,\"312\":1}}],[\"cross\",{\"0\":{\"14\":1,\"832\":1},\"1\":{\"32\":1,\"33\":2,\"35\":1,\"36\":4,\"40\":1,\"45\":8,\"59\":3,\"75\":1,\"78\":1,\"126\":1,\"143\":1,\"145\":1,\"147\":2,\"152\":1,\"162\":5,\"163\":2,\"199\":2,\"252\":2,\"265\":1,\"276\":1,\"277\":4,\"278\":1,\"289\":2,\"290\":1,\"291\":1,\"293\":3,\"294\":2,\"299\":2,\"310\":2,\"311\":1,\"312\":13,\"468\":5,\"470\":4,\"473\":2,\"544\":3,\"815\":5,\"822\":3,\"854\":4}}],[\"csv\",{\"1\":{\"68\":2,\"577\":6}}],[\"cs\",{\"1\":{\"40\":2,\"105\":2}}],[\"csdn\",{\"1\":{\"0\":1}}],[\"cp\",{\"1\":{\"40\":1,\"697\":1}}],[\"cpu\",{\"1\":{\"28\":1,\"40\":1,\"83\":2,\"169\":1,\"300\":3,\"302\":3,\"304\":3,\"378\":1,\"463\":2,\"621\":1,\"803\":1,\"840\":2,\"848\":1,\"856\":1,\"857\":3,\"860\":1,\"861\":1,\"886\":2}}],[\"cider\",{\"1\":{\"202\":1}}],[\"ci\",{\"1\":{\"40\":1}}],[\"cnn中\",{\"1\":{\"385\":1}}],[\"cnn具有两种归纳偏置\",{\"1\":{\"314\":1}}],[\"cnn二阶段检测器提取region的特征\",{\"1\":{\"283\":1}}],[\"cnn\",{\"1\":{\"73\":1,\"107\":1,\"112\":4,\"114\":3,\"261\":1,\"299\":1,\"314\":1,\"326\":9,\"328\":1,\"386\":2,\"387\":2,\"522\":1,\"766\":1,\"802\":1,\"843\":5,\"845\":1,\"885\":1}}],[\"cn\",{\"1\":{\"37\":1,\"202\":2,\"211\":1,\"228\":1}}],[\"cmap=\",{\"1\":{\"697\":1,\"857\":3,\"861\":1,\"886\":1}}],[\"cmafm\",{\"0\":{\"14\":1},\"1\":{\"5\":1,\"8\":1,\"14\":1,\"24\":1}}],[\"cmd\",{\"1\":{\"696\":2}}],[\"cm\",{\"1\":{\"455\":1}}],[\"cmff\",{\"1\":{\"35\":2}}],[\"cylindrical\",{\"1\":{\"32\":1}}],[\"cli\",{\"1\":{\"715\":1}}],[\"clipprocessor\",{\"1\":{\"302\":1,\"304\":2}}],[\"clipmodel\",{\"1\":{\"302\":1,\"304\":2}}],[\"clip模型均能够以较高的置信度给出正确的分类结果\",{\"1\":{\"300\":1}}],[\"clip模型能够在没有特定任务训练数据的情况下\",{\"1\":{\"300\":1}}],[\"clip模型的一个显著优势是它能够进行zero\",{\"1\":{\"300\":1}}],[\"clip模型会预测出个可能的文本\",{\"1\":{\"299\":1}}],[\"clip包含两个核心模型\",{\"1\":{\"299\":1}}],[\"clip的训练数据采用的是文本\",{\"1\":{\"298\":1}}],[\"clip的英文全称为contrastive\",{\"1\":{\"298\":1}}],[\"clip原始论文链接\",{\"1\":{\"296\":1}}],[\"clip属于基于对比学习的多模态模型\",{\"1\":{\"298\":1}}],[\"clip属于\",{\"1\":{\"282\":1}}],[\"clip\",{\"0\":{\"310\":1,\"822\":1},\"1\":{\"167\":1,\"198\":1,\"201\":1,\"220\":1,\"234\":2,\"235\":2,\"260\":2,\"261\":1,\"277\":3,\"297\":3,\"300\":1,\"302\":3,\"304\":1,\"305\":1,\"581\":1,\"789\":1,\"803\":1,\"811\":1,\"817\":5,\"821\":1,\"822\":1}}],[\"cleargrad\",{\"1\":{\"683\":1,\"697\":4}}],[\"clean\",{\"1\":{\"29\":1}}],[\"clm\",{\"1\":{\"295\":1}}],[\"clamp\",{\"1\":{\"473\":2,\"615\":4,\"853\":1}}],[\"clamped\",{\"1\":{\"170\":2}}],[\"cla\",{\"1\":{\"316\":9}}],[\"claude\",{\"1\":{\"218\":1,\"703\":1,\"704\":14}}],[\"classify\",{\"1\":{\"840\":1}}],[\"classifier\",{\"0\":{\"816\":1},\"1\":{\"575\":2,\"580\":3,\"593\":2,\"603\":2,\"617\":2,\"618\":2,\"816\":1}}],[\"classification\",{\"0\":{\"776\":1},\"1\":{\"99\":1,\"175\":1,\"201\":1,\"202\":1,\"594\":1}}],[\"class=val\",{\"1\":{\"317\":1}}],[\"class=train\",{\"1\":{\"317\":1}}],[\"classes=10\",{\"1\":{\"860\":1,\"861\":1}}],[\"classes=1000\",{\"1\":{\"319\":1,\"320\":1,\"323\":1}}],[\"classes=classes\",{\"1\":{\"399\":1}}],[\"classes=5\",{\"1\":{\"327\":1}}],[\"classes=num\",{\"1\":{\"327\":1}}],[\"classes=dim\",{\"1\":{\"254\":2}}],[\"classes\",{\"1\":{\"68\":2,\"98\":1,\"101\":8,\"254\":1,\"319\":3,\"320\":2,\"323\":6,\"327\":2,\"399\":5}}],[\"class\",{\"0\":{\"319\":1,\"399\":1},\"1\":{\"29\":1,\"30\":1,\"32\":1,\"33\":1,\"34\":2,\"35\":2,\"36\":2,\"40\":1,\"41\":1,\"45\":2,\"46\":1,\"58\":1,\"59\":7,\"62\":1,\"68\":6,\"70\":1,\"72\":1,\"73\":1,\"74\":1,\"75\":1,\"76\":2,\"78\":1,\"83\":1,\"92\":1,\"93\":4,\"96\":4,\"100\":1,\"101\":1,\"107\":1,\"109\":1,\"110\":1,\"111\":1,\"142\":2,\"145\":1,\"146\":1,\"147\":1,\"162\":1,\"163\":1,\"169\":1,\"170\":2,\"179\":1,\"186\":5,\"252\":1,\"254\":1,\"272\":5,\"274\":6,\"275\":1,\"284\":1,\"289\":2,\"290\":1,\"291\":1,\"292\":2,\"293\":1,\"295\":3,\"309\":1,\"311\":1,\"312\":4,\"313\":1,\"316\":27,\"318\":1,\"319\":3,\"320\":1,\"321\":2,\"322\":1,\"323\":1,\"336\":2,\"347\":1,\"348\":3,\"351\":1,\"399\":8,\"463\":1,\"467\":2,\"468\":1,\"469\":1,\"470\":3,\"471\":1,\"473\":1,\"478\":1,\"544\":3,\"575\":1,\"578\":1,\"580\":1,\"584\":1,\"590\":1,\"591\":1,\"597\":1,\"599\":3,\"600\":1,\"601\":1,\"602\":1,\"603\":1,\"605\":1,\"606\":1,\"607\":1,\"609\":1,\"610\":1,\"611\":1,\"612\":1,\"615\":1,\"617\":1,\"618\":1,\"623\":1,\"624\":1,\"626\":1,\"627\":1,\"628\":1,\"630\":1,\"631\":1,\"632\":1,\"637\":1,\"643\":2,\"647\":1,\"659\":1,\"660\":1,\"661\":1,\"664\":2,\"665\":1,\"668\":1,\"672\":1,\"673\":1,\"675\":1,\"676\":1,\"681\":1,\"682\":1,\"683\":1,\"684\":1,\"686\":3,\"687\":2,\"688\":3,\"689\":4,\"690\":7,\"696\":1,\"793\":2,\"801\":1,\"802\":1,\"804\":2,\"821\":1,\"822\":1,\"840\":2,\"848\":2,\"853\":1,\"859\":1,\"885\":4,\"886\":2}}],[\"clusters\",{\"1\":{\"170\":7}}],[\"cluster\",{\"1\":{\"169\":9,\"170\":13}}],[\"clues\",{\"1\":{\"71\":1}}],[\"cls是一个二分类值\",{\"1\":{\"581\":1}}],[\"cls特征\",{\"1\":{\"147\":2}}],[\"cls2idx\",{\"1\":{\"68\":2}}],[\"cls\",{\"1\":{\"59\":2,\"68\":7,\"81\":3,\"93\":1,\"96\":2,\"126\":2,\"147\":3,\"154\":1,\"156\":1,\"160\":1,\"161\":3,\"162\":3,\"163\":3,\"165\":1,\"179\":3,\"186\":1,\"263\":2,\"265\":3,\"267\":1,\"272\":7,\"274\":10,\"276\":8,\"277\":43,\"278\":5,\"289\":1,\"295\":2,\"312\":2,\"319\":22,\"320\":5,\"323\":5,\"348\":3,\"463\":5,\"560\":1,\"573\":4,\"575\":6,\"578\":2,\"579\":5,\"580\":10,\"581\":4,\"594\":9,\"601\":1,\"612\":3,\"614\":2,\"616\":2,\"618\":1,\"804\":8}}],[\"cl=语言嵌入维度\",{\"1\":{\"40\":1}}],[\"cl\",{\"1\":{\"40\":3,\"68\":2}}],[\"cloze和race提升明显\",{\"1\":{\"515\":1}}],[\"cloze\",{\"1\":{\"507\":1}}],[\"closed\",{\"1\":{\"529\":1,\"549\":1}}],[\"close\",{\"1\":{\"506\":1}}],[\"closing\",{\"1\":{\"214\":2}}],[\"clones\",{\"1\":{\"627\":1,\"628\":1,\"630\":1,\"631\":1,\"632\":1}}],[\"clone\",{\"1\":{\"59\":1,\"145\":4,\"147\":4,\"161\":2,\"163\":2,\"169\":2,\"255\":1,\"311\":1,\"312\":1,\"544\":1,\"593\":1,\"620\":1,\"848\":1}}],[\"cloud\",{\"1\":{\"29\":1,\"46\":3,\"83\":6,\"114\":1}}],[\"clock\",{\"1\":{\"29\":1,\"58\":1,\"68\":1}}],[\"cauchy\",{\"0\":{\"749\":1},\"1\":{\"749\":2}}],[\"causallmoutputwithcrossattentions\",{\"1\":{\"295\":1,\"312\":1}}],[\"causal\",{\"1\":{\"295\":1,\"312\":2,\"544\":1,\"814\":1,\"822\":2}}],[\"case\",{\"1\":{\"575\":1,\"593\":1,\"716\":2,\"717\":3}}],[\"casual\",{\"1\":{\"322\":1}}],[\"cache的实现细节\",{\"1\":{\"544\":1}}],[\"cache结构\",{\"1\":{\"544\":1}}],[\"cache用元组的形式进行返回\",{\"1\":{\"544\":1}}],[\"cache形式\",{\"1\":{\"544\":1}}],[\"cache后\",{\"1\":{\"544\":1}}],[\"cache进行推理\",{\"1\":{\"541\":1}}],[\"cache详解\",{\"1\":{\"540\":1}}],[\"cache\",{\"0\":{\"540\":1,\"541\":1,\"542\":1,\"543\":1},\"1\":{\"312\":4,\"541\":1,\"542\":1,\"543\":1,\"544\":41,\"815\":9,\"816\":8,\"817\":4}}],[\"cache=cache\",{\"1\":{\"815\":1,\"817\":1}}],[\"cache=use\",{\"1\":{\"312\":1,\"544\":2}}],[\"cache=none\",{\"1\":{\"312\":1,\"544\":1,\"815\":1}}],[\"cache=true\",{\"1\":{\"309\":1,\"312\":2,\"544\":1}}],[\"camera\",{\"1\":{\"300\":1}}],[\"calling\",{\"1\":{\"704\":1}}],[\"callbacks\",{\"1\":{\"273\":16,\"713\":1}}],[\"calls\",{\"1\":{\"273\":1}}],[\"call\",{\"1\":{\"186\":1,\"252\":1,\"341\":2,\"346\":2,\"351\":2,\"642\":1,\"643\":1,\"660\":2,\"664\":2,\"681\":1,\"686\":1,\"687\":1,\"688\":2,\"690\":2,\"704\":1,\"801\":1,\"802\":1}}],[\"capacity\",{\"1\":{\"871\":1}}],[\"capital\",{\"1\":{\"616\":2}}],[\"captions\",{\"1\":{\"131\":2,\"140\":2,\"143\":3,\"234\":1,\"313\":2,\"809\":1,\"810\":2}}],[\"caption\",{\"1\":{\"128\":1,\"142\":10,\"143\":2,\"145\":5,\"146\":2,\"147\":4,\"234\":3,\"274\":5,\"305\":1,\"312\":1,\"807\":1}}],[\"captioner模块初始化\",{\"1\":{\"142\":1}}],[\"captioner\",{\"0\":{\"141\":1},\"1\":{\"120\":1,\"123\":1,\"128\":1,\"132\":3,\"134\":1,\"138\":1,\"140\":1,\"142\":1,\"143\":1}}],[\"captioning\",{\"1\":{\"120\":1,\"128\":1,\"202\":1,\"269\":1,\"312\":1}}],[\"capfilt\",{\"0\":{\"128\":1,\"132\":1,\"136\":1,\"140\":1},\"1\":{\"120\":1,\"122\":1,\"123\":1,\"125\":1,\"128\":2,\"129\":1,\"132\":1,\"134\":1,\"136\":3,\"137\":3,\"138\":1,\"140\":3,\"147\":1}}],[\"carlo\",{\"1\":{\"866\":1}}],[\"cardinality\",{\"1\":{\"78\":4}}],[\"carry\",{\"1\":{\"29\":1}}],[\"ca\",{\"1\":{\"40\":1,\"126\":2}}],[\"categorical\",{\"0\":{\"738\":1},\"1\":{\"738\":1}}],[\"category\",{\"1\":{\"82\":2,\"302\":4,\"304\":4}}],[\"catastrophic\",{\"1\":{\"483\":1}}],[\"cat\",{\"1\":{\"32\":4,\"34\":1,\"35\":2,\"36\":1,\"41\":1,\"43\":3,\"45\":1,\"46\":1,\"59\":4,\"70\":1,\"92\":2,\"96\":2,\"100\":1,\"109\":1,\"145\":9,\"147\":8,\"161\":2,\"162\":6,\"186\":2,\"255\":1,\"272\":3,\"276\":2,\"278\":5,\"300\":1,\"311\":6,\"312\":3,\"319\":1,\"320\":1,\"323\":1,\"541\":1,\"544\":1,\"804\":1,\"815\":2,\"817\":2,\"820\":1,\"859\":2,\"886\":1}}],[\"cand\",{\"1\":{\"578\":2,\"579\":3}}],[\"candidates\",{\"1\":{\"302\":13,\"304\":10,\"579\":3}}],[\"cannot\",{\"1\":{\"322\":1}}],[\"cancel\",{\"1\":{\"186\":1}}],[\"can\",{\"1\":{\"28\":4}}],[\"cub\",{\"1\":{\"806\":1}}],[\"customized\",{\"1\":{\"802\":1,\"803\":1}}],[\"cumval\",{\"1\":{\"463\":2}}],[\"cumulative\",{\"1\":{\"373\":1}}],[\"cumsum\",{\"0\":{\"373\":1},\"1\":{\"186\":2,\"373\":3,\"463\":1}}],[\"cup\",{\"1\":{\"300\":1}}],[\"cur\",{\"1\":{\"817\":2}}],[\"current\",{\"1\":{\"59\":2,\"82\":3,\"275\":9,\"278\":1,\"302\":2,\"303\":1,\"304\":3}}],[\"curve\",{\"1\":{\"22\":1,\"28\":2,\"82\":3}}],[\"cutmix\",{\"1\":{\"395\":1}}],[\"cut\",{\"1\":{\"29\":1,\"58\":1,\"68\":1}}],[\"cuda\",{\"1\":{\"28\":1,\"107\":2,\"108\":2,\"186\":1,\"252\":1,\"255\":1,\"300\":2,\"302\":2,\"304\":2,\"378\":2,\"438\":1,\"803\":1,\"820\":2,\"840\":8,\"848\":2,\"856\":2,\"860\":2}}],[\"c\",{\"1\":{\"6\":2,\"19\":1,\"30\":1,\"32\":2,\"35\":1,\"40\":1,\"41\":9,\"45\":16,\"46\":3,\"59\":25,\"70\":4,\"72\":2,\"73\":2,\"74\":2,\"75\":2,\"76\":12,\"92\":14,\"96\":5,\"98\":3,\"100\":7,\"101\":1,\"170\":9,\"196\":2,\"199\":1,\"202\":2,\"252\":1,\"257\":1,\"272\":6,\"276\":1,\"282\":1,\"299\":1,\"307\":2,\"309\":1,\"318\":6,\"319\":3,\"320\":2,\"322\":3,\"323\":2,\"333\":2,\"336\":1,\"370\":6,\"374\":4,\"388\":2,\"453\":2,\"455\":1,\"463\":3,\"471\":1,\"537\":1,\"538\":1,\"544\":4,\"577\":2,\"584\":1,\"591\":1,\"618\":1,\"647\":2,\"662\":1,\"685\":2,\"687\":5,\"690\":17,\"727\":2,\"794\":2,\"804\":1,\"810\":1,\"815\":5,\"821\":2,\"822\":3,\"858\":1,\"859\":9,\"860\":2,\"861\":2,\"866\":3,\"885\":7}}],[\"cost=0\",{\"1\":{\"885\":1}}],[\"cost\",{\"1\":{\"885\":3}}],[\"cos\",{\"1\":{\"587\":1,\"695\":1}}],[\"cosineannealing\",{\"1\":{\"395\":1}}],[\"cosineannealinglr\",{\"1\":{\"80\":1}}],[\"cosine\",{\"1\":{\"169\":1,\"170\":5,\"186\":3,\"299\":1,\"302\":2,\"303\":1,\"304\":3,\"391\":1,\"514\":1,\"774\":1}}],[\"copies\",{\"1\":{\"562\":1}}],[\"copy\",{\"1\":{\"145\":1,\"147\":1,\"160\":1,\"169\":3,\"170\":3,\"254\":1,\"544\":1,\"697\":2,\"816\":1}}],[\"coqa\",{\"1\":{\"522\":1}}],[\"coefficient\",{\"1\":{\"467\":3,\"468\":2,\"738\":1}}],[\"covariance\",{\"1\":{\"752\":4}}],[\"cov\",{\"1\":{\"455\":1}}],[\"core\",{\"1\":{\"628\":1,\"691\":9,\"714\":1,\"715\":1}}],[\"corpus\",{\"1\":{\"514\":1,\"515\":2}}],[\"correlations\",{\"1\":{\"527\":1}}],[\"corresponding\",{\"1\":{\"478\":1,\"601\":1}}],[\"correct\",{\"1\":{\"302\":3,\"304\":3,\"582\":2,\"817\":1,\"821\":1}}],[\"corners\",{\"1\":{\"388\":1}}],[\"corners=none\",{\"1\":{\"388\":1}}],[\"counter\",{\"0\":{\"401\":1},\"1\":{\"401\":8,\"403\":1}}],[\"counts\",{\"1\":{\"372\":3,\"377\":2,\"401\":5,\"403\":2}}],[\"counts=false\",{\"1\":{\"372\":1}}],[\"counts=true\",{\"1\":{\"186\":2,\"372\":1}}],[\"count\",{\"1\":{\"302\":7,\"304\":7,\"476\":2,\"478\":5,\"579\":3,\"801\":4}}],[\"coffee\",{\"1\":{\"300\":1}}],[\"co\",{\"1\":{\"276\":3,\"277\":7}}],[\"cogvlm\",{\"1\":{\"219\":1}}],[\"coyo\",{\"1\":{\"198\":1,\"225\":1}}],[\"codistillation\",{\"1\":{\"176\":1}}],[\"coder\",{\"1\":{\"704\":2}}],[\"codebook机制最早是在vq\",{\"1\":{\"877\":1}}],[\"codebook\",{\"0\":{\"808\":1},\"1\":{\"165\":1,\"167\":1,\"169\":19,\"170\":23,\"773\":2,\"787\":1,\"793\":7,\"794\":4,\"795\":1,\"798\":1,\"800\":4,\"803\":2,\"815\":2,\"817\":1,\"821\":18,\"877\":1,\"878\":1,\"883\":2,\"885\":7,\"886\":1,\"887\":1}}],[\"code=true\",{\"1\":{\"28\":2}}],[\"code\",{\"0\":{\"139\":1,\"158\":1,\"251\":1,\"252\":1},\"1\":{\"4\":1,\"170\":13,\"252\":1,\"593\":7,\"800\":4}}],[\"cookbook\",{\"1\":{\"170\":1}}],[\"coordinates\",{\"1\":{\"83\":6}}],[\"cococaptionkarpathydataset\",{\"1\":{\"274\":5}}],[\"cococaptionkarpathydatamodule\",{\"1\":{\"274\":2}}],[\"coco\",{\"1\":{\"128\":2,\"131\":1,\"140\":1,\"142\":4,\"143\":1,\"145\":1,\"202\":4,\"274\":6,\"781\":1,\"806\":2,\"810\":4}}],[\"cola上取得45\",{\"1\":{\"515\":1}}],[\"cola\",{\"1\":{\"515\":1}}],[\"column\",{\"1\":{\"274\":1,\"422\":1,\"423\":2}}],[\"color=\",{\"1\":{\"697\":2}}],[\"color=lightblue\",{\"1\":{\"696\":3}}],[\"color=orange\",{\"1\":{\"696\":9}}],[\"colorjitter\",{\"1\":{\"186\":1,\"252\":1,\"802\":1}}],[\"colors\",{\"1\":{\"83\":6}}],[\"color\",{\"1\":{\"83\":9,\"186\":4}}],[\"collect\",{\"1\":{\"478\":1}}],[\"collections\",{\"0\":{\"400\":1},\"1\":{\"401\":3,\"478\":1}}],[\"collection\",{\"0\":{\"17\":1},\"1\":{\"537\":1}}],[\"collator\",{\"1\":{\"274\":7}}],[\"collator=self\",{\"1\":{\"274\":1}}],[\"collate可以参考\",{\"1\":{\"316\":1}}],[\"collate\",{\"1\":{\"142\":1,\"145\":1,\"147\":1,\"274\":17,\"316\":3,\"317\":4,\"596\":2}}],[\"collapse\",{\"1\":{\"167\":1,\"800\":3}}],[\"collaborative\",{\"1\":{\"4\":1,\"5\":1}}],[\"consistency的过程\",{\"1\":{\"502\":1}}],[\"consistency的例子\",{\"1\":{\"502\":1}}],[\"consistency的大致原理是这样\",{\"1\":{\"502\":1}}],[\"consistency技术是在cot技术的基础之上\",{\"1\":{\"502\":1}}],[\"consistency\",{\"0\":{\"502\":1},\"1\":{\"502\":1}}],[\"consecutive\",{\"0\":{\"372\":1},\"1\":{\"186\":2,\"372\":5}}],[\"confidence\",{\"1\":{\"470\":1}}],[\"config函数\",{\"1\":{\"688\":1}}],[\"configure\",{\"1\":{\"273\":1,\"840\":2}}],[\"config=none\",{\"1\":{\"272\":1}}],[\"config=bert\",{\"1\":{\"160\":2}}],[\"config=decoder\",{\"1\":{\"147\":1}}],[\"config=encoder\",{\"1\":{\"147\":2}}],[\"config=\",{\"1\":{\"145\":1,\"147\":1}}],[\"config=med\",{\"1\":{\"142\":1,\"145\":2,\"146\":1}}],[\"configs\",{\"1\":{\"142\":1,\"145\":1,\"146\":1,\"147\":1}}],[\"config\",{\"1\":{\"28\":4,\"42\":2,\"44\":3,\"83\":1,\"142\":11,\"145\":13,\"146\":3,\"147\":11,\"159\":4,\"160\":13,\"163\":2,\"272\":4,\"274\":22,\"275\":1,\"276\":1,\"289\":3,\"290\":4,\"292\":5,\"295\":15,\"312\":2,\"544\":3,\"593\":2,\"597\":9,\"599\":16,\"600\":3,\"601\":3,\"602\":5,\"603\":7,\"605\":9,\"606\":5,\"607\":3,\"609\":8,\"610\":5,\"611\":3,\"612\":5,\"614\":1,\"615\":6,\"617\":7,\"618\":5,\"688\":8,\"691\":3}}],[\"confusion\",{\"0\":{\"442\":1}}],[\"conquer\",{\"1\":{\"385\":1}}],[\"condaerror\",{\"1\":{\"439\":1}}],[\"conda\",{\"1\":{\"431\":4,\"432\":2,\"433\":1,\"434\":4,\"435\":3,\"436\":1,\"437\":1,\"438\":6,\"439\":4,\"593\":2,\"620\":2}}],[\"conda虚拟环境管理\",{\"0\":{\"430\":1},\"1\":{\"430\":1}}],[\"conditioning\",{\"1\":{\"817\":1}}],[\"conditional\",{\"1\":{\"817\":1,\"843\":1}}],[\"conditionally\",{\"1\":{\"730\":1}}],[\"condition\",{\"1\":{\"368\":4,\"817\":1,\"859\":1}}],[\"cond\",{\"1\":{\"336\":1,\"692\":1,\"815\":3,\"816\":10,\"817\":3}}],[\"connections\",{\"1\":{\"627\":1,\"630\":1}}],[\"connection\",{\"1\":{\"72\":1,\"74\":1,\"98\":1,\"100\":1,\"544\":2,\"622\":1,\"713\":1}}],[\"concrete\",{\"1\":{\"795\":1}}],[\"conclusion\",{\"0\":{\"138\":1,\"247\":1,\"269\":1,\"286\":1},\"1\":{\"134\":1}}],[\"conceptualcaptiondatamodule\",{\"1\":{\"274\":1}}],[\"conceptual\",{\"1\":{\"131\":2,\"234\":1,\"809\":1,\"810\":2}}],[\"concise\",{\"1\":{\"63\":1}}],[\"concatdataset\",{\"1\":{\"274\":3}}],[\"concatenate\",{\"0\":{\"333\":1},\"1\":{\"186\":1,\"333\":4}}],[\"concat\",{\"1\":{\"40\":2,\"43\":1,\"92\":1,\"96\":3,\"145\":2,\"257\":1,\"575\":1,\"632\":1,\"859\":1}}],[\"contour\",{\"1\":{\"697\":1}}],[\"contribution\",{\"1\":{\"280\":1}}],[\"contrast\",{\"0\":{\"242\":1,\"244\":1},\"1\":{\"240\":2}}],[\"contrast=0\",{\"1\":{\"186\":1}}],[\"contrastive\",{\"0\":{\"154\":1,\"277\":1,\"310\":1,\"784\":1},\"1\":{\"127\":1,\"145\":1,\"198\":1,\"248\":2,\"260\":1,\"262\":1,\"265\":1,\"275\":2,\"277\":1,\"305\":1,\"310\":1}}],[\"continuous\",{\"1\":{\"486\":1}}],[\"continue\",{\"1\":{\"186\":1,\"578\":2}}],[\"contig\",{\"1\":{\"426\":4}}],[\"contiguity\",{\"1\":{\"421\":1}}],[\"contiguous\",{\"1\":{\"59\":2,\"111\":1,\"293\":1,\"295\":3,\"312\":3,\"360\":1,\"361\":2,\"362\":2,\"426\":7,\"544\":1,\"590\":1,\"605\":1,\"632\":1,\"885\":2,\"886\":1}}],[\"content\",{\"1\":{\"60\":1,\"590\":2}}],[\"contextmanager\",{\"1\":{\"688\":1}}],[\"contextlib\",{\"1\":{\"688\":2}}],[\"context设定的早期尝试\",{\"1\":{\"531\":1}}],[\"contextualized\",{\"1\":{\"616\":1}}],[\"contextual\",{\"1\":{\"63\":1,\"616\":1}}],[\"context\",{\"1\":{\"45\":2,\"59\":2,\"86\":2,\"293\":7,\"312\":10,\"527\":1,\"531\":1,\"532\":1,\"584\":3,\"591\":6,\"601\":1,\"605\":9,\"614\":1}}],[\"containing\",{\"1\":{\"478\":2}}],[\"contain\",{\"1\":{\"29\":1,\"58\":1,\"68\":1}}],[\"convtranspose\",{\"1\":{\"821\":1}}],[\"convtranspose2d\",{\"1\":{\"793\":1,\"821\":1,\"885\":2}}],[\"convnext\",{\"1\":{\"395\":2}}],[\"convnets\",{\"1\":{\"173\":5}}],[\"convirt基于对比学习的方法\",{\"1\":{\"305\":1}}],[\"convbench评估显示\",{\"1\":{\"228\":1}}],[\"conv4\",{\"1\":{\"111\":2}}],[\"conv3\",{\"1\":{\"107\":2,\"109\":2,\"111\":2}}],[\"conv2\",{\"1\":{\"101\":2,\"107\":2,\"109\":2,\"111\":2,\"885\":4}}],[\"conv2d\",{\"1\":{\"92\":2,\"96\":3,\"272\":1,\"318\":1,\"793\":6,\"804\":1,\"821\":4,\"848\":19,\"885\":2,\"886\":2}}],[\"conv1\",{\"1\":{\"101\":2,\"107\":2,\"109\":2,\"111\":2,\"885\":4}}],[\"conv1d\",{\"1\":{\"34\":1,\"35\":1,\"36\":1,\"41\":2,\"45\":2,\"59\":3,\"98\":2,\"100\":3,\"101\":2,\"107\":3,\"109\":4,\"111\":5,\"112\":1,\"544\":2}}],[\"conv\",{\"1\":{\"92\":2,\"96\":6,\"100\":2}}],[\"convs\",{\"1\":{\"92\":3,\"96\":3,\"100\":3}}],[\"conversation\",{\"1\":{\"235\":1,\"708\":1}}],[\"convert\",{\"1\":{\"29\":1,\"58\":1,\"142\":1,\"302\":1,\"304\":1,\"593\":1}}],[\"convention\",{\"1\":{\"76\":1}}],[\"convolution\",{\"1\":{\"76\":2,\"100\":1,\"279\":2}}],[\"cot的特点是同类型问题的迁移思考\",{\"1\":{\"503\":1}}],[\"cot的效果并不明显\",{\"1\":{\"501\":1}}],[\"cot是llm足够大\",{\"1\":{\"501\":1}}],[\"cot及其变体通过多步推理增强mllms能力\",{\"1\":{\"7\":1}}],[\"cot\",{\"1\":{\"7\":2,\"501\":1,\"706\":1}}],[\"comboloss\",{\"1\":{\"473\":2}}],[\"combo\",{\"0\":{\"473\":1},\"1\":{\"473\":12}}],[\"complement\",{\"1\":{\"729\":1}}],[\"complex\",{\"1\":{\"235\":1,\"503\":1}}],[\"compatibility\",{\"1\":{\"602\":1}}],[\"comparison\",{\"0\":{\"23\":1}}],[\"compile\",{\"1\":{\"476\":1,\"478\":1}}],[\"composition\",{\"1\":{\"385\":1}}],[\"compose\",{\"1\":{\"186\":5,\"252\":1,\"317\":2,\"463\":1,\"802\":4,\"840\":1,\"848\":1,\"885\":1}}],[\"compute\",{\"0\":{\"399\":1},\"1\":{\"252\":2,\"255\":3,\"275\":7,\"276\":1,\"277\":2,\"278\":2,\"399\":4,\"632\":1}}],[\"community\",{\"1\":{\"715\":1}}],[\"comment\",{\"1\":{\"538\":1}}],[\"commercial\",{\"1\":{\"214\":2}}],[\"commitment\",{\"1\":{\"170\":1,\"885\":5}}],[\"committer\",{\"1\":{\"2\":2}}],[\"commoncrawl等网络数据隐含的社会偏见难以完全过滤\",{\"1\":{\"551\":1}}],[\"commoncrawl\",{\"1\":{\"547\":1,\"548\":1}}],[\"common\",{\"1\":{\"28\":2,\"59\":4,\"225\":1,\"401\":2,\"521\":1,\"528\":1,\"549\":1,\"704\":1,\"802\":3}}],[\"com\",{\"1\":{\"4\":2,\"37\":1,\"47\":2,\"60\":2,\"85\":2,\"102\":2,\"119\":1,\"140\":2,\"148\":1,\"164\":1,\"171\":1,\"172\":1,\"187\":1,\"231\":1,\"240\":1,\"259\":1,\"270\":1,\"277\":1,\"279\":1,\"306\":1,\"316\":2,\"327\":3,\"463\":1,\"472\":1,\"544\":1,\"570\":1,\"577\":2,\"593\":2,\"620\":1,\"633\":1,\"679\":1,\"694\":1,\"699\":1,\"764\":1,\"816\":1,\"849\":1}}],[\"cvae使我们能够解决输入到输出是一对多映射的问题\",{\"1\":{\"874\":1}}],[\"cvae\",{\"0\":{\"850\":1,\"858\":1,\"859\":1},\"1\":{\"850\":1,\"858\":3,\"859\":2,\"860\":1,\"874\":1}}],[\"cv领域的信号是在一个连续而且高维的空间\",{\"1\":{\"246\":1}}],[\"cvpr\",{\"1\":{\"60\":1}}],[\"cvpr2024\",{\"1\":{\"60\":1}}],[\"cv\",{\"1\":{\"3\":1,\"247\":1,\"298\":1,\"704\":1}}]],\"version\":2}}")).map(([e,t])=>[e,jn(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:n,options:s,id:r}})=>{const o=An[n];e==="suggest"?self.postMessage([e,r,Et(t,o,s)]):e==="search"?self.postMessage([e,r,vt(t,o,s,"max")]):self.postMessage({suggestions:[e,r,Et(t,o,s)],results:[e,r,vt(t,o,s,__SLIMSEARCH_SORT_STRATEGY__)]})};
//# sourceMappingURL=index.js.map
