/**
* @vue/shared v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/const Se={},ze=()=>{},Ce=Object.assign,Oe=Array.isArray,D=e=>typeof e=="function",Me=e=>typeof e=="string",Ne=e=>typeof e=="symbol";let X;const L=()=>X||(X=typeof globalThis<"u"?globalThis:typeof self<"u"?self:typeof window<"u"?window:typeof global<"u"?global:{});/**
* @vue/reactivity v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/new Set(Object.getOwnPropertyNames(Symbol).filter(e=>e!=="arguments"&&e!=="caller").map(e=>Symbol[e]).filter(Ne));function P(e){const t=e&&e.__v_raw;return t?P(t):e}function Te(e){return e?e.__v_isRef===!0:!1}/**
* @vue/runtime-core v3.5.13
* (c) 2018-present Yuxi (Evan) You and Vue contributors
* @license MIT
**/const v=[];function kt(e){v.push(e)}function It(){v.pop()}let W=!1;function Et(e,...t){if(W)return;W=!0;const n=v.length?v[v.length-1].component:null,o=n&&n.appContext.config.warnHandler,s=Fe();if(o)A(o,n,11,[e+t.map(r=>{var i,c;return(c=(i=r.toString)==null?void 0:i.call(r))!=null?c:JSON.stringify(r)}).join(""),n&&n.proxy,s.map(({vnode:r})=>`at <${re(n,r.type)}>`).join(`
`),s]);else{const r=[`[Vue warn]: ${e}`,...t];s.length&&r.push(`
`,...$e(s)),console.warn(...r)}W=!1}function Fe(){let e=v[v.length-1];if(!e)return[];const t=[];for(;e;){const n=t[0];n&&n.vnode===e?n.recurseCount++:t.push({vnode:e,recurseCount:0});const o=e.component&&e.component.parent;e=o&&o.vnode}return t}function $e(e){const t=[];return e.forEach((n,o)=>{t.push(...o===0?[]:[`
`],...Ve(n))}),t}function Ve({vnode:e,recurseCount:t}){const n=t>0?`... (${t} recursive calls)`:"",o=e.component?e.component.parent==null:!1,s=` at <${re(e.component,e.type,o)}`,r=">"+n;return e.props?[s,...Re(e.props),r]:[s+r]}function Re(e){const t=[],n=Object.keys(e);return n.slice(0,3).forEach(o=>{t.push(...Z(o,e[o]))}),n.length>3&&t.push(" ..."),t}function Z(e,t,n){return Me(t)?(t=JSON.stringify(t),n?t:[`${e}=${t}`]):typeof t=="number"||typeof t=="boolean"||t==null?n?t:[`${e}=${t}`]:Te(t)?(t=Z(e,P(t.value),!0),n?t:[`${e}=Ref<`,t,">"]):D(t)?[`${e}=fn${t.name?`<${t.name}>`:""}`]:(t=P(t),n?t:[`${e}=`,t])}const vt={sp:"serverPrefetch hook",bc:"beforeCreate hook",c:"created hook",bm:"beforeMount hook",m:"mounted hook",bu:"beforeUpdate hook",u:"updated",bum:"beforeUnmount hook",um:"unmounted hook",a:"activated hook",da:"deactivated hook",ec:"errorCaptured hook",rtc:"renderTracked hook",rtg:"renderTriggered hook",0:"setup function",1:"render function",2:"watcher getter",3:"watcher callback",4:"watcher cleanup function",5:"native event handler",6:"component event handler",7:"vnode hook",8:"directive hook",9:"transition hook",10:"app errorHandler",11:"app warnHandler",12:"ref function",13:"async component loader",14:"scheduler flush",15:"component update",16:"app unmount cleanup function"};function A(e,t,n,o){try{return o?e(...o):e()}catch(s){ee(s,t,n)}}function ee(e,t,n,o=!0){const s=t?t.vnode:null,{errorHandler:r,throwUnhandledErrorInProduction:i}=t&&t.appContext.config||Se;if(t){let c=t.parent;const l=t.proxy,u=`https://vuejs.org/error-reference/#runtime-${n}`;for(;c;){const a=c.ec;if(a){for(let h=0;h<a.length;h++)if(a[h](e,l,u)===!1)return}c=c.parent}if(r){A(r,null,10,[e,l,u]);return}}je(e,n,s,o,i)}function je(e,t,n,o=!0,s=!1){if(s)throw e;console.error(e)}const b=[];let x=-1;const S=[];let k=null,z=0;const De=Promise.resolve();let q=null;const Le=100;function Pe(e){let t=x+1,n=b.length;for(;t<n;){const o=t+n>>>1,s=b[o],r=M(s);r<e||r===e&&s.flags&2?t=o+1:n=o}return t}function We(e){if(!(e.flags&1)){const t=M(e),n=b[b.length-1];!n||!(e.flags&2)&&t>=M(n)?b.push(e):b.splice(Pe(t),0,e),e.flags|=1,te()}}function te(){q||(q=De.then(ne))}function Ae(e){Oe(e)?S.push(...e):k&&e.id===-1?k.splice(z+1,0,e):e.flags&1||(S.push(e),e.flags|=1),te()}function qe(e){if(S.length){const t=[...new Set(S)].sort((n,o)=>M(n)-M(o));if(S.length=0,k){k.push(...t);return}for(k=t,z=0;z<k.length;z++){const n=k[z];n.flags&4&&(n.flags&=-2),n.flags&8||n(),n.flags&=-2}k=null,z=0}}const M=e=>e.id==null?e.flags&2?-1:1/0:e.id;function ne(e){const t=ze;try{for(x=0;x<b.length;x++){const n=b[x];n&&!(n.flags&8)&&(n.flags&4&&(n.flags&=-2),A(n,n.i,n.i?15:14),n.flags&4||(n.flags&=-2))}}finally{for(;x<b.length;x++){const n=b[x];n&&(n.flags&=-2)}x=-1,b.length=0,qe(e),q=null,(b.length||S.length)&&ne(e)}}function St(e,t){const n=e.get(t)||0;if(n>Le){const o=t.i,s=o&&se(o.type);return ee(`Maximum recursive updates exceeded${s?` in component <${s}>`:""}. This means you have a reactive effect that is mutating its own dependencies and thus recursively triggering itself. Possible sources include component template, render function, updated hook or watcher source function.`,null,10),!0}return e.set(t,n+1),!1}const H=new Map,F=new Map;function zt(e,t){return F.has(e)?!1:(F.set(e,{initialDef:$(t),instances:new Set}),!0)}function $(e){return Je(e)?e.__vccOpts:e}function Ct(e,t){const n=F.get(e);n&&(n.initialDef.render=t,[...n.instances].forEach(o=>{t&&(o.render=t,$(o.type).render=t),o.renderCache=[],o.update()}))}function Ot(e,t){const n=F.get(e);if(!n)return;t=$(t),oe(n.initialDef,t);const o=[...n.instances];for(let s=0;s<o.length;s++){const r=o[s],i=$(r.type);let c=H.get(i);c||(i!==n.initialDef&&oe(i,t),H.set(i,c=new Set)),c.add(r),r.appContext.propsCache.delete(r.type),r.appContext.emitsCache.delete(r.type),r.appContext.optionsCache.delete(r.type),r.ceReload?(c.add(r),r.ceReload(t.styles),c.delete(r)):r.parent?We(()=>{r.parent.update(),c.delete(r)}):r.appContext.reload?r.appContext.reload():typeof window<"u"?window.location.reload():console.warn("[HMR] Root or manually mounted instance modified. Full reload required."),r.root.ce&&r!==r.root&&r.root.ce._removeChildStyle(i)}Ae(()=>{H.clear()})}function oe(e,t){Ce(e,t);for(const n in e)n!=="__file"&&!(n in t)&&delete e[n]}function Mt(e){return(t,n)=>{try{return e(t,n)}catch(o){console.error(o),console.warn("[HMR] Something went wrong during Vue component hot-reload. Full reload required.")}}}L().requestIdleCallback,L().cancelIdleCallback;const Nt={};{const e=L(),t=(n,o)=>{let s;return(s=e[n])||(s=e[n]=[]),s.push(o),r=>{s.length>1?s.forEach(i=>i(r)):s[0](r)}};t("__VUE_INSTANCE_SETTERS__",n=>n),t("__VUE_SSR_SETTERS__",n=>n)}const He=/(?:^|[-_])(\w)/g,Ue=e=>e.replace(He,t=>t.toUpperCase()).replace(/[-_]/g,"");function se(e,t=!0){return D(e)?e.displayName||e.name:e.name||t&&e.__name}function re(e,t,n=!1){let o=se(t);if(!o&&t.__file){const s=t.__file.match(/([^/\\]+)\.\w+$/);s&&(o=s[1])}if(!o&&e&&e.parent){const s=r=>{for(const i in r)if(r[i]===t)return i};o=s(e.components||e.parent.type.components)||s(e.appContext.components)}return o?Ue(o):n?"App":"Anonymous"}function Je(e){return D(e)&&"__vccOpts"in e}[...new Array(6)].map((e,t)=>`[vp-content] h${t+1}`).join(",");const{entries:Ge}=Object,{fromEntries:Be}=Object,Ye="ENTRIES",ie="KEYS",ce="VALUES",y="";class U{set;_type;_path;constructor(t,n){const o=t._tree,s=Array.from(o.keys());this.set=t,this._type=n,this._path=s.length>0?[{node:o,keys:s}]:[]}next(){const t=this.dive();return this.backtrack(),t}dive(){if(this._path.length===0)return{done:!0,value:void 0};const{node:t,keys:n}=C(this._path);if(C(n)===y)return{done:!1,value:this.result()};const o=t.get(C(n));return this._path.push({node:o,keys:Array.from(o.keys())}),this.dive()}backtrack(){if(this._path.length===0)return;const t=C(this._path).keys;t.pop(),!(t.length>0)&&(this._path.pop(),this.backtrack())}key(){return this.set._prefix+this._path.map(({keys:t})=>C(t)).filter(t=>t!==y).join("")}value(){return C(this._path).node.get(y)}result(){switch(this._type){case ce:return this.value();case ie:return this.key();default:return[this.key(),this.value()]}}[Symbol.iterator](){return this}}const C=e=>e[e.length-1],Ke=(e,t,n)=>{const o=new Map;if(typeof t!="string")return o;const s=t.length+1,r=s+n,i=new Uint8Array(r*s).fill(n+1);for(let c=0;c<s;++c)i[c]=c;for(let c=1;c<r;++c)i[c*s]=c;return le(e,t,n,o,i,1,s,""),o},le=(e,t,n,o,s,r,i,c)=>{const l=r*i;e:for(const u of e.keys())if(u===y){const a=s[l-1];a<=n&&o.set(c,[e.get(u),a])}else{let a=r;for(let h=0;h<u.length;++h,++a){const g=u[h],m=i*a,w=m-i;let d=s[m];const f=Math.max(0,a-n-1),p=Math.min(i-1,a+n);for(let _=f;_<p;++_){const I=g!==t[_],j=s[w+_]+ +I,T=s[w+_+1]+1,E=s[m+_]+1,O=s[m+_+1]=Math.min(j,T,E);O<d&&(d=O)}if(d>n)continue e}le(e.get(u),t,n,o,s,a,i,c+u)}};let ue=class N{_tree;_prefix;_size=void 0;constructor(t=new Map,n=""){this._tree=t,this._prefix=n}atPrefix(t){if(!t.startsWith(this._prefix))throw new Error("Mismatched prefix");const[n,o]=V(this._tree,t.slice(this._prefix.length));if(n===void 0){const[s,r]=B(o);for(const i of s.keys())if(i!==y&&i.startsWith(r)){const c=new Map;return c.set(i.slice(r.length),s.get(i)),new N(c,t)}}return new N(n,t)}clear(){this._size=void 0,this._tree.clear()}delete(t){return this._size=void 0,Qe(this._tree,t)}entries(){return new U(this,Ye)}forEach(t){for(const[n,o]of this)t(n,o,this)}fuzzyGet(t,n){return Ke(this._tree,t,n)}get(t){const n=J(this._tree,t);return n!==void 0?n.get(y):void 0}has(t){return J(this._tree,t)?.has(y)??!1}keys(){return new U(this,ie)}set(t,n){if(typeof t!="string")throw new Error("key must be a string");return this._size=void 0,G(this._tree,t).set(y,n),this}get size(){if(this._size)return this._size;this._size=0;const t=this.entries();for(;!t.next().done;)this._size+=1;return this._size}update(t,n){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const o=G(this._tree,t);return o.set(y,n(o.get(y))),this}fetch(t,n){if(typeof t!="string")throw new Error("key must be a string");this._size=void 0;const o=G(this._tree,t);let s=o.get(y);return s===void 0&&o.set(y,s=n()),s}values(){return new U(this,ce)}[Symbol.iterator](){return this.entries()}static from(t){const n=new N;for(const[o,s]of t)n.set(o,s);return n}static fromObject(t){return N.from(Object.entries(t))}};const V=(e,t,n=[])=>{if(t.length===0||e==null)return[e,n];for(const o of e.keys())if(o!==y&&t.startsWith(o))return n.push([e,o]),V(e.get(o),t.slice(o.length),n);return n.push([e,t]),V(void 0,"",n)},J=(e,t)=>{if(t.length===0||!e)return e;for(const n of e.keys())if(n!==y&&t.startsWith(n))return J(e.get(n),t.slice(n.length))},G=(e,t)=>{const n=t.length;e:for(let o=0;e&&o<n;){for(const r of e.keys())if(r!==y&&t[o]===r[0]){const i=Math.min(n-o,r.length);let c=1;for(;c<i&&t[o+c]===r[c];)++c;const l=e.get(r);if(c===r.length)e=l;else{const u=new Map;u.set(r.slice(c),l),e.set(t.slice(o,o+c),u),e.delete(r),e=u}o+=c;continue e}const s=new Map;return e.set(t.slice(o),s),s}return e},Qe=(e,t)=>{const[n,o]=V(e,t);if(n!==void 0){if(n.delete(y),n.size===0)ae(o);else if(n.size===1){const[s,r]=n.entries().next().value;fe(o,s,r)}}},ae=e=>{if(e.length===0)return;const[t,n]=B(e);if(t.delete(n),t.size===0)ae(e.slice(0,-1));else if(t.size===1){const[o,s]=t.entries().next().value;o!==y&&fe(e.slice(0,-1),o,s)}},fe=(e,t,n)=>{if(e.length===0)return;const[o,s]=B(e);o.set(s+t,n),o.delete(s)},B=e=>e[e.length-1],Xe=(e,t)=>{const n=e._idToShortId.get(t);if(n!=null)return e._storedFields.get(n)},Ze=/[\n\r\p{Z}\p{P}]+/u,Y="or",de="and",et="and_not",tt=(e,t)=>{e.includes(t)||e.push(t)},he=(e,t)=>{for(const n of t)e.includes(n)||e.push(n)},pe=({score:e},{score:t})=>t-e,nt=()=>new Map,R=e=>{const t=new Map;for(const n of Object.keys(e))t.set(parseInt(n,10),e[n]);return t},ge=(e,t)=>Object.prototype.hasOwnProperty.call(e,t)?e[t]:void 0,me={[Y]:(e,t)=>{for(const n of t.keys()){const o=e.get(n);if(o==null)e.set(n,t.get(n));else{const{score:s,terms:r,match:i}=t.get(n);o.score=o.score+s,o.match=Object.assign(o.match,i),he(o.terms,r)}}return e},[de]:(e,t)=>{const n=new Map;for(const o of t.keys()){const s=e.get(o);if(s==null)continue;const{score:r,terms:i,match:c}=t.get(o);he(s.terms,i),n.set(o,{score:s.score+r,terms:s.terms,match:Object.assign(s.match,c)})}return n},[et]:(e,t)=>{for(const n of t.keys())e.delete(n);return e}},ot=(e,t,n,o,s,r)=>{const{k:i,b:c,d:l}=r;return Math.log(1+(n-t+.5)/(t+.5))*(l+e*(i+1)/(e+i*(1-c+c*o/s)))},st=e=>(t,n,o)=>({term:t,fuzzy:typeof e.fuzzy=="function"?e.fuzzy(t,n,o):e.fuzzy??!1,prefix:typeof e.prefix=="function"?e.prefix(t,n,o):e.prefix===!0,termBoost:typeof e.boostTerm=="function"?e.boostTerm(t,n,o):1}),_e=(e,t,n,o)=>{for(const s of Object.keys(e._fieldIds))if(e._fieldIds[s]===n){e._options.logger("warn",`SlimSearch: document with ID ${e._documentIds.get(t)} has changed before removal: term "${o}" was not present in field "${s}". Removing a document after it has changed can corrupt the index!`,"version_conflict");return}},rt=(e,t,n,o)=>{if(!e._index.has(o)){_e(e,n,t,o);return}const s=e._index.fetch(o,nt),r=s.get(t),i=r?.get(n);!r||typeof i>"u"?_e(e,n,t,o):i<=1?r.size<=1?s.delete(t):r.delete(n):r.set(n,i-1),e._index.get(o).size===0&&e._index.delete(o)},it={k:1.2,b:.7,d:.5},ct={idField:"id",extractField:(e,t)=>e[t],tokenize:e=>e.split(Ze),processTerm:e=>e.toLowerCase(),fields:void 0,searchOptions:void 0,storeFields:[],logger:(e,t)=>{console?.[e]?.(t)},autoVacuum:!0},ye={combineWith:Y,prefix:!1,fuzzy:!1,maxFuzzy:6,boost:{},weights:{fuzzy:.45,prefix:.375},bm25:it},lt={combineWith:de,prefix:(e,t,n)=>t===n.length-1},ut={batchSize:1e3,batchWait:10},we={minDirtFactor:.1,minDirtCount:20},at={...ut,...we},be=Symbol("*"),ft=(e,t)=>{const n=new Map,o={...e._options.searchOptions,...t};for(const[s,r]of e._documentIds){const i=o.boostDocument?o.boostDocument(r,"",e._storedFields.get(s)):1;n.set(s,{score:i,terms:[],match:{}})}return n},xe=(e,t=Y)=>{if(e.length===0)return new Map;const n=t.toLowerCase();if(!(n in me))throw new Error(`Invalid combination operator: ${t}`);return e.reduce(me[n])},K=(e,t,n,o,s,r,i,c,l,u=new Map)=>{if(r==null)return u;for(const a of Object.keys(i)){const h=i[a],g=e._fieldIds[a],m=r.get(g);if(m==null)continue;let w=m.size;const d=e._avgFieldLength[g];for(const f of m.keys()){if(!e._documentIds.has(f)){rt(e,g,f,n),w-=1;continue}const p=c?c(e._documentIds.get(f),n,e._storedFields.get(f)):1;if(!p)continue;const _=m.get(f),I=e._fieldLength.get(f)[g],j=ot(_,w,e._documentCount,I,d,l),T=o*s*h*p*j,E=u.get(f);if(E){E.score+=T,tt(E.terms,t);const O=ge(E.match,n);O?O.push(a):E.match[n]=[a]}else u.set(f,{score:T,terms:[t],match:{[n]:[a]}})}}return u},dt=(e,t,n)=>{const o={...e._options.searchOptions,...n},s=(o.fields??e._options.fields).reduce((d,f)=>({...d,[f]:ge(o.boost,f)||1}),{}),{boostDocument:r,weights:i,maxFuzzy:c,bm25:l}=o,{fuzzy:u,prefix:a}={...ye.weights,...i},h=e._index.get(t.term),g=K(e,t.term,t.term,1,t.termBoost,h,s,r,l);let m,w;if(t.prefix&&(m=e._index.atPrefix(t.term)),t.fuzzy){const d=t.fuzzy===!0?.2:t.fuzzy,f=d<1?Math.min(c,Math.round(t.term.length*d)):d;f&&(w=e._index.fuzzyGet(t.term,f))}if(m)for(const[d,f]of m){const p=d.length-t.term.length;if(!p)continue;w?.delete(d);const _=a*d.length/(d.length+.3*p);K(e,t.term,d,_,t.termBoost,f,s,r,l,g)}if(w)for(const d of w.keys()){const[f,p]=w.get(d);if(!p)continue;const _=u*d.length/(d.length+p);K(e,t.term,d,_,t.termBoost,f,s,r,l,g)}return g},ke=(e,t,n={})=>{if(t===be)return ft(e,n);if(typeof t!="string"){const a={...n,...t,queries:void 0},h=t.queries.map(g=>ke(e,g,a));return xe(h,a.combineWith)}const{tokenize:o,processTerm:s,searchOptions:r}=e._options,i={tokenize:o,processTerm:s,...r,...n},{tokenize:c,processTerm:l}=i,u=c(t).flatMap(a=>l(a)).filter(a=>!!a).map(st(i)).map(a=>dt(e,a,i));return xe(u,i.combineWith)},Ie=(e,t,n={})=>{const{searchOptions:o}=e._options,s={...o,...n},r=ke(e,t,n),i=[];for(const[c,{score:l,terms:u,match:a}]of r){const h=u.length||1,g={id:e._documentIds.get(c),score:l*h,terms:Object.keys(a),queryTerms:u,match:a};Object.assign(g,e._storedFields.get(c)),(s.filter==null||s.filter(g))&&i.push(g)}return t===be&&s.boostDocument==null||i.sort(pe),i},ht=(e,t,n={})=>{n={...e._options.autoSuggestOptions,...n};const o=new Map;for(const{score:r,terms:i}of Ie(e,t,n)){const c=i.join(" "),l=o.get(c);l!=null?(l.score+=r,l.count+=1):o.set(c,{score:r,terms:i,count:1})}const s=[];for(const[r,{score:i,terms:c,count:l}]of o)s.push({suggestion:r,terms:c,score:i/l});return s.sort(pe),s};class pt{_options;_index;_documentCount;_documentIds;_idToShortId;_fieldIds;_fieldLength;_avgFieldLength;_nextId;_storedFields;_dirtCount;_currentVacuum;_enqueuedVacuum;_enqueuedVacuumConditions;constructor(t){if(!t?.fields)throw new Error('SlimSearch: option "fields" must be provided');const n=t.autoVacuum==null||t.autoVacuum===!0?at:t.autoVacuum;this._options={...ct,...t,autoVacuum:n,searchOptions:{...ye,...t.searchOptions},autoSuggestOptions:{...lt,...t.autoSuggestOptions}},this._index=new ue,this._documentCount=0,this._documentIds=new Map,this._idToShortId=new Map,this._fieldIds={},this._fieldLength=new Map,this._avgFieldLength=[],this._nextId=0,this._storedFields=new Map,this._dirtCount=0,this._currentVacuum=null,this._enqueuedVacuum=null,this._enqueuedVacuumConditions=we,this.addFields(this._options.fields)}get isVacuuming(){return this._currentVacuum!=null}get dirtCount(){return this._dirtCount}get dirtFactor(){return this._dirtCount/(1+this._documentCount+this._dirtCount)}get documentCount(){return this._documentCount}get termCount(){return this._index.size}toJSON(){const t=[];for(const[n,o]of this._index){const s={};for(const[r,i]of o)s[r]=Object.fromEntries(i);t.push([n,s])}return{documentCount:this._documentCount,nextId:this._nextId,documentIds:Object.fromEntries(this._documentIds),fieldIds:this._fieldIds,fieldLength:Object.fromEntries(this._fieldLength),averageFieldLength:this._avgFieldLength,storedFields:Object.fromEntries(this._storedFields),dirtCount:this._dirtCount,index:t,version:2}}addFields(t){for(let n=0;n<t.length;n++)this._fieldIds[t[n]]=n}}const gt=e=>new pt(e),mt=({documentCount:e,nextId:t,fieldIds:n,averageFieldLength:o,dirtCount:s,version:r},i)=>{if(r!==2)throw new Error("SlimSearch: cannot deserialize an index created with an incompatible version");const c=gt(i);return c._documentCount=e,c._nextId=t,c._idToShortId=new Map,c._fieldIds=n,c._avgFieldLength=o,c._dirtCount=s??0,c._index=new ue,c},_t=(e,t)=>{const{index:n,documentIds:o,fieldLength:s,storedFields:r}=e,i=mt(e,t);i._documentIds=R(o),i._fieldLength=R(s),i._storedFields=R(r);for(const[c,l]of i._documentIds)i._idToShortId.set(l,c);for(const[c,l]of n){const u=new Map;for(const a of Object.keys(l))u.set(parseInt(a,10),R(l[a]));i._index.set(c,u)}return i},Q=(e,t)=>{const n=e.toLowerCase(),o=t.toLowerCase(),s=[];let r=0,i=0;const c=(u,a=!1)=>{let h;i===0?h=u.length>20?`… ${u.slice(-20)}`:u:a?h=u.length+i>100?`${u.slice(0,100-i)}… `:u:h=u.length>20?`${u.slice(0,20)} … ${u.slice(-20)}`:u,h&&s.push(h),i+=h.length,a||(s.push(["mark",t]),i+=t.length,i>=100&&s.push(" …"))};let l=n.indexOf(o,r);if(l===-1)return null;for(;l>=0;){const u=l+o.length;if(c(e.slice(r,l)),r=u,i>100)break;l=n.indexOf(o,r)}return i<100&&c(e.slice(r),!0),s},{entries:yt}=Object,wt=(e,t)=>t.contents.reduce((n,[,o])=>n+o,0)-e.contents.reduce((n,[,o])=>n+o,0),bt=(e,t)=>Math.max(...t.contents.map(([,n])=>n))-Math.max(...e.contents.map(([,n])=>n)),Ee=(e,t,n={},o="max")=>{const s={};return Ie(t,e,{boost:{h:2,t:1,c:4},prefix:!0,...n}).forEach(r=>{const{id:i,terms:c,score:l}=r,u=i.includes("@"),a=i.includes("#"),[h,g]=i.split(/[#@]/),m=Number(h),w=c.sort((f,p)=>f.length-p.length).filter((f,p)=>c.slice(p+1).every(_=>!_.includes(f))),{contents:d}=s[m]??={title:"",contents:[]};if(u)d.push([{type:"customField",id:m,index:g,display:w.map(f=>r.c.map(p=>Q(p,f))).flat().filter(f=>f!==null)},l]);else{const f=w.map(p=>Q(r.h,p)).filter(p=>p!==null);if(f.length&&d.push([{type:a?"heading":"title",id:m,...a&&{anchor:g},display:f},l]),"t"in r&&r.t)for(const p of r.t){const _=w.map(I=>Q(p,I)).filter(I=>I!==null);_.length&&d.push([{type:"text",id:m,...a&&{anchor:g},display:_},l])}}}),yt(s).sort(([,r],[,i])=>(o?wt:bt)(r,i)).map(([r,{title:i,contents:c}])=>{if(!i){const l=Xe(t,r);l&&(i=l.h)}return{title:i,contents:c.map(([l])=>l)}})},ve=(e,t,n={})=>{const o=ht(t,e,{fuzzy:.2,maxFuzzy:3,...n}).map(({suggestion:s})=>s);return e.includes(" ")?o:o.filter(s=>!s.includes(" "))},xt=Be(Ge(JSON.parse("{\"/\":{\"documentCount\":112,\"nextId\":112,\"documentIds\":{\"0\":\"0\",\"1\":\"1\",\"2\":\"1#binary-oracle\",\"3\":\"1#elowen\",\"4\":\"2\",\"5\":\"3\",\"6\":\"4\",\"7\":\"4#背景\",\"8\":\"4#模型结构\",\"9\":\"4#层次化点集特征学习\",\"10\":\"4#sampling-layer\",\"11\":\"4#grouping-layer\",\"12\":\"4#pointnet-layer\",\"13\":\"4#代码实现\",\"14\":\"4#单尺度分组分类模型\",\"15\":\"4#非均匀密度下稳定的特征学习\",\"16\":\"4#多尺度分组-multi-scale-grouping\",\"17\":\"4#多尺度分组分类模型\",\"18\":\"4#多分辨率分组-multi-resolution-grouping\",\"19\":\"5\",\"20\":\"5#核心\",\"21\":\"5#难点\",\"22\":\"5#解决方案\",\"23\":\"5#代码-pytorch版本\",\"24\":\"5#输入标准化\",\"25\":\"5#正则化损失\",\"26\":\"5#特征提取\",\"27\":\"5#分类任务\",\"28\":\"5#分割任务\",\"29\":\"5#缺陷\",\"30\":\"5#背景知识扫盲-可选\",\"31\":\"5#点云\",\"32\":\"5#对称函数\",\"33\":\"5#刚性运动\",\"34\":\"5#正交变换\",\"35\":\"6\",\"36\":\"7\",\"37\":\"7#环境搭建\",\"38\":\"7#数据预处理\",\"39\":\"7#模型架构\",\"40\":\"7#dataloader\",\"41\":\"7#bertembeddings\",\"42\":\"7#bertencoder\",\"43\":\"7#bertlayer\",\"44\":\"7#bertencoder-1\",\"45\":\"7#bertpooler\",\"46\":\"7#bertmodel\",\"47\":\"7#bertforsequenceclassification\",\"48\":\"7#bertattention\",\"49\":\"7#bertselfattention\",\"50\":\"7#bertselfoutput\",\"51\":\"7#bertattention-1\",\"52\":\"7#预训练\",\"53\":\"7#bertpredictionheadtransform\",\"54\":\"7#bertlmpredictionhead\",\"55\":\"7#bertpretrainingheads\",\"56\":\"7#bertforpretraining\",\"57\":\"7#其他下游任务\",\"58\":\"7#问答任务\",\"59\":\"7#代码实现\",\"60\":\"7#易混淆\",\"61\":\"7#token分类任务\",\"62\":\"7#多项选择任务\",\"63\":\"8\",\"64\":\"8#环境\",\"65\":\"8#背景\",\"66\":\"8#模型架构\",\"67\":\"8#encoder-decoder-结构\",\"68\":\"8#generator\",\"69\":\"8#encoder-结构\",\"70\":\"8#sublayerconnection\",\"71\":\"8#encoderlayer\",\"72\":\"8#encoder\",\"73\":\"8#decoder-结构\",\"74\":\"8#decoderlayer\",\"75\":\"8#decoder\",\"76\":\"8#多头自注意力\",\"77\":\"9\",\"78\":\"10\",\"79\":\"10#引言\",\"80\":\"10#介绍\",\"81\":\"10#训练\",\"82\":\"10#推理\",\"83\":\"10#文本描述生成\",\"84\":\"10#花卉图片分类\",\"85\":\"10#文字搜索图像\",\"86\":\"10#完整代码\",\"87\":\"10#小结\",\"88\":\"11\",\"89\":\"11#背景\",\"90\":\"11#模型结构\",\"91\":\"11#stage-1-representation-learning-表征学习\",\"92\":\"11#_1、image-text-contrastive-learning-itc-loss-clip-like\",\"93\":\"11#_2、image-text-matching-itm-loss-二分类task\",\"94\":\"12\",\"95\":\"12#原理\",\"96\":\"12#_0-数据下载\",\"97\":\"12#_1-图片预处理\",\"98\":\"12#_2-图片切割\",\"99\":\"12#_3-添加-class-token\",\"100\":\"12#_4-添加位置编码\",\"101\":\"12#_5-encoder\",\"102\":\"12#_6-多头自注意力\",\"103\":\"12#_7-mlp-head\",\"104\":\"12#效果对比\",\"105\":\"12#注意力可视化\",\"106\":\"12#混合模型探索\",\"107\":\"12#加载预训练模型\",\"108\":\"12#总结\",\"109\":\"13\",\"110\":\"14\",\"111\":\"15\"},\"fieldIds\":{\"h\":0,\"t\":1,\"c\":2},\"fieldLength\":{\"0\":[1,7],\"1\":[1],\"2\":[2,13],\"3\":[1,5],\"4\":[2,25],\"5\":[3],\"6\":[1,19],\"7\":[1,73],\"8\":[1,15],\"9\":[1,24],\"10\":[2,23],\"11\":[2,51],\"12\":[2,15],\"13\":[1,316],\"14\":[1,122],\"15\":[1,17],\"16\":[5,35],\"17\":[1,196],\"18\":[5,40],\"19\":[1,17],\"20\":[1,33],\"21\":[1,28],\"22\":[1,121],\"23\":[3,1],\"24\":[1,192],\"25\":[1,73],\"26\":[1,112],\"27\":[1,54],\"28\":[1,94],\"29\":[1,290],\"30\":[3],\"31\":[1,65],\"32\":[1,83],\"33\":[1,24],\"34\":[1,13],\"35\":[1],\"36\":[2,2],\"37\":[1,138],\"38\":[1,165],\"39\":[1],\"40\":[1,48],\"41\":[1,66],\"42\":[1],\"43\":[1,58],\"44\":[1,30],\"45\":[1,40],\"46\":[1,49],\"47\":[1,73],\"48\":[1],\"49\":[1,104],\"50\":[1,32],\"51\":[1,23],\"52\":[1,1],\"53\":[1,41],\"54\":[1,44],\"55\":[1,28],\"56\":[1,75],\"57\":[1,1],\"58\":[1,120],\"59\":[1,95],\"60\":[1,173],\"61\":[1,75],\"62\":[1,119],\"63\":[1,2],\"64\":[1,41],\"65\":[1,23],\"66\":[1,64],\"67\":[3,30],\"68\":[1,28],\"69\":[2],\"70\":[1,33],\"71\":[1,37],\"72\":[1,37],\"73\":[2],\"74\":[1,49],\"75\":[1,39],\"76\":[1,116],\"77\":[1],\"78\":[1,3],\"79\":[1,31],\"80\":[1,20],\"81\":[1,146],\"82\":[1,156],\"83\":[1,57],\"84\":[1,245],\"85\":[1,92],\"86\":[1,210],\"87\":[1,132],\"88\":[1,17],\"89\":[1,66],\"90\":[1,20],\"91\":[6,144],\"92\":[10,95],\"93\":[8,278],\"94\":[1,53],\"95\":[1,4],\"96\":[2,234],\"97\":[2,130],\"98\":[2,181],\"99\":[4,160],\"100\":[2,141],\"101\":[2,153],\"102\":[2,138],\"103\":[3,220],\"104\":[1,61],\"105\":[1,13],\"106\":[1,51],\"107\":[1,158],\"108\":[1,15],\"109\":[1],\"110\":[1],\"111\":[1,3]},\"averageFieldLength\":[1.5000000000000004,75.111331694142],\"storedFields\":{\"0\":{\"h\":\"主页\",\"t\":[\"知识星球: MetaMind , 小红书: BinaryOracle , CSDN: Binary Oracle\"]},\"1\":{\"h\":\"关于我们\"},\"2\":{\"h\":\"Binary Oracle\",\"t\":[\"一名普通但十分热爱探索技术的Coder\",\"开源框架 Spring committer\",\"Golang 开源网络库 netpoll committer\",\"Javaer 转型 3D - VL 方向研究\",\"现就读于四川大学\"]},\"3\":{\"h\":\"Elowen\",\"t\":[\"CV 转 LLM 领域\",\"现就读于电子科技大学\"]},\"4\":{\"h\":\"LMAffordance3D 模型代码解读与复现\",\"t\":[\"Grounding 3D Object Affordance with Language Instructions, Visual Observations and Interactions 论文代码解读与复现\",\"论文: https://arxiv.org/abs/2504.04744 代码: https://github.com/cn-hezhu/LMAffordance3D\"]},\"5\":{\"h\":\"3D-Vision Language\"},\"6\":{\"h\":\"简析PointNet++\",\"t\":[\"简析PointNet++\",\"论文: https://arxiv.org/abs/1706.02413 TensorFlow 版本代码: https://github.com/charlesq34/pointnet2 Pytorch 版本代码: https://github.com/yanx27/Pointnet_Pointnet2_pytorch\"]},\"7\":{\"h\":\"背景\",\"t\":[\"在PointNet中，网络对每一个点做低维到高维的映射，进行特征学习，然后把所有点映射到高维的特征通过最大池化最终表示全局特征。从本质上来说，要么对一个点做操作，要么对所有点做操作，实际上没有局部的概念(loal context) 。同时缺少 local context 在平移不变性上也有局限性（世界坐标系和局部坐标系）。对点云数据做平移操作后，所有的数据都将发生变化，导致所有的特征，全局特征都不一样了。对于单个的物体还好，可以将其平移到坐标系的中心，把他的大小归一化到一个球中，但是在一个场景中有多个物体时则不好办，需要对哪个物体做归一化呢？\",\"PointNet++ 解决了两个问题：如何生成点集的划分（Partitioning），以及如何通过局部特征学习器（Local Feature Learner）抽象点集或局部特征。\",\"生成点集的划分（Partitioning）：\",\"点集划分是指如何将一个大的点云分割成更小的、更易于管理的子集。这个过程类似于在传统的卷积神经网络中如何处理图像的小区域（或“patches”），以便可以在这些区域上应用局部操作。PointNet++需要一种方法来有效地将点云分割成多个部分，这样可以在每个部分上独立地学习特征。\",\"通过局部特征学习器（Local Feature Learner）抽象点集或局部特征：\",\"一旦点云被划分成小的子集，PointNet++的下一个任务是学习这些子集（或局部区域）的特征。这需要一个“局部特征学习器”，它能够从每个子集中提取有用的信息或特征。这与在传统CNN中学习图像局部区域特征的过程相似。\",\"两个问题是相关联的，因为：\",\"点集的划分必须产生跨分区的共同结构：为了能够在不同的局部子集上共享权重（类似于在CNN中权重共享的概念），PointNet++在进行点集划分时，需要确保这些划分具有一定的一致性或共同结构。这意味着即使是不同的局部子集，也应该以一种方式被处理，使得在它们之间可以共享学习到的特征表示的权重。这样做的目的是提高模型的效率和泛化能力，因为学习到的特征和权重可以在多个局部区域中复用。\",\"上述即为PointNet++设计中的两个核心挑战：\",\"如何有效地对点云进行分区，以便可以在这些分区上独立地学习特征。\",\"如何设计一个能够从这些局部分区中学习有用特征的机制，同时确保这些分区的处理方式允许在它们之间共享模型权重。 \",\"为了模仿传统卷积网络中的权重共享机制以提高学习效率和模型的泛化能力。\",\"PointNet++选择PointNet作为局部特征学习器（它是无序点云数据特征提取的高效算法）。\",\"可以理解为：PointNet++应用PointNet递归地对输入集进行嵌套分区。\"]},\"8\":{\"h\":\"模型结构\",\"t\":[\"以二维欧几里得空间为例，网络的分割和分类模型\",\"网络的每一组set abstraction layers主要包括3个部分：\",\"Sample layer : 对输入点进行采样，在这些点中选出若干个中心点。\",\"Grouping layer : 利用上一步得到的中心点将点集划分成若干个区域。\",\"PointNet layer : 对上述得到的每个区域进行编码，变成特征向量。\"]},\"9\":{\"h\":\"层次化点集特征学习\",\"t\":[\"层次化结构由多个set abstraction layers组成，在每个层上，一组点云被处理和抽象，以产生一个更少元素的新集合。set abstraction layers 由 Sampling layer、Grouping layer 和 PointNet layer 三部分组成。\",\"Sampling layer ：采样层 从输入点中选取一组点，定义局部区域的形心。\",\"Grouping layer ：通过查找形心点周围的“邻近点”来构建局部区域点集。\",\"PointNet layer ：使用mini-PointNet将局部区域编码为特征向量。\"]},\"10\":{\"h\":\"Sampling layer\",\"t\":[\"使用farthest point sampling（FPS）选择𝑁个点（相比于随机采样，该方法能更好的覆盖整个点集，具体选择多少个中心点以及邻域内的数量由超参数确定）\",\"FPS是一种在点云、图像处理或其他数据集中用于抽样的算法。目的是从一个大的数据集中选出一组代表性强的点，这些点彼此之间的最小距离尽可能大。\",\"作者通过FPS来抽样点集中较为重要的点。（即任务是找到点云集中的局部区域的中心点）\",\"可能存在的问题：计算成本、样本分布偏差（可能导致样本在高密度区域内过度集中，低密度区域则过于稀缺）、参数依赖（依赖初始点和距离度量方式的选择）、可能无法捕捉重要的几何细节。\"]},\"11\":{\"h\":\"Grouping layer\",\"t\":[\"文中作者通过Ball query来查询形心的邻居点。\",\"具体做法：给定两个超参数（每个区域中点的数量𝐾和query的半径𝑟），对于某个形心，Ball query找到该查询点在半径为𝑟范围内点，该范围确保局部区域的尺度是固定的。\",\"与K最近邻（kNN）查询相比，Ball query通过固定区域尺度而不是固定邻居数量来定义邻域。kNN查询寻找最近的K个邻居，但这可能导致所选邻域的实际尺寸随点的密度变化而变化，这在处理非均匀采样的数据时可能不是最优的选择。相反，Ball query通过确保每个局部区域都有一个固定的尺度，提高了模型在空间上的泛化能力。在实现时，通常会设置一个上限K，以限制每个局部区域中考虑的点的数量，以保持计算的可管理性。\",\"可改进的地方：对点云密度变换较为敏感、对参数选择依赖性高（半径太小可能无法有效捕获足够的局部详细，太大则可能导致不相关的点增多，使局部特征的表示不够精确）、计算效率问题、均匀性假设（Ball query是基于欧氏距离的均匀性假设）\",\"欧式距离的均匀性假设：即在欧氏空间中，两点的距离反映了这两点的实际相似度或关联度。\",\"基于以下前提： \",\"空间均匀性：空间是均匀和各向同性的，即任何方向上的度量都是等价的，距离的度量不受空间中位置的影响。\",\"距离直观性：在屋里空间或某些特定的抽象空间中，两个点之间的直线距离被认为是相似度或连接强度的直观表示。\",\"规模一致性：假设空间中所有区域的尺度或特征分布具有一定的一致性，即空间中的任何距离值具有相似的含义。\",\"总结: Grouping layer的任务是通过中心点找到邻居点，并将它们组织称为局部区域集。\"]},\"12\":{\"h\":\"PointNet layer\",\"t\":[\"局部坐标系转换：局部区域中的点转换成相对于形心的局部坐标系。\",\"局部区域中的每个点将相对于形心所在位置进行调整，以反映其相对位置。\",\"实现方法：通过将局部区域中的每个点-形心点的坐标来实现。\",\"特征编码：将转换后的坐标以及点的附加特征（文中的𝐶所表示的其他信息）一起送入mini-PointNet来提取局部区域中的特征。\",\"输出：利用相对坐标与点特征相结合的方式可以捕获局部区域中点与点之间的关系。\"]},\"13\":{\"h\":\"代码实现\",\"t\":[\"sample_and_group 这个函数的作用是从输入点云中：\",\"采样一些关键点\",\"为每个关键点构建局部邻域（局部区域）\",\"提取这些局部区域中的点及其特征\",\"def sample_and_group(npoint, radius, nsample, xyz, points, returnfps=False): \\\"\\\"\\\" Input: npoint: 采样的关键点数量 radius: 构建局部邻域的半径 nsample: 每个邻域内采样的关键点数量 xyz: 点云坐标数据 , [B, N, 3] points: 点的特征数据（可选）, [B, N, D] Return: new_xyz: 采样得到的关键点坐标, [B, npoint, nsample, 3] new_points: 每个关键点对应的局部区域点和特征, [B, npoint, nsample, 3+D] \\\"\\\"\\\" B, N, C = xyz.shape S = npoint # 使用 最远点采样（FPS） 从原始点云中选出 npoint 个具有代表性的点。 fps_idx = farthest_point_sample(xyz, npoint) # [B, npoint] new_xyz = index_points(xyz, fps_idx) # [B, npoint, 3] # 对于每个选中的关键点，使用 球查询（Ball Query） 找出它周围距离小于 radius 的所有邻近点。 # 最多保留 nsample 个点，如果不够就重复最近的点来填充。 idx = query_ball_point(radius, nsample, xyz, new_xyz) # 把刚才找到的邻近点的坐标提取出来。 grouped_xyz = index_points(xyz, idx) # [B, npoint, nsample, 3] # 把它们相对于关键点的位置进行归一化（平移中心到以关键点为原点的局部坐标系上）。 grouped_xyz_norm = grouped_xyz - new_xyz.view(B, S, 1, C) # [B, npoint, nsample, 3] # 如果有额外的点特征（比如颜色、法线等），也一并提取。 if points is not None: grouped_points = index_points(points, idx) # 把邻近点的坐标和特征拼接在一起，形成最终的局部区域表示。 new_points = torch.cat([grouped_xyz_norm, grouped_points], dim=-1) # [B, npoint, nsample, C+D] else: new_points = grouped_xyz_norm if returnfps: return new_xyz, new_points, grouped_xyz, fps_idx else: return new_xyz, new_points\",\"farthest_point_sample 这个函数实现的是最远点采样（Farthest Point Sampling, FPS）, 这是 PointNet++ 中用于从点云中选择具有代表性的采样点的一种策略。它的核心思想是：在点云中逐步选择离已选点尽可能远的点，使得采样点在整个点云空间中分布尽可能均匀 。\",\"def farthest_point_sample(xyz, npoint): \\\"\\\"\\\" Input: xyz: pointcloud data, [B, N, 3] npoint: number of samples Return: centroids: sampled pointcloud index, [B, npoint] \\\"\\\"\\\" device = xyz.device B, N, C = xyz.shape centroids = torch.zeros(B, npoint, dtype=torch.long).to(device) # 存储每次选出的“最远点”的索引。 distance = torch.ones(B, N).to(device) * 1e10 # 每个点到当前所有已选中心点的最小距离，初始设为一个极大值（1e10）。 farthest = torch.randint(0, N, (B,), dtype=torch.long).to(device) # 初始时随机选择一个点作为第一个中心点。 batch_indices = torch.arange(B, dtype=torch.long).to(device) # 批次索引，用于快速访问每个 batch 的点。 # 重复 npoint 次，最终得到 npoint 个分布尽可能均匀的采样点索引。 for i in range(npoint): # 将当前选中的“最远点”索引保存下来； centroids[:, i] = farthest # （batch,npoint) # 取出当前最远点的坐标，用于后续计算其他点到该点的距离; centroid = xyz[batch_indices, farthest, :].view(B, 1, 3) # # （batch, 1 , 3) # 计算当前中心点与所有点之间的欧氏距离平方。 dist = torch.sum((xyz - centroid) ** 2, -1) # （batch,npoint) # 如果某个点到新中心点的距离比之前记录的“最小距离”还小，就更新它。 mask = dist < distance # 在 distance 中找到最大的那个距离对应的点，这就是下一个“最远点”。 distance[mask] = dist[mask] # （batch,npoint) # 在 distance 中找到最大的那个距离对应的点，这就是下一个“最远点”。 # 返回：一个元组：(values, indices)，分别是最大值和它们的位置索引。 farthest = torch.max(distance, -1)[1] # 返回位置索引 return centroids\",\"index_points 这个函数实现的是根据给定的索引 idx，从输入点云 points 中提取对应的点，形成一个新的子集。\",\"def index_points(points, idx): \\\"\\\"\\\" Input: points: input points data, [B, N, C] idx: sample index data, [B, S] Return: new_points:, indexed points data, [B, S, C] \\\"\\\"\\\" device = points.device B = points.shape[0] view_shape = list(idx.shape) view_shape[1:] = [1] * (len(view_shape) - 1) # 将view_shape的形状从[B, S]变成[B, 1]，便于广播 repeat_shape = list(idx.shape) repeat_shape[0] = 1 # 从[B, S]变成[1, S] # 从点云中根据索引提取特定点 (看不懂下面两行代码的话，可以先去了解一下python中的高级索引机制)。 batch_indices = torch.arange(B, dtype=torch.long).to(device).view(view_shape).repeat(repeat_shape) new_points = points[batch_indices, idx, :] # （batch,npoint,3) return new_points\",\"query_ball_point 这个函数的作用是从点云中找出每个查询点周围一定半径范围内的邻近点索引。这个操作被称为 球查询（Ball Query）。\",\"def query_ball_point(radius, nsample, xyz, new_xyz): \\\"\\\"\\\" Input: radius: local region radius nsample: max sample number in local region xyz: all points, [B, N, 3] new_xyz: query points, [B, S, 3] Return: group_idx: grouped points index, [B, S, nsample] \\\"\\\"\\\" device = xyz.device B, N, C = xyz.shape _, S, _ = new_xyz.shape # 查询点数量（比如通过 FPS 得到的质心） # 构造一个从 0 到 N-1 的索引数组，代表原始点云中每个点的“身份证号” # 然后复制这个索引数组到每个 batch 和每个查询点上，形成 [B, S, N] 的结构 group_idx = torch.arange(N, dtype=torch.long).to(device).view(1, 1, N).repeat([B, S, 1]) # 计算每个查询点（new_xyz）与原始点（xyz）之间的平方欧氏距离 # 输出形状为 [B, S, N]：每个查询点对所有原始点的距离 sqrdists = square_distance(new_xyz, xyz) # 把距离超过 radius^2 的点全部替换为 N（一个非法索引），表示“这些人离我太远了，我不感兴趣。” group_idx[sqrdists > radius ** 2] = N # 对每个查询点的邻近点按索引排序（因为前面有 N，所以小的才是有效点） # 然后只保留前 nsample 个点 group_idx = group_idx.sort(dim=-1)[0][:, :, :nsample] # 如果某个查询点附近的点太少，有些位置被标记为 N（无效）。 # 我们就用该查询点最近的那个点（第一个点）去填充这些空缺。 group_first = group_idx[:, :, 0].view(B, S, 1).repeat([1, 1, nsample]) mask = group_idx == N group_idx[mask] = group_first[mask] return group_idx # （batch,npoint,nsample)\",\"sample_and_group流程图\",\"sample_and_group_all 函数的作用是将整个点云视为一个“大局部区域”，不进行采样，直接对所有点进行特征提取，用于 PointNet++ 中的全局特征学习。\",\"def sample_and_group_all(xyz, points): \\\"\\\"\\\" Input: xyz: input points position data, [B, N, 3], 点云坐标数据 points: input points data, [B, N, D], 点云的额外特征（如法线、颜色等） Return: new_xyz: sampled points position data, [B, 1, 3] new_points: sampled points data, [B, 1, N, 3+D] \\\"\\\"\\\" device = xyz.device B, N, C = xyz.shape # 创建一个全零点作为“质心” # 虽然这个点没有实际意义，但它是为了统一接口设计的一个占位符 new_xyz = torch.zeros(B, 1, C).to(device) # 把原始点云 reshape 成一个大的局部区域 grouped_xyz = xyz.view(B, 1, N, C) # 如果有额外特征（比如法线、颜色），也一并加入 if points is not None: # 终输出的 new_points 是 [B, 1, N, 3+D]，代表每个 batch 中只有一组“大区域”的点及其特征 new_points = torch.cat([grouped_xyz, points.view(B, 1, N, -1)], dim=-1) else: new_points = grouped_xyz return new_xyz, new_points # 全局质心点（0 位置）, 所有点组成的局部区域\",\"sample_and_group_all流程图\",\"PointNetSetAbstraction（点集抽象层） 是 PointNet++ 中的核心模块 ， 它的作用是负责从输入的点云数据中采样关键点，构建它们的局部邻域区域，并通过一个小型 PointNet 提取这些区域的高维特征，从而实现点云的分层特征学习。\",\"class PointNetSetAbstraction(nn.Module): def __init__(self, npoint, radius, nsample, in_channel, mlp, group_all): super(PointNetSetAbstraction, self).__init__() self.npoint = npoint # 采样的关键点数量 self.radius = radius # 构建局部邻域的半径 self.nsample = nsample # 每个邻域内采样的关键点数量 self.mlp_convs = nn.ModuleList() self.mlp_bns = nn.ModuleList() last_channel = in_channel # 输入点的特征维度 for out_channel in mlp: self.mlp_convs.append(nn.Conv2d(last_channel, out_channel, 1)) self.mlp_bns.append(nn.BatchNorm2d(out_channel)) last_channel = out_channel self.group_all = group_all def forward(self, xyz, points): \\\"\\\"\\\" Input: xyz: input points position data, [B, C, N] points: input points data, [B, D, N] Return: new_xyz: sampled points position data, [B, C, S] new_points_concat: sample points feature data, [B, D', S] \\\"\\\"\\\" xyz = xyz.permute(0, 2, 1) # [B, N, C] if points is not None: points = points.permute(0, 2, 1) # 如果 group_all=True，则对整个点云做全局特征提取。 if self.group_all: new_xyz, new_points = sample_and_group_all(xyz, points) else: # 否则使用 FPS（最远点采样）选关键点，再用 Ball Query 找出每个点的局部邻近点。 # 参数: 质点数量，采样半径，采样点数量，点坐标，点额外特征 new_xyz, new_points = sample_and_group(self.npoint, self.radius, self.nsample, xyz, points) # 局部特征编码（Mini-PointNet） # new_xyz: sampled points position data, [B, npoint, C] # new_points: sampled points data, [B, npoint, nsample, C+D] # 把邻域点的数据整理成适合卷积的格式 [B, C+D, nsample, npoint] new_points = new_points.permute(0, 3, 2, 1) # 使用多个 Conv2d + BatchNorm + ReLU 层提取特征 for i, conv in enumerate(self.mlp_convs): bn = self.mlp_bns[i] new_points = F.relu(bn(conv(new_points))) # [B, out_channel , nsample, npoint] # 对每个局部区域内所有点的最大响应值进行池化，得到该区域的固定长度特征表示。 # 在 new_points 的第 2 个维度（即每个局部邻域内的点数量维度）上做最大池化（max pooling）。 # 输出形状为 [B, out_channel, npoint]，即每个查询点有一个特征向量。 new_points = torch.max(new_points, 2)[0] # [B, out_channel, npoint] new_xyz = new_xyz.permute(0, 2, 1) # [B, C, npoint] return new_xyz, new_points # 查询点的位置(质心) ， 每个查询点点局部特征。\",\"最终每个采样得到的关键点所在的局部领域，都会被压缩为一个固定长度的特征向量。这个特征向量代表了这个局部区域的高维特征，它包含了这个区域内所有点的信息。\"]},\"14\":{\"h\":\"单尺度分组分类模型\",\"t\":[\"PointNet++ 的 单尺度分组（SSG）架构 ，通过多层 Set Abstraction 提取点云的层次化特征，并最终输出分类结果。\",\"Single-Scale Grouping (SSG)\",\"代码实现如下:\",\"# pointnet2_cls_ssg.py class get_model(nn.Module): # num_class: 输出类别数 # normal_channel: 是否包含法线信息（默认有 (x,y,z,nx,ny,nz)，否则只有 (x,y,z)） def __init__(self,num_class,normal_channel=True): super(get_model, self).__init__() in_channel = 6 if normal_channel else 3 self.normal_channel = normal_channel # PointNet++ 的核心就是逐层提取局部特征。这里的三个 SA 层构成了一个 三层分层特征学习结构 ： self.sa1 = PointNetSetAbstraction(npoint=512, radius=0.2, nsample=32, in_channel=in_channel, mlp=[64, 64, 128], group_all=False) self.sa2 = PointNetSetAbstraction(npoint=128, radius=0.4, nsample=64, in_channel=128 + 3, mlp=[128, 128, 256], group_all=False) self.sa3 = PointNetSetAbstraction(npoint=None, radius=None, nsample=None, in_channel=256 + 3, mlp=[256, 512, 1024], group_all=True) self.fc1 = nn.Linear(1024, 512) self.bn1 = nn.BatchNorm1d(512) self.drop1 = nn.Dropout(0.4) self.fc2 = nn.Linear(512, 256) self.bn2 = nn.BatchNorm1d(256) self.drop2 = nn.Dropout(0.4) self.fc3 = nn.Linear(256, num_class) def forward(self, xyz): B, _, _ = xyz.shape if self.normal_channel: norm = xyz[:, 3:, :] xyz = xyz[:, :3, :] else: norm = None l1_xyz, l1_points = self.sa1(xyz, norm) l2_xyz, l2_points = self.sa2(l1_xyz, l1_points) l3_xyz, l3_points = self.sa3(l2_xyz, l2_points) x = l3_points.view(B, 1024) x = self.drop1(F.relu(self.bn1(self.fc1(x)))) x = self.drop2(F.relu(self.bn2(self.fc2(x)))) x = self.fc3(x) x = F.log_softmax(x, -1) return x, l3_points\",\"完整的单尺度分组分类流程为:\",\"原始点云数据，首次sample，grouping，mini-PointNet后，得到:\",\"512 个关键点的坐标\",\"512 个关键点对应的局部区域特征向量\",\"二次sample，grouping，mini-PointNet后，得到:\",\"128 个关键点的坐标\",\"128 个关键点对应的局部区域特征向量\",\"三次sample，grouping，mini-PointNet后，得到:\",\"1 个关键点的坐标\",\"1 个关键点对应的全局区域特征向量\",\"获取全局区域特征向量后，通过全连接层进行分类。\"]},\"15\":{\"h\":\"非均匀密度下稳定的特征学习\",\"t\":[\"由于点集在不同区域可能会有不同的采样密度，这种非均匀性为点集特征学习带来了显著挑战。在密集采样的区域中学到的特征可能无法很好地泛化到稀疏采样的区域，反之亦然。因此，为了解决这一问题，PointNet++提出了密度自适应PointNet层，包含两种适应性特征学习层：多尺度分组（Multi-Scale Grouping, MSG）和多分辨率分组（Multi-Resolution Grouping, MRG）。\"]},\"16\":{\"h\":\"多尺度分组 （Multi-Scale Grouping）\",\"t\":[\"MSG通过应用不同尺度的分组层（按照不同的搜索半径或领域大小对点集进行分组），然后通过对应的PointNets提取每个尺度上的特征来捕获多尺度模式。不同尺度的特征被串联形成多尺度特征向量。这种方法使网络能够通过在训练期间随机丢弃输入点（称为随机输入丢弃 - random input dropout）来学习优化的策略，以结合来自不同尺度的特征。这样，网络在训练时被呈现了不同稀疏度的点集，从而学会根据输入数据的变化自适应地加权不同尺度上检测到的模式。\",\"多尺度分组\",\"具体来说，在MSG中，网络对于每个选定的形心点，按照几个预定义的半径值来搜索周围的邻近点。每个半径定义了一个局部邻域的大小，因此每个质心将根据这些不同的半径值与其周围点形成多个点集群。这样，对于每个质心点，网络不是只捕获一个尺度上的局部特征，而是能够捕获多个尺度上的局部特征。\",\"每个尺度（或每组邻域大小）的点集群都将独立地送入对应的PointNet网络进行特征提取，之后这些不同尺度上提取的特征被串联起来，形成一个综合的多尺度特征表示。这种方法使得网络能够在细节丰富的区域（通过较小的邻域尺度捕获细节）和稀疏采样的区域（通过较大的邻域尺度避免过度稀疏的问题）中均能有效提取特征。\"]},\"17\":{\"h\":\"多尺度分组分类模型\",\"t\":[\"PointNetSetAbstractionMsg 这个模块实现了 PointNet++ 中的 多尺度特征提取机制 ：对于每个局部区域，使用多个不同大小的邻域球（multi-scale ball query），分别提取特征，然后将这些不同尺度的特征拼接在一起，以获得更强的局部几何感知能力。\",\"class PointNetSetAbstractionMsg(nn.Module): def __init__(self, npoint, radius_list, nsample_list, in_channel, mlp_list): super(PointNetSetAbstractionMsg, self).__init__() self.npoint = npoint # 要采样的质心点数量 self.radius_list = radius_list # 不同尺度的查询半径列表 self.nsample_list = nsample_list # 对应半径下最多取多少邻近点 self.conv_blocks = nn.ModuleList() self.bn_blocks = nn.ModuleList() # 为每个尺度构建一个独立的小型 PointNet（Conv2d + BN + ReLU） # 每个尺度可以有不同的网络深度和宽度 # 所有尺度的网络并行运行，最后拼接结果 for i in range(len(mlp_list)): convs = nn.ModuleList() bns = nn.ModuleList() last_channel = in_channel + 3 for out_channel in mlp_list[i]: convs.append(nn.Conv2d(last_channel, out_channel, 1)) bns.append(nn.BatchNorm2d(out_channel)) last_channel = out_channel self.conv_blocks.append(convs) self.bn_blocks.append(bns) def forward(self, xyz, points): \\\"\\\"\\\" Input: xyz: input points position data, [B, C, N] points: input points data, [B, D, N] Return: new_xyz: sampled points position data, [B, C, S] new_points_concat: sample points feature data, [B, D', S] \\\"\\\"\\\" xyz = xyz.permute(0, 2, 1) # [B, N, C] if points is not None: points = points.permute(0, 2, 1) B, N, C = xyz.shape S = self.npoint # 使用 FPS（最远点采样）选出 S 个关键点作为局部区域中心 new_xyz = index_points(xyz, farthest_point_sample(xyz, S)) new_points_list = [] for i, radius in enumerate(self.radius_list): K = self.nsample_list[i] # 对每个半径 radius，找出该尺度下每个质心点周围的邻近点 group_idx = query_ball_point(radius, K, xyz, new_xyz) grouped_xyz = index_points(xyz, group_idx) # 把这些点的坐标归一化到以质心为中心的局部坐标系下 grouped_xyz -= new_xyz.view(B, S, 1, C) # 如果有额外特征，也一并加入 if points is not None: grouped_points = index_points(points, group_idx) grouped_points = torch.cat([grouped_points, grouped_xyz], dim=-1) else: grouped_points = grouped_xyz # 对每个尺度的局部点集应用对应的 Conv2d + BN + ReLU grouped_points = grouped_points.permute(0, 3, 2, 1) # [B, D, K, S] for j in range(len(self.conv_blocks[i])): conv = self.conv_blocks[i][j] bn = self.bn_blocks[i][j] grouped_points = F.relu(bn(conv(grouped_points))) # 使用最大池化聚合局部信息，生成固定长度的特征向量 new_points = torch.max(grouped_points, 2)[0] # [B, D', S] # 所有尺度的特征保存到 new_points_list new_points_list.append(new_points) new_xyz = new_xyz.permute(0, 2, 1) # 把不同尺度学到的特征拼接在一起，形成最终的局部特征表示 new_points_concat = torch.cat(new_points_list, dim=1) # 最终输出就是： 一组新的关键点位置； 每个关键点的多尺度特征表示 return new_xyz, new_points_concat\",\"pointnet2_cls_msg 这个模型使用了 PointNet++ 的 多尺度分组（MSG）策略 ，通过多个局部区域球查询提取不同尺度的局部特征，逐层抽象后融合成全局特征，最后通过全连接层完成分类任务。\",\"# pointnet2_cls_msg.py class get_model(nn.Module): def __init__(self,num_class,normal_channel=True): super(get_model, self).__init__() in_channel = 3 if normal_channel else 0 self.normal_channel = normal_channel self.sa1 = PointNetSetAbstractionMsg(512, [0.1, 0.2, 0.4], [16, 32, 128], in_channel,[[32, 32, 64], [64, 64, 128], [64, 96, 128]]) self.sa2 = PointNetSetAbstractionMsg(128, [0.2, 0.4, 0.8], [32, 64, 128], 320,[[64, 64, 128], [128, 128, 256], [128, 128, 256]]) self.sa3 = PointNetSetAbstraction(None, None, None, 640 + 3, [256, 512, 1024], True) self.fc1 = nn.Linear(1024, 512) self.bn1 = nn.BatchNorm1d(512) self.drop1 = nn.Dropout(0.4) self.fc2 = nn.Linear(512, 256) self.bn2 = nn.BatchNorm1d(256) self.drop2 = nn.Dropout(0.5) self.fc3 = nn.Linear(256, num_class) def forward(self, xyz): B, _, _ = xyz.shape if self.normal_channel: norm = xyz[:, 3:, :] xyz = xyz[:, :3, :] else: norm = None l1_xyz, l1_points = self.sa1(xyz, norm) l2_xyz, l2_points = self.sa2(l1_xyz, l1_points) l3_xyz, l3_points = self.sa3(l2_xyz, l2_points) x = l3_points.view(B, 1024) x = self.drop1(F.relu(self.bn1(self.fc1(x)))) x = self.drop2(F.relu(self.bn2(self.fc2(x)))) x = self.fc3(x) x = F.log_softmax(x, -1) return x,l3_points\",\"MSG的关键优点在于它通过在训练期间的随机输入丢弃（即随机移除一部分输入点）来模拟不同的采样密度，从而训练网络在面对实际应用中可能遇到的各种采样密度时，能够自适应地选择最适合的特征尺度进行组合，以实现最佳的性能。这种方法大大增强了网络处理非均匀采样数据的能力，提高了模型的泛化性和稳健性。\",\"在训练时引入不同密度的点集情况，使网络能学习不同采样密度下局部点云特征的提取，捕获密集到稀疏采样区域内的多尺度信息 -- 通过随机丢弃来模拟不同密度的采样，使网络能够应对实际中各种密度变换的情况-提高模型的泛化性能。\",\"MSG相当于并联了多个hierarchical structure，每个结构中心点不变，但是尺度不同。通过PointNet获取每个形心多尺度信息，之后concat形成该区域提取的总特征。在训练时引入随机丢弃形心来模拟不同密度情况，提高算法鲁棒性。\"]},\"18\":{\"h\":\"多分辨率分组（Multi-Resolution Grouping）\",\"t\":[\"MSG方法虽然有效，但在计算上可能非常昂贵，尤其是在低层次上对每个质心点运行局部PointNet时。为此，MRG为一种低成本的替代方案。\",\"MRG通过结合来自不同分辨率的特征来实现效率和适应性的平衡。具体而言，MRG策略在处理每个局部区域时，不仅考虑从当前分辨率下抽象得到的特征，还考虑了从更低分辨率（即上一层级）直接提取的特征。这两种特征被concat为一个复合特征向量，为后续的处理步骤提供信息。\",\"多分辨率分组\",\"在MRG中，某一层次𝐿𝑖的区域特征是通过将来自下一级𝐿𝑖−1的子区域特征总结后的向量与直接处理该局部区域所有原始点的单个PointNet得到的特征向量进行concat得到的。当局部区域的密度较低时，由于子区域在计算第一个向量时包含的点更稀疏，因此可能比第二个向量更不可靠。在这种情况下，应该更高地加权第二个向量。相反，当局部区域的密度较高时，第一个向量提供了更细致的信息，因为它能够在更低层次上递归地检视更高分辨率。\",\"来自下一级的特征：首先，将来自下一级（更高分辨率）的特征进行汇总，形成一个特征向量。这一过程通过对每个子区域应用集合抽象层（set abstraction level）完成。\",\"直接处理的原始点特征：另一部分特征是通过在当前分辨率直接对所有原始点应用单个PointNet得到的。\"]},\"19\":{\"h\":\"简析PointNet\",\"t\":[\"简析PointNet网络模型及其背后原理\",\"论文: https://arxiv.org/abs/1612.00593 TensorFlow 版本代码: https://github.com/charlesq34/pointnet Pytorch 版本代码: https://github.com/fxia22/pointnet.pytorch\"]},\"20\":{\"h\":\"核心\",\"t\":[\"问题背景: 点云是三维几何数据的一种重要表示形式，但由于其无序性和非规则性，传统卷积神经网络难以直接处理。\",\"❌ 传统方法的缺陷 ：\",\"将点云转换为体素网格（voxel grid）或图像视图（multi-view rendering）， 这些方法会导致信息损失、计算量大、不灵活等问题。\",\"🌟 PointNet 的创新点 ：\",\"直接以点集作为输入，避免了复杂的预处理；\",\"设计了一个统一架构，适用于分类、物体分割和场景语义解析；\",\"利用对称函数（如最大池化）实现点集顺序不变性；\",\"引入 T-Net（空间变换网络）标准化输入点云和特征空间。\"]},\"21\":{\"h\":\"难点\",\"t\":[\"点云的无序性（Unordered）: 点云是点的集合，没有固定顺序；模型必须对输入点的排列顺序不敏感（permutation invariant）。\",\"点之间存在相互作用（Interaction among points）: 点与点之间有空间关系，需要捕捉局部结构。\",\"对几何变换的不变性（Invariance under transformations）: 模型输出应不受刚性变换影响（如旋转、平移）。\",\"输入点云可能缺失或包含噪声（Missing or noisy points）: 实际采集的点云常有遮挡、稀疏、异常值等问题。\"]},\"22\":{\"h\":\"解决方案\",\"t\":[\"✅ 难点 1：点云的无序性 → 使用对称函数（Symmetric Function）\",\"使用 max pooling 作为对称函数，聚合所有点的信息；\",\"所有点经过共享参数的 MLP 提取特征；\",\"最终输出与点的顺序无关；\",\"原理说明：\",\"f({x1, ..., xn}) ≈ g(h(x1), ..., h(xn)) = γ(MAX(h(x1), ..., h(xn)))\",\"其中：\",\"h(xi) 是每个点的高维特征；\",\"MAX 是 max pooling 函数；\",\"γ 是后续的全连接网络；\",\"整个函数 f 是对称的，即对点顺序不敏感。\",\"效果：\",\"实验证明 max pooling 比排序、RNN、average pooling 更有效；s\",\"PointNet 可以处理任意顺序的点集；\",\"✅ 难点 2：点之间的相互作用 → 设计局部 + 全局信息融合机制\",\"在分割任务中，将全局特征与每个点的局部特征拼接起来；\",\"这样每个点在预测标签时都能看到整个物体的上下文；\",\"效果：\",\"显著提升了分割性能；\",\"让模型既关注局部细节，又理解整体结构；\",\"✅ 难点 3：对几何变换的不变性 → 引入 T-Net（空间变换网络）\",\"引入两个空间变换网络： \",\"STN3d：对输入点云做刚性变换（3×3 矩阵）；\",\"STNkd：对特征空间做变换（64×64 矩阵）；\",\"加入正则项约束变换矩阵接近正交：\",\"L_reg = ||I - A @ A^T||_F^2\",\"效果：\",\"PointNet 对点云的旋转、平移等变换具有鲁棒性；\",\"提升了模型的泛化能力和稳定性；\",\"✅ 难点 4：输入点云可能缺失或含有异常点 → 理论分析保证模型鲁棒性\",\"理论上证明 PointNet 学到的是一个“关键点集”（critical point set），即只依赖一小部分关键点就能判断整体形状；\",\"即使丢失一些点或加入异常点，只要关键点还在，结果就不会变；\",\"定理表明：\",\"小扰动不会改变函数输出；\",\"网络输出由一个有限子集 CS 决定（大小不超过 bottleneck 维度 K）；\",\"CS 是关键点集合，NS 是最大可容忍的点云范围；\",\"实验验证：\",\"即使 50% 的点缺失，分类准确率仅下降约 3.7%；\",\"对异常点也有一定容忍能力；\",\"✅ 总结: PointNet 通过 max pooling 实现对称性，结合 T-Net 实现变换不变性，并通过局部+全局特征融合机制实现强大的点云建模能力，解决了点云处理中的四大技术难点，为后续三维深度学习奠定了基础。\"]},\"23\":{\"h\":\"代码(Pytorch版本)\",\"t\":[\"PointNet网络模型结构图\"]},\"24\":{\"h\":\"输入标准化\",\"t\":[\"在 PointNet 架构中，第一层是一个叫做 STN3d（Spatial Transformer Network for 3D points） 的模块，它的目标是：\",\"✅ 对输入的点云做刚性变换（如旋转 + 平移），使其姿态统一，提升模型鲁棒性。\",\"这是因为在实际采集过程中，点云的姿态可能各不相同（比如椅子朝向不同、扫描角度不同等），如果不加处理，会影响特征提取的一致性。\",\"STN3d 是一个小型神经网络，专门用于预测一个 3×3 的变换矩阵 ，这个矩阵表示对点云所做的变换（通常是旋转或反射）。\",\"它具有以下特点：\",\"输入是原始点云（shape: (B, 3, N)）；\",\"输出是一个变换矩阵（shape: (B, 3, 3)）；\",\"这个变换矩阵是近似正交的，保证变换是刚性的；\",\"变换矩阵会通过 torch.bmm() 应用到原始点云上（这一步不在 STN3d 类中）；\",\"目的是让点云“摆正”，便于后续处理。\",\"代码实现:\",\"class STN3d(nn.Module): def __init__(self): super(STN3d, self).__init__() # 使用 1D 卷积 处理点云数据（每个点有 3 个坐标值） # kernel_size=1 表示只在通道维度操作，不考虑空间邻域关系 # 提取每一点的特征向量（从 3 → 64 → 128 → 1024） self.conv1 = torch.nn.Conv1d(3, 64, 1) self.conv2 = torch.nn.Conv1d(64, 128, 1) self.conv3 = torch.nn.Conv1d(128, 1024, 1) # 经过全局池化后得到一个全局特征向量（1024维） # 用全连接层逐步压缩到 9 个输出 → 对应一个 3x3 的变换矩阵 self.fc1 = nn.Linear(1024, 512) self.fc2 = nn.Linear(512, 256) self.fc3 = nn.Linear(256, 9) # 所有卷积和 FC 层后面都加了 BN 和 ReLU，帮助训练稳定收敛 self.relu = nn.ReLU() self.bn1 = nn.BatchNorm1d(64) self.bn2 = nn.BatchNorm1d(128) self.bn3 = nn.BatchNorm1d(1024) self.bn4 = nn.BatchNorm1d(512) self.bn5 = nn.BatchNorm1d(256) # x: (batch,3,point_size) def forward(self, x): # 获取当前 batch 的大小（有多少组点云） batchsize = x.size()[0] # CNN 逐点，通道维度特征提取阶段 x = F.relu(self.bn1(self.conv1(x))) x = F.relu(self.bn2(self.conv2(x))) x = F.relu(self.bn3(self.conv3(x))) # x: (batch,1024,point_size) # 全局最大池化（Global Max Pooling） # 从所有点中选出每个通道的最大响应值，作为整个点云的“抽象”表示，shape: (B, 1024) # 返回：一个元组：(values, indices)，分别是最大值和它们的位置索引。 x = torch.max(x, 2, keepdim=True)[0] # x: (batch,1024,1) x = x.view(-1, 1024) # x: (batch,1024) # 全连接层预测变换矩阵 x = F.relu(self.bn4(self.fc1(x))) x = F.relu(self.bn5(self.fc2(x))) x = self.fc3(x) # x: (batch,9) # 加上单位矩阵作为初始偏置 # 初始假设变换为恒等变换（不做任何变化） iden = Variable(torch.from_numpy(np.array([1,0,0,0,1,0,0,0,1]).astype(np.float32))).view(1,9).repeat(batchsize,1) if x.is_cuda: iden = iden.cuda() # 让网络从一个小扰动开始学习，更容易训练 x = x + iden # 最终 reshape 成 3x3 矩阵返回 x = x.view(-1, 3, 3) return x\",\"标准化的意义:\",\"✅ 1. 解决点云姿态不一致问题\",\"输入点云可能来自不同角度、不同位置；\",\"T-Net 把它们“对齐”到一个标准姿态；\",\"这样 PointNet 后续的特征提取更稳定。\",\"✅ 2. 提升模型鲁棒性\",\"如果没有 T-Net，PointNet 必须自己学会对各种姿态都识别准确；\",\"加入 T-Net 后，相当于加了一个“预处理层”，让模型更容易训练和泛化。\",\"神经网络的输出在训练初期往往接近于零，如果直接作为变换矩阵，会导致非正交、不稳定。PointNet 通过“加单位矩阵”的方式，让变换矩阵从一个恒等变换开始学习，并结合正则化损失，逐步向正交矩阵靠拢，从而保证变换是刚性的、稳定的。\"]},\"25\":{\"h\":\"正则化损失\",\"t\":[\"feature_transform_regularizer 是 PointNet 中用于约束变换矩阵接近正交性的正则化损失函数。\",\"🧠 为什么需要这个正则化项？\",\"在 PointNet 中，为了提升模型对点云姿态变化的鲁棒性，引入了两个变换网络：\",\"STN3d: 对原始点云做刚性变换（如旋转、反射），使其标准化。\",\"STNkd: 对特征空间做变换，使特征分布更稳定。\",\"这两个网络输出的是变换矩阵（分别是 3×3 和 k×k 的矩阵）。但由于它们是神经网络直接预测出来的，并不能保证这些矩阵是正交矩阵（orthogonal matrix） 。\",\"❗而只有正交矩阵才能表示刚性变换（rigid transformation），即只改变物体的方向而不改变形状和大小。\",\"所以我们需要加一个正则化项来鼓励变换矩阵接近正交矩阵 , 这就是 feature_transform_regularizer 的作用！\",\"def feature_transform_regularizer(trans): d = trans.size()[1] batchsize = trans.size()[0] # 构造一个单位矩阵 I，用于后续比较； # 添加 None 是为了扩展成 (1, d, d)，便于广播到整个 batch； I = torch.eye(d)[None, :, :] if trans.is_cuda: I = I.cuda() # 计算变换矩阵与其转置相乘后与单位矩阵之间的距离（Frobenius 范数），然后取 batch 平均值作为损失项，鼓励变换矩阵接近正交矩阵。 # Frobenius 范数（矩阵所有元素平方和开方） loss = torch.mean(torch.norm(torch.bmm(trans, trans.transpose(2,1)) - I, dim=(1,2))) return loss\"]},\"26\":{\"h\":\"特征提取\",\"t\":[\"PointNet 的核心特征提取模块 PointNetfeat ，它负责从输入点云中提取出可用于分类或分割的特征。\",\"class PointNetfeat(nn.Module): def __init__(self, global_feat = True, feature_transform = False): super(PointNetfeat, self).__init__() # 输入点云变换网络（3D） self.stn = STN3d() # 使用 Conv1D 对每个点进行特征提取； # 每个卷积层后跟一个 BatchNorm 层； # 最终输出高维特征（1024维）； self.conv1 = torch.nn.Conv1d(3, 64, 1) self.conv2 = torch.nn.Conv1d(64, 128, 1) self.conv3 = torch.nn.Conv1d(128, 1024, 1) self.bn1 = nn.BatchNorm1d(64) self.bn2 = nn.BatchNorm1d(128) self.bn3 = nn.BatchNorm1d(1024) # 全局特征开关：控制是否输出全局特征 self.global_feat = global_feat # 特征变换开关：控制是否使用 STN 对特征空间进行变换 self.feature_transform = feature_transform if self.feature_transform: self.fstn = STNkd(k=64) def forward(self, x): n_pts = x.size()[2] # 使用 STN3d 预测出一个变换矩阵； trans = self.stn(x) x = x.transpose(2, 1) # 将原始点云“摆正”； x = torch.bmm(x, trans) x = x.transpose(2, 1) # 再通过第一个卷积层提取初始特征； x = F.relu(self.bn1(self.conv1(x))) if self.feature_transform: trans_feat = self.fstn(x) x = x.transpose(2,1) x = torch.bmm(x, trans_feat) x = x.transpose(2,1) else: trans_feat = None # 提取更高维的特征； # 最后一层输出 shape: (B, 1024, N) pointfeat = x x = F.relu(self.bn2(self.conv2(x))) x = self.bn3(self.conv3(x)) # 从所有点中选出每个通道的最大响应值，作为整个点云的“抽象”表示，shape: (B, 1024) # 返回：一个元组：(values, indices)，分别是最大值和它们的位置索引。 x = torch.max(x, 2, keepdim=True)[0] x = x.view(-1, 1024) # 如果是分类任务 (global_feat=True)： if self.global_feat: return x, trans, trans_feat else: # 如果是分割任务 (global_feat=False)： x = x.view(-1, 1024, 1).repeat(1, 1, n_pts) return torch.cat([x, pointfeat], 1), trans, trans_feat\",\"✅ 如果是分类任务 (global_feat=True)，则返回：\",\"x: 全局特征 (B, 1024)\",\"trans: 输入点云变换矩阵\",\"trans_feat: 特征空间变换矩阵（可选）\",\"✅ 如果是分割任务 (global_feat=False)， 则返回：\",\"把全局特征复制 N 次并与每个点的局部特征，在通道维度进行拼接\",\"将每个点的局部特征与整个点云的全局特征拼接起来，让每个点都能看到上下文信息\",\"输出 shape: (B, 1088, N) ，即 1088 = 1024+64\"]},\"27\":{\"h\":\"分类任务\",\"t\":[\"PointNet 的分类模块 PointNetCls ，它基于前面的特征提取模块 PointNetfeat 来完成点云分类任务。\",\"class PointNetCls(nn.Module): def __init__(self, k=2, feature_transform=False): super(PointNetCls, self).__init__() self.feature_transform = feature_transform # 它使用 PointNetfeat 提取全局特征（1024维）； self.feat = PointNetfeat(global_feat=True, feature_transform=feature_transform) # 然后通过全连接层（MLP）将这些特征映射到类别空间； self.fc1 = nn.Linear(1024, 512) self.fc2 = nn.Linear(512, 256) self.fc3 = nn.Linear(256, k) self.dropout = nn.Dropout(p=0.3) self.bn1 = nn.BatchNorm1d(512) self.bn2 = nn.BatchNorm1d(256) self.relu = nn.ReLU() def forward(self, x): # 它使用 PointNetfeat 提取全局特征（1024维）； x, trans, trans_feat = self.feat(x) # 然后通过全连接层（MLP）将这些特征映射到类别空间； x = F.relu(self.bn1(self.fc1(x))) x = F.relu(self.bn2(self.dropout(self.fc2(x)))) x = self.fc3(x) # 最终输出每个类别的概率分布（log_softmax）； return F.log_softmax(x, dim=1), trans, trans_feat\"]},\"28\":{\"h\":\"分割任务\",\"t\":[\"PointNet 的分割模块 PointNetDenseCls ，它基于前面的特征提取模块 PointNetfeat 来完成点云物体分割任务。\",\"class PointNetDenseCls(nn.Module): def __init__(self, k = 2, feature_transform=False): super(PointNetDenseCls, self).__init__() self.k = k self.feature_transform=feature_transform self.feat = PointNetfeat(global_feat=False, feature_transform=feature_transform) self.conv1 = torch.nn.Conv1d(1088, 512, 1) self.conv2 = torch.nn.Conv1d(512, 256, 1) self.conv3 = torch.nn.Conv1d(256, 128, 1) self.conv4 = torch.nn.Conv1d(128, self.k, 1) self.bn1 = nn.BatchNorm1d(512) self.bn2 = nn.BatchNorm1d(256) self.bn3 = nn.BatchNorm1d(128) def forward(self, x): batchsize = x.size()[0] n_pts = x.size()[2] # 点的数量 # 调用 PointNetfeat 提取特征 # 最后将每个点的局部特征与整个点云的全局特征拼接起来，让每个点都能看到上下文信息 x, trans, trans_feat = self.feat(x) # 使用多层 Conv1D 层进一步融合局部 + 全局信息 # 最终输出 shape: (B, k, N) x = F.relu(self.bn1(self.conv1(x))) x = F.relu(self.bn2(self.conv2(x))) x = F.relu(self.bn3(self.conv3(x))) x = self.conv4(x) # shape: (B, k, N) -> (B, N, k) , 即每个点的各个类别得分 x = x.transpose(2,1).contiguous() # 使用 log_softmax 得到 log 概率分布； x = F.log_softmax(x.view(-1,self.k), dim=-1) # shape: (B*N, k) x = x.view(batchsize, n_pts, self.k) # shape: (B, N, k) return x, trans, trans_feat\",\"✅ 1. 每个点都需要全局上下文\",\"仅靠局部特征很难判断某个点属于哪个部件（比如椅子的腿 vs 座位）；\",\"加上全局特征后，相当于告诉模型：“你知道吗，这是一个椅子”；\",\"这样模型就能根据上下文更准确地做出判断；\",\"✅ 2. 全局特征不能直接用于分割\",\"全局特征只有一份（(B, 1024)），无法直接用于每个点；\",\"所以要把它复制 N 次，变成 (B, 1024, N)；\",\"再与每个点的局部特征拼接；\"]},\"29\":{\"h\":\"缺陷\",\"t\":[\"🧠 一、核心问题：忽略局部结构信息\",\"PointNet 只通过 max pooling 聚合所有点的信息，忽略了局部邻域之间的结构关系。\",\"🔍 原因分析：\",\"PointNet 对每个点独立处理（参数共享），然后使用全局最大池化（Global Max Pooling）提取特征；\",\"这种设计使得网络只关注“最显著的点”，而没有建模点与点之间的局部几何关系；\",\"导致模型无法捕捉到更细粒度的几何细节，比如边缘、曲率、表面纹理等；\",\"💡 论文中的验证：\",\"在部件分割任务中，虽然 PointNet 表现不错，但在一些复杂区域（如椅子腿和桌面连接处）容易出错；\",\"分类任务中对缺失点具有一定鲁棒性，但遇到遮挡严重或点分布不均匀时性能下降明显；\",\"📉 二、分割任务依赖拼接机制，不够精细\",\"PointNet 的分割模块通过拼接全局特征 + 局部特征实现上下文感知，但这种方式表达能力有限。\",\"🔍 原理回顾：\",\"PointNet 的分割网络将全局特征复制 N 次并与每个点的局部特征拼接；\",\"然后使用 Conv1D 进行分类；\",\"实际上是用一个固定大小的全局特征去“广播”给每个点；\",\"⚠️ 问题所在：\",\"全局特征不能很好地反映每个点的上下文；\",\"拼接方式缺乏动态调整机制；\",\"难以区分语义相近但位置不同的区域（如桌子边缘 vs 中心）；\",\"🧱 三、对局部形状变化敏感\",\"PointNet 提取的关键点集合（critical point set）可能不足以代表复杂的局部结构。\",\"🔍 实验观察：\",\"在论文中提到，PointNet 学到的是一个关键点集合，这些点大致构成物体的骨架；\",\"如果这些关键点缺失或被遮挡，即使其他点都在，也可能导致错误分类；\",\"对于非刚性变形（如人体姿态变化），PointNet 的表现不如基于图结构的模型；\",\"📈 四、分类性能略逊于多视角方法\",\"在某些标准数据集（如 ModelNet40）上，PointNet 的分类准确率略低于 MVCNN 等基于图像的方法。\",\"方法\",\"分类准确率\",\"MVCNN（多视角 CNN）\",\"90.1%\",\"VoxNet（体素 CNN）\",\"85.9%\",\"PointNet\",\"89.2%\",\"虽然 PointNet 在速度和效率上占优，但在精度上仍略逊一筹。\",\"🧩 五、难以捕捉非刚性变换下的不变性\",\"PointNet 使用 T-Net 强制学习正交变换矩阵，只能处理刚性变换（旋转、反射），无法处理非刚性形变（如弯曲、拉伸）。\",\"🔍 举例说明：\",\"如果你有一张人脸的点云，由于表情不同，面部发生形变；\",\"PointNet 很难在这种情况下保持分类的一致性；\",\"相比之下，基于图卷积或注意力机制的模型更能捕捉这种非刚性变化；\",\"🧱 六、缺乏层次化特征提取机制\",\"PointNet 是一种单尺度网络，无法像 CNN 那样逐层提取多层次的抽象特征。\",\"✅ 后续改进：\",\"PointNet++ 正是对这一缺陷的改进；\",\"它引入了局部区域搜索 + 多尺度聚合机制；\",\"从而能够更好地捕捉点云的局部结构和层次信息；\",\"📊 七、对稀疏点云敏感\",\"当输入点云非常稀疏时（如只有几十个点），PointNet 的性能会显著下降。\",\"🔍 原因分析：\",\"PointNet 的全局特征来自于 max pooling；\",\"如果点太少，max pooling 得到的特征可能无法覆盖整个物体；\",\"特别是在遮挡严重的情况下，关键点可能丢失；\",\"📐 八、结构简单，不利于高维空间建模\",\"PointNet 的结构过于简单，难以建模更高维度的空间关系。\",\"✅ 后续发展：\",\"后续的 3D 深度学习模型（如 DGCNN、SpiderCNN、PointCNN、Transformer-based 点云模型）都尝试引入更复杂的结构来提升建模能力；\",\"如：构建点之间的邻接图、使用 attention、引入多尺度采样等；\",\"🧪 九、理论上的限制：受限于瓶颈维度 K\",\"PointNet 的表达能力受 max pooling 层维度 K 的限制，即 bottleneck dimension。\",\"📌 来自论文的理论分析：\",\"Theorem 2 表明，PointNet 的输出仅由一个不超过 K 个点的子集决定（critical point set），这意味着：\",\"如果 K 不够大，PointNet 可能遗漏重要细节；\",\"如果 K 太大，又会导致计算资源浪费；\",\"🧱 十、对噪声点敏感（尤其未训练时）\",\"虽然 PointNet 对少量异常点有一定鲁棒性，但如果训练时没有加入扰动，面对大量噪声点时效果较差。\",\"🔍 实验验证：\",\"论文中做了“插入异常点”的实验；\",\"结果显示，如果训练过程中加入了噪声，模型表现良好；\",\"否则，异常点会影响分类和分割性能；\",\"📉 十一、在大规模场景理解任务中表现一般\",\"PointNet 的时间复杂度虽然是 O(N)，但在处理超大规模点云时，仍然不如分块处理或多层级聚合模型高效。\",\"✅ 后续改进方向：\",\"使用分块策略（chunking）\",\"构建点云的层次化表示\",\"引入 attention 或图结构增强局部建模能力\",\"🧩 总结表格：PointNet 的主要缺陷\",\"缺陷类型\",\"描述\",\"是否被后续模型改进\",\"忽略局部结构\",\"仅靠 max pooling 提取特征，无局部聚合机制\",\"✅ PointNet++ 改进\",\"分割精度不高\",\"拼接机制不够精细，缺乏动态上下文感知\",\"✅ Transformer-based 改进\",\"无法处理非刚性变形\",\"T-Net 只学正交变换，无法应对弯曲、拉伸等形变\",\"✅ 图卷积、attention 改进\",\"分类精度略低\",\"在 ModelNet40 上略低于 MVCNN\",\"✅ 多视角 + PointNet 混合模型改进\",\"稀疏点云下性能差\",\"少量点无法覆盖关键结构\",\"✅ PointNet++ 改进\",\"局部建模能力弱\",\"无法捕捉边缘、曲率等细节\",\"✅ DGCNN、SpiderCNN 改进\",\"对噪声点敏感\",\"未经扰动训练时，对异常点鲁棒性差\",\"✅ 加入数据增强后缓解\",\"结构单一\",\"缺乏层次化、多尺度建模能力\",\"✅ PointNet++ / Transformer 改进\",\"📈 PointNet 的优势 vs 缺陷对比\",\"维度\",\"优势\",\"缺陷\",\"输入形式\",\"支持原始点云，无需预处理\",\"无法有效利用局部结构\",\"排列不变性\",\"完全支持\",\"无法区分顺序信息（如时间序列点云）\",\"变换不变性\",\"支持刚性变换标准化\",\"无法处理非刚性形变\",\"分类性能\",\"接近 SOTA\",\"略逊于多视角 CNN\",\"分割性能\",\"表现良好\",\"缺乏精细建模\",\"效率\",\"极其高效（O(N)）\",\"无法充分利用 GPU 并行优化\",\"扩展性\",\"易于扩展为检测、检索等任务\",\"表达能力受限于 max pooling 维度\",\"✅ 一句话总结：\",\"PointNet 的最大缺陷在于它“看不清细节”，只关注全局结构，忽视局部邻域关系，这使得它在细粒度识别、非刚性变形、稀疏点云等任务中表现受限，但它也为后续模型奠定了基础。\"]},\"30\":{\"h\":\"背景知识扫盲(可选)\"},\"31\":{\"h\":\"点云\",\"t\":[\"点云: 是一种表示三维空间中物体或场景的方式，它由大量带有位置信息的点组成。\",\"每个点通常包含：\",\"坐标信息 ：x, y, z（3D 空间中的位置）。\",\"可选属性：颜色（RGB）、法向量（Normal）、强度（Intensity）、时间戳等。\",\"表示形式:\",\"点云（Point Cloud）: 原始点集合：每个点有(x, y, z)坐标; 可选颜色、法向量等属性, 简洁、轻便; 保留原始几何信息,无序性、非结构化、难以用 CNN 处理。\",\"体素网格 (voxel grids) : 将空间划分成立方体格子，每个格子表示是否有物体; 结构规整，适合 3D CNN; 计算复杂度高、稀疏性强、精度受限。\",\"多视角图像（Multi-View Images）: 从多个角度渲染点云或 3D 模型为 2D 图像; 可使用成熟的 2D CNN 方法; 丢失部分几何信息，依赖视角选择。\",\"网格（Mesh）： 由三角形面片组成的 3D 模型； 包含表面细节，适合渲染； 难以自动构建，拓扑复杂。\"]},\"32\":{\"h\":\"对称函数\",\"t\":[\"对称函数（Symmetric Function）是一种对输入顺序不敏感的函数；换句话说，无论你如何打乱输入元素的顺序，输出结果都保持不变。\",\"🧠 数学定义:\",\"设是一个函数，如果对于任意排列（permutation），都有：\",\"那么就是一个 对称函数。\",\"PointNet 处理的是点云数据，而点云是无序集合（unordered set） ，即：\",\"点云中点的顺序不影响整体形状。\",\"所以模型必须具有对点顺序的不变性（permutation invariance）。\",\"这就要求网络中的某些关键操作必须是对称函数 ，才能保证整个网络输出与输入点的顺序无关。\",\"📦 常见的对称函数:\",\"函数\",\"描述\",\"是否可微\",\"应用场景\",\"最大池化（Max Pooling）\",\"取所有点的最大值：\",\"✅ 是\",\"PointNet 中的核心操作\",\"平均池化（Average Pooling）\",\"取所有点的平均值：\",\"✅ 是\",\"特征融合、平滑处理\",\"求和（Summation）\",\"所有点相加：\",\"✅ 是\",\"构建全局特征向量\",\"乘积（Product）\",\"所有点相乘：\",\"⚠️ 对数值变化敏感\",\"不常用，但可用于特定任务\",\"最小池化（Min Pooling）\",\"取最小值：\",\"✅ 是\",\"异常检测等特殊场景\",\"Softmax + 加权和（Attention-based Sum）\",\"根据注意力机制加权求和，权重由 softmax 得出\",\"✅ 是\",\"DGCNN、Transformer 中使用\",\"统计量（如方差、标准差）\",\"计算点集的分布特性\",\"✅ 是\",\"特征增强、异常检测\",\"集合函数近似器（如 Deep Sets）\",\"使用神经网络直接学习对称函数\",\"✅ 是\",\"更复杂的对称函数建模\"]},\"33\":{\"h\":\"刚性运动\",\"t\":[\"刚性运动(rigid motions) 是指：物体在空间中移动时，其形状和大小保持不变的运动方式 。\",\"刚性运动\",\"❌ 不改变\",\"移动、旋转\",\"非刚性运动\",\"✅ 改变\",\"弯曲、拉伸、缩放（非均匀）、变形\",\"刚性运动 = 平移 + 旋转，不改变物体形状和内部结构，只改变位置和朝向。\"]},\"34\":{\"h\":\"正交变换\",\"t\":[\"正交变换的本质是：只改变物体的方向（旋转），不改变形状和大小\",\"所以：\",\"正交变换包括：旋转 + 反射。\",\"不包括：缩放、剪切、拉伸等会导致形变的操作。\"]},\"35\":{\"h\":\"大语言模型\"},\"36\":{\"h\":\"图解 Bert\",\"t\":[\"图解Bert & Bert文本分类实战\"]},\"37\":{\"h\":\"环境搭建\",\"t\":[\"按序执行以下命令完成环境搭建:\",\"git clone https://github.com/DA-southampton/Read_Bert_Code.git cd Read_Bert_Code conda create -n Read_Bert_Code python=3.9.22 conda activate Read_Bert_Code\",\"本文使用的是谷歌的中文预训练模型：chinese_L-12_H-768_A-12.zip，模型有点大，我就不上传了，如果本地不存在，就点击这里直接下载,或者直接命令行运行\",\"wget https://storage.googleapis.com/bert_models/2018_11_03/chinese_L-12_H-768_A-12.zip\",\"预训练模型下载下来之后，进行解压，然后将tf模型转为对应的pytorch版本即可。对应代码如下:\",\"export BERT_BASE_DIR=/Users/zhandaohong/Read_Bert_Code/chinese_L-12_H-768_A-12 python convert_tf_checkpoint_to_pytorch.py \\\\ --tf_checkpoint_path$BERT_BASE_DIR/bert_model.ckpt \\\\ --bert_config_file$BERT_BASE_DIR/bert_config.json \\\\ --pytorch_dump_path$BERT_BASE_DIR/pytorch_model.bin\",\"转化成功之后，将模型放入到仓库对应位置：\",\"Read_Bert_Code/bert_read_step_to_step/prev_trained_model/\",\"并重新命名为：\",\" bert-base-chinese\",\"其次是准备训练数据，这里我准备做一个文本分类任务，使用的是Tnews数据集，这个数据集来源是这里，分为训练，测试和开发集，我已经上传到了仓库中，具体位置在\",\"Read_Bert_Code/bert_read_step_to_step/chineseGLUEdatasets/tnews\",\"需要注意的一点是，因为我只是为了了解内部代码情况，所以准确度不是在我的考虑范围之内，所以我只是取其中的一部分数据，其中训练数据使用1k，测试数据使用1k，开发数据1k。\",\"准备就绪，使用pycharm导入项目，准备调试，我的调试文件是run_classifier.py文件，对应的参数为\",\"--model_type=bert --model_name_or_path=prev_trained_model/bert-base-chinese --task_name=\\\"tnews\\\" --do_train --do_eval --do_lower_case --data_dir=./chineseGLUEdatasets/tnews --max_seq_length=128 --per_gpu_train_batch_size=16 --per_gpu_eval_batch_size=16 --learning_rate=2e-5 --num_train_epochs=4.0 --logging_steps=100 --save_steps=100 --output_dir=./outputs/tnews_output/ --overwrite_output_dir\",\"然后启动 run_classifier.py 文件进行调试即可 , 所参考源仓库未提供requirements.txt文件，因此需要大家自行完成运行时缺失依赖包的安装。\"]},\"38\":{\"h\":\"数据预处理\",\"t\":[\"输入数据格式\",\"{ \\\"guid\\\": \\\"train-0\\\", \\\"label\\\": \\\"104\\\", // 文本分类任务: 文本对应的标签 \\\"text_a\\\": \\\"股票中的突破形态\\\", \\\"text_b\\\": null // NSP任务: 用于判断给出的两个句子是否连续 }\",\"NSP (Next Sentence Prediction)\",\"文本分词 & 借助字典映射为word id\",\"\\\"股票中的突破形态\\\" --> ['股', '票', '中', '的', '突', '破', '形', '态'] --> [5500, 4873, 704, 4638, 4960, 4788, 2501, 2578]\",\"对于字典中不存在的词 , 用 [UNK] 表示, 对应的id为 100\",\"过长截断策略\",\"添加特殊Token标记\",\"原序列添加特殊Token标记图\",\"[101, 5500, 4873, 704, 4638, 4960, 4788, 2501, 2578, 102]\",\"BertTokenizer中的特殊token id:\",\"[CLS]: 101\",\"[SEP]: 102\",\"[MASK]: 103\",\"[UNK]: 100\",\"[PAD]: 0\",\" # BertTokenizer def build_inputs_with_special_tokens(self, token_ids_0, token_ids_1=None): if token_ids_1 is None: return [self.cls_token_id] + token_ids_0 + [self.sep_token_id] cls = [self.cls_token_id] sep = [self.sep_token_id] return cls + token_ids_0 + sep + token_ids_1 + sep\",\"创建句子辨识列表，用以区分不同的句子\",\"token_type_ids作用图解\",\" # BertTokenizer def create_token_type_ids_from_sequences(self, token_ids_0, token_ids_1=None): \\\"\\\"\\\" Creates a mask from the two sequences passed to be used in a sequence-pair classification task. A BERT sequence pair mask has the following format: 0 0 0 0 0 0 0 0 0 0 1 1 1 1 1 1 1 1 1 1 1 | first sequence | second sequence if token_ids_1 is None, only returns the first portion of the mask (0's). \\\"\\\"\\\" sep = [self.sep_token_id] cls = [self.cls_token_id] if token_ids_1 is None: return len(cls + token_ids_0 + sep) * [0] return len(cls + token_ids_0 + sep) * [0] + len(token_ids_1 + sep) * [1]\",\"创建用以区分special tokens部分的mask列表\",\"special_tokens_mask作用图解\",\" # BertTokenizer def get_special_tokens_mask(self, token_ids_0, token_ids_1=None, already_has_special_tokens=False): if token_ids_1 is not None: return [1] + ([0] * len(token_ids_0)) + [1] + ([0] * len(token_ids_1)) + [1] return [1] + ([0] * len(token_ids_0)) + [1]\",\"超长截断\",\" # PreTrainedTokenizer if max_length and len(encoded_inputs[\\\"input_ids\\\"]) > max_length: encoded_inputs[\\\"input_ids\\\"] = encoded_inputs[\\\"input_ids\\\"][:max_length] encoded_inputs[\\\"token_type_ids\\\"] = encoded_inputs[\\\"token_type_ids\\\"][:max_length] encoded_inputs[\\\"special_tokens_mask\\\"] = encoded_inputs[\\\"special_tokens_mask\\\"][:max_length]\",\"生成padding部分的mask列表\",\"attention_mask作用图解\",\" # 生成注意力掩码，真实token对应1，填充token对应0 attention_mask = [1 if mask_padding_with_zero else 0] * len(input_ids)\",\"所有序列都填充到max_length长度,不足长度用padding填充\",\"填充过程图\",\" # 记录输入长度 input_len = len(input_ids) # 计算需要填充的长度 --- 所有输入序列等长，都等于max_length padding_length = max_length - len(input_ids) # 右填充 input_ids = input_ids + ([pad_token] * padding_length) attention_mask = attention_mask + ([0 if mask_padding_with_zero else 1] * padding_length) token_type_ids = token_type_ids + ([pad_token_segment_id] * padding_length)\",\"数据集中每一个样本最终都会解析得到一个InputFeatures\",\"InputFeatures组成图解\",\"features.append( InputFeatures(input_ids=input_ids, attention_mask=attention_mask, token_type_ids=token_type_ids, label=label, input_len=input_len))\",\"label 是当前文本对应的类别标签 input_len 是序列实际长度(含special tokens)\",\"数据集预处理完后，将InputFeatures List列表组装起来得到需要的DataSet\",\"dataset = TensorDataset(all_input_ids, all_attention_mask, all_token_type_ids, all_lens,all_labels)\"]},\"39\":{\"h\":\"模型架构\"},\"40\":{\"h\":\"DataLoader\",\"t\":[\" train_sampler = RandomSampler(train_dataset) if args.local_rank == -1 else DistributedSampler(train_dataset) train_dataloader = DataLoader(train_dataset, sampler=train_sampler, batch_size=args.train_batch_size,collate_fn=collate_fn)\",\"DataLoader 设置的回调方法cllote_fn负责对返回的一个batch，在返回前进行预处理:\",\"def collate_fn(batch): all_input_ids, all_attention_mask, all_token_type_ids, all_lens, all_labels = map(torch.stack, zip(*batch)) max_len = max(all_lens).item() # 计算当前批次中所有序列的实际最大长度 all_input_ids = all_input_ids[:, :max_len] # 按照本批次序列中最大长度进行截断: max_length --> max_len all_attention_mask = all_attention_mask[:, :max_len] all_token_type_ids = all_token_type_ids[:, :max_len] return all_input_ids, all_attention_mask, all_token_type_ids, all_labels\"]},\"41\":{\"h\":\"BertEmbeddings\",\"t\":[\"input embeddings = token embeddings + segmentation embeddings + position embeddings\",\"class BertEmbeddings(nn.Module): def __init__(self, config): super(BertEmbeddings, self).__init__() self.word_embeddings = nn.Embedding(config.vocab_size, config.hidden_size, padding_idx=0) self.position_embeddings = nn.Embedding(config.max_position_embeddings, config.hidden_size) self.token_type_embeddings = nn.Embedding(config.type_vocab_size, config.hidden_size) self.LayerNorm = BertLayerNorm(config.hidden_size, eps=config.layer_norm_eps) self.dropout = nn.Dropout(config.hidden_dropout_prob) def forward(self, input_ids, token_type_ids=None, position_ids=None): seq_length = input_ids.size(1) if position_ids is None: # 为当前批次中的每个序列样本生成一个位置序列: (1,2,3,4,5,...) , 构成一个位置序列矩阵 position_ids = torch.arange(seq_length, dtype=torch.long, device=input_ids.device) position_ids = position_ids.unsqueeze(0).expand_as(input_ids) if token_type_ids is None: token_type_ids = torch.zeros_like(input_ids) words_embeddings = self.word_embeddings(input_ids) position_embeddings = self.position_embeddings(position_ids) # 位置编码为可学习的矩阵 token_type_embeddings = self.token_type_embeddings(token_type_ids) # 让模型自己学会区分不同的句子 embeddings = words_embeddings + position_embeddings + token_type_embeddings embeddings = self.LayerNorm(embeddings) embeddings = self.dropout(embeddings) return embeddings\",\"嵌入向量生成过程图\"]},\"42\":{\"h\":\"BertEncoder\"},\"43\":{\"h\":\"BertLayer\",\"t\":[\"BertLayer模型结构图\",\"class BertIntermediate(nn.Module): def __init__(self, config): super(BertIntermediate, self).__init__() self.dense = nn.Linear(config.hidden_size, config.intermediate_size) # (768,3072) # 激活函数 - GLEU if isinstance(config.hidden_act, str) or (sys.version_info[0] == 2 and isinstance(config.hidden_act, unicode)): self.intermediate_act_fn = ACT2FN[config.hidden_act] else: self.intermediate_act_fn = config.hidden_act def forward(self, hidden_states): hidden_states = self.dense(hidden_states) hidden_states = self.intermediate_act_fn(hidden_states) # 激活函数 - GLEU return hidden_states class BertOutput(nn.Module): def __init__(self, config): super(BertOutput, self).__init__() self.dense = nn.Linear(config.intermediate_size, config.hidden_size) # (3072,768) self.LayerNorm = BertLayerNorm(config.hidden_size, eps=config.layer_norm_eps) self.dropout = nn.Dropout(config.hidden_dropout_prob) def forward(self, hidden_states, input_tensor): hidden_states = self.dense(hidden_states) hidden_states = self.dropout(hidden_states) hidden_states = self.LayerNorm(hidden_states + input_tensor) return hidden_states class BertLayer(nn.Module): def __init__(self, config): super(BertLayer, self).__init__() self.attention = BertAttention(config) self.intermediate = BertIntermediate(config) self.output = BertOutput(config) def forward(self, hidden_states, attention_mask=None): attention_output = self.attention(hidden_states, attention_mask) intermediate_output = self.intermediate(attention_output) layer_output = self.output(intermediate_output, attention_output) return layer_output\"]},\"44\":{\"h\":\"BertEncoder\",\"t\":[\"BertEncoder模型结构图\",\"class BertEncoder(nn.Module): def __init__(self, config): super(BertEncoder, self).__init__() self.layer = nn.ModuleList([BertLayer(config) for _ in range(config.num_hidden_layers)]) def forward(self, hidden_states, attention_mask=None, head_mask=None): for i, layer_module in enumerate(self.layer): hidden_states = layer_module(hidden_states, attention_mask, head_mask[i]) return hidden_states\"]},\"45\":{\"h\":\"BertPooler\",\"t\":[\"BertPooler模型结构图\",\"class BertPooler(nn.Module): def __init__(self, config): super(BertPooler, self).__init__() self.dense = nn.Linear(config.hidden_size, config.hidden_size) self.activation = nn.Tanh() def forward(self, hidden_states): # We \\\"pool\\\" the model by simply taking the hidden state corresponding # to the first token. first_token_tensor = hidden_states[:, 0] # CLS Token Context Embeddings pooled_output = self.dense(first_token_tensor) pooled_output = self.activation(pooled_output) return pooled_output\"]},\"46\":{\"h\":\"BertModel\",\"t\":[\"BertModel模型结构图\",\"class BertModel(BertPreTrainedModel): def __init__(self, config): super(BertModel, self).__init__(config) self.embeddings = BertEmbeddings(config) self.encoder = BertEncoder(config) self.pooler = BertPooler(config) self.init_weights() def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None): extended_attention_mask = attention_mask.unsqueeze(1).unsqueeze(2) extended_attention_mask = extended_attention_mask.to(dtype=next(self.parameters()).dtype) # fp16 compatibility extended_attention_mask = (1.0 - extended_attention_mask) * -10000.0 embedding_output = self.embeddings(input_ids, position_ids=position_ids, token_type_ids=token_type_ids) sequence_output = self.encoder(embedding_output, extended_attention_mask, # padding mask ) pooled_output = self.pooler(sequence_output) outputs = (sequence_output, pooled_output,) return outputs\"]},\"47\":{\"h\":\"BertForSequenceClassification\",\"t\":[\"BertForSequenceClassification模型结构图\",\"class BertForSequenceClassification(BertPreTrainedModel): def __init__(self, config): super(BertForSequenceClassification, self).__init__(config) self.num_labels = config.num_labels self.bert = BertModel(config) self.dropout = nn.Dropout(config.hidden_dropout_prob) self.classifier = nn.Linear(config.hidden_size, self.config.num_labels) self.init_weights() def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None, labels=None): outputs = self.bert(input_ids, attention_mask=attention_mask, # padding mask token_type_ids=token_type_ids, position_ids=position_ids, head_mask=head_mask) # None ? pooled_output = outputs[1] # 对于分类任务来说，只需要去除CLS Token用于分类任务即可 pooled_output = self.dropout(pooled_output) logits = self.classifier(pooled_output) outputs = (logits,) + outputs[2:] # add hidden states and attention if they are here if labels is not None: if self.num_labels == 1: # We are doing regression loss_fct = MSELoss() loss = loss_fct(logits.view(-1), labels.view(-1)) else: loss_fct = CrossEntropyLoss() loss = loss_fct(logits.view(-1, self.num_labels), labels.view(-1)) outputs = (loss,) + outputs return outputs # (loss), logits, (hidden_states), (attentions)\"]},\"48\":{\"h\":\"BertAttention\"},\"49\":{\"h\":\"BertSelfAttention\",\"t\":[\"多头自注意力计算流程图\",\"class BertSelfAttention(nn.Module): def __init__(self, config): super(BertSelfAttention, self).__init__() self.output_attentions = config.output_attentions self.num_attention_heads = config.num_attention_heads self.attention_head_size = int(config.hidden_size / config.num_attention_heads) self.all_head_size = self.num_attention_heads * self.attention_head_size self.query = nn.Linear(config.hidden_size, self.all_head_size) self.key = nn.Linear(config.hidden_size, self.all_head_size) self.value = nn.Linear(config.hidden_size, self.all_head_size) self.dropout = nn.Dropout(config.attention_probs_dropout_prob) def transpose_for_scores(self, x): new_x_shape = x.size()[:-1] + (self.num_attention_heads, self.attention_head_size) x = x.view(*new_x_shape) return x.permute(0, 2, 1, 3) def forward(self, hidden_states, attention_mask=None, head_mask=None): mixed_query_layer = self.query(hidden_states) mixed_key_layer = self.key(hidden_states) mixed_value_layer = self.value(hidden_states) # view 成多头格式: (batch,heads,seq_len,d_k) query_layer = self.transpose_for_scores(mixed_query_layer) key_layer = self.transpose_for_scores(mixed_key_layer) value_layer = self.transpose_for_scores(mixed_value_layer) # Take the dot product between \\\"query\\\" and \\\"key\\\" to get the raw attention scores. attention_scores = torch.matmul(query_layer, key_layer.transpose(-1, -2)) # (batch,heads,d_k,seq_len) attention_scores = attention_scores / math.sqrt(self.attention_head_size) if attention_mask is not None: # Apply the attention mask is (precomputed for all layers in BertModel forward() function) attention_scores = attention_scores + attention_mask # Normalize the attention scores to probabilities. attention_probs = nn.Softmax(dim=-1)(attention_scores) # This is actually dropping out entire tokens to attend to, which might # seem a bit unusual, but is taken from the original Transformer paper. attention_probs = self.dropout(attention_probs) context_layer = torch.matmul(attention_probs, value_layer) context_layer = context_layer.permute(0, 2, 1, 3).contiguous() new_context_layer_shape = context_layer.size()[:-2] + (self.all_head_size,) context_layer = context_layer.view(*new_context_layer_shape) # 合并头结果 return context_layer\"]},\"50\":{\"h\":\"BertSelfOutput\",\"t\":[\"BertSelfOutput计算流程图\",\"class BertSelfOutput(nn.Module): def __init__(self, config): super(BertSelfOutput, self).__init__() self.dense = nn.Linear(config.hidden_size, config.hidden_size) self.LayerNorm = BertLayerNorm(config.hidden_size, eps=config.layer_norm_eps) self.dropout = nn.Dropout(config.hidden_dropout_prob) # 残差链接 + 层归一化 def forward(self, hidden_states, input_tensor): hidden_states = self.dense(hidden_states) hidden_states = self.dropout(hidden_states) hidden_states = self.LayerNorm(hidden_states + input_tensor) return hidden_states\"]},\"51\":{\"h\":\"BertAttention\",\"t\":[\"BertAttention计算流程图\",\"class BertAttention(nn.Module): def __init__(self, config): super(BertAttention, self).__init__() self.self = BertSelfAttention(config) self.output = BertSelfOutput(config) def forward(self, input_tensor, attention_mask=None): self_outputs = self.self(input_tensor, attention_mask) # 多头自注意力机制 attention_output = self.output(self_outputs, input_tensor) return attention_output\"]},\"52\":{\"h\":\"预训练\",\"t\":[\"预训练与微调\"]},\"53\":{\"h\":\"BertPredictionHeadTransform\",\"t\":[\"BertPredictionHeadTransform结构图\",\"class BertPredictionHeadTransform(nn.Module): def __init__(self, config): super(BertPredictionHeadTransform, self).__init__() self.dense = nn.Linear(config.hidden_size, config.hidden_size) if isinstance(config.hidden_act, str) or (sys.version_info[0] == 2 and isinstance(config.hidden_act, unicode)): self.transform_act_fn = ACT2FN[config.hidden_act] else: self.transform_act_fn = config.hidden_act self.LayerNorm = BertLayerNorm(config.hidden_size, eps=config.layer_norm_eps) def forward(self, hidden_states): hidden_states = self.dense(hidden_states) hidden_states = self.transform_act_fn(hidden_states) hidden_states = self.LayerNorm(hidden_states) return hidden_states\"]},\"54\":{\"h\":\"BertLMPredictionHead\",\"t\":[\"BertLMPredictionHead结构图\",\"class BertLMPredictionHead(nn.Module): def __init__(self, config): super(BertLMPredictionHead, self).__init__() self.transform = BertPredictionHeadTransform(config) # The output weights are the same as the input embeddings, but there is # an output-only bias for each token. self.decoder = nn.Linear(config.hidden_size, config.vocab_size, bias=False) self.bias = nn.Parameter(torch.zeros(config.vocab_size)) def forward(self, hidden_states): hidden_states = self.transform(hidden_states) hidden_states = self.decoder(hidden_states) + self.bias return hidden_states\"]},\"55\":{\"h\":\"BertPreTrainingHeads\",\"t\":[\"BertPreTrainingHeads结构图\",\"class BertPreTrainingHeads(nn.Module): def __init__(self, config): super(BertPreTrainingHeads, self).__init__() self.predictions = BertLMPredictionHead(config) self.seq_relationship = nn.Linear(config.hidden_size, 2) def forward(self, sequence_output, pooled_output): prediction_scores = self.predictions(sequence_output) # seq_relationship_score = self.seq_relationship(pooled_output) # 两个句子是否为上下句关系 return prediction_scores, seq_relationship_score\"]},\"56\":{\"h\":\"BertForPreTraining\",\"t\":[\"BertForPreTraining结构图\",\"class BertForPreTraining(BertPreTrainedModel): def __init__(self, config): super(BertForPreTraining, self).__init__(config) self.bert = BertModel(config) self.cls = BertPreTrainingHeads(config) def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None, masked_lm_labels=None, next_sentence_label=None): outputs = self.bert(input_ids, attention_mask=attention_mask, token_type_ids=token_type_ids, position_ids=position_ids, head_mask=head_mask) sequence_output, pooled_output = outputs[:2] # 隐藏层输出,CLS Token Embeddings prediction_scores, seq_relationship_score = self.cls(sequence_output, pooled_output) outputs = (prediction_scores, seq_relationship_score,) # 计算掩码语言损失 和 下一个句子预测损失 if masked_lm_labels is not None and next_sentence_label is not None: loss_fct = CrossEntropyLoss(ignore_index=-1) masked_lm_loss = loss_fct(prediction_scores.view(-1, self.config.vocab_size), masked_lm_labels.view(-1)) next_sentence_loss = loss_fct(seq_relationship_score.view(-1, 2), next_sentence_label.view(-1)) total_loss = masked_lm_loss + next_sentence_loss outputs = (total_loss,) + outputs return outputs # (loss), prediction_scores, seq_relationship_score, (hidden_states), (attentions)\"]},\"57\":{\"h\":\"其他下游任务\",\"t\":[\"Bert支持的下游任务图\"]},\"58\":{\"h\":\"问答任务\",\"t\":[\"在 BERT 的问答任务中，典型的输入是一个包含 问题（Question） 和 上下文（Context） 的文本对。例如：\",\"问题: “谁写了《哈姆雷特》？”上下文: “莎士比亚是英国文学史上最伟大的作家之一，他写了包括《哈姆雷特》、《麦克白》等著名悲剧。”\",\"输入格式（Tokenization 后的形式），在使用 BertTokenizer 编码后，输入会变成如下结构：\",\"[CLS] 问题 tokens [SEP] 上下文 tokens [SEP]\",\"BERT 的输出（Outputs），通过调用 self.bert(...)，你将得到一个包含多个元素的 tuple 输出：\",\"outputs = self.bert(input_ids, attention_mask=attention_mask, token_type_ids=token_type_ids)\",\"返回值形如：\",\"( sequence_output, # (batch_size, seq_length, hidden_size) pooled_output, # (batch_size, hidden_size) )\",\"主要输出项解释:\",\"✅ sequence_output: 最终每个 token 的表示\",\"形状：(batch_size, seq_length, hidden_size)\",\"是模型最后一层所有 token（包括问题和上下文）的隐藏状态。\",\"在问答任务中，我们主要使用它来预测答案的起始和结束位置。\",\"✅ pooled_output: 句子级别表示（不常用）\",\"形状：(batch_size, hidden_size)\",\"是 [CLS] token 经过一层全连接后的输出。\",\"在分类任务中更有用，在问答任务中一般不会使用这个输出。\",\"如何利用 BERT 输出做问答预测？\",\"在 BertForQuestionAnswering 中，使用了如下逻辑：\",\"logits = self.qa_outputs(sequence_output) # (batch_size, seq_length, 2) start_logits, end_logits = logits.split(1, dim=-1) # split into start and end start_logits = start_logits.squeeze(-1) # (batch_size, seq_length) end_logits = end_logits.squeeze(-1)\",\"qa_outputs 层的作用：\",\"是一个线性层：nn.Linear(config.hidden_size, 2)\",\"将每个 token 的 hidden_size 向量映射成两个分数：一个是该 token 作为答案开始的可能性，另一个是作为答案结束的可能性。\",\"输出解释：\",\"start_logits: 每个 token 是答案起点的得分（未归一化）。\",\"end_logits: 每个 token 是答案终点的得分。\",\"比如对于一个长度为 128 的序列，每个 token 都有一个对应的 start/end 分数：\",\"start_scores = torch.softmax(start_logits, dim=-1) # softmax 得到概率 end_scores = torch.softmax(end_logits, dim=-1) # 找出最可能是 start 和 end 的位置 start_index = torch.argmax(start_scores) end_index = torch.argmax(end_scores)\",\"如果 start_index <= end_index，那么可以组合这两个索引得到答案 span。\"]},\"59\":{\"h\":\"代码实现\",\"t\":[\"class BertForQuestionAnswering(BertPreTrainedModel): def __init__(self, config): super(BertForQuestionAnswering, self).__init__(config) self.num_labels = config.num_labels # 通常是 2，即 start 和 end self.bert = BertModel(config) self.qa_outputs = nn.Linear(config.hidden_size, config.num_labels) def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None, start_positions=None, end_positions=None): outputs = self.bert(input_ids, attention_mask=attention_mask, token_type_ids=token_type_ids, position_ids=position_ids) sequence_output = outputs[0] # (batch,seq_len,hidden_size) ---> (batch,seq_len,2) logits = self.qa_outputs(sequence_output) start_logits, end_logits = logits.split(1, dim=-1) start_logits = start_logits.squeeze(-1) # (batch,seq_len) end_logits = end_logits.squeeze(-1) outputs = (start_logits, end_logits,) # 计算交叉熵损失 if start_positions is not None and end_positions is not None: # sometimes the start/end positions are outside our model inputs, we ignore these terms # ignored_index = seq_len ignored_index = start_logits.size(1) # clamp_ 是 PyTorch 中的一个方法，用于将张量中的值限制在指定的范围内。 # 它的语法是 tensor.clamp_(min, max) ，表示将张量中的值限制在 min 和 max 之间。 # 如果值小于 min ，则将其设置为 min ；如果值大于 max ，则将其设置为 max 。 start_positions.clamp_(0, ignored_index) end_positions.clamp_(0, ignored_index) # ignore_index: 用于指定在计算损失时忽略的标签索引。 loss_fct = CrossEntropyLoss(ignore_index=ignored_index) # 分别计算答案起始下标和结束下标预测得到的交叉熵损失 start_loss = loss_fct(start_logits, start_positions) end_loss = loss_fct(end_logits, end_positions) total_loss = (start_loss + end_loss) / 2 outputs = (total_loss,) + outputs return outputs # (loss), start_logits, end_logits\"]},\"60\":{\"h\":\"易混淆\",\"t\":[\"BERT 是一个 基于上下文编码（Contextual Encoder） 的模型，不是自回归生成器。它不会“生成”新的文本，而是对输入文本中每个 token 的角色进行分类（如判断哪个是答案的开始、结束）。所以最终的答案只能来自原始输入文本中的某一段子串。\",\"📚 详细解释\",\"✅ BERT 是一个 Encoder-only 模型\",\"BERT 只包含 Transformer 的 encoder 部分。\",\"它的作用是给定一个完整的句子（或两个句子），对每个 token 生成一个上下文相关的表示（contextualized representation）。\",\"它不具有生成能力，不能像 GPT 这样的 decoder-only 模型那样逐词生成新内容。\",\"🔍 QA 任务的本质：定位答案 span 而非生成答案\",\"在 SQuAD 这类抽取式问答任务中：\",\"答案必须是原文中的连续片段（span）。\",\"所以模型的任务是：\",\"给出问题和上下文；\",\"在上下文中找到最可能的答案起始位置和结束位置；\",\"最终答案就是上下文中这两个位置之间的字符串。\",\"BERT 做的就是这个定位任务，而不是重新生成一个新的答案。\",\"🧩 输入与输出的关系\",\"answer_tokens = input_ids[0][start_index : end_index + 1] answer = tokenizer.decode(answer_tokens, skip_special_tokens=True)\",\"这段代码的意思是：\",\"start_index 和 end_index 是模型预测出的答案的起始和结束位置。\",\"我们从原始输入的 input_ids 中取出对应的 token ID 子序列。\",\"使用 tokenizer 把这些 token ID 解码成自然语言文本。\",\"得到的就是答案。\",\"这其实就是在说：\",\"“根据你的理解，答案应该在这段文字中的第 X 到第 Y 个词之间，请把这部分原文告诉我。”\",\"🧪 举个例子\",\"假设原始上下文是：\",\"The capital of France is Paris.\",\"经过 Tokenizer 编码后可能是：\",\"[CLS] the capital of france is paris [SEP]\",\"如果模型预测 start_index=5，end_index=5，那么对应的就是单词 \\\"paris\\\"，这就是答案。\",\"⚠️ 注意事项\",\"不能超出上下文范围\",\"start/end positions 必须落在上下文部分（即 token_type_id == 1 的区域）。\",\"否则答案可能不合理（比如取到了问题部分的内容）。\",\"特殊 token 不计入答案\",\"[CLS], [SEP] 等会被 skip_special_tokens=True 自动跳过。\",\"无法处理不在原文中的答案\",\"如果正确答案没有出现在上下文中，BERT 无法“编造”出来。\",\"这是抽取式问答模型的局限性。\",\"💡 对比：生成式 vs 抽取式问答\",\"类型\",\"模型代表\",\"是否能生成新文本\",\"答案是否必须在原文中\",\"示例\",\"抽取式\",\"BERT\",\"❌\",\"✅\",\"答案是原文中的一段\",\"生成式\",\"T5 / BART / GPT\",\"✅\",\"❌\",\"答案可以是任意文本\",\"如果你希望模型能“自己写答案”，那就需要使用生成式模型。\",\"✅ 总结\",\"问题\",\"回答\",\"为什么答案来自 input_ids？\",\"因为 BERT 是编码器模型，只做抽取式问答，答案必须是原文中的一段文本。\",\"BERT 能不能自己生成答案？\",\"不能，BERT 不具备生成能力，只能对输入文本中的 token 做分类。\",\"如何获取答案？\",\"根据预测的 start/end index，从 input_ids 中提取 token，并用 tokenizer 解码成自然语言。\"]},\"61\":{\"h\":\"Token分类任务\",\"t\":[\"Token 分类任务是指对输入文本中的每个 token 进行分类，常见的应用场景包括：\",\"命名实体识别 (NER)\",\"词性标注 (POS)\",\"语义角色标注 (SRL)\",\"class BertForTokenClassification(BertPreTrainedModel): def __init__(self, config): super(BertForTokenClassification, self).__init__(config) self.num_labels = config.num_labels self.bert = BertModel(config) self.dropout = nn.Dropout(config.hidden_dropout_prob) self.classifier = nn.Linear(config.hidden_size, config.num_labels) def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None, labels=None): outputs = self.bert(input_ids, attention_mask=attention_mask, token_type_ids=token_type_ids, position_ids=position_ids, head_mask=head_mask) sequence_output = outputs[0] # (batch,seq_len,hidden_size) sequence_output = self.dropout(sequence_output) logits = self.classifier(sequence_output) # （batch,seq_len,num_labels） outputs = (logits,) if labels is not None: loss_fct = CrossEntropyLoss() # Only keep active parts of the loss if attention_mask is not None: active_loss = attention_mask.view(-1) == 1 active_logits = logits.view(-1, self.num_labels)[active_loss] active_labels = labels.view(-1)[active_loss] loss = loss_fct(active_logits, active_labels) else: loss = loss_fct(logits.view(-1, self.num_labels), labels.view(-1)) outputs = (loss,) + outputs return outputs # (loss), scores\"]},\"62\":{\"h\":\"多项选择任务\",\"t\":[\"多项选择任务是指给定一个问题和多个候选答案，模型需要从中选择最合适的答案。常见的应用场景包括：\",\"阅读理解任务\",\"问答系统中的候选答案选择\",\"对话系统中的候选回复选择\",\"在 多项选择题（Multiple Choice） 任务中，BERT 的输入组织形式与普通分类或问答任务略有不同。你需要为每个选项分别构造一个完整的 BERT 输入序列，并将它们组合成一个批次进行处理。\",\"✅ 假设你有一个问题 + 4 个选项：\",\"问题：谁写了《哈姆雷特》？ A. 雨果 B. 歌德 C. 莎士比亚 D. 托尔斯泰\",\"对于这样的多选问题，BERT 的输入方式是：\",\"对每一个选项，都单独构造一个 [CLS] + 问题 + [SEP] + 选项内容 + [SEP] 的输入序列。\",\"也就是说，模型会对每个选项分别编码 ，然后从中选出最合适的那个。\",\"class BertForMultipleChoice(BertPreTrainedModel): def __init__(self, config): super(BertForMultipleChoice, self).__init__(config) self.bert = BertModel(config) self.dropout = nn.Dropout(config.hidden_dropout_prob) self.classifier = nn.Linear(config.hidden_size, 1) def forward(self, input_ids, attention_mask=None, token_type_ids=None, position_ids=None, head_mask=None, labels=None): # 获取选项个数 num_choices = input_ids.shape[1] # (batch_size, num_choices, seq_length) # 将选项展平，以便一起处理: (batch_size * num_choices, seq_length) input_ids = input_ids.view(-1, input_ids.size(-1)) attention_mask = attention_mask.view(-1, attention_mask.size(-1)) if attention_mask is not None else None token_type_ids = token_type_ids.view(-1, token_type_ids.size(-1)) if token_type_ids is not None else None position_ids = position_ids.view(-1, position_ids.size(-1)) if position_ids is not None else None outputs = self.bert(input_ids, attention_mask=attention_mask, token_type_ids=token_type_ids, position_ids=position_ids, head_mask=head_mask) pooled_output = outputs[1] # (batch_size * num_choices, hidden_size) pooled_output = self.dropout(pooled_output) logits = self.classifier(pooled_output) # (batch_size * num_choices, 1) reshaped_logits = logits.view(-1, num_choices) # (batch_size , num_choices, 1) outputs = (reshaped_logits,) if labels is not None: loss_fct = CrossEntropyLoss() loss = loss_fct(reshaped_logits, labels) outputs = (loss,) + outputs return outputs # (loss), reshaped_logits, (hidden_states), (attentions)\",\"在前向传播中，会将这些输入展平，变成：\",\"input_ids.view(-1, seq_length) # (batch_size * num_choices, seq_length)\",\"这样就能让 BERT 对每个选项分别进行编码。\",\"BERT 输出后，再对每个选项做分类打分，最后重新 reshape 成 (batch_size, num_choices) 形式，用于计算交叉熵损失。\"]},\"63\":{\"h\":\"图解Transformer\",\"t\":[\"图解Transformer & 机器翻译实战\"]},\"64\":{\"h\":\"环境\",\"t\":[\"本文基于 The Annotated Transformer 所提供的代码展开进行讲解。\",\"环境搭建遵从如下步骤即可:\",\"git clone https://github.com/harvardnlp/annotated-transformer cd annotated-transformer conda create -n annotated-transformer python=3.9.22 conda activate annotated-transformer pip install -r requirements.txt\",\"MacOS 用户本地运行时，需要将 requirements.txt 文件中的 torch == 1.11.0+cu113 改为 torch==1.11.0，因为CUDA不支持MacOS。\"]},\"65\":{\"h\":\"背景\",\"t\":[\"RNN等模型的缺点是需要顺序计算，从而很难并行。因此出现了Extended Neural GPU、ByteNet和ConvS2S等网络模型。这些模型都是以CNN为基础，这比较容易并行。但是和RNN相比，它较难学习到长距离的依赖关系。\",\"本文的Transformer使用了Self-Attention机制，它在编码每一词的时候都能够注意(attend to)整个句子，从而可以解决长距离依赖的问题，同时计算Self-Attention可以用矩阵乘法一次计算所有的时刻，因此可以充分利用计算资源(CPU/GPU上的矩阵运算都是充分优化和高度并行的)。\"]},\"66\":{\"h\":\"模型架构\",\"t\":[\"Transformer 模型架构图\",\"Transformer 是一种基于自注意力机制(Self-Attention) 的神经网络架构,其由七大主要部分构成:\",\"Encoder-Decoder 结构\",\"编码器(Encoder)：将输入序列（如句子）转换为一系列高维向量表示。\",\"解码器(Decoder)：根据编码器的输出生成目标序列（如翻译后的句子）。\",\"多头自注意力机制（Multi-Head Self-Attention）\",\"自注意力机制是 Transformer 的核心，它允许模型在处理每个词时关注输入序列中的所有词。\",\"多头自注意力机制通过并行计算多个注意力头，捕捉不同子空间的信息，从而增强模型的表达能力。\",\"位置编码（Positional Encoding）\",\"由于 Transformer 不使用传统的循环或卷积结构，它通过位置编码将序列中词的位置信息注入到输入中。位置编码通常使用正弦和余弦函数生成。\",\"前馈神经网络（Feed-Forward Neural Network）\",\"在自注意力机制之后，每个位置的输出会通过一个独立的前馈神经网络进行进一步处理。\",\"残差连接与层归一化（Residual Connection & Layer Normalization）\",\"每个子层（如自注意力层和前馈层）都使用了残差连接和层归一化，以加速训练并提高模型的稳定性。\",\"掩码机制（Masking）\",\"在解码器中，使用掩码机制确保模型在生成目标序列时只能看到当前及之前的词，而不能看到未来的词。\",\"在输入序列长度不一致时，通过填充掩码（Padding Mask）屏蔽填充部分的信息。\",\"输出层\",\"解码器的最终输出通过一个线性层和 Softmax 函数生成目标序列的概率分布。\"]},\"67\":{\"h\":\"Encoder-Decoder 结构\",\"t\":[\"EncoderDecoder模型结构图\",\"class EncoderDecoder(nn.Module): def __init__(self, encoder, decoder, src_embed, tgt_embed, generator): super(EncoderDecoder, self).__init__() self.encoder = encoder self.decoder = decoder self.src_embed = src_embed self.tgt_embed = tgt_embed self.generator = generator def forward(self, src, tgt, src_mask, tgt_mask): \\\"Take in and process masked src and target sequences.\\\" return self.decode(self.encode(src, src_mask), src_mask, tgt, tgt_mask) def encode(self, src, src_mask): return self.encoder(self.src_embed(src), src_mask) def decode(self, memory, src_mask, tgt, tgt_mask): return self.decoder(self.tgt_embed(tgt), memory, src_mask, tgt_mask)\"]},\"68\":{\"h\":\"Generator\",\"t\":[\"Generator模型结构图\",\"class Generator(nn.Module): # 根据Decoder的隐状态输出一个词 # d_model是Decoder输出的大小，vocab是词典大小 def __init__(self, d_model, vocab): super(Generator, self).__init__() self.proj = nn.Linear(d_model, vocab) # 全连接再加上一个softmax def forward(self, x): return F.log_softmax(self.proj(x), dim=-1)\"]},\"69\":{\"h\":\"Encoder 结构\"},\"70\":{\"h\":\"SublayerConnection\",\"t\":[\"SublayerConnection模型结构图\",\"class SublayerConnection(nn.Module): \\\"\\\"\\\" LayerNorm + sublayer(Self-Attenion/Dense) + dropout + 残差连接 为了简单，把LayerNorm放到了前面，这和原始论文稍有不同，原始论文LayerNorm在最后。 \\\"\\\"\\\" def __init__(self, size, dropout): super(SublayerConnection, self).__init__() self.norm = LayerNorm(size) self.dropout = nn.Dropout(dropout) def forward(self, x, sublayer): \\\"sublayer是传入的参数，参考DecoderLayer，它可以当成函数调用，这个函数的有一个输入参数\\\" return x + self.dropout(sublayer(self.norm(x)))\"]},\"71\":{\"h\":\"EncoderLayer\",\"t\":[\"EncoderLayer模型结构图\",\"# 编码器层 = 自注意力子层 + 前馈层 class EncoderLayer(nn.Module): def __init__(self, size, self_attn, feed_forward, dropout): super(EncoderLayer, self).__init__() self.self_attn = self_attn self.feed_forward = feed_forward # 自注意力子层 和 前馈层 各需要一个 self.sublayer = clones(SublayerConnection(size, dropout), 2) self.size = size def forward(self, x, mask): \\\"Follow Figure 1 (left) for connections.\\\" x = self.sublayer[0](x, lambda x: self.self_attn(x, x, x, mask)) return self.sublayer[1](x, self.feed_forward)\"]},\"72\":{\"h\":\"Encoder\",\"t\":[\"Encoder模型结构图\",\"class Encoder(nn.Module): \\\"Core encoder is a stack of N layers\\\" def __init__(self, layer, N): super(Encoder, self).__init__() self.layers = clones(layer, N) self.norm = LayerNorm(layer.size) def forward(self, x, mask): \\\"Pass the input (and mask) through each layer in turn.\\\" for layer in self.layers: x = layer(x, mask) return self.norm(x)\"]},\"73\":{\"h\":\"Decoder 结构\"},\"74\":{\"h\":\"DecoderLayer\",\"t\":[\"Decoder模型结构图\",\"# 解码器层 = 自注意力子层 + 源注意力子层 + 前馈层 class DecoderLayer(nn.Module): \\\"Decoder is made of self-attn, src-attn, and feed forward (defined below)\\\" def __init__(self, size, self_attn, src_attn, feed_forward, dropout): super(DecoderLayer, self).__init__() self.size = size self.self_attn = self_attn self.src_attn = src_attn self.feed_forward = feed_forward # 自注意力子层 + 源注意力子层 + 前馈层 各需要一个 self.sublayer = clones(SublayerConnection(size, dropout), 3) def forward(self, x, memory, src_mask, tgt_mask): \\\"Follow Figure 1 (right) for connections.\\\" m = memory x = self.sublayer[0](x, lambda x: self.self_attn(x, x, x, tgt_mask)) x = self.sublayer[1](x, lambda x: self.src_attn(x, m, m, src_mask)) return self.sublayer[2](x, self.feed_forward)\"]},\"75\":{\"h\":\"Decoder\",\"t\":[\"Decoder模型结构图\",\"# 解码器 = N个解码器层 + 层归一化 class Decoder(nn.Module): \\\"Generic N layer decoder with masking.\\\" def __init__(self, layer, N): super(Decoder, self).__init__() self.layers = clones(layer, N) self.norm = LayerNorm(layer.size) def forward(self, x, memory, src_mask, tgt_mask): # 输入,编码器隐藏层输出,源掩码,目标掩码 for layer in self.layers: x = layer(x, memory, src_mask, tgt_mask) return self.norm(x)\"]},\"76\":{\"h\":\"多头自注意力\",\"t\":[\"多头自注意力计算流程图\",\"class MultiHeadedAttention(nn.Module): def __init__(self, h, d_model, dropout=0.1): \\\"Take in model size and number of heads.\\\" super(MultiHeadedAttention, self).__init__() assert d_model % h == 0 # We assume d_v always equals d_k self.d_k = d_model // h # 每个头64维 self.h = h # 8个头 self.linears = clones(nn.Linear(d_model, d_model), 4) # W_q,W_k,W_v,W_projection self.attn = None self.dropout = nn.Dropout(p=dropout) def forward(self, query, key, value, mask=None): \\\"Implements Figure 2\\\" if mask is not None: # Same mask applied to all h heads. mask = mask.unsqueeze(1) nbatches = query.size(0) # 1) Do all the linear projections in batch from d_model => h x d_k query, key, value = [ lin(x).view(nbatches, -1, self.h, self.d_k).transpose(1, 2) # (batches,heads,seq_len,d_k) for lin, x in zip(self.linears, (query, key, value)) ] # 2) Apply attention on all the projected vectors in batch. x, self.attn = attention( query, key, value, mask=mask, dropout=self.dropout ) # 3) \\\"Concat\\\" using a view and apply a final linear. x = ( x.transpose(1, 2) .contiguous() .view(nbatches, -1, self.h * self.d_k) ) del query del key del value return self.linears[-1](x)\",\"def attention(query, key, value, mask=None, dropout=None): \\\"Compute 'Scaled Dot Product Attention'\\\" d_k = query.size(-1) scores = torch.matmul(query, key.transpose(-2, -1)) / math.sqrt(d_k) if mask is not None: scores = scores.masked_fill(mask == 0, -1e9) # 广播: (1,1,1,10) ---> (1,8,10,10) p_attn = scores.softmax(dim=-1) if dropout is not None: p_attn = dropout(p_attn) return torch.matmul(p_attn, value), p_attn\"]},\"77\":{\"h\":\"多模态\"},\"78\":{\"h\":\"庖丁解牛CLIP\",\"t\":[\"多模态模型CLIP原理与图片分类，文字搜索图像实战演练\",\"CLIP原始论文链接\"]},\"79\":{\"h\":\"引言\",\"t\":[\"2021 年可谓是视觉 Transformer（Vision Transformer）大放异彩的一年。自谷歌提出 ViT 之后，众多基于视觉 Transformer 的研究如潮水般涌来，广泛应用于各类计算机视觉任务。与此同时，OpenAI 在 2021 年 1 月发布的 DALL-E 和 CLIP，同样给计算机视觉领域带来了巨大影响。这两个模型都属于融合图像与文本的多模态模型，其中 DALL-E 是基于文本输入来生成图像的模型，而 CLIP 则是以文本作为监督信号，训练出具有可迁移能力的视觉模型。和 ViT 类似，DALL-E 和 CLIP 的出现也掀起了新一轮的研究热潮。\"]},\"80\":{\"h\":\"介绍\",\"t\":[\"CLIP的英文全称为Contrastive Language-Image Pre-training，它代表着一种基于对比文本-图像对的预训练方法，同时也指运用该方法构建的模型。CLIP属于基于对比学习的多模态模型。与计算机视觉（CV）领域中的一些对比学习方法，像MoCo和SimCLR有所不同，CLIP的训练数据采用的是文本-图像对，也就是一张图像搭配与之对应的文本描述。在训练过程中，借助对比学习机制，期望模型能够学习到文本和图像之间的匹配关系。\"]},\"81\":{\"h\":\"训练\",\"t\":[\"CLIP包含两个核心模型，分别是文本编码器（Text Encoder）和图像编码器（Image Encoder）。其中，文本编码器的作用是提取文本的特征，在实现时可采用自然语言处理（NLP）领域常用的文本Transformer模型；而图像编码器则用于提取图像的特征，在实际应用中可以选用常见的卷积神经网络（CNN）模型，也可以采用视觉Transformer模型。\",\"这里对提取的文本特征和图像特征进行对比学习。对于一个包含个文本-图像对的训练batch，将个文本特征和个图像特征两两组合，CLIP模型会预测出个可能的文本-图像对的相似度，这里的相似度直接计算文本特征和图像特征的余弦相似性（cosine similarity），即上图所示的矩阵。这里共有个正样本，即真正属于一对的文本和图像（矩阵中的对角线元素），而剩余的个文本-图像对为负样本，那么CLIP的训练目标就是最大个正样本的相似度，同时最小化个负样本的相似度，对应的伪代码实现如下所示：\",\"# image_encoder - ResNet or Vision Transformer # text_encoder - CBOW or Text Transformer # I[n, h, w, c] - minibatch of aligned images # T[n, l] - minibatch of aligned texts # W_i[d_i, d_e] - learned proj of image to embed # W_t[d_t, d_e] - learned proj of text to embed # t - learned temperature parameter # 分别提取图像特征和文本特征 I_f = image_encoder(I) #[n, d_i] T_f = text_encoder(T) #[n, d_t] # 对两个特征进行线性投射，得到相同维度的特征，并进行l2归一化 I_e = l2_normalize(np.dot(I_f, W_i), axis=1) T_e = l2_normalize(np.dot(T_f, W_t), axis=1) # 计算缩放的余弦相似度：[n, n] logits = np.dot(I_e, T_e.T) * np.exp(t) # 对称的对比学习损失：等价于N个类别的cross_entropy_loss labels = np.arange(n) # 对角线元素的labels loss_i = cross_entropy_loss(logits, labels, axis=0) loss_t = cross_entropy_loss(logits, labels, axis=1) loss = (loss_i + loss_t)/2\",\"为了训练CLIP模型，OpenAI从网络上收集了总计4亿对文本和图像，这些数据在论文中被称为WebImageText。若以文本单词数量来衡量，其规模与GPT-2训练时使用的WebText数据集相似。然而，从数据对的数量来看，它比谷歌的JFT-300M数据集还要多出1亿对，因此这是一个非常庞大的数据集。\",\"尽管CLIP是一个多模态模型，但其主要目的是训练可迁移的视觉模型。在论文中，文本编码器（Text Encoder）选择了一个包含6300万参数的Transformer模型，而图像编码器（Image Encoder）则采用了两种不同的架构：\",\"一种是常用的CNN架构ResNet。\",\"另一种是基于 Transformer 的ViT。\",\"ResNet包含五种不同尺寸的模型：ResNet50、ResNet101、RN50x4、RN50x16和RNx64（后三种模型是按照EfficientNet的缩放规则对ResNet分别放大4倍、16倍和64倍得到的），而ViT则选择了三种不同尺寸的模型：ViT-B/32、ViT-B/16和ViT-L/14。\",\"所有模型均训练了32个周期，使用AdamW优化器，并且在训练过程中采用了一个相对较大的批次大小：32768。由于数据量巨大，最大的ResNet模型RN50x64需要在592个V100 GPU上训练18天，而最大的ViT模型ViT-L/14则需要在256个V100 GPU上训练12天，这表明训练CLIP模型需要消耗大量的资源。对于ViT-L/14模型，还在336的分辨率下额外进行了一个周期的微调（finetune）以增强性能，论文发现这个模型的效果最佳，并将其标记为ViT-L/14@336，论文中进行对比实验的CLIP模型也采用了这一配置。\"]},\"82\":{\"h\":\"推理\",\"t\":[\"我们已经探讨了CLIP模型的运作机制，它由两个部分组成：一个视觉模型和一个文本模型。那么，如何将这个预训练的视觉模型应用到新的任务中呢？CLIP模型的一个显著优势是它能够进行zero-shot图像分类，这意味着它能够在没有任何特定任务训练数据的情况下，直接对图像进行分类。这不仅展示了CLIP的强大功能，也是其一大亮点。实现zero-shot分类的过程相当直接，可以概括为以下两个主要步骤：\",\"构建描述文本并提取特征：首先，根据任务的分类需求，为每个类别创建一个描述性的文本，例如“A photo of {label}”。这些文本随后被输入到文本编码器（Text Encoder）中，以生成相应的文本特征。如果有个类别，那么就会得到个文本特征。\",\"图像特征提取与分类：接下来，将待分类的图像输入到图像编码器（Image Encoder）中，以获取图像特征。然后，这些图像特征会与之前得到的个文本特征进行余弦相似度计算（这一过程与训练时相同）。最终，选择与图像特征相似度最高的文本所对应的类别，作为图像的分类预测结果。此外，这些相似度值可以被视为logits，通过softmax函数转换后，可以得到每个类别的预测概率。\",\"通过这种方式，CLIP模型能够在没有特定任务训练数据的情况下，直接对图像进行分类，这展示了其在图像分类任务中的灵活性和强大能力。\",\" 显然，我们通过利用CLIP模型的多模态能力，为特定任务动态构建了一个分类器。在这个过程中，文本编码器（Text Encoder）生成的文本特征相当于分类器的权重，而图像编码器（Image Encoder）提取的图像特征则是分类器的输入数据。以下是一个官方给出的CLIP模型的示例 ，该示例中的任务涉及8个类别:\",\"我们首先创建了各类别的文本描述，然后提取了相应的文本特征；\",\"然后我们读取要预测的图像，输入Image Encoder提取图像特征，并计算与文本特征的余弦相似度。\",\"# 1. 提取文本特征 texts = [ \\\"a page of text about segmentation\\\", \\\"a facial photo of a tabby cat\\\", \\\"a portrait of an astronaut with the American flag\\\", \\\"a rocket standing on a launchpad\\\", \\\"a red motorcycle standing in a garage\\\", \\\"a person looking at a camera on a tripod\\\", \\\"a black-and-white silhouette of a horse\\\", \\\"a cup of coffee on a saucer\\\" ] text_tokens = clip.tokenize([\\\"This is \\\" + desc for desc in texts]).cuda() with torch.no_grad(): text_features = model.encode_text(text_tokens).float() # 2. 提取图像特征 image_input = torch.tensor(np.stack(images)).cuda() with torch.no_grad(): image_features = model.encode_image(image_input).float() # 3. 计算余弦相似度 image_features /= image_features.norm(dim=-1, keepdim=True) text_features /= text_features.norm(dim=-1, keepdim=True) similarity = text_features.cpu().numpy() @ image_features.cpu().numpy().T\",\"相似度如下所示，可以看到对于要预测的8个图像，按照最大相似度，其均能匹配到正确的文本标签：\",\"进一步地，我们也可以对得到的余弦相似度计算softmax，得到每个预测类别的概率值：\",\"text_probs = (100.0 * image_features @ text_features.T).softmax(dim=-1) top_probs, top_labels = text_probs.cpu().topk(5, dim=-1)\",\"得到的预测概率如下所示，可以看到8个图像，CLIP模型均能够以较高的置信度给出正确的分类结果：\"]},\"83\":{\"h\":\"文本描述生成\",\"t\":[\"在使用CLIP模型进行zero-shot分类时，除了模型本身的应用，文本描述的生成也是一个关键环节。在之前的例子中，我们使用了“A photo of {label}”这样的格式来生成文本描述，但实际上，我们还有其他的选择。例如，我们可以直接使用类别标签作为文本描述。这种方法实际上与NLP领域的一个研究方向——prompt learning或prompt engineering——紧密相关。关于这一领域的详细综述，可以参考论文《Pre-train, Prompt, and Predict: A Systematic Survey of Prompting Methods in Natural Language Processing》。\",\"简单来说，prompt learning的核心思想是通过设计合适的prompt（提示），使得预训练模型能够直接应用于下游任务。这与传统的预训练加微调的方法有所不同。论文指出，如果我们直接使用类别标签作为文本描述，由于这些文本往往只是一个单词，缺乏具体的上下文，并且与CLIP模型的训练数据不完全一致，因此在效果上可能不如使用“A photo of {label}”这种格式（在ImageNet数据集上可以提升1.3%的效果）。\",\"此外，论文还实验了使用80个不同的prompt进行集成，结果发现在ImageNet数据集上能够带来3.5%的性能提升。具体的实验结果可以参考CLIP公开的notebook。\"]},\"84\":{\"h\":\"花卉图片分类\",\"t\":[\"本节我们将基于CLIP预训练模型实现Zero-Shot推理，训练使用到的数据集和AlexNet保持一致，因此这里就不再给出数据集下载链接了。\",\"图片分类实战 – 分别基于LeNet，AlexNet，VGG进行实现\",\"# 预训练模型名称 model_name = \\\"openai/clip-vit-large-patch14\\\" # 定义当前目录 current_dir = os.getcwd() model_dir = os.path.join(current_dir, model_name.replace(\\\"/\\\", \\\"_\\\")) # 检查当前目录是否有预训练权重文件，如果没有则下载 def download_pretrained_weights_if_needed(model_name, save_dir): if not os.path.exists(save_dir): try: print(f\\\"Downloading {model_name} to {save_dir}...\\\") snapshot_download(repo_id=model_name, local_dir=save_dir, local_dir_use_symlinks=False) print(f\\\"{model_name} downloaded successfully.\\\") except Exception as e: print(f\\\"Error downloading {model_name}: {e}\\\") download_pretrained_weights_if_needed(model_name, model_dir) # 加载模型和处理器 model = CLIPModel.from_pretrained(model_dir) processor = CLIPProcessor.from_pretrained(model_dir) device = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\") model = model.to(device)\",\"在 openai/clip-vit-large-patch14 这个 CLIP 预训练模型中，图像编码器采用了 Vision Transformer（ViT）架构，具体使用的是 ViT-L/14 版本，文本编码器使用的是基于 Transformer 的架构。\",\"# 函数：生成文本嵌入 def text_embedding(texts): inputs = processor(text=texts, return_tensors=\\\"pt\\\", padding=True).to(device) with torch.no_grad(): embeddings = model.get_text_features(**inputs) return embeddings.cpu().numpy()\",\"这个函数的作用是将输入的文本转化为对应的嵌入表示（embedding）。它通过处理器对输入文本进行处理，使其符合模型的输入要求，然后利用模型获取文本特征，最后将结果转换为 numpy 数组格式返回，方便后续的计算和比较。\",\"def get_image_embeddings(image_paths): images = [] for image_path in image_paths: try: image = Image.open(image_path).convert(\\\"RGB\\\") images.append(image) except Exception as e: print(f\\\"Error loading image {e}\\\") if not images: return None inputs = processor(images=images, return_tensors=\\\"pt\\\").to(device) with torch.no_grad(): image_features = model.get_image_features(**inputs) return image_features.cpu().numpy()\",\"该函数作用是针对给定的图片路径，读取图片并将其转换为合适的格式后，通过模型获取图片的特征嵌入。如果在读取图片过程中出现错误，会进行相应的错误提示并返回 None。\",\"def cosine_similarity(vec1, vec2): vec1 = np.array(vec1) vec2 = np.array(vec2) return np.dot(vec1, vec2.T) / (np.linalg.norm(vec1, axis=1, keepdims=True) * np.linalg.norm(vec2, axis=1))\",\"在图文检索中，我们常常需要衡量文本嵌入和图片嵌入之间的相似度，这里采用了余弦相似度的计算方法。它将输入的向量转换为 numpy 数组后，按照余弦相似度的数学公式来计算两者的相似度数值。\",\"首先，我们需要根据上面给出的花卉数据集下载链接，将数据下载到当前项目目录下:\",\"其次，我们从flower_photos目录下读取出所有图片的路径:\",\"# 递归遍历目录获取所有图片路径 def get_all_image_paths(directory): image_paths = [] for root, _, files in os.walk(directory): for file in files: file_extension = os.path.splitext(file)[1].lower() if file_extension in ['.png', '.jpg', '.jpeg']: image_paths.append(os.path.join(root, file)) return image_paths image_paths = get_all_image_paths(\\\"./flower_photos\\\")\",\"同时将flower_photos下的子目录名作为我们的候选待匹配分类文本列表，并改造为a photo of 子目录名的格式，然后计算每个分类文本对应的文本嵌入向量:\",\"# 获取候选分类名列表 def get_candidates(directory): candidates = [] for sub_dir in os.listdir(directory): sub_dir_path = os.path.join(directory, sub_dir) if os.path.isdir(sub_dir_path): candidates.append(f\\\"a photo of {sub_dir}\\\") return candidates candidates = get_candidates(\\\"./flower_photos\\\") text_embeddings = text_embedding(candidates)\",\"最后:\",\"分批次从图像列表中取出一批图像，获取其对应的图像嵌入向量列表\",\"计算这批图像嵌入向量中每一个图像嵌入向量和我们所有分类文本嵌入向量的余弦相似度\",\"针对每个图像嵌入向量取出和其相似度最高的那个文本嵌入向量的索引\",\"判断预测是否正确，统计正确率\",\"# 测试图片分类正确率 def accuracy(image_paths, candidates, text_embeddings, batch_size=64): correct_count = 0 total_count = len(image_paths) num_batches = (total_count + batch_size - 1) // batch_size # 分批次预测 for i in range(num_batches): start_idx = i * batch_size end_idx = min(start_idx + batch_size, total_count) # 取出当前批次的图像列表，并获得该批次图像列表对应的图像嵌入向量列表 batch_image_paths = image_paths[start_idx:end_idx] image_embeddings = get_image_embeddings(batch_image_paths) if image_embeddings is not None: # 计算图像嵌入向量列表中每个图像对应的嵌入向量和传入的分类文本嵌入向量的余弦相似度 similarities = cosine_similarity(image_embeddings, text_embeddings) # 针对每个图像嵌入向量获取和其相似度最高的分类文本嵌入向量索引下标 predicted_indices = np.argmax(similarities, axis=1) for j, predicted_index in enumerate(predicted_indices): # 针对每张图像，根据上述计算得到的和其相似度最高的分类文本索引，从候选分类文本集合中取出其分类名词 predicted_category = candidates[predicted_index].split(\\\" \\\")[-1] # 用当前图片外层目录的名字作为其分类名词 actual_category = os.path.basename(os.path.dirname(batch_image_paths[j])) # 比较两个分类名词是否相等 if predicted_category == actual_category: correct_count += 1 accuracy = correct_count / total_count return accuracy # 图片分类 def flowerClassify(): image_paths = get_all_image_paths(\\\"./flower_photos\\\") candidates = get_candidates(\\\"./flower_photos\\\") text_embeddings = text_embedding(candidates) start_time = time.time() acc = accuracy(image_paths, candidates, text_embeddings, batch_size=64) end_time = time.time() print(f\\\"Time taken to test accuracy: {end_time - start_time:.2f} seconds\\\") print(f\\\"Accuracy: {acc * 100:.2f}%\\\")\",\"Time taken to test accuracy: 396.62 seconds Accuracy: 95.48%\"]},\"85\":{\"h\":\"文字搜索图像\",\"t\":[\"上面的花卉分类案例相当于使用图像去匹配最合适的文本描述，而这里我们将会反转这个逻辑，用文本描述去匹配最合适的图片内容。\",\"为了实现文字搜索图像的功能，我们只需要在计算出相似度得分矩阵后，以每个文本描述为一行，取出该行中得分最大的那一列，即为与当前文本描述相似度最高的那副图片，具体代码实现如下：\",\"# 找到与文本最匹配的图片 def find_most_matching_image(text, image_paths): text_emb = text_embedding([text]) image_embeddings = get_image_embeddings(image_paths) if image_embeddings is None: return None similarities = cosine_similarity(text_emb, image_embeddings) most_matching_index = np.argmax(similarities) return image_paths[most_matching_index]\",\"下面来实际展示一下效果，首先我们用data目录充当我们的图片库来源:\",\" 遍历data目录，拿到所有图片路径:\",\"# 遍历 data 目录获取所有图片路径 def get_images_from_data_dir(): data_dir = os.path.join(current_dir, 'data') if not os.path.exists(data_dir): print(f\\\"Data directory {data_dir} does not exist.\\\") return [] return get_all_image_paths(data_dir)\",\"这里以搜索向日葵花为例，我们首先获取图片库中所有图片，然后计算出和当前文本描述相似度最高的那副图片，并将图片展示出来:\",\"# 根据文字搜索图片 def searchPicByText(): image_paths = get_images_from_data_dir() query_text = \\\"a photo of a sunflowers\\\" most_matching_image = find_most_matching_image(query_text, image_paths) if most_matching_image: print(f\\\"The most matching image for '{query_text}' is: {most_matching_image}\\\") try: img = Image.open(most_matching_image) plt.imshow(img) plt.axis('off') plt.title(f\\\"Most matching image for '{query_text}'\\\") plt.show() except Exception as e: print(f\\\"Error opening image: {e}\\\") else: print(\\\"No matching image found.\\\")\",\"图片库中的图片： 运行上述代码，搜索出来的图片:\"]},\"86\":{\"h\":\"完整代码\",\"t\":[\"import time from matplotlib import pyplot as plt from transformers import CLIPProcessor, CLIPModel import torch from PIL import Image import numpy as np import warnings import os from huggingface_hub import snapshot_download warnings.filterwarnings(\\\"ignore\\\") # 模型名称 model_name = \\\"openai/clip-vit-large-patch14\\\" # 定义当前目录 current_dir = os.getcwd() model_dir = os.path.join(current_dir, model_name.replace(\\\"/\\\", \\\"_\\\")) # 检查当前目录是否有预训练权重文件，如果没有则下载 def download_pretrained_weights_if_needed(model_name, save_dir): if not os.path.exists(save_dir): try: print(f\\\"Downloading {model_name} to {save_dir}...\\\") snapshot_download(repo_id=model_name, local_dir=save_dir, local_dir_use_symlinks=False) print(f\\\"{model_name} downloaded successfully.\\\") except Exception as e: print(f\\\"Error downloading {model_name}: {e}\\\") download_pretrained_weights_if_needed(model_name, model_dir) # 加载模型和处理器 model = CLIPModel.from_pretrained(model_dir) processor = CLIPProcessor.from_pretrained(model_dir) device = torch.device(\\\"cuda\\\" if torch.cuda.is_available() else \\\"cpu\\\") model = model.to(device) # 函数：生成文本嵌入 def text_embedding(texts): inputs = processor(text=texts, return_tensors=\\\"pt\\\", padding=True).to(device) with torch.no_grad(): embeddings = model.get_text_features(**inputs) return embeddings.cpu().numpy() def get_image_embeddings(image_paths): images = [] for image_path in image_paths: try: image = Image.open(image_path).convert(\\\"RGB\\\") images.append(image) except Exception as e: print(f\\\"Error loading image {e}\\\") if not images: return None inputs = processor(images=images, return_tensors=\\\"pt\\\").to(device) with torch.no_grad(): image_features = model.get_image_features(**inputs) return image_features.cpu().numpy() def cosine_similarity(vec1, vec2): vec1 = np.array(vec1) vec2 = np.array(vec2) return np.dot(vec1, vec2.T) / (np.linalg.norm(vec1, axis=1, keepdims=True) * np.linalg.norm(vec2, axis=1)) # 递归遍历目录获取所有图片路径 def get_all_image_paths(directory): image_paths = [] for root, _, files in os.walk(directory): for file in files: file_extension = os.path.splitext(file)[1].lower() if file_extension in ['.png', '.jpg', '.jpeg']: image_paths.append(os.path.join(root, file)) return image_paths # 获取候选分类名列表 def get_candidates(directory): candidates = [] for sub_dir in os.listdir(directory): sub_dir_path = os.path.join(directory, sub_dir) if os.path.isdir(sub_dir_path): candidates.append(f\\\"a photo of {sub_dir}\\\") return candidates # 测试图片分类正确率 def accuracy(image_paths, candidates, text_embeddings, batch_size=64): correct_count = 0 total_count = len(image_paths) num_batches = (total_count + batch_size - 1) // batch_size for i in range(num_batches): start_idx = i * batch_size end_idx = min(start_idx + batch_size, total_count) batch_image_paths = image_paths[start_idx:end_idx] image_embeddings = get_image_embeddings(batch_image_paths) if image_embeddings is not None: similarities = cosine_similarity(image_embeddings, text_embeddings) predicted_indices = np.argmax(similarities, axis=1) for j, predicted_index in enumerate(predicted_indices): predicted_category = candidates[predicted_index].split(\\\" \\\")[-1] actual_category = os.path.basename(os.path.dirname(batch_image_paths[j])) if predicted_category == actual_category: correct_count += 1 accuracy = correct_count / total_count return accuracy # 图片分类 def flowerClassify(): image_paths = get_all_image_paths(\\\"./flower_photos\\\") candidates = get_candidates(\\\"./flower_photos\\\") text_embeddings = text_embedding(candidates) start_time = time.time() acc = accuracy(image_paths, candidates, text_embeddings, batch_size=64) end_time = time.time() print(f\\\"Time taken to test accuracy: {end_time - start_time:.2f} seconds\\\") print(f\\\"Accuracy: {acc * 100:.2f}%\\\") ##################################################################################################3 # 遍历 data 目录获取所有图片路径 def get_images_from_data_dir(): data_dir = os.path.join(current_dir, 'data') if not os.path.exists(data_dir): print(f\\\"Data directory {data_dir} does not exist.\\\") return [] return get_all_image_paths(data_dir) # 找到与文本最匹配的图片 def find_most_matching_image(text, image_paths): text_emb = text_embedding([text]) image_embeddings = get_image_embeddings(image_paths) if image_embeddings is None: return None similarities = cosine_similarity(text_emb, image_embeddings) most_matching_index = np.argmax(similarities) return image_paths[most_matching_index] # 根据文字搜索图片 def searchPicByText(): image_paths = get_images_from_data_dir() query_text = \\\"a photo of a sunflowers\\\" most_matching_image = find_most_matching_image(query_text, image_paths) if most_matching_image: print(f\\\"The most matching image for '{query_text}' is: {most_matching_image}\\\") try: img = Image.open(most_matching_image) plt.imshow(img) plt.axis('off') plt.title(f\\\"Most matching image for '{query_text}'\\\") plt.show() except Exception as e: print(f\\\"Error opening image: {e}\\\") else: print(\\\"No matching image found.\\\")\"]},\"87\":{\"h\":\"小结\",\"t\":[\"在计算机视觉领域，常见的迁移学习方法是首先在大规模数据集（如ImageNet）上进行预训练，然后在具体的下游任务上进行微调。这种预训练通常是基于有监督学习的，需要大量的数据标注，因此成本较高。近年来，出现了一些基于自监督的方法，包括基于对比学习的方法（如MoCo和SimCLR）和基于图像掩码的方法（如MAE和BeiT）。自监督方法的优势在于不再需要标注数据。然而，无论是有监督还是自监督方法，在迁移到下游任务时，都需要进行有监督微调，无法实现zero-shot学习。对于有监督模型，由于它们在预训练数据集上采用固定类别数的分类器，因此在新的数据集上需要定义新的分类器来重新训练。对于自监督模型，代理任务通常是辅助进行表征学习，在迁移到其他数据集时也需要加上新的分类器进行有监督训练。\",\"然而，在NLP领域，基于自回归或语言掩码的预训练方法已经相对成熟，预训练模型很容易直接zero-shot迁移到下游任务，例如OpenAI的GPT-3。这种差异一方面是由于文本和图像属于两个完全不同的模态，另一个原因是NLP模型可以利用从互联网上收集的大量文本。因此，问题来了：能否基于互联网上的大量文本来预训练视觉模型？\",\"实际上，之前已经有一些研究工作探讨了使用文本作为监督信号来训练视觉模型。例如，2016年的工作《Learning Visual Features from Large Weakly Supervised Data》将这个问题转化为一个多标签分类任务，预测图像对应的文本的词袋模型；2017年的工作《Learning Visual N-Grams from Web Data》进一步扩展了这个方法来预测n-grams。最近的一些工作采用新的模型架构和预训练方法来从文本学习视觉特征，例如VirTex基于transformer的语言模型，ICMLM基于语言掩码的方法，ConVIRT基于对比学习的方法。总体来看，这方面的工作并不多，主要是因为这些方法难以实现较高的性能，例如2017年的那篇工作只在ImageNet上实现了11.5%的zero-shot性能，这远远低于ImageNet上的SOTA。此外，还有另一个方向，即基于文本弱监督来提升性能，例如谷歌的BiT和ViT基于JFT-300M数据集来预训练模型在ImageNet上取得SOTA。JFT-300M数据集是谷歌从互联网上收集的，通过一些自动化的手段将web text转化为18291个类别，但存在一定的噪声。尽管谷歌基于JFT-300M数据集取得了较好的结果，但这些模型仍然采用固定类别的softmax分类器进行预训练，这大大限制了它们的迁移能力和扩展性。\",\"谷歌采用的弱监督方法与以往方法的一个主要区别在于规模，或者说在于计算能力和数据集的规模。JFT-300M数据集的规模达到了上亿级别，谷歌利用强大的计算能力进行了预训练。相比之下，VirTex、ICMLM和ConVIRT仅在10万级别的数据上训练了几天。为了弥补数据规模上的差距，OpenAI从网络上收集了4亿条数据进行实验。然而，新的问题出现了：应该采用什么样的方法来进行训练。\",\"OpenAI首先尝试了VirTex模型，该模型联合训练一个CNN和文本transformer来预测图像的文本描述（image caption），但发现这种方法的训练效率（根据ImageNet数据集上的zero-shot性能评估）还不如直接预测词袋模型（bag of words），两者的训练效率相差3倍。如果进一步采用ConVIRT，即基于对比学习的方法，训练效率可以提高4倍。出现这种差异的原因不难理解，因为训练数据集中的文本-图像对是从互联网收集的，存在一定的噪声，即文本和图像可能不完全匹配。在这种情况下，适当降低训练目标反而可能取得更好的效果。\",\"从任务难度来看，排序为：Transformer Language Model > Bag of Words Prediction > Bag of Words Contrastive (CLIP)。由于训练数据量和模型计算量较大，训练效率成为一个至关重要的因素。因此，作者最终选择了对比学习方法来进行训练。\"]},\"88\":{\"h\":\"庖丁解牛BLIP2\",\"t\":[\"庖丁解牛BLIP2\",\"论文: https://arxiv.org/abs/2301.12597 代码: https://github.com/salesforce/LAVIS/tree/main/projects/blip2\"]},\"89\":{\"h\":\"背景\",\"t\":[\"多模态模型在过往发展的过程中，曾有一段时期一直在追求更大的网络架构（image encoder 和 text encoder/decoder）和 数据集，从而导致更大的训练代价。例如CLIP，400M数据，需要数百个GPU训练数十天，如何降低模型训练成本，同时具有很好的性能？\",\"这就是BLIP-2的起因，回顾下之前的多模态网络设计，三个模块（图像分支、文本分支、融合模块）:\",\"多模态网络设计\",\"(a) 早期的图文多模态：图像分支依赖目标检测器，模态融合比较弱，如VSE++。\",\"(b) 重点训练图像和文本特征提取，模态融合比较轻量，如CLIP。\",\"(c) 图像特征提取和模态融合都很重。\",\"(d) 侧重模态融合，特征提取网络相对轻量，如ViLT。\",\"模块\",\"(a)\",\"(b)\",\"(c)\",\"(d)\",\"理想情况\",\"视觉分支\",\"重\",\"重\",\"重\",\"轻\",\"重\",\"文本分支\",\"轻\",\"重\",\"轻\",\"轻\",\"重\",\"融合模块\",\"轻\",\"轻\",\"重\",\"重\",\"轻\",\"性能\",\"一般\",\"好\",\"好\",\"一般\",\"好\",\"训练代价\",\"中\",\"非常高\",\"非常高\",\"高\",\"中\",\"BLIP-2 基于 BLIP 架构，利用已有的ViT 和 LLM（均冻结）+ 一个的轻量Q-Former模块做模态融合，大幅降低训练成本。具有很强的zero-shot image-to-text generation能力，同时因LLM而具有了视觉推理能力。\"]},\"90\":{\"h\":\"模型结构\",\"t\":[\"BLIP-2 框架按照 Two-Stage 策略预训练轻量级查询 Transformer 以弥合模态差距。\",\"Stage 1: 不同模态数据的提取与融合。\",\"Stage 2: 把数据转换成LLM能识别的格式。\",\"Two-Stage流程\",\"从冻结的Image Encoder引到Vision-Language表征学习。\",\"从冻结的LLM引到Vision-Language生成学习，实现Zero Shot图文生成。\"]},\"91\":{\"h\":\"Stage 1: Representation Learning （表征学习）\",\"t\":[\"tage 1: Representation Learning （表征学习）\",\"Q-Former 由两个transformer模块组成，输入包含三部分：\",\"冻结参数的Image Encoder提取的图像embeddings\",\"Learned Queries\",\"Queries是一组可学习的embeddings，是第一个transformer模块的input，可认为是模型参数一部分\",\"推理时，Queries被用来从image encoder输出的embeddings里提取与input text最相关的视觉信息\",\"Input Text\",\"Stage 1 使用 图像-文本对 进行预训练，目标是训练好 Q-Former，以便 Queries 可以学习到如何更好地结合文本提取图片信息。\",\"对于Q-Former，一种比较好理解的方式：把Q-Former类比为一个Self-attention模块\",\"Q：learned queries\",\"K：input text\",\"V：image embeddings from Image Encoder\",\"Blip2Qformer核心代码实现如下:\",\"利用 query tokens 从 image embeddings 中提取与 text 最相关的视觉信息\",\"将输入的 input text 进行编码 , 然后使用第一个CLS Token 作为 input text representation\",\"class Blip2Qformer(Blip2Base): ... def forward(self, samples): image = samples[\\\"image\\\"] # (B,C,H,W) text = samples[\\\"text_input\\\"] # (B,seq_len) # frozen vit 将图片编码成 (B, seq_len, hidden_size) image_embeds = self.ln_vision(self.visual_encoder(image)) # 构建padding mask标注哪些image token是有效的 (B,seq_len) image_atts = torch.ones(image_embeds.size()[:-1], dtype=torch.long).to( image.device ) # 初始化query tokens (B,seq_len,hidden_size) query_tokens = self.query_tokens.expand(image_embeds.shape[0], -1, -1) # query tokens 从 image embeddings 中提取与 text 最相关的视觉信息 # query_output (B,seq_len,hidden_size) query_output = self.Qformer.bert( query_embeds=query_tokens, encoder_hidden_states=image_embeds, encoder_attention_mask=image_atts, use_cache=True, return_dict=True, ) image_feats = F.normalize( self.vision_proj(query_output.last_hidden_state), dim=-1 ) # 将input text 进行编码，维度为 (B,seq_len,hidden_size) text_tokens = self.tokenizer( text, padding=\\\"max_length\\\", truncation=True, max_length=self.max_txt_len, return_tensors=\\\"pt\\\", ).to(image.device) text_output = self.Qformer.bert( text_tokens.input_ids, attention_mask=text_tokens.attention_mask, # padding mask return_dict=True, ) # 取第一个cls token作为input text representation，维度为 (B,hidden_size) text_feat = F.normalize( self.text_proj(text_output.last_hidden_state[:, 0, :]), dim=-1 ) ...\",\"以上代码注释中统一用B代替image_batch和text_batch，以及seq_len和hidden_size也是同样处理手段，大家注意区分。\",\"为了训练好Q-Former，第一阶段设计了三个训练目标，分别如下:\"]},\"92\":{\"h\":\"1、Image-Text Contrastive Learning (ITC Loss, CLIP-like)\",\"t\":[\"目的: Image representation 与 Text representation，以最大化互信息\",\"自注意力掩码策略: Uni-modal Self-attention Mask（单模态自注意力）\",\"Queries 和 Text 仅能和自己的 tokens 做 attention（Query和Query、Text和Text）\",\"Uni-modal Self-attention Mask\",\"image_feats 中每个 image_feat 与 text_feat 计算一个 similarity score ，选择最大值作为这个图文对的相似度 :\",\"similarity score\",\"如何计算loss的: “in-batch negatives”，该方法正是CLIP在VLP领域发扬光大的。以下引用CLIP论文图做说明：\",\"in-batch negatives\",\"###============== Image-text Contrastive ===================### # 计算每个query token 和 text_feat 的相似度 , 得到相似度矩阵 (B,B,seq_len) # image_feats (B,seq_len,hidden_size) 变为 (B,1,seq_len,hidden_size) # text_feat (B,hidden_size) 变为 (B,hidden_size,1) sim_q2t = torch.matmul( image_feats.unsqueeze(1), text_feat.unsqueeze(-1) ).squeeze() # image-text similarity: aggregate across all query tokens # 保留和text_feat相似度最大的那个query token作为最后的相似度得分 , 维度为 (B,B) sim_i2t, _ = sim_q2t.max(-1) sim_i2t = sim_i2t / self.temp # 反过来计算text_feat 和 每个query token的相似度 , 得到相似度矩阵 (B,B,seq_len) # image_feats 维度变为 (B,hidden_size,seq_len) # text_feat (B,hidden_size) 变为 (B,1,1,hidden_size) sim_t2q = torch.matmul( text_feat.unsqueeze(1).unsqueeze(1), image_feats.permute(0, 2, 1) ).squeeze() # text-image similarity: aggregate across all query tokens # 保留和text_feat相似度最大的那个query token作为最后的相似度得分 , 维度为 (B,B) sim_t2i, _ = sim_t2q.max(-1) sim_t2i = sim_t2i / self.temp # 生成比标签 targets = torch.arange(image.size(0), device=image.device) # 计算 图文对比 Loss loss_itc = ( # sim_i2t 形状是 (B, B)，每一行表示一张图像和所有文本之间的相似度。 F.cross_entropy(sim_i2t, targets, label_smoothing=0.1) + F.cross_entropy(sim_t2i, targets, label_smoothing=0.1) ) / 2\"]},\"93\":{\"h\":\"2、Image-Text Matching (ITM Loss，二分类task)\",\"t\":[\"目的：通过学习image-text pair是否match，以细粒度对齐 Image representation 与 Text representation\",\"自注意力掩码策略: Bi-directional Self-attention Mask（双向自注意力）\",\"Queries 和Text都能和所有的tokens 做attention\",\"Bi-directional Self-attention Mask\",\"每个output query embedding送到二分类器中，得到一个logit；所有logits的平均作为最终的matching score:\",\"matching score\",\" ###============== Image-text Matching ===================### text_input_ids_world = text_tokens.input_ids text_attention_mask_world = text_tokens.attention_mask image_embeds_world = image_embeds with torch.no_grad(): # bs (batch size) ， diag_indices = [0,1,2,...,bs-1] diag_indices = torch.arange(bs, device=sim_t2i.device) # 把相似度矩阵对角线元素置为负无穷大，以避免模型将匹配图文对挑选为负样本 # (0,0) , (1,1) ... (bs-1,bs-1) 位置处设置为 -10000 sim_t2i[diag_indices, diag_indices] = -10000 sim_i2t[diag_indices, diag_indices] = -10000 weights_t2i = F.softmax(sim_t2i, dim=1) weights_i2t = F.softmax(sim_i2t, dim=1) # 为每个文本选择一个负样本图像 image_embeds_neg = [] for b in range(bs): neg_idx = torch.multinomial(weights_t2i[b], 1).item() image_embeds_neg.append(image_embeds_world[neg_idx]) image_embeds_neg = torch.stack(image_embeds_neg, dim=0) # 为每个图像选择一个负样本文本 text_ids_neg = [] text_atts_neg = [] for b in range(bs): neg_idx = torch.multinomial(weights_i2t[b], 1).item() text_ids_neg.append(text_input_ids_world[neg_idx]) text_atts_neg.append(text_attention_mask_world[neg_idx]) text_ids_neg = torch.stack(text_ids_neg, dim=0) text_atts_neg = torch.stack(text_atts_neg, dim=0) # 构建输入文本列表: [正样本batch，负样本batch1，负样本batch2] ，维度为 (3*bs,seq_len) text_ids_all = torch.cat( [text_tokens.input_ids, text_tokens.input_ids, text_ids_neg], dim=0 ) text_atts_all = torch.cat( [text_tokens.attention_mask, text_tokens.attention_mask, text_atts_neg], dim=0, ) # 构建query tokens列表: [正样本batch，负样本batch1，负样本batch2] ，维度为 (3*bs,seq_len,hidden_size) query_tokens_itm = self.query_tokens.expand(text_ids_all.shape[0], -1, -1) query_atts_itm = torch.ones(query_tokens_itm.size()[:-1], dtype=torch.long).to( image.device ) # 构建query和text的padding mask ，维度为 (3*bs,seq_len) attention_mask_all = torch.cat([query_atts_itm, text_atts_all], dim=1) # 构建输入图像列表: [正样本batch，负样本batch1，负样本batch2] ，维度为 (3*bs,seq_len,hidden_size) image_embeds_all = torch.cat( [image_embeds, image_embeds_neg, image_embeds], dim=0 ) image_atts_all = torch.ones(image_embeds_all.size()[:-1], dtype=torch.long).to( image.device ) # 1. 将输入文本转换为嵌入列表后和query tokens 在seq_len维度上拼接起来，维度为 (3*bs,text_seq_len + query_tokens_seq_len,hidden_size) # 2. 将文本和query tokens拼接得到的结果和图像嵌入进行cross attention计算，编码后得到输出的结果 output_itm = self.Qformer.bert( text_ids_all, query_embeds=query_tokens_itm, attention_mask=attention_mask_all, encoder_hidden_states=image_embeds_all, encoder_attention_mask=image_atts_all, return_dict=True, ) # 取 (3*bs,text_seq_len + query_tokens_seq_len,hidden_size) 中 query tokens部分的结果，维度为 (3*bs,query_tokens_seq_len,hidden_size) vl_embeddings = output_itm.last_hidden_state[:, : query_tokens_itm.size(1), :] # 把query tokens部分的每个位置都映射到2维匹配空间，维度为 (3*bs,query_tokens_seq_len,2) vl_output = self.itm_head(vl_embeddings) # 取每个位置的平均作为最终的匹配得分，维度为 (3*bs,2) logits = vl_output.mean(dim=1) # 构建匹配标签: [正样本batch=1，负样本batch1=0，负样本batch2=0] ，维度为 (3*bs) itm_labels = torch.cat( [torch.ones(bs, dtype=torch.long), torch.zeros(2 * bs, dtype=torch.long)], dim=0, ).to(image.device) # 计算交叉熵损失 loss_itm = F.cross_entropy(logits, itm_labels)\",\"当文本和query tokens同时输入BertModel时，BertEmbeddings会将text embeddings和query tokens的embeddings在seq_len维度上拼接起来。\",\"class BertEmbeddings(nn.Module): ... def forward( self, input_ids=None, position_ids=None, query_embeds=None, past_key_values_length=0, ): # 计算序列长度 if input_ids is not None: seq_length = input_ids.size()[1] else: seq_length = 0 # 如果未提供位置id，则自动生成 if position_ids is None: position_ids = self.position_ids[ :, past_key_values_length : seq_length + past_key_values_length ].clone() # 词嵌入与位置嵌入相加，若有query_embeds则拼接 if input_ids is not None: embeddings = self.word_embeddings(input_ids) if self.position_embedding_type == \\\"absolute\\\": position_embeddings = self.position_embeddings(position_ids) embeddings = embeddings + position_embeddings if query_embeds is not None: embeddings = torch.cat((query_embeds, embeddings), dim=1) else: embeddings = query_embeds embeddings = self.LayerNorm(embeddings) embeddings = self.dropout(embeddings) return embeddings\",\"下图展示了 Image-Text Matching 的完整计算流程，关于BertModel的代码解析部分，将会在下文进行详细讲解:\",\"庖丁解牛BLIP2\",\"BertLayer 核心代码实现如下:\",\"class BertLayer(nn.Module): def __init__(self, config, layer_num): super().__init__() ... self.attention = BertAttention(config) # 每个几层,添加一个cross attention if ( self.config.add_cross_attention and layer_num % self.config.cross_attention_freq == 0 ): self.crossattention = BertAttention( config, is_cross_attention=self.config.add_cross_attention ) self.has_cross_attention = True else: self.has_cross_attention = False self.intermediate = BertIntermediate(config) self.output = BertOutput(config) self.intermediate_query = BertIntermediate(config) self.output_query = BertOutput(config) def forward( self, hidden_states, # query tokens attention_mask=None, # query token padding mask head_mask=None, encoder_hidden_states=None, # image tokens encoder_attention_mask=None, # image padding mask past_key_value=None, output_attentions=False, query_length=0, ): # decoder uni-directional self-attention cached key/values tuple is at positions 1,2 self_attn_past_key_value = ( past_key_value[:2] if past_key_value is not None else None ) # 如果 self_attention_outputs = self.attention( hidden_states, attention_mask, head_mask, output_attentions=output_attentions, past_key_value=self_attn_past_key_value, ) attention_output = self_attention_outputs[0] outputs = self_attention_outputs[1:-1] present_key_value = self_attention_outputs[-1] if query_length > 0: # query tokens nums = 32 query_attention_output = attention_output[:, :query_length, :] # query tokens 经过 attention 后得到 context states if self.has_cross_attention: # q (context states) , k 和 v 来自 images encoder # q(b,32,h) * k(b,seq_len,h).t = (b,32,seq_len) # score(b,32,seq_len) * v(b,seq_len,h) = (b,32,h) cross_attention_outputs = self.crossattention( query_attention_output, attention_mask, head_mask, encoder_hidden_states, encoder_attention_mask, output_attentions=output_attentions, ) query_attention_output = cross_attention_outputs[0] outputs = ( outputs + cross_attention_outputs[1:-1] ) # add cross attentions if we output attention weights # 分块并行处理 layer_output = apply_chunking_to_forward( self.feed_forward_chunk_query, self.chunk_size_feed_forward, self.seq_len_dim, query_attention_output, ) if attention_output.shape[1] > query_length: layer_output_text = apply_chunking_to_forward( self.feed_forward_chunk, self.chunk_size_feed_forward, self.seq_len_dim, attention_output[:, query_length:, :], ) layer_output = torch.cat([layer_output, layer_output_text], dim=1) else: layer_output = apply_chunking_to_forward( self.feed_forward_chunk, self.chunk_size_feed_forward, self.seq_len_dim, attention_output, ) outputs = (layer_output,) + outputs outputs = outputs + (present_key_value,) return outputs def feed_forward_chunk(self, attention_output): intermediate_output = self.intermediate(attention_output) layer_output = self.output(intermediate_output, attention_output) return layer_output def feed_forward_chunk_query(self, attention_output): intermediate_output = self.intermediate_query(attention_output) layer_output = self.output_query(intermediate_output, attention_output) return layer_output\",\"class BertAttention(nn.Module): def __init__(self, config, is_cross_attention=False): super().__init__() self.self = BertSelfAttention(config, is_cross_attention) self.output = BertSelfOutput(config) def forward( self, hidden_states, attention_mask=None, head_mask=None, encoder_hidden_states=None, encoder_attention_mask=None, past_key_value=None, output_attentions=False, ): self_outputs = self.self( hidden_states, attention_mask, head_mask, encoder_hidden_states, encoder_attention_mask, past_key_value, output_attentions, ) # (context_layer, attention_probs) attention_output = self.output(self_outputs[0], hidden_states) outputs = (attention_output,) + self_outputs[ 1: ] # add attentions if we output them return outputs\",\"class BertSelfAttention(nn.Module): ... def transpose_for_scores(self, x): # 调整张量形状以便多头注意力计算 new_x_shape = x.size()[:-1] + ( self.num_attention_heads, self.attention_head_size, ) x = x.view(*new_x_shape) return x.permute(0, 2, 1, 3) def forward( self, hidden_states, attention_mask=None, head_mask=None, encoder_hidden_states=None, encoder_attention_mask=None, past_key_value=None, output_attentions=False, ): # 判断是否为交叉注意力 is_cross_attention = encoder_hidden_states is not None if is_cross_attention: # key and value come from image key_layer = self.transpose_for_scores(self.key(encoder_hidden_states)) value_layer = self.transpose_for_scores(self.value(encoder_hidden_states)) attention_mask = encoder_attention_mask elif past_key_value is not None: key_layer = self.transpose_for_scores(self.key(hidden_states)) value_layer = self.transpose_for_scores(self.value(hidden_states)) key_layer = torch.cat([past_key_value[0], key_layer], dim=2) value_layer = torch.cat([past_key_value[1], value_layer], dim=2) else: key_layer = self.transpose_for_scores(self.key(hidden_states)) value_layer = self.transpose_for_scores(self.value(hidden_states)) mixed_query_layer = self.query(hidden_states) query_layer = self.transpose_for_scores(mixed_query_layer) past_key_value = (key_layer, value_layer) # 计算注意力分数 attention_scores = torch.matmul(query_layer, key_layer.transpose(-1, -2)) attention_scores = attention_scores / math.sqrt(self.attention_head_size) if attention_mask is not None: # 应用注意力掩码 attention_scores = attention_scores + attention_mask # softmax归一化得到注意力概率 attention_probs = nn.Softmax(dim=-1)(attention_scores) # dropout防止过拟合 attention_probs_dropped = self.dropout(attention_probs) # 计算上下文表示 context_layer = torch.matmul(attention_probs_dropped, value_layer) context_layer = context_layer.permute(0, 2, 1, 3).contiguous() new_context_layer_shape = context_layer.size()[:-2] + (self.all_head_size,) context_layer = context_layer.view(*new_context_layer_shape) outputs = ( (context_layer, attention_probs) if output_attentions else (context_layer,) ) outputs = outputs + (past_key_value,) return outputs\"]},\"94\":{\"h\":\"庖丁解牛VIT\",\"t\":[\"多模态模型VIT原理与图片分类实战演练\",\"Vision Transformer是2021年谷歌在ICLR上提出的算法，它首次将NLP领域火热的Transformer模型架构移植到了CV领域，打破了这两个领域壁垒，并取得不错的成效。\",\"Vision Transformer的模型结构相比于Transformer来说更简单，在Transformer模型中，主要包含Encoder和Decoder结构，而ViT(Vision Transformer)仅借鉴了Encoder结构。\",\"ViT原论文中最核心的结论是: 当拥有足够多的数据进行预训练的时候，ViT的表现就会超过CNN，突破transformer缺少归纳偏置的限制，可以在下游任务中获得较好的迁移效果。\",\"归纳偏置:\",\"归纳偏置能够帮助学习算法缩小搜索范围，快速找到合适的模型。\",\"例如，在图像分类任务中，如果没有任何归纳偏置，学习算法需要在所有可能的函数空间中搜索最优模型，这几乎是不可能完成的任务。而通过引入特定的归纳偏置，如局部性和平移不变性（CNN 所具备的），可以将搜索范围限制在满足这些性质的模型子空间内，大大提高学习效率。\",\"但是当训练数据集不够大的时候，ViT的表现通常比同等大小的ResNets要差一些，因为Transformer和CNN相比缺少归纳偏置（inductive bias），即一种先验知识，提前做好的假设。CNN具有两种归纳偏置，一种是局部性（locality/two-dimensional neighborhood structure），即图片上相邻的区域具有相似的特征；一种是平移不变形（translation equivariance）。当CNN具有以上两种归纳偏置，就有了很多先验信息，需要相对少的数据就可以学习一个比较好的模型。\"]},\"95\":{\"h\":\"原理\",\"t\":[\"本文将通过一个花卉分类的实战案例结合ViT原论文，来帮助大家梳理清楚Vision Transformer的核心流程实现。\"]},\"96\":{\"h\":\"0. 数据下载\",\"t\":[\"实验采用的是花蕊数据集，共5个类别，约4000多个样本。\",\"数据集下载：https://pan.baidu.com/s/137mO-7PY1jDq1Wp0NNyT3A?pwd=qvmq\",\"数据集加载代码:\",\"def read_split_data(root: str, val_rate: float = 0.2): random.seed(0) # 保证随机结果可复现 assert os.path.exists(root), \\\"dataset root: {} does not exist.\\\".format(root) # 遍历文件夹，一个文件夹对应一个类别 flower_class = [cla for cla in os.listdir(root) if os.path.isdir(os.path.join(root, cla))] # 排序，保证顺序一致 flower_class.sort() # 生成类别名称以及对应的数字索引 class_indices = dict((k, v) for v, k in enumerate(flower_class)) json_str = json.dumps(dict((val, key) for key, val in class_indices.items()), indent=4) with open('class_indices.json', 'w') as json_file: json_file.write(json_str) train_images_path = [] # 存储训练集的所有图片路径 train_images_label = [] # 存储训练集图片对应索引信息 val_images_path = [] # 存储验证集的所有图片路径 val_images_label = [] # 存储验证集图片对应索引信息 every_class_num = [] # 存储每个类别的样本总数 supported = [\\\".jpg\\\", \\\".JPG\\\", \\\".png\\\", \\\".PNG\\\"] # 支持的文件后缀类型 # 遍历每个文件夹下的文件 for cla in flower_class: cla_path = os.path.join(root, cla) # 遍历获取supported支持的所有文件路径 images = [os.path.join(root, cla, i) for i in os.listdir(cla_path) if os.path.splitext(i)[-1] in supported] # 获取该类别对应的索引 image_class = class_indices[cla] # 记录该类别的样本数量 every_class_num.append(len(images)) # 按比例随机采样验证样本 val_path = random.sample(images, k=int(len(images) * val_rate)) for img_path in images: if img_path in val_path: # 如果该路径在采样的验证集样本中则存入验证集 val_images_path.append(img_path) val_images_label.append(image_class) else: # 否则存入训练集 train_images_path.append(img_path) train_images_label.append(image_class) print(\\\"{} images were found in the dataset.\\\".format(sum(every_class_num))) print(\\\"{} images for training.\\\".format(len(train_images_path))) print(\\\"{} images for validation.\\\".format(len(val_images_path))) plot_image = True if plot_image: # 绘制每种类别个数柱状图 plt.bar(range(len(flower_class)), every_class_num, align='center') # 将横坐标0,1,2,3,4替换为相应的类别名称 plt.xticks(range(len(flower_class)), flower_class) # 在柱状图上添加数值标签 for i, v in enumerate(every_class_num): plt.text(x=i, y=v + 5, s=str(v), ha='center') # 设置x坐标 plt.xlabel('image class') # 设置y坐标 plt.ylabel('number of images') # 设置柱状图的标题 plt.title('flower class distribution') plt.show() return train_images_path, train_images_label, val_images_path, val_images_label\",\"自定义一个MyDataSet类来封装我们加载得到的数据集:\",\"from torch.utils.data import Dataset from PIL import Image import torch class MyDataSet(Dataset): \\\"\\\"\\\"自定义数据集\\\"\\\"\\\" def __init__(self, images_path: list, images_class: list, transform=None): \\\"\\\"\\\" 初始化自定义数据集类 :param images_path: 包含所有图像文件路径的列表 :param images_class: 包含所有图像对应类别的列表，与 images_path 中的图像一一对应 :param transform: 图像预处理的转换操作，默认为 None \\\"\\\"\\\" self.images_path = images_path self.images_class = images_class self.transform = transform def __len__(self): \\\"\\\"\\\" 返回数据集中图像的数量 :return: 数据集中图像的数量 \\\"\\\"\\\" return len(self.images_path) def __getitem__(self, item): \\\"\\\"\\\" 根据索引获取数据集中的图像和对应的标签 :param item: 图像的索引 :return: 经过预处理的图像和对应的标签 \\\"\\\"\\\" # 打开指定索引的图像文件 img = Image.open(self.images_path[item]) # RGB为彩色图片，L为灰度图片 # 检查图像是否为 RGB 模式，如果不是则抛出异常 if img.mode != 'RGB': raise ValueError(\\\"image: {} isn't RGB mode.\\\".format(self.images_path[item])) # 获取对应图像的标签 label = self.images_class[item] # 如果定义了图像预处理转换操作，则对图像进行处理 if self.transform is not None: img = self.transform(img) return img, label @staticmethod def collate_fn(batch): \\\"\\\"\\\" 自定义的批量数据处理函数，用于将一个批次的数据组合成一个张量 :param batch: 一个批次的数据，包含图像和对应的标签 :return: 组合后的图像张量和标签张量 \\\"\\\"\\\" # 官方实现的default_collate可以参考 # https://github.com/pytorch/pytorch/blob/67b7e751e6b5931a9f45274653f4f653a4e6cdf6/torch/utils/data/_utils/collate.py # 将一个批次的数据拆分为图像和标签两个元组 images, labels = tuple(zip(*batch)) # 将图像元组堆叠成一个四维张量，维度为 (batch_size, channels, height, width) images = torch.stack(images, dim=0) # 将标签元组转换为一个一维张量 labels = torch.as_tensor(labels) return images, labels\",\"两点注意:\",\"当使用 DataLoader 从数据集（Dataset）中加载数据时，它会将多个样本收集起来形成一个批次，但默认的组合方式可能不满足所有需求，这时就可以自定义 collate_fn 函数。\",\"@staticmethod 是 Python 中的一个装饰器，用于将一个方法定义为静态方法。静态方法是类中的一种特殊方法，它与类的实例和类本身都没有直接关联，可以直接通过类名调用，不需要创建类的实例。\"]},\"97\":{\"h\":\"1. 图片预处理\",\"t\":[\"预处理这个步骤在论文里并没有详细说明，但是对于ViT这个结构而言，输入的图片尺寸并不是自定义的，ViT-B/16为例，输入的图片尺寸必须为224x224。\",\"在 ViT - B/16 中，“B” 代表的是模型的基础（Base）版本 ，“16” 表示每个图像块的大小是 16x16 像素；ViT 通常在大规模数据集（如 ImageNet）上进行预训练，而预训练过程中使用的输入图像尺寸通常固定为 224x224。在预训练时，模型的参数是根据这个特定尺寸的输入数据进行优化和学习的。当我们在其他任务中使用预训练好的模型时，为了充分利用预训练的权重，也需要保持输入图像尺寸与预训练时一致，这样可以保证模型的特征提取能力和性能。\",\"因此，首先需要对输入图片进行尺寸变化，具体方式可以是直接缩放(Resize)，也可以进行随机裁剪(RandomResizedCrop)。\",\"对数据集和验证集划分之后，这里对训练集的处理方式是随机切成224x224像素的图片，然后进行水平翻转，再进行归一化和标准化处理；对验证集的处理方式是先Resize成256x256的图片，再从中心位置裁剪成224x224，再进行归一化和标准化处理。\",\"# 定义一个字典 data_transform，用于存储训练集和验证集的图像预处理转换操作 data_transform = { # 训练集的预处理转换操作 \\\"train\\\": transforms.Compose([ # 随机裁剪输入图像，将裁剪后的图像调整为 224x224 大小 # 这是一种数据增强的方式，通过随机裁剪可以增加训练数据的多样性，提高模型的泛化能力 transforms.RandomResizedCrop(224), # 以 0.5 的概率随机水平翻转图像 # 同样是数据增强的手段，增加了图像的多样性，有助于模型学习到不同方向的特征 transforms.RandomHorizontalFlip(), # 将 PIL 图像或 NumPy 数组转换为 PyTorch 的张量（Tensor） # 同时会将像素值从 [0, 255] 范围缩放到 [0, 1] 范围 transforms.ToTensor(), # 对图像进行归一化处理 # 第一个参数 [0.5, 0.5, 0.5] 是图像每个通道的均值，第二个参数 [0.5, 0.5, 0.5] 是图像每个通道的标准差 # 归一化有助于模型更快地收敛，提高训练的稳定性 transforms.Normalize([0.5, 0.5, 0.5], [0.5, 0.5, 0.5]) ]), # 验证集的预处理转换操作 \\\"val\\\": transforms.Compose([ # 将图像的短边缩放为 256 像素，长边按比例缩放 # 这一步是为了保证图像的整体比例不变，后续再进行裁剪操作 transforms.Resize(256), # 从图像的中心位置裁剪出 224x224 大小的图像 # 验证集不需要进行数据增强，只需要将图像调整到合适的大小 transforms.CenterCrop(224), # 将 PIL 图像或 NumPy 数组转换为 PyTorch 的张量（Tensor） # 同样会将像素值从 [0, 255] 范围缩放到 [0, 1] 范围 transforms.ToTensor(), # 对图像进行归一化处理，参数与训练集的归一化参数相同 # 保证训练集和验证集的数据处理方式一致 transforms.Normalize([0.5, 0.5, 0.5], [0.5, 0.5, 0.5]) ]) }\",\"下面我们将用于图片变换的transforms流水线和上面自定义的MyDataSet类都封装到DataLoader去。\",\"train_images_path, train_images_label, val_images_path, val_images_label = read_split_data(data_path) # 实例化训练数据集 train_dataset = MyDataSet(images_path=train_images_path, images_class=train_images_label, transform=data_transform[\\\"train\\\"]) # 实例化验证数据集 val_dataset = MyDataSet(images_path=val_images_path, images_class=val_images_label, transform=data_transform[\\\"val\\\"]) train_loader = torch.utils.data.DataLoader(train_dataset, batch_size=batch_size, shuffle=True, collate_fn=train_dataset.collate_fn) val_loader = torch.utils.data.DataLoader(val_dataset, batch_size=batch_size, shuffle=False, collate_fn=val_dataset.collate_fn)\"]},\"98\":{\"h\":\"2. 图片切割\",\"t\":[\"Transformer需要输入的是一维的Token，对于二维的图像，一种朴素的想法就是把一个个像素点拉平，这样就成了一个一维序列。但是这样造成的一个后果是计算量太庞大，比如一张224x224的图片，变成1维度之后就成了50176，相当于直接输入一篇五万字的文章，模型难以计算。\",\"那么，一个改进的想法就是把一张图片分成nxn个Patch，每一个Patch作为一个Token，这样计算量就大大减小了。\",\"以ViT-B/16为例，将输入图片(224x224)按照16x16大小的Patch进行划分，划分后可以得到共个Patch。每个Patch是三通道的小图片，shape为(16, 16, 3)，将其展平就变成了一个长度为768的向量。\",\"每一个向量作为一个单独的输入，那样我们总共有196个向量，在代码中，可以变成一个[196,768]的矩阵，进行并行输入。\",\"这一步的操作在论文中是直接采用切割的处理办法，但是实际的代码实现中，采用了一种更巧妙的解决思路，就是利用一个卷积核大小为16x16，步距为16，卷积核个数为768的卷积层来进行实现。\",\"再来回顾我们的卷积层计算公式：\",\"输入为[224,244,3]，经过卷积层变成[14,14,768]，再映射为[196,768]。\",\"这样，就完成了从图片到Token之间的转换，我们通过自定义一个PatchEmbed类完成上述工作。\",\"class PatchEmbed(nn.Module): \\\"\\\"\\\" 2D Image to Patch Embedding 该类的作用是将二维图像分割成多个图像块（patch），并将这些图像块嵌入到一个低维向量空间中 \\\"\\\"\\\" def __init__(self, img_size=224, patch_size=16, in_c=3, embed_dim=768, norm_layer=None): \\\"\\\"\\\" 初始化 PatchEmbed 类 :param img_size: 输入图像的尺寸，默认为 224。如果传入一个整数，则表示图像是正方形，边长为该整数； :param patch_size: 每个图像块的尺寸，默认为 16。同样，如果传入一个整数，则表示图像块是正方形，边长为该整数； :param in_c: 输入图像的通道数，默认为 3（对应 RGB 图像） :param embed_dim: 嵌入维度，即每个图像块经过卷积操作后得到的特征向量的维度，默认为 768 :param norm_layer: 归一化层，默认为 None。如果传入一个归一化层类，则使用该层进行归一化；否则使用 nn.Identity() 表示不进行归一化 \\\"\\\"\\\" super().__init__() # 将 img_size 和 patch_size 转换为元组形式，如果传入的是整数，则将其转换为 (整数, 整数) 的形式 img_size = (img_size, img_size) patch_size = (patch_size, patch_size) self.img_size = img_size self.patch_size = patch_size # 计算网格大小，即图像在水平和垂直方向上分别可以划分的图像块数量 self.grid_size = (img_size[0] // patch_size[0], img_size[1] // patch_size[1]) # 计算图像块的总数，即网格大小的乘积 self.num_patches = self.grid_size[0] * self.grid_size[1] # 定义一个二维卷积层，用于将输入图像分割成多个图像块并进行嵌入 # in_c 是输入通道数，embed_dim 是输出通道数（也就是卷积核的数量） # kernel_size 是卷积核的大小，这里设置为图像块的大小 # stride 是卷积核的步长，这里设置为图像块的大小，确保卷积操作不会重叠 self.proj = nn.Conv2d(in_c, embed_dim, kernel_size=patch_size, stride=patch_size) # 如果传入了归一化层类，则使用该层进行归一化；否则使用 nn.Identity() 表示不进行归一化 self.norm = norm_layer(embed_dim) if norm_layer else nn.Identity() def forward(self, x): \\\"\\\"\\\" 前向传播函数 :param x: 输入的图像张量，形状为 [B, C, H, W]，其中 B 是批量大小，C 是通道数，H 是图像高度，W 是图像宽度 :return: 经过处理后的图像块嵌入张量，形状为 [B, num_patches, embed_dim] \\\"\\\"\\\" # 获取输入图像张量的形状 B, C, H, W = x.shape # 注意下面的embed_dim代表的是卷积核的数量，也就是经过卷积后拼接得到的特征图(输出通道)数量 # H`和 W`代表输出特征图的宽和高 # 首先使用卷积层对输入图像进行处理，得到形状为 [B, embed_dim, H', W'] 的特征图 # 然后将特征图的最后两维展平为一维，得到形状为 [B, embed_dim, num_patches] 的张量 # 最后交换第 1 维和第 2 维，得到形状为 [B, num_patches, embed_dim] 的张量 # 这里的 num_patches 是图像块的总数 x = self.proj(x).flatten(2).transpose(1, 2) # 对处理后的张量进行归一化操作 x = self.norm(x) return x\",\"用一个简化版的例子说明上述过程:\",\"核心要点: 将卷积后的通道维数作为embedding的维度，卷积后剩余的长和宽相乘作为时间维度，由此把图片转换为序列的embedding形式。\"]},\"99\":{\"h\":\"3. 添加[class]token\",\"t\":[\"在上面的结构图中可以看到，输入Encoder的最左侧部分添加了一个0*这个Token，这个就是额外添加的一个[class]token，单独用来处理类别信息，经过Encoder之后，需要单独将这个Token再提取出来，输入到MLP Head之中再输出分类结果。\",\"这也是为什么结构图中MLP Head的位置是和这个[class]token对齐。\",\"这里简单介绍一下CLS TOKEN的作用:\",\"[CLS] Token 的作用是通过训练过程中损失值的降低，模型学会如何通过注意力机制将图像的有效信息汇聚到 [CLS] Token 中，从而完成图像分类任务。\",\"初始化： \",\"[CLS] Token 是一个随机初始化的向量，初始时没有任何语义信息。\",\"位置编码被添加到 patch 嵌入中，以保留图像的空间信息。\",\"前向传播： \",\"输入图像被分割成 patches，并通过线性变换映射到嵌入空间。\",\"[CLS] Token 被添加到 patch 嵌入序列的开头。\",\"通过多层 Transformer Encoder，模型计算每个 patch 嵌入（包括 [CLS] Token）与其他 patch 嵌入的关系。\",\"注意力汇聚： \",\"在每一层 Transformer 中，[CLS] Token 通过自注意力机制与其他 patch 嵌入交互。\",\"模型学会将图像中与分类任务相关的信息汇聚到 [CLS] Token 中。\",\"损失计算与反向传播： \",\"[CLS] Token 的输出向量被输入到分类头中，用于预测图像的类别。\",\"通过计算损失（如交叉熵损失），模型更新参数，使得 [CLS] Token 能够更好地聚合图像信息。\",\"收敛： \",\"随着训练的进行，损失值逐渐降低，模型学会如何通过注意力机制将图像的有效信息汇聚到 [CLS] Token 中。\",\"最终，[CLS] Token 的输出向量能够很好地表示图像的全局特征，用于分类任务。\",\"[CLS] Token 能起作用的原因在于：\",\"注意力机制的特性： \",\"自注意力机制能够捕捉图像中任意两个 patches 之间的关系。\",\"[CLS] Token 通过与其他 patches 的交互，能够动态地聚合图像信息。\",\"训练目标的引导： \",\"训练过程中，损失函数直接作用于 [CLS] Token 的输出。\",\"模型被强制学会将图像的有效信息汇聚到 [CLS] Token 中，以最小化损失。\",\"全局特征表示： \",\"[CLS] Token 位于序列的开头，能够通过多层 Transformer 逐步聚合全局信息。\",\"最终，[CLS] Token 的输出向量能够很好地表示图像的全局特征。\",\"class VisionTransformer(nn.Module): def __init__(self, img_size=224, patch_size=16, in_c=3, num_classes=1000, embed_dim=768, embed_layer=None): \\\"\\\"\\\" Args: img_size (int, tuple): 输入图像的尺寸 patch_size (int, tuple): 图像块的尺寸 in_c (int): 输入图像的通道数 num_classes (int): 分类任务的类别数 embed_dim (int): 嵌入维度 embed_layer (nn.Module): 图像块嵌入层 \\\"\\\"\\\" super(VisionTransformer, self).__init__() # 保存分类任务的类别数 self.num_classes = num_classes # 保存嵌入维度，同时作为特征数量，以保持与其他模型的一致性 self.num_features = self.embed_dim = embed_dim # 只有一个特殊标记（分类标记） self.num_tokens = 1 # 创建图像块嵌入层 self.patch_embed = embed_layer(img_size=img_size, patch_size=patch_size, in_c=in_c, embed_dim=embed_dim) # 计算图像块的数量 num_patches = self.patch_embed.num_patches # 创建可学习的分类标记 self.cls_token = nn.Parameter(torch.zeros(1, 1, embed_dim)) # 使用截断正态分布初始化分类标记 nn.init.trunc_normal_(self.cls_token, std=0.02) ... def forward_features(self, x): # [B, C, H, W] -> [B, num_patches, embed_dim] # 将输入图像进行图像块嵌入 x = self.patch_embed(x) # [B, 196, 768] # [1, 1, 768] -> [B, 1, 768] # 扩展分类标记以匹配输入批次大小 cls_token = self.cls_token.expand(x.shape[0], -1, -1) # 将分类标记和图像块嵌入拼接 x = torch.cat((cls_token, x), dim=1) # [B, 197, 768] ... # 返回分类标记对应的特征,x[:,0]对应维度为[B,1,768] return x[:,0]; def forward(self, x): # 提取输入图像的特征 x = self.forward_features(x) # 通过分类头 -- [B,1,768] x = self.head(x) return x\"]},\"100\":{\"h\":\"4. 添加位置编码\",\"t\":[\"在Transformer中，位置编码的作用是为了记忆输入的语序信息。ViT中，同样需要位置编码来记录各图像块之间的位置信息。\",\"这里主要有两种位置编码思路，一种思路是在转换之前(14,14)的图像块矩阵添加二维(2-D)位置编码，另一种思路是在转换后(196+1)这个维度上添加一维(1-D)位置编码。\",\"论文作者也对其做了实验，实验结果如下表所示：\",\" 可以看到，添加一维位置编码和二维位置编码并没有太大的差异。作者随后也对一维位置编码的结果进行了可视化，结果如下图所示：\",\" 上图中是每一个Patch中各位置的位置编码相似性度量，越接近黄色的位置代表越靠近位置编码的中心位置，可以看到，即使是一维位置编码，同样可以比较好地记录二维信息。\",\"class VisionTransformer(nn.Module): def __init__(self, img_size=224, patch_size=16, in_c=3, num_classes=1000, embed_dim=768, depth=12, num_heads=12, mlp_ratio=4.0, qkv_bias=True, qk_scale=None, representation_size=None, drop_ratio=0., attn_drop_ratio=0., drop_path_ratio=0., embed_layer=None, norm_layer=None, act_layer=None): super(VisionTransformer, self).__init__() # 保存分类任务的类别数 self.num_classes = num_classes # 保存嵌入维度，同时作为特征数量，以保持与其他模型的一致性 self.num_features = self.embed_dim = embed_dim # 只有一个特殊标记（分类标记） self.num_tokens = 1 # 创建图像块嵌入层 self.patch_embed = embed_layer(img_size=img_size, patch_size=patch_size, in_c=in_c, embed_dim=embed_dim) # 计算图像块的数量 num_patches = self.patch_embed.num_patches # 创建可学习的分类标记 self.cls_token = nn.Parameter(torch.zeros(1, 1, embed_dim)) # 创建可学习的位置嵌入 self.pos_embed = nn.Parameter(torch.zeros(1, num_patches + self.num_tokens, embed_dim)) # 创建丢弃层，用于位置嵌入后的随机丢弃 self.pos_drop = nn.Dropout(p=drop_ratio) ... # 权重初始化 # 使用截断正态分布初始化位置嵌入 nn.init.trunc_normal_(self.pos_embed, std=0.02) # 使用截断正态分布初始化分类标记 nn.init.trunc_normal_(self.cls_token, std=0.02) ... def forward_features(self, x): # [B, C, H, W] -> [B, num_patches, embed_dim] # 将输入图像进行图像块嵌入 x = self.patch_embed(x) # [B, 196, 768] # [1, 1, 768] -> [B, 1, 768] # 扩展分类标记以匹配输入批次大小 cls_token = self.cls_token.expand(x.shape[0], -1, -1) # 将分类标记和图像块嵌入拼接 x = torch.cat((cls_token, x), dim=1) # [B, 197, 768] # 加上位置嵌入并进行随机丢弃 x = self.pos_drop(x + self.pos_embed) ... # 返回分类标记对应的特征 return x[:, 0] def forward(self, x): # 提取输入图像的特征 x = self.forward_features(x) # 通过分类头 x = self.head(x) return x\",\"上面代码实现中使用的是可学习位置嵌入，具体解释如下:\",\"可学习位置嵌入（learnable positional embedding）是指位置嵌入的参数是可以在模型训练过程中通过反向传播算法进行更新的。具体来说，在模型初始化时，位置嵌入会被初始化为一组特定的值（通常是随机初始化或者初始化为零），然后在训练过程中，这些值会根据模型的损失函数不断调整，以使得模型能够学习到最适合当前任务的位置表示。\"]},\"101\":{\"h\":\"5. Encoder\",\"t\":[\"ViT虽然采用的是Transformer Encoder的结构，但是和Transformer原始的Encoder还是有所区别，我将两者的结构进行对比，如下图所示，左侧为Transformer原始的Encoder结构。\",\" 可以看到，大致上两者结构是相同的，主要区别在于Norm层的顺序，原始Transformer的Norm层在多头注意力和前馈网络之后，而ViT将其放到前面，这里的原因，论文里没有做解释。\",\"关于Norm层，ViT仍是采用Transformer中用到Layer Normalization，计算公式如下：\",\"Norm层之后同样是多头注意力层(Multi-Head Attention)，和Transformer中的一样。\",\"后面的MLP是个单独的结构，就是两个线性层+GELU激活函数+Dropout的结构 ：\",\" MLP Block 中第一个线性层把输入特征投影到一个更高维度的空间后，不同特征之间能够进行更多样的组合。这有助于模型发现输入数据中更复杂的模式和关系。第二个线性层再把高维特征映射回原来的维度，这样就可以提取出对最终任务有帮助的特征组合。\",\"单一的线性层只能进行线性变换，其表达能力是有限的。在两个线性层之间通常会插入一个非线性激活函数（如 GELU），这样就能让 MLP 学习到输入数据的非线性特征。第一个线性层将输入特征映射到更高维度的空间，在这个高维空间里，数据的分布更加稀疏，也就为非线性激活函数提供了更多可以学习的特征组合，从而增强了模型的表达能力。\",\"class Block(nn.Module): def __init__(self, dim, num_heads, mlp_ratio=4., qkv_bias=False, qk_scale=None, drop_ratio=0., attn_drop_ratio=0., drop_path_ratio=0., act_layer=nn.GELU, norm_layer=nn.LayerNorm): super(Block, self).__init__() # 第一个归一化层，对输入进行归一化处理 self.norm1 = norm_layer(dim) # 多头自注意力层 self.attn = Attention(dim, num_heads=num_heads, qkv_bias=qkv_bias, qk_scale=qk_scale, attn_drop_ratio=attn_drop_ratio, proj_drop_ratio=drop_ratio) # DropPath 层，用于随机深度，当 drop_path_ratio 大于 0 时使用，否则使用恒等映射 self.drop_path = DropPath(drop_path_ratio) if drop_path_ratio > 0. else nn.Identity() # 第二个归一化层，对经过注意力层的输出进行归一化处理 self.norm2 = norm_layer(dim) # 计算 MLP 的隐藏维度 mlp_hidden_dim = int(dim * mlp_ratio) # 创建 MLP 层 self.mlp = Mlp(in_features=dim, hidden_features=mlp_hidden_dim, act_layer=act_layer, drop=drop_ratio) def forward(self, x): # 残差连接：输入加上经过归一化和注意力层处理后的输出 x = x + self.drop_path(self.attn(self.norm1(x))) # 残差连接：输入加上经过归一化和 MLP 层处理后的输出 x = x + self.drop_path(self.mlp(self.norm2(x))) return x\",\"class Mlp(nn.Module): \\\"\\\"\\\" MLP as used in Vision Transformer, MLP-Mixer and related networks \\\"\\\"\\\" def __init__(self, in_features, hidden_features=None, out_features=None, act_layer=nn.GELU, drop=0.): super().__init__() # 如果未指定 out_features，则默认为 in_features out_features = out_features or in_features # 如果未指定 hidden_features，则默认为 in_features hidden_features = hidden_features or in_features # 第一个全连接层，将输入特征映射到隐藏特征空间 self.fc1 = nn.Linear(in_features, hidden_features) # 激活函数层，默认使用 GELU 激活函数 self.act = act_layer() # 第二个全连接层，将隐藏特征映射到输出特征空间 self.fc2 = nn.Linear(hidden_features, out_features) # Dropout 层，用于防止过拟合 self.drop = nn.Dropout(drop) def forward(self, x): # 通过第一个全连接层 x = self.fc1(x) # 通过激活函数层 x = self.act(x) # 应用 Dropout x = self.drop(x) # 通过第二个全连接层 x = self.fc2(x) # 再次应用 Dropout x = self.drop(x) return x\",\"一个block之后维度依然和输入相同，都是197 x 768 ，因此可以堆叠多个block。\"]},\"102\":{\"h\":\"6. 多头自注意力\",\"t\":[\"ViT中的多头自注意力模块实现逻辑和Transformer基本一致，主要的区别就是去掉了Paddding_Mask和Casual_Mask部分相关的掩码逻辑。\",\"下面所给出的代码实现，注意是通过一个线性层来同时计算qkv三个矩阵，这样可以提升计算效率。\",\"class Attention(nn.Module): def __init__(self, dim, # 嵌入层维度 num_heads=8, # 注意力头的数量，默认为8 qkv_bias=False, # 是否在生成Q、K、V时使用偏置，默认为False qk_scale=None, # 缩放因子，用于调整注意力分数，若为None则使用默认值 attn_drop_ratio=0., # 注意力矩阵的丢弃率，默认为0 proj_drop_ratio=0.): # 投影层的丢弃率，默认为0 super(Attention, self).__init__() self.num_heads = num_heads # 保存注意力头的数量 head_dim = dim // num_heads # 计算每个注意力头的维度 self.scale = qk_scale or head_dim ** -0.5 # 确定缩放因子，若qk_scale未指定，则使用默认的缩放因子 # 定义一个线性层，将输入的维度dim映射到dim * 3，用于同时生成查询（Q）、键（K）和值（V） self.qkv = nn.Linear(dim, dim * 3, bias=qkv_bias) # 定义注意力矩阵的丢弃层，防止过拟合 self.attn_drop = nn.Dropout(attn_drop_ratio) # 定义投影层，将多头注意力的输出进行线性变换 self.proj = nn.Linear(dim, dim) # 定义投影层的丢弃层，防止过拟合 self.proj_drop = nn.Dropout(proj_drop_ratio) # 没有padding_mask, casual_mask def forward(self, x): # [batch_size, num_patches + 1, total_embed_dim] # 获取输入张量x的形状，B为批量大小，N为序列长度（包含分类token），C为输入token的总维度 B, N, C = x.shape # qkv(): -> [batch_size, num_patches + 1, 3 * total_embed_dim] # reshape: -> [batch_size, num_patches + 1, 3, num_heads, embed_dim_per_head] # permute: -> [3, batch_size, num_heads, num_patches + 1, embed_dim_per_head] # 通过qkv线性层将输入x映射到dim * 3的维度，然后调整形状并重新排列维度 # 下面的3是因为我们用一次矩阵运算得到了拼接在一起的Q,K,V矩阵，这里需要将其分离开来 qkv = self.qkv(x).reshape(B, N, 3, self.num_heads, C // self.num_heads).permute(2, 0, 3, 1, 4) # [batch_size, num_heads, num_patches + 1, embed_dim_per_head] # 从qkv张量中分离出查询（Q）、键（K）和值（V） # 注意: Q,K,V计算来源相同,因此是自注意力 q, k, v = qkv[0], qkv[1], qkv[2] # make torchscript happy (cannot use tensor as tuple) # transpose: -> [batch_size, num_heads, embed_dim_per_head, num_patches + 1] # @: multiply -> [batch_size, num_heads, num_patches + 1, num_patches + 1] # 将Q和K的转置相乘，得到注意力分数矩阵，再乘以缩放因子scale attn = (q @ k.transpose(-2, -1)) * self.scale # 对注意力分数矩阵应用softmax函数，得到注意力权重矩阵 attn = attn.softmax(dim=-1) # 对注意力权重矩阵应用丢弃层，防止过拟合 attn = self.attn_drop(attn) # @: multiply -> [batch_size, num_heads, num_patches + 1, embed_dim_per_head] # transpose: -> [batch_size, num_patches + 1, num_heads, embed_dim_per_head] # reshape: -> [batch_size, num_patches + 1, total_embed_dim] # 将注意力权重矩阵与V相乘，得到每个注意力头的输出 # 对输出进行维度交换和形状调整，将多个注意力头的输出合并为一个张量 x = (attn @ v).transpose(1, 2).reshape(B, N, C) # 通过投影层对合并后的张量进行线性变换 x = self.proj(x) # 对投影后的结果应用丢弃层，防止过拟合 x = self.proj_drop(x) return x\",\"关于多头注意力机制流程不太清楚的，可以看这篇文章。\"]},\"103\":{\"h\":\"7. MLP Head\",\"t\":[\"在Transformer Encoder输出结果之后，需要再将第一个添加的Class Token提取出来，然后输入到MLP Head进行分类。在论文中，作者先是在ImageNet21K上进行预训练，MLP Head结构由Linear+tanh激活函数+Linear组成，但是迁移到其它数据集训练时，只需要用一个一个Linear即可。\",\"class VisionTransformer(nn.Module): def __init__(self, img_size=224, patch_size=16, in_c=3, num_classes=1000, embed_dim=768, depth=12, num_heads=12, mlp_ratio=4.0, qkv_bias=True, qk_scale=None, representation_size=None, drop_ratio=0., attn_drop_ratio=0., drop_path_ratio=0., embed_layer=None, norm_layer=None, act_layer=None): super(VisionTransformer, self).__init__() # 保存分类任务的类别数 self.num_classes = num_classes # 保存嵌入维度，同时作为特征数量，以保持与其他模型的一致性 self.num_features = self.embed_dim = embed_dim # 只有一个特殊标记（分类标记） self.num_tokens = 1 # 如果没有提供归一化层，则使用默认的 LayerNorm，epsilon 为 1e-6 norm_layer = norm_layer or partial(nn.LayerNorm, eps=1e-6) # 如果没有提供激活函数层，则使用 GELU 激活函数 act_layer = act_layer or nn.GELU # 创建图像块嵌入层 self.patch_embed = embed_layer(img_size=img_size, patch_size=patch_size, in_c=in_c, embed_dim=embed_dim) # 计算图像块的数量 num_patches = self.patch_embed.num_patches # 创建可学习的分类标记 self.cls_token = nn.Parameter(torch.zeros(1, 1, embed_dim)) # 创建可学习的位置嵌入 self.pos_embed = nn.Parameter(torch.zeros(1, num_patches + self.num_tokens, embed_dim)) # 创建丢弃层，用于位置嵌入后的随机丢弃 self.pos_drop = nn.Dropout(p=drop_ratio) # 创建Encoder Block块序列 self.blocks = nn.Sequential(*[ Block(dim=embed_dim, num_heads=num_heads, mlp_ratio=mlp_ratio, qkv_bias=qkv_bias, qk_scale=qk_scale, drop_ratio=drop_ratio, attn_drop_ratio=attn_drop_ratio, drop_path_ratio=dpr[i], norm_layer=norm_layer, act_layer=act_layer) for i in range(depth) ]) # 创建归一化层 self.norm = norm_layer(embed_dim) ############################# MLP Head ############################################ # 更新特征数量为表示层的维度 self.num_features = representation_size # 创建预输出层，包含一个线性层和一个 Tanh 激活函数 self.pre_logits = nn.Sequential(OrderedDict([ (\\\"fc\\\", nn.Linear(embed_dim, representation_size)), (\\\"act\\\", nn.Tanh()) ])) # 分类头 # 如果类别数大于 0，则创建线性分类头，否则为恒等映射 self.head = nn.Linear(self.num_features, num_classes) if num_classes > 0 else nn.Identity() ########################################################################### # 权重初始化 # 使用截断正态分布初始化位置嵌入 nn.init.trunc_normal_(self.pos_embed, std=0.02) # 使用截断正态分布初始化分类标记 nn.init.trunc_normal_(self.cls_token, std=0.02) # 应用自定义的权重初始化函数 self.apply(_init_vit_weights) def forward_features(self, x): # [B, C, H, W] -> [B, num_patches, embed_dim] # 将输入图像进行图像块嵌入 x = self.patch_embed(x) # [B, 196, 768] # [1, 1, 768] -> [B, 1, 768] # 扩展分类标记以匹配输入批次大小 cls_token = self.cls_token.expand(x.shape[0], -1, -1) # 将分类标记和图像块嵌入拼接 x = torch.cat((cls_token, x), dim=1) # [B, 197, 768] # 加上位置嵌入并进行随机丢弃 x = self.pos_drop(x + self.pos_embed) # 通过Encoder Block块序列 x = self.blocks(x) # 进行归一化 x = self.norm(x) # 返回分类标记对应的特征 -- 先交给预输出层进行处理 return self.pre_logits(x[:, 0]) def forward(self, x): # 提取输入图像的特征 x = self.forward_features(x) # 通过分类头 -- 映射到分类空间中去 x = self.head(x) return x\",\"self.pre_logits 模块可以看作是一个特征预处理模块，它位于最终分类头之前。通过将特征映射到特定的维度并进行非线性变换，该模块可以为后续的分类任务提供更具区分性和稳定性的特征表示，从而提高模型的分类性能。\",\"输出结果之后，再和真实标签做交叉熵损失，这样就可以完成ViT的训练过程。\",\"def train_one_epoch(model, optimizer, data_loader, device, epoch): ... # 遍历数据加载器中的每个批次数据 for step, data in enumerate(data_loader): # 解包数据，得到图像和对应的标签 images, labels = data # 累加当前批次的样本数到总样本数中 sample_num += images.shape[0] # 将图像数据移动到指定设备上，并通过模型进行前向传播，得到预测结果 pred = model(images.to(device)) # 从预测结果中找出每个样本预测概率最大的类别索引 pred_classes = torch.max(pred, dim=1)[1] # 计算预测正确的样本数，并累加到累计正确样本数中 accu_num += torch.eq(pred_classes, labels.to(device)).sum() # 计算预测结果与真实标签之间的交叉熵损失 loss = loss_function(pred, labels.to(device)) # 进行反向传播，计算梯度 loss.backward() ...\"]},\"104\":{\"h\":\"效果对比\",\"t\":[\"在论文中，作者将ViT和之前图像分类领域比较强的ResNet模型进行了对比测试，结果如下：\",\" 可以看到，右图中，作者使用了谷歌制作的JFT-300M数据集，当数据量小于30M时，ViT的效果表现不如ResNet，但是当数据量逐渐增大时，ViT才会慢慢超越ResNet。由此可见ViT工作的局限性，它必须要在超大数据集上进行预训练，然后再拿到其它数据集上做迁移学习，才会有好的效果。\",\"关于ViT模型的不同版本，论文里也做了说明： 其中的Layers就是Transformer Encoder中重复堆叠Encoder Block的次数，Hidden Size就是对应通过Embedding层后每个token的dim（向量的长度），MLP size是Transformer Encoder中MLP Block第一个全连接的节点个数（是Hidden Size的四倍），Heads代表Transformer中Multi-Head Attention的heads数。\",\"在深度学习领域，当提到模型参数量时，“M” 通常是 “million” 的缩写，代表 “百万”。所以参数量为 86M 就意味着模型大约有 86×1000000 = 8600000（八百六十万）个可训练参数。\",\"与之类似的还有 “B”，它是 “billion” 的缩写，代表 “十亿”。例如参数量为 1.2B 就表示模型大约有 1.2×1000000000 = 1200000000（十二亿）个可训练参数。\"]},\"105\":{\"h\":\"注意力可视化\",\"t\":[\"ViT这篇论文长达二十多页，里面包含了非常丰富的成果，其中包括注意力可视化。由于作者是首次将Transformer应用到图像领域，里面包含了注意力机制，那么作者就想把注意力得到的结果(也就是Q-K矩阵乘积)换源到图像上，得到结果如下图所示：\",\"可以看到，模型自动学习到了如果注意画面中的分类主体。\"]},\"106\":{\"h\":\"混合模型探索\",\"t\":[\"在论文的最后，作者又探索了一种混合模型(Hybrid)，就是将传统CNN和Transformer进行结合。\",\"下表中对比了ViT、ResNet和混合模型在不同图像分类数据集上的测试结果，可以看到当Epochs增大时，ResNet和混合模型的效果均不如ViT模型。\",\"混合模型的常见结合方式:\",\"CNN 作为特征提取器，Transformer 作为编码器 \",\"先用 CNN 对输入数据进行初步的特征提取，利用 CNN 的局部特征提取能力快速捕捉图像的底层特征。例如，在图像分类任务中，可以使用预训练的 ResNet 等 CNN 模型提取图像的特征图。\",\"然后将 CNN 提取的特征图转换为序列形式，输入到 Transformer 中进行进一步的处理。Transformer 可以利用其自注意力机制捕捉特征之间的长距离依赖关系，对特征进行更深入的建模。\",\"交错堆叠 CNN 和 Transformer 模块 \",\"在模型架构中，将 CNN 层和 Transformer 层交错堆叠。例如，先经过一层或多层 CNN 进行局部特征提取，然后再经过一层 Transformer 捕捉全局信息，如此反复。这样可以在模型的不同阶段交替利用 CNN 和 Transformer 的优势。\",\"在 Transformer 中引入卷积操作 \",\"在 Transformer 的架构中融入卷积操作，例如在多头自注意力机制或前馈网络中引入卷积层。这样可以为 Transformer 赋予局部特征提取的能力，同时保留其捕捉长距离依赖的优势。\"]},\"107\":{\"h\":\"加载预训练模型\",\"t\":[\"上面已经给出了数据集加载以及ViT模型核心代码实现了，下面我们将进入训练流程；首先说明，本次训练是基于预训练好的ViT-B/16这个模型进行微调，整体结构图如下：\",\"具体为vit_base_patch16_224_in21k这个模型:\",\"vit：代表 Vision Transformer。\",\"base：表示模型的规模。\",\"patch16：意味着在处理图像时，会将输入图像分割成大小为 16×16 像素的图像块（patches）。\",\"224：指的是输入图像的尺寸为 224×224 像素。在预训练和使用该模型时，需要将输入图像调整为这个固定的尺寸。\",\"in21k：该模型是在 ImageNet - 21k 数据集上进行预训练的。ImageNet - 21k 是一个大规模的图像数据集，包含大约 21000 个类别和 1.4 亿张图像。在如此大规模的数据集上进行预训练，模型能够学习到丰富的图像特征和模式，具有较强的泛化能力。\",\"def vit_base_patch16_224_in21k(num_classes: int = 21843, has_logits: bool = True): \\\"\\\"\\\" ViT-Base model (ViT-B/16) from original paper (https://arxiv.org/abs/2010.11929). ImageNet-21k weights @ 224x224, source https://github.com/google-research/vision_transformer. weights ported from official Google JAX impl: https://github.com/rwightman/pytorch-image-models/releases/download/v0.1-vitjx/jx_vit_base_patch16_224_in21k-e5005f0a.pth \\\"\\\"\\\" model = VisionTransformer(img_size=224, patch_size=16, embed_dim=768, depth=12, num_heads=12, representation_size=768 if has_logits else None, num_classes=num_classes) return model # 加载预训练好的vit_base_patch16_224_in21k模型权重文件 model = vit_base_patch16_224_in21k(num_classes=5, has_logits=False).to(device) weights_dict = torch.load(args.weights, map_location=device) model.load_state_dict(weights_dict, strict=False)\",\"加载该模型后，训练了10个epoch，验证集上准确率达到了98.5%。整体模型还是比较大的，预训练权重大小为393MB，但是训练速度还是挺快的，因为在代码中有个冻结权重的操作，主干部分全部冻结，仅训练分类头。\",\"for name, para in model.named_parameters(): # 除head, pre_logits外，其他权重全部冻结 if \\\"head\\\" not in name and \\\"pre_logits\\\" not in name: para.requires_grad_(False) else: print(\\\"training {}\\\".format(name))\",\"训练与评估流程的代码为模版代码，考虑篇幅原因，这里不再贴出，大家可以自行拉取项目完整代码进行学习:\",\"https://pan.baidu.com/s/1rkdjdlR37O7gSr9j1mhjBg?pwd=vket\"]},\"108\":{\"h\":\"总结\",\"t\":[\"Vision Transformer证明了使用Transformer结构可以有效处理图像数据，并且取得了与卷积神经网络（CNN）相媲美的效果。\",\"统一多模态的可能性：使用Transformer架构为未来的多模态统一提供了可能性。\",\"图像到文本的桥梁：架起了图像空间到文本空间的桥梁。\",\"ViT核心：如何将二维图像转换为一维时间序列？通过将图像切成小片（Patches），并按行优先排序来实现。\"]},\"109\":{\"h\":\"开源项目\"},\"110\":{\"h\":\"杂谈\"},\"111\":{\"h\":\"\",\"t\":[\"404 Not Found\"]}},\"dirtCount\":0,\"index\":[[\"杂谈\",{\"0\":{\"110\":1}}],[\"架起了图像空间到文本空间的桥梁\",{\"1\":{\"108\":1}}],[\"架构中\",{\"1\":{\"24\":1}}],[\"架构\",{\"1\":{\"14\":1,\"84\":1,\"89\":1}}],[\"统一多模态的可能性\",{\"1\":{\"108\":1}}],[\"统计正确率\",{\"1\":{\"84\":1}}],[\"统计量\",{\"1\":{\"32\":1}}],[\"考虑篇幅原因\",{\"1\":{\"107\":1}}],[\"除head\",{\"1\":{\"107\":1}}],[\"除了模型本身的应用\",{\"1\":{\"83\":1}}],[\"亿张图像\",{\"1\":{\"107\":1}}],[\"指的是输入图像的尺寸为\",{\"1\":{\"107\":1}}],[\"意味着在处理图像时\",{\"1\":{\"107\":1}}],[\"赋予局部特征提取的能力\",{\"1\":{\"106\":1}}],[\"交错堆叠\",{\"1\":{\"106\":1}}],[\"先经过一层或多层\",{\"1\":{\"106\":1}}],[\"先用\",{\"1\":{\"106\":1}}],[\"先交给预输出层进行处理\",{\"1\":{\"103\":1}}],[\"混合模型的常见结合方式\",{\"1\":{\"106\":1}}],[\"混合模型探索\",{\"0\":{\"106\":1}}],[\"混合模型改进\",{\"1\":{\"29\":1}}],[\"换源到图像上\",{\"1\":{\"105\":1}}],[\"换句话说\",{\"1\":{\"32\":1}}],[\"里面包含了注意力机制\",{\"1\":{\"105\":1}}],[\"里面包含了非常丰富的成果\",{\"1\":{\"105\":1}}],[\"百万\",{\"1\":{\"104\":1}}],[\"向量的长度\",{\"1\":{\"104\":1}}],[\"向量映射成两个分数\",{\"1\":{\"58\":1}}],[\"才会有好的效果\",{\"1\":{\"104\":1}}],[\"才能保证整个网络输出与输入点的顺序无关\",{\"1\":{\"32\":1}}],[\"右图中\",{\"1\":{\"104\":1}}],[\"右填充\",{\"1\":{\"38\":1}}],[\"累加当前批次的样本数到总样本数中\",{\"1\":{\"103\":1}}],[\"映射到分类空间中去\",{\"1\":{\"103\":1}}],[\"没有padding\",{\"1\":{\"102\":1}}],[\"没有固定顺序\",{\"1\":{\"21\":1}}],[\"防止过拟合\",{\"1\":{\"102\":4}}],[\"键\",{\"1\":{\"102\":2}}],[\"确定缩放因子\",{\"1\":{\"102\":1}}],[\"确保卷积操作不会重叠\",{\"1\":{\"98\":1}}],[\"投影层的丢弃率\",{\"1\":{\"102\":1}}],[\"时使用\",{\"1\":{\"101\":1}}],[\"时间戳等\",{\"1\":{\"31\":1}}],[\"左侧为transformer原始的encoder结构\",{\"1\":{\"101\":1}}],[\"权重初始化\",{\"1\":{\"100\":1,\"103\":1}}],[\"权重由\",{\"1\":{\"32\":1}}],[\"越接近黄色的位置代表越靠近位置编码的中心位置\",{\"1\":{\"100\":1}}],[\"扩展分类标记以匹配输入批次大小\",{\"1\":{\"99\":1,\"100\":1,\"103\":1}}],[\"扩展性\",{\"1\":{\"29\":1}}],[\"位于序列的开头\",{\"1\":{\"99\":1}}],[\"位置嵌入会被初始化为一组特定的值\",{\"1\":{\"100\":1}}],[\"位置处设置为\",{\"1\":{\"93\":1}}],[\"位置编码的作用是为了记忆输入的语序信息\",{\"1\":{\"100\":1}}],[\"位置编码被添加到\",{\"1\":{\"99\":1}}],[\"位置编码通常使用正弦和余弦函数生成\",{\"1\":{\"66\":1}}],[\"位置编码\",{\"1\":{\"66\":1,\"100\":2}}],[\"位置编码为可学习的矩阵\",{\"1\":{\"41\":1}}],[\"位置\",{\"1\":{\"13\":1}}],[\"损失函数直接作用于\",{\"1\":{\"99\":1}}],[\"损失值逐渐降低\",{\"1\":{\"99\":1}}],[\"损失计算与反向传播\",{\"1\":{\"99\":1}}],[\"随着训练的进行\",{\"1\":{\"99\":1}}],[\"随机裁剪输入图像\",{\"1\":{\"97\":1}}],[\"收敛\",{\"1\":{\"99\":1}}],[\"被添加到\",{\"1\":{\"99\":1}}],[\"维\",{\"1\":{\"98\":1}}],[\"维和第\",{\"1\":{\"98\":1}}],[\"维度变为\",{\"1\":{\"92\":1}}],[\"维度为\",{\"1\":{\"91\":2,\"92\":2,\"93\":9,\"96\":1}}],[\"维度\",{\"1\":{\"22\":1,\"29\":2}}],[\"注意\",{\"1\":{\"102\":1}}],[\"注意是通过一个线性层来同时计算qkv三个矩阵\",{\"1\":{\"102\":1}}],[\"注意力可视化\",{\"0\":{\"105\":1}}],[\"注意力矩阵的丢弃率\",{\"1\":{\"102\":1}}],[\"注意力头的数量\",{\"1\":{\"102\":1}}],[\"注意力机制的特性\",{\"1\":{\"99\":1}}],[\"注意力汇聚\",{\"1\":{\"99\":1}}],[\"注意下面的embed\",{\"1\":{\"98\":1}}],[\"注意事项\",{\"1\":{\"60\":1}}],[\"前向传播\",{\"1\":{\"99\":1}}],[\"前向传播函数\",{\"1\":{\"98\":1}}],[\"前馈层\",{\"1\":{\"71\":2,\"74\":2}}],[\"前馈神经网络\",{\"1\":{\"66\":1}}],[\"整体模型还是比较大的\",{\"1\":{\"107\":1}}],[\"整体结构图如下\",{\"1\":{\"107\":1}}],[\"整数\",{\"1\":{\"98\":2}}],[\"整个句子\",{\"1\":{\"65\":1}}],[\"整个函数\",{\"1\":{\"22\":1}}],[\"嵌入层维度\",{\"1\":{\"102\":1}}],[\"嵌入交互\",{\"1\":{\"99\":1}}],[\"嵌入的关系\",{\"1\":{\"99\":1}}],[\"嵌入\",{\"1\":{\"99\":1}}],[\"嵌入序列的开头\",{\"1\":{\"99\":1}}],[\"嵌入中\",{\"1\":{\"99\":1}}],[\"嵌入维度\",{\"1\":{\"98\":1,\"99\":1}}],[\"嵌入向量生成过程图\",{\"1\":{\"41\":1}}],[\"边长为该整数\",{\"1\":{\"98\":2}}],[\"步距为16\",{\"1\":{\"98\":1}}],[\"采用了一种更巧妙的解决思路\",{\"1\":{\"98\":1}}],[\"采样点数量\",{\"1\":{\"13\":1}}],[\"采样半径\",{\"1\":{\"13\":1}}],[\"采样得到的关键点坐标\",{\"1\":{\"13\":1}}],[\"采样的关键点数量\",{\"1\":{\"13\":2}}],[\"采样一些关键点\",{\"1\":{\"13\":1}}],[\"采样层\",{\"1\":{\"9\":1}}],[\"划分后可以得到共个patch\",{\"1\":{\"98\":1}}],[\"验证集上准确率达到了98\",{\"1\":{\"107\":1}}],[\"验证集不需要进行数据增强\",{\"1\":{\"97\":1}}],[\"验证集的预处理转换操作\",{\"1\":{\"97\":1}}],[\"长边按比例缩放\",{\"1\":{\"97\":1}}],[\"归一化层\",{\"1\":{\"98\":1}}],[\"归一化有助于模型更快地收敛\",{\"1\":{\"97\":1}}],[\"归纳偏置能够帮助学习算法缩小搜索范围\",{\"1\":{\"94\":1}}],[\"归纳偏置\",{\"1\":{\"94\":1}}],[\"第二个全连接层\",{\"1\":{\"101\":1}}],[\"第二个归一化层\",{\"1\":{\"101\":1}}],[\"第二个线性层再把高维特征映射回原来的维度\",{\"1\":{\"101\":1}}],[\"第二个参数\",{\"1\":{\"97\":1}}],[\"第一阶段设计了三个训练目标\",{\"1\":{\"91\":1}}],[\"第一层是一个叫做\",{\"1\":{\"24\":1}}],[\"第一个全连接层\",{\"1\":{\"101\":1}}],[\"第一个归一化层\",{\"1\":{\"101\":1}}],[\"第一个线性层将输入特征映射到更高维度的空间\",{\"1\":{\"101\":1}}],[\"第一个参数\",{\"1\":{\"97\":1}}],[\"第一个向量提供了更细致的信息\",{\"1\":{\"18\":1}}],[\"第一个点\",{\"1\":{\"13\":1}}],[\"范围\",{\"1\":{\"97\":2}}],[\"范围缩放到\",{\"1\":{\"97\":2}}],[\"范数\",{\"1\":{\"25\":2}}],[\"增加了图像的多样性\",{\"1\":{\"97\":1}}],[\"像素的图像块\",{\"1\":{\"107\":1}}],[\"像素\",{\"1\":{\"97\":2,\"107\":1}}],[\"像moco和simclr有所不同\",{\"1\":{\"80\":1}}],[\"静态方法是类中的一种特殊方法\",{\"1\":{\"96\":1}}],[\"官方实现的default\",{\"1\":{\"96\":1}}],[\"组合后的图像张量和标签张量\",{\"1\":{\"96\":1}}],[\"打开指定索引的图像文件\",{\"1\":{\"96\":1}}],[\"打破了这两个领域壁垒\",{\"1\":{\"94\":1}}],[\"默认使用\",{\"1\":{\"101\":1}}],[\"默认为0\",{\"1\":{\"102\":2}}],[\"默认为false\",{\"1\":{\"102\":1}}],[\"默认为8\",{\"1\":{\"102\":1}}],[\"默认为\",{\"1\":{\"96\":1,\"98\":5}}],[\"默认有\",{\"1\":{\"14\":1}}],[\"绘制每种类别个数柱状图\",{\"1\":{\"96\":1}}],[\"记录该类别的样本数量\",{\"1\":{\"96\":1}}],[\"记录输入长度\",{\"1\":{\"38\":1}}],[\"约4000多个样本\",{\"1\":{\"96\":1}}],[\"共5个类别\",{\"1\":{\"96\":1}}],[\"学习到输入数据的非线性特征\",{\"1\":{\"101\":1}}],[\"学习算法需要在所有可能的函数空间中搜索最优模型\",{\"1\":{\"94\":1}}],[\"学到的是一个关键点集合\",{\"1\":{\"29\":1}}],[\"学到的是一个\",{\"1\":{\"22\":1}}],[\"快速找到合适的模型\",{\"1\":{\"94\":1}}],[\"判断是否为交叉注意力\",{\"1\":{\"93\":1}}],[\"判断预测是否正确\",{\"1\":{\"84\":1}}],[\"调整张量形状以便多头注意力计算\",{\"1\":{\"93\":1}}],[\"调用\",{\"1\":{\"28\":1}}],[\"若qk\",{\"1\":{\"102\":1}}],[\"若为none则使用默认值\",{\"1\":{\"102\":1}}],[\"若有query\",{\"1\":{\"93\":1}}],[\"若以文本单词数量来衡量\",{\"1\":{\"81\":1}}],[\"词嵌入与位置嵌入相加\",{\"1\":{\"93\":1}}],[\"词性标注\",{\"1\":{\"61\":1}}],[\"负样本batch2=0\",{\"1\":{\"93\":1}}],[\"负样本batch2\",{\"1\":{\"93\":3}}],[\"负样本batch1=0\",{\"1\":{\"93\":1}}],[\"负样本batch1\",{\"1\":{\"93\":3}}],[\"双向自注意力\",{\"1\":{\"93\":1}}],[\"每一个向量作为一个单独的输入\",{\"1\":{\"98\":1}}],[\"每一个patch作为一个token\",{\"1\":{\"98\":1}}],[\"每一行表示一张图像和所有文本之间的相似度\",{\"1\":{\"92\":1}}],[\"每个图像块的尺寸\",{\"1\":{\"98\":1}}],[\"每个patch是三通道的小图片\",{\"1\":{\"98\":1}}],[\"每个几层\",{\"1\":{\"93\":1}}],[\"每个output\",{\"1\":{\"93\":1}}],[\"每个query\",{\"1\":{\"92\":1}}],[\"每个头64维\",{\"1\":{\"76\":1}}],[\"每个子层\",{\"1\":{\"66\":1}}],[\"每个位置的输出会通过一个独立的前馈神经网络进行进一步处理\",{\"1\":{\"66\":1}}],[\"每个\",{\"1\":{\"58\":3}}],[\"每个格子表示是否有物体\",{\"1\":{\"31\":1}}],[\"每个卷积层后跟一个\",{\"1\":{\"26\":1}}],[\"每个点通常包含\",{\"1\":{\"31\":1}}],[\"每个点都需要全局上下文\",{\"1\":{\"28\":1}}],[\"每个点有\",{\"1\":{\"24\":1,\"31\":1}}],[\"每个点到当前所有已选中心点的最小距离\",{\"1\":{\"13\":1}}],[\"每个结构中心点不变\",{\"1\":{\"17\":1}}],[\"每个关键点的多尺度特征表示\",{\"1\":{\"17\":1}}],[\"每个关键点对应的局部区域点和特征\",{\"1\":{\"13\":1}}],[\"每个尺度可以有不同的网络深度和宽度\",{\"1\":{\"17\":1}}],[\"每个尺度\",{\"1\":{\"16\":1}}],[\"每个半径定义了一个局部邻域的大小\",{\"1\":{\"16\":1}}],[\"每个查询点点局部特征\",{\"1\":{\"13\":1}}],[\"每个查询点对所有原始点的距离\",{\"1\":{\"13\":1}}],[\"每个邻域内采样的关键点数量\",{\"1\":{\"13\":2}}],[\"每个区域中点的数量𝐾和query的半径𝑟\",{\"1\":{\"11\":1}}],[\"仅训练分类头\",{\"1\":{\"107\":1}}],[\"仅借鉴了encoder结构\",{\"1\":{\"94\":1}}],[\"仅能和自己的\",{\"1\":{\"92\":1}}],[\"仅靠\",{\"1\":{\"29\":1}}],[\"仅靠局部特征很难判断某个点属于哪个部件\",{\"1\":{\"28\":1}}],[\"单一的线性层只能进行线性变换\",{\"1\":{\"101\":1}}],[\"单独用来处理类别信息\",{\"1\":{\"99\":1}}],[\"单模态自注意力\",{\"1\":{\"92\":1}}],[\"单尺度分组\",{\"1\":{\"14\":1}}],[\"单尺度分组分类模型\",{\"0\":{\"14\":1}}],[\"冻结参数的image\",{\"1\":{\"91\":1}}],[\"框架按照\",{\"1\":{\"90\":1}}],[\"具有较强的泛化能力\",{\"1\":{\"107\":1}}],[\"具有很强的zero\",{\"1\":{\"89\":1}}],[\"具体为vit\",{\"1\":{\"107\":1}}],[\"具体解释如下\",{\"1\":{\"100\":1}}],[\"具体方式可以是直接缩放\",{\"1\":{\"97\":1}}],[\"具体代码实现如下\",{\"1\":{\"85\":1}}],[\"具体使用的是\",{\"1\":{\"84\":1}}],[\"具体的实验结果可以参考clip公开的notebook\",{\"1\":{\"83\":1}}],[\"具体位置在\",{\"1\":{\"37\":1}}],[\"具体而言\",{\"1\":{\"18\":1}}],[\"具体来说\",{\"1\":{\"16\":1,\"100\":1}}],[\"具体做法\",{\"1\":{\"11\":1}}],[\"具体选择多少个中心点以及邻域内的数量由超参数确定\",{\"1\":{\"10\":1}}],[\"均冻结\",{\"1\":{\"89\":1}}],[\"均匀性假设\",{\"1\":{\"11\":1}}],[\"高\",{\"1\":{\"89\":1}}],[\"好\",{\"1\":{\"89\":3}}],[\"性能\",{\"1\":{\"89\":1}}],[\"轻\",{\"1\":{\"89\":7}}],[\"轻便\",{\"1\":{\"31\":1}}],[\"视觉分支\",{\"1\":{\"89\":1}}],[\"理想情况\",{\"1\":{\"89\":1}}],[\"理论上的限制\",{\"1\":{\"29\":1}}],[\"理论上证明\",{\"1\":{\"22\":1}}],[\"理论分析保证模型鲁棒性\",{\"1\":{\"22\":1}}],[\"侧重模态融合\",{\"1\":{\"89\":1}}],[\"重\",{\"1\":{\"89\":8}}],[\"重点训练图像和文本特征提取\",{\"1\":{\"89\":1}}],[\"重复\",{\"1\":{\"13\":1}}],[\"模式\",{\"1\":{\"96\":1}}],[\"模块可以看作是一个特征预处理模块\",{\"1\":{\"103\":1}}],[\"模块\",{\"1\":{\"89\":1,\"106\":1}}],[\"模态融合比较轻量\",{\"1\":{\"89\":1}}],[\"模态融合比较弱\",{\"1\":{\"89\":1}}],[\"模型能够学习到丰富的图像特征和模式\",{\"1\":{\"107\":1}}],[\"模型提取图像的特征图\",{\"1\":{\"106\":1}}],[\"模型自动学习到了如果注意画面中的分类主体\",{\"1\":{\"105\":1}}],[\"模型被强制学会将图像的有效信息汇聚到\",{\"1\":{\"99\":1}}],[\"模型更新参数\",{\"1\":{\"99\":1}}],[\"模型学会将图像中与分类任务相关的信息汇聚到\",{\"1\":{\"99\":1}}],[\"模型学会如何通过注意力机制将图像的有效信息汇聚到\",{\"1\":{\"99\":2}}],[\"模型计算每个\",{\"1\":{\"99\":1}}],[\"模型难以计算\",{\"1\":{\"98\":1}}],[\"模型的参数是根据这个特定尺寸的输入数据进行优化和学习的\",{\"1\":{\"97\":1}}],[\"模型名称\",{\"1\":{\"86\":1}}],[\"模型会对每个选项分别编码\",{\"1\":{\"62\":1}}],[\"模型需要从中选择最合适的答案\",{\"1\":{\"62\":1}}],[\"模型代表\",{\"1\":{\"60\":1}}],[\"模型代码解读与复现\",{\"0\":{\"4\":1}}],[\"模型那样逐词生成新内容\",{\"1\":{\"60\":1}}],[\"模型架构图\",{\"1\":{\"66\":1}}],[\"模型架构\",{\"0\":{\"39\":1,\"66\":1}}],[\"模型有点大\",{\"1\":{\"37\":1}}],[\"模型\",{\"1\":{\"31\":1,\"60\":1,\"81\":1}}],[\"模型为\",{\"1\":{\"31\":1}}],[\"模型表现良好\",{\"1\":{\"29\":1}}],[\"模型输出应不受刚性变换影响\",{\"1\":{\"21\":1}}],[\"模型必须对输入点的排列顺序不敏感\",{\"1\":{\"21\":1}}],[\"模型结构\",{\"0\":{\"8\":1,\"90\":1}}],[\"早期的图文多模态\",{\"1\":{\"89\":1}}],[\"融合模块\",{\"1\":{\"89\":2}}],[\"回顾下之前的多模态网络设计\",{\"1\":{\"89\":1}}],[\"回答\",{\"1\":{\"60\":1}}],[\"曾有一段时期一直在追求更大的网络架构\",{\"1\":{\"89\":1}}],[\"庖丁解牛vit\",{\"0\":{\"94\":1}}],[\"庖丁解牛blip2\",{\"0\":{\"88\":1},\"1\":{\"88\":1,\"93\":1}}],[\"庖丁解牛clip\",{\"0\":{\"78\":1}}],[\"排序\",{\"1\":{\"96\":1}}],[\"排序为\",{\"1\":{\"87\":1}}],[\"排列不变性\",{\"1\":{\"29\":1}}],[\"存储每个类别的样本总数\",{\"1\":{\"96\":1}}],[\"存储每次选出的\",{\"1\":{\"13\":1}}],[\"存储验证集图片对应索引信息\",{\"1\":{\"96\":1}}],[\"存储验证集的所有图片路径\",{\"1\":{\"96\":1}}],[\"存储训练集图片对应索引信息\",{\"1\":{\"96\":1}}],[\"存储训练集的所有图片路径\",{\"1\":{\"96\":1}}],[\"存在一定的噪声\",{\"1\":{\"87\":1}}],[\"新的问题出现了\",{\"1\":{\"87\":1}}],[\"新的文本\",{\"1\":{\"60\":1}}],[\"谷歌利用强大的计算能力进行了预训练\",{\"1\":{\"87\":1}}],[\"谷歌采用的弱监督方法与以往方法的一个主要区别在于规模\",{\"1\":{\"87\":1}}],[\"尽管谷歌基于jft\",{\"1\":{\"87\":1}}],[\"尽管clip是一个多模态模型\",{\"1\":{\"81\":1}}],[\"总体来看\",{\"1\":{\"87\":1}}],[\"总结表格\",{\"1\":{\"29\":1}}],[\"总结\",{\"0\":{\"108\":1},\"1\":{\"11\":1,\"22\":1,\"60\":1}}],[\"出现这种差异的原因不难理解\",{\"1\":{\"87\":1}}],[\"出现了一些基于自监督的方法\",{\"1\":{\"87\":1}}],[\"出来\",{\"1\":{\"60\":1}}],[\"近年来\",{\"1\":{\"87\":1}}],[\"搜索出来的图片\",{\"1\":{\"85\":1}}],[\"运行上述代码\",{\"1\":{\"85\":1}}],[\"遍历数据加载器中的每个批次数据\",{\"1\":{\"103\":1}}],[\"遍历获取supported支持的所有文件路径\",{\"1\":{\"96\":1}}],[\"遍历每个文件夹下的文件\",{\"1\":{\"96\":1}}],[\"遍历文件夹\",{\"1\":{\"96\":1}}],[\"遍历\",{\"1\":{\"85\":1,\"86\":1}}],[\"遍历data目录\",{\"1\":{\"85\":1}}],[\"拿到所有图片路径\",{\"1\":{\"85\":1}}],[\"下表中对比了vit\",{\"1\":{\"106\":1}}],[\"下面我们将进入训练流程\",{\"1\":{\"107\":1}}],[\"下面我们将用于图片变换的transforms流水线和上面自定义的mydataset类都封装到dataloader去\",{\"1\":{\"97\":1}}],[\"下面的3是因为我们用一次矩阵运算得到了拼接在一起的q\",{\"1\":{\"102\":1}}],[\"下面所给出的代码实现\",{\"1\":{\"102\":1}}],[\"下面来实际展示一下效果\",{\"1\":{\"85\":1}}],[\"下图展示了\",{\"1\":{\"93\":1}}],[\"下一个句子预测损失\",{\"1\":{\"56\":1}}],[\"找到与文本最匹配的图片\",{\"1\":{\"85\":1,\"86\":1}}],[\"找出最可能是\",{\"1\":{\"58\":1}}],[\"找出该尺度下每个质心点周围的邻近点\",{\"1\":{\"17\":1}}],[\"找出每个点的局部邻近点\",{\"1\":{\"13\":1}}],[\"找出它周围距离小于\",{\"1\":{\"13\":1}}],[\"针对每张图像\",{\"1\":{\"84\":1}}],[\"针对每个图像嵌入向量获取和其相似度最高的分类文本嵌入向量索引下标\",{\"1\":{\"84\":1}}],[\"针对每个图像嵌入向量取出和其相似度最高的那个文本嵌入向量的索引\",{\"1\":{\"84\":1}}],[\"子目录名的格式\",{\"1\":{\"84\":1}}],[\"子序列\",{\"1\":{\"60\":1}}],[\"递归遍历目录获取所有图片路径\",{\"1\":{\"84\":1,\"86\":1}}],[\"读取图片并将其转换为合适的格式后\",{\"1\":{\"84\":1}}],[\"版本\",{\"1\":{\"84\":1,\"97\":1}}],[\"版本代码\",{\"1\":{\"6\":2,\"19\":2}}],[\"检查图像是否为\",{\"1\":{\"96\":1}}],[\"检查当前目录是否有预训练权重文件\",{\"1\":{\"84\":1,\"86\":1}}],[\"检索等任务\",{\"1\":{\"29\":1}}],[\"本次训练是基于预训练好的vit\",{\"1\":{\"107\":1}}],[\"本节我们将基于clip预训练模型实现zero\",{\"1\":{\"84\":1}}],[\"本文将通过一个花卉分类的实战案例结合vit原论文\",{\"1\":{\"95\":1}}],[\"本文的transformer使用了self\",{\"1\":{\"65\":1}}],[\"本文基于\",{\"1\":{\"64\":1}}],[\"本文使用的是谷歌的中文预训练模型\",{\"1\":{\"37\":1}}],[\"花卉图片分类\",{\"0\":{\"84\":1}}],[\"紧密相关\",{\"1\":{\"83\":1}}],[\"进一步扩展了这个方法来预测n\",{\"1\":{\"87\":1}}],[\"进一步地\",{\"1\":{\"82\":1}}],[\"进行局部特征提取\",{\"1\":{\"106\":1}}],[\"进行反向传播\",{\"1\":{\"103\":1}}],[\"进行归一化\",{\"1\":{\"103\":1}}],[\"进行并行输入\",{\"1\":{\"98\":1}}],[\"进行编码\",{\"1\":{\"91\":2}}],[\"进行预训练\",{\"1\":{\"91\":1}}],[\"进行解压\",{\"1\":{\"37\":1}}],[\"进行分类\",{\"1\":{\"29\":1,\"61\":1}}],[\"进行特征学习\",{\"1\":{\"7\":1}}],[\"显然\",{\"1\":{\"82\":1}}],[\"显著提升了分割性能\",{\"1\":{\"22\":1}}],[\"此外\",{\"1\":{\"82\":1,\"83\":1,\"87\":1}}],[\"接下来\",{\"1\":{\"82\":1}}],[\"接近\",{\"1\":{\"29\":1}}],[\"推理时\",{\"1\":{\"91\":1}}],[\"推理\",{\"0\":{\"82\":1}}],[\"然而\",{\"1\":{\"81\":1,\"87\":3}}],[\"然后再经过一层\",{\"1\":{\"106\":1}}],[\"然后再拿到其它数据集上做迁移学习\",{\"1\":{\"104\":1}}],[\"然后输入到mlp\",{\"1\":{\"103\":1}}],[\"然后调整形状并重新排列维度\",{\"1\":{\"102\":1}}],[\"然后在训练过程中\",{\"1\":{\"100\":1}}],[\"然后在具体的下游任务上进行微调\",{\"1\":{\"87\":1}}],[\"然后进行水平翻转\",{\"1\":{\"97\":1}}],[\"然后计算出和当前文本描述相似度最高的那副图片\",{\"1\":{\"85\":1}}],[\"然后计算每个分类文本对应的文本嵌入向量\",{\"1\":{\"84\":1}}],[\"然后利用模型获取文本特征\",{\"1\":{\"84\":1}}],[\"然后我们读取要预测的图像\",{\"1\":{\"82\":1}}],[\"然后提取了相应的文本特征\",{\"1\":{\"82\":1}}],[\"然后\",{\"1\":{\"82\":1}}],[\"然后从中选出最合适的那个\",{\"1\":{\"62\":1}}],[\"然后启动\",{\"1\":{\"37\":1}}],[\"然后将\",{\"1\":{\"106\":1}}],[\"然后将特征图的最后两维展平为一维\",{\"1\":{\"98\":1}}],[\"然后将tf模型转为对应的pytorch版本即可\",{\"1\":{\"37\":1}}],[\"然后将这些不同尺度的特征拼接在一起\",{\"1\":{\"17\":1}}],[\"然后使用第一个cls\",{\"1\":{\"91\":1}}],[\"然后使用\",{\"1\":{\"29\":1}}],[\"然后使用全局最大池化\",{\"1\":{\"29\":1}}],[\"然后通过全连接层\",{\"1\":{\"27\":2}}],[\"然后通过对应的pointnets提取每个尺度上的特征来捕获多尺度模式\",{\"1\":{\"16\":1}}],[\"然后取\",{\"1\":{\"25\":1}}],[\"然后只保留前\",{\"1\":{\"13\":1}}],[\"然后复制这个索引数组到每个\",{\"1\":{\"13\":1}}],[\"然后把所有点映射到高维的特征通过最大池化最终表示全局特征\",{\"1\":{\"7\":1}}],[\"训练与评估流程的代码为模版代码\",{\"1\":{\"107\":1}}],[\"训练了10个epoch\",{\"1\":{\"107\":1}}],[\"训练过程中\",{\"1\":{\"99\":1}}],[\"训练目标的引导\",{\"1\":{\"99\":1}}],[\"训练集的预处理转换操作\",{\"1\":{\"97\":1}}],[\"训练代价\",{\"1\":{\"89\":1}}],[\"训练效率成为一个至关重要的因素\",{\"1\":{\"87\":1}}],[\"训练效率可以提高4倍\",{\"1\":{\"87\":1}}],[\"训练使用到的数据集和alexnet保持一致\",{\"1\":{\"84\":1}}],[\"训练\",{\"0\":{\"81\":1}}],[\"训练出具有可迁移能力的视觉模型\",{\"1\":{\"79\":1}}],[\"期望模型能够学习到文本和图像之间的匹配关系\",{\"1\":{\"80\":1}}],[\"借助对比学习机制\",{\"1\":{\"80\":1}}],[\"借助字典映射为word\",{\"1\":{\"38\":1}}],[\"介绍\",{\"0\":{\"80\":1}}],[\"同样可以比较好地记录二维信息\",{\"1\":{\"100\":1}}],[\"同样需要位置编码来记录各图像块之间的位置信息\",{\"1\":{\"100\":1}}],[\"同样\",{\"1\":{\"98\":1}}],[\"同样会将像素值从\",{\"1\":{\"97\":1}}],[\"同样是数据增强的手段\",{\"1\":{\"97\":1}}],[\"同样给计算机视觉领域带来了巨大影响\",{\"1\":{\"79\":1}}],[\"同时保留其捕捉长距离依赖的优势\",{\"1\":{\"106\":1}}],[\"同时作为特征数量\",{\"1\":{\"99\":1,\"100\":1,\"103\":1}}],[\"同时会将像素值从\",{\"1\":{\"97\":1}}],[\"同时因llm而具有了视觉推理能力\",{\"1\":{\"89\":1}}],[\"同时具有很好的性能\",{\"1\":{\"89\":1}}],[\"同时将flower\",{\"1\":{\"84\":1}}],[\"同时最小化个负样本的相似度\",{\"1\":{\"81\":1}}],[\"同时也指运用该方法构建的模型\",{\"1\":{\"80\":1}}],[\"同时计算self\",{\"1\":{\"65\":1}}],[\"同时确保这些分区的处理方式允许在它们之间共享模型权重\",{\"1\":{\"7\":1}}],[\"同时缺少\",{\"1\":{\"7\":1}}],[\"月发布的\",{\"1\":{\"79\":1}}],[\"年\",{\"1\":{\"79\":1}}],[\"年可谓是视觉\",{\"1\":{\"79\":1}}],[\"广泛应用于各类计算机视觉任务\",{\"1\":{\"79\":1}}],[\"广播\",{\"1\":{\"29\":1,\"76\":1}}],[\"众多基于视觉\",{\"1\":{\"79\":1}}],[\"引言\",{\"0\":{\"79\":1}}],[\"引入多尺度采样等\",{\"1\":{\"29\":1}}],[\"引入了两个变换网络\",{\"1\":{\"25\":1}}],[\"引入两个空间变换网络\",{\"1\":{\"22\":1}}],[\"引入\",{\"1\":{\"20\":1,\"22\":1,\"29\":1}}],[\"目的\",{\"1\":{\"92\":1,\"93\":1}}],[\"目的是让点云\",{\"1\":{\"24\":1}}],[\"目的是从一个大的数据集中选出一组代表性强的点\",{\"1\":{\"10\":1}}],[\"目标是训练好\",{\"1\":{\"91\":1}}],[\"目标掩码\",{\"1\":{\"75\":1}}],[\"目录获取所有图片路径\",{\"1\":{\"85\":1,\"86\":1}}],[\"源掩码\",{\"1\":{\"75\":1}}],[\"源注意力子层\",{\"1\":{\"74\":2}}],[\"各需要一个\",{\"1\":{\"71\":1,\"74\":1}}],[\"参考decoderlayer\",{\"1\":{\"70\":1}}],[\"参数与训练集的归一化参数相同\",{\"1\":{\"97\":1}}],[\"参数共享\",{\"1\":{\"29\":1}}],[\"参数\",{\"1\":{\"13\":1}}],[\"参数依赖\",{\"1\":{\"10\":1}}],[\"屏蔽填充部分的信息\",{\"1\":{\"66\":1}}],[\"掩码机制\",{\"1\":{\"66\":1}}],[\"残差连接\",{\"1\":{\"70\":1,\"101\":2}}],[\"残差连接与层归一化\",{\"1\":{\"66\":1}}],[\"残差链接\",{\"1\":{\"50\":1}}],[\"捕捉全局信息\",{\"1\":{\"106\":1}}],[\"捕捉不同子空间的信息\",{\"1\":{\"66\":1}}],[\"捕获密集到稀疏采样区域内的多尺度信息\",{\"1\":{\"17\":1}}],[\"环境\",{\"0\":{\"64\":1}}],[\"环境搭建遵从如下步骤即可\",{\"1\":{\"64\":1}}],[\"环境搭建\",{\"0\":{\"37\":1}}],[\"机器翻译实战\",{\"1\":{\"63\":1}}],[\"托尔斯泰\",{\"1\":{\"62\":1}}],[\"莎士比亚\",{\"1\":{\"62\":1}}],[\"莎士比亚是英国文学史上最伟大的作家之一\",{\"1\":{\"58\":1}}],[\"歌德\",{\"1\":{\"62\":1}}],[\"雨果\",{\"1\":{\"62\":1}}],[\"任务中\",{\"1\":{\"62\":1}}],[\"任务的本质\",{\"1\":{\"60\":1}}],[\"阅读理解任务\",{\"1\":{\"62\":1}}],[\"语义角色标注\",{\"1\":{\"61\":1}}],[\"命名实体识别\",{\"1\":{\"61\":1}}],[\"常见的迁移学习方法是首先在大规模数据集\",{\"1\":{\"87\":1}}],[\"常见的应用场景包括\",{\"1\":{\"61\":1,\"62\":1}}],[\"常见的对称函数\",{\"1\":{\"32\":1}}],[\"做attention\",{\"1\":{\"93\":1}}],[\"做\",{\"1\":{\"92\":1}}],[\"做分类\",{\"1\":{\"60\":1}}],[\"做的就是这个定位任务\",{\"1\":{\"60\":1}}],[\"能起作用的原因在于\",{\"1\":{\"99\":1}}],[\"能够通过多层\",{\"1\":{\"99\":1}}],[\"能够动态地聚合图像信息\",{\"1\":{\"99\":1}}],[\"能够更好地聚合图像信息\",{\"1\":{\"99\":1}}],[\"能够自适应地选择最适合的特征尺度进行组合\",{\"1\":{\"17\":1}}],[\"能否基于互联网上的大量文本来预训练视觉模型\",{\"1\":{\"87\":1}}],[\"能不能自己生成答案\",{\"1\":{\"60\":1}}],[\"自定义的批量数据处理函数\",{\"1\":{\"96\":1}}],[\"自定义数据集\",{\"1\":{\"96\":1}}],[\"自定义一个mydataset类来封装我们加载得到的数据集\",{\"1\":{\"96\":1}}],[\"自监督方法的优势在于不再需要标注数据\",{\"1\":{\"87\":1}}],[\"自谷歌提出\",{\"1\":{\"79\":1}}],[\"自注意力机制能够捕捉图像中任意两个\",{\"1\":{\"99\":1}}],[\"自注意力机制是\",{\"1\":{\"66\":1}}],[\"自注意力掩码策略\",{\"1\":{\"92\":1,\"93\":1}}],[\"自注意力子层\",{\"1\":{\"71\":2,\"74\":2}}],[\"自己写答案\",{\"1\":{\"60\":1}}],[\"自动跳过\",{\"1\":{\"60\":1}}],[\"示例\",{\"1\":{\"60\":1}}],[\"抽取式\",{\"1\":{\"60\":1}}],[\"抽取式问答\",{\"1\":{\"60\":1}}],[\"抽象\",{\"1\":{\"24\":1,\"26\":1}}],[\"抽象点集或局部特征\",{\"1\":{\"7\":2}}],[\"编码器隐藏层输出\",{\"1\":{\"75\":1}}],[\"编码器层\",{\"1\":{\"71\":1}}],[\"编码器\",{\"1\":{\"66\":1}}],[\"编码后得到输出的结果\",{\"1\":{\"93\":1}}],[\"编码后可能是\",{\"1\":{\"60\":1}}],[\"编码后\",{\"1\":{\"58\":1}}],[\"编造\",{\"1\":{\"60\":1}}],[\"必须落在上下文部分\",{\"1\":{\"60\":1}}],[\"必须自己学会对各种姿态都识别准确\",{\"1\":{\"24\":1}}],[\"假设你有一个问题\",{\"1\":{\"62\":1}}],[\"假设原始上下文是\",{\"1\":{\"60\":1}}],[\"假设空间中所有区域的尺度或特征分布具有一定的一致性\",{\"1\":{\"11\":1}}],[\"举个例子\",{\"1\":{\"60\":1}}],[\"举例说明\",{\"1\":{\"29\":1}}],[\"请把这部分原文告诉我\",{\"1\":{\"60\":1}}],[\"答案必须是原文中的一段文本\",{\"1\":{\"60\":1}}],[\"答案必须是原文中的连续片段\",{\"1\":{\"60\":1}}],[\"答案可以是任意文本\",{\"1\":{\"60\":1}}],[\"答案是原文中的一段\",{\"1\":{\"60\":1}}],[\"答案是否必须在原文中\",{\"1\":{\"60\":1}}],[\"答案应该在这段文字中的第\",{\"1\":{\"60\":1}}],[\"根据索引获取数据集中的图像和对应的标签\",{\"1\":{\"96\":1}}],[\"根据imagenet数据集上的zero\",{\"1\":{\"87\":1}}],[\"根据文字搜索图片\",{\"1\":{\"85\":1,\"86\":1}}],[\"根据上述计算得到的和其相似度最高的分类文本索引\",{\"1\":{\"84\":1}}],[\"根据任务的分类需求\",{\"1\":{\"82\":1}}],[\"根据decoder的隐状态输出一个词\",{\"1\":{\"68\":1}}],[\"根据编码器的输出生成目标序列\",{\"1\":{\"66\":1}}],[\"根据预测的\",{\"1\":{\"60\":1}}],[\"根据你的理解\",{\"1\":{\"60\":1}}],[\"根据注意力机制加权求和\",{\"1\":{\"32\":1}}],[\"解包数据\",{\"1\":{\"103\":1}}],[\"解码器层\",{\"1\":{\"74\":1}}],[\"解码器的最终输出通过一个线性层和\",{\"1\":{\"66\":1}}],[\"解码器\",{\"1\":{\"66\":1,\"75\":1}}],[\"解码成自然语言\",{\"1\":{\"60\":1}}],[\"解码成自然语言文本\",{\"1\":{\"60\":1}}],[\"解决点云姿态不一致问题\",{\"1\":{\"24\":1}}],[\"解决了点云处理中的四大技术难点\",{\"1\":{\"22\":1}}],[\"解决了两个问题\",{\"1\":{\"7\":1}}],[\"解决方案\",{\"0\":{\"22\":1}}],[\"部分\",{\"1\":{\"60\":1}}],[\"详细解释\",{\"1\":{\"60\":1}}],[\"易混淆\",{\"0\":{\"60\":1}}],[\"易于扩展为检测\",{\"1\":{\"29\":1}}],[\"未归一化\",{\"1\":{\"58\":1}}],[\"未经扰动训练时\",{\"1\":{\"29\":1}}],[\"另一种思路是在转换后\",{\"1\":{\"100\":1}}],[\"另一种是基于\",{\"1\":{\"81\":1}}],[\"另一个原因是nlp模型可以利用从互联网上收集的大量文本\",{\"1\":{\"87\":1}}],[\"另一个是作为答案结束的可能性\",{\"1\":{\"58\":1}}],[\"另一部分特征是通过在当前分辨率直接对所有原始点应用单个pointnet得到的\",{\"1\":{\"18\":1}}],[\"qk\",{\"1\":{\"100\":1,\"101\":2,\"102\":2,\"103\":2}}],[\"qkv\",{\"1\":{\"100\":1,\"101\":2,\"102\":8,\"103\":2}}],[\"q2t\",{\"1\":{\"92\":2}}],[\"qformer\",{\"1\":{\"91\":2,\"93\":1}}],[\"q\",{\"1\":{\"76\":1,\"91\":3,\"93\":2,\"102\":5}}],[\"qa\",{\"1\":{\"58\":2,\"59\":2,\"60\":1}}],[\"queries被用来从image\",{\"1\":{\"91\":1}}],[\"queries是一组可学习的embeddings\",{\"1\":{\"91\":1}}],[\"queries\",{\"1\":{\"91\":3,\"92\":1,\"93\":1}}],[\"query和query\",{\"1\":{\"92\":1}}],[\"query\",{\"1\":{\"13\":7,\"17\":2,\"49\":7,\"76\":9,\"85\":4,\"86\":4,\"91\":8,\"92\":2,\"93\":41}}],[\"query是基于欧氏距离的均匀性假设\",{\"1\":{\"11\":1}}],[\"query通过确保每个局部区域都有一个固定的尺度\",{\"1\":{\"11\":1}}],[\"query通过固定区域尺度而不是固定邻居数量来定义邻域\",{\"1\":{\"11\":1}}],[\"query找到该查询点在半径为𝑟范围内点\",{\"1\":{\"11\":1}}],[\"query来查询形心的邻居点\",{\"1\":{\"11\":1}}],[\"question\",{\"1\":{\"58\":1}}],[\"经过encoder之后\",{\"1\":{\"99\":1}}],[\"经过处理后的图像块嵌入张量\",{\"1\":{\"98\":1}}],[\"经过卷积层变成\",{\"1\":{\"98\":1}}],[\"经过预处理的图像和对应的标签\",{\"1\":{\"96\":1}}],[\"经过\",{\"1\":{\"60\":1,\"93\":1}}],[\"经过一层全连接后的输出\",{\"1\":{\"58\":1}}],[\"经过全局池化后得到一个全局特征向量\",{\"1\":{\"24\":1}}],[\"句子级别表示\",{\"1\":{\"58\":1}}],[\"包括\",{\"1\":{\"99\":1}}],[\"包括基于对比学习的方法\",{\"1\":{\"87\":1}}],[\"包括问题和上下文\",{\"1\":{\"58\":1}}],[\"包含大约\",{\"1\":{\"107\":1}}],[\"包含一个线性层和一个\",{\"1\":{\"103\":1}}],[\"包含分类token\",{\"1\":{\"102\":1}}],[\"包含图像和对应的标签\",{\"1\":{\"96\":1}}],[\"包含所有图像对应类别的列表\",{\"1\":{\"96\":1}}],[\"包含所有图像文件路径的列表\",{\"1\":{\"96\":1}}],[\"包含表面细节\",{\"1\":{\"31\":1}}],[\"包含两种适应性特征学习层\",{\"1\":{\"15\":1}}],[\"主干部分全部冻结\",{\"1\":{\"107\":1}}],[\"主要的区别就是去掉了paddding\",{\"1\":{\"102\":1}}],[\"主要区别在于norm层的顺序\",{\"1\":{\"101\":1}}],[\"主要包含encoder和decoder结构\",{\"1\":{\"94\":1}}],[\"主要是因为这些方法难以实现较高的性能\",{\"1\":{\"87\":1}}],[\"主要输出项解释\",{\"1\":{\"58\":1}}],[\"主页\",{\"0\":{\"0\":1}}],[\"你需要为每个选项分别构造一个完整的\",{\"1\":{\"62\":1}}],[\"你将得到一个包含多个元素的\",{\"1\":{\"58\":1}}],[\"你知道吗\",{\"1\":{\"28\":1}}],[\"等\",{\"1\":{\"106\":1}}],[\"等价于n个类别的cross\",{\"1\":{\"81\":1}}],[\"等会被\",{\"1\":{\"60\":1}}],[\"等著名悲剧\",{\"1\":{\"58\":1}}],[\"等基于图像的方法\",{\"1\":{\"29\":1}}],[\"麦克白\",{\"1\":{\"58\":1}}],[\"他写了包括\",{\"1\":{\"58\":1}}],[\"哈姆雷特\",{\"1\":{\"58\":2,\"62\":1}}],[\"谁写了\",{\"1\":{\"58\":1,\"62\":1}}],[\"例如在多头自注意力机制或前馈网络中引入卷积层\",{\"1\":{\"106\":1}}],[\"例如参数量为\",{\"1\":{\"104\":1}}],[\"例如clip\",{\"1\":{\"89\":1}}],[\"例如谷歌的bit和vit基于jft\",{\"1\":{\"87\":1}}],[\"例如2017年的那篇工作只在imagenet上实现了11\",{\"1\":{\"87\":1}}],[\"例如virtex基于transformer的语言模型\",{\"1\":{\"87\":1}}],[\"例如openai的gpt\",{\"1\":{\"87\":1}}],[\"例如\",{\"1\":{\"58\":1,\"82\":1,\"83\":1,\"87\":1,\"94\":1,\"106\":2}}],[\"典型的输入是一个包含\",{\"1\":{\"58\":1}}],[\"问答系统中的候选答案选择\",{\"1\":{\"62\":1}}],[\"问答任务\",{\"0\":{\"58\":1}}],[\"问题来了\",{\"1\":{\"87\":1}}],[\"问题\",{\"1\":{\"58\":3,\"60\":1,\"62\":2}}],[\"问题所在\",{\"1\":{\"29\":1}}],[\"问题背景\",{\"1\":{\"20\":1}}],[\"隐藏层输出\",{\"1\":{\"56\":1}}],[\"合并头结果\",{\"1\":{\"49\":1}}],[\"激活函数层\",{\"1\":{\"101\":1}}],[\"激活函数\",{\"1\":{\"43\":2,\"101\":1,\"103\":2}}],[\"含special\",{\"1\":{\"38\":1}}],[\"填充过程图\",{\"1\":{\"38\":1}}],[\"填充token对应0\",{\"1\":{\"38\":1}}],[\"真实token对应1\",{\"1\":{\"38\":1}}],[\"超长截断\",{\"1\":{\"38\":1}}],[\"|\",{\"1\":{\"38\":2}}],[\"||i\",{\"1\":{\"22\":1}}],[\"创建预输出层\",{\"1\":{\"103\":1}}],[\"创建归一化层\",{\"1\":{\"103\":1}}],[\"创建encoder\",{\"1\":{\"103\":1}}],[\"创建\",{\"1\":{\"101\":1}}],[\"创建丢弃层\",{\"1\":{\"100\":1,\"103\":1}}],[\"创建可学习的位置嵌入\",{\"1\":{\"100\":1,\"103\":1}}],[\"创建可学习的分类标记\",{\"1\":{\"99\":1,\"100\":1,\"103\":1}}],[\"创建图像块嵌入层\",{\"1\":{\"99\":1,\"100\":1,\"103\":1}}],[\"创建用以区分special\",{\"1\":{\"38\":1}}],[\"创建句子辨识列表\",{\"1\":{\"38\":1}}],[\"创建一个全零点作为\",{\"1\":{\"13\":1}}],[\"过长截断策略\",{\"1\":{\"38\":1}}],[\"态\",{\"1\":{\"38\":1}}],[\"破\",{\"1\":{\"38\":1}}],[\"突破transformer缺少归纳偏置的限制\",{\"1\":{\"94\":1}}],[\"突\",{\"1\":{\"38\":1}}],[\"票\",{\"1\":{\"38\":1}}],[\"股\",{\"1\":{\"38\":1}}],[\"股票中的突破形态\",{\"1\":{\"38\":2}}],[\"数量\",{\"1\":{\"98\":1}}],[\"数组转换为\",{\"1\":{\"97\":2}}],[\"数组后\",{\"1\":{\"84\":1}}],[\"数组格式返回\",{\"1\":{\"84\":1}}],[\"数据的分布更加稀疏\",{\"1\":{\"101\":1}}],[\"数据下载\",{\"0\":{\"96\":1}}],[\"数据集上进行预训练的\",{\"1\":{\"107\":1}}],[\"数据集中图像的数量\",{\"1\":{\"96\":1}}],[\"数据集中每一个样本最终都会解析得到一个inputfeatures\",{\"1\":{\"38\":1}}],[\"数据集加载代码\",{\"1\":{\"96\":1}}],[\"数据集下载\",{\"1\":{\"96\":1}}],[\"数据集\",{\"1\":{\"89\":1}}],[\"数据集预处理完后\",{\"1\":{\"38\":1}}],[\"数据预处理\",{\"0\":{\"38\":1}}],[\"数学定义\",{\"1\":{\"32\":1}}],[\"文字搜索图像\",{\"0\":{\"85\":1}}],[\"文字搜索图像实战演练\",{\"1\":{\"78\":1}}],[\"文件中的\",{\"1\":{\"64\":1}}],[\"文件进行调试即可\",{\"1\":{\"37\":1}}],[\"文本对\",{\"1\":{\"91\":1}}],[\"文本对应的标签\",{\"1\":{\"38\":1}}],[\"文本描述的生成也是一个关键环节\",{\"1\":{\"83\":1}}],[\"文本描述生成\",{\"0\":{\"83\":1}}],[\"文本编码器使用的是基于\",{\"1\":{\"84\":1}}],[\"文本编码器\",{\"1\":{\"81\":1,\"82\":1}}],[\"文本编码器的作用是提取文本的特征\",{\"1\":{\"81\":1}}],[\"文本分支\",{\"1\":{\"89\":2}}],[\"文本分词\",{\"1\":{\"38\":1}}],[\"文本分类任务\",{\"1\":{\"38\":1}}],[\"文中的𝐶所表示的其他信息\",{\"1\":{\"12\":1}}],[\"文中作者通过ball\",{\"1\":{\"11\":1}}],[\"准备调试\",{\"1\":{\"37\":1}}],[\"准备就绪\",{\"1\":{\"37\":1}}],[\"开发数据1k\",{\"1\":{\"37\":1}}],[\"开源项目\",{\"0\":{\"109\":1}}],[\"开源网络库\",{\"1\":{\"2\":1}}],[\"开源框架\",{\"1\":{\"2\":1}}],[\"测试图片分类正确率\",{\"1\":{\"84\":1,\"86\":1}}],[\"测试数据使用1k\",{\"1\":{\"37\":1}}],[\"测试和开发集\",{\"1\":{\"37\":1}}],[\"utils\",{\"1\":{\"96\":3,\"97\":2}}],[\"using\",{\"1\":{\"76\":1}}],[\"use\",{\"1\":{\"84\":1,\"86\":1,\"91\":1,\"102\":1}}],[\"used\",{\"1\":{\"38\":1,\"101\":1}}],[\"users\",{\"1\":{\"37\":1}}],[\"uni\",{\"1\":{\"92\":2,\"93\":1}}],[\"unicode\",{\"1\":{\"43\":1,\"53\":1}}],[\"unusual\",{\"1\":{\"49\":1}}],[\"unsqueeze\",{\"1\":{\"41\":1,\"46\":2,\"76\":1,\"92\":4}}],[\"unk\",{\"1\":{\"38\":2}}],[\"under\",{\"1\":{\"21\":1}}],[\"unordered\",{\"1\":{\"21\":1,\"32\":1}}],[\"w`代表输出特征图的宽和高\",{\"1\":{\"98\":1}}],[\"width\",{\"1\":{\"96\":1}}],[\"with\",{\"1\":{\"4\":1,\"38\":3,\"75\":1,\"82\":3,\"84\":2,\"86\":2,\"93\":1,\"96\":1}}],[\"write\",{\"1\":{\"96\":1}}],[\"world\",{\"1\":{\"93\":6}}],[\"words\",{\"1\":{\"41\":2,\"87\":3}}],[\"word\",{\"1\":{\"41\":2,\"93\":1}}],[\"warnings\",{\"1\":{\"86\":2}}],[\"walk\",{\"1\":{\"84\":1,\"86\":1}}],[\"white\",{\"1\":{\"82\":1}}],[\"which\",{\"1\":{\"49\":1}}],[\"w\",{\"1\":{\"76\":4,\"81\":5,\"91\":1,\"96\":1,\"98\":4,\"99\":1,\"100\":1,\"103\":1}}],[\"were\",{\"1\":{\"96\":1}}],[\"web\",{\"1\":{\"87\":1}}],[\"weakly\",{\"1\":{\"87\":1}}],[\"weights\",{\"1\":{\"46\":1,\"47\":1,\"54\":1,\"84\":2,\"86\":2,\"93\":5,\"103\":1,\"107\":5}}],[\"we\",{\"1\":{\"45\":1,\"47\":1,\"59\":1,\"76\":1,\"93\":2}}],[\"wget\",{\"1\":{\"37\":1}}],[\"就表示模型大约有\",{\"1\":{\"104\":1}}],[\"就意味着模型大约有\",{\"1\":{\"104\":1}}],[\"就是将传统cnn和transformer进行结合\",{\"1\":{\"106\":1}}],[\"就是两个线性层+gelu激活函数+dropout的结构\",{\"1\":{\"101\":1}}],[\"就是利用一个卷积核大小为16x16\",{\"1\":{\"98\":1}}],[\"就完成了从图片到token之间的转换\",{\"1\":{\"98\":1}}],[\"就有了很多先验信息\",{\"1\":{\"94\":1}}],[\"就点击这里直接下载\",{\"1\":{\"37\":1}}],[\"就更新它\",{\"1\":{\"13\":1}}],[\"按比例随机采样验证样本\",{\"1\":{\"96\":1}}],[\"按序执行以下命令完成环境搭建\",{\"1\":{\"37\":1}}],[\"按照16x16大小的patch进行划分\",{\"1\":{\"98\":1}}],[\"按照余弦相似度的数学公式来计算两者的相似度数值\",{\"1\":{\"84\":1}}],[\"按照最大相似度\",{\"1\":{\"82\":1}}],[\"按照本批次序列中最大长度进行截断\",{\"1\":{\"40\":1}}],[\"按照几个预定义的半径值来搜索周围的邻近点\",{\"1\":{\"16\":1}}],[\"按照不同的搜索半径或领域大小对点集进行分组\",{\"1\":{\"16\":1}}],[\"剪切\",{\"1\":{\"34\":1}}],[\"缩放因子\",{\"1\":{\"102\":1}}],[\"缩放\",{\"1\":{\"33\":1,\"34\":1}}],[\"弯曲\",{\"1\":{\"33\":1}}],[\"改为\",{\"1\":{\"64\":1}}],[\"改变\",{\"1\":{\"33\":1}}],[\"改进\",{\"1\":{\"29\":6}}],[\"移动\",{\"1\":{\"33\":1}}],[\"其他权重全部冻结\",{\"1\":{\"107\":1}}],[\"其他下游任务\",{\"0\":{\"57\":1}}],[\"其表达能力是有限的\",{\"1\":{\"101\":1}}],[\"其次\",{\"1\":{\"84\":1}}],[\"其次是准备训练数据\",{\"1\":{\"37\":1}}],[\"其均能匹配到正确的文本标签\",{\"1\":{\"82\":1}}],[\"其规模与gpt\",{\"1\":{\"81\":1}}],[\"其由七大主要部分构成\",{\"1\":{\"66\":1}}],[\"其形状和大小保持不变的运动方式\",{\"1\":{\"33\":1}}],[\"其中包括注意力可视化\",{\"1\":{\"105\":1}}],[\"其中的layers就是transformer\",{\"1\":{\"104\":1}}],[\"其中训练数据使用1k\",{\"1\":{\"37\":1}}],[\"其中\",{\"1\":{\"22\":1,\"79\":1,\"81\":1,\"98\":1}}],[\"物体在空间中移动时\",{\"1\":{\"33\":1}}],[\"物体分割和场景语义解析\",{\"1\":{\"20\":1}}],[\"刚性运动\",{\"0\":{\"33\":1},\"1\":{\"33\":3}}],[\"集合函数近似器\",{\"1\":{\"32\":1}}],[\"标准差\",{\"1\":{\"32\":1}}],[\"标准化的意义\",{\"1\":{\"24\":1}}],[\"标准化输入点云和特征空间\",{\"1\":{\"20\":1}}],[\"得出\",{\"1\":{\"32\":1}}],[\"得到结果如下图所示\",{\"1\":{\"105\":1}}],[\"得到预测结果\",{\"1\":{\"103\":1}}],[\"得到图像和对应的标签\",{\"1\":{\"103\":1}}],[\"得到每个注意力头的输出\",{\"1\":{\"102\":1}}],[\"得到每个预测类别的概率值\",{\"1\":{\"82\":1}}],[\"得到注意力权重矩阵\",{\"1\":{\"102\":1}}],[\"得到注意力分数矩阵\",{\"1\":{\"102\":1}}],[\"得到形状为\",{\"1\":{\"98\":3}}],[\"得到一个logit\",{\"1\":{\"93\":1}}],[\"得到相似度矩阵\",{\"1\":{\"92\":2}}],[\"得到相同维度的特征\",{\"1\":{\"81\":1}}],[\"得到概率\",{\"1\":{\"58\":1}}],[\"得到的预测概率如下所示\",{\"1\":{\"82\":1}}],[\"得到的就是答案\",{\"1\":{\"60\":1}}],[\"得到的特征可能无法覆盖整个物体\",{\"1\":{\"29\":1}}],[\"得到的质心\",{\"1\":{\"13\":1}}],[\"得到\",{\"1\":{\"14\":3,\"28\":1}}],[\"得到该区域的固定长度特征表示\",{\"1\":{\"13\":1}}],[\"乘积\",{\"1\":{\"32\":1}}],[\"求和\",{\"1\":{\"32\":1}}],[\"取每个位置的平均作为最终的匹配得分\",{\"1\":{\"93\":1}}],[\"取\",{\"1\":{\"93\":1}}],[\"取第一个cls\",{\"1\":{\"91\":1}}],[\"取出该行中得分最大的那一列\",{\"1\":{\"85\":1}}],[\"取出当前批次的图像列表\",{\"1\":{\"84\":1}}],[\"取出当前最远点的坐标\",{\"1\":{\"13\":1}}],[\"取最小值\",{\"1\":{\"32\":1}}],[\"取所有点的平均值\",{\"1\":{\"32\":1}}],[\"取所有点的最大值\",{\"1\":{\"32\":1}}],[\"那样我们总共有196个向量\",{\"1\":{\"98\":1}}],[\"那样逐层提取多层次的抽象特征\",{\"1\":{\"29\":1}}],[\"那就需要使用生成式模型\",{\"1\":{\"60\":1}}],[\"那么作者就想把注意力得到的结果\",{\"1\":{\"105\":1}}],[\"那么就会得到个文本特征\",{\"1\":{\"82\":1}}],[\"那么就是一个\",{\"1\":{\"32\":1}}],[\"那么\",{\"1\":{\"82\":1,\"98\":1}}],[\"那么clip的训练目标就是最大个正样本的相似度\",{\"1\":{\"81\":1}}],[\"那么对应的就是单词\",{\"1\":{\"60\":1}}],[\"那么可以组合这两个索引得到答案\",{\"1\":{\"58\":1}}],[\"设置柱状图的标题\",{\"1\":{\"96\":1}}],[\"设置y坐标\",{\"1\":{\"96\":1}}],[\"设置x坐标\",{\"1\":{\"96\":1}}],[\"设置的回调方法cllote\",{\"1\":{\"40\":1}}],[\"设是一个函数\",{\"1\":{\"32\":1}}],[\"设计局部\",{\"1\":{\"22\":1}}],[\"设计了一个统一架构\",{\"1\":{\"20\":1}}],[\"拓扑复杂\",{\"1\":{\"31\":1}}],[\"网格\",{\"1\":{\"31\":1}}],[\"网络输出由一个有限子集\",{\"1\":{\"22\":1}}],[\"网络不是只捕获一个尺度上的局部特征\",{\"1\":{\"16\":1}}],[\"网络对于每个选定的形心点\",{\"1\":{\"16\":1}}],[\"网络对每一个点做低维到高维的映射\",{\"1\":{\"7\":1}}],[\"网络在训练时被呈现了不同稀疏度的点集\",{\"1\":{\"16\":1}}],[\"网络的每一组set\",{\"1\":{\"8\":1}}],[\"网络的分割和分类模型\",{\"1\":{\"8\":1}}],[\"依赖视角选择\",{\"1\":{\"31\":1}}],[\"依赖初始点和距离度量方式的选择\",{\"1\":{\"10\":1}}],[\"丢失部分几何信息\",{\"1\":{\"31\":1}}],[\"精度受限\",{\"1\":{\"31\":1}}],[\"适当降低训练目标反而可能取得更好的效果\",{\"1\":{\"87\":1}}],[\"适合渲染\",{\"1\":{\"31\":1}}],[\"适合\",{\"1\":{\"31\":1}}],[\"适用于分类\",{\"1\":{\"20\":1}}],[\"处理的是点云数据\",{\"1\":{\"32\":1}}],[\"处理\",{\"1\":{\"31\":1}}],[\"处理点云数据\",{\"1\":{\"24\":1}}],[\"保存注意力头的数量\",{\"1\":{\"102\":1}}],[\"保存嵌入维度\",{\"1\":{\"99\":1,\"100\":1,\"103\":1}}],[\"保存分类任务的类别数\",{\"1\":{\"99\":1,\"100\":1,\"103\":1}}],[\"保证训练集和验证集的数据处理方式一致\",{\"1\":{\"97\":1}}],[\"保证顺序一致\",{\"1\":{\"96\":1}}],[\"保证随机结果可复现\",{\"1\":{\"96\":1}}],[\"保证变换是刚性的\",{\"1\":{\"24\":1}}],[\"保留和text\",{\"1\":{\"92\":2}}],[\"保留原始几何信息\",{\"1\":{\"31\":1}}],[\"简单来说\",{\"1\":{\"83\":1}}],[\"简洁\",{\"1\":{\"31\":1}}],[\"简析pointnet网络模型及其背后原理\",{\"1\":{\"19\":1}}],[\"简析pointnet\",{\"0\":{\"19\":1}}],[\"简析pointnet++\",{\"0\":{\"6\":1},\"1\":{\"6\":1}}],[\"坐标\",{\"1\":{\"31\":1}}],[\"坐标信息\",{\"1\":{\"31\":1}}],[\"强度\",{\"1\":{\"31\":1}}],[\"强制学习正交变换矩阵\",{\"1\":{\"29\":1}}],[\"法向量等属性\",{\"1\":{\"31\":1}}],[\"法向量\",{\"1\":{\"31\":1}}],[\"法线等\",{\"1\":{\"13\":1}}],[\"非常高\",{\"1\":{\"89\":2}}],[\"非均匀\",{\"1\":{\"33\":1}}],[\"非均匀密度下稳定的特征学习\",{\"0\":{\"15\":1}}],[\"非刚性运动\",{\"1\":{\"33\":1}}],[\"非刚性变形\",{\"1\":{\"29\":1}}],[\"非结构化\",{\"1\":{\"31\":1}}],[\"忽视局部邻域关系\",{\"1\":{\"29\":1}}],[\"忽略局部结构\",{\"1\":{\"29\":1}}],[\"忽略局部结构信息\",{\"1\":{\"29\":1}}],[\"忽略了局部邻域之间的结构关系\",{\"1\":{\"29\":1}}],[\"看不清细节\",{\"1\":{\"29\":1}}],[\"看不懂下面两行代码的话\",{\"1\":{\"13\":1}}],[\"极其高效\",{\"1\":{\"29\":1}}],[\"效率\",{\"1\":{\"29\":1}}],[\"效果对比\",{\"0\":{\"104\":1}}],[\"效果\",{\"1\":{\"22\":3}}],[\"略逊于多视角\",{\"1\":{\"29\":1}}],[\"支持的文件后缀类型\",{\"1\":{\"96\":1}}],[\"支持刚性变换标准化\",{\"1\":{\"29\":1}}],[\"支持原始点云\",{\"1\":{\"29\":1}}],[\"优势\",{\"1\":{\"29\":1}}],[\"少量点无法覆盖关键结构\",{\"1\":{\"29\":1}}],[\"图文对比\",{\"1\":{\"92\":1}}],[\"图片切割\",{\"0\":{\"98\":1}}],[\"图片预处理\",{\"0\":{\"97\":1}}],[\"图片库中的图片\",{\"1\":{\"85\":1}}],[\"图片分类\",{\"1\":{\"84\":1,\"86\":1}}],[\"图片分类实战\",{\"1\":{\"84\":1}}],[\"图解transformer\",{\"0\":{\"63\":1},\"1\":{\"63\":1}}],[\"图解bert\",{\"1\":{\"36\":1}}],[\"图解\",{\"0\":{\"36\":1}}],[\"图像到文本的桥梁\",{\"1\":{\"108\":1}}],[\"图像块嵌入层\",{\"1\":{\"99\":1}}],[\"图像块的尺寸\",{\"1\":{\"99\":1}}],[\"图像或\",{\"1\":{\"97\":2}}],[\"图像的索引\",{\"1\":{\"96\":1}}],[\"图像预处理的转换操作\",{\"1\":{\"96\":1}}],[\"图像特征提取和模态融合都很重\",{\"1\":{\"89\":1}}],[\"图像特征提取与分类\",{\"1\":{\"82\":1}}],[\"图像分支依赖目标检测器\",{\"1\":{\"89\":1}}],[\"图像分支\",{\"1\":{\"89\":1}}],[\"图像编码器采用了\",{\"1\":{\"84\":1}}],[\"图像对是从互联网收集的\",{\"1\":{\"87\":1}}],[\"图像对为负样本\",{\"1\":{\"81\":1}}],[\"图像对的相似度\",{\"1\":{\"81\":1}}],[\"图像对的训练batch\",{\"1\":{\"81\":1}}],[\"图像对的预训练方法\",{\"1\":{\"80\":1}}],[\"图像对\",{\"1\":{\"80\":1}}],[\"图像\",{\"1\":{\"31\":1,\"91\":1,\"98\":1}}],[\"图像处理或其他数据集中用于抽样的算法\",{\"1\":{\"10\":1}}],[\"图卷积\",{\"1\":{\"29\":1}}],[\"拼接机制不够精细\",{\"1\":{\"29\":1}}],[\"拼接方式缺乏动态调整机制\",{\"1\":{\"29\":1}}],[\"描述\",{\"1\":{\"29\":1,\"32\":1}}],[\"仍然不如分块处理或多层级聚合模型高效\",{\"1\":{\"29\":1}}],[\"异常检测\",{\"1\":{\"32\":1}}],[\"异常检测等特殊场景\",{\"1\":{\"32\":1}}],[\"异常点会影响分类和分割性能\",{\"1\":{\"29\":1}}],[\"异常值等问题\",{\"1\":{\"21\":1}}],[\"插入异常点\",{\"1\":{\"29\":1}}],[\"面对大量噪声点时效果较差\",{\"1\":{\"29\":1}}],[\"面部发生形变\",{\"1\":{\"29\":1}}],[\"尤其未训练时\",{\"1\":{\"29\":1}}],[\"尤其是在低层次上对每个质心点运行局部pointnet时\",{\"1\":{\"18\":1}}],[\"十二亿\",{\"1\":{\"104\":1}}],[\"十亿\",{\"1\":{\"104\":1}}],[\"十一\",{\"1\":{\"29\":1}}],[\"十\",{\"1\":{\"29\":1}}],[\"又会导致计算资源浪费\",{\"1\":{\"29\":1}}],[\"又理解整体结构\",{\"1\":{\"22\":1}}],[\"太大\",{\"1\":{\"29\":1}}],[\"太大则可能导致不相关的点增多\",{\"1\":{\"11\":1}}],[\"受限于瓶颈维度\",{\"1\":{\"29\":1}}],[\"九\",{\"1\":{\"29\":1}}],[\"都是197\",{\"1\":{\"101\":1}}],[\"都需要进行有监督微调\",{\"1\":{\"87\":1}}],[\"都使用了残差连接和层归一化\",{\"1\":{\"66\":1}}],[\"都单独构造一个\",{\"1\":{\"62\":1}}],[\"都等于max\",{\"1\":{\"38\":1}}],[\"都有一个对应的\",{\"1\":{\"58\":1}}],[\"都有\",{\"1\":{\"32\":1}}],[\"都尝试引入更复杂的结构来提升建模能力\",{\"1\":{\"29\":1}}],[\"都会被压缩为一个固定长度的特征向量\",{\"1\":{\"13\":1}}],[\"深度学习模型\",{\"1\":{\"29\":1}}],[\"八百六十万\",{\"1\":{\"104\":1}}],[\"八\",{\"1\":{\"29\":1}}],[\"特殊\",{\"1\":{\"60\":1}}],[\"特别是在遮挡严重的情况下\",{\"1\":{\"29\":1}}],[\"特征增强\",{\"1\":{\"32\":1}}],[\"特征融合\",{\"1\":{\"32\":1}}],[\"特征空间变换矩阵\",{\"1\":{\"26\":1}}],[\"特征变换开关\",{\"1\":{\"26\":1}}],[\"特征提取网络相对轻量\",{\"1\":{\"89\":1}}],[\"特征提取\",{\"0\":{\"26\":1}}],[\"特征编码\",{\"1\":{\"12\":1}}],[\"当提到模型参数量时\",{\"1\":{\"104\":1}}],[\"当数据量小于30m时\",{\"1\":{\"104\":1}}],[\"当\",{\"1\":{\"101\":1}}],[\"当我们在其他任务中使用预训练好的模型时\",{\"1\":{\"97\":1}}],[\"当使用\",{\"1\":{\"96\":1}}],[\"当cnn具有以上两种归纳偏置\",{\"1\":{\"94\":1}}],[\"当拥有足够多的数据进行预训练的时候\",{\"1\":{\"94\":1}}],[\"当文本和query\",{\"1\":{\"93\":1}}],[\"当输入点云非常稀疏时\",{\"1\":{\"29\":1}}],[\"当局部区域的密度较高时\",{\"1\":{\"18\":1}}],[\"当局部区域的密度较低时\",{\"1\":{\"18\":1}}],[\"七\",{\"1\":{\"29\":1}}],[\"正样本batch=1\",{\"1\":{\"93\":1}}],[\"正样本batch\",{\"1\":{\"93\":3}}],[\"正交变换包括\",{\"1\":{\"34\":1}}],[\"正交变换的本质是\",{\"1\":{\"34\":1}}],[\"正交变换\",{\"0\":{\"34\":1}}],[\"正是对这一缺陷的改进\",{\"1\":{\"29\":1}}],[\"正则化损失\",{\"0\":{\"25\":1}}],[\"缺乏具体的上下文\",{\"1\":{\"83\":1}}],[\"缺乏精细建模\",{\"1\":{\"29\":1}}],[\"缺乏层次化\",{\"1\":{\"29\":1}}],[\"缺乏层次化特征提取机制\",{\"1\":{\"29\":1}}],[\"缺乏动态上下文感知\",{\"1\":{\"29\":1}}],[\"缺陷对比\",{\"1\":{\"29\":1}}],[\"缺陷类型\",{\"1\":{\"29\":1}}],[\"缺陷\",{\"0\":{\"29\":1},\"1\":{\"29\":1}}],[\"六\",{\"1\":{\"29\":1}}],[\"基于\",{\"1\":{\"89\":1}}],[\"基于自回归或语言掩码的预训练方法已经相对成熟\",{\"1\":{\"87\":1}}],[\"基于上下文编码\",{\"1\":{\"60\":1}}],[\"基于图卷积或注意力机制的模型更能捕捉这种非刚性变化\",{\"1\":{\"29\":1}}],[\"基于以下前提\",{\"1\":{\"11\":1}}],[\"很难在这种情况下保持分类的一致性\",{\"1\":{\"29\":1}}],[\"拉伸等会导致形变的操作\",{\"1\":{\"34\":1}}],[\"拉伸等形变\",{\"1\":{\"29\":1}}],[\"拉伸\",{\"1\":{\"29\":1,\"33\":1}}],[\"旋转\",{\"1\":{\"29\":1,\"33\":2,\"34\":2}}],[\"五\",{\"1\":{\"29\":1}}],[\"体素网格\",{\"1\":{\"31\":1}}],[\"体素\",{\"1\":{\"29\":1}}],[\"方便后续的计算和比较\",{\"1\":{\"84\":1}}],[\"方法\",{\"1\":{\"29\":1,\"31\":1}}],[\"方向研究\",{\"1\":{\"2\":1}}],[\"四\",{\"1\":{\"29\":1}}],[\"🧪\",{\"1\":{\"29\":1,\"60\":1}}],[\"🧩\",{\"1\":{\"29\":2,\"60\":1}}],[\"🧱\",{\"1\":{\"29\":3}}],[\"🧠\",{\"1\":{\"25\":1,\"29\":1,\"32\":1}}],[\"难以自动构建\",{\"1\":{\"31\":1}}],[\"难以用\",{\"1\":{\"31\":1}}],[\"难以建模更高维度的空间关系\",{\"1\":{\"29\":1}}],[\"难以捕捉非刚性变换下的不变性\",{\"1\":{\"29\":1}}],[\"难以区分语义相近但位置不同的区域\",{\"1\":{\"29\":1}}],[\"难点\",{\"0\":{\"21\":1},\"1\":{\"22\":4}}],[\"⚠️\",{\"1\":{\"29\":1,\"32\":1,\"60\":1}}],[\"给出问题和上下文\",{\"1\":{\"60\":1}}],[\"给每个点\",{\"1\":{\"29\":1}}],[\"给定两个超参数\",{\"1\":{\"11\":1}}],[\"二分类task\",{\"0\":{\"93\":1}}],[\"二\",{\"1\":{\"29\":1}}],[\"二次sample\",{\"1\":{\"14\":1}}],[\"容易出错\",{\"1\":{\"29\":1}}],[\"虽然\",{\"1\":{\"29\":3}}],[\"虽然这个点没有实际意义\",{\"1\":{\"13\":1}}],[\"📚\",{\"1\":{\"60\":1}}],[\"📦\",{\"1\":{\"32\":1}}],[\"📌\",{\"1\":{\"29\":1}}],[\"📐\",{\"1\":{\"29\":1}}],[\"📊\",{\"1\":{\"29\":1}}],[\"📈\",{\"1\":{\"29\":2}}],[\"📉\",{\"1\":{\"29\":2}}],[\"💡\",{\"1\":{\"29\":1,\"60\":1}}],[\"🔍\",{\"1\":{\"29\":6,\"60\":1}}],[\"表征学习\",{\"0\":{\"91\":1},\"1\":{\"91\":1}}],[\"表达能力受限于\",{\"1\":{\"29\":1}}],[\"表现良好\",{\"1\":{\"29\":1}}],[\"表现不错\",{\"1\":{\"29\":1}}],[\"表明\",{\"1\":{\"29\":1}}],[\"表面纹理等\",{\"1\":{\"29\":1}}],[\"表示模型的规模\",{\"1\":{\"107\":1}}],[\"表示不进行归一化\",{\"1\":{\"98\":2}}],[\"表示每个图像块的大小是\",{\"1\":{\"97\":1}}],[\"表示将张量中的值限制在\",{\"1\":{\"59\":1}}],[\"表示形式\",{\"1\":{\"31\":1}}],[\"表示只在通道维度操作\",{\"1\":{\"24\":1}}],[\"表示\",{\"1\":{\"13\":1,\"24\":1,\"26\":1,\"38\":1}}],[\"曲率等细节\",{\"1\":{\"29\":1}}],[\"曲率\",{\"1\":{\"29\":1}}],[\"导致模型无法捕捉到更细粒度的几何细节\",{\"1\":{\"29\":1}}],[\"导致所有的特征\",{\"1\":{\"7\":1}}],[\"而预训练过程中使用的输入图像尺寸通常固定为\",{\"1\":{\"97\":1}}],[\"而通过引入特定的归纳偏置\",{\"1\":{\"94\":1}}],[\"而vit将其放到前面\",{\"1\":{\"101\":1}}],[\"而vit\",{\"1\":{\"94\":1}}],[\"而vit则选择了三种不同尺寸的模型\",{\"1\":{\"81\":1}}],[\"而这里我们将会反转这个逻辑\",{\"1\":{\"85\":1}}],[\"而最大的vit模型vit\",{\"1\":{\"81\":1}}],[\"而图像编码器\",{\"1\":{\"81\":1,\"82\":1}}],[\"而图像编码器则用于提取图像的特征\",{\"1\":{\"81\":1}}],[\"而剩余的个文本\",{\"1\":{\"81\":1}}],[\"而\",{\"1\":{\"79\":1}}],[\"而不能看到未来的词\",{\"1\":{\"66\":1}}],[\"而不是重新生成一个新的答案\",{\"1\":{\"60\":1}}],[\"而非生成答案\",{\"1\":{\"60\":1}}],[\"而是对输入文本中每个\",{\"1\":{\"60\":1}}],[\"而是能够捕获多个尺度上的局部特征\",{\"1\":{\"16\":1}}],[\"而点云是无序集合\",{\"1\":{\"32\":1}}],[\"而没有建模点与点之间的局部几何关系\",{\"1\":{\"29\":1}}],[\"只有一个特殊标记\",{\"1\":{\"99\":1,\"100\":1,\"103\":1}}],[\"只需要用一个一个linear即可\",{\"1\":{\"103\":1}}],[\"只需要将图像调整到合适的大小\",{\"1\":{\"97\":1}}],[\"只需要去除cls\",{\"1\":{\"47\":1}}],[\"只能对输入文本中的\",{\"1\":{\"60\":1}}],[\"只能处理刚性变换\",{\"1\":{\"29\":1}}],[\"只做抽取式问答\",{\"1\":{\"60\":1}}],[\"只包含\",{\"1\":{\"60\":1}}],[\"只改变物体的方向\",{\"1\":{\"34\":1}}],[\"只改变位置和朝向\",{\"1\":{\"33\":1}}],[\"只关注全局结构\",{\"1\":{\"29\":1}}],[\"只学正交变换\",{\"1\":{\"29\":1}}],[\"只通过\",{\"1\":{\"29\":1}}],[\"只要关键点还在\",{\"1\":{\"22\":1}}],[\"无论是有监督还是自监督方法\",{\"1\":{\"87\":1}}],[\"无论你如何打乱输入元素的顺序\",{\"1\":{\"32\":1}}],[\"无序性\",{\"1\":{\"31\":1}}],[\"无需预处理\",{\"1\":{\"29\":1}}],[\"无局部聚合机制\",{\"1\":{\"29\":1}}],[\"无法实现zero\",{\"1\":{\"87\":1}}],[\"无法\",{\"1\":{\"60\":1}}],[\"无法处理不在原文中的答案\",{\"1\":{\"60\":1}}],[\"无法处理非刚性变形\",{\"1\":{\"29\":1}}],[\"无法处理非刚性形变\",{\"1\":{\"29\":2}}],[\"无法充分利用\",{\"1\":{\"29\":1}}],[\"无法区分顺序信息\",{\"1\":{\"29\":1}}],[\"无法有效利用局部结构\",{\"1\":{\"29\":1}}],[\"无法捕捉边缘\",{\"1\":{\"29\":1}}],[\"无法应对弯曲\",{\"1\":{\"29\":1}}],[\"无法像\",{\"1\":{\"29\":1}}],[\"无法直接用于每个点\",{\"1\":{\"28\":1}}],[\"无效\",{\"1\":{\"13\":1}}],[\"座位\",{\"1\":{\"28\":1}}],[\"概率分布\",{\"1\":{\"28\":1}}],[\"则创建线性分类头\",{\"1\":{\"103\":1}}],[\"则使用\",{\"1\":{\"103\":1}}],[\"则使用默认的\",{\"1\":{\"103\":1}}],[\"则使用默认的缩放因子\",{\"1\":{\"102\":1}}],[\"则使用该层进行归一化\",{\"1\":{\"98\":2}}],[\"则默认为\",{\"1\":{\"101\":2}}],[\"则将其转换为\",{\"1\":{\"98\":1}}],[\"则将其设置为\",{\"1\":{\"59\":2}}],[\"则表示图像块是正方形\",{\"1\":{\"98\":1}}],[\"则表示图像是正方形\",{\"1\":{\"98\":1}}],[\"则对图像进行处理\",{\"1\":{\"96\":1}}],[\"则对整个点云做全局特征提取\",{\"1\":{\"13\":1}}],[\"则自动生成\",{\"1\":{\"93\":1}}],[\"则采用了两种不同的架构\",{\"1\":{\"81\":1}}],[\"则是以文本作为监督信号\",{\"1\":{\"79\":1}}],[\"则返回\",{\"1\":{\"26\":2}}],[\"再和真实标签做交叉熵损失\",{\"1\":{\"103\":1}}],[\"再乘以缩放因子scale\",{\"1\":{\"102\":1}}],[\"再次应用\",{\"1\":{\"101\":1}}],[\"再映射为\",{\"1\":{\"98\":1}}],[\"再来回顾我们的卷积层计算公式\",{\"1\":{\"98\":1}}],[\"再从中心位置裁剪成224x224\",{\"1\":{\"97\":1}}],[\"再进行归一化和标准化处理\",{\"1\":{\"97\":2}}],[\"再对每个选项做分类打分\",{\"1\":{\"62\":1}}],[\"再与每个点的局部特征拼接\",{\"1\":{\"28\":1}}],[\"再通过第一个卷积层提取初始特征\",{\"1\":{\"26\":1}}],[\"再用\",{\"1\":{\"13\":1}}],[\"预处理这个步骤在论文里并没有详细说明\",{\"1\":{\"97\":1}}],[\"预处理层\",{\"1\":{\"24\":1}}],[\"预测图像对应的文本的词袋模型\",{\"1\":{\"87\":1}}],[\"预测出一个变换矩阵\",{\"1\":{\"26\":1}}],[\"预训练权重大小为393mb\",{\"1\":{\"107\":1}}],[\"预训练模型很容易直接zero\",{\"1\":{\"87\":1}}],[\"预训练模型中\",{\"1\":{\"84\":1}}],[\"预训练模型名称\",{\"1\":{\"84\":1}}],[\"预训练模型下载下来之后\",{\"1\":{\"37\":1}}],[\"预训练与微调\",{\"1\":{\"52\":1}}],[\"预训练\",{\"0\":{\"52\":1}}],[\"控制是否使用\",{\"1\":{\"26\":1}}],[\"控制是否输出全局特征\",{\"1\":{\"26\":1}}],[\"鼓励变换矩阵接近正交矩阵\",{\"1\":{\"25\":1}}],[\"平滑处理\",{\"1\":{\"32\":1}}],[\"平均池化\",{\"1\":{\"32\":1}}],[\"平均值作为损失项\",{\"1\":{\"25\":1}}],[\"平移等变换具有鲁棒性\",{\"1\":{\"22\":1}}],[\"平移\",{\"1\":{\"21\":1,\"24\":1,\"33\":1}}],[\"平移中心到以关键点为原点的局部坐标系上\",{\"1\":{\"13\":1}}],[\"添加一维位置编码和二维位置编码并没有太大的差异\",{\"1\":{\"100\":1}}],[\"添加一个cross\",{\"1\":{\"93\":1}}],[\"添加位置编码\",{\"0\":{\"100\":1}}],[\"添加特殊token标记\",{\"1\":{\"38\":1}}],[\"添加\",{\"0\":{\"99\":1},\"1\":{\"25\":1}}],[\"❗而只有正交矩阵才能表示刚性变换\",{\"1\":{\"25\":1}}],[\"反过来计算text\",{\"1\":{\"92\":1}}],[\"反射\",{\"1\":{\"25\":1,\"29\":1,\"34\":1}}],[\"反之亦然\",{\"1\":{\"15\":1}}],[\"稳定的\",{\"1\":{\"24\":1}}],[\"会将输入图像分割成大小为\",{\"1\":{\"107\":1}}],[\"会将这些输入展平\",{\"1\":{\"62\":1}}],[\"会进行相应的错误提示并返回\",{\"1\":{\"84\":1}}],[\"会导致非正交\",{\"1\":{\"24\":1}}],[\"会影响特征提取的一致性\",{\"1\":{\"24\":1}}],[\"神经网络的输出在训练初期往往接近于零\",{\"1\":{\"24\":1}}],[\"后面的mlp是个单独的结构\",{\"1\":{\"101\":1}}],[\"后得到\",{\"1\":{\"93\":1}}],[\"后三种模型是按照efficientnet的缩放规则对resnet分别放大4倍\",{\"1\":{\"81\":1}}],[\"后的形式\",{\"1\":{\"58\":1}}],[\"后续再进行裁剪操作\",{\"1\":{\"97\":1}}],[\"后续的\",{\"1\":{\"29\":1}}],[\"后续的特征提取更稳定\",{\"1\":{\"24\":1}}],[\"后续发展\",{\"1\":{\"29\":1}}],[\"后续改进方向\",{\"1\":{\"29\":1}}],[\"后续改进\",{\"1\":{\"29\":1}}],[\"后\",{\"1\":{\"24\":1}}],[\"成多头格式\",{\"1\":{\"49\":1}}],[\"成\",{\"1\":{\"24\":1,\"62\":1}}],[\"成一个大的局部区域\",{\"1\":{\"13\":1}}],[\"让每个点都能看到上下文信息\",{\"1\":{\"26\":1,\"28\":1}}],[\"让变换矩阵从一个恒等变换开始学习\",{\"1\":{\"24\":1}}],[\"让模型自己学会区分不同的句子\",{\"1\":{\"41\":1}}],[\"让模型更容易训练和泛化\",{\"1\":{\"24\":1}}],[\"让模型既关注局部细节\",{\"1\":{\"22\":1}}],[\"让网络从一个小扰动开始学习\",{\"1\":{\"24\":1}}],[\"加载该模型后\",{\"1\":{\"107\":1}}],[\"加载预训练好的vit\",{\"1\":{\"107\":1}}],[\"加载预训练模型\",{\"0\":{\"107\":1}}],[\"加载模型和处理器\",{\"1\":{\"84\":1,\"86\":1}}],[\"加权和\",{\"1\":{\"32\":1}}],[\"加上位置嵌入并进行随机丢弃\",{\"1\":{\"100\":1,\"103\":1}}],[\"加上全局特征后\",{\"1\":{\"28\":1}}],[\"加上单位矩阵作为初始偏置\",{\"1\":{\"24\":1}}],[\"加单位矩阵\",{\"1\":{\"24\":1}}],[\"加入数据增强后缓解\",{\"1\":{\"29\":1}}],[\"加入\",{\"1\":{\"24\":1}}],[\"加入正则项约束变换矩阵接近正交\",{\"1\":{\"22\":1}}],[\"全连接再加上一个softmax\",{\"1\":{\"68\":1}}],[\"全连接层预测变换矩阵\",{\"1\":{\"24\":1}}],[\"全局信息\",{\"1\":{\"28\":1}}],[\"全局信息融合机制\",{\"1\":{\"22\":1}}],[\"全局特征表示\",{\"1\":{\"99\":1}}],[\"全局特征不能很好地反映每个点的上下文\",{\"1\":{\"29\":1}}],[\"全局特征不能直接用于分割\",{\"1\":{\"28\":1}}],[\"全局特征只有一份\",{\"1\":{\"28\":1}}],[\"全局特征\",{\"1\":{\"26\":1}}],[\"全局特征开关\",{\"1\":{\"26\":1}}],[\"全局特征都不一样了\",{\"1\":{\"7\":1}}],[\"全局最大池化\",{\"1\":{\"24\":1}}],[\"全局质心点\",{\"1\":{\"13\":1}}],[\"逐步聚合全局信息\",{\"1\":{\"99\":1}}],[\"逐步向正交矩阵靠拢\",{\"1\":{\"24\":1}}],[\"逐点\",{\"1\":{\"24\":1}}],[\"逐层抽象后融合成全局特征\",{\"1\":{\"17\":1}}],[\"有助于模型学习到不同方向的特征\",{\"1\":{\"97\":1}}],[\"有多少组点云\",{\"1\":{\"24\":1}}],[\"有些位置被标记为\",{\"1\":{\"13\":1}}],[\"获取输入张量x的形状\",{\"1\":{\"102\":1}}],[\"获取输入图像张量的形状\",{\"1\":{\"98\":1}}],[\"获取对应图像的标签\",{\"1\":{\"96\":1}}],[\"获取该类别对应的索引\",{\"1\":{\"96\":1}}],[\"获取其对应的图像嵌入向量列表\",{\"1\":{\"84\":1}}],[\"获取候选分类名列表\",{\"1\":{\"84\":1,\"86\":1}}],[\"获取选项个数\",{\"1\":{\"62\":1}}],[\"获取当前\",{\"1\":{\"24\":1}}],[\"获取全局区域特征向量后\",{\"1\":{\"14\":1}}],[\"帮助训练稳定收敛\",{\"1\":{\"24\":1}}],[\"95\",{\"1\":{\"84\":1}}],[\"90\",{\"1\":{\"29\":1}}],[\"9\",{\"1\":{\"24\":4,\"29\":1,\"37\":1,\"64\":1}}],[\"96\",{\"1\":{\"17\":1}}],[\"用一个简化版的例子说明上述过程\",{\"1\":{\"98\":1}}],[\"用文本描述去匹配最合适的图片内容\",{\"1\":{\"85\":1}}],[\"用当前图片外层目录的名字作为其分类名词\",{\"1\":{\"84\":1}}],[\"用户本地运行时\",{\"1\":{\"64\":1}}],[\"用以区分不同的句子\",{\"1\":{\"38\":1}}],[\"用\",{\"1\":{\"38\":1}}],[\"用全连接层逐步压缩到\",{\"1\":{\"24\":1}}],[\"用于同时生成查询\",{\"1\":{\"102\":1}}],[\"用于调整注意力分数\",{\"1\":{\"102\":1}}],[\"用于防止过拟合\",{\"1\":{\"101\":1}}],[\"用于随机深度\",{\"1\":{\"101\":1}}],[\"用于位置嵌入后的随机丢弃\",{\"1\":{\"100\":1,\"103\":1}}],[\"用于分类任务\",{\"1\":{\"99\":1}}],[\"用于预测图像的类别\",{\"1\":{\"99\":1}}],[\"用于存储训练集和验证集的图像预处理转换操作\",{\"1\":{\"97\":1}}],[\"用于将输入图像分割成多个图像块并进行嵌入\",{\"1\":{\"98\":1}}],[\"用于将一个方法定义为静态方法\",{\"1\":{\"96\":1}}],[\"用于将一个批次的数据组合成一个张量\",{\"1\":{\"96\":1}}],[\"用于将张量中的值限制在指定的范围内\",{\"1\":{\"59\":1}}],[\"用于计算交叉熵损失\",{\"1\":{\"62\":1}}],[\"用于指定在计算损失时忽略的标签索引\",{\"1\":{\"59\":1}}],[\"用于判断给出的两个句子是否连续\",{\"1\":{\"38\":1}}],[\"用于后续比较\",{\"1\":{\"25\":1}}],[\"用于后续计算其他点到该点的距离\",{\"1\":{\"13\":1}}],[\"用于\",{\"1\":{\"13\":1}}],[\"用于快速访问每个\",{\"1\":{\"13\":1}}],[\"卷积后剩余的长和宽相乘作为时间维度\",{\"1\":{\"98\":1}}],[\"卷积核个数为768的卷积层来进行实现\",{\"1\":{\"98\":1}}],[\"卷积\",{\"1\":{\"24\":1}}],[\"便于后续处理\",{\"1\":{\"24\":1}}],[\"便于广播到整个\",{\"1\":{\"25\":1}}],[\"便于广播\",{\"1\":{\"13\":1}}],[\"摆正\",{\"1\":{\"24\":1,\"26\":1}}],[\"类\",{\"1\":{\"98\":1}}],[\"类似\",{\"1\":{\"79\":1}}],[\"类似于在cnn中权重共享的概念\",{\"1\":{\"7\":1}}],[\"类型\",{\"1\":{\"60\":1}}],[\"类中\",{\"1\":{\"24\":1}}],[\"应该采用什么样的方法来进行训练\",{\"1\":{\"87\":1}}],[\"应该更高地加权第二个向量\",{\"1\":{\"18\":1}}],[\"应用自定义的权重初始化函数\",{\"1\":{\"103\":1}}],[\"应用\",{\"1\":{\"101\":1}}],[\"应用注意力掩码\",{\"1\":{\"93\":1}}],[\"应用场景\",{\"1\":{\"32\":1}}],[\"应用到原始点云上\",{\"1\":{\"24\":1}}],[\"变为\",{\"1\":{\"92\":3}}],[\"变形\",{\"1\":{\"33\":1}}],[\"变换不变性\",{\"1\":{\"29\":1}}],[\"变换矩阵会通过\",{\"1\":{\"24\":1}}],[\"变成1维度之后就成了50176\",{\"1\":{\"98\":1}}],[\"变成\",{\"1\":{\"13\":2,\"28\":1,\"62\":1}}],[\"变成特征向量\",{\"1\":{\"8\":1}}],[\"专门用于预测一个\",{\"1\":{\"24\":1}}],[\"扫描角度不同等\",{\"1\":{\"24\":1}}],[\"结束\",{\"1\":{\"60\":1}}],[\"结构\",{\"0\":{\"67\":1,\"69\":1,\"73\":1},\"1\":{\"66\":1}}],[\"结构规整\",{\"1\":{\"31\":1}}],[\"结构单一\",{\"1\":{\"29\":1}}],[\"结构简单\",{\"1\":{\"29\":1}}],[\"结果如下\",{\"1\":{\"104\":1}}],[\"结果如下图所示\",{\"1\":{\"100\":1}}],[\"结果发现在imagenet数据集上能够带来3\",{\"1\":{\"83\":1}}],[\"结果显示\",{\"1\":{\"29\":1}}],[\"结果就不会变\",{\"1\":{\"22\":1}}],[\"结合\",{\"1\":{\"22\":1}}],[\"7py1jdq1wp0nnyt3a\",{\"1\":{\"96\":1}}],[\"704\",{\"1\":{\"38\":2}}],[\"768\",{\"1\":{\"37\":3,\"43\":2,\"98\":4,\"99\":6,\"100\":4,\"101\":1,\"103\":4}}],[\"7\",{\"0\":{\"103\":1},\"1\":{\"22\":1}}],[\"分块并行处理\",{\"1\":{\"93\":1}}],[\"分批次预测\",{\"1\":{\"84\":1}}],[\"分批次从图像列表中取出一批图像\",{\"1\":{\"84\":1}}],[\"分数\",{\"1\":{\"58\":1}}],[\"分为训练\",{\"1\":{\"37\":1}}],[\"分割性能\",{\"1\":{\"29\":1}}],[\"分割精度不高\",{\"1\":{\"29\":1}}],[\"分割任务依赖拼接机制\",{\"1\":{\"29\":1}}],[\"分割任务\",{\"0\":{\"28\":1}}],[\"分类头\",{\"1\":{\"103\":1}}],[\"分类标记\",{\"1\":{\"99\":1,\"100\":1,\"103\":1}}],[\"分类性能\",{\"1\":{\"29\":1}}],[\"分类性能略逊于多视角方法\",{\"1\":{\"29\":1}}],[\"分类精度略低\",{\"1\":{\"29\":1}}],[\"分类准确率\",{\"1\":{\"29\":1}}],[\"分类准确率仅下降约\",{\"1\":{\"22\":1}}],[\"分类任务的类别数\",{\"1\":{\"99\":1}}],[\"分类任务是指对输入文本中的每个\",{\"1\":{\"61\":1}}],[\"分类任务中对缺失点具有一定鲁棒性\",{\"1\":{\"29\":1}}],[\"分类任务\",{\"0\":{\"27\":1}}],[\"分别如下\",{\"1\":{\"91\":1}}],[\"分别基于lenet\",{\"1\":{\"84\":1}}],[\"分别提取图像特征和文本特征\",{\"1\":{\"81\":1}}],[\"分别提取特征\",{\"1\":{\"17\":1}}],[\"分别计算答案起始下标和结束下标预测得到的交叉熵损失\",{\"1\":{\"59\":1}}],[\"分别是文本编码器\",{\"1\":{\"81\":1}}],[\"分别是\",{\"1\":{\"25\":1}}],[\"分别是最大值和它们的位置索引\",{\"1\":{\"13\":1,\"24\":1,\"26\":1}}],[\"决定\",{\"1\":{\"22\":1}}],[\"小结\",{\"0\":{\"87\":1}}],[\"小扰动不会改变函数输出\",{\"1\":{\"22\":1}}],[\"小红书\",{\"1\":{\"0\":1}}],[\"定义投影层的丢弃层\",{\"1\":{\"102\":1}}],[\"定义投影层\",{\"1\":{\"102\":1}}],[\"定义注意力矩阵的丢弃层\",{\"1\":{\"102\":1}}],[\"定义一个线性层\",{\"1\":{\"102\":1}}],[\"定义一个二维卷积层\",{\"1\":{\"98\":1}}],[\"定义一个字典\",{\"1\":{\"97\":1}}],[\"定义当前目录\",{\"1\":{\"84\":1,\"86\":1}}],[\"定义局部区域的形心\",{\"1\":{\"9\":1}}],[\"定位答案\",{\"1\":{\"60\":1}}],[\"定理表明\",{\"1\":{\"22\":1}}],[\"关于vit模型的不同版本\",{\"1\":{\"104\":1}}],[\"关于多头注意力机制流程不太清楚的\",{\"1\":{\"102\":1}}],[\"关于norm层\",{\"1\":{\"101\":1}}],[\"关于bertmodel的代码解析部分\",{\"1\":{\"93\":1}}],[\"关于这一领域的详细综述\",{\"1\":{\"83\":1}}],[\"关于我们\",{\"0\":{\"1\":1}}],[\"关键点可能丢失\",{\"1\":{\"29\":1}}],[\"关键点集\",{\"1\":{\"22\":1}}],[\"矩阵中的对角线元素\",{\"1\":{\"81\":1}}],[\"矩阵所有元素平方和开方\",{\"1\":{\"25\":1}}],[\"矩阵返回\",{\"1\":{\"24\":1}}],[\"矩阵\",{\"1\":{\"22\":2}}],[\"比较两个分类名词是否相等\",{\"1\":{\"84\":1}}],[\"比排序\",{\"1\":{\"22\":1}}],[\"比如一张224x224的图片\",{\"1\":{\"98\":1}}],[\"比如取到了问题部分的内容\",{\"1\":{\"60\":1}}],[\"比如对于一个长度为\",{\"1\":{\"58\":1}}],[\"比如边缘\",{\"1\":{\"29\":1}}],[\"比如椅子的腿\",{\"1\":{\"28\":1}}],[\"比如椅子朝向不同\",{\"1\":{\"24\":1}}],[\"比如法线\",{\"1\":{\"13\":1}}],[\"比如通过\",{\"1\":{\"13\":1}}],[\"比如颜色\",{\"1\":{\"13\":1}}],[\"函数生成目标序列的概率分布\",{\"1\":{\"66\":1}}],[\"函数\",{\"1\":{\"22\":1,\"32\":1,\"84\":1,\"86\":1,\"96\":1}}],[\"函数的作用是将整个点云视为一个\",{\"1\":{\"13\":1}}],[\"γ\",{\"1\":{\"22\":2}}],[\"≈\",{\"1\":{\"22\":1}}],[\"原始transformer的norm层在多头注意力和前馈网络之后\",{\"1\":{\"101\":1}}],[\"原始论文layernorm在最后\",{\"1\":{\"70\":1}}],[\"原始点集合\",{\"1\":{\"31\":1}}],[\"原始点云数据\",{\"1\":{\"14\":1}}],[\"原序列添加特殊token标记图\",{\"1\":{\"38\":1}}],[\"原理\",{\"0\":{\"95\":1}}],[\"原理回顾\",{\"1\":{\"29\":1}}],[\"原理说明\",{\"1\":{\"22\":1}}],[\"原因分析\",{\"1\":{\"29\":2}}],[\"聚合所有点的信息\",{\"1\":{\"22\":1,\"29\":1}}],[\"作者又探索了一种混合模型\",{\"1\":{\"106\":1}}],[\"作者使用了谷歌制作的jft\",{\"1\":{\"104\":1}}],[\"作者将vit和之前图像分类领域比较强的resnet模型进行了对比测试\",{\"1\":{\"104\":1}}],[\"作者先是在imagenet21k上进行预训练\",{\"1\":{\"103\":1}}],[\"作者随后也对一维位置编码的结果进行了可视化\",{\"1\":{\"100\":1}}],[\"作者最终选择了对比学习方法来进行训练\",{\"1\":{\"87\":1}}],[\"作者通过fps来抽样点集中较为重要的点\",{\"1\":{\"10\":1}}],[\"作为编码器\",{\"1\":{\"106\":1}}],[\"作为特征提取器\",{\"1\":{\"106\":1}}],[\"作为\",{\"1\":{\"91\":1}}],[\"作为图像的分类预测结果\",{\"1\":{\"82\":1}}],[\"作为答案开始的可能性\",{\"1\":{\"58\":1}}],[\"作为整个点云的\",{\"1\":{\"24\":1,\"26\":1}}],[\"作为对称函数\",{\"1\":{\"22\":1}}],[\"→\",{\"1\":{\"22\":4,\"24\":4}}],[\"✅\",{\"1\":{\"22\":5,\"24\":3,\"26\":2,\"28\":2,\"29\":12,\"32\":7,\"33\":1,\"58\":2,\"60\":4,\"62\":1}}],[\"稀疏性强\",{\"1\":{\"31\":1}}],[\"稀疏点云等任务中表现受限\",{\"1\":{\"29\":1}}],[\"稀疏点云下性能差\",{\"1\":{\"29\":1}}],[\"稀疏\",{\"1\":{\"21\":1}}],[\"避免了复杂的预处理\",{\"1\":{\"20\":1}}],[\"🌟\",{\"1\":{\"20\":1}}],[\"传统方法的缺陷\",{\"1\":{\"20\":1}}],[\"传统卷积神经网络难以直接处理\",{\"1\":{\"20\":1}}],[\"❌\",{\"1\":{\"20\":1,\"33\":1,\"60\":2}}],[\"核心要点\",{\"1\":{\"98\":1}}],[\"核心代码实现如下\",{\"1\":{\"93\":1}}],[\"核心问题\",{\"1\":{\"29\":1}}],[\"核心\",{\"0\":{\"20\":1}}],[\"完整代码\",{\"0\":{\"86\":1}}],[\"完整的单尺度分组分类流程为\",{\"1\":{\"14\":1}}],[\"完全支持\",{\"1\":{\"29\":1}}],[\"完成\",{\"1\":{\"18\":1}}],[\"更新特征数量为表示层的维度\",{\"1\":{\"103\":1}}],[\"更复杂的对称函数建模\",{\"1\":{\"32\":1}}],[\"更容易训练\",{\"1\":{\"24\":1}}],[\"更有效\",{\"1\":{\"22\":1}}],[\"更高分辨率\",{\"1\":{\"18\":1}}],[\"更易于管理的子集\",{\"1\":{\"7\":1}}],[\"首先说明\",{\"1\":{\"107\":1}}],[\"首先使用卷积层对输入图像进行处理\",{\"1\":{\"98\":1}}],[\"首先需要对输入图片进行尺寸变化\",{\"1\":{\"97\":1}}],[\"首先我们用data目录充当我们的图片库来源\",{\"1\":{\"85\":1}}],[\"首先\",{\"1\":{\"18\":1,\"82\":1,\"84\":1}}],[\"首次sample\",{\"1\":{\"14\":1}}],[\"某一层次𝐿𝑖的区域特征是通过将来自下一级𝐿𝑖−1的子区域特征总结后的向量与直接处理该局部区域所有原始点的单个pointnet得到的特征向量进行concat得到的\",{\"1\":{\"18\":1}}],[\"直接对图像进行分类\",{\"1\":{\"82\":2}}],[\"直接对所有点进行特征提取\",{\"1\":{\"13\":1}}],[\"直接以点集作为输入\",{\"1\":{\"20\":1}}],[\"直接处理的原始点特征\",{\"1\":{\"18\":1}}],[\"直接提取的特征\",{\"1\":{\"18\":1}}],[\"还不如直接预测词袋模型\",{\"1\":{\"87\":1}}],[\"还有另一个方向\",{\"1\":{\"87\":1}}],[\"还在336的分辨率下额外进行了一个周期的微调\",{\"1\":{\"81\":1}}],[\"还考虑了从更低分辨率\",{\"1\":{\"18\":1}}],[\"还小\",{\"1\":{\"13\":1}}],[\"多模态网络设计\",{\"1\":{\"89\":1}}],[\"多模态模型vit原理与图片分类实战演练\",{\"1\":{\"94\":1}}],[\"多模态模型在过往发展的过程中\",{\"1\":{\"89\":1}}],[\"多模态模型clip原理与图片分类\",{\"1\":{\"78\":1}}],[\"多模态\",{\"0\":{\"77\":1}}],[\"多项选择题\",{\"1\":{\"62\":1}}],[\"多项选择任务是指给定一个问题和多个候选答案\",{\"1\":{\"62\":1}}],[\"多项选择任务\",{\"0\":{\"62\":1}}],[\"多头自注意力层\",{\"1\":{\"101\":1}}],[\"多头自注意力\",{\"0\":{\"76\":1,\"102\":1}}],[\"多头自注意力机制通过并行计算多个注意力头\",{\"1\":{\"66\":1}}],[\"多头自注意力机制\",{\"1\":{\"51\":1,\"66\":1}}],[\"多头自注意力计算流程图\",{\"1\":{\"49\":1,\"76\":1}}],[\"多视角图像\",{\"1\":{\"31\":1}}],[\"多视角\",{\"1\":{\"29\":2}}],[\"多分辨率分组\",{\"0\":{\"18\":1},\"1\":{\"18\":1}}],[\"多尺度建模能力\",{\"1\":{\"29\":1}}],[\"多尺度聚合机制\",{\"1\":{\"29\":1}}],[\"多尺度特征提取机制\",{\"1\":{\"17\":1}}],[\"多尺度分组分类模型\",{\"0\":{\"17\":1}}],[\"多尺度分组\",{\"0\":{\"16\":1},\"1\":{\"15\":1,\"16\":1,\"17\":1}}],[\"5500\",{\"1\":{\"38\":2}}],[\"50\",{\"1\":{\"22\":1}}],[\"5\",{\"0\":{\"101\":1},\"1\":{\"17\":1,\"37\":1,\"41\":1,\"82\":1,\"83\":1,\"87\":1,\"96\":1,\"97\":19,\"102\":1,\"107\":1}}],[\"512\",{\"1\":{\"14\":6,\"17\":5,\"24\":3,\"27\":3,\"28\":3}}],[\"8600000\",{\"1\":{\"104\":1}}],[\"86×1000000\",{\"1\":{\"104\":1}}],[\"86m\",{\"1\":{\"104\":1}}],[\"8个头\",{\"1\":{\"76\":1}}],[\"89\",{\"1\":{\"29\":1}}],[\"85\",{\"1\":{\"29\":1}}],[\"8\",{\"1\":{\"17\":1,\"76\":1}}],[\"策略预训练轻量级查询\",{\"1\":{\"90\":1}}],[\"策略\",{\"1\":{\"17\":1}}],[\"生成类别名称以及对应的数字索引\",{\"1\":{\"96\":1}}],[\"生成比标签\",{\"1\":{\"92\":1}}],[\"生成文本嵌入\",{\"1\":{\"84\":1,\"86\":1}}],[\"生成的文本特征相当于分类器的权重\",{\"1\":{\"82\":1}}],[\"生成式\",{\"1\":{\"60\":2}}],[\"生成一个上下文相关的表示\",{\"1\":{\"60\":1}}],[\"生成\",{\"1\":{\"60\":1}}],[\"生成注意力掩码\",{\"1\":{\"38\":1}}],[\"生成padding部分的mask列表\",{\"1\":{\"38\":1}}],[\"生成固定长度的特征向量\",{\"1\":{\"17\":1}}],[\"生成点集的划分\",{\"1\":{\"7\":1}}],[\"jx\",{\"1\":{\"107\":1}}],[\"jax\",{\"1\":{\"107\":1}}],[\"javaer\",{\"1\":{\"2\":1}}],[\"jft\",{\"1\":{\"87\":2}}],[\"jpeg\",{\"1\":{\"84\":1,\"86\":1}}],[\"jpg\",{\"1\":{\"84\":1,\"86\":1,\"96\":2}}],[\"join\",{\"1\":{\"84\":3,\"85\":1,\"86\":4,\"96\":3}}],[\"json\",{\"1\":{\"37\":1,\"96\":6}}],[\"j\",{\"1\":{\"17\":3,\"84\":2,\"86\":2}}],[\"k矩阵乘积\",{\"1\":{\"105\":1}}],[\"k=int\",{\"1\":{\"96\":1}}],[\"k=2\",{\"1\":{\"27\":1}}],[\"k=64\",{\"1\":{\"26\":1}}],[\"k×k\",{\"1\":{\"25\":1}}],[\"keepdims=true\",{\"1\":{\"84\":1,\"86\":1}}],[\"keepdim=true\",{\"1\":{\"24\":1,\"26\":1,\"82\":2}}],[\"keep\",{\"1\":{\"61\":1}}],[\"key\",{\"1\":{\"49\":7,\"76\":7,\"93\":31,\"96\":2}}],[\"kernel\",{\"1\":{\"24\":1,\"98\":2}}],[\"k\",{\"1\":{\"17\":3,\"22\":1,\"27\":1,\"28\":11,\"29\":5,\"49\":2,\"76\":9,\"91\":1,\"93\":2,\"96\":2,\"102\":7}}],[\"knn查询寻找最近的k个邻居\",{\"1\":{\"11\":1}}],[\"knn\",{\"1\":{\"11\":1}}],[\"要采样的质心点数量\",{\"1\":{\"17\":1}}],[\"要么对所有点做操作\",{\"1\":{\"7\":1}}],[\"要么对一个点做操作\",{\"1\":{\"7\":1}}],[\"之前已经有一些研究工作探讨了使用文本作为监督信号来训练视觉模型\",{\"1\":{\"87\":1}}],[\"之间的关系\",{\"1\":{\"99\":1}}],[\"之间的平方欧氏距离\",{\"1\":{\"13\":1}}],[\"之间\",{\"1\":{\"59\":1}}],[\"之后\",{\"1\":{\"79\":1}}],[\"之后concat形成该区域提取的总特征\",{\"1\":{\"17\":1}}],[\"之后这些不同尺度上提取的特征被串联起来\",{\"1\":{\"16\":1}}],[\"来帮助大家梳理清楚vision\",{\"1\":{\"95\":1}}],[\"来自\",{\"1\":{\"93\":1}}],[\"来自论文的理论分析\",{\"1\":{\"29\":1}}],[\"来自下一级的特征\",{\"1\":{\"18\":1}}],[\"来完成点云物体分割任务\",{\"1\":{\"28\":1}}],[\"来完成点云分类任务\",{\"1\":{\"27\":1}}],[\"来模拟不同的采样密度\",{\"1\":{\"17\":1}}],[\"来学习优化的策略\",{\"1\":{\"16\":1}}],[\"来构建局部区域点集\",{\"1\":{\"9\":1}}],[\"称为随机输入丢弃\",{\"1\":{\"16\":1}}],[\"不需要创建类的实例\",{\"1\":{\"96\":1}}],[\"不使用传统的循环或卷积结构\",{\"1\":{\"66\":1}}],[\"不具备生成能力\",{\"1\":{\"60\":1}}],[\"不计入答案\",{\"1\":{\"60\":1}}],[\"不能\",{\"1\":{\"60\":1}}],[\"不能超出上下文范围\",{\"1\":{\"60\":1}}],[\"不能像\",{\"1\":{\"60\":1}}],[\"不是自回归生成器\",{\"1\":{\"60\":1}}],[\"不足长度用padding填充\",{\"1\":{\"38\":1}}],[\"不包括\",{\"1\":{\"34\":1}}],[\"不改变形状和大小\",{\"1\":{\"34\":1}}],[\"不改变物体形状和内部结构\",{\"1\":{\"33\":1}}],[\"不改变\",{\"1\":{\"33\":1}}],[\"不常用\",{\"1\":{\"32\":1,\"58\":1}}],[\"不够大\",{\"1\":{\"29\":1}}],[\"不够精细\",{\"1\":{\"29\":1}}],[\"不利于高维空间建模\",{\"1\":{\"29\":1}}],[\"不稳定\",{\"1\":{\"24\":1}}],[\"不同特征之间能够进行更多样的组合\",{\"1\":{\"101\":1}}],[\"不同模态数据的提取与融合\",{\"1\":{\"90\":1}}],[\"不同位置\",{\"1\":{\"24\":1}}],[\"不同尺度的查询半径列表\",{\"1\":{\"17\":1}}],[\"不同尺度的特征被串联形成多尺度特征向量\",{\"1\":{\"16\":1}}],[\"不做任何变化\",{\"1\":{\"24\":1}}],[\"不考虑空间邻域关系\",{\"1\":{\"24\":1}}],[\"不灵活等问题\",{\"1\":{\"20\":1}}],[\"不仅考虑从当前分辨率下抽象得到的特征\",{\"1\":{\"18\":1}}],[\"不进行采样\",{\"1\":{\"13\":1}}],[\"因此是自注意力\",{\"1\":{\"102\":1}}],[\"因此在新的数据集上需要定义新的分类器来重新训练\",{\"1\":{\"87\":1}}],[\"因此在效果上可能不如使用\",{\"1\":{\"83\":1}}],[\"因此成本较高\",{\"1\":{\"87\":1}}],[\"因此这里就不再给出数据集下载链接了\",{\"1\":{\"84\":1}}],[\"因此这是一个非常庞大的数据集\",{\"1\":{\"81\":1}}],[\"因此可以堆叠多个block\",{\"1\":{\"101\":1}}],[\"因此可以充分利用计算资源\",{\"1\":{\"65\":1}}],[\"因此可能比第二个向量更不可靠\",{\"1\":{\"18\":1}}],[\"因此出现了extended\",{\"1\":{\"65\":1}}],[\"因此需要大家自行完成运行时缺失依赖包的安装\",{\"1\":{\"37\":1}}],[\"因此每个质心将根据这些不同的半径值与其周围点形成多个点集群\",{\"1\":{\"16\":1}}],[\"因此\",{\"1\":{\"15\":1,\"87\":2,\"97\":1}}],[\"因为在代码中有个冻结权重的操作\",{\"1\":{\"107\":1}}],[\"因为transformer和cnn相比缺少归纳偏置\",{\"1\":{\"94\":1}}],[\"因为训练数据集中的文本\",{\"1\":{\"87\":1}}],[\"因为cuda不支持macos\",{\"1\":{\"64\":1}}],[\"因为我只是为了了解内部代码情况\",{\"1\":{\"37\":1}}],[\"因为它能够在更低层次上递归地检视更高分辨率\",{\"1\":{\"18\":1}}],[\"因为前面有\",{\"1\":{\"13\":1}}],[\"因为学习到的特征和权重可以在多个局部区域中复用\",{\"1\":{\"7\":1}}],[\"因为\",{\"1\":{\"7\":1,\"60\":1}}],[\"404\",{\"1\":{\"111\":1}}],[\"400m数据\",{\"1\":{\"89\":1}}],[\"4替换为相应的类别名称\",{\"1\":{\"96\":1}}],[\"48\",{\"1\":{\"84\":1}}],[\"4873\",{\"1\":{\"38\":2}}],[\"4788\",{\"1\":{\"38\":2}}],[\"4960\",{\"1\":{\"38\":2}}],[\"4638\",{\"1\":{\"38\":2}}],[\"4\",{\"0\":{\"100\":1},\"1\":{\"14\":3,\"17\":3,\"22\":1,\"41\":1,\"62\":1,\"76\":1,\"102\":1,\"107\":1}}],[\"三个模块\",{\"1\":{\"89\":1}}],[\"三\",{\"1\":{\"29\":1}}],[\"三次sample\",{\"1\":{\"14\":1}}],[\"三层分层特征学习结构\",{\"1\":{\"14\":1}}],[\"三部分组成\",{\"1\":{\"9\":1}}],[\"67b7e751e6b5931a9f45274653f4f653a4e6cdf6\",{\"1\":{\"96\":1}}],[\"62\",{\"1\":{\"84\":1}}],[\"64×64\",{\"1\":{\"22\":1}}],[\"640\",{\"1\":{\"17\":1}}],[\"64\",{\"1\":{\"14\":2,\"17\":7,\"24\":4,\"26\":3}}],[\"6\",{\"0\":{\"102\":1},\"1\":{\"14\":1,\"103\":2}}],[\"否则为恒等映射\",{\"1\":{\"103\":1}}],[\"否则存入训练集\",{\"1\":{\"96\":1}}],[\"否则答案可能不合理\",{\"1\":{\"60\":1}}],[\"否则\",{\"1\":{\"29\":1}}],[\"否则只有\",{\"1\":{\"14\":1}}],[\"否则使用恒等映射\",{\"1\":{\"101\":1}}],[\"否则使用\",{\"1\":{\"13\":1,\"98\":2}}],[\"zero\",{\"1\":{\"38\":2}}],[\"zeros\",{\"1\":{\"13\":2,\"41\":1,\"54\":1,\"93\":1,\"99\":1,\"100\":2,\"103\":2}}],[\"zhandaohong\",{\"1\":{\"37\":1}}],[\"zip\",{\"1\":{\"37\":2,\"40\":1,\"76\":1,\"96\":1}}],[\"z\",{\"1\":{\"14\":2,\"31\":2}}],[\"ylabel\",{\"1\":{\"96\":1}}],[\"y=v\",{\"1\":{\"96\":1}}],[\"y\",{\"1\":{\"14\":2,\"31\":2,\"60\":1}}],[\"yanx27\",{\"1\":{\"6\":1}}],[\"xlabel\",{\"1\":{\"96\":1}}],[\"x=i\",{\"1\":{\"96\":1}}],[\"xticks\",{\"1\":{\"96\":1}}],[\"xi\",{\"1\":{\"22\":1}}],[\"xn\",{\"1\":{\"22\":3}}],[\"x1\",{\"1\":{\"22\":3}}],[\"x\",{\"1\":{\"14\":12,\"17\":10,\"24\":29,\"26\":32,\"27\":10,\"28\":20,\"31\":2,\"49\":7,\"60\":1,\"68\":2,\"70\":3,\"71\":8,\"72\":4,\"74\":12,\"75\":4,\"76\":7,\"93\":7,\"98\":8,\"99\":14,\"100\":15,\"101\":21,\"102\":9,\"103\":19}}],[\"xyz\",{\"1\":{\"13\":60,\"14\":11,\"17\":31}}],[\"上面已经给出了数据集加载以及vit模型核心代码实现了\",{\"1\":{\"107\":1}}],[\"上面代码实现中使用的是可学习位置嵌入\",{\"1\":{\"100\":1}}],[\"上面的花卉分类案例相当于使用图像去匹配最合适的文本描述\",{\"1\":{\"85\":1}}],[\"上图中是每一个patch中各位置的位置编码相似性度量\",{\"1\":{\"100\":1}}],[\"上进行预训练\",{\"1\":{\"87\":1,\"97\":1}}],[\"上下文\",{\"1\":{\"58\":3}}],[\"上略低于\",{\"1\":{\"29\":1}}],[\"上\",{\"1\":{\"29\":1}}],[\"上做最大池化\",{\"1\":{\"13\":1}}],[\"上述即为pointnet++设计中的两个核心挑战\",{\"1\":{\"7\":1}}],[\"e5005f0a\",{\"1\":{\"107\":1}}],[\"eq\",{\"1\":{\"103\":1}}],[\"equivariance\",{\"1\":{\"94\":1}}],[\"equals\",{\"1\":{\"76\":1}}],[\"every\",{\"1\":{\"96\":5}}],[\"eval\",{\"1\":{\"37\":2}}],[\"emb\",{\"1\":{\"85\":2,\"86\":2}}],[\"embeds则拼接\",{\"1\":{\"93\":1}}],[\"embeds=none\",{\"1\":{\"93\":1}}],[\"embeds=query\",{\"1\":{\"91\":1,\"93\":1}}],[\"embeds\",{\"1\":{\"91\":4,\"93\":16}}],[\"embed\",{\"1\":{\"67\":8,\"81\":2,\"98\":9,\"99\":13,\"100\":15,\"102\":9,\"103\":17,\"107\":1}}],[\"embedding送到二分类器中\",{\"1\":{\"93\":1}}],[\"embedding\",{\"1\":{\"41\":3,\"46\":2,\"84\":4,\"85\":1,\"86\":3,\"93\":1,\"98\":1,\"100\":1}}],[\"embeddings和query\",{\"1\":{\"93\":1}}],[\"embeddings\",{\"1\":{\"41\":23,\"45\":1,\"46\":2,\"54\":1,\"56\":1,\"84\":12,\"85\":4,\"86\":15,\"91\":3,\"93\":17}}],[\"error\",{\"1\":{\"84\":2,\"85\":1,\"86\":3}}],[\"e\",{\"1\":{\"79\":3,\"81\":6,\"84\":4,\"85\":2,\"86\":6}}],[\"each\",{\"1\":{\"54\":1,\"72\":1}}],[\"exist\",{\"1\":{\"85\":1,\"86\":1,\"96\":1}}],[\"exists\",{\"1\":{\"84\":1,\"85\":1,\"86\":2,\"96\":1}}],[\"extension\",{\"1\":{\"84\":2,\"86\":2}}],[\"extended\",{\"1\":{\"46\":6}}],[\"exception\",{\"1\":{\"84\":2,\"85\":1,\"86\":3}}],[\"except\",{\"1\":{\"84\":2,\"85\":1,\"86\":3}}],[\"exp\",{\"1\":{\"81\":1}}],[\"expand\",{\"1\":{\"41\":1,\"91\":1,\"93\":1,\"99\":1,\"100\":1,\"103\":1}}],[\"export\",{\"1\":{\"37\":1}}],[\"epoch\",{\"1\":{\"103\":2}}],[\"epochs=4\",{\"1\":{\"37\":1}}],[\"eps=1e\",{\"1\":{\"103\":1}}],[\"eps=config\",{\"1\":{\"41\":1,\"43\":1,\"50\":1,\"53\":1}}],[\"epsilon\",{\"1\":{\"103\":1}}],[\"eps\",{\"1\":{\"41\":1,\"43\":1,\"50\":1,\"53\":1}}],[\"engineering\",{\"1\":{\"83\":1}}],[\"entropy\",{\"1\":{\"81\":3,\"92\":2,\"93\":1}}],[\"entire\",{\"1\":{\"49\":1}}],[\"encoding\",{\"1\":{\"66\":1}}],[\"encode\",{\"1\":{\"67\":2,\"82\":2}}],[\"encoder中mlp\",{\"1\":{\"104\":1}}],[\"encoder中重复堆叠encoder\",{\"1\":{\"104\":1}}],[\"encoder输出结果之后\",{\"1\":{\"103\":1}}],[\"encoder输出的embeddings里提取与input\",{\"1\":{\"91\":1}}],[\"encoder的结构\",{\"1\":{\"101\":1}}],[\"encoder提取的图像embeddings\",{\"1\":{\"91\":1}}],[\"encoder提取图像特征\",{\"1\":{\"82\":1}}],[\"encoder引到vision\",{\"1\":{\"90\":1}}],[\"encoder模型结构图\",{\"1\":{\"72\":1}}],[\"encoderlayer模型结构图\",{\"1\":{\"71\":1}}],[\"encoderlayer\",{\"0\":{\"71\":1},\"1\":{\"71\":2}}],[\"encoderdecoder\",{\"1\":{\"67\":2}}],[\"encoderdecoder模型结构图\",{\"1\":{\"67\":1}}],[\"encoder\",{\"0\":{\"67\":1,\"69\":1,\"72\":1,\"101\":1},\"1\":{\"46\":2,\"60\":3,\"66\":2,\"67\":4,\"72\":3,\"81\":8,\"82\":4,\"89\":2,\"91\":4,\"93\":17,\"99\":1}}],[\"encoded\",{\"1\":{\"38\":7}}],[\"end\",{\"1\":{\"58\":12,\"59\":14,\"60\":5,\"84\":4,\"86\":4}}],[\"enumerate\",{\"1\":{\"13\":1,\"17\":1,\"44\":1,\"84\":1,\"86\":1,\"96\":2,\"103\":1}}],[\"eye\",{\"1\":{\"25\":1}}],[\"elif\",{\"1\":{\"93\":1}}],[\"else\",{\"1\":{\"13\":4,\"14\":2,\"17\":3,\"26\":2,\"38\":2,\"40\":1,\"43\":1,\"47\":1,\"53\":1,\"61\":1,\"62\":3,\"84\":1,\"85\":1,\"86\":2,\"93\":7,\"96\":1,\"98\":1,\"101\":1,\"103\":1,\"107\":2}}],[\"elowen\",{\"0\":{\"3\":1}}],[\"层交错堆叠\",{\"1\":{\"106\":1}}],[\"层和\",{\"1\":{\"106\":1}}],[\"层处理后的输出\",{\"1\":{\"101\":1}}],[\"层的作用\",{\"1\":{\"58\":1}}],[\"层归一化\",{\"1\":{\"50\":1,\"75\":1}}],[\"层维度\",{\"1\":{\"29\":1}}],[\"层进一步融合局部\",{\"1\":{\"28\":1}}],[\"层\",{\"1\":{\"26\":1,\"101\":3}}],[\"层后面都加了\",{\"1\":{\"24\":1}}],[\"层构成了一个\",{\"1\":{\"14\":1}}],[\"层提取特征\",{\"1\":{\"13\":1}}],[\"层次化结构由多个set\",{\"1\":{\"9\":1}}],[\"层次化点集特征学习\",{\"0\":{\"9\":1}}],[\"+=\",{\"1\":{\"84\":1,\"86\":1,\"103\":2}}],[\"+\",{\"1\":{\"13\":2,\"14\":2,\"17\":6,\"22\":1,\"24\":2,\"28\":1,\"29\":3,\"32\":1,\"33\":1,\"34\":1,\"38\":21,\"41\":4,\"43\":1,\"47\":2,\"49\":3,\"50\":2,\"54\":1,\"56\":2,\"59\":2,\"60\":1,\"61\":1,\"62\":6,\"70\":4,\"71\":1,\"74\":4,\"75\":1,\"81\":1,\"82\":1,\"84\":2,\"86\":2,\"89\":1,\"92\":1,\"93\":12,\"96\":1,\"100\":2,\"101\":2,\"102\":11,\"103\":2}}],[\"质点数量\",{\"1\":{\"13\":1}}],[\"质心\",{\"1\":{\"13\":2}}],[\"选择最大值作为这个图文对的相似度\",{\"1\":{\"92\":1}}],[\"选择与图像特征相似度最高的文本所对应的类别\",{\"1\":{\"82\":1}}],[\"选择了一个包含6300万参数的transformer模型\",{\"1\":{\"81\":1}}],[\"选择𝑁个点\",{\"1\":{\"10\":1}}],[\"选项内容\",{\"1\":{\"62\":1}}],[\"选出\",{\"1\":{\"17\":1}}],[\"选关键点\",{\"1\":{\"13\":1}}],[\"输入到\",{\"1\":{\"106\":1}}],[\"输入到mlp\",{\"1\":{\"99\":1}}],[\"输入加上经过归一化和\",{\"1\":{\"101\":1}}],[\"输入加上经过归一化和注意力层处理后的输出\",{\"1\":{\"101\":1}}],[\"输入图像被分割成\",{\"1\":{\"99\":1}}],[\"输入图像的通道数\",{\"1\":{\"98\":1,\"99\":1}}],[\"输入图像的尺寸\",{\"1\":{\"98\":1,\"99\":1}}],[\"输入encoder的最左侧部分添加了一个0\",{\"1\":{\"99\":1}}],[\"输入的图像张量\",{\"1\":{\"98\":1}}],[\"输入的图片尺寸必须为224x224\",{\"1\":{\"97\":1}}],[\"输入的图片尺寸并不是自定义的\",{\"1\":{\"97\":1}}],[\"输入为\",{\"1\":{\"98\":1}}],[\"输入包含三部分\",{\"1\":{\"91\":1}}],[\"输入image\",{\"1\":{\"82\":1}}],[\"输入\",{\"1\":{\"75\":1}}],[\"输入序列\",{\"1\":{\"62\":1}}],[\"输入与输出的关系\",{\"1\":{\"60\":1}}],[\"输入会变成如下结构\",{\"1\":{\"58\":1}}],[\"输入格式\",{\"1\":{\"58\":1}}],[\"输入数据格式\",{\"1\":{\"38\":1}}],[\"输入形式\",{\"1\":{\"29\":1}}],[\"输入是原始点云\",{\"1\":{\"24\":1}}],[\"输入标准化\",{\"0\":{\"24\":1}}],[\"输入点云变换矩阵\",{\"1\":{\"26\":1}}],[\"输入点云变换网络\",{\"1\":{\"26\":1}}],[\"输入点云可能来自不同角度\",{\"1\":{\"24\":1}}],[\"输入点云可能缺失或含有异常点\",{\"1\":{\"22\":1}}],[\"输入点云可能缺失或包含噪声\",{\"1\":{\"21\":1}}],[\"输入点的特征维度\",{\"1\":{\"13\":1}}],[\"输出结果之后\",{\"1\":{\"103\":1}}],[\"输出结果都保持不变\",{\"1\":{\"32\":1}}],[\"输出通道\",{\"1\":{\"98\":1}}],[\"输出层\",{\"1\":{\"66\":1}}],[\"输出后\",{\"1\":{\"62\":1}}],[\"输出解释\",{\"1\":{\"58\":1}}],[\"输出做问答预测\",{\"1\":{\"58\":1}}],[\"输出是一个变换矩阵\",{\"1\":{\"24\":1}}],[\"输出类别数\",{\"1\":{\"14\":1}}],[\"输出形状为\",{\"1\":{\"13\":2}}],[\"输出\",{\"1\":{\"12\":1,\"26\":1,\"58\":1}}],[\"并按行优先排序来实现\",{\"1\":{\"108\":1}}],[\"并累加到累计正确样本数中\",{\"1\":{\"103\":1}}],[\"并取得不错的成效\",{\"1\":{\"94\":1}}],[\"并获得该批次图像列表对应的图像嵌入向量列表\",{\"1\":{\"84\":1}}],[\"并改造为a\",{\"1\":{\"84\":1}}],[\"并且取得了与卷积神经网络\",{\"1\":{\"108\":1}}],[\"并且与clip模型的训练数据不完全一致\",{\"1\":{\"83\":1}}],[\"并且在训练过程中采用了一个相对较大的批次大小\",{\"1\":{\"81\":1}}],[\"并计算与文本特征的余弦相似度\",{\"1\":{\"82\":1}}],[\"并将这些图像块嵌入到一个低维向量空间中\",{\"1\":{\"98\":1}}],[\"并将图片展示出来\",{\"1\":{\"85\":1}}],[\"并将其标记为vit\",{\"1\":{\"81\":1}}],[\"并将它们组合成一个批次进行处理\",{\"1\":{\"62\":1}}],[\"并将它们组织称为局部区域集\",{\"1\":{\"11\":1}}],[\"并进行l2归一化\",{\"1\":{\"81\":1}}],[\"并用\",{\"1\":{\"60\":1}}],[\"并重新命名为\",{\"1\":{\"37\":1}}],[\"并行优化\",{\"1\":{\"29\":1}}],[\"并不能保证这些矩阵是正交矩阵\",{\"1\":{\"25\":1}}],[\"并结合正则化损失\",{\"1\":{\"24\":1}}],[\"并通过模型进行前向传播\",{\"1\":{\"103\":1}}],[\"并通过线性变换映射到嵌入空间\",{\"1\":{\"99\":1}}],[\"并通过局部+全局特征融合机制实现强大的点云建模能力\",{\"1\":{\"22\":1}}],[\"并通过一个小型\",{\"1\":{\"13\":1}}],[\"并最终输出分类结果\",{\"1\":{\"14\":1}}],[\"大家可以自行拉取项目完整代码进行学习\",{\"1\":{\"107\":1}}],[\"大家注意区分\",{\"1\":{\"91\":1}}],[\"大于\",{\"1\":{\"101\":1}}],[\"大致上两者结构是相同的\",{\"1\":{\"101\":1}}],[\"大小的图像\",{\"1\":{\"97\":1}}],[\"大小\",{\"1\":{\"97\":1}}],[\"大小不超过\",{\"1\":{\"22\":1}}],[\"大大提高学习效率\",{\"1\":{\"94\":1}}],[\"大幅降低训练成本\",{\"1\":{\"89\":1}}],[\"大放异彩的一年\",{\"1\":{\"79\":1}}],[\"大语言模型\",{\"0\":{\"35\":1}}],[\"大区域\",{\"1\":{\"13\":1}}],[\"大局部区域\",{\"1\":{\"13\":1}}],[\"是hidden\",{\"1\":{\"104\":1}}],[\"是图像块的总数\",{\"1\":{\"98\":1}}],[\"是图像宽度\",{\"1\":{\"98\":1}}],[\"是图像高度\",{\"1\":{\"98\":1}}],[\"是图像每个通道的标准差\",{\"1\":{\"97\":1}}],[\"是图像每个通道的均值\",{\"1\":{\"97\":1}}],[\"是通道数\",{\"1\":{\"98\":1}}],[\"是批量大小\",{\"1\":{\"98\":1}}],[\"是卷积核的步长\",{\"1\":{\"98\":1}}],[\"是卷积核的大小\",{\"1\":{\"98\":1}}],[\"是输出通道数\",{\"1\":{\"98\":1}}],[\"是输入通道数\",{\"1\":{\"98\":1}}],[\"是第一个transformer模块的input\",{\"1\":{\"91\":1}}],[\"是基于文本输入来生成图像的模型\",{\"1\":{\"79\":1}}],[\"是编码器模型\",{\"1\":{\"60\":1}}],[\"是模型预测出的答案的起始和结束位置\",{\"1\":{\"60\":1}}],[\"是模型最后一层所有\",{\"1\":{\"58\":1}}],[\"是答案终点的得分\",{\"1\":{\"58\":1}}],[\"是答案起点的得分\",{\"1\":{\"58\":1}}],[\"是序列实际长度\",{\"1\":{\"38\":1}}],[\"是当前文本对应的类别标签\",{\"1\":{\"38\":1}}],[\"是指位置嵌入的参数是可以在模型训练过程中通过反向传播算法进行更新的\",{\"1\":{\"100\":1}}],[\"是指\",{\"1\":{\"33\":1}}],[\"是否在生成q\",{\"1\":{\"102\":1}}],[\"是否能生成新文本\",{\"1\":{\"60\":1}}],[\"是否可微\",{\"1\":{\"32\":1}}],[\"是否被后续模型改进\",{\"1\":{\"29\":1}}],[\"是否包含法线信息\",{\"1\":{\"14\":1}}],[\"是一个大规模的图像数据集\",{\"1\":{\"107\":1}}],[\"是一个随机初始化的向量\",{\"1\":{\"99\":1}}],[\"是一个\",{\"1\":{\"60\":2}}],[\"是一个线性层\",{\"1\":{\"58\":1}}],[\"是一个小型神经网络\",{\"1\":{\"24\":1}}],[\"是一种基于自注意力机制\",{\"1\":{\"66\":1}}],[\"是一种对输入顺序不敏感的函数\",{\"1\":{\"32\":1}}],[\"是一种表示三维空间中物体或场景的方式\",{\"1\":{\"31\":1}}],[\"是一种单尺度网络\",{\"1\":{\"29\":1}}],[\"是为了扩展成\",{\"1\":{\"25\":1}}],[\"是最大可容忍的点云范围\",{\"1\":{\"22\":1}}],[\"是关键点集合\",{\"1\":{\"22\":1}}],[\"是对称的\",{\"1\":{\"22\":1}}],[\"是后续的全连接网络\",{\"1\":{\"22\":1}}],[\"是每个点的高维特征\",{\"1\":{\"22\":1}}],[\"是\",{\"1\":{\"13\":2,\"22\":1,\"25\":1,\"32\":7,\"58\":1,\"59\":1,\"96\":1}}],[\"终输出的\",{\"1\":{\"13\":1}}],[\"颜色\",{\"1\":{\"13\":1,\"31\":1}}],[\"颜色等\",{\"1\":{\"13\":1}}],[\"去填充这些空缺\",{\"1\":{\"13\":1}}],[\"我将两者的结构进行对比\",{\"1\":{\"101\":1}}],[\"我们通过自定义一个patchembed类完成上述工作\",{\"1\":{\"98\":1}}],[\"我们通过利用clip模型的多模态能力\",{\"1\":{\"82\":1}}],[\"我们首先获取图片库中所有图片\",{\"1\":{\"85\":1}}],[\"我们首先创建了各类别的文本描述\",{\"1\":{\"82\":1}}],[\"我们只需要在计算出相似度得分矩阵后\",{\"1\":{\"85\":1}}],[\"我们从flower\",{\"1\":{\"84\":1}}],[\"我们从原始输入的\",{\"1\":{\"60\":1}}],[\"我们需要根据上面给出的花卉数据集下载链接\",{\"1\":{\"84\":1}}],[\"我们常常需要衡量文本嵌入和图片嵌入之间的相似度\",{\"1\":{\"84\":1}}],[\"我们可以直接使用类别标签作为文本描述\",{\"1\":{\"83\":1}}],[\"我们还有其他的选择\",{\"1\":{\"83\":1}}],[\"我们使用了\",{\"1\":{\"83\":1}}],[\"我们也可以对得到的余弦相似度计算softmax\",{\"1\":{\"82\":1}}],[\"我们已经探讨了clip模型的运作机制\",{\"1\":{\"82\":1}}],[\"我们主要使用它来预测答案的起始和结束位置\",{\"1\":{\"58\":1}}],[\"我们就用该查询点最近的那个点\",{\"1\":{\"13\":1}}],[\"我的调试文件是run\",{\"1\":{\"37\":1}}],[\"我已经上传到了仓库中\",{\"1\":{\"37\":1}}],[\"我就不上传了\",{\"1\":{\"37\":1}}],[\"我不感兴趣\",{\"1\":{\"13\":1}}],[\"所具备的\",{\"1\":{\"94\":1}}],[\"所提供的代码展开进行讲解\",{\"1\":{\"64\":1}}],[\"所参考源仓库未提供requirements\",{\"1\":{\"37\":1}}],[\"所以参数量为\",{\"1\":{\"104\":1}}],[\"所以模型的任务是\",{\"1\":{\"60\":1}}],[\"所以模型必须具有对点顺序的不变性\",{\"1\":{\"32\":1}}],[\"所以最终的答案只能来自原始输入文本中的某一段子串\",{\"1\":{\"60\":1}}],[\"所以我只是取其中的一部分数据\",{\"1\":{\"37\":1}}],[\"所以我们需要加一个正则化项来鼓励变换矩阵接近正交矩阵\",{\"1\":{\"25\":1}}],[\"所以准确度不是在我的考虑范围之内\",{\"1\":{\"37\":1}}],[\"所以\",{\"1\":{\"34\":1}}],[\"所以要把它复制\",{\"1\":{\"28\":1}}],[\"所以小的才是有效点\",{\"1\":{\"13\":1}}],[\"所有logits的平均作为最终的matching\",{\"1\":{\"93\":1}}],[\"所有模型均训练了32个周期\",{\"1\":{\"81\":1}}],[\"所有输入序列等长\",{\"1\":{\"38\":1}}],[\"所有序列都填充到max\",{\"1\":{\"38\":1}}],[\"所有卷积和\",{\"1\":{\"24\":1}}],[\"所有点相乘\",{\"1\":{\"32\":1}}],[\"所有点相加\",{\"1\":{\"32\":1}}],[\"所有点经过共享参数的\",{\"1\":{\"22\":1}}],[\"所有点组成的局部区域\",{\"1\":{\"13\":1}}],[\"所有尺度的特征保存到\",{\"1\":{\"17\":1}}],[\"所有尺度的网络并行运行\",{\"1\":{\"17\":1}}],[\"所有的数据都将发生变化\",{\"1\":{\"7\":1}}],[\">\",{\"1\":{\"13\":1,\"28\":1,\"38\":3,\"40\":1,\"59\":1,\"76\":1,\"87\":2,\"93\":2,\"99\":2,\"100\":2,\"101\":1,\"102\":8,\"103\":3}}],[\"与之类似的还有\",{\"1\":{\"104\":1}}],[\"与其他\",{\"1\":{\"99\":1}}],[\"与\",{\"1\":{\"92\":2,\"93\":1,\"96\":1}}],[\"与计算机视觉\",{\"1\":{\"80\":1}}],[\"与此同时\",{\"1\":{\"79\":1}}],[\"与原始点\",{\"1\":{\"13\":1}}],[\"与k最近邻\",{\"1\":{\"11\":1}}],[\"身份证号\",{\"1\":{\"13\":1}}],[\"代理任务通常是辅助进行表征学习\",{\"1\":{\"87\":1}}],[\"代表\",{\"1\":{\"104\":2,\"107\":1}}],[\"代表的是模型的基础\",{\"1\":{\"97\":1}}],[\"代表每个\",{\"1\":{\"13\":1}}],[\"代表原始点云中每个点的\",{\"1\":{\"13\":1}}],[\"代码实现如下\",{\"1\":{\"14\":1}}],[\"代码实现\",{\"0\":{\"13\":1,\"59\":1},\"1\":{\"24\":1}}],[\"代码\",{\"0\":{\"23\":1},\"1\":{\"4\":1,\"88\":1}}],[\"到第\",{\"1\":{\"60\":1}}],[\"到一个标准姿态\",{\"1\":{\"24\":1}}],[\"到\",{\"1\":{\"13\":1}}],[\"构成一个位置序列矩阵\",{\"1\":{\"41\":1}}],[\"构造一个单位矩阵\",{\"1\":{\"25\":1}}],[\"构造一个从\",{\"1\":{\"13\":1}}],[\"构建匹配标签\",{\"1\":{\"93\":1}}],[\"构建输入图像列表\",{\"1\":{\"93\":1}}],[\"构建输入文本列表\",{\"1\":{\"93\":1}}],[\"构建query和text的padding\",{\"1\":{\"93\":1}}],[\"构建query\",{\"1\":{\"93\":1}}],[\"构建padding\",{\"1\":{\"91\":1}}],[\"构建描述文本并提取特征\",{\"1\":{\"82\":1}}],[\"构建全局特征向量\",{\"1\":{\"32\":1}}],[\"构建点云的层次化表示\",{\"1\":{\"29\":1}}],[\"构建点之间的邻接图\",{\"1\":{\"29\":1}}],[\"构建它们的局部邻域区域\",{\"1\":{\"13\":1}}],[\"构建局部邻域的半径\",{\"1\":{\"13\":2}}],[\"查询点的位置\",{\"1\":{\"13\":1}}],[\"查询点数量\",{\"1\":{\"13\":1}}],[\"查询相比\",{\"1\":{\"11\":1}}],[\"返回分类标记对应的特征\",{\"1\":{\"99\":1,\"100\":1,\"103\":1}}],[\"返回数据集中图像的数量\",{\"1\":{\"96\":1}}],[\"返回值形如\",{\"1\":{\"58\":1}}],[\"返回位置索引\",{\"1\":{\"13\":1}}],[\"返回\",{\"1\":{\"13\":1,\"24\":1,\"26\":1}}],[\"中引入卷积操作\",{\"1\":{\"106\":1}}],[\"中进行进一步的处理\",{\"1\":{\"106\":1}}],[\"中第一个线性层把输入特征投影到一个更高维度的空间后\",{\"1\":{\"101\":1}}],[\"中加载数据时\",{\"1\":{\"96\":1}}],[\"中每个\",{\"1\":{\"92\":1}}],[\"中提取与\",{\"1\":{\"91\":2}}],[\"中提取\",{\"1\":{\"60\":1}}],[\"中提取对应的点\",{\"1\":{\"13\":1}}],[\"中取出对应的\",{\"1\":{\"60\":1}}],[\"中使用\",{\"1\":{\"32\":1}}],[\"中心\",{\"1\":{\"29\":1}}],[\"中\",{\"1\":{\"25\":1,\"38\":1,\"58\":1,\"82\":2,\"89\":2,\"93\":1,\"97\":1,\"99\":5}}],[\"中用于约束变换矩阵接近正交性的正则化损失函数\",{\"1\":{\"25\":1}}],[\"中用于从点云中选择具有代表性的采样点的一种策略\",{\"1\":{\"13\":1}}],[\"中均能有效提取特征\",{\"1\":{\"16\":1}}],[\"中的一个装饰器\",{\"1\":{\"96\":1}}],[\"中的一个方法\",{\"1\":{\"59\":1}}],[\"中的图像一一对应\",{\"1\":{\"96\":1}}],[\"中的核心操作\",{\"1\":{\"32\":1}}],[\"中的核心模块\",{\"1\":{\"13\":1}}],[\"中的\",{\"1\":{\"17\":1}}],[\"中的全局特征学习\",{\"1\":{\"13\":1}}],[\"中只有一组\",{\"1\":{\"13\":1}}],[\"中找到最大的那个距离对应的点\",{\"1\":{\"13\":2}}],[\"<=\",{\"1\":{\"58\":1}}],[\"<\",{\"1\":{\"13\":1}}],[\"mydataset\",{\"1\":{\"96\":1,\"97\":2}}],[\"m\",{\"1\":{\"74\":3,\"104\":1}}],[\"mseloss\",{\"1\":{\"47\":1}}],[\"msg方法虽然有效\",{\"1\":{\"18\":1}}],[\"msg相当于并联了多个hierarchical\",{\"1\":{\"17\":1}}],[\"msg的关键优点在于它通过在训练期间的随机输入丢弃\",{\"1\":{\"17\":1}}],[\"msg通过应用不同尺度的分组层\",{\"1\":{\"16\":1}}],[\"msg\",{\"1\":{\"15\":1,\"17\":3}}],[\"most\",{\"1\":{\"85\":10,\"86\":10}}],[\"motorcycle\",{\"1\":{\"82\":1}}],[\"motions\",{\"1\":{\"33\":1}}],[\"mode\",{\"1\":{\"96\":2}}],[\"model是decoder输出的大小\",{\"1\":{\"68\":1}}],[\"models\",{\"1\":{\"37\":1,\"107\":1}}],[\"modelnet40\",{\"1\":{\"29\":2}}],[\"model\",{\"1\":{\"14\":2,\"17\":2,\"37\":6,\"45\":1,\"59\":1,\"68\":2,\"76\":7,\"82\":2,\"84\":16,\"86\":16,\"87\":1,\"103\":2,\"107\":6}}],[\"modal\",{\"1\":{\"92\":2}}],[\"modulelist\",{\"1\":{\"13\":2,\"17\":4,\"44\":1}}],[\"module\",{\"1\":{\"13\":1,\"14\":1,\"17\":2,\"24\":1,\"26\":1,\"27\":1,\"28\":1,\"41\":1,\"43\":3,\"44\":3,\"45\":1,\"49\":1,\"50\":1,\"51\":1,\"53\":1,\"54\":1,\"55\":1,\"67\":1,\"68\":1,\"70\":1,\"71\":1,\"72\":1,\"74\":1,\"75\":1,\"76\":1,\"93\":4,\"98\":1,\"99\":2,\"100\":1,\"101\":2,\"102\":1,\"103\":1}}],[\"mvcnn\",{\"1\":{\"29\":3}}],[\"methods\",{\"1\":{\"83\":1}}],[\"metamind\",{\"1\":{\"0\":1}}],[\"memory\",{\"1\":{\"67\":2,\"74\":2,\"75\":2}}],[\"mesh\",{\"1\":{\"31\":1}}],[\"mean\",{\"1\":{\"25\":1,\"93\":1}}],[\"million\",{\"1\":{\"104\":1}}],[\"mixer\",{\"1\":{\"101\":1}}],[\"mixed\",{\"1\":{\"49\":6,\"93\":2}}],[\"might\",{\"1\":{\"49\":1}}],[\"min\",{\"1\":{\"32\":1,\"59\":4,\"84\":1,\"86\":1}}],[\"minibatch\",{\"1\":{\"81\":2}}],[\"mini\",{\"1\":{\"13\":1,\"14\":3}}],[\"missing\",{\"1\":{\"21\":1}}],[\"mrg策略在处理每个局部区域时\",{\"1\":{\"18\":1}}],[\"mrg通过结合来自不同分辨率的特征来实现效率和适应性的平衡\",{\"1\":{\"18\":1}}],[\"mrg为一种低成本的替代方案\",{\"1\":{\"18\":1}}],[\"mrg\",{\"1\":{\"15\":1}}],[\"multiply\",{\"1\":{\"102\":2}}],[\"multiple\",{\"1\":{\"62\":1}}],[\"multinomial\",{\"1\":{\"93\":2}}],[\"multiheadedattention\",{\"1\":{\"76\":2}}],[\"multi\",{\"0\":{\"16\":1,\"18\":1},\"1\":{\"15\":2,\"17\":1,\"20\":1,\"31\":1,\"66\":1,\"101\":1}}],[\"mlp=\",{\"1\":{\"14\":3}}],[\"mlp\",{\"0\":{\"103\":1},\"1\":{\"13\":8,\"17\":3,\"22\":1,\"27\":2,\"100\":1,\"101\":14,\"103\":4,\"104\":1}}],[\"make\",{\"1\":{\"102\":1}}],[\"main\",{\"1\":{\"88\":1}}],[\"made\",{\"1\":{\"74\":1}}],[\"macos\",{\"1\":{\"64\":1}}],[\"matplotlib\",{\"1\":{\"86\":1}}],[\"matching\",{\"0\":{\"93\":1},\"1\":{\"85\":11,\"86\":11,\"93\":3}}],[\"math\",{\"1\":{\"49\":1,\"76\":1,\"93\":1}}],[\"matmul\",{\"1\":{\"49\":2,\"76\":2,\"92\":2,\"93\":2}}],[\"matrix\",{\"1\":{\"25\":1}}],[\"map\",{\"1\":{\"40\":1,\"107\":1}}],[\"max\",{\"1\":{\"13\":4,\"17\":1,\"22\":6,\"24\":2,\"26\":1,\"29\":7,\"32\":1,\"37\":1,\"38\":6,\"40\":7,\"41\":1,\"59\":4,\"91\":3,\"92\":2,\"103\":1}}],[\"mask部分相关的掩码逻辑\",{\"1\":{\"102\":1}}],[\"mask和casual\",{\"1\":{\"102\":1}}],[\"mask标注哪些image\",{\"1\":{\"91\":1}}],[\"masking\",{\"1\":{\"66\":1,\"75\":1}}],[\"masked\",{\"1\":{\"56\":5,\"67\":1,\"76\":1}}],[\"mask=text\",{\"1\":{\"91\":1}}],[\"mask=image\",{\"1\":{\"91\":1,\"93\":1}}],[\"mask=mask\",{\"1\":{\"76\":1}}],[\"mask=head\",{\"1\":{\"47\":1,\"56\":1,\"61\":1,\"62\":1}}],[\"mask=none\",{\"1\":{\"43\":1,\"44\":2,\"46\":2,\"47\":2,\"49\":2,\"51\":1,\"56\":2,\"59\":2,\"61\":2,\"62\":2,\"76\":2,\"93\":9}}],[\"mask=attention\",{\"1\":{\"38\":1,\"47\":1,\"56\":1,\"58\":1,\"59\":1,\"61\":1,\"62\":1,\"93\":1}}],[\"mask作用图解\",{\"1\":{\"38\":2}}],[\"mask\",{\"1\":{\"13\":6,\"38\":14,\"40\":4,\"43\":1,\"44\":2,\"46\":8,\"47\":3,\"49\":3,\"51\":1,\"56\":2,\"58\":1,\"59\":1,\"61\":4,\"62\":6,\"66\":1,\"67\":11,\"71\":2,\"72\":3,\"74\":4,\"75\":4,\"76\":6,\"91\":2,\"92\":2,\"93\":24,\"102\":2}}],[\"21843\",{\"1\":{\"107\":1}}],[\"21000\",{\"1\":{\"107\":1}}],[\"21k\",{\"1\":{\"107\":3}}],[\"2×1000000000\",{\"1\":{\"104\":1}}],[\"2b\",{\"1\":{\"104\":1}}],[\"244\",{\"1\":{\"98\":1}}],[\"2的起因\",{\"1\":{\"89\":1}}],[\"2301\",{\"1\":{\"88\":1}}],[\"2f\",{\"1\":{\"84\":2,\"86\":2}}],[\"2训练时使用的webtext数据集相似\",{\"1\":{\"81\":1}}],[\"2010\",{\"1\":{\"107\":1}}],[\"2017年的工作\",{\"1\":{\"87\":1}}],[\"2016年的工作\",{\"1\":{\"87\":1}}],[\"2018\",{\"1\":{\"37\":1}}],[\"2021\",{\"1\":{\"79\":2}}],[\"224×224\",{\"1\":{\"107\":1}}],[\"224\",{\"1\":{\"97\":2,\"98\":2,\"107\":6}}],[\"224x224\",{\"1\":{\"97\":3,\"98\":1,\"107\":1}}],[\"22\",{\"1\":{\"37\":1,\"64\":1}}],[\"2d\",{\"1\":{\"31\":2,\"98\":1}}],[\"255\",{\"1\":{\"97\":2}}],[\"2578\",{\"1\":{\"38\":2}}],[\"2501\",{\"1\":{\"38\":2}}],[\"2504\",{\"1\":{\"4\":1}}],[\"256\",{\"1\":{\"14\":5,\"17\":6,\"24\":3,\"27\":3,\"28\":3,\"97\":2}}],[\"2\",{\"0\":{\"93\":1,\"98\":1},\"1\":{\"13\":8,\"14\":1,\"17\":7,\"22\":1,\"24\":2,\"25\":2,\"26\":6,\"28\":4,\"29\":2,\"41\":1,\"43\":1,\"46\":1,\"47\":1,\"49\":4,\"53\":1,\"55\":1,\"56\":2,\"58\":2,\"59\":3,\"71\":1,\"74\":1,\"76\":5,\"81\":1,\"82\":1,\"89\":1,\"90\":2,\"92\":2,\"93\":11,\"96\":2,\"98\":3,\"100\":1,\"102\":4}}],[\"索引保存下来\",{\"1\":{\"13\":1}}],[\"将多个注意力头的输出合并为一个张量\",{\"1\":{\"102\":1}}],[\"将多头注意力的输出进行线性变换\",{\"1\":{\"102\":1}}],[\"将注意力权重矩阵与v相乘\",{\"1\":{\"102\":1}}],[\"将q和k的转置相乘\",{\"1\":{\"102\":1}}],[\"将隐藏特征映射到输出特征空间\",{\"1\":{\"101\":1}}],[\"将分类标记和图像块嵌入拼接\",{\"1\":{\"99\":1,\"100\":1,\"103\":1}}],[\"将卷积后的通道维数作为embedding的维度\",{\"1\":{\"98\":1}}],[\"将其展平就变成了一个长度为768的向量\",{\"1\":{\"98\":1}}],[\"将\",{\"1\":{\"97\":2,\"98\":1,\"106\":1}}],[\"将裁剪后的图像调整为\",{\"1\":{\"97\":1}}],[\"将标签元组转换为一个一维张量\",{\"1\":{\"96\":1}}],[\"将图像数据移动到指定设备上\",{\"1\":{\"103\":1}}],[\"将图像的短边缩放为\",{\"1\":{\"97\":1}}],[\"将图像元组堆叠成一个四维张量\",{\"1\":{\"96\":1}}],[\"将图片编码成\",{\"1\":{\"91\":1}}],[\"将一个批次的数据拆分为图像和标签两个元组\",{\"1\":{\"96\":1}}],[\"将横坐标0\",{\"1\":{\"96\":1}}],[\"将会在下文进行详细讲解\",{\"1\":{\"93\":1}}],[\"将文本和query\",{\"1\":{\"93\":1}}],[\"将input\",{\"1\":{\"91\":1}}],[\"将inputfeatures\",{\"1\":{\"38\":1}}],[\"将输入特征映射到隐藏特征空间\",{\"1\":{\"101\":1}}],[\"将输入图像进行图像块嵌入\",{\"1\":{\"99\":1,\"100\":1,\"103\":1}}],[\"将输入图片\",{\"1\":{\"98\":1}}],[\"将输入文本转换为嵌入列表后和query\",{\"1\":{\"93\":1}}],[\"将输入的维度dim映射到dim\",{\"1\":{\"102\":1}}],[\"将输入的\",{\"1\":{\"91\":1}}],[\"将输入序列\",{\"1\":{\"66\":1}}],[\"将这个问题转化为一个多标签分类任务\",{\"1\":{\"87\":1}}],[\"将这些特征映射到类别空间\",{\"1\":{\"27\":2}}],[\"将数据下载到当前项目目录下\",{\"1\":{\"84\":1}}],[\"将待分类的图像输入到图像编码器\",{\"1\":{\"82\":1}}],[\"将个文本特征和个图像特征两两组合\",{\"1\":{\"81\":1}}],[\"将选项展平\",{\"1\":{\"62\":1}}],[\"将每个\",{\"1\":{\"58\":1}}],[\"将每个点的局部特征与整个点云的全局特征拼接起来\",{\"1\":{\"26\":1}}],[\"将模型放入到仓库对应位置\",{\"1\":{\"37\":1}}],[\"将空间划分成立方体格子\",{\"1\":{\"31\":1}}],[\"将原始点云\",{\"1\":{\"26\":1}}],[\"将全局特征与每个点的局部特征拼接起来\",{\"1\":{\"22\":1}}],[\"将点云转换为体素网格\",{\"1\":{\"20\":1}}],[\"将来自下一级\",{\"1\":{\"18\":1}}],[\"将view\",{\"1\":{\"13\":1}}],[\"将当前选中的\",{\"1\":{\"13\":1}}],[\"将转换后的坐标以及点的附加特征\",{\"1\":{\"12\":1}}],[\"次并与每个点的局部特征拼接\",{\"1\":{\"29\":1}}],[\"次并与每个点的局部特征\",{\"1\":{\"26\":1}}],[\"次\",{\"1\":{\"13\":1,\"28\":1}}],[\"批次索引\",{\"1\":{\"13\":1}}],[\"初始时没有任何语义信息\",{\"1\":{\"99\":1}}],[\"初始时随机选择一个点作为第一个中心点\",{\"1\":{\"13\":1}}],[\"初始化\",{\"1\":{\"98\":1,\"99\":1}}],[\"初始化自定义数据集类\",{\"1\":{\"96\":1}}],[\"初始化query\",{\"1\":{\"91\":1}}],[\"初始假设变换为恒等变换\",{\"1\":{\"24\":1}}],[\"初始设为一个极大值\",{\"1\":{\"13\":1}}],[\"t2i\",{\"1\":{\"92\":4,\"93\":5}}],[\"t2q\",{\"1\":{\"92\":2}}],[\"title\",{\"1\":{\"85\":1,\"86\":1,\"96\":1}}],[\"time\",{\"1\":{\"84\":10,\"86\":10}}],[\"turn\",{\"1\":{\"72\":1}}],[\"tuple\",{\"1\":{\"58\":1,\"93\":1,\"96\":1,\"99\":2,\"102\":1}}],[\"tgt\",{\"1\":{\"67\":12,\"74\":2,\"75\":2}}],[\"txt\",{\"1\":{\"64\":2,\"91\":1}}],[\"txt文件\",{\"1\":{\"37\":1}}],[\"t5\",{\"1\":{\"60\":1}}],[\"through\",{\"1\":{\"72\":1}}],[\"this\",{\"1\":{\"49\":1,\"82\":1}}],[\"them\",{\"1\":{\"93\":1}}],[\"these\",{\"1\":{\"59\":1}}],[\"there\",{\"1\":{\"54\":1}}],[\"they\",{\"1\":{\"47\":1}}],[\"the\",{\"1\":{\"38\":4,\"45\":3,\"49\":5,\"54\":3,\"59\":1,\"60\":2,\"61\":1,\"64\":1,\"72\":1,\"76\":2,\"82\":1,\"85\":1,\"86\":1,\"96\":1}}],[\"theorem\",{\"1\":{\"29\":1}}],[\"tage\",{\"1\":{\"91\":1}}],[\"tabby\",{\"1\":{\"82\":1}}],[\"targets\",{\"1\":{\"92\":3}}],[\"target\",{\"1\":{\"67\":1}}],[\"taken\",{\"1\":{\"49\":1,\"84\":2,\"86\":1}}],[\"take\",{\"1\":{\"49\":1,\"67\":1,\"76\":1}}],[\"taking\",{\"1\":{\"45\":1}}],[\"tanh\",{\"1\":{\"45\":1,\"103\":2}}],[\"task\",{\"1\":{\"37\":1,\"38\":1}}],[\"two\",{\"1\":{\"38\":1,\"90\":2,\"94\":1}}],[\"type\",{\"1\":{\"38\":9,\"40\":4,\"41\":9,\"46\":3,\"47\":3,\"56\":3,\"58\":2,\"59\":3,\"60\":1,\"61\":3,\"62\":7,\"93\":1}}],[\"type=bert\",{\"1\":{\"37\":1}}],[\"temp\",{\"1\":{\"92\":2}}],[\"temperature\",{\"1\":{\"81\":1}}],[\"test\",{\"1\":{\"84\":2,\"86\":1}}],[\"terms\",{\"1\":{\"59\":1}}],[\"tensors=\",{\"1\":{\"84\":2,\"86\":2,\"91\":1}}],[\"tensor\",{\"1\":{\"43\":2,\"45\":2,\"50\":2,\"51\":3,\"59\":1,\"82\":1,\"96\":1,\"97\":2,\"102\":1}}],[\"tensordataset\",{\"1\":{\"38\":1}}],[\"tensorflow\",{\"1\":{\"6\":1,\"19\":1}}],[\"text和text\",{\"1\":{\"92\":1}}],[\"text最相关的视觉信息\",{\"1\":{\"91\":1}}],[\"text转化为18291个类别\",{\"1\":{\"87\":1}}],[\"text=texts\",{\"1\":{\"84\":1,\"86\":1}}],[\"texts\",{\"1\":{\"81\":1,\"82\":2,\"84\":1,\"86\":1}}],[\"text\",{\"0\":{\"92\":1,\"93\":1},\"1\":{\"38\":2,\"81\":6,\"82\":13,\"84\":9,\"85\":9,\"86\":16,\"89\":2,\"91\":17,\"92\":11,\"93\":33,\"96\":1}}],[\"tnews\",{\"1\":{\"37\":4}}],[\"tf\",{\"1\":{\"37\":2}}],[\"trunc\",{\"1\":{\"99\":1,\"100\":2,\"103\":2}}],[\"truncation=true\",{\"1\":{\"91\":1}}],[\"true\",{\"1\":{\"17\":1,\"26\":1,\"93\":1,\"96\":1,\"107\":1}}],[\"tree\",{\"1\":{\"88\":1}}],[\"try\",{\"1\":{\"84\":2,\"85\":1,\"86\":3}}],[\"tripod\",{\"1\":{\"82\":1}}],[\"training\",{\"1\":{\"80\":1,\"96\":1,\"107\":1}}],[\"train\",{\"1\":{\"37\":3,\"38\":1,\"40\":6,\"83\":1,\"96\":7,\"97\":7,\"103\":1}}],[\"trained\",{\"1\":{\"37\":2}}],[\"translation\",{\"1\":{\"94\":1}}],[\"transpose\",{\"1\":{\"25\":1,\"26\":4,\"28\":1,\"49\":5,\"76\":3,\"93\":9,\"98\":1,\"102\":4}}],[\"trans\",{\"1\":{\"25\":6,\"26\":11,\"27\":4,\"28\":4}}],[\"transforms\",{\"1\":{\"97\":10}}],[\"transform=data\",{\"1\":{\"97\":2}}],[\"transform=none\",{\"1\":{\"96\":1}}],[\"transform=feature\",{\"1\":{\"27\":1,\"28\":2}}],[\"transform=false\",{\"1\":{\"27\":1,\"28\":1}}],[\"transformation\",{\"1\":{\"25\":1}}],[\"transformations\",{\"1\":{\"21\":1}}],[\"transform\",{\"1\":{\"25\":3,\"26\":5,\"27\":3,\"28\":2,\"53\":3,\"54\":2,\"96\":5,\"97\":4}}],[\"transformer证明了使用transformer结构可以有效处理图像数据\",{\"1\":{\"108\":1}}],[\"transformer需要输入的是一维的token\",{\"1\":{\"98\":1}}],[\"transformer的核心流程实现\",{\"1\":{\"95\":1}}],[\"transformer的模型结构相比于transformer来说更简单\",{\"1\":{\"94\":1}}],[\"transformer是2021年谷歌在iclr上提出的算法\",{\"1\":{\"94\":1}}],[\"transformers\",{\"1\":{\"86\":1}}],[\"transformer\",{\"1\":{\"24\":1,\"29\":3,\"32\":1,\"49\":1,\"60\":1,\"64\":5,\"66\":4,\"79\":3,\"81\":3,\"84\":2,\"87\":1,\"90\":1,\"94\":1,\"99\":3,\"101\":1,\"106\":10,\"107\":2}}],[\"t\",{\"1\":{\"20\":1,\"22\":2,\"24\":3,\"29\":2,\"81\":15,\"82\":2,\"84\":1,\"86\":1,\"93\":1,\"96\":1}}],[\"totensor\",{\"1\":{\"97\":2}}],[\"total\",{\"1\":{\"56\":2,\"59\":2,\"84\":4,\"86\":4,\"102\":3}}],[\"topk\",{\"1\":{\"82\":1}}],[\"top\",{\"1\":{\"82\":2}}],[\"token提取出来\",{\"1\":{\"103\":1}}],[\"token的作用\",{\"1\":{\"99\":1}}],[\"token的相似度\",{\"1\":{\"92\":1}}],[\"token对齐\",{\"1\":{\"99\":1}}],[\"token作为最后的相似度得分\",{\"1\":{\"92\":2}}],[\"token作为input\",{\"1\":{\"91\":1}}],[\"token是有效的\",{\"1\":{\"91\":1}}],[\"token分类任务\",{\"0\":{\"61\":1}}],[\"tokenize\",{\"1\":{\"82\":1}}],[\"tokenizer\",{\"1\":{\"60\":4,\"91\":1}}],[\"tokenization\",{\"1\":{\"58\":1}}],[\"token用于分类任务即可\",{\"1\":{\"47\":1}}],[\"token\",{\"0\":{\"99\":1},\"1\":{\"38\":35,\"40\":4,\"41\":9,\"45\":4,\"46\":2,\"47\":2,\"54\":1,\"56\":3,\"58\":9,\"59\":2,\"60\":8,\"61\":4,\"62\":6,\"91\":1,\"92\":1,\"93\":1,\"99\":23,\"100\":5,\"103\":5}}],[\"tokens的embeddings在seq\",{\"1\":{\"93\":1}}],[\"tokens同时输入bertmodel时\",{\"1\":{\"93\":1}}],[\"tokens部分的每个位置都映射到2维匹配空间\",{\"1\":{\"93\":1}}],[\"tokens部分的结果\",{\"1\":{\"93\":1}}],[\"tokens部分的mask列表\",{\"1\":{\"38\":1}}],[\"tokens拼接得到的结果和图像嵌入进行cross\",{\"1\":{\"93\":1}}],[\"tokens列表\",{\"1\":{\"93\":1}}],[\"tokens=true\",{\"1\":{\"60\":2}}],[\"tokens=false\",{\"1\":{\"38\":1}}],[\"tokens\",{\"1\":{\"38\":6,\"49\":1,\"58\":2,\"60\":2,\"82\":2,\"91\":9,\"92\":3,\"93\":20,\"99\":1,\"100\":2,\"103\":2}}],[\"to\",{\"1\":{\"13\":7,\"37\":3,\"38\":1,\"45\":1,\"46\":1,\"49\":4,\"65\":1,\"76\":1,\"81\":2,\"84\":6,\"86\":5,\"89\":1,\"91\":2,\"93\":6,\"98\":1,\"103\":3,\"107\":1}}],[\"torchscript\",{\"1\":{\"102\":1}}],[\"torch==1\",{\"1\":{\"64\":1}}],[\"torch\",{\"1\":{\"13\":12,\"17\":3,\"24\":6,\"25\":4,\"26\":7,\"28\":4,\"40\":1,\"41\":2,\"49\":2,\"54\":1,\"58\":4,\"64\":1,\"76\":2,\"82\":3,\"84\":4,\"86\":5,\"91\":1,\"92\":3,\"93\":22,\"96\":5,\"97\":2,\"99\":2,\"100\":3,\"103\":5,\"107\":1}}],[\"形式\",{\"1\":{\"62\":1}}],[\"形状为\",{\"1\":{\"98\":2}}],[\"形状是\",{\"1\":{\"92\":1}}],[\"形状\",{\"1\":{\"58\":2}}],[\"形\",{\"1\":{\"38\":1}}],[\"形成最终的局部特征表示\",{\"1\":{\"17\":1}}],[\"形成最终的局部区域表示\",{\"1\":{\"13\":1}}],[\"形成一个特征向量\",{\"1\":{\"18\":1}}],[\"形成一个综合的多尺度特征表示\",{\"1\":{\"16\":1}}],[\"形成一个新的子集\",{\"1\":{\"13\":1}}],[\"形成\",{\"1\":{\"13\":1}}],[\"形心点的坐标来实现\",{\"1\":{\"12\":1}}],[\"也就为非线性激活函数提供了更多可以学习的特征组合\",{\"1\":{\"101\":1}}],[\"也就是q\",{\"1\":{\"105\":1}}],[\"也就是经过卷积后拼接得到的特征图\",{\"1\":{\"98\":1}}],[\"也就是卷积核的数量\",{\"1\":{\"98\":1}}],[\"也就是一张图像搭配与之对应的文本描述\",{\"1\":{\"80\":1}}],[\"也就是说\",{\"1\":{\"62\":1}}],[\"也需要保持输入图像尺寸与预训练时一致\",{\"1\":{\"97\":1}}],[\"也是其一大亮点\",{\"1\":{\"82\":1}}],[\"也可以进行随机裁剪\",{\"1\":{\"97\":1}}],[\"也可以采用视觉transformer模型\",{\"1\":{\"81\":1}}],[\"也可能导致错误分类\",{\"1\":{\"29\":1}}],[\"也一并加入\",{\"1\":{\"13\":1,\"17\":1}}],[\"也一并提取\",{\"1\":{\"13\":1}}],[\"也应该以一种方式被处理\",{\"1\":{\"7\":1}}],[\"1rkdjdlr37o7gsr9j1mhjbg\",{\"1\":{\"107\":1}}],[\"197\",{\"1\":{\"99\":1,\"100\":1,\"103\":1}}],[\"196+1\",{\"1\":{\"100\":1}}],[\"196\",{\"1\":{\"98\":2,\"99\":1,\"100\":1,\"103\":1}}],[\"137mo\",{\"1\":{\"96\":1}}],[\"14模型\",{\"1\":{\"81\":1}}],[\"14则需要在256个v100\",{\"1\":{\"81\":1}}],[\"14\",{\"1\":{\"81\":2,\"84\":1,\"98\":2,\"100\":2}}],[\"1e\",{\"1\":{\"103\":1}}],[\"1e9\",{\"1\":{\"76\":1}}],[\"1e10\",{\"1\":{\"13\":2}}],[\"1=none\",{\"1\":{\"38\":3}}],[\"11929\",{\"1\":{\"107\":1}}],[\"11\",{\"1\":{\"37\":1,\"64\":2}}],[\"1200000000\",{\"1\":{\"104\":1}}],[\"12597\",{\"1\":{\"88\":1}}],[\"12\",{\"1\":{\"37\":6}}],[\"128\",{\"1\":{\"14\":5,\"17\":10,\"24\":4,\"26\":3,\"28\":3,\"58\":1}}],[\"10\",{\"1\":{\"76\":3}}],[\"103\",{\"1\":{\"38\":1}}],[\"102\",{\"1\":{\"38\":2}}],[\"1024+64\",{\"1\":{\"26\":1}}],[\"1024维\",{\"1\":{\"24\":1,\"26\":1,\"27\":2}}],[\"1024\",{\"1\":{\"14\":3,\"17\":3,\"24\":9,\"26\":7,\"27\":1,\"28\":2}}],[\"101\",{\"1\":{\"38\":2}}],[\"10000\",{\"1\":{\"46\":1,\"93\":3}}],[\"100\",{\"1\":{\"38\":2,\"82\":1,\"84\":1,\"86\":1}}],[\"104\",{\"1\":{\"38\":1}}],[\"1088\",{\"1\":{\"26\":2,\"28\":1}}],[\"1d\",{\"1\":{\"24\":1}}],[\"16×16\",{\"1\":{\"107\":1}}],[\"16这个模型进行微调\",{\"1\":{\"107\":1}}],[\"16x16\",{\"1\":{\"97\":1}}],[\"16为例\",{\"1\":{\"97\":1,\"98\":1}}],[\"16和vit\",{\"1\":{\"81\":1}}],[\"16倍和64倍得到的\",{\"1\":{\"81\":1}}],[\"1612\",{\"1\":{\"19\":1}}],[\"16\",{\"1\":{\"17\":1,\"97\":2,\"98\":3,\"107\":1}}],[\"1\",{\"0\":{\"91\":1,\"92\":1,\"97\":1},\"1\":{\"13\":34,\"14\":3,\"17\":9,\"22\":1,\"24\":12,\"25\":4,\"26\":13,\"28\":8,\"29\":1,\"38\":26,\"40\":1,\"41\":2,\"46\":2,\"47\":6,\"49\":5,\"56\":5,\"58\":6,\"59\":5,\"60\":2,\"61\":6,\"62\":15,\"64\":1,\"68\":1,\"71\":2,\"74\":2,\"76\":15,\"79\":1,\"82\":5,\"84\":4,\"86\":4,\"90\":1,\"91\":7,\"92\":13,\"93\":29,\"96\":2,\"97\":2,\"98\":5,\"99\":10,\"100\":10,\"102\":16,\"103\":10,\"104\":2,\"107\":2}}],[\"1706\",{\"1\":{\"6\":1}}],[\"把相似度矩阵对角线元素置为负无穷大\",{\"1\":{\"93\":1}}],[\"把query\",{\"1\":{\"93\":1}}],[\"把q\",{\"1\":{\"91\":1}}],[\"把数据转换成llm能识别的格式\",{\"1\":{\"90\":1}}],[\"把layernorm放到了前面\",{\"1\":{\"70\":1}}],[\"把这些\",{\"1\":{\"60\":1}}],[\"把这些点的坐标归一化到以质心为中心的局部坐标系下\",{\"1\":{\"17\":1}}],[\"把全局特征复制\",{\"1\":{\"26\":1}}],[\"把它们\",{\"1\":{\"24\":1}}],[\"把它们相对于关键点的位置进行归一化\",{\"1\":{\"13\":1}}],[\"把不同尺度学到的特征拼接在一起\",{\"1\":{\"17\":1}}],[\"把邻域点的数据整理成适合卷积的格式\",{\"1\":{\"13\":1}}],[\"把邻近点的坐标和特征拼接在一起\",{\"1\":{\"13\":1}}],[\"把原始点云\",{\"1\":{\"13\":1}}],[\"把距离超过\",{\"1\":{\"13\":1}}],[\"把刚才找到的邻近点的坐标提取出来\",{\"1\":{\"13\":1}}],[\"把他的大小归一化到一个球中\",{\"1\":{\"7\":1}}],[\"如此反复\",{\"1\":{\"106\":1}}],[\"如下图所示\",{\"1\":{\"101\":1}}],[\"如交叉熵损失\",{\"1\":{\"99\":1}}],[\"如局部性和平移不变性\",{\"1\":{\"94\":1}}],[\"如vilt\",{\"1\":{\"89\":1}}],[\"如vse++\",{\"1\":{\"89\":1}}],[\"如clip\",{\"1\":{\"89\":1}}],[\"如mae和beit\",{\"1\":{\"87\":1}}],[\"如moco和simclr\",{\"1\":{\"87\":1}}],[\"如imagenet\",{\"1\":{\"87\":1}}],[\"如自注意力层和前馈层\",{\"1\":{\"66\":1}}],[\"如翻译后的句子\",{\"1\":{\"66\":1}}],[\"如句子\",{\"1\":{\"66\":1}}],[\"如判断哪个是答案的开始\",{\"1\":{\"60\":1}}],[\"如方差\",{\"1\":{\"32\":1}}],[\"如时间序列点云\",{\"1\":{\"29\":1}}],[\"如只有几十个点\",{\"1\":{\"29\":1}}],[\"如弯曲\",{\"1\":{\"29\":1}}],[\"如\",{\"1\":{\"29\":3,\"32\":1,\"97\":1,\"101\":1}}],[\"如人体姿态变化\",{\"1\":{\"29\":1}}],[\"如桌子边缘\",{\"1\":{\"29\":1}}],[\"如椅子腿和桌面连接处\",{\"1\":{\"29\":1}}],[\"如旋转\",{\"1\":{\"21\":1,\"24\":1,\"25\":1}}],[\"如最大池化\",{\"1\":{\"20\":1}}],[\"如法线\",{\"1\":{\"13\":1}}],[\"如果类别数大于\",{\"1\":{\"103\":1}}],[\"如果未指定\",{\"1\":{\"101\":2}}],[\"如果未提供位置id\",{\"1\":{\"93\":1}}],[\"如果传入了归一化层类\",{\"1\":{\"98\":1}}],[\"如果传入的是整数\",{\"1\":{\"98\":1}}],[\"如果传入一个归一化层类\",{\"1\":{\"98\":1}}],[\"如果传入一个整数\",{\"1\":{\"98\":2}}],[\"如果定义了图像预处理转换操作\",{\"1\":{\"96\":1}}],[\"如果该路径在采样的验证集样本中则存入验证集\",{\"1\":{\"96\":1}}],[\"如果进一步采用convirt\",{\"1\":{\"87\":1}}],[\"如果在读取图片过程中出现错误\",{\"1\":{\"84\":1}}],[\"如果我们直接使用类别标签作为文本描述\",{\"1\":{\"83\":1}}],[\"如果有个类别\",{\"1\":{\"82\":1}}],[\"如果有额外特征\",{\"1\":{\"13\":1,\"17\":1}}],[\"如果有额外的点特征\",{\"1\":{\"13\":1}}],[\"如果你希望模型能\",{\"1\":{\"60\":1}}],[\"如果你有一张人脸的点云\",{\"1\":{\"29\":1}}],[\"如果正确答案没有出现在上下文中\",{\"1\":{\"60\":1}}],[\"如果模型预测\",{\"1\":{\"60\":1}}],[\"如果值大于\",{\"1\":{\"59\":1}}],[\"如果值小于\",{\"1\":{\"59\":1}}],[\"如果本地不存在\",{\"1\":{\"37\":1}}],[\"如果对于任意排列\",{\"1\":{\"32\":1}}],[\"如果训练过程中加入了噪声\",{\"1\":{\"29\":1}}],[\"如果点太少\",{\"1\":{\"29\":1}}],[\"如果这些关键点缺失或被遮挡\",{\"1\":{\"29\":1}}],[\"如果是分割任务\",{\"1\":{\"26\":2}}],[\"如果是分类任务\",{\"1\":{\"26\":2}}],[\"如果直接作为变换矩阵\",{\"1\":{\"24\":1}}],[\"如果没有提供激活函数层\",{\"1\":{\"103\":1}}],[\"如果没有提供归一化层\",{\"1\":{\"103\":1}}],[\"如果没有任何归纳偏置\",{\"1\":{\"94\":1}}],[\"如果没有则下载\",{\"1\":{\"84\":1,\"86\":1}}],[\"如果没有\",{\"1\":{\"24\":1}}],[\"如果不是则抛出异常\",{\"1\":{\"96\":1}}],[\"如果不加处理\",{\"1\":{\"24\":1}}],[\"如果不够就重复最近的点来填充\",{\"1\":{\"13\":1}}],[\"如果\",{\"1\":{\"13\":1,\"29\":2,\"58\":1,\"93\":1}}],[\"如果某个查询点附近的点太少\",{\"1\":{\"13\":1}}],[\"如果某个点到新中心点的距离比之前记录的\",{\"1\":{\"13\":1}}],[\"如何将二维图像转换为一维时间序列\",{\"1\":{\"108\":1}}],[\"如何将这个预训练的视觉模型应用到新的任务中呢\",{\"1\":{\"82\":1}}],[\"如何计算loss的\",{\"1\":{\"92\":1}}],[\"如何降低模型训练成本\",{\"1\":{\"89\":1}}],[\"如何获取答案\",{\"1\":{\"60\":1}}],[\"如何利用\",{\"1\":{\"58\":1}}],[\"如何设计一个能够从这些局部分区中学习有用特征的机制\",{\"1\":{\"7\":1}}],[\"如何有效地对点云进行分区\",{\"1\":{\"7\":1}}],[\"如何生成点集的划分\",{\"1\":{\"7\":1}}],[\"个类别和\",{\"1\":{\"107\":1}}],[\"个可训练参数\",{\"1\":{\"104\":2}}],[\"个选项\",{\"1\":{\"62\":1}}],[\"个词之间\",{\"1\":{\"60\":1}}],[\"个输出\",{\"1\":{\"24\":1}}],[\"个坐标值\",{\"1\":{\"24\":1}}],[\"个关键点作为局部区域中心\",{\"1\":{\"17\":1}}],[\"个关键点对应的全局区域特征向量\",{\"1\":{\"14\":1}}],[\"个关键点对应的局部区域特征向量\",{\"1\":{\"14\":2}}],[\"个关键点的坐标\",{\"1\":{\"14\":3}}],[\"个维度\",{\"1\":{\"13\":1}}],[\"个分布尽可能均匀的采样点索引\",{\"1\":{\"13\":1}}],[\"个点的子集决定\",{\"1\":{\"29\":1}}],[\"个点\",{\"1\":{\"13\":2}}],[\"个具有代表性的点\",{\"1\":{\"13\":1}}],[\"最相关的视觉信息\",{\"1\":{\"91\":2}}],[\"最近的一些工作采用新的模型架构和预训练方法来从文本学习视觉特征\",{\"1\":{\"87\":1}}],[\"最大的resnet模型rn50x64需要在592个v100\",{\"1\":{\"81\":1}}],[\"最大池化\",{\"1\":{\"32\":1}}],[\"最小池化\",{\"1\":{\"32\":1}}],[\"最小距离\",{\"1\":{\"13\":1}}],[\"最显著的点\",{\"1\":{\"29\":1}}],[\"最后交换第\",{\"1\":{\"98\":1}}],[\"最后\",{\"1\":{\"84\":1}}],[\"最后将结果转换为\",{\"1\":{\"84\":1}}],[\"最后将每个点的局部特征与整个点云的全局特征拼接起来\",{\"1\":{\"28\":1}}],[\"最后重新\",{\"1\":{\"62\":1}}],[\"最后一层输出\",{\"1\":{\"26\":1}}],[\"最后通过全连接层完成分类任务\",{\"1\":{\"17\":1}}],[\"最后拼接结果\",{\"1\":{\"17\":1}}],[\"最终答案就是上下文中这两个位置之间的字符串\",{\"1\":{\"60\":1}}],[\"最终每个\",{\"1\":{\"58\":1}}],[\"最终每个采样得到的关键点所在的局部领域\",{\"1\":{\"13\":1}}],[\"最终\",{\"1\":{\"24\":1,\"82\":1,\"99\":2}}],[\"最终输出\",{\"1\":{\"28\":1}}],[\"最终输出每个类别的概率分布\",{\"1\":{\"27\":1}}],[\"最终输出高维特征\",{\"1\":{\"26\":1}}],[\"最终输出与点的顺序无关\",{\"1\":{\"22\":1}}],[\"最终输出就是\",{\"1\":{\"17\":1}}],[\"最终得到\",{\"1\":{\"13\":1}}],[\"最远点\",{\"1\":{\"13\":4}}],[\"最远点采样\",{\"1\":{\"13\":2,\"17\":1}}],[\"最多保留\",{\"1\":{\"13\":1}}],[\"的局部特征提取能力快速捕捉图像的底层特征\",{\"1\":{\"106\":1}}],[\"的缩写\",{\"1\":{\"104\":2}}],[\"的隐藏维度\",{\"1\":{\"101\":1}}],[\"的隐藏状态\",{\"1\":{\"58\":1}}],[\"的图像块矩阵添加二维\",{\"1\":{\"100\":1}}],[\"的交互\",{\"1\":{\"99\":1}}],[\"的形式\",{\"1\":{\"98\":1}}],[\"的张量\",{\"1\":{\"97\":2,\"98\":2}}],[\"的概率随机水平翻转图像\",{\"1\":{\"97\":1}}],[\"的完整计算流程\",{\"1\":{\"93\":1}}],[\"的相似度\",{\"1\":{\"92\":1}}],[\"的zero\",{\"1\":{\"87\":1}}],[\"的架构中融入卷积操作\",{\"1\":{\"106\":1}}],[\"的架构\",{\"1\":{\"84\":1}}],[\"的性能提升\",{\"1\":{\"83\":1}}],[\"的性能会显著下降\",{\"1\":{\"29\":1}}],[\"的效果\",{\"1\":{\"83\":1}}],[\"的vit\",{\"1\":{\"81\":1}}],[\"的出现也掀起了新一轮的研究热潮\",{\"1\":{\"79\":1}}],[\"的研究如潮水般涌来\",{\"1\":{\"79\":1}}],[\"的神经网络架构\",{\"1\":{\"66\":1}}],[\"的输入序列\",{\"1\":{\"62\":1}}],[\"的输入方式是\",{\"1\":{\"62\":1}}],[\"的输入组织形式与普通分类或问答任务略有不同\",{\"1\":{\"62\":1}}],[\"的输出向量能够很好地表示图像的全局特征\",{\"1\":{\"99\":2}}],[\"的输出向量被输入到分类头中\",{\"1\":{\"99\":1}}],[\"的输出\",{\"1\":{\"58\":1,\"99\":1}}],[\"的输出仅由一个不超过\",{\"1\":{\"29\":1}}],[\"的区域\",{\"1\":{\"60\":1}}],[\"的角色进行分类\",{\"1\":{\"60\":1}}],[\"的模型\",{\"1\":{\"60\":1}}],[\"的模块\",{\"1\":{\"24\":1}}],[\"的位置\",{\"1\":{\"58\":1}}],[\"的序列\",{\"1\":{\"58\":1}}],[\"的文本对\",{\"1\":{\"58\":1}}],[\"的问答任务中\",{\"1\":{\"58\":1}}],[\"的最大缺陷在于它\",{\"1\":{\"29\":1}}],[\"的优势\",{\"1\":{\"29\":1,\"106\":1}}],[\"的主要缺陷\",{\"1\":{\"29\":1}}],[\"的时间复杂度虽然是\",{\"1\":{\"29\":1}}],[\"的实验\",{\"1\":{\"29\":1}}],[\"的限制\",{\"1\":{\"29\":1}}],[\"的表示\",{\"1\":{\"58\":1}}],[\"的表达能力受\",{\"1\":{\"29\":1}}],[\"的表现不如基于图结构的模型\",{\"1\":{\"29\":1}}],[\"的全局特征来自于\",{\"1\":{\"29\":1}}],[\"的分类准确率略低于\",{\"1\":{\"29\":1}}],[\"的分类模块\",{\"1\":{\"27\":1}}],[\"的分割网络将全局特征复制\",{\"1\":{\"29\":1}}],[\"的分割模块通过拼接全局特征\",{\"1\":{\"29\":1}}],[\"的分割模块\",{\"1\":{\"28\":1}}],[\"的核心\",{\"1\":{\"66\":1}}],[\"的核心特征提取模块\",{\"1\":{\"26\":1}}],[\"的核心就是逐层提取局部特征\",{\"1\":{\"14\":1}}],[\"的作用是通过训练过程中损失值的降低\",{\"1\":{\"99\":1}}],[\"的作用\",{\"1\":{\"25\":1}}],[\"的矩阵\",{\"1\":{\"25\":1,\"98\":1}}],[\"的方式\",{\"1\":{\"24\":1}}],[\"的大小\",{\"1\":{\"24\":1}}],[\"的变换矩阵\",{\"1\":{\"24\":2}}],[\"的创新点\",{\"1\":{\"20\":1}}],[\"的\",{\"1\":{\"14\":1,\"17\":1,\"38\":1,\"58\":1,\"60\":1}}],[\"的第\",{\"1\":{\"13\":1}}],[\"的结构过于简单\",{\"1\":{\"29\":1}}],[\"的结构\",{\"1\":{\"13\":1}}],[\"的点缺失\",{\"1\":{\"22\":1}}],[\"的点集群都将独立地送入对应的pointnet网络进行特征提取\",{\"1\":{\"16\":1}}],[\"的点及其特征\",{\"1\":{\"13\":1}}],[\"的点全部替换为\",{\"1\":{\"13\":1}}],[\"的点\",{\"1\":{\"13\":1}}],[\"的索引数组\",{\"1\":{\"13\":1}}],[\"的索引\",{\"1\":{\"13\":1}}],[\"的所有邻近点\",{\"1\":{\"13\":1}}],[\"的特征图\",{\"1\":{\"98\":1}}],[\"的特征进行汇总\",{\"1\":{\"18\":1}}],[\"的特征\",{\"1\":{\"7\":1}}],[\"球查询\",{\"1\":{\"13\":2}}],[\"i2t\",{\"1\":{\"92\":5,\"93\":4}}],[\"itm\",{\"0\":{\"93\":1},\"1\":{\"93\":12}}],[\"itc\",{\"0\":{\"92\":1},\"1\":{\"92\":1}}],[\"items\",{\"1\":{\"96\":1}}],[\"item\",{\"1\":{\"40\":1,\"93\":2,\"96\":5}}],[\"icmlm和convirt仅在10万级别的数据上训练了几天\",{\"1\":{\"87\":1}}],[\"icmlm基于语言掩码的方法\",{\"1\":{\"87\":1}}],[\"impl\",{\"1\":{\"107\":1}}],[\"implements\",{\"1\":{\"76\":1}}],[\"import\",{\"1\":{\"86\":9,\"96\":3}}],[\"imshow\",{\"1\":{\"85\":1,\"86\":1}}],[\"img\",{\"1\":{\"85\":2,\"86\":2,\"96\":9,\"98\":10,\"99\":3,\"100\":2,\"103\":2,\"107\":1}}],[\"imagenet\",{\"1\":{\"97\":1,\"107\":3}}],[\"image\",{\"0\":{\"92\":1,\"93\":1},\"1\":{\"80\":1,\"81\":5,\"82\":10,\"84\":31,\"85\":21,\"86\":51,\"87\":1,\"89\":2,\"91\":14,\"92\":11,\"93\":22,\"96\":9,\"98\":1,\"107\":1}}],[\"images=images\",{\"1\":{\"84\":1,\"86\":1}}],[\"images\",{\"1\":{\"31\":1,\"81\":1,\"82\":1,\"84\":3,\"85\":2,\"86\":5,\"93\":1,\"96\":40,\"97\":12,\"103\":3}}],[\"ignored\",{\"1\":{\"59\":4}}],[\"ignore\",{\"1\":{\"56\":1,\"59\":3,\"86\":1}}],[\"id=model\",{\"1\":{\"84\":1,\"86\":1}}],[\"ids=position\",{\"1\":{\"46\":1,\"47\":1,\"56\":1,\"59\":1,\"61\":1,\"62\":1}}],[\"ids=none\",{\"1\":{\"41\":2,\"46\":2,\"47\":2,\"56\":2,\"59\":2,\"61\":2,\"62\":2,\"93\":2}}],[\"ids=token\",{\"1\":{\"38\":1,\"46\":1,\"47\":1,\"56\":1,\"58\":1,\"59\":1,\"61\":1,\"62\":1}}],[\"ids=input\",{\"1\":{\"38\":1}}],[\"ids作用图解\",{\"1\":{\"38\":1}}],[\"ids\",{\"1\":{\"38\":36,\"40\":8,\"41\":14,\"46\":4,\"47\":4,\"56\":4,\"58\":2,\"59\":4,\"60\":4,\"61\":4,\"62\":17,\"91\":1,\"93\":21}}],[\"id\",{\"1\":{\"38\":9,\"60\":3}}],[\"identity\",{\"1\":{\"98\":3,\"101\":1,\"103\":1}}],[\"iden\",{\"1\":{\"24\":4}}],[\"idx=0\",{\"1\":{\"41\":1}}],[\"idx\",{\"1\":{\"13\":21,\"17\":3,\"84\":5,\"86\":5,\"93\":5}}],[\"i\",{\"1\":{\"13\":4,\"17\":7,\"25\":5,\"44\":2,\"81\":12,\"84\":2,\"86\":2,\"96\":4,\"103\":2}}],[\"isn\",{\"1\":{\"96\":1}}],[\"isdir\",{\"1\":{\"84\":1,\"86\":1,\"96\":1}}],[\"isinstance\",{\"1\":{\"43\":2,\"53\":2}}],[\"is\",{\"1\":{\"13\":3,\"17\":2,\"24\":1,\"25\":1,\"38\":4,\"41\":2,\"47\":1,\"49\":4,\"54\":1,\"56\":2,\"59\":2,\"60\":2,\"61\":2,\"62\":4,\"72\":1,\"74\":1,\"76\":3,\"82\":1,\"84\":2,\"85\":2,\"86\":4,\"93\":14,\"96\":1}}],[\"if\",{\"1\":{\"13\":5,\"14\":2,\"17\":4,\"24\":1,\"25\":1,\"26\":3,\"38\":7,\"40\":1,\"41\":2,\"43\":1,\"47\":3,\"49\":1,\"53\":1,\"56\":1,\"59\":1,\"61\":2,\"62\":4,\"76\":3,\"84\":9,\"85\":3,\"86\":12,\"93\":15,\"96\":6,\"98\":1,\"101\":1,\"103\":1,\"107\":2}}],[\"in21k模型权重文件\",{\"1\":{\"107\":1}}],[\"in21k\",{\"1\":{\"107\":4}}],[\"in21k这个模型\",{\"1\":{\"107\":1}}],[\"install\",{\"1\":{\"64\":1}}],[\"instructions\",{\"1\":{\"4\":1}}],[\"into\",{\"1\":{\"58\":1}}],[\"int\",{\"1\":{\"49\":1,\"99\":5,\"101\":1,\"107\":1}}],[\"intermediate\",{\"1\":{\"43\":9,\"93\":8}}],[\"interaction\",{\"1\":{\"21\":1}}],[\"interactions\",{\"1\":{\"4\":1}}],[\"intensity\",{\"1\":{\"31\":1}}],[\"info\",{\"1\":{\"43\":1,\"53\":1}}],[\"invariance\",{\"1\":{\"21\":1,\"32\":1}}],[\"invariant\",{\"1\":{\"21\":1}}],[\"init\",{\"1\":{\"13\":2,\"14\":2,\"17\":4,\"24\":2,\"26\":2,\"27\":2,\"28\":2,\"41\":2,\"43\":6,\"44\":2,\"45\":2,\"46\":3,\"47\":3,\"49\":2,\"50\":2,\"51\":2,\"53\":2,\"54\":2,\"55\":2,\"56\":2,\"59\":2,\"61\":2,\"62\":2,\"67\":2,\"68\":2,\"70\":2,\"71\":2,\"72\":2,\"74\":2,\"75\":2,\"76\":2,\"93\":4,\"96\":1,\"98\":2,\"99\":3,\"100\":4,\"101\":4,\"102\":2,\"103\":5}}],[\"in\",{\"1\":{\"13\":6,\"14\":4,\"17\":8,\"38\":1,\"44\":2,\"49\":1,\"67\":1,\"72\":2,\"75\":1,\"76\":4,\"82\":2,\"83\":1,\"84\":7,\"86\":7,\"92\":2,\"93\":2,\"96\":10,\"98\":4,\"99\":3,\"100\":2,\"101\":8,\"103\":4,\"107\":3}}],[\"indent=4\",{\"1\":{\"96\":1}}],[\"index=5\",{\"1\":{\"60\":2}}],[\"index=ignored\",{\"1\":{\"59\":1}}],[\"index=\",{\"1\":{\"56\":1}}],[\"indexed\",{\"1\":{\"13\":1}}],[\"index\",{\"1\":{\"13\":8,\"17\":3,\"58\":4,\"59\":6,\"60\":5,\"84\":2,\"85\":2,\"86\":4}}],[\"inductive\",{\"1\":{\"94\":1}}],[\"indices\",{\"1\":{\"13\":5,\"24\":1,\"26\":1,\"84\":2,\"86\":2,\"93\":6,\"96\":4}}],[\"inputfeatures\",{\"1\":{\"38\":1}}],[\"inputfeatures组成图解\",{\"1\":{\"38\":1}}],[\"inputs\",{\"1\":{\"38\":8,\"59\":1,\"84\":4,\"86\":4}}],[\"input\",{\"1\":{\"13\":11,\"16\":1,\"17\":3,\"38\":13,\"40\":4,\"41\":6,\"43\":2,\"46\":2,\"47\":2,\"50\":2,\"51\":3,\"54\":1,\"56\":2,\"58\":1,\"59\":2,\"60\":4,\"61\":2,\"62\":7,\"72\":1,\"82\":2,\"91\":6,\"93\":10}}],[\"=>\",{\"1\":{\"76\":1}}],[\"===================\",{\"1\":{\"92\":1,\"93\":1}}],[\"==============\",{\"1\":{\"92\":1,\"93\":1}}],[\"==\",{\"1\":{\"13\":1,\"40\":1,\"43\":1,\"47\":1,\"53\":1,\"60\":1,\"61\":1,\"64\":1,\"76\":2,\"84\":1,\"86\":1,\"93\":2}}],[\"=\",{\"1\":{\"13\":63,\"14\":24,\"17\":53,\"22\":2,\"24\":25,\"25\":5,\"26\":30,\"27\":13,\"28\":20,\"33\":1,\"38\":14,\"40\":7,\"41\":16,\"43\":17,\"44\":2,\"45\":5,\"46\":10,\"47\":14,\"49\":25,\"50\":6,\"51\":4,\"53\":7,\"54\":5,\"55\":4,\"56\":11,\"58\":9,\"59\":17,\"60\":2,\"61\":16,\"62\":17,\"67\":5,\"68\":1,\"70\":2,\"71\":6,\"72\":3,\"74\":9,\"75\":4,\"76\":15,\"81\":9,\"82\":10,\"84\":40,\"85\":9,\"86\":46,\"91\":10,\"92\":8,\"93\":101,\"96\":25,\"97\":6,\"98\":11,\"99\":12,\"100\":15,\"101\":19,\"102\":16,\"103\":28,\"104\":2,\"107\":5}}],[\"dtype\",{\"1\":{\"46\":1}}],[\"dtype=next\",{\"1\":{\"46\":1}}],[\"dtype=torch\",{\"1\":{\"13\":5,\"41\":1,\"91\":1,\"93\":4}}],[\"does\",{\"1\":{\"85\":1,\"86\":1,\"96\":1}}],[\"downloaded\",{\"1\":{\"84\":1,\"86\":1}}],[\"downloading\",{\"1\":{\"84\":2,\"86\":2}}],[\"download\",{\"1\":{\"84\":3,\"86\":4,\"107\":1}}],[\"dot\",{\"1\":{\"49\":1,\"76\":1,\"81\":3,\"84\":1,\"86\":1}}],[\"doing\",{\"1\":{\"47\":1}}],[\"do\",{\"1\":{\"37\":3,\"76\":1}}],[\"dumps\",{\"1\":{\"96\":1}}],[\"dump\",{\"1\":{\"37\":1}}],[\"dall\",{\"1\":{\"79\":3}}],[\"da\",{\"1\":{\"37\":1}}],[\"dataloader\",{\"0\":{\"40\":1},\"1\":{\"40\":3,\"96\":1,\"97\":2}}],[\"dataset\",{\"1\":{\"38\":1,\"40\":3,\"96\":5,\"97\":6}}],[\"data\",{\"1\":{\"13\":14,\"17\":4,\"37\":1,\"85\":9,\"86\":9,\"87\":2,\"96\":3,\"97\":6,\"103\":4}}],[\"dgcnn\",{\"1\":{\"29\":2,\"32\":1}}],[\"drop=0\",{\"1\":{\"101\":1}}],[\"drop=drop\",{\"1\":{\"101\":1}}],[\"drop\",{\"1\":{\"100\":5,\"101\":16,\"102\":8,\"103\":9}}],[\"droppath\",{\"1\":{\"101\":2}}],[\"dropped\",{\"1\":{\"93\":2}}],[\"dropping\",{\"1\":{\"49\":1}}],[\"drop2\",{\"1\":{\"14\":2,\"17\":2}}],[\"dropout防止过拟合\",{\"1\":{\"93\":1}}],[\"dropout=none\",{\"1\":{\"76\":1}}],[\"dropout=self\",{\"1\":{\"76\":1}}],[\"dropout=0\",{\"1\":{\"76\":1}}],[\"dropout\",{\"1\":{\"14\":2,\"16\":1,\"17\":2,\"27\":3,\"41\":4,\"43\":4,\"47\":4,\"49\":4,\"50\":4,\"61\":4,\"62\":4,\"70\":6,\"71\":2,\"74\":2,\"76\":5,\"93\":2,\"100\":1,\"101\":4,\"102\":2,\"103\":1}}],[\"drop1\",{\"1\":{\"14\":2,\"17\":2}}],[\"dict\",{\"1\":{\"96\":2,\"107\":3}}],[\"dict=true\",{\"1\":{\"91\":2,\"93\":1}}],[\"diag\",{\"1\":{\"93\":6}}],[\"directional\",{\"1\":{\"93\":3}}],[\"directory\",{\"1\":{\"84\":5,\"85\":1,\"86\":6}}],[\"dirname\",{\"1\":{\"84\":1,\"86\":1}}],[\"dir\",{\"1\":{\"37\":4,\"84\":16,\"85\":7,\"86\":23}}],[\"dir=save\",{\"1\":{\"84\":1,\"86\":1}}],[\"dir=\",{\"1\":{\"37\":3}}],[\"dim代表的是卷积核的数量\",{\"1\":{\"98\":1}}],[\"dim\",{\"1\":{\"93\":3,\"98\":8,\"99\":6,\"100\":6,\"101\":7,\"102\":17,\"103\":9}}],[\"dimensional\",{\"1\":{\"94\":1}}],[\"dimension\",{\"1\":{\"29\":1}}],[\"dim=embed\",{\"1\":{\"99\":1,\"100\":1,\"103\":2}}],[\"dim=768\",{\"1\":{\"98\":1,\"99\":1,\"100\":1,\"103\":1,\"107\":1}}],[\"dim=2\",{\"1\":{\"93\":2}}],[\"dim=0\",{\"1\":{\"93\":7,\"96\":1}}],[\"dim=1\",{\"1\":{\"17\":1,\"27\":1,\"93\":6,\"99\":1,\"100\":1,\"103\":2}}],[\"dim=\",{\"1\":{\"13\":3,\"17\":1,\"25\":1,\"28\":1,\"49\":1,\"58\":3,\"59\":1,\"68\":1,\"76\":1,\"82\":4,\"91\":2,\"93\":1,\"102\":1}}],[\"distribution\",{\"1\":{\"96\":1}}],[\"distributedsampler\",{\"1\":{\"40\":1}}],[\"dist\",{\"1\":{\"13\":3}}],[\"distance\",{\"1\":{\"13\":7}}],[\"depth\",{\"1\":{\"103\":1}}],[\"depth=12\",{\"1\":{\"100\":1,\"103\":1,\"107\":1}}],[\"desc\",{\"1\":{\"82\":2}}],[\"del\",{\"1\":{\"76\":3}}],[\"decode\",{\"1\":{\"60\":1,\"67\":2}}],[\"decoder模型结构图\",{\"1\":{\"74\":1,\"75\":1}}],[\"decoderlayer\",{\"0\":{\"74\":1},\"1\":{\"74\":2}}],[\"decoder\",{\"0\":{\"67\":1,\"73\":1,\"75\":1},\"1\":{\"54\":2,\"60\":1,\"66\":2,\"67\":4,\"74\":1,\"75\":3,\"89\":1,\"93\":1}}],[\"dense\",{\"1\":{\"43\":4,\"45\":2,\"50\":2,\"53\":2,\"70\":1}}],[\"deep\",{\"1\":{\"32\":1}}],[\"device=sim\",{\"1\":{\"93\":1}}],[\"device=image\",{\"1\":{\"92\":1}}],[\"device=input\",{\"1\":{\"41\":1}}],[\"device\",{\"1\":{\"13\":15,\"41\":1,\"84\":5,\"86\":5,\"91\":2,\"92\":1,\"93\":4,\"103\":4,\"107\":1}}],[\"defined\",{\"1\":{\"74\":1}}],[\"def\",{\"1\":{\"13\":7,\"14\":2,\"17\":4,\"24\":2,\"25\":1,\"26\":2,\"27\":2,\"28\":2,\"38\":3,\"40\":1,\"41\":2,\"43\":6,\"44\":2,\"45\":2,\"46\":2,\"47\":2,\"49\":3,\"50\":2,\"51\":2,\"53\":2,\"54\":2,\"55\":2,\"56\":2,\"59\":2,\"61\":2,\"62\":2,\"67\":4,\"68\":2,\"70\":2,\"71\":2,\"72\":2,\"74\":2,\"75\":2,\"76\":3,\"84\":8,\"85\":3,\"86\":11,\"91\":1,\"93\":9,\"96\":5,\"98\":2,\"99\":3,\"100\":3,\"101\":4,\"102\":2,\"103\":4,\"107\":1}}],[\"d\",{\"1\":{\"13\":4,\"17\":4,\"25\":4,\"49\":2,\"62\":1,\"68\":3,\"76\":15,\"81\":6,\"89\":2,\"100\":2}}],[\"3的维度\",{\"1\":{\"102\":1}}],[\"396\",{\"1\":{\"84\":1}}],[\"336\",{\"1\":{\"81\":1}}],[\"300m数据集\",{\"1\":{\"104\":1}}],[\"300m数据集的规模达到了上亿级别\",{\"1\":{\"87\":1}}],[\"300m数据集取得了较好的结果\",{\"1\":{\"87\":1}}],[\"300m数据集是谷歌从互联网上收集的\",{\"1\":{\"87\":1}}],[\"300m数据集来预训练模型在imagenet上取得sota\",{\"1\":{\"87\":1}}],[\"300m数据集还要多出1亿对\",{\"1\":{\"81\":1}}],[\"3072\",{\"1\":{\"43\":2}}],[\"3x3\",{\"1\":{\"24\":2}}],[\"3×3\",{\"1\":{\"22\":1,\"24\":1,\"25\":1}}],[\"32768\",{\"1\":{\"81\":1}}],[\"320\",{\"1\":{\"17\":1}}],[\"32\",{\"1\":{\"17\":4,\"81\":1,\"93\":5}}],[\"3+d\",{\"1\":{\"13\":3}}],[\"3\",{\"0\":{\"99\":1},\"1\":{\"13\":14,\"14\":5,\"17\":6,\"22\":2,\"24\":9,\"26\":1,\"27\":1,\"41\":1,\"49\":2,\"74\":1,\"76\":1,\"82\":1,\"83\":1,\"86\":1,\"87\":1,\"93\":12,\"96\":1,\"98\":3,\"102\":7}}],[\"3d\",{\"0\":{\"5\":1},\"1\":{\"2\":1,\"4\":1,\"24\":1,\"26\":1,\"29\":1,\"31\":4}}],[\"点的数量\",{\"1\":{\"28\":1}}],[\"点的特征数据\",{\"1\":{\"13\":1}}],[\"点之间的相互作用\",{\"1\":{\"22\":1}}],[\"点之间存在相互作用\",{\"1\":{\"21\":1}}],[\"点与点之间有空间关系\",{\"1\":{\"21\":1}}],[\"点额外特征\",{\"1\":{\"13\":1}}],[\"点坐标\",{\"1\":{\"13\":1}}],[\"点云中点的顺序不影响整体形状\",{\"1\":{\"32\":1}}],[\"点云\",{\"0\":{\"31\":1},\"1\":{\"31\":2}}],[\"点云模型\",{\"1\":{\"29\":1}}],[\"点云是点的集合\",{\"1\":{\"21\":1}}],[\"点云是三维几何数据的一种重要表示形式\",{\"1\":{\"20\":1}}],[\"点云的姿态可能各不相同\",{\"1\":{\"24\":1}}],[\"点云的无序性\",{\"1\":{\"21\":1,\"22\":1}}],[\"点云的额外特征\",{\"1\":{\"13\":1}}],[\"点云坐标数据\",{\"1\":{\"13\":2}}],[\"点集抽象层\",{\"1\":{\"13\":1}}],[\"点集的划分必须产生跨分区的共同结构\",{\"1\":{\"7\":1}}],[\"点集划分是指如何将一个大的点云分割成更小的\",{\"1\":{\"7\":1}}],[\"rwightman\",{\"1\":{\"107\":1}}],[\"root\",{\"1\":{\"84\":2,\"86\":2,\"96\":8}}],[\"rocket\",{\"1\":{\"82\":1}}],[\"rn50x16和rnx64\",{\"1\":{\"81\":1}}],[\"rn50x4\",{\"1\":{\"81\":1}}],[\"rnn等模型的缺点是需要顺序计算\",{\"1\":{\"65\":1}}],[\"rnn\",{\"1\":{\"22\":1}}],[\"right\",{\"1\":{\"74\":1}}],[\"rigid\",{\"1\":{\"25\":1,\"33\":1}}],[\"r\",{\"1\":{\"64\":1}}],[\"run\",{\"1\":{\"37\":1}}],[\"rgb为彩色图片\",{\"1\":{\"96\":1}}],[\"rgb\",{\"1\":{\"31\":1,\"84\":1,\"86\":1,\"96\":3,\"98\":1}}],[\"requires\",{\"1\":{\"107\":1}}],[\"requirements\",{\"1\":{\"64\":2}}],[\"red\",{\"1\":{\"82\":1}}],[\"repo\",{\"1\":{\"84\":1,\"86\":1}}],[\"replace\",{\"1\":{\"84\":1,\"86\":1}}],[\"representation\",{\"0\":{\"91\":1},\"1\":{\"60\":1,\"91\":3,\"92\":2,\"93\":2,\"100\":1,\"103\":3,\"107\":1}}],[\"repeat\",{\"1\":{\"13\":6,\"24\":1,\"26\":1}}],[\"releases\",{\"1\":{\"107\":1}}],[\"related\",{\"1\":{\"101\":1}}],[\"relationship\",{\"1\":{\"55\":4,\"56\":4}}],[\"relu\",{\"1\":{\"13\":2,\"14\":2,\"17\":5,\"24\":8,\"26\":2,\"27\":4,\"28\":3}}],[\"read\",{\"1\":{\"37\":9,\"96\":1,\"97\":1}}],[\"regression\",{\"1\":{\"47\":1}}],[\"regularizer\",{\"1\":{\"25\":3}}],[\"reg\",{\"1\":{\"22\":1}}],[\"region\",{\"1\":{\"13\":2}}],[\"rendering\",{\"1\":{\"20\":1}}],[\"research\",{\"1\":{\"107\":1}}],[\"resize\",{\"1\":{\"97\":2}}],[\"residual\",{\"1\":{\"66\":1}}],[\"resnet和混合模型的效果均不如vit模型\",{\"1\":{\"106\":1}}],[\"resnet和混合模型在不同图像分类数据集上的测试结果\",{\"1\":{\"106\":1}}],[\"resnet101\",{\"1\":{\"81\":1}}],[\"resnet50\",{\"1\":{\"81\":1}}],[\"resnet包含五种不同尺寸的模型\",{\"1\":{\"81\":1}}],[\"resnet\",{\"1\":{\"81\":1,\"106\":1}}],[\"resolution\",{\"0\":{\"18\":1},\"1\":{\"15\":1}}],[\"reshaped\",{\"1\":{\"62\":4}}],[\"reshape\",{\"1\":{\"13\":1,\"24\":1,\"62\":1,\"102\":4}}],[\"returns\",{\"1\":{\"38\":1}}],[\"returnfps\",{\"1\":{\"13\":1}}],[\"returnfps=false\",{\"1\":{\"13\":1}}],[\"return\",{\"1\":{\"13\":13,\"14\":1,\"17\":3,\"24\":1,\"25\":1,\"26\":2,\"27\":1,\"28\":1,\"38\":6,\"40\":1,\"41\":1,\"43\":3,\"44\":1,\"45\":1,\"46\":1,\"47\":1,\"49\":2,\"50\":1,\"51\":1,\"53\":1,\"54\":1,\"55\":1,\"56\":1,\"59\":1,\"61\":1,\"62\":1,\"67\":3,\"68\":1,\"70\":1,\"71\":1,\"72\":1,\"74\":1,\"75\":1,\"76\":2,\"84\":9,\"85\":4,\"86\":13,\"91\":3,\"93\":8,\"96\":7,\"98\":2,\"99\":2,\"100\":2,\"101\":2,\"102\":1,\"103\":2,\"107\":1}}],[\"ratio\",{\"1\":{\"100\":1,\"101\":7,\"102\":2,\"103\":4}}],[\"ratio=dpr\",{\"1\":{\"103\":1}}],[\"ratio=drop\",{\"1\":{\"101\":1,\"103\":1}}],[\"ratio=mlp\",{\"1\":{\"103\":1}}],[\"ratio=attn\",{\"1\":{\"101\":1,\"103\":1}}],[\"ratio=0\",{\"1\":{\"100\":3,\"101\":3,\"102\":2,\"103\":3}}],[\"ratio=4\",{\"1\":{\"100\":1,\"101\":1,\"103\":1}}],[\"rate\",{\"1\":{\"96\":2}}],[\"rate=2e\",{\"1\":{\"37\":1}}],[\"raise\",{\"1\":{\"96\":1}}],[\"raw\",{\"1\":{\"49\":1}}],[\"rank\",{\"1\":{\"40\":1}}],[\"randomhorizontalflip\",{\"1\":{\"97\":1}}],[\"randomresizedcrop\",{\"1\":{\"97\":2}}],[\"randomsampler\",{\"1\":{\"40\":1}}],[\"random\",{\"1\":{\"16\":1,\"96\":2}}],[\"randint\",{\"1\":{\"13\":1}}],[\"range\",{\"1\":{\"13\":1,\"17\":2,\"44\":1,\"84\":1,\"86\":1,\"93\":2,\"96\":2,\"103\":1}}],[\"radius=none\",{\"1\":{\"14\":1}}],[\"radius=0\",{\"1\":{\"14\":2}}],[\"radius^2\",{\"1\":{\"13\":1}}],[\"radius\",{\"1\":{\"13\":12,\"17\":7}}],[\"n为序列长度\",{\"1\":{\"102\":1}}],[\"natural\",{\"1\":{\"83\":1}}],[\"named\",{\"1\":{\"107\":1}}],[\"name=\",{\"1\":{\"37\":1}}],[\"name\",{\"1\":{\"37\":1,\"84\":8,\"86\":8,\"107\":4}}],[\"nlp\",{\"1\":{\"81\":1}}],[\"nbatches\",{\"1\":{\"76\":3}}],[\"n个解码器层\",{\"1\":{\"75\":1}}],[\"null\",{\"1\":{\"38\":1}}],[\"nums\",{\"1\":{\"93\":1}}],[\"numpy\",{\"1\":{\"24\":1,\"82\":2,\"84\":4,\"86\":3,\"97\":2}}],[\"num\",{\"1\":{\"14\":3,\"17\":2,\"37\":1,\"44\":1,\"47\":5,\"49\":5,\"59\":3,\"61\":6,\"62\":9,\"84\":2,\"86\":2,\"93\":3,\"96\":5,\"98\":5,\"99\":9,\"100\":11,\"101\":2,\"102\":24,\"103\":18,\"107\":4}}],[\"number\",{\"1\":{\"13\":2,\"76\":1,\"96\":1}}],[\"np\",{\"1\":{\"24\":2,\"81\":5,\"82\":1,\"84\":6,\"85\":1,\"86\":8}}],[\"npoint=none\",{\"1\":{\"14\":1}}],[\"npoint=128\",{\"1\":{\"14\":1}}],[\"npoint=512\",{\"1\":{\"14\":1}}],[\"npoint\",{\"1\":{\"13\":35,\"17\":4}}],[\"nsp\",{\"1\":{\"38\":1}}],[\"nsp任务\",{\"1\":{\"38\":1}}],[\"ns\",{\"1\":{\"22\":1}}],[\"nsample=none\",{\"1\":{\"14\":1}}],[\"nsample=64\",{\"1\":{\"14\":1}}],[\"nsample=32\",{\"1\":{\"14\":1}}],[\"nsample\",{\"1\":{\"13\":23,\"17\":4}}],[\"nz\",{\"1\":{\"14\":1}}],[\"ny\",{\"1\":{\"14\":1}}],[\"nx\",{\"1\":{\"14\":1}}],[\"nn\",{\"1\":{\"13\":5,\"14\":8,\"17\":15,\"24\":13,\"26\":7,\"27\":8,\"28\":8,\"41\":5,\"43\":6,\"44\":2,\"45\":3,\"47\":2,\"49\":6,\"50\":3,\"51\":1,\"53\":2,\"54\":3,\"55\":2,\"58\":1,\"59\":1,\"61\":2,\"62\":2,\"67\":1,\"68\":2,\"70\":2,\"71\":1,\"72\":1,\"74\":1,\"75\":1,\"76\":3,\"93\":5,\"98\":5,\"99\":4,\"100\":6,\"101\":6,\"102\":5,\"103\":14}}],[\"no\",{\"1\":{\"82\":2,\"84\":2,\"85\":1,\"86\":3,\"93\":1}}],[\"noisy\",{\"1\":{\"21\":1}}],[\"none\",{\"1\":{\"13\":3,\"14\":1,\"17\":6,\"25\":2,\"26\":1,\"38\":4,\"41\":2,\"47\":2,\"49\":1,\"56\":2,\"59\":2,\"61\":2,\"62\":7,\"76\":4,\"84\":3,\"85\":2,\"86\":4,\"93\":9,\"96\":2,\"98\":1,\"107\":1}}],[\"not\",{\"1\":{\"13\":3,\"17\":2,\"38\":1,\"47\":1,\"49\":1,\"56\":2,\"59\":2,\"61\":2,\"62\":4,\"76\":3,\"84\":3,\"85\":2,\"86\":5,\"93\":7,\"96\":2,\"107\":2,\"111\":1}}],[\"norm2\",{\"1\":{\"101\":2}}],[\"norm1\",{\"1\":{\"101\":2}}],[\"norm层之后同样是多头注意力层\",{\"1\":{\"101\":1}}],[\"normalization\",{\"1\":{\"66\":1,\"101\":1}}],[\"normalize\",{\"1\":{\"49\":1,\"81\":2,\"91\":2,\"97\":2}}],[\"normal\",{\"1\":{\"14\":6,\"17\":5,\"31\":1,\"99\":1,\"100\":2,\"103\":2}}],[\"norm\",{\"1\":{\"13\":3,\"14\":3,\"17\":3,\"25\":1,\"41\":1,\"43\":1,\"50\":1,\"53\":1,\"70\":2,\"72\":2,\"75\":2,\"82\":2,\"84\":2,\"86\":2,\"98\":6,\"100\":1,\"101\":3,\"103\":7}}],[\"neighborhood\",{\"1\":{\"94\":1}}],[\"neg\",{\"1\":{\"93\":20}}],[\"negatives\",{\"1\":{\"92\":2}}],[\"needed\",{\"1\":{\"84\":2,\"86\":2}}],[\"neural\",{\"1\":{\"65\":1,\"66\":1}}],[\"ner\",{\"1\":{\"61\":1}}],[\"next\",{\"1\":{\"38\":1,\"56\":5}}],[\"networks\",{\"1\":{\"101\":1}}],[\"network\",{\"1\":{\"24\":1,\"66\":1}}],[\"net\",{\"1\":{\"20\":1,\"22\":2,\"24\":3,\"29\":2}}],[\"netpoll\",{\"1\":{\"2\":1}}],[\"new\",{\"1\":{\"13\":46,\"17\":16,\"49\":4,\"93\":4}}],[\"n\",{\"1\":{\"13\":30,\"17\":4,\"24\":1,\"26\":5,\"28\":9,\"29\":3,\"37\":1,\"64\":1,\"72\":3,\"75\":3,\"81\":7,\"87\":1,\"102\":3}}],[\"提前做好的假设\",{\"1\":{\"94\":1}}],[\"提示\",{\"1\":{\"83\":1}}],[\"提升模型鲁棒性\",{\"1\":{\"24\":2}}],[\"提升了模型的泛化能力和稳定性\",{\"1\":{\"22\":1}}],[\"提高训练的稳定性\",{\"1\":{\"97\":1}}],[\"提高模型的泛化能力\",{\"1\":{\"97\":1}}],[\"提高模型的泛化性能\",{\"1\":{\"17\":1}}],[\"提高算法鲁棒性\",{\"1\":{\"17\":1}}],[\"提高了模型的泛化性和稳健性\",{\"1\":{\"17\":1}}],[\"提高了模型在空间上的泛化能力\",{\"1\":{\"11\":1}}],[\"提取输入图像的特征\",{\"1\":{\"99\":1,\"100\":1,\"103\":1}}],[\"提取图像特征\",{\"1\":{\"82\":1}}],[\"提取文本特征\",{\"1\":{\"82\":1}}],[\"提取的特征图转换为序列形式\",{\"1\":{\"106\":1}}],[\"提取的图像特征则是分类器的输入数据\",{\"1\":{\"82\":1}}],[\"提取的关键点集合\",{\"1\":{\"29\":1}}],[\"提取全局特征\",{\"1\":{\"27\":2}}],[\"提取更高维的特征\",{\"1\":{\"26\":1}}],[\"提取每一点的特征向量\",{\"1\":{\"24\":1}}],[\"提取特征\",{\"1\":{\"22\":1,\"28\":1,\"29\":2}}],[\"提取点云的层次化特征\",{\"1\":{\"14\":1}}],[\"提取这些区域的高维特征\",{\"1\":{\"13\":1}}],[\"提取这些局部区域中的点及其特征\",{\"1\":{\"13\":1}}],[\"为\",{\"1\":{\"103\":1}}],[\"为特定任务动态构建了一个分类器\",{\"1\":{\"82\":1}}],[\"为什么答案来自\",{\"1\":{\"60\":1}}],[\"为什么需要这个正则化项\",{\"1\":{\"25\":1}}],[\"为当前批次中的每个序列样本生成一个位置序列\",{\"1\":{\"41\":1}}],[\"为后续三维深度学习奠定了基础\",{\"1\":{\"22\":1}}],[\"为后续的处理步骤提供信息\",{\"1\":{\"18\":1}}],[\"为此\",{\"1\":{\"18\":1}}],[\"为每个图像选择一个负样本文本\",{\"1\":{\"93\":1}}],[\"为每个文本选择一个负样本图像\",{\"1\":{\"93\":1}}],[\"为每个类别创建一个描述性的文本\",{\"1\":{\"82\":1}}],[\"为每个尺度构建一个独立的小型\",{\"1\":{\"17\":1}}],[\"为每个关键点构建局部邻域\",{\"1\":{\"13\":1}}],[\"为了充分利用预训练的权重\",{\"1\":{\"97\":1}}],[\"为了训练好q\",{\"1\":{\"91\":1}}],[\"为了训练clip模型\",{\"1\":{\"81\":1}}],[\"为了弥补数据规模上的差距\",{\"1\":{\"87\":1}}],[\"为了实现文字搜索图像的功能\",{\"1\":{\"85\":1}}],[\"为了简单\",{\"1\":{\"70\":1}}],[\"为了提升模型对点云姿态变化的鲁棒性\",{\"1\":{\"25\":1}}],[\"为了解决这一问题\",{\"1\":{\"15\":1}}],[\"为了模仿传统卷积网络中的权重共享机制以提高学习效率和模型的泛化能力\",{\"1\":{\"7\":1}}],[\"为了能够在不同的局部子集上共享权重\",{\"1\":{\"7\":1}}],[\"利用\",{\"1\":{\"91\":1,\"106\":1}}],[\"利用已有的vit\",{\"1\":{\"89\":1}}],[\"利用对称函数\",{\"1\":{\"20\":1}}],[\"利用相对坐标与点特征相结合的方式可以捕获局部区域中点与点之间的关系\",{\"1\":{\"12\":1}}],[\"利用上一步得到的中心点将点集划分成若干个区域\",{\"1\":{\"8\":1}}],[\"实例化验证数据集\",{\"1\":{\"97\":1}}],[\"实例化训练数据集\",{\"1\":{\"97\":1}}],[\"实验结果如下表所示\",{\"1\":{\"100\":1}}],[\"实验采用的是花蕊数据集\",{\"1\":{\"96\":1}}],[\"实验观察\",{\"1\":{\"29\":1}}],[\"实验验证\",{\"1\":{\"22\":1,\"29\":1}}],[\"实验证明\",{\"1\":{\"22\":1}}],[\"实际上\",{\"1\":{\"87\":1}}],[\"实际上是用一个固定大小的全局特征去\",{\"1\":{\"29\":1}}],[\"实际上没有局部的概念\",{\"1\":{\"7\":1}}],[\"实际采集的点云常有遮挡\",{\"1\":{\"21\":1}}],[\"实现zero\",{\"1\":{\"82\":1,\"90\":1}}],[\"实现变换不变性\",{\"1\":{\"22\":1}}],[\"实现对称性\",{\"1\":{\"22\":1}}],[\"实现点集顺序不变性\",{\"1\":{\"20\":1}}],[\"实现方法\",{\"1\":{\"12\":1}}],[\"局部建模能力弱\",{\"1\":{\"29\":1}}],[\"局部特征实现上下文感知\",{\"1\":{\"29\":1}}],[\"局部特征编码\",{\"1\":{\"13\":1}}],[\"局部特征学习器\",{\"1\":{\"7\":1}}],[\"局部区域\",{\"1\":{\"13\":1}}],[\"局部区域中的每个点将相对于形心所在位置进行调整\",{\"1\":{\"12\":1}}],[\"局部区域中的点转换成相对于形心的局部坐标系\",{\"1\":{\"12\":1}}],[\"局部坐标系转换\",{\"1\":{\"12\":1}}],[\"规模一致性\",{\"1\":{\"11\":1}}],[\"距离直观性\",{\"1\":{\"11\":1}}],[\"距离的度量不受空间中位置的影响\",{\"1\":{\"11\":1}}],[\"空间中的位置\",{\"1\":{\"31\":1}}],[\"空间变换网络\",{\"1\":{\"20\":1,\"22\":1}}],[\"空间是均匀和各向同性的\",{\"1\":{\"11\":1}}],[\"空间均匀性\",{\"1\":{\"11\":1}}],[\"两点注意\",{\"1\":{\"96\":1}}],[\"两点的距离反映了这两点的实际相似度或关联度\",{\"1\":{\"11\":1}}],[\"两者的训练效率相差3倍\",{\"1\":{\"87\":1}}],[\"两个句子是否为上下句关系\",{\"1\":{\"55\":1}}],[\"两个点之间的直线距离被认为是相似度或连接强度的直观表示\",{\"1\":{\"11\":1}}],[\"两个问题是相关联的\",{\"1\":{\"7\":1}}],[\"即网格大小的乘积\",{\"1\":{\"98\":1}}],[\"即图像在水平和垂直方向上分别可以划分的图像块数量\",{\"1\":{\"98\":1}}],[\"即图片上相邻的区域具有相似的特征\",{\"1\":{\"94\":1}}],[\"即一种先验知识\",{\"1\":{\"94\":1}}],[\"即文本和图像可能不完全匹配\",{\"1\":{\"87\":1}}],[\"即基于对比学习的方法\",{\"1\":{\"87\":1}}],[\"即基于文本弱监督来提升性能\",{\"1\":{\"87\":1}}],[\"即为与当前文本描述相似度最高的那副图片\",{\"1\":{\"85\":1}}],[\"即真正属于一对的文本和图像\",{\"1\":{\"81\":1}}],[\"即上图所示的矩阵\",{\"1\":{\"81\":1}}],[\"即上一层级\",{\"1\":{\"18\":1}}],[\"即\",{\"1\":{\"26\":1,\"29\":1,\"32\":1,\"59\":1,\"60\":1}}],[\"即只改变物体的方向而不改变形状和大小\",{\"1\":{\"25\":1}}],[\"即只依赖一小部分关键点就能判断整体形状\",{\"1\":{\"22\":1}}],[\"即使是一维位置编码\",{\"1\":{\"100\":1}}],[\"即使其他点都在\",{\"1\":{\"29\":1}}],[\"即使\",{\"1\":{\"22\":1}}],[\"即使丢失一些点或加入异常点\",{\"1\":{\"22\":1}}],[\"即对点顺序不敏感\",{\"1\":{\"22\":1}}],[\"即随机移除一部分输入点\",{\"1\":{\"17\":1}}],[\"即每个图像块经过卷积操作后得到的特征向量的维度\",{\"1\":{\"98\":1}}],[\"即每个点的各个类别得分\",{\"1\":{\"28\":1}}],[\"即每个查询点有一个特征向量\",{\"1\":{\"13\":1}}],[\"即每个局部邻域内的点数量维度\",{\"1\":{\"13\":1}}],[\"即空间中的任何距离值具有相似的含义\",{\"1\":{\"11\":1}}],[\"即任何方向上的度量都是等价的\",{\"1\":{\"11\":1}}],[\"即任务是找到点云集中的局部区域的中心点\",{\"1\":{\"10\":1}}],[\"即在欧氏空间中\",{\"1\":{\"11\":1}}],[\"欧式距离的均匀性假设\",{\"1\":{\"11\":1}}],[\"计算梯度\",{\"1\":{\"103\":1}}],[\"计算预测结果与真实标签之间的交叉熵损失\",{\"1\":{\"103\":1}}],[\"计算预测正确的样本数\",{\"1\":{\"103\":1}}],[\"计算公式如下\",{\"1\":{\"101\":1}}],[\"计算图像块的数量\",{\"1\":{\"99\":1,\"100\":1,\"103\":1}}],[\"计算图像块的总数\",{\"1\":{\"98\":1}}],[\"计算图像嵌入向量列表中每个图像对应的嵌入向量和传入的分类文本嵌入向量的余弦相似度\",{\"1\":{\"84\":1}}],[\"计算网格大小\",{\"1\":{\"98\":1}}],[\"计算上下文表示\",{\"1\":{\"93\":1}}],[\"计算注意力分数\",{\"1\":{\"93\":1}}],[\"计算序列长度\",{\"1\":{\"93\":1}}],[\"计算\",{\"1\":{\"92\":1,\"101\":1}}],[\"计算每个注意力头的维度\",{\"1\":{\"102\":1}}],[\"计算每个query\",{\"1\":{\"92\":1}}],[\"计算每个查询点\",{\"1\":{\"13\":1}}],[\"计算一个\",{\"1\":{\"92\":1}}],[\"计算这批图像嵌入向量中每一个图像嵌入向量和我们所有分类文本嵌入向量的余弦相似度\",{\"1\":{\"84\":1}}],[\"计算余弦相似度\",{\"1\":{\"82\":1}}],[\"计算缩放的余弦相似度\",{\"1\":{\"81\":1}}],[\"计算交叉熵损失\",{\"1\":{\"59\":1,\"93\":1}}],[\"计算掩码语言损失\",{\"1\":{\"56\":1}}],[\"计算当前批次中所有序列的实际最大长度\",{\"1\":{\"40\":1}}],[\"计算当前中心点与所有点之间的欧氏距离平方\",{\"1\":{\"13\":1}}],[\"计算需要填充的长度\",{\"1\":{\"38\":1}}],[\"计算点集的分布特性\",{\"1\":{\"32\":1}}],[\"计算复杂度高\",{\"1\":{\"31\":1}}],[\"计算变换矩阵与其转置相乘后与单位矩阵之间的距离\",{\"1\":{\"25\":1}}],[\"计算量大\",{\"1\":{\"20\":1}}],[\"计算效率问题\",{\"1\":{\"11\":1}}],[\"计算成本\",{\"1\":{\"10\":1}}],[\"半径太小可能无法有效捕获足够的局部详细\",{\"1\":{\"11\":1}}],[\"通道维度特征提取阶段\",{\"1\":{\"24\":1}}],[\"通常在大规模数据集\",{\"1\":{\"97\":1}}],[\"通常是随机初始化或者初始化为零\",{\"1\":{\"100\":1}}],[\"通常是\",{\"1\":{\"59\":1,\"104\":1}}],[\"通常是旋转或反射\",{\"1\":{\"24\":1}}],[\"通常会设置一个上限k\",{\"1\":{\"11\":1}}],[\"通过将图像切成小片\",{\"1\":{\"108\":1}}],[\"通过将特征映射到特定的维度并进行非线性变换\",{\"1\":{\"103\":1}}],[\"通过将局部区域中的每个点\",{\"1\":{\"12\":1}}],[\"通过encoder\",{\"1\":{\"103\":1}}],[\"通过投影层对合并后的张量进行线性变换\",{\"1\":{\"102\":1}}],[\"通过qkv线性层将输入x映射到dim\",{\"1\":{\"102\":1}}],[\"通过第二个全连接层\",{\"1\":{\"101\":1}}],[\"通过第一个全连接层\",{\"1\":{\"101\":1}}],[\"通过激活函数层\",{\"1\":{\"101\":1}}],[\"通过分类头\",{\"1\":{\"99\":1,\"100\":1,\"103\":1}}],[\"通过与其他\",{\"1\":{\"99\":1}}],[\"通过计算损失\",{\"1\":{\"99\":1}}],[\"通过自注意力机制与其他\",{\"1\":{\"99\":1}}],[\"通过随机裁剪可以增加训练数据的多样性\",{\"1\":{\"97\":1}}],[\"通过随机丢弃来模拟不同密度的采样\",{\"1\":{\"17\":1}}],[\"通过学习image\",{\"1\":{\"93\":1}}],[\"通过一些自动化的手段将web\",{\"1\":{\"87\":1}}],[\"通过模型获取图片的特征嵌入\",{\"1\":{\"84\":1}}],[\"通过这种方式\",{\"1\":{\"82\":1}}],[\"通过softmax函数转换后\",{\"1\":{\"82\":1}}],[\"通过填充掩码\",{\"1\":{\"66\":1}}],[\"通过调用\",{\"1\":{\"58\":1}}],[\"通过\",{\"1\":{\"22\":1,\"24\":1}}],[\"通过pointnet获取每个形心多尺度信息\",{\"1\":{\"17\":1}}],[\"通过多个局部区域球查询提取不同尺度的局部特征\",{\"1\":{\"17\":1}}],[\"通过多层\",{\"1\":{\"14\":1,\"99\":1}}],[\"通过较大的邻域尺度避免过度稀疏的问题\",{\"1\":{\"16\":1}}],[\"通过较小的邻域尺度捕获细节\",{\"1\":{\"16\":1}}],[\"通过全连接层进行分类\",{\"1\":{\"14\":1}}],[\"通过查找形心点周围的\",{\"1\":{\"9\":1}}],[\"通过局部特征学习器\",{\"1\":{\"7\":1}}],[\"相媲美的效果\",{\"1\":{\"108\":1}}],[\"相似度如下所示\",{\"1\":{\"82\":1}}],[\"相比之下\",{\"1\":{\"29\":1,\"87\":1}}],[\"相比于随机采样\",{\"1\":{\"10\":1}}],[\"相当于直接输入一篇五万字的文章\",{\"1\":{\"98\":1}}],[\"相当于告诉模型\",{\"1\":{\"28\":1}}],[\"相当于加了一个\",{\"1\":{\"24\":1}}],[\"相反\",{\"1\":{\"11\":1,\"18\":1}}],[\"但默认的组合方式可能不满足所有需求\",{\"1\":{\"96\":1}}],[\"但发现这种方法的训练效率\",{\"1\":{\"87\":1}}],[\"但存在一定的噪声\",{\"1\":{\"87\":1}}],[\"但实际上\",{\"1\":{\"83\":1}}],[\"但其主要目的是训练可迁移的视觉模型\",{\"1\":{\"81\":1}}],[\"但可用于特定任务\",{\"1\":{\"32\":1}}],[\"但它也为后续模型奠定了基础\",{\"1\":{\"29\":1}}],[\"但它是为了统一接口设计的一个占位符\",{\"1\":{\"13\":1}}],[\"但如果训练时没有加入扰动\",{\"1\":{\"29\":1}}],[\"但这些模型仍然采用固定类别的softmax分类器进行预训练\",{\"1\":{\"87\":1}}],[\"但这种方式表达能力有限\",{\"1\":{\"29\":1}}],[\"但这可能导致所选邻域的实际尺寸随点的密度变化而变化\",{\"1\":{\"11\":1}}],[\"但遇到遮挡严重或点分布不均匀时性能下降明显\",{\"1\":{\"29\":1}}],[\"但在处理超大规模点云时\",{\"1\":{\"29\":1}}],[\"但在精度上仍略逊一筹\",{\"1\":{\"29\":1}}],[\"但在一些复杂区域\",{\"1\":{\"29\":1}}],[\"但在计算上可能非常昂贵\",{\"1\":{\"18\":1}}],[\"但由于它们是神经网络直接预测出来的\",{\"1\":{\"25\":1}}],[\"但由于其无序性和非规则性\",{\"1\":{\"20\":1}}],[\"但是训练速度还是挺快的\",{\"1\":{\"107\":1}}],[\"但是当数据量逐渐增大时\",{\"1\":{\"104\":1}}],[\"但是当训练数据集不够大的时候\",{\"1\":{\"94\":1}}],[\"但是迁移到其它数据集训练时\",{\"1\":{\"103\":1}}],[\"但是和transformer原始的encoder还是有所区别\",{\"1\":{\"101\":1}}],[\"但是和rnn相比\",{\"1\":{\"65\":1}}],[\"但是实际的代码实现中\",{\"1\":{\"98\":1}}],[\"但是这样造成的一个后果是计算量太庞大\",{\"1\":{\"98\":1}}],[\"但是对于vit这个结构而言\",{\"1\":{\"97\":1}}],[\"但是尺度不同\",{\"1\":{\"17\":1}}],[\"但是在一个场景中有多个物体时则不好办\",{\"1\":{\"7\":1}}],[\"该模型是在\",{\"1\":{\"107\":1}}],[\"该模型联合训练一个cnn和文本transformer来预测图像的文本描述\",{\"1\":{\"87\":1}}],[\"该模块可以为后续的分类任务提供更具区分性和稳定性的特征表示\",{\"1\":{\"103\":1}}],[\"该类的作用是将二维图像分割成多个图像块\",{\"1\":{\"98\":1}}],[\"该方法正是clip在vlp领域发扬光大的\",{\"1\":{\"92\":1}}],[\"该方法能更好的覆盖整个点集\",{\"1\":{\"10\":1}}],[\"该函数作用是针对给定的图片路径\",{\"1\":{\"84\":1}}],[\"该示例中的任务涉及8个类别\",{\"1\":{\"82\":1}}],[\"该范围确保局部区域的尺度是固定的\",{\"1\":{\"11\":1}}],[\"bool\",{\"1\":{\"107\":1}}],[\"bottleneck\",{\"1\":{\"22\":1,\"29\":1}}],[\"b为批量大小\",{\"1\":{\"102\":1}}],[\"bs\",{\"1\":{\"93\":19}}],[\"block第一个全连接的节点个数\",{\"1\":{\"104\":1}}],[\"block的次数\",{\"1\":{\"104\":1}}],[\"block块序列\",{\"1\":{\"103\":2}}],[\"block\",{\"1\":{\"101\":3,\"103\":1}}],[\"blocks\",{\"1\":{\"17\":7,\"103\":2}}],[\"blob\",{\"1\":{\"96\":1}}],[\"blip\",{\"1\":{\"89\":2,\"90\":1}}],[\"blip2base\",{\"1\":{\"91\":1}}],[\"blip2qformer\",{\"1\":{\"91\":1}}],[\"blip2qformer核心代码实现如下\",{\"1\":{\"91\":1}}],[\"blip2\",{\"1\":{\"88\":1}}],[\"black\",{\"1\":{\"82\":1}}],[\"but\",{\"1\":{\"49\":1,\"54\":1}}],[\"build\",{\"1\":{\"38\":1}}],[\"billion\",{\"1\":{\"104\":1}}],[\"bi\",{\"1\":{\"93\":2}}],[\"bias=qkv\",{\"1\":{\"101\":1,\"102\":1,\"103\":1}}],[\"bias=true\",{\"1\":{\"100\":1,\"103\":1}}],[\"bias=false\",{\"1\":{\"54\":1,\"101\":1,\"102\":1}}],[\"bias\",{\"1\":{\"54\":3,\"94\":1,\"101\":1,\"102\":1,\"103\":1}}],[\"bit\",{\"1\":{\"49\":1}}],[\"bin\",{\"1\":{\"37\":1}}],[\"binary\",{\"0\":{\"2\":1},\"1\":{\"0\":1}}],[\"binaryoracle\",{\"1\":{\"0\":1}}],[\"bytenet和convs2s等网络模型\",{\"1\":{\"65\":1}}],[\"by\",{\"1\":{\"45\":1}}],[\"below\",{\"1\":{\"74\":1}}],[\"between\",{\"1\":{\"49\":1}}],[\"be\",{\"1\":{\"38\":1}}],[\"bert支持的下游任务图\",{\"1\":{\"57\":1}}],[\"bertformultiplechoice\",{\"1\":{\"62\":2}}],[\"bertfortokenclassification\",{\"1\":{\"61\":2}}],[\"bertforquestionanswering\",{\"1\":{\"58\":1,\"59\":2}}],[\"bertforpretraining结构图\",{\"1\":{\"56\":1}}],[\"bertforpretraining\",{\"0\":{\"56\":1},\"1\":{\"56\":2}}],[\"bertforsequenceclassification模型结构图\",{\"1\":{\"47\":1}}],[\"bertforsequenceclassification\",{\"0\":{\"47\":1},\"1\":{\"47\":2}}],[\"bertlmpredictionhead结构图\",{\"1\":{\"54\":1}}],[\"bertlmpredictionhead\",{\"0\":{\"54\":1},\"1\":{\"54\":2,\"55\":1}}],[\"bertlayer模型结构图\",{\"1\":{\"43\":1}}],[\"bertlayer\",{\"0\":{\"43\":1},\"1\":{\"43\":2,\"44\":1,\"93\":2}}],[\"bertlayernorm\",{\"1\":{\"41\":1,\"43\":1,\"50\":1,\"53\":1}}],[\"bertselfoutput计算流程图\",{\"1\":{\"50\":1}}],[\"bertselfoutput\",{\"0\":{\"50\":1},\"1\":{\"50\":2,\"51\":1,\"93\":1}}],[\"bertselfattention\",{\"0\":{\"49\":1},\"1\":{\"49\":2,\"51\":1,\"93\":2}}],[\"bertpretrainingheads结构图\",{\"1\":{\"55\":1}}],[\"bertpretrainingheads\",{\"0\":{\"55\":1},\"1\":{\"55\":2,\"56\":1}}],[\"bertpretrainedmodel\",{\"1\":{\"46\":1,\"47\":1,\"56\":1,\"59\":1,\"61\":1,\"62\":1}}],[\"bertpredictionheadtransform结构图\",{\"1\":{\"53\":1}}],[\"bertpredictionheadtransform\",{\"0\":{\"53\":1},\"1\":{\"53\":2,\"54\":1}}],[\"bertpooler模型结构图\",{\"1\":{\"45\":1}}],[\"bertpooler\",{\"0\":{\"45\":1},\"1\":{\"45\":2,\"46\":1}}],[\"bertmodel模型结构图\",{\"1\":{\"46\":1}}],[\"bertmodel\",{\"0\":{\"46\":1},\"1\":{\"46\":2,\"47\":1,\"49\":1,\"56\":1,\"59\":1,\"61\":1,\"62\":1}}],[\"bertattention计算流程图\",{\"1\":{\"51\":1}}],[\"bertattention\",{\"0\":{\"48\":1,\"51\":1},\"1\":{\"43\":1,\"51\":2,\"93\":3}}],[\"bertoutput\",{\"1\":{\"43\":3,\"93\":2}}],[\"bertintermediate\",{\"1\":{\"43\":3,\"93\":2}}],[\"bertencoder模型结构图\",{\"1\":{\"44\":1}}],[\"bertencoder\",{\"0\":{\"42\":1,\"44\":1},\"1\":{\"44\":2,\"46\":1}}],[\"bertembeddings会将text\",{\"1\":{\"93\":1}}],[\"bertembeddings\",{\"0\":{\"41\":1},\"1\":{\"41\":2,\"46\":1,\"93\":1}}],[\"berttokenizer\",{\"1\":{\"38\":3,\"58\":1}}],[\"berttokenizer中的特殊token\",{\"1\":{\"38\":1}}],[\"bert文本分类实战\",{\"1\":{\"36\":1}}],[\"bert\",{\"0\":{\"36\":1},\"1\":{\"37\":16,\"38\":1,\"47\":2,\"56\":2,\"58\":5,\"59\":2,\"60\":9,\"61\":2,\"62\":7,\"91\":2,\"93\":1}}],[\"bmm\",{\"1\":{\"24\":1,\"25\":1,\"26\":2}}],[\"bn5\",{\"1\":{\"24\":2}}],[\"bn4\",{\"1\":{\"24\":2}}],[\"bn3\",{\"1\":{\"24\":2,\"26\":2,\"28\":2}}],[\"bn2\",{\"1\":{\"14\":2,\"17\":2,\"24\":2,\"26\":2,\"27\":2,\"28\":2}}],[\"bn1\",{\"1\":{\"14\":2,\"17\":2,\"24\":2,\"26\":2,\"27\":2,\"28\":2}}],[\"bn\",{\"1\":{\"13\":2,\"17\":7,\"24\":1}}],[\"bns\",{\"1\":{\"13\":3,\"17\":3}}],[\"backward\",{\"1\":{\"103\":1}}],[\"bar\",{\"1\":{\"96\":1}}],[\"bart\",{\"1\":{\"60\":1}}],[\"baidu\",{\"1\":{\"96\":1,\"107\":1}}],[\"bag\",{\"1\":{\"87\":3}}],[\"basename\",{\"1\":{\"84\":1,\"86\":1}}],[\"base\",{\"1\":{\"37\":6,\"97\":1,\"107\":7}}],[\"based\",{\"1\":{\"29\":2,\"32\":1}}],[\"batch和text\",{\"1\":{\"91\":1}}],[\"batches\",{\"1\":{\"76\":1,\"84\":2,\"86\":2}}],[\"batchsize\",{\"1\":{\"24\":2,\"25\":1,\"28\":2}}],[\"batchnorm1d\",{\"1\":{\"14\":2,\"17\":2,\"24\":5,\"26\":3,\"27\":2,\"28\":3}}],[\"batchnorm\",{\"1\":{\"13\":1,\"26\":1}}],[\"batchnorm2d\",{\"1\":{\"13\":1,\"17\":1}}],[\"batch\",{\"1\":{\"13\":13,\"24\":6,\"25\":2,\"37\":2,\"40\":4,\"49\":2,\"58\":6,\"59\":3,\"61\":2,\"62\":7,\"76\":2,\"84\":9,\"86\":9,\"91\":1,\"92\":2,\"93\":1,\"96\":4,\"97\":2,\"102\":10}}],[\"ball\",{\"1\":{\"11\":4,\"13\":6,\"17\":2}}],[\"b\",{\"1\":{\"13\":56,\"14\":2,\"17\":11,\"24\":3,\"26\":4,\"28\":7,\"38\":1,\"62\":1,\"81\":2,\"89\":2,\"91\":8,\"92\":17,\"93\":10,\"97\":3,\"98\":8,\"99\":7,\"100\":5,\"102\":3,\"103\":5,\"104\":1,\"107\":2}}],[\"低密度区域则过于稀缺\",{\"1\":{\"10\":1}}],[\"样本分布偏差\",{\"1\":{\"10\":1}}],[\"可学习位置嵌入\",{\"1\":{\"100\":1}}],[\"可认为是模型参数一部分\",{\"1\":{\"91\":1}}],[\"可使用成熟的\",{\"1\":{\"31\":1}}],[\"可选颜色\",{\"1\":{\"31\":1}}],[\"可选属性\",{\"1\":{\"31\":1}}],[\"可选\",{\"0\":{\"30\":1},\"1\":{\"13\":1,\"26\":1}}],[\"可改进的地方\",{\"1\":{\"11\":1}}],[\"可能遗漏重要细节\",{\"1\":{\"29\":1}}],[\"可能不足以代表复杂的局部结构\",{\"1\":{\"29\":1}}],[\"可能无法捕捉重要的几何细节\",{\"1\":{\"10\":1}}],[\"可能导致样本在高密度区域内过度集中\",{\"1\":{\"10\":1}}],[\"可能存在的问题\",{\"1\":{\"10\":1}}],[\"可以利用其自注意力机制捕捉特征之间的长距离依赖关系\",{\"1\":{\"106\":1}}],[\"可以使用预训练的\",{\"1\":{\"106\":1}}],[\"可以看这篇文章\",{\"1\":{\"102\":1}}],[\"可以看到当epochs增大时\",{\"1\":{\"106\":1}}],[\"可以看到\",{\"1\":{\"100\":2,\"101\":1,\"104\":1,\"105\":1}}],[\"可以看到8个图像\",{\"1\":{\"82\":1}}],[\"可以看到对于要预测的8个图像\",{\"1\":{\"82\":1}}],[\"可以变成一个\",{\"1\":{\"98\":1}}],[\"可以直接通过类名调用\",{\"1\":{\"96\":1}}],[\"可以将搜索范围限制在满足这些性质的模型子空间内\",{\"1\":{\"94\":1}}],[\"可以将其平移到坐标系的中心\",{\"1\":{\"7\":1}}],[\"可以在下游任务中获得较好的迁移效果\",{\"1\":{\"94\":1}}],[\"可以学习到如何更好地结合文本提取图片信息\",{\"1\":{\"91\":1}}],[\"可以参考论文\",{\"1\":{\"83\":1}}],[\"可以得到每个类别的预测概率\",{\"1\":{\"82\":1}}],[\"可以概括为以下两个主要步骤\",{\"1\":{\"82\":1}}],[\"可以处理任意顺序的点集\",{\"1\":{\"22\":1}}],[\"可以先去了解一下python中的高级索引机制\",{\"1\":{\"13\":1}}],[\"可以理解为\",{\"1\":{\"7\":1}}],[\"flatten\",{\"1\":{\"98\":1}}],[\"flag\",{\"1\":{\"82\":1}}],[\"flowerclassify\",{\"1\":{\"84\":1,\"86\":1}}],[\"flower\",{\"1\":{\"84\":4,\"86\":2,\"96\":8}}],[\"float\",{\"1\":{\"82\":2,\"96\":1}}],[\"float32\",{\"1\":{\"24\":1}}],[\"feed\",{\"1\":{\"66\":1,\"71\":4,\"74\":5,\"93\":8}}],[\"feat相似度最大的那个query\",{\"1\":{\"92\":2}}],[\"feats\",{\"1\":{\"91\":1,\"92\":5}}],[\"feat=false\",{\"1\":{\"26\":2,\"28\":1}}],[\"feat=true\",{\"1\":{\"26\":2,\"27\":1}}],[\"feat\",{\"1\":{\"26\":10,\"27\":4,\"28\":4,\"91\":1,\"92\":8}}],[\"features=none\",{\"1\":{\"101\":2}}],[\"features=mlp\",{\"1\":{\"101\":1}}],[\"features=dim\",{\"1\":{\"101\":1}}],[\"features\",{\"1\":{\"38\":1,\"82\":10,\"84\":4,\"86\":4,\"87\":1,\"99\":3,\"100\":3,\"101\":15,\"103\":5}}],[\"feature\",{\"1\":{\"7\":2,\"13\":1,\"17\":1,\"25\":3,\"26\":5,\"27\":4,\"28\":3}}],[\"freq\",{\"1\":{\"93\":1}}],[\"france\",{\"1\":{\"60\":2}}],[\"frozen\",{\"1\":{\"91\":1}}],[\"frobenius\",{\"1\":{\"25\":2}}],[\"from\",{\"1\":{\"24\":1,\"38\":2,\"49\":1,\"76\":1,\"84\":2,\"85\":2,\"86\":8,\"87\":2,\"91\":1,\"93\":1,\"96\":2,\"107\":2}}],[\"fp16\",{\"1\":{\"46\":1}}],[\"fps是一种在点云\",{\"1\":{\"10\":1}}],[\"fps\",{\"1\":{\"10\":1,\"13\":7,\"17\":1}}],[\"fn=val\",{\"1\":{\"97\":1}}],[\"fn=train\",{\"1\":{\"97\":1}}],[\"fn=collate\",{\"1\":{\"40\":1}}],[\"fn负责对返回的一个batch\",{\"1\":{\"40\":1}}],[\"fn\",{\"1\":{\"40\":2,\"43\":3,\"53\":3,\"96\":2,\"97\":2}}],[\"found\",{\"1\":{\"85\":1,\"86\":1,\"96\":1,\"111\":1}}],[\"follow\",{\"1\":{\"71\":1,\"74\":1}}],[\"following\",{\"1\":{\"38\":1}}],[\"former类比为一个self\",{\"1\":{\"91\":1}}],[\"former\",{\"1\":{\"91\":4}}],[\"former模块做模态融合\",{\"1\":{\"89\":1}}],[\"format\",{\"1\":{\"38\":1,\"96\":5,\"107\":1}}],[\"forward\",{\"1\":{\"13\":1,\"14\":1,\"17\":2,\"24\":1,\"26\":1,\"27\":1,\"28\":1,\"41\":1,\"43\":3,\"44\":1,\"45\":1,\"46\":1,\"47\":1,\"49\":2,\"50\":1,\"51\":1,\"53\":1,\"54\":1,\"55\":1,\"56\":1,\"59\":1,\"61\":1,\"62\":1,\"66\":1,\"67\":1,\"68\":1,\"70\":1,\"71\":5,\"72\":1,\"74\":6,\"75\":1,\"76\":1,\"91\":1,\"93\":15,\"98\":1,\"99\":3,\"100\":3,\"101\":2,\"102\":1,\"103\":3}}],[\"for\",{\"1\":{\"13\":3,\"17\":4,\"24\":1,\"44\":2,\"49\":5,\"54\":1,\"71\":1,\"72\":1,\"74\":1,\"75\":1,\"76\":1,\"82\":1,\"84\":6,\"85\":2,\"86\":8,\"93\":10,\"96\":9,\"103\":2,\"107\":1}}],[\"find\",{\"1\":{\"85\":2,\"86\":2}}],[\"finetune\",{\"1\":{\"81\":1}}],[\"final\",{\"1\":{\"76\":1}}],[\"filterwarnings\",{\"1\":{\"86\":1}}],[\"file\",{\"1\":{\"84\":5,\"86\":5,\"96\":2}}],[\"files\",{\"1\":{\"84\":2,\"86\":2}}],[\"file$bert\",{\"1\":{\"37\":1}}],[\"fill\",{\"1\":{\"76\":1}}],[\"figure\",{\"1\":{\"71\":1,\"74\":1,\"76\":1}}],[\"first\",{\"1\":{\"13\":2,\"38\":2,\"45\":3}}],[\"fstn\",{\"1\":{\"26\":2}}],[\"facial\",{\"1\":{\"82\":1}}],[\"false\",{\"1\":{\"26\":1,\"93\":1,\"107\":1}}],[\"farthest\",{\"1\":{\"13\":8,\"17\":1}}],[\"f^2\",{\"1\":{\"22\":1}}],[\"function\",{\"1\":{\"22\":1,\"32\":1,\"49\":1,\"103\":1}}],[\"fxia22\",{\"1\":{\"19\":1}}],[\"fct\",{\"1\":{\"47\":4,\"56\":3,\"59\":3,\"61\":3,\"62\":2}}],[\"fc\",{\"1\":{\"24\":1,\"103\":1}}],[\"fc3\",{\"1\":{\"14\":2,\"17\":2,\"24\":2,\"27\":2}}],[\"fc2\",{\"1\":{\"14\":2,\"17\":2,\"24\":2,\"27\":2,\"101\":2}}],[\"fc1\",{\"1\":{\"14\":2,\"17\":2,\"24\":2,\"27\":2,\"101\":2}}],[\"f\",{\"1\":{\"13\":1,\"14\":3,\"17\":4,\"22\":2,\"24\":5,\"26\":2,\"27\":3,\"28\":4,\"68\":1,\"81\":4,\"84\":7,\"85\":4,\"86\":11,\"91\":2,\"92\":2,\"93\":3}}],[\"使特征分布更稳定\",{\"1\":{\"25\":1}}],[\"使其符合模型的输入要求\",{\"1\":{\"84\":1}}],[\"使其标准化\",{\"1\":{\"25\":1}}],[\"使其姿态统一\",{\"1\":{\"24\":1}}],[\"使网络能够应对实际中各种密度变换的情况\",{\"1\":{\"17\":1}}],[\"使网络能学习不同采样密度下局部点云特征的提取\",{\"1\":{\"17\":1}}],[\"使得\",{\"1\":{\"99\":1}}],[\"使得预训练模型能够直接应用于下游任务\",{\"1\":{\"83\":1}}],[\"使得采样点在整个点云空间中分布尽可能均匀\",{\"1\":{\"13\":1}}],[\"使得在它们之间可以共享学习到的特征表示的权重\",{\"1\":{\"7\":1}}],[\"使局部特征的表示不够精确\",{\"1\":{\"11\":1}}],[\"使用transformer架构为未来的多模态统一提供了可能性\",{\"1\":{\"108\":1}}],[\"使用截断正态分布初始化位置嵌入\",{\"1\":{\"100\":1,\"103\":1}}],[\"使用截断正态分布初始化分类标记\",{\"1\":{\"99\":1,\"100\":1,\"103\":1}}],[\"使用adamw优化器\",{\"1\":{\"81\":1}}],[\"使用掩码机制确保模型在生成目标序列时只能看到当前及之前的词\",{\"1\":{\"66\":1}}],[\"使用了如下逻辑\",{\"1\":{\"58\":1}}],[\"使用pycharm导入项目\",{\"1\":{\"37\":1}}],[\"使用的是tnews数据集\",{\"1\":{\"37\":1}}],[\"使用神经网络直接学习对称函数\",{\"1\":{\"32\":1}}],[\"使用分块策略\",{\"1\":{\"29\":1}}],[\"使用多层\",{\"1\":{\"28\":1}}],[\"使用多个不同大小的邻域球\",{\"1\":{\"17\":1}}],[\"使用多个\",{\"1\":{\"13\":1}}],[\"使用对称函数\",{\"1\":{\"22\":1}}],[\"使用最大池化聚合局部信息\",{\"1\":{\"17\":1}}],[\"使用\",{\"1\":{\"13\":2,\"17\":1,\"22\":1,\"24\":1,\"26\":2,\"28\":1,\"29\":2,\"60\":1,\"91\":1}}],[\"使用farthest\",{\"1\":{\"10\":1}}],[\"使用mini\",{\"1\":{\"9\":1}}],[\"邻近点\",{\"1\":{\"9\":1}}],[\"从预测结果中找出每个样本预测概率最大的类别索引\",{\"1\":{\"103\":1}}],[\"从qkv张量中分离出查询\",{\"1\":{\"102\":1}}],[\"从图像的中心位置裁剪出\",{\"1\":{\"97\":1}}],[\"从数据集\",{\"1\":{\"96\":1}}],[\"从数据对的数量来看\",{\"1\":{\"81\":1}}],[\"从冻结的llm引到vision\",{\"1\":{\"90\":1}}],[\"从冻结的image\",{\"1\":{\"90\":1}}],[\"从任务难度来看\",{\"1\":{\"87\":1}}],[\"从候选分类文本集合中取出其分类名词\",{\"1\":{\"84\":1}}],[\"从多个角度渲染点云或\",{\"1\":{\"31\":1}}],[\"从所有点中选出每个通道的最大响应值\",{\"1\":{\"24\":1,\"26\":1}}],[\"从而提高模型的分类性能\",{\"1\":{\"103\":1}}],[\"从而增强了模型的表达能力\",{\"1\":{\"101\":1}}],[\"从而增强模型的表达能力\",{\"1\":{\"66\":1}}],[\"从而完成图像分类任务\",{\"1\":{\"99\":1}}],[\"从而导致更大的训练代价\",{\"1\":{\"89\":1}}],[\"从而可以解决长距离依赖的问题\",{\"1\":{\"65\":1}}],[\"从而很难并行\",{\"1\":{\"65\":1}}],[\"从而能够更好地捕捉点云的局部结构和层次信息\",{\"1\":{\"29\":1}}],[\"从而保证变换是刚性的\",{\"1\":{\"24\":1}}],[\"从而训练网络在面对实际应用中可能遇到的各种采样密度时\",{\"1\":{\"17\":1}}],[\"从而学会根据输入数据的变化自适应地加权不同尺度上检测到的模式\",{\"1\":{\"16\":1}}],[\"从而实现点云的分层特征学习\",{\"1\":{\"13\":1}}],[\"从点云中根据索引提取特定点\",{\"1\":{\"13\":1}}],[\"从\",{\"1\":{\"13\":1,\"24\":1,\"60\":1,\"91\":2}}],[\"从输入点云\",{\"1\":{\"13\":1}}],[\"从输入点中选取一组点\",{\"1\":{\"9\":1}}],[\"从原始点云中选出\",{\"1\":{\"13\":1}}],[\"从本质上来说\",{\"1\":{\"7\":1}}],[\"和值\",{\"1\":{\"102\":2}}],[\"和transformer中的一样\",{\"1\":{\"101\":1}}],[\"和text都能和所有的tokens\",{\"1\":{\"93\":1}}],[\"和基于图像掩码的方法\",{\"1\":{\"87\":1}}],[\"和图像编码器\",{\"1\":{\"81\":1}}],[\"和稀疏采样的区域\",{\"1\":{\"16\":1}}],[\"和多分辨率分组\",{\"1\":{\"15\":1}}],[\"和每个查询点上\",{\"1\":{\"13\":1}}],[\"和\",{\"1\":{\"9\":1,\"24\":1,\"25\":1,\"56\":1,\"58\":2,\"59\":2,\"60\":1,\"71\":1,\"79\":3,\"89\":3,\"92\":3,\"93\":1,\"98\":1,\"106\":2}}],[\"由此可见vit工作的局限性\",{\"1\":{\"104\":1}}],[\"由此把图片转换为序列的embedding形式\",{\"1\":{\"98\":1}}],[\"由两个transformer模块组成\",{\"1\":{\"91\":1}}],[\"由三角形面片组成的\",{\"1\":{\"31\":1}}],[\"由于作者是首次将transformer应用到图像领域\",{\"1\":{\"105\":1}}],[\"由于训练数据量和模型计算量较大\",{\"1\":{\"87\":1}}],[\"由于它们在预训练数据集上采用固定类别数的分类器\",{\"1\":{\"87\":1}}],[\"由于这些文本往往只是一个单词\",{\"1\":{\"83\":1}}],[\"由于数据量巨大\",{\"1\":{\"81\":1}}],[\"由于\",{\"1\":{\"66\":1}}],[\"由于表情不同\",{\"1\":{\"29\":1}}],[\"由于子区域在计算第一个向量时包含的点更稀疏\",{\"1\":{\"18\":1}}],[\"由于点集在不同区域可能会有不同的采样密度\",{\"1\":{\"15\":1}}],[\"由\",{\"1\":{\"9\":1}}],[\"s=str\",{\"1\":{\"96\":1}}],[\"smoothing=0\",{\"1\":{\"92\":2}}],[\"snapshot\",{\"1\":{\"84\":1,\"86\":2}}],[\"shuffle=false\",{\"1\":{\"97\":1}}],[\"shuffle=true\",{\"1\":{\"97\":1}}],[\"show\",{\"1\":{\"85\":1,\"86\":1,\"96\":1}}],[\"shot图文生成\",{\"1\":{\"90\":1}}],[\"shot图像分类\",{\"1\":{\"82\":1}}],[\"shot\",{\"1\":{\"89\":1}}],[\"shot性能评估\",{\"1\":{\"87\":1}}],[\"shot性能\",{\"1\":{\"87\":1}}],[\"shot迁移到下游任务\",{\"1\":{\"87\":1}}],[\"shot学习\",{\"1\":{\"87\":1}}],[\"shot推理\",{\"1\":{\"84\":1}}],[\"shot分类时\",{\"1\":{\"83\":1}}],[\"shot分类的过程相当直接\",{\"1\":{\"82\":1}}],[\"shape为\",{\"1\":{\"98\":1}}],[\"shape的形状从\",{\"1\":{\"13\":1}}],[\"shape\",{\"1\":{\"13\":15,\"14\":1,\"17\":2,\"24\":3,\"26\":3,\"28\":4,\"49\":4,\"62\":1,\"91\":1,\"93\":6,\"98\":1,\"99\":1,\"100\":1,\"102\":1,\"103\":2}}],[\"src\",{\"1\":{\"67\":16,\"74\":7,\"75\":2}}],[\"srl\",{\"1\":{\"61\":1}}],[\"skip\",{\"1\":{\"60\":2}}],[\"score\",{\"1\":{\"55\":2,\"56\":4,\"92\":2,\"93\":3}}],[\"scores\",{\"1\":{\"49\":12,\"55\":2,\"56\":4,\"58\":4,\"61\":1,\"76\":4,\"93\":14}}],[\"scale未指定\",{\"1\":{\"102\":1}}],[\"scale=qk\",{\"1\":{\"101\":1,\"103\":1}}],[\"scale=none\",{\"1\":{\"100\":1,\"101\":1,\"102\":1,\"103\":1}}],[\"scaled\",{\"1\":{\"76\":1}}],[\"scale\",{\"0\":{\"16\":1},\"1\":{\"14\":1,\"15\":1,\"17\":1,\"101\":1,\"102\":3,\"103\":1}}],[\"symlinks=false\",{\"1\":{\"84\":1,\"86\":1}}],[\"symmetric\",{\"1\":{\"22\":1,\"32\":1}}],[\"systematic\",{\"1\":{\"83\":1}}],[\"sys\",{\"1\":{\"43\":1,\"53\":1}}],[\"silhouette\",{\"1\":{\"82\":1}}],[\"sim\",{\"1\":{\"92\":13,\"93\":4}}],[\"similarities\",{\"1\":{\"84\":2,\"85\":2,\"86\":4}}],[\"similarity\",{\"1\":{\"81\":1,\"82\":1,\"84\":2,\"85\":1,\"86\":3,\"92\":4}}],[\"simply\",{\"1\":{\"45\":1}}],[\"size的四倍\",{\"1\":{\"104\":1}}],[\"size是transformer\",{\"1\":{\"104\":1}}],[\"size就是对应通过embedding层后每个token的dim\",{\"1\":{\"104\":1}}],[\"size也是同样处理手段\",{\"1\":{\"91\":1}}],[\"size=768\",{\"1\":{\"107\":1}}],[\"size=none\",{\"1\":{\"100\":1,\"103\":1}}],[\"size=img\",{\"1\":{\"99\":1,\"100\":1,\"103\":1}}],[\"size=patch\",{\"1\":{\"98\":1,\"99\":1,\"100\":1,\"103\":1}}],[\"size=224\",{\"1\":{\"98\":1,\"99\":1,\"100\":1,\"103\":1,\"107\":1}}],[\"size=batch\",{\"1\":{\"97\":2}}],[\"size=64\",{\"1\":{\"84\":2,\"86\":2}}],[\"size=args\",{\"1\":{\"40\":1}}],[\"size=16\",{\"1\":{\"37\":2,\"98\":1,\"99\":1,\"100\":1,\"103\":1,\"107\":1}}],[\"size=1\",{\"1\":{\"24\":1}}],[\"size\",{\"1\":{\"24\":3,\"25\":2,\"26\":1,\"28\":2,\"40\":1,\"41\":7,\"43\":5,\"45\":2,\"47\":1,\"49\":15,\"50\":3,\"53\":3,\"54\":3,\"55\":1,\"56\":1,\"58\":12,\"59\":3,\"61\":2,\"62\":13,\"70\":2,\"71\":4,\"72\":1,\"74\":4,\"75\":1,\"76\":3,\"84\":4,\"86\":4,\"91\":6,\"92\":8,\"93\":18,\"96\":1,\"97\":2,\"98\":24,\"99\":4,\"100\":2,\"102\":10,\"103\":4}}],[\"single\",{\"1\":{\"14\":1}}],[\"span\",{\"1\":{\"58\":1,\"60\":2}}],[\"spatial\",{\"1\":{\"24\":1}}],[\"splitext\",{\"1\":{\"84\":1,\"86\":1,\"96\":1}}],[\"split\",{\"1\":{\"58\":2,\"59\":1,\"84\":1,\"86\":1,\"96\":1,\"97\":1}}],[\"special\",{\"1\":{\"38\":6,\"60\":2}}],[\"spidercnn\",{\"1\":{\"29\":2}}],[\"spring\",{\"1\":{\"2\":1}}],[\"std=0\",{\"1\":{\"99\":1,\"100\":2,\"103\":2}}],[\"staticmethod\",{\"1\":{\"96\":2}}],[\"state\",{\"1\":{\"45\":1,\"91\":2,\"93\":1,\"107\":1}}],[\"states=none\",{\"1\":{\"93\":3}}],[\"states=image\",{\"1\":{\"91\":1,\"93\":1}}],[\"states\",{\"1\":{\"43\":16,\"44\":4,\"45\":2,\"47\":2,\"49\":4,\"50\":8,\"53\":8,\"54\":6,\"56\":1,\"62\":1,\"93\":18}}],[\"stage流程\",{\"1\":{\"90\":1}}],[\"stage\",{\"0\":{\"91\":1},\"1\":{\"90\":3,\"91\":1}}],[\"standing\",{\"1\":{\"82\":2}}],[\"start\",{\"1\":{\"58\":12,\"59\":15,\"60\":5,\"84\":5,\"86\":5}}],[\"stack\",{\"1\":{\"40\":1,\"72\":1,\"82\":1,\"93\":3,\"96\":1}}],[\"strict=false\",{\"1\":{\"107\":1}}],[\"stride=patch\",{\"1\":{\"98\":1}}],[\"stride\",{\"1\":{\"98\":1}}],[\"str\",{\"1\":{\"43\":1,\"53\":1,\"96\":3}}],[\"structure\",{\"1\":{\"17\":1,\"94\":1}}],[\"steps=100\",{\"1\":{\"37\":2}}],[\"step\",{\"1\":{\"37\":4,\"103\":1}}],[\"storage\",{\"1\":{\"37\":1}}],[\"stn\",{\"1\":{\"26\":3}}],[\"stnkd\",{\"1\":{\"22\":1,\"25\":1,\"26\":1}}],[\"stn3d\",{\"1\":{\"22\":1,\"24\":5,\"25\":1,\"26\":2}}],[\"source\",{\"1\":{\"107\":1}}],[\"southampton\",{\"1\":{\"37\":1}}],[\"sometimes\",{\"1\":{\"59\":1}}],[\"sota\",{\"1\":{\"29\":1}}],[\"softmax归一化得到注意力概率\",{\"1\":{\"93\":1}}],[\"softmax\",{\"1\":{\"14\":1,\"17\":1,\"27\":2,\"28\":2,\"32\":2,\"49\":1,\"58\":3,\"66\":1,\"68\":1,\"76\":1,\"82\":1,\"93\":3,\"102\":1}}],[\"sort\",{\"1\":{\"13\":1,\"96\":1}}],[\"salesforce\",{\"1\":{\"88\":1}}],[\"saucer\",{\"1\":{\"82\":1}}],[\"same\",{\"1\":{\"54\":1,\"76\":1}}],[\"sampling\",{\"0\":{\"10\":1},\"1\":{\"9\":2,\"10\":1,\"13\":1}}],[\"sampler=train\",{\"1\":{\"40\":1}}],[\"sampler\",{\"1\":{\"40\":2}}],[\"sampled\",{\"1\":{\"13\":6,\"17\":1}}],[\"samples\",{\"1\":{\"13\":1,\"91\":3}}],[\"sample\",{\"1\":{\"8\":1,\"13\":14,\"17\":2,\"96\":1,\"103\":1}}],[\"save\",{\"1\":{\"37\":1,\"84\":3,\"86\":3}}],[\"sa3\",{\"1\":{\"14\":2,\"17\":2}}],[\"sa2\",{\"1\":{\"14\":2,\"17\":2}}],[\"sa1\",{\"1\":{\"14\":2,\"17\":2}}],[\"sa\",{\"1\":{\"14\":1}}],[\"ssg\",{\"1\":{\"14\":3}}],[\"supported\",{\"1\":{\"96\":2}}],[\"supervised\",{\"1\":{\"87\":1}}],[\"super\",{\"1\":{\"13\":1,\"14\":1,\"17\":2,\"24\":1,\"26\":1,\"27\":1,\"28\":1,\"41\":1,\"43\":3,\"44\":1,\"45\":1,\"46\":1,\"47\":1,\"49\":1,\"50\":1,\"51\":1,\"53\":1,\"54\":1,\"55\":1,\"56\":1,\"59\":1,\"61\":1,\"62\":1,\"67\":1,\"68\":1,\"70\":1,\"71\":1,\"72\":1,\"74\":1,\"75\":1,\"76\":1,\"93\":2,\"98\":1,\"99\":1,\"100\":1,\"101\":2,\"102\":1,\"103\":1}}],[\"sunflowers\",{\"1\":{\"85\":1,\"86\":1}}],[\"sub\",{\"1\":{\"84\":5,\"86\":5}}],[\"sublayer是传入的参数\",{\"1\":{\"70\":1}}],[\"sublayer\",{\"1\":{\"70\":3,\"71\":3,\"74\":4}}],[\"sublayerconnection模型结构图\",{\"1\":{\"70\":1}}],[\"sublayerconnection\",{\"0\":{\"70\":1},\"1\":{\"70\":2,\"71\":1,\"74\":1}}],[\"successfully\",{\"1\":{\"84\":1,\"86\":1}}],[\"survey\",{\"1\":{\"83\":1}}],[\"summation\",{\"1\":{\"32\":1}}],[\"sum\",{\"1\":{\"13\":1,\"32\":1,\"96\":1,\"103\":1}}],[\"seed\",{\"1\":{\"96\":1}}],[\"seem\",{\"1\":{\"49\":1}}],[\"searchpicbytext\",{\"1\":{\"85\":1,\"86\":1}}],[\"segmentation\",{\"1\":{\"41\":1,\"82\":1}}],[\"segment\",{\"1\":{\"38\":1}}],[\"seconds\",{\"1\":{\"84\":2,\"86\":1}}],[\"second\",{\"1\":{\"38\":1}}],[\"sep\",{\"1\":{\"38\":11,\"58\":2,\"60\":2,\"62\":2}}],[\"sentence\",{\"1\":{\"38\":1,\"56\":5}}],[\"sequential\",{\"1\":{\"103\":2}}],[\"sequence\",{\"1\":{\"38\":4,\"46\":3,\"55\":2,\"56\":2,\"58\":3,\"59\":2,\"61\":4}}],[\"sequences\",{\"1\":{\"38\":2,\"67\":1}}],[\"seq\",{\"1\":{\"37\":1,\"41\":2,\"49\":2,\"55\":4,\"56\":4,\"58\":4,\"59\":4,\"61\":2,\"62\":4,\"76\":1,\"91\":6,\"92\":5,\"93\":20}}],[\"self\",{\"1\":{\"13\":17,\"14\":25,\"17\":41,\"24\":26,\"26\":24,\"27\":19,\"28\":24,\"38\":9,\"41\":13,\"43\":26,\"44\":5,\"45\":7,\"46\":11,\"47\":14,\"49\":28,\"50\":9,\"51\":11,\"53\":10,\"54\":9,\"55\":7,\"56\":8,\"58\":3,\"59\":8,\"61\":12,\"62\":9,\"66\":2,\"67\":16,\"68\":5,\"70\":8,\"71\":15,\"72\":7,\"74\":19,\"75\":7,\"76\":15,\"91\":9,\"92\":4,\"93\":80,\"96\":12,\"98\":12,\"99\":16,\"100\":22,\"101\":25,\"102\":16,\"103\":33}}],[\"sets\",{\"1\":{\"32\":1}}],[\"set\",{\"1\":{\"9\":1,\"14\":1,\"18\":1,\"22\":1,\"29\":2,\"32\":1}}],[\"squad\",{\"1\":{\"60\":1}}],[\"square\",{\"1\":{\"13\":1}}],[\"squeeze\",{\"1\":{\"58\":2,\"59\":2,\"92\":2}}],[\"sqrt\",{\"1\":{\"49\":1,\"76\":1,\"93\":1}}],[\"sqrdists\",{\"1\":{\"13\":2}}],[\"s\",{\"1\":{\"13\":16,\"17\":8,\"22\":1,\"38\":1,\"96\":1,\"107\":1}}],[\"它是\",{\"1\":{\"104\":1}}],[\"它是无序点云数据特征提取的高效算法\",{\"1\":{\"7\":1}}],[\"它必须要在超大数据集上进行预训练\",{\"1\":{\"104\":1}}],[\"它位于最终分类头之前\",{\"1\":{\"103\":1}}],[\"它与类的实例和类本身都没有直接关联\",{\"1\":{\"96\":1}}],[\"它会将多个样本收集起来形成一个批次\",{\"1\":{\"96\":1}}],[\"它首次将nlp领域火热的transformer模型架构移植到了cv领域\",{\"1\":{\"94\":1}}],[\"它将输入的向量转换为\",{\"1\":{\"84\":1}}],[\"它通过处理器对输入文本进行处理\",{\"1\":{\"84\":1}}],[\"它通过位置编码将序列中词的位置信息注入到输入中\",{\"1\":{\"66\":1}}],[\"它由两个部分组成\",{\"1\":{\"82\":1}}],[\"它由大量带有位置信息的点组成\",{\"1\":{\"31\":1}}],[\"它比谷歌的jft\",{\"1\":{\"81\":1}}],[\"它代表着一种基于对比文本\",{\"1\":{\"80\":1}}],[\"它可以当成函数调用\",{\"1\":{\"70\":1}}],[\"它允许模型在处理每个词时关注输入序列中的所有词\",{\"1\":{\"66\":1}}],[\"它在编码每一词的时候都能够注意\",{\"1\":{\"65\":1}}],[\"它较难学习到长距离的依赖关系\",{\"1\":{\"65\":1}}],[\"它不具有生成能力\",{\"1\":{\"60\":1}}],[\"它不会\",{\"1\":{\"60\":1}}],[\"它引入了局部区域搜索\",{\"1\":{\"29\":1}}],[\"它使用\",{\"1\":{\"27\":2}}],[\"它基于前面的特征提取模块\",{\"1\":{\"27\":1,\"28\":1}}],[\"它负责从输入点云中提取出可用于分类或分割的特征\",{\"1\":{\"26\":1}}],[\"它具有以下特点\",{\"1\":{\"24\":1}}],[\"它包含了这个区域内所有点的信息\",{\"1\":{\"13\":1}}],[\"它的作用是给定一个完整的句子\",{\"1\":{\"60\":1}}],[\"它的作用是负责从输入的点云数据中采样关键点\",{\"1\":{\"13\":1}}],[\"它的语法是\",{\"1\":{\"59\":1}}],[\"它的目标是\",{\"1\":{\"24\":1}}],[\"它的核心思想是\",{\"1\":{\"13\":1}}],[\"它能够从每个子集中提取有用的信息或特征\",{\"1\":{\"7\":1}}],[\"需要再将第一个添加的class\",{\"1\":{\"103\":1}}],[\"需要单独将这个token再提取出来\",{\"1\":{\"99\":1}}],[\"需要相对少的数据就可以学习一个比较好的模型\",{\"1\":{\"94\":1}}],[\"需要数百个gpu训练数十天\",{\"1\":{\"89\":1}}],[\"需要大量的数据标注\",{\"1\":{\"87\":1}}],[\"需要将输入图像调整为这个固定的尺寸\",{\"1\":{\"107\":1}}],[\"需要将\",{\"1\":{\"64\":1}}],[\"需要注意的一点是\",{\"1\":{\"37\":1}}],[\"需要捕捉局部结构\",{\"1\":{\"21\":1}}],[\"需要确保这些划分具有一定的一致性或共同结构\",{\"1\":{\"7\":1}}],[\"需要对哪个物体做归一化呢\",{\"1\":{\"7\":1}}],[\"一种思路是在转换之前\",{\"1\":{\"100\":1}}],[\"一种朴素的想法就是把一个个像素点拉平\",{\"1\":{\"98\":1}}],[\"一种是平移不变形\",{\"1\":{\"94\":1}}],[\"一种是局部性\",{\"1\":{\"94\":1}}],[\"一种是常用的cnn架构resnet\",{\"1\":{\"81\":1}}],[\"一种比较好理解的方式\",{\"1\":{\"91\":1}}],[\"一般\",{\"1\":{\"89\":2}}],[\"一句话总结\",{\"1\":{\"29\":1}}],[\"一\",{\"1\":{\"29\":1}}],[\"一组新的关键点位置\",{\"1\":{\"17\":1}}],[\"一组点云被处理和抽象\",{\"1\":{\"9\":1}}],[\"一个block之后维度依然和输入相同\",{\"1\":{\"101\":1}}],[\"一个改进的想法就是把一张图片分成nxn个patch\",{\"1\":{\"98\":1}}],[\"一个批次的数据\",{\"1\":{\"96\":1}}],[\"一个文件夹对应一个类别\",{\"1\":{\"96\":1}}],[\"一个的轻量q\",{\"1\":{\"89\":1}}],[\"一个视觉模型和一个文本模型\",{\"1\":{\"82\":1}}],[\"一个是该\",{\"1\":{\"58\":1}}],[\"一个非法索引\",{\"1\":{\"13\":1}}],[\"一个元组\",{\"1\":{\"13\":1,\"24\":1,\"26\":1}}],[\"一起送入mini\",{\"1\":{\"12\":1}}],[\"一旦点云被划分成小的子集\",{\"1\":{\"7\":1}}],[\"一名普通但十分热爱探索技术的coder\",{\"1\":{\"2\":1}}],[\"这有助于模型发现输入数据中更复杂的模式和关系\",{\"1\":{\"101\":1}}],[\"这也是为什么结构图中mlp\",{\"1\":{\"99\":1}}],[\"这时就可以自定义\",{\"1\":{\"96\":1}}],[\"这几乎是不可能完成的任务\",{\"1\":{\"94\":1}}],[\"这大大限制了它们的迁移能力和扩展性\",{\"1\":{\"87\":1}}],[\"这远远低于imagenet上的sota\",{\"1\":{\"87\":1}}],[\"这方面的工作并不多\",{\"1\":{\"87\":1}}],[\"这与传统的预训练加微调的方法有所不同\",{\"1\":{\"83\":1}}],[\"这与在传统cnn中学习图像局部区域特征的过程相似\",{\"1\":{\"7\":1}}],[\"这展示了其在图像分类任务中的灵活性和强大能力\",{\"1\":{\"82\":1}}],[\"这不仅展示了clip的强大功能\",{\"1\":{\"82\":1}}],[\"这表明训练clip模型需要消耗大量的资源\",{\"1\":{\"81\":1}}],[\"这和原始论文稍有不同\",{\"1\":{\"70\":1}}],[\"这比较容易并行\",{\"1\":{\"65\":1}}],[\"这其实就是在说\",{\"1\":{\"60\":1}}],[\"这段代码的意思是\",{\"1\":{\"60\":1}}],[\"这类抽取式问答任务中\",{\"1\":{\"60\":1}}],[\"这里不再贴出\",{\"1\":{\"107\":1}}],[\"这里需要将其分离开来\",{\"1\":{\"102\":1}}],[\"这里主要有两种位置编码思路\",{\"1\":{\"100\":1}}],[\"这里简单介绍一下cls\",{\"1\":{\"99\":1}}],[\"这里设置为图像块的大小\",{\"1\":{\"98\":2}}],[\"这里对训练集的处理方式是随机切成224x224像素的图片\",{\"1\":{\"97\":1}}],[\"这里对提取的文本特征和图像特征进行对比学习\",{\"1\":{\"81\":1}}],[\"这里以搜索向日葵花为例\",{\"1\":{\"85\":1}}],[\"这里采用了余弦相似度的计算方法\",{\"1\":{\"84\":1}}],[\"这里共有个正样本\",{\"1\":{\"81\":1}}],[\"这里的原因\",{\"1\":{\"101\":1}}],[\"这里的\",{\"1\":{\"98\":1}}],[\"这里的相似度直接计算文本特征和图像特征的余弦相似性\",{\"1\":{\"81\":1}}],[\"这里的三个\",{\"1\":{\"14\":1}}],[\"这里我准备做一个文本分类任务\",{\"1\":{\"37\":1}}],[\"这就要求网络中的某些关键操作必须是对称函数\",{\"1\":{\"32\":1}}],[\"这就是blip\",{\"1\":{\"89\":1}}],[\"这就是答案\",{\"1\":{\"60\":1}}],[\"这就是\",{\"1\":{\"25\":1}}],[\"这就是下一个\",{\"1\":{\"13\":2}}],[\"这使得它在细粒度识别\",{\"1\":{\"29\":1}}],[\"这意味着它能够在没有任何特定任务训练数据的情况下\",{\"1\":{\"82\":1}}],[\"这意味着\",{\"1\":{\"29\":1}}],[\"这意味着即使是不同的局部子集\",{\"1\":{\"7\":1}}],[\"这两个模型都属于融合图像与文本的多模态模型\",{\"1\":{\"79\":1}}],[\"这两个网络输出的是变换矩阵\",{\"1\":{\"25\":1}}],[\"这两种特征被concat为一个复合特征向量\",{\"1\":{\"18\":1}}],[\"这一步的操作在论文中是直接采用切割的处理办法\",{\"1\":{\"98\":1}}],[\"这一步是为了保证图像的整体比例不变\",{\"1\":{\"97\":1}}],[\"这一步不在\",{\"1\":{\"24\":1}}],[\"这一过程与训练时相同\",{\"1\":{\"82\":1}}],[\"这一过程通过对每个子区域应用集合抽象层\",{\"1\":{\"18\":1}}],[\"这种差异一方面是由于文本和图像属于两个完全不同的模态\",{\"1\":{\"87\":1}}],[\"这种预训练通常是基于有监督学习的\",{\"1\":{\"87\":1}}],[\"这种格式\",{\"1\":{\"83\":1}}],[\"这种设计使得网络只关注\",{\"1\":{\"29\":1}}],[\"这种方法实际上与nlp领域的一个研究方向\",{\"1\":{\"83\":1}}],[\"这种方法大大增强了网络处理非均匀采样数据的能力\",{\"1\":{\"17\":1}}],[\"这种方法使得网络能够在细节丰富的区域\",{\"1\":{\"16\":1}}],[\"这种方法使网络能够通过在训练期间随机丢弃输入点\",{\"1\":{\"16\":1}}],[\"这种非均匀性为点集特征学习带来了显著挑战\",{\"1\":{\"15\":1}}],[\"这些值会根据模型的损失函数不断调整\",{\"1\":{\"100\":1}}],[\"这些相似度值可以被视为logits\",{\"1\":{\"82\":1}}],[\"这些图像特征会与之前得到的个文本特征进行余弦相似度计算\",{\"1\":{\"82\":1}}],[\"这些文本随后被输入到文本编码器\",{\"1\":{\"82\":1}}],[\"这些数据在论文中被称为webimagetext\",{\"1\":{\"81\":1}}],[\"这些模型都是以cnn为基础\",{\"1\":{\"65\":1}}],[\"这些点大致构成物体的骨架\",{\"1\":{\"29\":1}}],[\"这些点彼此之间的最小距离尽可能大\",{\"1\":{\"10\":1}}],[\"这些方法会导致信息损失\",{\"1\":{\"20\":1}}],[\"这些人离我太远了\",{\"1\":{\"13\":1}}],[\"这是一种数据增强的方式\",{\"1\":{\"97\":1}}],[\"这是一个椅子\",{\"1\":{\"28\":1}}],[\"这是抽取式问答模型的局限性\",{\"1\":{\"60\":1}}],[\"这是因为在实际采集过程中\",{\"1\":{\"24\":1}}],[\"这是\",{\"1\":{\"13\":1}}],[\"这个维度上添加一维\",{\"1\":{\"100\":1}}],[\"这个就是额外添加的一个\",{\"1\":{\"99\":1}}],[\"这个token\",{\"1\":{\"99\":1}}],[\"这个\",{\"1\":{\"84\":1}}],[\"这个数据集来源是这里\",{\"1\":{\"37\":1}}],[\"这个变换矩阵是近似正交的\",{\"1\":{\"24\":1}}],[\"这个矩阵表示对点云所做的变换\",{\"1\":{\"24\":1}}],[\"这个模型使用了\",{\"1\":{\"17\":1}}],[\"这个模块实现了\",{\"1\":{\"17\":1}}],[\"这个特征向量代表了这个局部区域的高维特征\",{\"1\":{\"13\":1}}],[\"这个操作被称为\",{\"1\":{\"13\":1}}],[\"这个函数的作用是将输入的文本转化为对应的嵌入表示\",{\"1\":{\"84\":1}}],[\"这个函数的作用是从点云中找出每个查询点周围一定半径范围内的邻近点索引\",{\"1\":{\"13\":1}}],[\"这个函数的作用是从输入点云中\",{\"1\":{\"13\":1}}],[\"这个函数的有一个输入参数\",{\"1\":{\"70\":1}}],[\"这个函数实现的是根据给定的索引\",{\"1\":{\"13\":1}}],[\"这个函数实现的是最远点采样\",{\"1\":{\"13\":1}}],[\"这个过程类似于在传统的卷积神经网络中如何处理图像的小区域\",{\"1\":{\"7\":1}}],[\"这在处理非均匀采样的数据时可能不是最优的选择\",{\"1\":{\"11\":1}}],[\"这样计算量就大大减小了\",{\"1\":{\"98\":1}}],[\"这样就可以完成vit的训练过程\",{\"1\":{\"103\":1}}],[\"这样就可以提取出对最终任务有帮助的特征组合\",{\"1\":{\"101\":1}}],[\"这样就成了一个一维序列\",{\"1\":{\"98\":1}}],[\"这样就能让\",{\"1\":{\"62\":1,\"101\":1}}],[\"这样可以为\",{\"1\":{\"106\":1}}],[\"这样可以在模型的不同阶段交替利用\",{\"1\":{\"106\":1}}],[\"这样可以在每个部分上独立地学习特征\",{\"1\":{\"7\":1}}],[\"这样可以提升计算效率\",{\"1\":{\"102\":1}}],[\"这样可以保证模型的特征提取能力和性能\",{\"1\":{\"97\":1}}],[\"这样的格式来生成文本描述\",{\"1\":{\"83\":1}}],[\"这样的\",{\"1\":{\"60\":1}}],[\"这样模型就能根据上下文更准确地做出判断\",{\"1\":{\"28\":1}}],[\"这样每个点在预测标签时都能看到整个物体的上下文\",{\"1\":{\"22\":1}}],[\"这样\",{\"1\":{\"16\":2,\"24\":1,\"98\":1}}],[\"这样做的目的是提高模型的效率和泛化能力\",{\"1\":{\"7\":1}}],[\"这需要一个\",{\"1\":{\"7\":1}}],[\"以使得模型能够学习到最适合当前任务的位置表示\",{\"1\":{\"100\":1}}],[\"以最小化损失\",{\"1\":{\"99\":1}}],[\"以最大化互信息\",{\"1\":{\"92\":1}}],[\"以保持与其他模型的一致性\",{\"1\":{\"99\":1,\"100\":1,\"103\":1}}],[\"以保持计算的可管理性\",{\"1\":{\"11\":1}}],[\"以保留图像的空间信息\",{\"1\":{\"99\":1}}],[\"以vit\",{\"1\":{\"98\":1}}],[\"以\",{\"1\":{\"97\":1}}],[\"以避免模型将匹配图文对挑选为负样本\",{\"1\":{\"93\":1}}],[\"以细粒度对齐\",{\"1\":{\"93\":1}}],[\"以下引用clip论文图做说明\",{\"1\":{\"92\":1}}],[\"以下是一个官方给出的clip模型的示例\",{\"1\":{\"82\":1}}],[\"以及seq\",{\"1\":{\"91\":1}}],[\"以及如何通过局部特征学习器\",{\"1\":{\"7\":1}}],[\"以上代码注释中统一用b代替image\",{\"1\":{\"91\":1}}],[\"以弥合模态差距\",{\"1\":{\"90\":1}}],[\"以每个文本描述为一行\",{\"1\":{\"85\":1}}],[\"以获取图像特征\",{\"1\":{\"82\":1}}],[\"以获得更强的局部几何感知能力\",{\"1\":{\"17\":1}}],[\"以生成相应的文本特征\",{\"1\":{\"82\":1}}],[\"以增强性能\",{\"1\":{\"81\":1}}],[\"以加速训练并提高模型的稳定性\",{\"1\":{\"66\":1}}],[\"以便\",{\"1\":{\"91\":1}}],[\"以便一起处理\",{\"1\":{\"62\":1}}],[\"以便可以在这些分区上独立地学习特征\",{\"1\":{\"7\":1}}],[\"以便可以在这些区域上应用局部操作\",{\"1\":{\"7\":1}}],[\"以实现最佳的性能\",{\"1\":{\"17\":1}}],[\"以结合来自不同尺度的特征\",{\"1\":{\"16\":1}}],[\"以反映其相对位置\",{\"1\":{\"12\":1}}],[\"以限制每个局部区域中考虑的点的数量\",{\"1\":{\"11\":1}}],[\"以产生一个更少元素的新集合\",{\"1\":{\"9\":1}}],[\"以二维欧几里得空间为例\",{\"1\":{\"8\":1}}],[\"或者说在于计算能力和数据集的规模\",{\"1\":{\"87\":1}}],[\"或者直接命令行运行\",{\"1\":{\"37\":1}}],[\"或两个句子\",{\"1\":{\"60\":1}}],[\"或图结构增强局部建模能力\",{\"1\":{\"29\":1}}],[\"或图像视图\",{\"1\":{\"20\":1}}],[\"或每组邻域大小\",{\"1\":{\"16\":1}}],[\"或局部区域\",{\"1\":{\"7\":1}}],[\"或\",{\"1\":{\"7\":1}}],[\"对特征进行更深入的建模\",{\"1\":{\"106\":1}}],[\"对特征空间进行变换\",{\"1\":{\"26\":1}}],[\"对特征空间做变换\",{\"1\":{\"22\":1,\"25\":1}}],[\"对投影后的结果应用丢弃层\",{\"1\":{\"102\":1}}],[\"对输出进行维度交换和形状调整\",{\"1\":{\"102\":1}}],[\"对输入数据进行初步的特征提取\",{\"1\":{\"106\":1}}],[\"对输入进行归一化处理\",{\"1\":{\"101\":1}}],[\"对输入的点云做刚性变换\",{\"1\":{\"24\":1}}],[\"对输入点云做刚性变换\",{\"1\":{\"22\":1}}],[\"对输入点进行采样\",{\"1\":{\"8\":1}}],[\"对注意力权重矩阵应用丢弃层\",{\"1\":{\"102\":1}}],[\"对注意力分数矩阵应用softmax函数\",{\"1\":{\"102\":1}}],[\"对经过注意力层的输出进行归一化处理\",{\"1\":{\"101\":1}}],[\"对处理后的张量进行归一化操作\",{\"1\":{\"98\":1}}],[\"对图像进行归一化处理\",{\"1\":{\"97\":2}}],[\"对验证集的处理方式是先resize成256x256的图片\",{\"1\":{\"97\":1}}],[\"对数据集和验证集划分之后\",{\"1\":{\"97\":1}}],[\"对数值变化敏感\",{\"1\":{\"32\":1}}],[\"对角线元素的labels\",{\"1\":{\"81\":1}}],[\"对称的对比学习损失\",{\"1\":{\"81\":1}}],[\"对称函数\",{\"0\":{\"32\":1},\"1\":{\"32\":2}}],[\"对两个特征进行线性投射\",{\"1\":{\"81\":1}}],[\"对每一个选项\",{\"1\":{\"62\":1}}],[\"对每个选项分别进行编码\",{\"1\":{\"62\":1}}],[\"对每个\",{\"1\":{\"60\":1}}],[\"对每个点独立处理\",{\"1\":{\"29\":1}}],[\"对每个点进行特征提取\",{\"1\":{\"26\":1}}],[\"对每个尺度的局部点集应用对应的\",{\"1\":{\"17\":1}}],[\"对每个半径\",{\"1\":{\"17\":1}}],[\"对每个局部区域内所有点的最大响应值进行池化\",{\"1\":{\"13\":1}}],[\"对每个查询点的邻近点按索引排序\",{\"1\":{\"13\":1}}],[\"对话系统中的候选回复选择\",{\"1\":{\"62\":1}}],[\"对比\",{\"1\":{\"60\":1}}],[\"对异常点鲁棒性差\",{\"1\":{\"29\":1}}],[\"对异常点也有一定容忍能力\",{\"1\":{\"22\":1}}],[\"对少量异常点有一定鲁棒性\",{\"1\":{\"29\":1}}],[\"对噪声点敏感\",{\"1\":{\"29\":2}}],[\"对稀疏点云敏感\",{\"1\":{\"29\":1}}],[\"对局部形状变化敏感\",{\"1\":{\"29\":1}}],[\"对原始点云做刚性变换\",{\"1\":{\"25\":1}}],[\"对齐\",{\"1\":{\"24\":1}}],[\"对应维度为\",{\"1\":{\"99\":1}}],[\"对应\",{\"1\":{\"98\":1}}],[\"对应的伪代码实现如下所示\",{\"1\":{\"81\":1}}],[\"对应的id为\",{\"1\":{\"38\":1}}],[\"对应的参数为\",{\"1\":{\"37\":1}}],[\"对应代码如下\",{\"1\":{\"37\":1}}],[\"对应一个\",{\"1\":{\"24\":1}}],[\"对应半径下最多取多少邻近点\",{\"1\":{\"17\":1}}],[\"对几何变换的不变性\",{\"1\":{\"21\":1,\"22\":1}}],[\"对参数选择依赖性高\",{\"1\":{\"11\":1}}],[\"对点云的旋转\",{\"1\":{\"22\":1}}],[\"对点云密度变换较为敏感\",{\"1\":{\"11\":1}}],[\"对点云数据做平移操作后\",{\"1\":{\"7\":1}}],[\"对于二维的图像\",{\"1\":{\"98\":1}}],[\"对于q\",{\"1\":{\"91\":1}}],[\"对于自监督模型\",{\"1\":{\"87\":1}}],[\"对于有监督模型\",{\"1\":{\"87\":1}}],[\"对于vit\",{\"1\":{\"81\":1}}],[\"对于一个包含个文本\",{\"1\":{\"81\":1}}],[\"对于这样的多选问题\",{\"1\":{\"62\":1}}],[\"对于分类任务来说\",{\"1\":{\"47\":1}}],[\"对于字典中不存在的词\",{\"1\":{\"38\":1}}],[\"对于非刚性变形\",{\"1\":{\"29\":1}}],[\"对于每个局部区域\",{\"1\":{\"17\":1}}],[\"对于每个质心点\",{\"1\":{\"16\":1}}],[\"对于每个选中的关键点\",{\"1\":{\"13\":1}}],[\"对于某个形心\",{\"1\":{\"11\":1}}],[\"对于单个的物体还好\",{\"1\":{\"7\":1}}],[\"对上述得到的每个区域进行编码\",{\"1\":{\"8\":1}}],[\"世界坐标系和局部坐标系\",{\"1\":{\"7\":1}}],[\"在如此大规模的数据集上进行预训练\",{\"1\":{\"107\":1}}],[\"在预训练和使用该模型时\",{\"1\":{\"107\":1}}],[\"在预训练时\",{\"1\":{\"97\":1}}],[\"在模型架构中\",{\"1\":{\"106\":1}}],[\"在模型初始化时\",{\"1\":{\"100\":1}}],[\"在论文的最后\",{\"1\":{\"106\":1}}],[\"在论文中\",{\"1\":{\"81\":1,\"103\":1,\"104\":1}}],[\"在论文中提到\",{\"1\":{\"29\":1}}],[\"在深度学习领域\",{\"1\":{\"104\":1}}],[\"在两个线性层之间通常会插入一个非线性激活函数\",{\"1\":{\"101\":1}}],[\"在transformer\",{\"1\":{\"103\":1}}],[\"在transformer中\",{\"1\":{\"100\":1}}],[\"在transformer模型中\",{\"1\":{\"94\":1}}],[\"在每一层\",{\"1\":{\"99\":1}}],[\"在每个层上\",{\"1\":{\"9\":1}}],[\"在上面的结构图中可以看到\",{\"1\":{\"99\":1}}],[\"在上下文中找到最可能的答案起始位置和结束位置\",{\"1\":{\"60\":1}}],[\"在代码中\",{\"1\":{\"98\":1}}],[\"在柱状图上添加数值标签\",{\"1\":{\"96\":1}}],[\"在图像分类任务中\",{\"1\":{\"94\":1,\"106\":1}}],[\"在图文检索中\",{\"1\":{\"84\":1}}],[\"在seq\",{\"1\":{\"93\":1}}],[\"在nlp领域\",{\"1\":{\"87\":1}}],[\"在迁移到其他数据集时也需要加上新的分类器进行有监督训练\",{\"1\":{\"87\":1}}],[\"在迁移到下游任务时\",{\"1\":{\"87\":1}}],[\"在计算机视觉领域\",{\"1\":{\"87\":1}}],[\"在imagenet数据集上可以提升1\",{\"1\":{\"83\":1}}],[\"在之前的例子中\",{\"1\":{\"83\":1}}],[\"在实际应用中可以选用常见的卷积神经网络\",{\"1\":{\"81\":1}}],[\"在实现时可采用自然语言处理\",{\"1\":{\"81\":1}}],[\"在实现时\",{\"1\":{\"11\":1}}],[\"在训练过程中\",{\"1\":{\"80\":1}}],[\"在训练时引入随机丢弃形心来模拟不同密度情况\",{\"1\":{\"17\":1}}],[\"在训练时引入不同密度的点集情况\",{\"1\":{\"17\":1}}],[\"在输入序列长度不一致时\",{\"1\":{\"66\":1}}],[\"在解码器中\",{\"1\":{\"66\":1}}],[\"在自注意力机制之后\",{\"1\":{\"66\":1}}],[\"在前向传播中\",{\"1\":{\"62\":1}}],[\"在分类任务中更有用\",{\"1\":{\"58\":1}}],[\"在分割任务中\",{\"1\":{\"22\":1}}],[\"在问答任务中一般不会使用这个输出\",{\"1\":{\"58\":1}}],[\"在问答任务中\",{\"1\":{\"58\":1}}],[\"在使用clip模型进行zero\",{\"1\":{\"83\":1}}],[\"在使用\",{\"1\":{\"58\":1}}],[\"在返回前进行预处理\",{\"1\":{\"40\":1}}],[\"在大规模场景理解任务中表现一般\",{\"1\":{\"29\":1}}],[\"在速度和效率上占优\",{\"1\":{\"29\":1}}],[\"在某些标准数据集\",{\"1\":{\"29\":1}}],[\"在部件分割任务中\",{\"1\":{\"29\":1}}],[\"在通道维度进行拼接\",{\"1\":{\"26\":1}}],[\"在这个高维空间里\",{\"1\":{\"101\":1}}],[\"在这个过程中\",{\"1\":{\"82\":1}}],[\"在这种情况下\",{\"1\":{\"18\":1,\"87\":1}}],[\"在这些点中选出若干个中心点\",{\"1\":{\"8\":1}}],[\"在mrg中\",{\"1\":{\"18\":1}}],[\"在msg中\",{\"1\":{\"16\":1}}],[\"在密集采样的区域中学到的特征可能无法很好地泛化到稀疏采样的区域\",{\"1\":{\"15\":1}}],[\"在\",{\"1\":{\"13\":3,\"24\":1,\"25\":1,\"29\":1,\"58\":2,\"60\":1,\"62\":1,\"79\":1,\"84\":1,\"97\":1,\"106\":2}}],[\"在点云中逐步选择离已选点尽可能远的点\",{\"1\":{\"13\":1}}],[\"在屋里空间或某些特定的抽象空间中\",{\"1\":{\"11\":1}}],[\"在平移不变性上也有局限性\",{\"1\":{\"7\":1}}],[\"在pointnet中\",{\"1\":{\"7\":1}}],[\"背景知识扫盲\",{\"0\":{\"30\":1}}],[\"背景\",{\"0\":{\"7\":1,\"65\":1,\"89\":1}}],[\"pwd=vket\",{\"1\":{\"107\":1}}],[\"pwd=qvmq\",{\"1\":{\"96\":1}}],[\"plot\",{\"1\":{\"96\":2}}],[\"plt\",{\"1\":{\"85\":4,\"86\":5,\"96\":7}}],[\"pil\",{\"1\":{\"86\":1,\"96\":1,\"97\":2}}],[\"pip\",{\"1\":{\"64\":1}}],[\"png\",{\"1\":{\"84\":1,\"86\":1,\"96\":2}}],[\"pth\",{\"1\":{\"107\":1}}],[\"pt\",{\"1\":{\"84\":2,\"86\":2,\"91\":1}}],[\"pts\",{\"1\":{\"26\":2,\"28\":2}}],[\"photos下的子目录名作为我们的候选待匹配分类文本列表\",{\"1\":{\"84\":1}}],[\"photos\",{\"1\":{\"84\":4,\"86\":2}}],[\"photos目录下读取出所有图片的路径\",{\"1\":{\"84\":1}}],[\"photo\",{\"1\":{\"82\":2,\"83\":2,\"84\":2,\"85\":1,\"86\":2}}],[\"p\",{\"1\":{\"76\":5}}],[\"p=drop\",{\"1\":{\"100\":1,\"103\":1}}],[\"p=dropout\",{\"1\":{\"76\":1}}],[\"p=0\",{\"1\":{\"27\":1}}],[\"person\",{\"1\":{\"82\":1}}],[\"per\",{\"1\":{\"37\":2,\"102\":6}}],[\"permutation\",{\"1\":{\"21\":1,\"32\":2}}],[\"permute\",{\"1\":{\"13\":4,\"17\":4,\"49\":2,\"92\":1,\"93\":2,\"102\":2}}],[\"print\",{\"1\":{\"84\":6,\"85\":4,\"86\":10,\"96\":3,\"107\":1}}],[\"prompting\",{\"1\":{\"83\":1}}],[\"prompt\",{\"1\":{\"83\":3}}],[\"projects\",{\"1\":{\"88\":1}}],[\"projected\",{\"1\":{\"76\":1}}],[\"projections\",{\"1\":{\"76\":1}}],[\"projection\",{\"1\":{\"76\":1}}],[\"proj\",{\"1\":{\"68\":2,\"81\":2,\"91\":2,\"98\":2,\"101\":1,\"102\":6}}],[\"processor\",{\"1\":{\"84\":3,\"86\":3}}],[\"processing\",{\"1\":{\"83\":1}}],[\"process\",{\"1\":{\"67\":1}}],[\"probabilities\",{\"1\":{\"49\":1}}],[\"probs\",{\"1\":{\"49\":5,\"82\":3,\"93\":6}}],[\"prob\",{\"1\":{\"41\":1,\"43\":1,\"47\":1,\"49\":1,\"50\":1,\"61\":1,\"62\":1}}],[\"product\",{\"1\":{\"32\":1,\"49\":1,\"76\":1}}],[\"pred\",{\"1\":{\"103\":5}}],[\"predicted\",{\"1\":{\"84\":6,\"86\":6}}],[\"predict\",{\"1\":{\"83\":1}}],[\"predictions\",{\"1\":{\"55\":2}}],[\"prediction\",{\"1\":{\"38\":1,\"55\":2,\"56\":4,\"87\":1}}],[\"present\",{\"1\":{\"93\":2}}],[\"pretrained\",{\"1\":{\"84\":4,\"86\":4}}],[\"pretrainedtokenizer\",{\"1\":{\"38\":1}}],[\"pre\",{\"1\":{\"80\":1,\"83\":1,\"103\":3,\"107\":2}}],[\"precomputed\",{\"1\":{\"49\":1}}],[\"prev\",{\"1\":{\"37\":1}}],[\"pyplot\",{\"1\":{\"86\":1}}],[\"py文件\",{\"1\":{\"37\":1}}],[\"python\",{\"1\":{\"37\":1,\"96\":1}}],[\"python=3\",{\"1\":{\"37\":1,\"64\":1}}],[\"pytorch版本\",{\"0\":{\"23\":1}}],[\"pytorch\",{\"1\":{\"6\":2,\"19\":2,\"37\":3,\"59\":1,\"96\":2,\"97\":2,\"107\":1}}],[\"py\",{\"1\":{\"14\":1,\"17\":1,\"37\":2,\"96\":1}}],[\"ported\",{\"1\":{\"107\":1}}],[\"portrait\",{\"1\":{\"82\":1}}],[\"portion\",{\"1\":{\"38\":1}}],[\"pos\",{\"1\":{\"61\":1,\"100\":5,\"103\":5}}],[\"positional\",{\"1\":{\"66\":1,\"100\":1}}],[\"positions\",{\"1\":{\"59\":7,\"60\":1,\"93\":1}}],[\"positions=none\",{\"1\":{\"59\":2}}],[\"position\",{\"1\":{\"13\":5,\"17\":2,\"41\":12,\"46\":2,\"47\":2,\"56\":2,\"59\":2,\"61\":2,\"62\":6,\"93\":9}}],[\"pooler\",{\"1\":{\"46\":2}}],[\"pooled\",{\"1\":{\"45\":4,\"46\":2,\"47\":4,\"55\":2,\"56\":2,\"58\":2,\"62\":4}}],[\"pool\",{\"1\":{\"45\":1}}],[\"pooling\",{\"1\":{\"13\":1,\"22\":5,\"24\":1,\"29\":7,\"32\":3}}],[\"pointcnn\",{\"1\":{\"29\":1}}],[\"pointcloud\",{\"1\":{\"13\":2}}],[\"pointfeat\",{\"1\":{\"26\":2}}],[\"points\",{\"1\":{\"13\":68,\"14\":7,\"17\":39,\"21\":2,\"24\":1}}],[\"point\",{\"1\":{\"10\":1,\"13\":7,\"17\":2,\"22\":1,\"24\":2,\"29\":2,\"31\":1}}],[\"pointnetdensecls\",{\"1\":{\"28\":3}}],[\"pointnetcls\",{\"1\":{\"27\":3}}],[\"pointnetfeat\",{\"1\":{\"26\":3,\"27\":4,\"28\":3}}],[\"pointnet网络模型结构图\",{\"1\":{\"23\":1}}],[\"pointnet后\",{\"1\":{\"14\":3}}],[\"pointnetsetabstractionmsg\",{\"1\":{\"17\":5}}],[\"pointnetsetabstraction\",{\"1\":{\"13\":3,\"14\":3,\"17\":1}}],[\"pointnet来提取局部区域中的特征\",{\"1\":{\"12\":1}}],[\"pointnet将局部区域编码为特征向量\",{\"1\":{\"9\":1}}],[\"pointnet++提出了密度自适应pointnet层\",{\"1\":{\"15\":1}}],[\"pointnet++应用pointnet递归地对输入集进行嵌套分区\",{\"1\":{\"7\":1}}],[\"pointnet++选择pointnet作为局部特征学习器\",{\"1\":{\"7\":1}}],[\"pointnet++在进行点集划分时\",{\"1\":{\"7\":1}}],[\"pointnet++的下一个任务是学习这些子集\",{\"1\":{\"7\":1}}],[\"pointnet++需要一种方法来有效地将点云分割成多个部分\",{\"1\":{\"7\":1}}],[\"pointnet++\",{\"1\":{\"7\":1,\"13\":3,\"14\":2,\"17\":2,\"29\":4}}],[\"pointnet\",{\"0\":{\"12\":1},\"1\":{\"6\":1,\"8\":1,\"9\":2,\"13\":2,\"17\":1,\"19\":2,\"20\":1,\"22\":4,\"24\":4,\"25\":2,\"26\":1,\"27\":1,\"28\":1,\"29\":26,\"32\":2}}],[\"pointnet2\",{\"1\":{\"6\":2,\"14\":1,\"17\":2}}],[\"pan\",{\"1\":{\"96\":1,\"107\":1}}],[\"past\",{\"1\":{\"93\":17}}],[\"pass\",{\"1\":{\"72\":1}}],[\"passed\",{\"1\":{\"38\":1}}],[\"page\",{\"1\":{\"82\":1}}],[\"paper\",{\"1\":{\"49\":1,\"107\":1}}],[\"para\",{\"1\":{\"107\":2}}],[\"param\",{\"1\":{\"96\":5,\"98\":6}}],[\"parameter\",{\"1\":{\"54\":1,\"81\":1,\"99\":1,\"100\":2,\"103\":2}}],[\"parameters\",{\"1\":{\"46\":1,\"107\":1}}],[\"partial\",{\"1\":{\"103\":1}}],[\"partitioning\",{\"1\":{\"7\":2}}],[\"parts\",{\"1\":{\"61\":1}}],[\"paris\",{\"1\":{\"60\":3}}],[\"pair是否match\",{\"1\":{\"93\":1}}],[\"pair\",{\"1\":{\"38\":2}}],[\"padding=\",{\"1\":{\"91\":1}}],[\"padding=true\",{\"1\":{\"84\":1,\"86\":1}}],[\"padding\",{\"1\":{\"38\":6,\"41\":1,\"46\":1,\"47\":1,\"66\":1,\"91\":1,\"93\":2}}],[\"pad\",{\"1\":{\"38\":3}}],[\"patch16\",{\"1\":{\"107\":6}}],[\"patch14\",{\"1\":{\"84\":2,\"86\":1}}],[\"patch\",{\"1\":{\"98\":12,\"99\":11,\"100\":5,\"103\":5,\"107\":1}}],[\"patchembed\",{\"1\":{\"98\":2}}],[\"patches\",{\"1\":{\"7\":1,\"98\":5,\"99\":6,\"100\":4,\"102\":11,\"103\":4,\"107\":1,\"108\":1}}],[\"path=val\",{\"1\":{\"97\":1}}],[\"path=train\",{\"1\":{\"97\":1}}],[\"path=prev\",{\"1\":{\"37\":1}}],[\"paths\",{\"1\":{\"84\":17,\"85\":6,\"86\":21}}],[\"path\",{\"1\":{\"84\":12,\"85\":2,\"86\":14,\"96\":30,\"97\":5,\"100\":1,\"101\":7,\"103\":2}}],[\"path$bert\",{\"1\":{\"37\":2}}],[\"02\",{\"1\":{\"99\":1,\"100\":2,\"103\":2}}],[\"02413\",{\"1\":{\"6\":1}}],[\"0+cu113\",{\"1\":{\"64\":1}}],[\"03\",{\"1\":{\"37\":1}}],[\"00593\",{\"1\":{\"19\":1}}],[\"0\",{\"0\":{\"96\":1},\"1\":{\"13\":12,\"14\":2,\"17\":14,\"24\":8,\"25\":1,\"26\":1,\"28\":1,\"37\":1,\"38\":29,\"41\":1,\"43\":1,\"45\":1,\"46\":2,\"49\":2,\"53\":1,\"59\":3,\"60\":1,\"61\":1,\"64\":1,\"71\":1,\"74\":1,\"76\":3,\"82\":1,\"84\":1,\"86\":1,\"91\":2,\"92\":2,\"93\":13,\"96\":2,\"97\":23,\"98\":3,\"99\":3,\"100\":3,\"101\":2,\"102\":3,\"103\":6}}],[\"04744\",{\"1\":{\"4\":1}}],[\"hybrid\",{\"1\":{\"106\":1}}],[\"h`和\",{\"1\":{\"98\":1}}],[\"hub\",{\"1\":{\"86\":1}}],[\"huggingface\",{\"1\":{\"86\":1}}],[\"horse\",{\"1\":{\"82\":1}}],[\"happy\",{\"1\":{\"102\":1}}],[\"ha=\",{\"1\":{\"96\":1}}],[\"harvardnlp\",{\"1\":{\"64\":1}}],[\"has\",{\"1\":{\"38\":2,\"93\":3,\"107\":3}}],[\"height\",{\"1\":{\"96\":1}}],[\"here\",{\"1\":{\"47\":1}}],[\"head结构由linear+tanh激活函数+linear组成\",{\"1\":{\"103\":1}}],[\"head进行分类\",{\"1\":{\"103\":1}}],[\"head的位置是和这个\",{\"1\":{\"99\":1}}],[\"head之中再输出分类结果\",{\"1\":{\"99\":1}}],[\"heads代表transformer中multi\",{\"1\":{\"104\":1}}],[\"heads=8\",{\"1\":{\"102\":1}}],[\"heads=num\",{\"1\":{\"101\":1,\"103\":1}}],[\"heads=12\",{\"1\":{\"100\":1,\"103\":1,\"107\":1}}],[\"heads\",{\"1\":{\"49\":7,\"76\":3,\"93\":1,\"101\":2,\"102\":12,\"103\":1}}],[\"head\",{\"0\":{\"103\":1},\"1\":{\"44\":2,\"46\":1,\"47\":2,\"49\":10,\"56\":2,\"59\":1,\"61\":2,\"62\":2,\"66\":1,\"93\":10,\"99\":1,\"100\":1,\"101\":1,\"102\":8,\"103\":3,\"104\":1,\"107\":1}}],[\"hezhu\",{\"1\":{\"4\":1}}],[\"hidden\",{\"1\":{\"41\":5,\"43\":24,\"44\":5,\"45\":5,\"47\":4,\"49\":8,\"50\":12,\"53\":15,\"54\":7,\"55\":1,\"56\":1,\"58\":6,\"59\":2,\"61\":3,\"62\":4,\"91\":8,\"92\":7,\"93\":26,\"101\":9,\"104\":1}}],[\"h\",{\"1\":{\"22\":5,\"37\":3,\"76\":9,\"81\":1,\"91\":1,\"93\":4,\"98\":4,\"99\":1,\"100\":1,\"103\":1}}],[\"https\",{\"1\":{\"4\":2,\"6\":3,\"19\":3,\"37\":2,\"64\":1,\"88\":2,\"96\":2,\"107\":4}}],[\"论文里也做了说明\",{\"1\":{\"104\":1}}],[\"论文里没有做解释\",{\"1\":{\"101\":1}}],[\"论文作者也对其做了实验\",{\"1\":{\"100\":1}}],[\"论文还实验了使用80个不同的prompt进行集成\",{\"1\":{\"83\":1}}],[\"论文指出\",{\"1\":{\"83\":1}}],[\"论文发现这个模型的效果最佳\",{\"1\":{\"81\":1}}],[\"论文中进行对比实验的clip模型也采用了这一配置\",{\"1\":{\"81\":1}}],[\"论文中做了\",{\"1\":{\"29\":1}}],[\"论文中的验证\",{\"1\":{\"29\":1}}],[\"论文\",{\"1\":{\"4\":1,\"6\":1,\"19\":1,\"88\":1}}],[\"论文代码解读与复现\",{\"1\":{\"4\":1}}],[\"aggregate\",{\"1\":{\"92\":2}}],[\"axis\",{\"1\":{\"85\":1,\"86\":1}}],[\"axis=0\",{\"1\":{\"81\":1}}],[\"axis=1\",{\"1\":{\"81\":3,\"84\":3,\"86\":3}}],[\"across\",{\"1\":{\"92\":2}}],[\"accu\",{\"1\":{\"103\":1}}],[\"accuracy\",{\"1\":{\"84\":8,\"86\":6}}],[\"acc\",{\"1\":{\"84\":2,\"86\":2}}],[\"actual\",{\"1\":{\"84\":2,\"86\":2}}],[\"actually\",{\"1\":{\"49\":1}}],[\"active\",{\"1\":{\"61\":8}}],[\"activation\",{\"1\":{\"45\":2}}],[\"activate\",{\"1\":{\"37\":1,\"64\":1}}],[\"act2fn\",{\"1\":{\"43\":1,\"53\":1}}],[\"act\",{\"1\":{\"43\":7,\"53\":7,\"100\":1,\"101\":6,\"103\":5}}],[\"available\",{\"1\":{\"84\":1,\"86\":1}}],[\"average\",{\"1\":{\"22\":1,\"32\":1}}],[\"at\",{\"1\":{\"82\":1,\"93\":1}}],[\"atts\",{\"1\":{\"91\":2,\"93\":11}}],[\"attn\",{\"1\":{\"71\":4,\"74\":10,\"76\":7,\"93\":2,\"100\":1,\"101\":4,\"102\":10,\"103\":2}}],[\"attenion\",{\"1\":{\"70\":1}}],[\"attend\",{\"1\":{\"49\":1,\"65\":1}}],[\"attention的heads数\",{\"1\":{\"104\":1}}],[\"attention=false\",{\"1\":{\"93\":1}}],[\"attention=self\",{\"1\":{\"93\":1}}],[\"attention计算\",{\"1\":{\"93\":1}}],[\"attention模块\",{\"1\":{\"91\":1}}],[\"attention可以用矩阵乘法一次计算所有的时刻\",{\"1\":{\"65\":1}}],[\"attention机制\",{\"1\":{\"65\":1}}],[\"attentions=output\",{\"1\":{\"93\":2}}],[\"attentions=false\",{\"1\":{\"93\":3}}],[\"attentions\",{\"1\":{\"47\":1,\"49\":2,\"56\":1,\"62\":1,\"93\":6}}],[\"attention\",{\"1\":{\"29\":3,\"32\":1,\"38\":6,\"40\":4,\"43\":7,\"44\":2,\"46\":8,\"47\":3,\"49\":26,\"51\":4,\"56\":2,\"58\":1,\"59\":2,\"61\":4,\"62\":6,\"66\":2,\"76\":4,\"91\":3,\"92\":3,\"93\":79,\"101\":2,\"102\":2}}],[\"american\",{\"1\":{\"82\":1}}],[\"among\",{\"1\":{\"21\":1}}],[\"about\",{\"1\":{\"82\":1}}],[\"absolute\",{\"1\":{\"93\":1}}],[\"abstraction\",{\"1\":{\"8\":1,\"9\":2,\"14\":1,\"18\":1}}],[\"abs\",{\"1\":{\"4\":1,\"6\":1,\"19\":1,\"88\":1,\"107\":1}}],[\"annotated\",{\"1\":{\"64\":5}}],[\"answer\",{\"1\":{\"60\":3}}],[\"an\",{\"1\":{\"54\":1,\"82\":1}}],[\"and\",{\"1\":{\"4\":1,\"13\":8,\"38\":1,\"43\":1,\"47\":1,\"49\":1,\"53\":1,\"56\":1,\"58\":1,\"59\":1,\"67\":2,\"72\":1,\"74\":1,\"76\":2,\"82\":1,\"83\":1,\"93\":2,\"101\":1,\"107\":1}}],[\"applied\",{\"1\":{\"76\":1}}],[\"apply\",{\"1\":{\"49\":1,\"76\":2,\"93\":3,\"103\":1}}],[\"append\",{\"1\":{\"13\":2,\"17\":5,\"38\":1,\"84\":3,\"86\":3,\"93\":3,\"96\":5}}],[\"add\",{\"1\":{\"47\":1,\"93\":4}}],[\"astronaut\",{\"1\":{\"82\":1}}],[\"astype\",{\"1\":{\"24\":1}}],[\"assume\",{\"1\":{\"76\":1}}],[\"assert\",{\"1\":{\"76\":1,\"96\":1}}],[\"as\",{\"1\":{\"41\":1,\"54\":1,\"84\":2,\"85\":1,\"86\":5,\"96\":2,\"101\":1,\"102\":1}}],[\"align=\",{\"1\":{\"96\":1}}],[\"aligned\",{\"1\":{\"81\":2}}],[\"alexnet\",{\"1\":{\"84\":1}}],[\"always\",{\"1\":{\"76\":1}}],[\"already\",{\"1\":{\"38\":1}}],[\"all=false\",{\"1\":{\"14\":2}}],[\"all=true\",{\"1\":{\"13\":1,\"14\":1}}],[\"all流程图\",{\"1\":{\"13\":1}}],[\"all\",{\"1\":{\"13\":8,\"38\":5,\"40\":16,\"49\":6,\"76\":3,\"84\":3,\"85\":1,\"86\":3,\"92\":2,\"93\":13}}],[\"a^t||\",{\"1\":{\"22\":1}}],[\"a\",{\"1\":{\"22\":1,\"37\":3,\"38\":4,\"49\":1,\"62\":1,\"72\":1,\"76\":2,\"82\":16,\"83\":3,\"84\":1,\"85\":2,\"86\":3,\"89\":2}}],[\"argmax\",{\"1\":{\"58\":2,\"84\":1,\"85\":1,\"86\":2}}],[\"args\",{\"1\":{\"40\":1,\"99\":1,\"107\":1}}],[\"are\",{\"1\":{\"47\":2,\"54\":1,\"59\":1}}],[\"array\",{\"1\":{\"24\":1,\"84\":2,\"86\":2}}],[\"arange\",{\"1\":{\"13\":3,\"41\":1,\"81\":1,\"92\":1,\"93\":1}}],[\"arxiv\",{\"1\":{\"4\":1,\"6\":1,\"19\":1,\"88\":1,\"107\":1}}],[\"affordance\",{\"1\":{\"4\":1}}],[\"v0\",{\"1\":{\"107\":1}}],[\"v计算来源相同\",{\"1\":{\"102\":1}}],[\"v矩阵\",{\"1\":{\"102\":1}}],[\"v时使用偏置\",{\"1\":{\"102\":1}}],[\"vgg进行实现\",{\"1\":{\"84\":1}}],[\"vec2\",{\"1\":{\"84\":5,\"86\":5}}],[\"vec1\",{\"1\":{\"84\":5,\"86\":5}}],[\"vectors\",{\"1\":{\"76\":1}}],[\"version\",{\"1\":{\"43\":1,\"53\":1}}],[\"v\",{\"1\":{\"76\":2,\"91\":1,\"93\":2,\"96\":4,\"102\":4}}],[\"vocab是词典大小\",{\"1\":{\"68\":1}}],[\"vocab\",{\"1\":{\"41\":2,\"54\":2,\"56\":1,\"68\":2}}],[\"voxnet\",{\"1\":{\"29\":1}}],[\"voxel\",{\"1\":{\"20\":1,\"31\":1}}],[\"vs\",{\"1\":{\"28\":1,\"29\":2,\"60\":1}}],[\"validation\",{\"1\":{\"96\":1}}],[\"val\",{\"1\":{\"96\":13,\"97\":7}}],[\"valueerror\",{\"1\":{\"96\":1}}],[\"value=self\",{\"1\":{\"93\":1}}],[\"value=none\",{\"1\":{\"93\":3}}],[\"value\",{\"1\":{\"49\":6,\"76\":7,\"93\":23}}],[\"values\",{\"1\":{\"13\":1,\"24\":1,\"26\":1,\"93\":4}}],[\"variable\",{\"1\":{\"24\":1}}],[\"virtex\",{\"1\":{\"87\":1}}],[\"vit核心\",{\"1\":{\"108\":1}}],[\"vitjx\",{\"1\":{\"107\":1}}],[\"vit这篇论文长达二十多页\",{\"1\":{\"105\":1}}],[\"vit才会慢慢超越resnet\",{\"1\":{\"104\":1}}],[\"vit的效果表现不如resnet\",{\"1\":{\"104\":1}}],[\"vit的表现通常比同等大小的resnets要差一些\",{\"1\":{\"94\":1}}],[\"vit的表现就会超过cnn\",{\"1\":{\"94\":1}}],[\"vit仍是采用transformer中用到layer\",{\"1\":{\"101\":1}}],[\"vit虽然采用的是transformer\",{\"1\":{\"101\":1}}],[\"vit中的多头自注意力模块实现逻辑和transformer基本一致\",{\"1\":{\"102\":1}}],[\"vit中\",{\"1\":{\"100\":1}}],[\"vit原论文中最核心的结论是\",{\"1\":{\"94\":1}}],[\"vit\",{\"1\":{\"79\":2,\"81\":2,\"84\":4,\"86\":1,\"91\":1,\"97\":3,\"103\":1,\"107\":6}}],[\"view\",{\"1\":{\"13\":11,\"14\":1,\"17\":2,\"20\":1,\"24\":3,\"26\":2,\"28\":2,\"31\":1,\"47\":4,\"49\":3,\"56\":4,\"61\":5,\"62\":6,\"76\":3,\"93\":2}}],[\"visiontransformer\",{\"1\":{\"99\":2,\"100\":2,\"103\":2,\"107\":1}}],[\"vision\",{\"0\":{\"5\":1},\"1\":{\"79\":1,\"81\":1,\"84\":1,\"91\":2,\"94\":3,\"101\":1,\"107\":2,\"108\":1}}],[\"visual\",{\"1\":{\"4\":1,\"87\":2,\"91\":1}}],[\"vl\",{\"1\":{\"2\":1,\"93\":4}}],[\"optimizer\",{\"1\":{\"103\":1}}],[\"opening\",{\"1\":{\"85\":1,\"86\":1}}],[\"open\",{\"1\":{\"84\":1,\"85\":1,\"86\":2,\"96\":2}}],[\"openai首先尝试了virtex模型\",{\"1\":{\"87\":1}}],[\"openai从网络上收集了4亿条数据进行实验\",{\"1\":{\"87\":1}}],[\"openai从网络上收集了总计4亿对文本和图像\",{\"1\":{\"81\":1}}],[\"openai\",{\"1\":{\"79\":1,\"84\":2,\"86\":1}}],[\"os\",{\"1\":{\"84\":11,\"85\":2,\"86\":14,\"96\":8}}],[\"our\",{\"1\":{\"59\":1}}],[\"outside\",{\"1\":{\"59\":1}}],[\"outputs\",{\"1\":{\"37\":1,\"46\":2,\"47\":7,\"51\":2,\"56\":6,\"58\":4,\"59\":8,\"61\":6,\"62\":6,\"93\":24}}],[\"output\",{\"1\":{\"37\":3,\"43\":9,\"45\":4,\"46\":7,\"47\":4,\"49\":2,\"51\":4,\"54\":2,\"55\":4,\"56\":4,\"58\":5,\"59\":2,\"61\":4,\"62\":4,\"91\":5,\"93\":51}}],[\"out\",{\"1\":{\"13\":7,\"17\":4,\"49\":1,\"101\":5}}],[\"one\",{\"1\":{\"103\":1}}],[\"ones\",{\"1\":{\"13\":1,\"91\":1,\"93\":3}}],[\"on\",{\"1\":{\"76\":1,\"82\":3}}],[\"only\",{\"1\":{\"38\":1,\"54\":1,\"60\":2,\"61\":1}}],[\"overwrite\",{\"1\":{\"37\":1}}],[\"o\",{\"1\":{\"29\":2}}],[\"official\",{\"1\":{\"107\":1}}],[\"off\",{\"1\":{\"85\":1,\"86\":1}}],[\"of\",{\"1\":{\"13\":1,\"38\":1,\"60\":2,\"61\":1,\"72\":1,\"74\":1,\"76\":1,\"81\":4,\"82\":6,\"83\":3,\"84\":2,\"85\":1,\"86\":2,\"87\":3,\"96\":1}}],[\"ordereddict\",{\"1\":{\"103\":1}}],[\"original\",{\"1\":{\"49\":1,\"107\":1}}],[\"orthogonal\",{\"1\":{\"25\":1}}],[\"or\",{\"1\":{\"21\":1,\"37\":1,\"43\":1,\"53\":1,\"81\":2,\"101\":2,\"102\":1,\"103\":2}}],[\"org\",{\"1\":{\"4\":1,\"6\":1,\"19\":1,\"88\":1,\"107\":1}}],[\"oracle\",{\"0\":{\"2\":1},\"1\":{\"0\":1}}],[\"observations\",{\"1\":{\"4\":1}}],[\"object\",{\"1\":{\"4\":1}}],[\"garage\",{\"1\":{\"82\":1}}],[\"gelu\",{\"1\":{\"101\":4,\"103\":2}}],[\"generation能力\",{\"1\":{\"89\":1}}],[\"generator模型结构图\",{\"1\":{\"68\":1}}],[\"generator\",{\"0\":{\"68\":1},\"1\":{\"67\":3,\"68\":2}}],[\"generic\",{\"1\":{\"75\":1}}],[\"getitem\",{\"1\":{\"96\":1}}],[\"getcwd\",{\"1\":{\"84\":1,\"86\":1}}],[\"get\",{\"1\":{\"14\":2,\"17\":2,\"38\":1,\"49\":1,\"84\":10,\"85\":4,\"86\":12}}],[\"gpt\",{\"1\":{\"60\":2}}],[\"gpu上训练12天\",{\"1\":{\"81\":1}}],[\"gpu上训练18天\",{\"1\":{\"81\":1}}],[\"gpu上的矩阵运算都是充分优化和高度并行的\",{\"1\":{\"65\":1}}],[\"gpu\",{\"1\":{\"29\":1,\"37\":2,\"65\":1}}],[\"gleu\",{\"1\":{\"43\":2}}],[\"global\",{\"1\":{\"24\":1,\"26\":8,\"27\":1,\"28\":1,\"29\":1}}],[\"guid\",{\"1\":{\"38\":1}}],[\"google\",{\"1\":{\"107\":2}}],[\"googleapis\",{\"1\":{\"37\":1}}],[\"golang\",{\"1\":{\"2\":1}}],[\"git\",{\"1\":{\"37\":2,\"64\":1}}],[\"github\",{\"1\":{\"4\":1,\"6\":2,\"19\":2,\"37\":1,\"64\":1,\"88\":1,\"96\":1,\"107\":2}}],[\"g\",{\"1\":{\"22\":1}}],[\"grams\",{\"1\":{\"87\":2}}],[\"grad\",{\"1\":{\"82\":2,\"84\":2,\"86\":2,\"93\":1,\"107\":1}}],[\"grids\",{\"1\":{\"31\":1}}],[\"grid\",{\"1\":{\"20\":1,\"98\":3}}],[\"group流程图\",{\"1\":{\"13\":1}}],[\"grouped\",{\"1\":{\"13\":12,\"17\":13}}],[\"group\",{\"1\":{\"13\":23,\"14\":3,\"17\":3}}],[\"grouping\",{\"0\":{\"11\":1,\"16\":1,\"18\":1},\"1\":{\"8\":1,\"9\":2,\"11\":1,\"14\":4,\"15\":2}}],[\"grounding\",{\"1\":{\"4\":1}}],[\"l为灰度图片\",{\"1\":{\"96\":1}}],[\"ln\",{\"1\":{\"91\":1}}],[\"lm\",{\"1\":{\"56\":5}}],[\"lmaffordance3d\",{\"0\":{\"4\":1},\"1\":{\"4\":1}}],[\"l\",{\"1\":{\"22\":1,\"37\":3,\"81\":5,\"84\":1}}],[\"l3\",{\"1\":{\"14\":4,\"17\":4}}],[\"l2\",{\"1\":{\"14\":4,\"17\":4,\"81\":2}}],[\"l1\",{\"1\":{\"14\":4,\"17\":4}}],[\"linalg\",{\"1\":{\"84\":2,\"86\":2}}],[\"lin\",{\"1\":{\"76\":2}}],[\"linears\",{\"1\":{\"76\":3}}],[\"linear\",{\"1\":{\"14\":3,\"17\":3,\"24\":3,\"27\":3,\"43\":2,\"45\":1,\"47\":1,\"49\":3,\"50\":1,\"53\":1,\"54\":1,\"55\":1,\"58\":1,\"59\":1,\"61\":1,\"62\":1,\"68\":1,\"76\":3,\"101\":2,\"102\":2,\"103\":2}}],[\"like\",{\"0\":{\"92\":1},\"1\":{\"41\":1}}],[\"listdir\",{\"1\":{\"84\":1,\"86\":1,\"96\":2}}],[\"list列表组装起来得到需要的dataset\",{\"1\":{\"38\":1}}],[\"list\",{\"1\":{\"13\":2,\"17\":15,\"96\":2}}],[\"left\",{\"1\":{\"71\":1}}],[\"learnable\",{\"1\":{\"100\":1}}],[\"learned\",{\"1\":{\"81\":3,\"91\":2}}],[\"learner\",{\"1\":{\"7\":2}}],[\"learning的核心思想是通过设计合适的prompt\",{\"1\":{\"83\":1}}],[\"learning或prompt\",{\"1\":{\"83\":1}}],[\"learning\",{\"0\":{\"91\":1,\"92\":1},\"1\":{\"37\":1,\"87\":2,\"91\":1}}],[\"level\",{\"1\":{\"18\":1}}],[\"len维度上拼接起来\",{\"1\":{\"93\":2}}],[\"len和hidden\",{\"1\":{\"91\":1}}],[\"lens\",{\"1\":{\"38\":1,\"40\":2}}],[\"len=input\",{\"1\":{\"38\":1}}],[\"length=0\",{\"1\":{\"93\":2}}],[\"length=self\",{\"1\":{\"91\":1}}],[\"length=128\",{\"1\":{\"37\":1}}],[\"length长度\",{\"1\":{\"38\":1}}],[\"length\",{\"1\":{\"38\":11,\"40\":1,\"41\":2,\"58\":4,\"62\":4,\"91\":1,\"93\":9}}],[\"len\",{\"1\":{\"13\":1,\"17\":2,\"38\":13,\"40\":5,\"49\":2,\"59\":4,\"61\":2,\"76\":1,\"84\":1,\"86\":1,\"91\":7,\"92\":5,\"93\":17,\"96\":8}}],[\"lavis\",{\"1\":{\"88\":1}}],[\"large\",{\"1\":{\"84\":2,\"86\":1,\"87\":1}}],[\"launchpad\",{\"1\":{\"82\":1}}],[\"lambda\",{\"1\":{\"71\":1,\"74\":2}}],[\"label=none\",{\"1\":{\"56\":1}}],[\"label=label\",{\"1\":{\"38\":1}}],[\"labels=none\",{\"1\":{\"47\":1,\"56\":1,\"61\":1,\"62\":1}}],[\"labels\",{\"1\":{\"38\":1,\"40\":2,\"47\":8,\"56\":2,\"59\":3,\"61\":11,\"62\":2,\"81\":3,\"82\":1,\"93\":2,\"96\":4,\"103\":3}}],[\"label\",{\"1\":{\"38\":2,\"56\":2,\"82\":1,\"83\":2,\"92\":2,\"96\":8,\"97\":4}}],[\"last\",{\"1\":{\"13\":3,\"17\":3,\"91\":2,\"93\":1}}],[\"layer=act\",{\"1\":{\"101\":1,\"103\":1}}],[\"layer=norm\",{\"1\":{\"103\":1}}],[\"layer=none\",{\"1\":{\"98\":1,\"99\":1,\"100\":3,\"103\":3}}],[\"layer=nn\",{\"1\":{\"101\":3}}],[\"layernorm\",{\"1\":{\"41\":2,\"43\":2,\"50\":2,\"53\":2,\"70\":2,\"72\":1,\"75\":1,\"93\":1,\"101\":1,\"103\":2}}],[\"layer的任务是通过中心点找到邻居点\",{\"1\":{\"11\":1}}],[\"layers\",{\"1\":{\"9\":1,\"44\":1,\"49\":1,\"72\":3,\"75\":2}}],[\"layers组成\",{\"1\":{\"9\":1}}],[\"layers主要包括3个部分\",{\"1\":{\"8\":1}}],[\"layer\",{\"0\":{\"10\":1,\"11\":1,\"12\":1},\"1\":{\"8\":3,\"9\":6,\"41\":1,\"43\":3,\"44\":4,\"49\":21,\"50\":1,\"53\":1,\"66\":1,\"72\":6,\"75\":6,\"93\":42,\"98\":3,\"99\":2,\"100\":1,\"101\":4,\"103\":8}}],[\"language生成学习\",{\"1\":{\"90\":1}}],[\"language表征学习\",{\"1\":{\"90\":1}}],[\"language\",{\"0\":{\"5\":1},\"1\":{\"4\":1,\"80\":1,\"83\":1,\"87\":1}}],[\"location=device\",{\"1\":{\"107\":1}}],[\"locality\",{\"1\":{\"94\":1}}],[\"local\",{\"1\":{\"7\":3,\"13\":2,\"40\":1,\"84\":2,\"86\":2}}],[\"load\",{\"1\":{\"107\":2}}],[\"loader\",{\"1\":{\"97\":2,\"103\":2}}],[\"loading\",{\"1\":{\"84\":1,\"86\":1}}],[\"loal\",{\"1\":{\"7\":1}}],[\"looking\",{\"1\":{\"82\":1}}],[\"lower\",{\"1\":{\"37\":1,\"84\":1,\"86\":1}}],[\"loss\",{\"0\":{\"92\":1,\"93\":1},\"1\":{\"25\":2,\"47\":8,\"56\":10,\"59\":10,\"61\":11,\"62\":5,\"81\":8,\"92\":2,\"93\":1,\"103\":3}}],[\"logits外\",{\"1\":{\"107\":1}}],[\"logits=false\",{\"1\":{\"107\":1}}],[\"logits\",{\"1\":{\"47\":5,\"58\":12,\"59\":15,\"61\":6,\"62\":6,\"81\":3,\"93\":2,\"103\":3,\"107\":3}}],[\"logging\",{\"1\":{\"37\":1}}],[\"log\",{\"1\":{\"14\":1,\"17\":1,\"27\":2,\"28\":3,\"68\":1}}],[\"long\",{\"1\":{\"13\":5,\"41\":1,\"91\":1,\"93\":4}}],[\"llm\",{\"1\":{\"3\":1,\"89\":1}}],[\"现就读于电子科技大学\",{\"1\":{\"3\":1}}],[\"现就读于四川大学\",{\"1\":{\"2\":1}}],[\"领域常用的文本transformer模型\",{\"1\":{\"81\":1}}],[\"领域中的一些对比学习方法\",{\"1\":{\"80\":1}}],[\"领域\",{\"1\":{\"3\":1}}],[\"转换为元组形式\",{\"1\":{\"98\":1}}],[\"转换为一系列高维向量表示\",{\"1\":{\"66\":1}}],[\"转化成功之后\",{\"1\":{\"37\":1}}],[\"转\",{\"1\":{\"3\":1}}],[\"转型\",{\"1\":{\"2\":1}}],[\"c为输入token的总维度\",{\"1\":{\"102\":1}}],[\"c=in\",{\"1\":{\"99\":1,\"100\":1,\"103\":1}}],[\"c=3\",{\"1\":{\"98\":1,\"99\":1,\"100\":1,\"103\":1}}],[\"centercrop\",{\"1\":{\"97\":1}}],[\"center\",{\"1\":{\"96\":2}}],[\"centroid\",{\"1\":{\"13\":2}}],[\"centroids\",{\"1\":{\"13\":4}}],[\"current\",{\"1\":{\"84\":2,\"85\":1,\"86\":3}}],[\"cup\",{\"1\":{\"82\":1}}],[\"cuda\",{\"1\":{\"24\":2,\"25\":2,\"82\":2,\"84\":2,\"86\":2}}],[\"cbow\",{\"1\":{\"81\":1}}],[\"cpu\",{\"1\":{\"65\":1,\"82\":3,\"84\":3,\"86\":3}}],[\"cannot\",{\"1\":{\"102\":1}}],[\"candidates\",{\"1\":{\"84\":13,\"86\":10}}],[\"casual\",{\"1\":{\"102\":1}}],[\"case\",{\"1\":{\"37\":1}}],[\"cached\",{\"1\":{\"93\":1}}],[\"cache=true\",{\"1\":{\"91\":1}}],[\"caption\",{\"1\":{\"87\":1}}],[\"capital\",{\"1\":{\"60\":2}}],[\"camera\",{\"1\":{\"82\":1}}],[\"category\",{\"1\":{\"84\":4,\"86\":4}}],[\"cat\",{\"1\":{\"13\":2,\"17\":2,\"26\":1,\"82\":1,\"93\":9,\"99\":1,\"100\":1,\"103\":1}}],[\"ckpt\",{\"1\":{\"37\":1}}],[\"crossattention\",{\"1\":{\"93\":2}}],[\"cross\",{\"1\":{\"81\":2,\"92\":2,\"93\":16}}],[\"crossentropyloss\",{\"1\":{\"47\":1,\"56\":1,\"59\":1,\"61\":1,\"62\":1}}],[\"creates\",{\"1\":{\"38\":1}}],[\"create\",{\"1\":{\"37\":1,\"38\":1,\"64\":1}}],[\"critical\",{\"1\":{\"22\":1,\"29\":2}}],[\"cd\",{\"1\":{\"37\":1,\"64\":1}}],[\"chunk\",{\"1\":{\"93\":8}}],[\"chunking\",{\"1\":{\"29\":1,\"93\":3}}],[\"choices\",{\"1\":{\"62\":9}}],[\"choice\",{\"1\":{\"62\":1}}],[\"checkpoint\",{\"1\":{\"37\":2}}],[\"chinesegluedatasets\",{\"1\":{\"37\":2}}],[\"chinese\",{\"1\":{\"37\":5}}],[\"channels\",{\"1\":{\"96\":1}}],[\"channel=256\",{\"1\":{\"14\":1}}],[\"channel=128\",{\"1\":{\"14\":1}}],[\"channel=in\",{\"1\":{\"14\":1}}],[\"channel=true\",{\"1\":{\"14\":1,\"17\":1}}],[\"channel\",{\"1\":{\"13\":12,\"14\":7,\"17\":15}}],[\"charlesq34\",{\"1\":{\"6\":1,\"19\":1}}],[\"cs\",{\"1\":{\"22\":2}}],[\"csdn\",{\"1\":{\"0\":1}}],[\"clipprocessor\",{\"1\":{\"84\":1,\"86\":2}}],[\"clipmodel\",{\"1\":{\"84\":1,\"86\":2}}],[\"clip模型均能够以较高的置信度给出正确的分类结果\",{\"1\":{\"82\":1}}],[\"clip模型能够在没有特定任务训练数据的情况下\",{\"1\":{\"82\":1}}],[\"clip模型的一个显著优势是它能够进行zero\",{\"1\":{\"82\":1}}],[\"clip模型会预测出个可能的文本\",{\"1\":{\"81\":1}}],[\"clip包含两个核心模型\",{\"1\":{\"81\":1}}],[\"clip的训练数据采用的是文本\",{\"1\":{\"80\":1}}],[\"clip的英文全称为contrastive\",{\"1\":{\"80\":1}}],[\"clip属于基于对比学习的多模态模型\",{\"1\":{\"80\":1}}],[\"clip\",{\"0\":{\"92\":1},\"1\":{\"79\":3,\"82\":1,\"84\":3,\"86\":1,\"87\":1}}],[\"clip原始论文链接\",{\"1\":{\"78\":1}}],[\"cla\",{\"1\":{\"96\":9}}],[\"clamp\",{\"1\":{\"59\":4}}],[\"classes=5\",{\"1\":{\"107\":1}}],[\"classes=num\",{\"1\":{\"107\":1}}],[\"classes=1000\",{\"1\":{\"99\":1,\"100\":1,\"103\":1}}],[\"classes\",{\"1\":{\"99\":3,\"100\":2,\"103\":6,\"107\":2}}],[\"class=val\",{\"1\":{\"97\":1}}],[\"class=train\",{\"1\":{\"97\":1}}],[\"classification\",{\"1\":{\"38\":1}}],[\"classifier\",{\"1\":{\"37\":2,\"47\":2,\"61\":2,\"62\":2}}],[\"class\",{\"0\":{\"99\":1},\"1\":{\"13\":1,\"14\":4,\"17\":4,\"24\":1,\"26\":1,\"27\":1,\"28\":1,\"41\":1,\"43\":3,\"44\":1,\"45\":1,\"46\":1,\"47\":1,\"49\":1,\"50\":1,\"51\":1,\"53\":1,\"54\":1,\"55\":1,\"56\":1,\"59\":1,\"61\":1,\"62\":1,\"67\":1,\"68\":1,\"70\":1,\"71\":1,\"72\":1,\"74\":1,\"75\":1,\"76\":1,\"91\":1,\"93\":4,\"96\":27,\"98\":1,\"99\":3,\"100\":1,\"101\":2,\"102\":1,\"103\":1}}],[\"clones\",{\"1\":{\"71\":1,\"72\":1,\"74\":1,\"75\":1,\"76\":1}}],[\"clone\",{\"1\":{\"37\":1,\"64\":1,\"93\":1}}],[\"cloud\",{\"1\":{\"31\":1}}],[\"cls\",{\"1\":{\"14\":1,\"17\":2,\"38\":9,\"45\":1,\"56\":3,\"58\":2,\"60\":2,\"62\":1,\"99\":22,\"100\":5,\"103\":5}}],[\"c+d\",{\"1\":{\"13\":3}}],[\"c\",{\"1\":{\"13\":14,\"17\":5,\"62\":1,\"81\":1,\"89\":2,\"91\":1,\"98\":6,\"99\":3,\"100\":2,\"102\":3,\"103\":2}}],[\"count\",{\"1\":{\"84\":7,\"86\":7}}],[\"coffee\",{\"1\":{\"82\":1}}],[\"cosine\",{\"1\":{\"81\":1,\"84\":2,\"85\":1,\"86\":3}}],[\"correct\",{\"1\":{\"84\":3,\"86\":3}}],[\"corresponding\",{\"1\":{\"45\":1}}],[\"core\",{\"1\":{\"72\":1}}],[\"collate可以参考\",{\"1\":{\"96\":1}}],[\"collate\",{\"1\":{\"40\":2,\"96\":3,\"97\":4}}],[\"code\",{\"1\":{\"37\":7}}],[\"connections\",{\"1\":{\"71\":1,\"74\":1}}],[\"connection\",{\"1\":{\"66\":1}}],[\"config\",{\"1\":{\"37\":2,\"41\":9,\"43\":16,\"44\":3,\"45\":3,\"46\":5,\"47\":7,\"49\":9,\"50\":5,\"51\":3,\"53\":8,\"54\":5,\"55\":3,\"56\":5,\"58\":1,\"59\":6,\"61\":7,\"62\":5,\"93\":13}}],[\"conda\",{\"1\":{\"37\":2,\"64\":2}}],[\"contrastive\",{\"0\":{\"92\":1},\"1\":{\"87\":1,\"92\":1}}],[\"contiguous\",{\"1\":{\"28\":1,\"49\":1,\"76\":1,\"93\":1}}],[\"contextualized\",{\"1\":{\"60\":1}}],[\"contextual\",{\"1\":{\"60\":1}}],[\"context\",{\"1\":{\"7\":2,\"45\":1,\"49\":9,\"58\":1,\"93\":13}}],[\"concat\",{\"1\":{\"13\":1,\"17\":3,\"76\":1}}],[\"convirt基于对比学习的方法\",{\"1\":{\"87\":1}}],[\"convert\",{\"1\":{\"37\":1,\"84\":1,\"86\":1}}],[\"conv4\",{\"1\":{\"28\":2}}],[\"conv3\",{\"1\":{\"24\":2,\"26\":2,\"28\":2}}],[\"conv2\",{\"1\":{\"24\":2,\"26\":2,\"28\":2}}],[\"conv2d\",{\"1\":{\"13\":2,\"17\":3,\"98\":1}}],[\"conv1d\",{\"1\":{\"24\":3,\"26\":4,\"28\":5,\"29\":1}}],[\"conv1\",{\"1\":{\"24\":2,\"26\":2,\"28\":2}}],[\"conv\",{\"1\":{\"13\":2,\"17\":6}}],[\"convs\",{\"1\":{\"13\":3,\"17\":3}}],[\"come\",{\"1\":{\"93\":1}}],[\"compose\",{\"1\":{\"97\":2}}],[\"compute\",{\"1\":{\"76\":1}}],[\"compatibility\",{\"1\":{\"46\":1}}],[\"com\",{\"1\":{\"4\":1,\"6\":2,\"19\":2,\"37\":2,\"64\":1,\"88\":1,\"96\":2,\"107\":3}}],[\"committer\",{\"1\":{\"2\":2}}],[\"cnn具有两种归纳偏置\",{\"1\":{\"94\":1}}],[\"cnn\",{\"1\":{\"24\":1,\"29\":4,\"31\":3,\"81\":1,\"94\":1,\"106\":9,\"108\":1}}],[\"cn\",{\"1\":{\"4\":1}}],[\"cv\",{\"1\":{\"3\":1,\"80\":1}}],[\"知识星球\",{\"1\":{\"0\":1}}]],\"version\":2}}")).map(([e,t])=>[e,_t(t,{fields:["h","t","c"],storeFields:["h","t","c"]})]));self.onmessage=({data:{type:e="all",query:t,locale:n,options:o,id:s}})=>{const r=xt[n];e==="suggest"?self.postMessage([e,s,ve(t,r,o)]):e==="search"?self.postMessage([e,s,Ee(t,r,o,"max")]):self.postMessage({suggestions:[e,s,ve(t,r,o)],results:[e,s,Ee(t,r,o,__SLIMSEARCH_SORT_STRATEGY__)]})};
//# sourceMappingURL=index.js.map
